[
    {
        "title": "Lowest Common Ancestor of a Binary Search Tree",
        "question_content": "Given a binary search tree (BST), find the lowest common ancestor (LCA) node of two given nodes in the BST.\nAccording to the definition of LCA on Wikipedia: &ldquo;The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).&rdquo;\n&nbsp;\nExample 1:\n\nInput: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8\nOutput: 6\nExplanation: The LCA of nodes 2 and 8 is 6.\n\nExample 2:\n\nInput: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4\nOutput: 2\nExplanation: The LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition.\n\nExample 3:\n\nInput: root = [2,1], p = 2, q = 1\nOutput: 2\n\n&nbsp;\nConstraints:\n\n\tThe number of nodes in the tree is in the range [2, 105].\n\t-109 <= Node.val <= 109\n\tAll Node.val are unique.\n\tp != q\n\tp and q will exist in the BST.",
        "solutions": [
            {
                "id": 64963,
                "title": "3-lines-with-o-1-space-1-liners-alternatives",
                "content": "Just walk down from the whole tree's root as long as both p and q are in the same subtree (meaning their values are both smaller or both larger than root's). This walks straight from the root to the LCA, not looking at the rest of the tree, so it's pretty much as fast as it gets. A few ways to do it:\\n\\n**Iterative, O(1) space**\\n\\nPython\\n\\n    def lowestCommonAncestor(self, root, p, q):\\n        while (root.val - p.val) * (root.val - q.val) > 0:\\n            root = (root.left, root.right)[p.val > root.val]\\n        return root\\n\\nJava\\n\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        while ((root.val - p.val) * (root.val - q.val) > 0)\\n            root = p.val < root.val ? root.left : root.right;\\n        return root;\\n    }\\n\\n(in case of overflow, I'd do `(root.val - (long)p.val) * (root.val - (long)q.val)`)\\n\\nDifferent Python\\n\\n    def lowestCommonAncestor(self, root, p, q):\\n        a, b = sorted([p.val, q.val])\\n        while not a <= root.val <= b:\\n            root = (root.left, root.right)[a > root.val]\\n        return root\\n\\n\"Long\" Python, maybe easiest to understand\\n\\n    def lowestCommonAncestor(self, root, p, q):\\n        while root:\\n            if p.val < root.val > q.val:\\n                root = root.left\\n            elif p.val > root.val < q.val:\\n                root = root.right\\n            else:\\n                return root\\n\\n**Recursive**\\n\\nPython\\n\\n    def lowestCommonAncestor(self, root, p, q):\\n        next = p.val < root.val > q.val and root.left or \\\\\\n               p.val > root.val < q.val and root.right\\n        return self.lowestCommonAncestor(next, p, q) if next else root\\n\\nPython One-Liner\\n\\n    def lowestCommonAncestor(self, root, p, q):\\n        return root if (root.val - p.val) * (root.val - q.val) < 1 else \\\\\\n               self.lowestCommonAncestor((root.left, root.right)[p.val > root.val], p, q)\\n\\nJava One-Liner\\n\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        return (root.val - p.val) * (root.val - q.val) < 1 ? root :\\n               lowestCommonAncestor(p.val < root.val ? root.left : root.right, p, q);\\n    }\\n\\n\"Long\" Python, maybe easiest to understand\\n\\n    def lowestCommonAncestor(self, root, p, q):\\n        if p.val < root.val > q.val:\\n            return self.lowestCommonAncestor(root.left, p, q)\\n        if p.val > root.val < q.val:\\n            return self.lowestCommonAncestor(root.right, p, q)\\n        return root",
                "solutionTags": [],
                "code": "Just walk down from the whole tree's root as long as both p and q are in the same subtree (meaning their values are both smaller or both larger than root's). This walks straight from the root to the LCA, not looking at the rest of the tree, so it's pretty much as fast as it gets. A few ways to do it:\\n\\n**Iterative, O(1) space**\\n\\nPython\\n\\n    def lowestCommonAncestor(self, root, p, q):\\n        while (root.val - p.val) * (root.val - q.val) > 0:\\n            root = (root.left, root.right)[p.val > root.val]\\n        return root\\n\\nJava\\n\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        while ((root.val - p.val) * (root.val - q.val) > 0)\\n            root = p.val < root.val ? root.left : root.right;\\n        return root;\\n    }\\n\\n(in case of overflow, I'd do `(root.val - (long)p.val) * (root.val - (long)q.val)`)\\n\\nDifferent Python\\n\\n    def lowestCommonAncestor(self, root, p, q):\\n        a, b = sorted([p.val, q.val])\\n        while not a <= root.val <= b:\\n            root = (root.left, root.right)[a > root.val]\\n        return root\\n\\n\"Long\" Python, maybe easiest to understand\\n\\n    def lowestCommonAncestor(self, root, p, q):\\n        while root:\\n            if p.val < root.val > q.val:\\n                root = root.left\\n            elif p.val > root.val < q.val:\\n                root = root.right\\n            else:\\n                return root\\n\\n**Recursive**\\n\\nPython\\n\\n    def lowestCommonAncestor(self, root, p, q):\\n        next = p.val < root.val > q.val and root.left or \\\\\\n               p.val > root.val < q.val and root.right\\n        return self.lowestCommonAncestor(next, p, q) if next else root\\n\\nPython One-Liner\\n\\n    def lowestCommonAncestor(self, root, p, q):\\n        return root if (root.val - p.val) * (root.val - q.val) < 1 else \\\\\\n               self.lowestCommonAncestor((root.left, root.right)[p.val > root.val], p, q)\\n\\nJava One-Liner\\n\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        return (root.val - p.val) * (root.val - q.val) < 1 ? root :\\n               lowestCommonAncestor(p.val < root.val ? root.left : root.right, p, q);\\n    }\\n\\n\"Long\" Python, maybe easiest to understand\\n\\n    def lowestCommonAncestor(self, root, p, q):\\n        if p.val < root.val > q.val:\\n            return self.lowestCommonAncestor(root.left, p, q)\\n        if p.val > root.val < q.val:\\n            return self.lowestCommonAncestor(root.right, p, q)\\n        return root",
                "codeTag": "Python3"
            },
            {
                "id": 64980,
                "title": "c-recursive-and-iterative",
                "content": "Well, remember to take advantage of the property of binary search trees, which is, `node -> left -> val < node -> val < node -> right -> val`. Moreover, both `p` and `q` will be the descendants of the `root` of the subtree that contains both of them. And the `root` with the largest depth is just the lowest common ancestor. This idea can be turned into the following simple recursive code.\\n\\n```cpp\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if ((root -> val > p -> val) && (root -> val > q -> val)) {\\n            return lowestCommonAncestor(root -> left, p, q);\\n        }\\n        if ((root -> val < p -> val) && (root -> val < q -> val)) {\\n            return lowestCommonAncestor(root -> right, p, q);\\n        }\\n        return root;\\n    }\\n};\\n```\\n\\nOf course, we can also solve it iteratively.\\n\\n```cpp\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        TreeNode* cur = root;\\n        while (true) {\\n            if (p -> val < cur -> val && q -> val < cur -> val) {\\n                cur = cur -> left;\\n            } else if (p -> val > cur -> val && q -> val > cur -> val) {\\n                cur = cur -> right;\\n            } else {\\n                break;\\n            }\\n        }\\n        return cur;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion",
                    "Binary Tree",
                    "Iterator"
                ],
                "code": "```cpp\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if ((root -> val > p -> val) && (root -> val > q -> val)) {\\n            return lowestCommonAncestor(root -> left, p, q);\\n        }\\n        if ((root -> val < p -> val) && (root -> val < q -> val)) {\\n            return lowestCommonAncestor(root -> right, p, q);\\n        }\\n        return root;\\n    }\\n};\\n```\n```cpp\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        TreeNode* cur = root;\\n        while (true) {\\n            if (p -> val < cur -> val && q -> val < cur -> val) {\\n                cur = cur -> left;\\n            } else if (p -> val > cur -> val && q -> val > cur -> val) {\\n                cur = cur -> right;\\n            } else {\\n                break;\\n            }\\n        }\\n        return cur;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1347857,
                "title": "c-java-python-iterate-in-bst-picture-explain-time-o-h-space-o-1",
                "content": "**\\u2714\\uFE0F Solution 1: Iterate in BST**\\n- Let `large = max(p.val, q.val)`, `small = min(p.val, q.val)`.\\n- We keep iterate `root` in our BST:\\n\\t- If `root.val > large` then both node `p` and `q` belong to the left subtree, go to left by `root = root.left`.\\n\\t- If `root.val < small` then both node `p` and `q` belong to the right subtree, go to right by `root = root.right`.\\n\\t- Now, `small <= root.val <= large` the current `root` is the LCA between `q` and `p`.\\n\\n![image](https://assets.leetcode.com/users/images/c9441871-3cdd-49fa-b4f4-7ab1f88779f1_1626682525.9321432.png)\\n\\n<iframe src=\"https://leetcode.com/playground/QdSyKrz6/shared\" frameBorder=\"0\" width=\"100%\" height=\"350\"></iframe>\\n\\nComplexity:\\n- Time: `O(H)`, where `H` is the heigh of Binary Tree.\\n- Space: `O(1)`\\n\\n---\\n\\n**\\u2714\\uFE0F Solution 2: Find LCA of general Binary Tree**\\n- There are two other solutions, which take `O(N)` in Time Complexity to find the LCA between `p` and `q` in the general **Binary Tree**, please check out this article: [236. Lowest Common Ancestor of a Binary Tree](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/1306476)\\n\\n\\nIf you think this **post is useful**, I\\'m happy if you **give a vote**. Any **questions or discussions are welcome**! Thanks.",
                "solutionTags": [],
                "code": "**\\u2714\\uFE0F Solution 1: Iterate in BST**\\n- Let `large = max(p.val, q.val)`, `small = min(p.val, q.val)`.\\n- We keep iterate `root` in our BST:\\n\\t- If `root.val > large` then both node `p` and `q` belong to the left subtree, go to left by `root = root.left`.\\n\\t- If `root.val < small` then both node `p` and `q` belong to the right subtree, go to right by `root = root.right`.\\n\\t- Now, `small <= root.val <= large` the current `root` is the LCA between `q` and `p`.\\n\\n![image](https://assets.leetcode.com/users/images/c9441871-3cdd-49fa-b4f4-7ab1f88779f1_1626682525.9321432.png)\\n\\n<iframe src=\"https://leetcode.com/playground/QdSyKrz6/shared\" frameBorder=\"0\" width=\"100%\" height=\"350\"></iframe>\\n\\nComplexity:\\n- Time: `O(H)`, where `H` is the heigh of Binary Tree.\\n- Space: `O(1)`\\n\\n---\\n\\n**\\u2714\\uFE0F Solution 2: Find LCA of general Binary Tree**\\n- There are two other solutions, which take `O(N)` in Time Complexity to find the LCA between `p` and `q` in the general **Binary Tree**, please check out this article: [236. Lowest Common Ancestor of a Binary Tree](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/1306476)\\n\\n\\nIf you think this **post is useful**, I\\'m happy if you **give a vote**. Any **questions or discussions are welcome**! Thanks.",
                "codeTag": "Unknown"
            },
            {
                "id": 64954,
                "title": "my-java-solution",
                "content": "    public class Solution {\\n        public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n            if(root.val > p.val && root.val > q.val){\\n                return lowestCommonAncestor(root.left, p, q);\\n            }else if(root.val < p.val && root.val < q.val){\\n                return lowestCommonAncestor(root.right, p, q);\\n            }else{\\n                return root;\\n            }\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n            if(root.val > p.val && root.val > q.val){\\n                return lowestCommonAncestor(root.left, p, q);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 65074,
                "title": "python-iterative-solution",
                "content": "    class Solution:\\n\\n    def lowestCommonAncestor(self, root, p, q):\\n        while root:\\n            if root.val > p.val and root.val > q.val:\\n                root = root.left\\n            elif root.val < p.val and root.val < q.val:\\n                root = root.right\\n            else:\\n                return root",
                "solutionTags": [],
                "code": "    class Solution:\\n\\n    def lowestCommonAncestor(self, root, p, q):\\n        while root:\\n            if root.val > p.val and root.val > q.val:\\n                root = root.left\\n            elif root.val < p.val and root.val < q.val:\\n                root = root.right\\n            else:\\n                return root",
                "codeTag": "Java"
            },
            {
                "id": 1394823,
                "title": "explained-easy-iterative-python-solution",
                "content": "We will rely upon the invariant of the BST to solve the exercise. We know that the left subtree of each node contains nodes with smaller values and the right subtree contains nodes with greater values. We also know that if two nodes, x and y, are on different subtrees of a node z (one in the left portion and one in the right portion), then x and y have z as the lowest common ancestor. Having these facts in mind, a possible solution looks like the following:\\n\\n```\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        \\n        while True:\\n            if root.val > p.val and root.val > q.val:\\n                root = root.left\\n            elif root.val < p.val and root.val < q.val:\\n                root = root.right\\n            else:\\n                return root\\n```\\n\\nNote: Since we are guaranteed that p and q exist in the tree, we do not need to check for edges cases.\\n\\nConsider upvoting, if you found this post useful. :)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        \\n        while True:\\n            if root.val > p.val and root.val > q.val:\\n                root = root.left\\n            elif root.val < p.val and root.val < q.val:\\n                root = root.right\\n            else:\\n                return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 65183,
                "title": "my-python-recursive-solution",
                "content": "\\n\\n    class Solution:\\n        # @param {TreeNode} root\\n        # @param {TreeNode} p\\n        # @param {TreeNode} q\\n        # @return {TreeNode}\\n        def lowestCommonAncestor(self, root, p, q):\\n            if not root or not p or not q:\\n                return None\\n            if (max(p.val, q.val) < root.val):\\n                return self.lowestCommonAncestor(root.left, p, q)\\n            elif (min(p.val, q.val) > root.val):\\n                return self.lowestCommonAncestor(root.right, p, q)\\n            else:\\n                return root",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n        # @param {TreeNode}",
                "codeTag": "Java"
            },
            {
                "id": 1347824,
                "title": "c-simple-and-efficient-short-recursive-iterative-solutions",
                "content": "**Recursive:**\\n```\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if (p->val < root->val && q->val < root->val)\\n            return lowestCommonAncestor(root->left, p, q);\\n        else if (p->val > root->val && q->val > root->val)\\n            return lowestCommonAncestor(root->right, p, q);\\n        else return root;\\n    }\\n};\\n```\\n****\\n**Iterative:**\\n```\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        while (root) {\\n            if (p->val < root->val && q->val < root->val) root = root->left;\\n            else if (p->val > root->val && q->val > root->val) root = root->right;\\n            else return root;\\n        }\\n        return root;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if (p->val < root->val && q->val < root->val)\\n            return lowestCommonAncestor(root->left, p, q);\\n        else if (p->val > root->val && q->val > root->val)\\n            return lowestCommonAncestor(root->right, p, q);\\n        else return root;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        while (root) {\\n            if (p->val < root->val && q->val < root->val) root = root->left;\\n            else if (p->val > root->val && q->val > root->val) root = root->right;\\n            else return root;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 64955,
                "title": "clear-java-10-ms",
                "content": "    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if(root==null) return null;\\n        if(p.val<root.val&&q.val<root.val) {\\n            return lowestCommonAncestor(root.left,p,q);\\n        }\\n        else if(p.val>root.val&&q.val>root.val){\\n            return lowestCommonAncestor(root.right,p,q);\\n        }\\n        else\\n        return root;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if(root==null) return null;\\n        if(p.val<root.val&&q.val<root.val) {\\n            return lowestCommonAncestor(root.left,p,q);\\n        }\\n        else if(p.val>root.val&&q.val>root.val){\\n            return lowestCommonAncestor(root.right,p,q);\\n        }\\n        else\\n        return root;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 541362,
                "title": "javascript-iterative-recursive",
                "content": "### Iterative solution\\n- Time Complexity: O(H)\\n- Space Complexity: O(1)\\n```JavaScript\\n/**\\n * @param {TreeNode} root\\n * @param {TreeNode} p\\n * @param {TreeNode} q\\n * @return {TreeNode}\\n */\\nvar lowestCommonAncestor = function(root, p, q) {\\n    while (root) {\\n        if (root.val < p.val && root.val < q.val) {\\n            root = root.right;\\n        }\\n        else if (root.val > p.val && root.val > q.val) {\\n            root = root.left;\\n        } else {\\n            break;\\n        }\\n    }\\n    return root;\\n};\\n```\\n### Recursive solution\\n- Time Complexity: O(H)\\n- Space Complexity: O(H)\\n\\n```JavaScript\\n/**\\n * @param {TreeNode} root\\n * @param {TreeNode} p\\n * @param {TreeNode} q\\n * @return {TreeNode}\\n */\\nvar lowestCommonAncestor = function(root, p, q) {\\n    if (root.val < p.val && root.val < q.val) {\\n        return lowestCommonAncestor(root.right, p, q);\\n    }\\n    if (root.val > p.val && root.val > q.val) {\\n        return lowestCommonAncestor(root.left, p, q);\\n    }\\n    return root;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```JavaScript\\n/**\\n * @param {TreeNode} root\\n * @param {TreeNode} p\\n * @param {TreeNode} q\\n * @return {TreeNode}\\n */\\nvar lowestCommonAncestor = function(root, p, q) {\\n    while (root) {\\n        if (root.val < p.val && root.val < q.val) {\\n            root = root.right;\\n        }\\n        else if (root.val > p.val && root.val > q.val) {\\n            root = root.left;\\n        } else {\\n            break;\\n        }\\n    }\\n    return root;\\n};\\n```\n```JavaScript\\n/**\\n * @param {TreeNode} root\\n * @param {TreeNode} p\\n * @param {TreeNode} q\\n * @return {TreeNode}\\n */\\nvar lowestCommonAncestor = function(root, p, q) {\\n    if (root.val < p.val && root.val < q.val) {\\n        return lowestCommonAncestor(root.right, p, q);\\n    }\\n    if (root.val > p.val && root.val > q.val) {\\n        return lowestCommonAncestor(root.left, p, q);\\n    }\\n    return root;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1348584,
                "title": "java-lowest-common-ancestor-of-bst-explained-solution",
                "content": "class Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n    \\n\\t// it is BST so that we should take advantage of it\\n\\t// there is only three cases\\n\\t\\n\\t// 1st one is that if both p & q are smaller than the root then call the left subtree\\n        if(p.val < root.val && q.val < root.val)\\n\\t\\t{\\n            return lowestCommonAncestor(root.left,p,q);\\n        }\\n\\t\\t// 2nd if both p & q are greter than the root then call the right subtree\\n\\t\\telse if(p.val > root.val && q.val > root.val)\\n\\t\\t{\\n            return lowestCommonAncestor(root.right, p, q);\\n        }\\n\\t\\t// 3rd is that we get our answer that is root :)\\n\\t\\telse\\n\\t\\t{\\n            return root;\\n        }\\n        \\n    }\\n}\\n\\n<<<<<<<<<<< upvote if you like it >>>>>>>>>>>>",
                "solutionTags": [
                    "Java",
                    "Binary Search Tree"
                ],
                "code": "class Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n    \\n\\t// it is BST so that we should take advantage of it\\n\\t// there is only three cases\\n\\t\\n\\t// 1st one is that if both p & q are smaller than the root then call the left subtree\\n        if(p.val < root.val && q.val < root.val)\\n\\t\\t{\\n            return lowestCommonAncestor(root.left,p,q);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2414941,
                "title": "python-detailed-explanation-easily-understood-o-h-o-n",
                "content": "Method 1: `O(n)`\\nWe can search through the tree\\n```\\n1) If the value p or q exist the left/right subtree\\n\\t-  return the node\\n2) Until a node have both left and right nodes return, it is the LCA of p and q.\\n   Else, either left or right node is the LCA\\n```\\n```\\ndef lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n\\t\\tdef find_lca(root, p, q):\\n\\t\\t\\tif root in [p, q, None]:\\n\\t\\t\\t\\treturn root\\n\\n\\t\\t\\tleft = find_lca(root.left, p, q)\\n\\t\\t\\tright = find_lca(root.right, p, q)\\n\\n\\t\\t\\tif left is not None and right is not None: \\n\\t\\t\\t\\treturn root\\n\\t\\t\\telif left is not None: \\n\\t\\t\\t\\treturn left\\n\\t\\t\\telse:\\n\\t\\t\\t\\treturn right\\n\\n\\t\\tif p.val == q.val:\\n\\t\\t\\treturn root\\n\\n\\t\\treturn find_lca(root, p, q)\\n```\\n**Time Complexity**: `O(n)`\\n**Space Complexity**: `O(n)`\\n<br/>\\n\\nMethod 2: `O(h)` where h is the height of the tree\\nFirst, we could set 3 condition to find out which subtree(s) do `p` and `q` place.\\n\\nLet `min_val` be `min(p.val, q.val)`\\nand `max_val` be `max(p.val, q.val)`\\n\\n```\\n1) min_val <= node.val <= max_val\\n\\t- It means min_val is inside the left subtree and max_val is inside the right subtree\\n\\t  -> The LCA is the node\\n\\t  \\n2) min_val < max_val < node.val\\n\\t- It means min_val and max_val are inside the left subtree\\n\\t  -> The LCA is inside the left subtree\\n\\t  \\n3) node.val  > max_val  > min_val\\n\\t- It means min_val and max_val are inside the right subtree\\n\\t  -> The LCA is inside the right subtree\\n```\\n\\n```\\ndef lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n\\tif p.val < q.val:\\n\\t\\tmin_val = p.val\\n\\t\\tmax_val = q.val\\n\\telse:\\n\\t\\tmin_val = q.val\\n\\t\\tmax_val = p.val\\n\\n\\twhile True:\\n\\t\\tif min_val <= root.val <= max_val:\\n\\t\\t\\treturn root\\n\\t\\telif max_val < root.val:\\n\\t\\t\\troot = root.left\\n\\t\\telse:\\n\\t\\t\\troot = root.right\\n```\\n**Time Complexity**: `O(h)` where h is the height of the tree\\n**Space Complexity**: `O(1)`",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\n1) If the value p or q exist the left/right subtree\\n\\t-  return the node\\n2) Until a node have both left and right nodes return, it is the LCA of p and q.\\n   Else, either left or right node is the LCA\\n```\n```\\ndef lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n\\t\\tdef find_lca(root, p, q):\\n\\t\\t\\tif root in [p, q, None]:\\n\\t\\t\\t\\treturn root\\n\\n\\t\\t\\tleft = find_lca(root.left, p, q)\\n\\t\\t\\tright = find_lca(root.right, p, q)\\n\\n\\t\\t\\tif left is not None and right is not None: \\n\\t\\t\\t\\treturn root\\n\\t\\t\\telif left is not None: \\n\\t\\t\\t\\treturn left\\n\\t\\t\\telse:\\n\\t\\t\\t\\treturn right\\n\\n\\t\\tif p.val == q.val:\\n\\t\\t\\treturn root\\n\\n\\t\\treturn find_lca(root, p, q)\\n```\n```\\n1) min_val <= node.val <= max_val\\n\\t- It means min_val is inside the left subtree and max_val is inside the right subtree\\n\\t  -> The LCA is the node\\n\\t  \\n2) min_val < max_val < node.val\\n\\t- It means min_val and max_val are inside the left subtree\\n\\t  -> The LCA is inside the left subtree\\n\\t  \\n3) node.val  > max_val  > min_val\\n\\t- It means min_val and max_val are inside the right subtree\\n\\t  -> The LCA is inside the right subtree\\n```\n```\\ndef lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n\\tif p.val < q.val:\\n\\t\\tmin_val = p.val\\n\\t\\tmax_val = q.val\\n\\telse:\\n\\t\\tmin_val = q.val\\n\\t\\tmax_val = p.val\\n\\n\\twhile True:\\n\\t\\tif min_val <= root.val <= max_val:\\n\\t\\t\\treturn root\\n\\t\\telif max_val < root.val:\\n\\t\\t\\troot = root.left\\n\\t\\telse:\\n\\t\\t\\troot = root.right\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 65093,
                "title": "simple-java-solution",
                "content": "    If the given both nodes values are less than that of root, then both the nodes must be on the left side of the root , so now we have to check only left tree of the root.\\n    Otherwise If the given both nodes values are greater than that of root, then both the nodes must be on the right side of the root , so now we have to check only right tree of the root.\\n    Otherwise . both the nodes will be on the either side of the root, this implies the lowest common ancestor is root.\\n    \\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n            if(p.val < root.val && q.val < root.val){\\n            return lowestCommonAncestor(root.left,p,q);}\\n            else if(p.val > root.val && q.val > root.val){\\n            return lowestCommonAncestor(root.right,p,q);}\\n            else{\\n            return root;}\\n        }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    If the given both nodes values are less than that of root, then both the nodes must be on the left side of the root , so now we have to check only left tree of the root.\\n    Otherwise If the given both nodes values are greater than that of root, then both the nodes must be on the right side of the root , so now we have to check only right tree of the root.\\n    Otherwise . both the nodes will be on the either side of the root, this implies the lowest common ancestor is root.\\n    \\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n            if(p.val < root.val && q.val < root.val){\\n            return lowestCommonAncestor(root.left,p,q);}\\n            else if(p.val > root.val && q.val > root.val){\\n            return lowestCommonAncestor(root.right,p,q);}\\n            else{\\n            return root;}\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 2413331,
                "title": "python-easiest-solution-detailed-graph-explantion-dfs-beginner-friendly",
                "content": "![image](https://assets.leetcode.com/users/images/44e4d220-c0b3-496e-94fb-ca29f3721af3_1660267475.6685576.png)\\n\\n```\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        \\n        # found what we want or there is nothing \\n        if (root == p or root == q or not root): return root \\n        \\n        #recursion\\n        left = self.lowestCommonAncestor(root.left, p, q)\\n        right = self.lowestCommonAncestor(root.right, p, q) \\n        \\n        if left and right: return root    # found common ancestor \\n        elif left: return left\\n        elif right: return right\\n```\\n**Please UPVOTE if you LIKE !!**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        \\n        # found what we want or there is nothing \\n        if (root == p or root == q or not root): return root \\n        \\n        #recursion\\n        left = self.lowestCommonAncestor(root.left, p, q)\\n        right = self.lowestCommonAncestor(root.right, p, q) \\n        \\n        if left and right: return root    # found common ancestor \\n        elif left: return left\\n        elif right: return right\\n```",
                "codeTag": "Java"
            },
            {
                "id": 65008,
                "title": "11ms-java-solution-3-lines",
                "content": "     public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if(root.val<Math.min(p.val,q.val)) return lowestCommonAncestor(root.right,p,q);\\n        if(root.val>Math.max(p.val,q.val)) return lowestCommonAncestor(root.left,p,q);\\n        return root;\\n    }",
                "solutionTags": [],
                "code": "     public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if(root.val<Math.min(p.val,q.val)) return lowestCommonAncestor(root.right,p,q);\\n        if(root.val>Math.max(p.val,q.val)) return lowestCommonAncestor(root.left,p,q);\\n        return root;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2413386,
                "title": "java-4ms-100-faster-beginner-friendly",
                "content": "**If you really found my solution helpful please upvote it, as it motivates me to post such kind of codes and help the coding community, if you have some queries or some improvements please feel free to comment and share your views.**\\n```\\n\\tpublic TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n\\t// Base Case\\n        if (root == null) {\\n            return null;\\n        } else if (p.val < root.val && q.val < root.val) { // if current root value is greater than both p and q value that means root is in left of current root\\n            return lowestCommonAncestor(root.left, p, q); \\n        } else if (p.val > root.val && q.val > root.val) { // if current root value is lesser than both p and q value that means root is in right of current root\\n            return lowestCommonAncestor(root.right, p, q);\\n        } else {\\n            return root; // if root value is between both left and right of the root then we got the least common ancestor\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search Tree"
                ],
                "code": "```\\n\\tpublic TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n\\t// Base Case\\n        if (root == null) {\\n            return null;\\n        } else if (p.val < root.val && q.val < root.val) { // if current root value is greater than both p and q value that means root is in left of current root\\n            return lowestCommonAncestor(root.left, p, q); \\n        } else if (p.val > root.val && q.val > root.val) { // if current root value is lesser than both p and q value that means root is in right of current root\\n            return lowestCommonAncestor(root.right, p, q);\\n        } else {\\n            return root; // if root value is between both left and right of the root then we got the least common ancestor\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3575320,
                "title": "beats-100-log-n-only-3-lines-code-best-explaination-c-python-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nStart!\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- First we will check that the node is null or not \\n- if both Q,P are smaller then ROOT then it will be in left.\\n- if both q,p are grater then root then it will be in right.\\n- if not the current root is the answer!\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(Log N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(H)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if(root==NULL) return nullptr;\\n        if(root->val>p->val&&root->val>q->val) return lowestCommonAncestor(root->left,p,q);\\n        if(root->val<p->val&&root->val<q->val) return lowestCommonAncestor(root->right,p,q);\\n        return root;        \\n    }\\n};\\n```\\n![7abc56.jpg](https://assets.leetcode.com/users/images/528179d1-2cbe-47c7-a3c9-79372d690859_1685362528.162892.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Tree",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if(root==NULL) return nullptr;\\n        if(root->val>p->val&&root->val>q->val) return lowestCommonAncestor(root->left,p,q);\\n        if(root->val<p->val&&root->val<q->val) return lowestCommonAncestor(root->right,p,q);\\n        return root;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3237609,
                "title": "java-solution-easy-solution-5ms-runtime-interesting-logic",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIn the first place when i understood the problem description it was clear that i have to use DFS ofcourse and as it is based on Binary Search Tree (BST), i got to an interesting observation that we know ancestor will be that node at which the two given nodes `p` and `q` will split or wont be a part of same subtree after that particular node.\\nSo lets see how to solve it.\\n\\n**Problem Link** : https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/description/\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach is quite straight forward. The Algorithm will check if `p` and `q` falls under same subtree i.e the left one or right one then it will recursively call that subtree to search the ancestor.\\nOtherwise if `p` and `q` are separated and they belongs to different subtree then that particular node is the ancestor.\\n\\nFor example\\n```\\np = 3\\nq = 5\\n```\\nlets say `current node = 6` then we know that the `p` and `q` will fall under left subtree of this particular node.\\nAgain lets say the `current node = 2` then we know that `p` and `q` will fall under right subtree of the particular node. \\n\\nFor above these situations we will search through that particular subtree recursively.\\nNow if these conditions doesn\\'t satisfied, there will be 2 cases and we will simply return that current node. \\n\\n**Cases:**\\n- The current node is equals to any of `p` or `q`.\\n- If the `current node = 4` then `p` will belongs to left subtree and `q` will belongs to right subtree and vice-verse.\\n\\nIn any of these two cases we will simply return current node as our answer.\\nThis is how the algorithm will work to find the common ancestor.\\n# Complexity\\n- Time complexity: O(h)\\n`h` is the height of the tree.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(h)\\nTotal `h` stack spaces in recursive calls.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\n\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if(root.val > p.val && root.val > q.val){\\n            return lowestCommonAncestor(root.left,p,q);\\n        }\\n        if(root.val < p.val && root.val < q.val){\\n            return lowestCommonAncestor(root.right,p,q);\\n        }\\n        //  If above 2 conditions doesn\\'t satisfy then \\n        //  2 cases will arise. For them we simply return \\n        //  the current node.\\n        return root;\\n    }\\n}\\n```\\nI hope the approach is easy and understandable. Please do comment if any doubts or suggestions .\\n\\nPLEASE DO UPVOTE MATES !!!\\n\\nThank You !!!",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Binary Search Tree"
                ],
                "code": "```\\np = 3\\nq = 5\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\n\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if(root.val > p.val && root.val > q.val){\\n            return lowestCommonAncestor(root.left,p,q);\\n        }\\n        if(root.val < p.val && root.val < q.val){\\n            return lowestCommonAncestor(root.right,p,q);\\n        }\\n        //  If above 2 conditions doesn\\'t satisfy then \\n        //  2 cases will arise. For them we simply return \\n        //  the current node.\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2413340,
                "title": "c-2-ways-to-solve",
                "content": "**Solved LIVE ON TWITCH.  Tune in at 6pm Pacific Time.  Link in profile.**\\n\\n1st way (brought to you by Q_ULTIMAS / OVERFITT) :\\n\\n\\t1. If both P and Q are less than the root, go left\\n\\t2. If both P and Q are greater than the root, go right\\n\\t3. if P and Q are split between left and right, then we have found the LCA.\\n\\n```\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        int current = root->val;\\n        if(p->val < current && q->val < current) {\\n            return lowestCommonAncestor(root->left, p, q);\\n        }\\n        else if(p->val > current && q->val > current) {\\n            return lowestCommonAncestor(root->right, p, q);\\n        }\\n        else{\\n            return root;\\n        }\\n    }\\n};\\n```\\n\\n\\n2nd way (sub-optimal, home grown junk by me):\\n\\nThe first node to have two trues (out of left, right ,and current) is our LCA.\\n\\n```\\nclass Solution {\\n    bool dfs(TreeNode* root, TreeNode* p, TreeNode* q, TreeNode*& lca) {\\n        if(!root || lca) return false;\\n        \\n        bool left = dfs(root->left, p, q, lca);\\n        bool right = dfs(root->right, p, q, lca);\\n        \\n        bool cur = false;\\n        if(root == p || root == q) {\\n            cur = true;\\n        }\\n        if(left + right + cur >= 2) {\\n            lca = root;\\n            return false;\\n        }\\n        return left || right || cur;   \\n    }\\n    \\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        TreeNode* ans = nullptr;\\n        dfs(root, p, q, ans);\\n        \\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        int current = root->val;\\n        if(p->val < current && q->val < current) {\\n            return lowestCommonAncestor(root->left, p, q);\\n        }\\n        else if(p->val > current && q->val > current) {\\n            return lowestCommonAncestor(root->right, p, q);\\n        }\\n        else{\\n            return root;\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\n    bool dfs(TreeNode* root, TreeNode* p, TreeNode* q, TreeNode*& lca) {\\n        if(!root || lca) return false;\\n        \\n        bool left = dfs(root->left, p, q, lca);\\n        bool right = dfs(root->right, p, q, lca);\\n        \\n        bool cur = false;\\n        if(root == p || root == q) {\\n            cur = true;\\n        }\\n        if(left + right + cur >= 2) {\\n            lca = root;\\n            return false;\\n        }\\n        return left || right || cur;   \\n    }\\n    \\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        TreeNode* ans = nullptr;\\n        dfs(root, p, q, ans);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 65091,
                "title": "my-java-solution-to-share",
                "content": "public class Solution {\\n\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if(p.val>q.val)\\n            return lowestCommonAncestor(root, q,p);\\n        if(root.val>= p.val && root.val<=q.val)\\n            return root;\\n        return lowestCommonAncestor(root.val>p.val?root.left:root.right, p,q);    \\n    }\\n\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if(p.val>q.val)\\n            return lowestCommonAncestor(root, q,p);\\n        if(root.val>= p.val && root.val<=q.val)\\n            return root;\\n        return lowestCommonAncestor(root.val>p.val?root.left:root.right, p,q);    \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 65051,
                "title": "c-solution-40ms",
                "content": "    /**\\n     * Definition for a binary tree node.\\n     * struct TreeNode {\\n     *     int val;\\n     *     TreeNode *left;\\n     *     TreeNode *right;\\n     *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n     * };\\n     */\\n    class Solution {\\n    public:\\n        TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n            if(!root){\\n                return NULL;\\n            }\\n            // check if the current value is larger than both nodes , go left\\n            if(p->val < root->val && q->val < root->val){\\n                lowestCommonAncestor(root->left , p , q);\\n             // go right\\n            }else if(p->val > root->val && q->val > root->val){\\n                lowestCommonAncestor(root->right , p , q);\\n            }// my LCA \\n            else{\\n                return root;\\n            }\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n            if(!root){\\n                return NULL;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 65157,
                "title": "my-java-solution",
                "content": "    /**\\n     * Definition for a binary tree node.\\n     * public class TreeNode {\\n     *     int val;\\n     *     TreeNode left;\\n     *     TreeNode right;\\n     *     TreeNode(int x) { val = x; }\\n     * }\\n     */\\n    public class Solution {\\n        public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n            while(true){\\n              if((root.val-p.val)*(root.val-q.val)<=0) return root;\\n              if(p.val<root.val){\\n                 root=root.left;\\n              }\\n             else{\\n                  root=root.right;\\n              }\\n            }\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n            while(true){\\n              if((root.val-p.val)*(root.val-q.val)<=0) return root;\\n              if(p.val<root.val){\\n                 root=root.left;\\n              }",
                "codeTag": "Java"
            },
            {
                "id": 3231689,
                "title": "235-space-96-79-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. We are given the root of a binary search tree and two nodes p and q.\\n2. We start traversing from the root of the binary search tree.\\n3. If the value of both p and q is less than the value of the root, then the LCA will be in the left subtree. So, we recursively call the function on the left subtree.\\n4. If the value of both p and q is greater than the value of the root, then the LCA will be in the right subtree. So, we recursively call the function on the right subtree.\\n5. If one value is less than the root and the other is greater than the root, then root is the LCA. So, we return the root.\\n\\n# Complexity\\n- Time complexity:\\n80.42%\\n\\n- Space complexity:\\n96.79%\\n\\n# Code\\n```\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        # If the value of p and q is less than root, then LCA will be in the left subtree\\n        if p.val < root.val and q.val < root.val:\\n            return self.lowestCommonAncestor(root.left, p, q)\\n        # If the value of p and q is greater than root, then LCA will be in the right subtree\\n        elif p.val > root.val and q.val > root.val:\\n            return self.lowestCommonAncestor(root.right, p, q)\\n        # If one value is less and the other is greater, then root is the LCA\\n        else:\\n            return root\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Tree",
                    "Depth-First Search",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        # If the value of p and q is less than root, then LCA will be in the left subtree\\n        if p.val < root.val and q.val < root.val:\\n            return self.lowestCommonAncestor(root.left, p, q)\\n        # If the value of p and q is greater than root, then LCA will be in the right subtree\\n        elif p.val > root.val and q.val > root.val:\\n            return self.lowestCommonAncestor(root.right, p, q)\\n        # If one value is less and the other is greater, then root is the LCA\\n        else:\\n            return root\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1520007,
                "title": "python-iterative-recursive-beats-99-simple-solutions",
                "content": "## Solution 1 - Iterative\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        while True:\\n            if p.val < root.val and q.val < root.val:\\n                root = root.left\\n            elif p.val > root.val and q.val > root.val:\\n                root = root.right\\n            else:\\n                return root\\n```\\n\\n## Solution 2 - Recursive\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        if p.val > root.val and q.val > root.val:\\n            return self.lowestCommonAncestor(root.right, p, q)\\n        elif p.val < root.val and q.val < root.val:\\n            return self.lowestCommonAncestor(root.left, p, q)\\n        else:\\n            return root\\n```\\n\\n***If you liked the above solutions then please upvote!***",
                "solutionTags": [
                    "Python",
                    "Binary Search Tree",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        while True:\\n            if p.val < root.val and q.val < root.val:\\n                root = root.left\\n            elif p.val > root.val and q.val > root.val:\\n                root = root.right\\n            else:\\n                return root\\n```\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        if p.val > root.val and q.val > root.val:\\n            return self.lowestCommonAncestor(root.right, p, q)\\n        elif p.val < root.val and q.val < root.val:\\n            return self.lowestCommonAncestor(root.left, p, q)\\n        else:\\n            return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1167549,
                "title": "c-solution-by-comparing-the-values",
                "content": "\\nSince in bst value less than root are to left and greater than root are to right, we make use of it.\\n\\nIf the value of root is equal to anyone of p & q it means it is LCA since second value will be velow it.\\nElse we check if both value lie on left and right side, then in this case root will be LCA since both are on different side.\\nIn case if both values are on same side, we check which side do they belong to and pass that to our function\\n\\n```\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n         if(!root){\\n            return NULL;\\n        }\\n        if(root->val==p->val || root->val==q->val)\\n            return root;\\n        if(root->val<max(p->val,q->val) && root->val>min(p->val,q->val)){\\n            return root;\\n        }\\n        // both are less than root then lca is left side\\n        else if(root->val >max(p->val,q->val)){\\n            return lowestCommonAncestor(root->left,p,q);\\n        }\\n        else\\n            return lowestCommonAncestor(root->right,p,q);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n         if(!root){\\n            return NULL;\\n        }\\n        if(root->val==p->val || root->val==q->val)\\n            return root;\\n        if(root->val<max(p->val,q->val) && root->val>min(p->val,q->val)){\\n            return root;\\n        }\\n        // both are less than root then lca is left side\\n        else if(root->val >max(p->val,q->val)){\\n            return lowestCommonAncestor(root->left,p,q);\\n        }\\n        else\\n            return lowestCommonAncestor(root->right,p,q);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 158059,
                "title": "python-dfs",
                "content": "###  235. Lowest Common Ancestor of a Binary Search Tree\\n```\\n> \\u7C7B\\u578B\\uFF1ADFS\\u5206\\u5236\\n> Time Complexity O(h)\\n> Space Complexity O(1)\\n```\\n\\n\\u6839\\u636EBST\\u7684\\u7279\\u6027\\uFF0C\\u5982\\u679C`p`\\u548C`q`\\u91CC\\u9762\\u6700\\u5927\\u7684\\u503C\\u90FD\\u6BD4`root.val`\\u5C0F\\u7684\\u8BDD\\uFF0C\\u90A3\\u8BC1\\u660E`p`\\u548C`q`\\u90FD\\u5728\\u5DE6\\u8FB9\\uFF0C\\u6240\\u4EE5\\u5F80\\u5DE6\\u8FB9\\u9012\\u5F52\\u5C31\\u884C\\uFF0C\\u53F3\\u8FB9\\u9012\\u5F52\\u9053\\u7406\\u76F8\\u540C\\u3002\\u7136\\u540E\\u7B2C\\u4E09\\u79CDcase\\u5F53`root.val`\\u7B49\\u4E8E`p`\\u548C`q`\\u4E4B\\u95F4\\u4E00\\u4E2A\\u7684\\u65F6\\u5019\\uFF0C\\u76F4\\u63A5\\u8FD4\\u56DE`root`\\u5373\\u53EF\\uFF0C\\u56E0\\u4E3A\\u627E\\u5230\\u4E86\\n\\n```\\nclass Solution(object):\\n    def lowestCommonAncestor(self, root, p, q):\\n        if not root: return None\\n        if max(p.val, q.val) < root.val:\\n            return self.lowestCommonAncestor(root.left, p, q)\\n        if min(p.val, q.val) > root.val:\\n            return self.lowestCommonAncestor(root.right, p, q)\\n        return root   \\n```",
                "solutionTags": [],
                "code": "```\\n> \\u7C7B\\u578B\\uFF1ADFS\\u5206\\u5236\\n> Time Complexity O(h)\\n> Space Complexity O(1)\\n```\n```\\nclass Solution(object):\\n    def lowestCommonAncestor(self, root, p, q):\\n        if not root: return None\\n        if max(p.val, q.val) < root.val:\\n            return self.lowestCommonAncestor(root.left, p, q)\\n        if min(p.val, q.val) > root.val:\\n            return self.lowestCommonAncestor(root.right, p, q)\\n        return root   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 65184,
                "title": "no-comparison-needed-java",
                "content": "    public class Solution {\\n        public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n            \\n            if(root==null || root==p || root==q) return root;\\n            \\n            TreeNode left = lowestCommonAncestor(root.left,p,q);\\n            TreeNode right = lowestCommonAncestor(root.right,p,q);\\n            \\n            if(left==null) return right;\\n            if(right==null) return left;\\n            \\n            return root;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n            \\n            if(root==null || root==p || root==q) return root;\\n            \\n            TreeNode left = lowestCommonAncestor(root.left,p,q);\\n            TreeNode right = lowestCommonAncestor(root.right,p,q);\\n            \\n            if(left==null) return right;\\n            if(right==null) return left;\\n            \\n            return root;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2413931,
                "title": "java-c-classic-recursion",
                "content": "Move recursively through the tree until 1 and 2 are greater than or less than the root, which means they are in the same subtree. \\n\\n#### Java:\\n\\n```java\\npublic TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if (p.val < root.val && q.val < root.val)\\n            return lowestCommonAncestor(root.left, p, q);\\n        if (p.val > root.val && q.val > root.val)\\n            return lowestCommonAncestor(root.right, p, q);\\n        else\\n            return root;\\n    }\\n```\\n\\nThe same, but shorter: \\n\\n```java\\npublic TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        return (root.val - p.val) * (root.val - q.val) < 1 ? \\n            root : lowestCommonAncestor(p.val < root.val ? root.left : root.right, p, q);\\n    }\\n\\t\\n```\\n#### C++\\n```cpp\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if (p->val < root->val && q->val < root->val)\\n            return lowestCommonAncestor(root->left, p, q);\\n        if (p->val > root->val && q->val > root->val)\\n            return lowestCommonAncestor(root->right, p, q);\\n        else\\n            return root;\\n    }\\n```\\n\\nThe same, but shorter: \\n\\n```cpp\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n         return (root->val - p->val) * (root->val - q->val) < 1 ? \\n             root : lowestCommonAncestor(p->val < root->val ? root->left : root->right, p, q);\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```java\\npublic TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if (p.val < root.val && q.val < root.val)\\n            return lowestCommonAncestor(root.left, p, q);\\n        if (p.val > root.val && q.val > root.val)\\n            return lowestCommonAncestor(root.right, p, q);\\n        else\\n            return root;\\n    }\\n```\n```java\\npublic TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        return (root.val - p.val) * (root.val - q.val) < 1 ? \\n            root : lowestCommonAncestor(p.val < root.val ? root.left : root.right, p, q);\\n    }\\n\\t\\n```\n```cpp\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if (p->val < root->val && q->val < root->val)\\n            return lowestCommonAncestor(root->left, p, q);\\n        if (p->val > root->val && q->val > root->val)\\n            return lowestCommonAncestor(root->right, p, q);\\n        else\\n            return root;\\n    }\\n```\n```cpp\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n         return (root->val - p->val) * (root->val - q->val) < 1 ? \\n             root : lowestCommonAncestor(p->val < root->val ? root->left : root->right, p, q);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2504620,
                "title": "very-easy-100-fully-explained-c-java-python-js-c-python3-iterative-recursive",
                "content": "# **C++ Solution:**\\n```\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        // Loop till root becomes null...\\n        while(root!= NULL){\\n            // If the value of p node and the q node is greater than the value of root node...\\n            if(p->val > root->val && q->val > root->val){\\n                root = root->right;\\n            }\\n            // If the value of p node and the q node is less than the value of root node...\\n            else if (p->val < root->val && q->val < root->val){\\n                root = root->left;\\n            }\\n            // Otherwise, return the root...\\n            else{\\n                return root;\\n            }\\n        }\\n        return NULL;\\n    }\\n};\\n```\\n\\n# **Java Solution:**\\n```\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        // If the value of root node is greater than the value of p node and less than the value of q node...\\n        if(root.val > p.val && root.val < q.val){\\n            return root;\\n        }\\n        // If the value of p node and the q node is less than the value of root node...\\n        else if(root.val > p.val && root.val > q.val){\\n            return lowestCommonAncestor(root.left, p, q);\\n        }\\n        // If the value of p node and the q node is greater than the value of root node...\\n        else if(root.val < p.val && root.val < q.val){\\n            return lowestCommonAncestor(root.right, p, q);\\n        }\\n        return root;\\n    }\\n}\\n```\\n\\n# **Python/Python3 Solution:**\\n```\\nclass Solution(object):\\n    def lowestCommonAncestor(self, root, p, q):\\n        if root:\\n            # If the value of p node and the q node is greater than the value of root node...\\n            if root.val > p.val and root.val > q.val:\\n                return self.lowestCommonAncestor(root.left, p, q)\\n            # If the value of p node and the q node is less than the value of root node...\\n            elif root.val < p.val and root.val < q.val:\\n                return self.lowestCommonAncestor(root.right, p, q)\\n            else:\\n                return root\\n```\\n                \\n# **JavaScript Solution:**\\n```\\nvar lowestCommonAncestor = function(root, p, q) {\\n    // If the value of root node is greater than the value of p node and less than the value of q node...\\n    if(root.val > p.val && root.val < q.val){\\n        return root;\\n    }\\n    // If the value of p node and the q node is less than the value of root node...\\n    else if(root.val > p.val && root.val > q.val){\\n        return lowestCommonAncestor(root.left, p, q);\\n    }\\n    // If the value of p node and the q node is greater than the value of root node...\\n    else if(root.val < p.val && root.val < q.val){\\n        return lowestCommonAncestor(root.right, p, q);\\n    }\\n    return root;\\n};\\n```\\n\\n# **C Language:**\\n```\\nstruct TreeNode* lowestCommonAncestor(struct TreeNode* root, struct TreeNode* p, struct TreeNode* q) {\\n    // Loop till root becomes null...\\n    while(root!= NULL){\\n        // If the value of p node and the q node is greater than the value of root node...\\n        if(p->val > root->val && q->val > root->val){\\n            root = root->right;\\n        }\\n        // If the value of p node and the q node is less than the value of root node...\\n        else if (p->val < root->val && q->val < root->val){\\n            root = root->left;\\n        }\\n        // Otherwise, return the root...\\n        else{\\n            return root;\\n        }\\n    }\\n    return NULL;\\n}\\n```\\n**I am working hard for you guys...\\nPlease upvote if you found any help with this code...**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Tree",
                    "Depth-First Search",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        // Loop till root becomes null...\\n        while(root!= NULL){\\n            // If the value of p node and the q node is greater than the value of root node...\\n            if(p->val > root->val && q->val > root->val){\\n                root = root->right;\\n            }\\n            // If the value of p node and the q node is less than the value of root node...\\n            else if (p->val < root->val && q->val < root->val){\\n                root = root->left;\\n            }\\n            // Otherwise, return the root...\\n            else{\\n                return root;\\n            }\\n        }\\n        return NULL;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        // If the value of root node is greater than the value of p node and less than the value of q node...\\n        if(root.val > p.val && root.val < q.val){\\n            return root;\\n        }\\n        // If the value of p node and the q node is less than the value of root node...\\n        else if(root.val > p.val && root.val > q.val){\\n            return lowestCommonAncestor(root.left, p, q);\\n        }\\n        // If the value of p node and the q node is greater than the value of root node...\\n        else if(root.val < p.val && root.val < q.val){\\n            return lowestCommonAncestor(root.right, p, q);\\n        }\\n        return root;\\n    }\\n}\\n```\n```\\nclass Solution(object):\\n    def lowestCommonAncestor(self, root, p, q):\\n        if root:\\n            # If the value of p node and the q node is greater than the value of root node...\\n            if root.val > p.val and root.val > q.val:\\n                return self.lowestCommonAncestor(root.left, p, q)\\n            # If the value of p node and the q node is less than the value of root node...\\n            elif root.val < p.val and root.val < q.val:\\n                return self.lowestCommonAncestor(root.right, p, q)\\n            else:\\n                return root\\n```\n```\\nvar lowestCommonAncestor = function(root, p, q) {\\n    // If the value of root node is greater than the value of p node and less than the value of q node...\\n    if(root.val > p.val && root.val < q.val){\\n        return root;\\n    }\\n    // If the value of p node and the q node is less than the value of root node...\\n    else if(root.val > p.val && root.val > q.val){\\n        return lowestCommonAncestor(root.left, p, q);\\n    }\\n    // If the value of p node and the q node is greater than the value of root node...\\n    else if(root.val < p.val && root.val < q.val){\\n        return lowestCommonAncestor(root.right, p, q);\\n    }\\n    return root;\\n};\\n```\n```\\nstruct TreeNode* lowestCommonAncestor(struct TreeNode* root, struct TreeNode* p, struct TreeNode* q) {\\n    // Loop till root becomes null...\\n    while(root!= NULL){\\n        // If the value of p node and the q node is greater than the value of root node...\\n        if(p->val > root->val && q->val > root->val){\\n            root = root->right;\\n        }\\n        // If the value of p node and the q node is less than the value of root node...\\n        else if (p->val < root->val && q->val < root->val){\\n            root = root->left;\\n        }\\n        // Otherwise, return the root...\\n        else{\\n            return root;\\n        }\\n    }\\n    return NULL;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2413256,
                "title": "python-easy-runtime-95-94",
                "content": "![image](https://assets.leetcode.com/users/images/b09acb43-60ad-44ee-b63d-59955357ddc8_1660264965.5501003.png)\\n\\ncase i)\\nif root.val is the smallest or the greatest among p.val, q.val, and root.val, then traverse down\\n\\ncase ii)\\nif case (i) is false <=>\\nif root.val is in between p.val and q.val: p and q are seperated by root(which is an ancester of p and q)\\nor if root.val is p.val or root.val is q.val => root is LCA -> return root\\n\\n```\\ndef lowestCommonAncestor(self, root, p, q):\\n    while True:\\n        if root.val < min(p.val,q.val):\\n            root = root.right\\n        elif root.val > max(p.val,q.val):\\n            root = root.left\\n        else:\\n            return root\\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef lowestCommonAncestor(self, root, p, q):\\n    while True:\\n        if root.val < min(p.val,q.val):\\n            root = root.right\\n        elif root.val > max(p.val,q.val):\\n            root = root.left\\n        else:\\n            return root\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1322878,
                "title": "solution-swift-lowest-common-ancestor-of-a-binary-search-tree-test-cases",
                "content": "```swift\\nclass Solution {\\n    func lowestCommonAncestor(_ root: TreeNode?, _ p: TreeNode?, _ q: TreeNode?) -> TreeNode? {\\n        guard let rootVal = root?.val, let nodeP = p, let nodeQ = q else { return nil }\\n        switch (p: nodeP.val, q: nodeQ.val) {\\n        case let val where rootVal > val.p && rootVal > val.q:\\n            return lowestCommonAncestor(root?.left, nodeP, nodeQ)\\n        case let val where rootVal < val.p && rootVal < val.q:\\n            return lowestCommonAncestor(root?.right, nodeP, nodeQ)\\n        default:\\n            return root\\n        }\\n    }\\n}\\n```\\n\\n```swift\\n// MARK: - Test cases -\\n\\n// Result: Executed 3 tests, with 0 failures (0 unexpected) in 0.062 (0.064) seconds\\n\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let tree = solution.lowestCommonAncestor(TreeNode([6,2,8,0,4,7,9,nil,nil,3,5]), TreeNode(2), TreeNode(8))\\n        XCTAssertEqual(tree!.val, 6)\\n    }\\n    \\n    func test1() {\\n        let tree = solution.lowestCommonAncestor(TreeNode([6,2,8,0,4,7,9,nil,nil,3,5]), TreeNode(2), TreeNode(4))\\n        XCTAssertEqual(tree!.val, 2)\\n    }\\n    \\n    func test2() {\\n        let tree = solution.lowestCommonAncestor(TreeNode([2,1]), TreeNode(2), TreeNode(1))\\n        XCTAssertEqual(tree!.val, 2)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n```swift\\npublic class TreeNode {\\n    public var val: Int\\n    public var left: TreeNode?\\n    public var right: TreeNode?\\n    public init(_ val: Int) {\\n        self.val = val\\n        self.left = nil\\n        self.right = nil\\n    }\\n    \\n    public init?(_ array: [Int?]) {\\n        var values = array\\n        guard !values.isEmpty, let head = values.removeFirst() else { return nil }\\n        \\n        val = head; left = nil; right = nil\\n        \\n        var queue = [self]\\n        while !queue.isEmpty {\\n            let node = queue.removeFirst()\\n            if !values.isEmpty, let val = values.removeFirst() {\\n                node.left = TreeNode(val)\\n                queue.append(node.left!)\\n            }\\n            if !values.isEmpty, let val = values.removeFirst() {\\n                node.right = TreeNode(val)\\n                queue.append(node.right!)\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func lowestCommonAncestor(_ root: TreeNode?, _ p: TreeNode?, _ q: TreeNode?) -> TreeNode? {\\n        guard let rootVal = root?.val, let nodeP = p, let nodeQ = q else { return nil }\\n        switch (p: nodeP.val, q: nodeQ.val) {\\n        case let val where rootVal > val.p && rootVal > val.q:\\n            return lowestCommonAncestor(root?.left, nodeP, nodeQ)\\n        case let val where rootVal < val.p && rootVal < val.q:\\n            return lowestCommonAncestor(root?.right, nodeP, nodeQ)\\n        default:\\n            return root\\n        }\\n    }\\n}\\n```\n```swift\\n// MARK: - Test cases -\\n\\n// Result: Executed 3 tests, with 0 failures (0 unexpected) in 0.062 (0.064) seconds\\n\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let tree = solution.lowestCommonAncestor(TreeNode([6,2,8,0,4,7,9,nil,nil,3,5]), TreeNode(2), TreeNode(8))\\n        XCTAssertEqual(tree!.val, 6)\\n    }\\n    \\n    func test1() {\\n        let tree = solution.lowestCommonAncestor(TreeNode([6,2,8,0,4,7,9,nil,nil,3,5]), TreeNode(2), TreeNode(4))\\n        XCTAssertEqual(tree!.val, 2)\\n    }\\n    \\n    func test2() {\\n        let tree = solution.lowestCommonAncestor(TreeNode([2,1]), TreeNode(2), TreeNode(1))\\n        XCTAssertEqual(tree!.val, 2)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\n```swift\\npublic class TreeNode {\\n    public var val: Int\\n    public var left: TreeNode?\\n    public var right: TreeNode?\\n    public init(_ val: Int) {\\n        self.val = val\\n        self.left = nil\\n        self.right = nil\\n    }\\n    \\n    public init?(_ array: [Int?]) {\\n        var values = array\\n        guard !values.isEmpty, let head = values.removeFirst() else { return nil }\\n        \\n        val = head; left = nil; right = nil\\n        \\n        var queue = [self]\\n        while !queue.isEmpty {\\n            let node = queue.removeFirst()\\n            if !values.isEmpty, let val = values.removeFirst() {\\n                node.left = TreeNode(val)\\n                queue.append(node.left!)\\n            }\\n            if !values.isEmpty, let val = values.removeFirst() {\\n                node.right = TreeNode(val)\\n                queue.append(node.right!)\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3059255,
                "title": "simple-java-beats-100-runtime-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe have to find the lowest common ancestor (LCA) node of two given nodes in the BST.\\nIt means we have to find the **lowest common parent node**.\\nIn a BST, left TreeNode value is smaller than root value and right TreeNode value is greater than the root value.\\n**Right TreeNode value > Root value > Left TreeNode value**\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    1. If p and q are smaller than root value, search in left sub-tree.\\n    2. If p and q are greater, search in right sub-tree.\\n    3. If p is smaller and q is greater or vice-versa, return root node.\\n\\nFollow the code below to understand the solution.\\n\\n         **If this solution helped you, give it an up-vote to help others** \\n\\n# Complexity\\n- Time complexity: O(logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\n\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        //if both the values are smaller than root value\\n        //then search in the left sub-tree.\\n        if (p.val < root.val && q.val < root.val)\\n        {\\n            return lowestCommonAncestor(root.left, p, q);\\n        }\\n        //if both the values are greater than root value\\n        //then search in the right sub-tree.\\n        else if (p.val > root.val && q.val > root.val)\\n        {\\n            return lowestCommonAncestor(root.right, p, q);\\n        }\\n        //if one value is greater and other is smaller, that means,\\n        //one node in left sub-tree and other in right sub-tree.\\n        //In that case, the root is the LCA.\\n        else\\n        {\\n            //hence, return root.\\n            return root;\\n        }   \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\n\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        //if both the values are smaller than root value\\n        //then search in the left sub-tree.\\n        if (p.val < root.val && q.val < root.val)\\n        {\\n            return lowestCommonAncestor(root.left, p, q);\\n        }\\n        //if both the values are greater than root value\\n        //then search in the right sub-tree.\\n        else if (p.val > root.val && q.val > root.val)\\n        {\\n            return lowestCommonAncestor(root.right, p, q);\\n        }\\n        //if one value is greater and other is smaller, that means,\\n        //one node in left sub-tree and other in right sub-tree.\\n        //In that case, the root is the LCA.\\n        else\\n        {\\n            //hence, return root.\\n            return root;\\n        }   \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3045251,
                "title": "accepted-easy-solution-short-simple-best-method",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n         while (root) {\\n            if (p->val < root->val && q->val < root->val)\\n                root = root->left;\\n            else if (p->val > root->val && q->val > root->val)\\n                root = root->right;\\n            else return root;\\n        }\\n        return root;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n         while (root) {\\n            if (p->val < root->val && q->val < root->val)\\n                root = root->left;\\n            else if (p->val > root->val && q->val > root->val)\\n                root = root->right;\\n            else return root;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2413347,
                "title": "c-4-line-detailed-explanation-dfs-beginner-friendly",
                "content": "![image](https://assets.leetcode.com/users/images/4d397ce8-6cdd-4ec7-885b-d7eeb827b2ae_1660268129.6445835.png)\\n\\n```\\nstruct TreeNode* lowestCommonAncestor(struct TreeNode* root, struct TreeNode* p, struct TreeNode* q) {\\n    if(root == p || root == q || !root) return root;   // found what we want or there is nothing\\n    struct TreeNode* left = lowestCommonAncestor(root->left, p, q);\\n    struct TreeNode* right = lowestCommonAncestor(root->right, p, q);\\n    return !left?right:!right?left:root;\\n}\\n```\\n\\nHere\\'s the code for better understand:\\n```\\nstruct TreeNode* lowestCommonAncestor(struct TreeNode* root, struct TreeNode* p, struct TreeNode* q) {\\n     \\n    // found what we want or there is nothing\\n    if(root == p || root == q || !root) \\n        return root;   // found what we want or there is nothing\\n    \\n    struct TreeNode* left = lowestCommonAncestor(root->left, p, q);\\n    struct TreeNode* right = lowestCommonAncestor(root->right, p, q);\\n    \\n    if (left && right)\\n        return root\\n    else if (left)\\n        return left\\n    else if (right)\\n        return right\\n    else \\n        return NULL;\\n}\\n```\\n**Please UPVOTE if you LIKE**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nstruct TreeNode* lowestCommonAncestor(struct TreeNode* root, struct TreeNode* p, struct TreeNode* q) {\\n    if(root == p || root == q || !root) return root;   // found what we want or there is nothing\\n    struct TreeNode* left = lowestCommonAncestor(root->left, p, q);\\n    struct TreeNode* right = lowestCommonAncestor(root->right, p, q);\\n    return !left?right:!right?left:root;\\n}\\n```\n```\\nstruct TreeNode* lowestCommonAncestor(struct TreeNode* root, struct TreeNode* p, struct TreeNode* q) {\\n     \\n    // found what we want or there is nothing\\n    if(root == p || root == q || !root) \\n        return root;   // found what we want or there is nothing\\n    \\n    struct TreeNode* left = lowestCommonAncestor(root->left, p, q);\\n    struct TreeNode* right = lowestCommonAncestor(root->right, p, q);\\n    \\n    if (left && right)\\n        return root\\n    else if (left)\\n        return left\\n    else if (right)\\n        return right\\n    else \\n        return NULL;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1376663,
                "title": "c-solution-recursive-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if(root == NULL) return NULL;\\n        if(root->val < p->val && root->val < q->val){\\n            return lowestCommonAncestor(root->right, p, q);\\n        }\\n        if(root->val > p->val && root->val > q->val){\\n            return lowestCommonAncestor(root->left, p, q);\\n        }\\n        else \\n            return root;\\n    }\\n};\\n```\\nPlease Upvote if you like the solution  and comment if have doubts",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if(root == NULL) return NULL;\\n        if(root->val < p->val && root->val < q->val){\\n            return lowestCommonAncestor(root->right, p, q);\\n        }\\n        if(root->val > p->val && root->val > q->val){\\n            return lowestCommonAncestor(root->left, p, q);\\n        }\\n        else \\n            return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3356461,
                "title": "java-binary-tree-common-parent",
                "content": "\\n```\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if (root.val > p.val && root.val > q.val)\\n            return lowestCommonAncestor(root.left, p, q);\\n        if (root.val < p.val && root.val < q.val)\\n            return lowestCommonAncestor(root.right, p, q);\\n        else\\n            return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if (root.val > p.val && root.val > q.val)\\n            return lowestCommonAncestor(root.left, p, q);\\n        if (root.val < p.val && root.val < q.val)\\n            return lowestCommonAncestor(root.right, p, q);\\n        else\\n            return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1616289,
                "title": "very-simple-c-with-explanation",
                "content": "Solving the problem by following steps\\n(Kindly read the code (Bottom) then see the explanation)\\n1. if root value is null then definetely there will not be any element \\n`  if(root==nullptr)return nullptr;`\\n\\n2. if our root value matches with either of two nodes p or q then we\\'ll return the root bcoz definitely  \\n    any node value ancestor is root then other node will come below that root node.\\n\\t` if(root==p || root==q)return root;`\\n\\t\\n3. we\\'ll call both side of the current node and if both value comes as not null value that means\\n   below the current node both the nodes (p,q) comes\\n   ` TreeNode *LeftS=lowestCommonAncestor(root->left,p,q);`\\n  ` TreeNode *RightS=lowestCommonAncestor(root->right,p,q);`\\n  \\n\\t  ` if(LeftS !=nullptr && RightS!=nullptr)\\n            return root; `\\n   \\n4. if above condition is not satisfy then we\\'ll check which node returned as not null we\\'ll return that\\n`else if(LeftS!=nullptr)\\n            return LeftS;`\\n6.  5.  else vice versa as above (4.)point\\n\\t`else \\n            return RightS;`\\n\\n```\\nTreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if(root==nullptr)return nullptr;\\n        if(root==p || root==q)return root;\\n        \\n        TreeNode *LeftS=lowestCommonAncestor(root->left,p,q);\\n        TreeNode *RightS=lowestCommonAncestor(root->right,p,q);\\n        if(LeftS !=nullptr && RightS!=nullptr)\\n            return root; //in the both side of current root both p,q node exist\\n        \\n        else if(LeftS!=nullptr)\\n            return LeftS;\\n        else \\n            return RightS;\\n    }\\n```\\n\\uD83D\\uDE42 ***why you guys always forget to upvote, it motivates me to make such post.***\\n<a href=\"https://cutt.ly/KalyanChannel\"> \\uD83C\\uDFA1 **You Can Checkout The Youtube Channel Here \\u270B\\uD83C\\uDFFB** \\uD83C\\uDFA1  </a>",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nTreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if(root==nullptr)return nullptr;\\n        if(root==p || root==q)return root;\\n        \\n        TreeNode *LeftS=lowestCommonAncestor(root->left,p,q);\\n        TreeNode *RightS=lowestCommonAncestor(root->right,p,q);\\n        if(LeftS !=nullptr && RightS!=nullptr)\\n            return root; //in the both side of current root both p,q node exist\\n        \\n        else if(LeftS!=nullptr)\\n            return LeftS;\\n        else \\n            return RightS;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3825701,
                "title": "java-4-liner-100-fast-easy-solution",
                "content": "### We need to find the diverging point, the node at the diverging point will always be the common ancestor\\n\\n- As given tree is a BST, the diverging point can be determined by checking if both nodes are on the same side or not ie. both nodes are less than current node or greater than current node.\\n\\n- If any one node fails this condition, then we can be sure it is the diverging point and return that node\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N) auxilary space\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\n\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n     if(root == null) return root;\\n     if(root.val > p.val && root.val > q.val) return lowestCommonAncestor(root.left, p, q);\\n     else if(root.val < p.val && root.val < q.val) return lowestCommonAncestor(root.right, p, q);\\n     else return root;\\n    }\\n}\\n```\\n# PLEASE UPVOTE IF THIS WAS HELPFULL",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\n\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n     if(root == null) return root;\\n     if(root.val > p.val && root.val > q.val) return lowestCommonAncestor(root.left, p, q);\\n     else if(root.val < p.val && root.val < q.val) return lowestCommonAncestor(root.right, p, q);\\n     else return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1509931,
                "title": "java-100-fast-only-3-line-code-recursive-approach",
                "content": "class Solution {\\n\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if (p.val > root.val && q.val > root.val) return lowestCommonAncestor(root.right, p, q);\\n        else if (p.val < root.val && q.val < root.val) return lowestCommonAncestor(root.left, p, q);\\n        else return root;\\n    }\\n\\n}\\n**Please UpVote if you like the solution**",
                "solutionTags": [
                    "Java",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "class Solution {\\n\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if (p.val > root.val && q.val > root.val) return lowestCommonAncestor(root.right, p, q);\\n        else if (p.val < root.val && q.val < root.val) return lowestCommonAncestor(root.left, p, q);\\n        else return root;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 862386,
                "title": "simple-recursive-and-iterative-solution",
                "content": "```\\nfunc lowestCommonAncestor(root, p, q *TreeNode) *TreeNode {\\n\\tif p.Val < root.Val && q.Val < root.Val {\\n\\t\\treturn lowestCommonAncestor(root.Left, p, q)\\n\\t}\\n\\tif p.Val > root.Val && q.Val > root.Val {\\n\\t\\treturn lowestCommonAncestor(root.Right, p, q)\\n\\t}\\n\\treturn root\\n}\\n\\n```\\n\\n```\\nfunc lowestCommonAncestor(root, p, q *TreeNode) *TreeNode {\\n\\tfor root != nil {\\n\\t\\tif p.Val < root.Val && q.Val < root.Val {\\n\\t\\t\\troot = root.Left\\n\\t\\t}else if p.Val > root.Val && q.Val > root.Val {\\n\\t\\t\\troot = root.Right\\n\\t\\t}else {\\n\\t\\t\\treturn root\\n\\t\\t}\\n\\t}\\n\\treturn nil\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc lowestCommonAncestor(root, p, q *TreeNode) *TreeNode {\\n\\tif p.Val < root.Val && q.Val < root.Val {\\n\\t\\treturn lowestCommonAncestor(root.Left, p, q)\\n\\t}\\n\\tif p.Val > root.Val && q.Val > root.Val {\\n\\t\\treturn lowestCommonAncestor(root.Right, p, q)\\n\\t}\\n\\treturn root\\n}\\n\\n```\n```\\nfunc lowestCommonAncestor(root, p, q *TreeNode) *TreeNode {\\n\\tfor root != nil {\\n\\t\\tif p.Val < root.Val && q.Val < root.Val {\\n\\t\\t\\troot = root.Left\\n\\t\\t}else if p.Val > root.Val && q.Val > root.Val {\\n\\t\\t\\troot = root.Right\\n\\t\\t}else {\\n\\t\\t\\treturn root\\n\\t\\t}\\n\\t}\\n\\treturn nil\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 693896,
                "title": "python-explained-simple-solution",
                "content": "```\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        ## APPROACH : RECURSION ##\\n        ## LOGIC ##\\n        # Both p and q are smaller than current node, then search left-subtree by recursive\\n        # Both p and q are larger than current node, then search right-subtree by recursive\\n        # Both p and q are not on the same side of current node, then current node must be the Lowest common ancestor of ( p, q )\\n        \\n\\t\\t## TIME COMPLEXITY : O(N) ##\\n\\t\\t## SPACE COMPLEXITY : O(N) ##\\n\\n        cur_value = root.val\\n        if p.val > cur_value and q.val > cur_value:\\n            return self.lowestCommonAncestor( root.right, p, q)\\n        \\n        elif p.val < cur_value and q.val < cur_value:\\n            return self.lowestCommonAncestor( root.left, p, q)\\n        else:\\n            return root\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        ## APPROACH : RECURSION ##\\n        ## LOGIC ##\\n        # Both p and q are smaller than current node, then search left-subtree by recursive\\n        # Both p and q are larger than current node, then search right-subtree by recursive\\n        # Both p and q are not on the same side of current node, then current node must be the Lowest common ancestor of ( p, q )\\n        \\n\\t\\t## TIME COMPLEXITY : O(N) ##\\n\\t\\t## SPACE COMPLEXITY : O(N) ##\\n\\n        cur_value = root.val\\n        if p.val > cur_value and q.val > cur_value:\\n            return self.lowestCommonAncestor( root.right, p, q)\\n        \\n        elif p.val < cur_value and q.val < cur_value:\\n            return self.lowestCommonAncestor( root.left, p, q)\\n        else:\\n            return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 677460,
                "title": "javascript-recursive-iterative-solution",
                "content": "**Recursive:**\\n```\\nvar lowestCommonAncestor = function(root, p, q) {\\n    if(p.val > root.val && q.val > root.val) return lowestCommonAncestor(root.right, p, q);\\n    \\n    if(p.val < root.val && q.val < root.val) return lowestCommonAncestor(root.left, p , q);\\n    \\n    return root;\\n};\\n```\\n**Iterative:**\\n```\\nvar lowestCommonAncestor = function(root, p, q) {\\n    while(true){\\n        if(p.val < root.val && q.val < root.val) root = root.left;\\n\\n        else if(p.val > root.val && q.val > root.val) root = root.right;\\n\\n        else return root;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nvar lowestCommonAncestor = function(root, p, q) {\\n    if(p.val > root.val && q.val > root.val) return lowestCommonAncestor(root.right, p, q);\\n    \\n    if(p.val < root.val && q.val < root.val) return lowestCommonAncestor(root.left, p , q);\\n    \\n    return root;\\n};\\n```\n```\\nvar lowestCommonAncestor = function(root, p, q) {\\n    while(true){\\n        if(p.val < root.val && q.val < root.val) root = root.left;\\n\\n        else if(p.val > root.val && q.val > root.val) root = root.right;\\n\\n        else return root;\\n    }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 65092,
                "title": "3-lines-non-recursive-solution-in-java",
                "content": "    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        while(true){\\n          if((root.val-p.val)*(root.val-q.val) <= 0) return root;\\n          root = p.val < root.val ? root.left : root.right;\\n        }\\n    }",
                "solutionTags": [],
                "code": "    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        while(true){\\n          if((root.val-p.val)*(root.val-q.val) <= 0) return root;\\n          root = p.val < root.val ? root.left : root.right;\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2805318,
                "title": "java-runtime-4ms-faster-than-100-3-lines-o-1-space",
                "content": "```\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if (p.val < root.val && q.val < root.val) return lowestCommonAncestor(root.left, p, q);\\n        else if (p.val > root.val && q.val > root.val) return lowestCommonAncestor(root.right, p, q);\\n        else return root;\\n    }\\n}\\n```\\n\\n![image](https://assets.leetcode.com/users/images/2ac59181-46e4-4a4e-ba7e-3bc834430fb3_1668225339.6344059.png)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if (p.val < root.val && q.val < root.val) return lowestCommonAncestor(root.left, p, q);\\n        else if (p.val > root.val && q.val > root.val) return lowestCommonAncestor(root.right, p, q);\\n        else return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2236931,
                "title": "java-simple-explanation-with-tc-sc-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if(root == null) { //base condition\\n            return root;\\n        }\\n        \\n        //we use a while loop to traverse in the BST\\n        while(root != null) {\\n            \\n            //if the value of current node is greater than both the value then we go on the left side\\n            if(root.val > p.val && root.val > q.val) {\\n                root = root.left;\\n                \\n            //if the value of current node is lesser than both the value then we go on the right side\\n            } else if(root.val < p.val && root.val < q.val) {\\n                root = root.right;\\n                \\n            //if both the condition fails then it means that one node is on the left and the other node is on the right side, so in this case LCA will be the current node itself. So we break the loop and return the current node as LCA from line no 33\\n            } else {\\n                break;\\n            }\\n        }\\n        return root;\\n    }\\n}\\n\\n//Time Complexity: O(h), where h is the height of the tree.\\n//Space Complexity: Since we are not doing any recursive call, so space complexity is constant.\\n//Please upvote the solution if you like it",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if(root == null) { //base condition\\n            return root;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2185308,
                "title": "python3-simple-recursive-solution",
                "content": "```\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        if p is None or q is None:\\n            return None\\n        if root == p or root == q:\\n            return root\\n        if (root.left == p and root.right ==q) or (root.right == p and root.left == q):\\n            return root\\n        if p.val < root.val and q.val < root.val:\\n            return self.lowestCommonAncestor(root.left, p, q)\\n        elif p.val > root.val and q.val > root.val:\\n            return self.lowestCommonAncestor(root.right, p, q)\\n        \\n        return root\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        if p is None or q is None:\\n            return None\\n        if root == p or root == q:\\n            return root\\n        if (root.left == p and root.right ==q) or (root.right == p and root.left == q):\\n            return root\\n        if p.val < root.val and q.val < root.val:\\n            return self.lowestCommonAncestor(root.left, p, q)\\n        elif p.val > root.val and q.val > root.val:\\n            return self.lowestCommonAncestor(root.right, p, q)\\n        \\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 212409,
                "title": "its-simpler-than-you-think-javascript",
                "content": "The simple solution is to trace the tree looking for both P and Q at same time. As soon as your paths diverge, thats your LCA!\\n\\n``` \\nvar lowestCommonAncestor = function(root, p, q) {\\n    \\n    //set root as LCA\\n    //trace tree together\\n    //as soon as they diverge, thats LCA\\n    \\n    let lca = root    \\n    let current = root\\n    while (current != null) {\\n                lca = current\\n                console.log(\"adding \"+current.val)\\n                if (p.val > current.val && q.val > current.val) {\\n                    current = current.right                \\n                } else if (p.val < current.val && q.val < current.val) {             \\n                    current = current.left\\n                } else {\\n                    console.log(\"found! LCA is \"+lca.val) \\n                    break\\n                }\\n                \\n    } //while\\n    console.log(\"LCA is \"+lca.val) \\n    return lca\\n",
                "solutionTags": [],
                "code": "The simple solution is to trace the tree looking for both P and Q at same time. As soon as your paths diverge, thats your LCA!\\n\\n``` \\nvar lowestCommonAncestor = function(root, p, q) {\\n    \\n    //set root as LCA\\n    //trace tree together\\n    //as soon as they diverge, thats LCA\\n    \\n    let lca = root    \\n    let current = root\\n    while (current != null) {\\n                lca = current\\n                console.log(\"adding \"+current.val)\\n                if (p.val > current.val && q.val > current.val) {\\n                    current = current.right                \\n                } else if (p.val < current.val && q.val < current.val) {             \\n                    current = current.left\\n                } else {\\n                    console.log(\"found! LCA is \"+lca.val) \\n                    break\\n                }\\n                \\n    } //while\\n    console.log(\"LCA is \"+lca.val) \\n    return lca\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3165048,
                "title": "easy-java-recursion-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nYe sab nahi ata mujhe bro. Itna aata toh kamaal ho jaata\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\nYe bhi nahi aata\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\n\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if(root==q || root==p) return root;\\n        if(root.val<q.val && root.val>p.val) return root;\\n        if(root.val<q.val && root.val<p.val) return lowestCommonAncestor(root.right,p,q);\\n        if(root.val>q.val && root.val>p.val) return lowestCommonAncestor(root.left,p,q);\\n        else return root;    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\n\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if(root==q || root==p) return root;\\n        if(root.val<q.val && root.val>p.val) return root;\\n        if(root.val<q.val && root.val<p.val) return lowestCommonAncestor(root.right,p,q);\\n        if(root.val>q.val && root.val>p.val) return lowestCommonAncestor(root.left,p,q);\\n        else return root;    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2693726,
                "title": "an-easy-readable-and-understandable-solution",
                "content": "# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        \\n        // Both p and q are on the left\\n        if (p->val < root->val && q->val < root->val) {\\n            return lowestCommonAncestor(root->left, p, q);\\n        }\\n\\n        // Both p and q are on the right\\n        if (p->val > root->val && q->val > root->val) {\\n            return lowestCommonAncestor(root->right, p, q);\\n        }\\n\\n        // 1. p and q are on different sides\\n        // OR\\n        // 2. Either p or q is equal to the root\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        \\n        // Both p and q are on the left\\n        if (p->val < root->val && q->val < root->val) {\\n            return lowestCommonAncestor(root->left, p, q);\\n        }\\n\\n        // Both p and q are on the right\\n        if (p->val > root->val && q->val > root->val) {\\n            return lowestCommonAncestor(root->right, p, q);\\n        }\\n\\n        // 1. p and q are on different sides\\n        // OR\\n        // 2. Either p or q is equal to the root\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2413199,
                "title": "daily-leetcoding-challenge-august-day-12",
                "content": "This problem is the Daily LeetCoding Challenge for August, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive Approach\n\n  \n**Approach 2:** Iterative Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 2161853,
                "title": "java-recursive-solution-with-little-bit-intuition-clearly-explained",
                "content": "Explanation:\\nGiven tree is a binary search tree. And if you go through the constraints then its given that both nodes P and Q will be present and they are not equal i.e. P != Q.\\nThis means we don\\'t need to check the null condition because we will never touch the leaf node as the nodes will always be available. We don\\'t need to check the equality also (I will explain why), hence in the worst case we need to traverse just before the leaf node.\\n\\nSince this is a BST, we have three cases to handle.\\n1. P and Q fall on same side of the root (either both left or both right)\\n2. P and Q fall on opposite sides of the root (either P left Q right or vice versa).\\n3. Either P or Q matches the root.\\n\\nWe do a recursive DFS starting from the root node. \\n1. If P and Q fall on opposite sides, then current root is the LCA. Because this is the lowest common point you can reach both points. We dont need to recur further and return.\\n2. If either P or Q matches the root then the current root is LCA because the other will be child of the current node. Hence we dont recur further and return.\\n3. If they fall on same side of the current root, then we recur left or right depending on the points.\\n\\nPlease give your comments and upvote if it helps.\\n\\n```\\n\\tpublic TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if ( p.val < root.val && q.val < root.val ) return this.lowestCommonAncestor(root.left, p, q);\\n        if ( p.val > root.val && q.val > root.val ) return this.lowestCommonAncestor(root.right, p, q);\\n        return root;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n\\tpublic TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if ( p.val < root.val && q.val < root.val ) return this.lowestCommonAncestor(root.left, p, q);\\n        if ( p.val > root.val && q.val > root.val ) return this.lowestCommonAncestor(root.right, p, q);\\n        return root;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 322190,
                "title": "python-very-simple-iterative-solution-faster-than-99",
                "content": "```\\nclass Solution(object):\\n    def lowestCommonAncestor(self, root, p, q):\\n        while True:\\n            if p.val <= root.val <= q.val or q.val <= root.val <= p.val:\\n                return root \\n            if p.val > root.val and q.val > root.val:\\n                root = root.right\\n            elif p.val < root.val and q.val < root.val:\\n                root = root.left\\n```",
                "solutionTags": [
                    "Python",
                    "Iterator"
                ],
                "code": "```\\nclass Solution(object):\\n    def lowestCommonAncestor(self, root, p, q):\\n        while True:\\n            if p.val <= root.val <= q.val or q.val <= root.val <= p.val:\\n                return root \\n            if p.val > root.val and q.val > root.val:\\n                root = root.right\\n            elif p.val < root.val and q.val < root.val:\\n                root = root.left\\n```",
                "codeTag": "Java"
            },
            {
                "id": 65072,
                "title": "simple-java-solution",
                "content": "    /**\\n     * Definition for a binary tree node.\\n     * public class TreeNode {\\n     *     int val;\\n     *     TreeNode left;\\n     *     TreeNode right;\\n     *     TreeNode(int x) { val = x; }\\n     * }\\n     */\\n    public class Solution {\\n        public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n            if (p == null || q == null || root == null){\\n                return null;\\n            }\\n            if (p.val < root.val && q.val < root.val){\\n                return lowestCommonAncestor (root.left, p , q);\\n            }\\n            else if (p.val > root.val && q.val > root.val){\\n                return lowestCommonAncestor (root.right, p , q);\\n            }\\n            else {\\n                return root;\\n            }\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n            if (p == null || q == null || root == null){\\n                return null;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 65083,
                "title": "1-line-solution-java",
                "content": "If both p and q in same direction (less or greater than), then change the root to its child in that direction. otherwise for all other cases it has to be the root.    \\n  \\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        return (p.val<root.val && q.val<root.val) ? lowestCommonAncestor(root.left,p,q) : (p.val>root.val && q.val>root.val) ? lowestCommonAncestor(root.right,p,q) : root;\\n        }",
                "solutionTags": [
                    "Binary Search",
                    "Tree"
                ],
                "code": "If both p and q in same direction (less or greater than), then change the root to its child in that direction. otherwise for all other cases it has to be the root.    \\n  \\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        return (p.val<root.val && q.val<root.val) ? lowestCommonAncestor(root.left,p,q) : (p.val>root.val && q.val>root.val) ? lowestCommonAncestor(root.right,p,q) : root;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 2827050,
                "title": "python-easy-solution",
                "content": "\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        curr=root\\n        while curr:\\n            if p.val>curr.val and q.val>curr.val:\\n                curr=curr.right\\n            elif p.val<curr.val and q.val<curr.val:\\n                curr=curr.left\\n            else:\\n                return curr\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        curr=root\\n        while curr:\\n            if p.val>curr.val and q.val>curr.val:\\n                curr=curr.right\\n            elif p.val<curr.val and q.val<curr.val:\\n                curr=curr.left\\n            else:\\n                return curr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2704717,
                "title": "python-easy-way-to-find-lowest-common-ancestor-of-a-binary-search-tree-96-faster",
                "content": "**IF YOU FIND THIS POST HELPFUL PLEASE UPVOTE \\uD83D\\uDC4D**\\n\\n```\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        curr = root\\n        \\n        while curr:\\n            if p.val>curr.val and q.val>curr.val:\\n                curr = curr.right\\n            elif p.val<curr.val and q.val<curr.val:\\n                curr = curr.left\\n            else:\\n                return curr\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        curr = root\\n        \\n        while curr:\\n            if p.val>curr.val and q.val>curr.val:\\n                curr = curr.right\\n            elif p.val<curr.val and q.val<curr.val:\\n                curr = curr.left\\n            else:\\n                return curr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2704082,
                "title": "store-parent-path-last-common-node",
                "content": "```\\n#define ff              first\\n#define ss              second\\n#define pb              push_back\\n#define mp              make_pair\\n#define mt              make_tuple\\n#define pii             pair<int,int>\\n#define vi              vector<int>\\n#define mii             map<int,int>\\n#define FIO             ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0)\\nconst int N = 1e5 + 10;\\n\\nclass Solution\\n{\\npublic:\\n    map<int, list<int>> g;\\n    mii par;\\n    vi x_path;\\n    vi y_path;\\n    void dfs(int src, int parent)\\n    {\\n        par[src] = parent;\\n        for (auto nbr : g[src])\\n        {\\n            if (nbr != parent)\\n            {\\n                dfs(nbr, src);\\n            }\\n        }\\n    }\\n    vi findPath(int node)\\n    {\\n        vi path;\\n        int parent = par[node];\\n        path.pb(node);\\n        while (parent != -1)\\n        {\\n            path.pb(parent);\\n            parent = par[parent];\\n        }\\n        reverse(path.begin(), path.end());\\n        return path;\\n    }\\n    TreeNode *reqNode(TreeNode *root, int data)\\n    {\\n        if (root == NULL)\\n            return NULL;\\n        if (root->val == data)\\n            return root;\\n        TreeNode *l = reqNode(root->left, data);\\n        TreeNode *r = reqNode(root->right, data);\\n        return l == NULL ? r : l;\\n    }\\n    TreeNode *lowestCommonAncestor(TreeNode *root, TreeNode *x, TreeNode *y)\\n    {\\n        FIO;\\n        queue<TreeNode *> q;\\n        q.push(root);\\n        while (!q.empty())\\n        {\\n            auto f = q.front();\\n            q.pop();\\n            int u = f->val;\\n            if (f->left != NULL)\\n            {\\n                int v = f->left->val;\\n                g[u].push_back(v);\\n                q.push(f->left);\\n            }\\n            if (f->right != NULL)\\n            {\\n                int v = f->right->val;\\n                g[u].push_back(v);\\n                q.push(f->right);\\n            }\\n        }\\n        dfs(root->val, -1);\\n        x_path = findPath(x->val);\\n        y_path = findPath(y->val);\\n        int lca = -1;\\n        int mn = min(x_path.size(), y_path.size());\\n        for (int i = 0; i < mn; i++)\\n        {\\n            if (x_path[i] == y_path[i])\\n            {\\n                lca = x_path[i];\\n            }\\n            else\\n            {\\n                break;\\n            }\\n        }\\n\\n        return reqNode(root, lca);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\n#define ff              first\\n#define ss              second\\n#define pb              push_back\\n#define mp              make_pair\\n#define mt              make_tuple\\n#define pii             pair<int,int>\\n#define vi              vector<int>\\n#define mii             map<int,int>\\n#define FIO             ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0)\\nconst int N = 1e5 + 10;\\n\\nclass Solution\\n{\\npublic:\\n    map<int, list<int>> g;\\n    mii par;\\n    vi x_path;\\n    vi y_path;\\n    void dfs(int src, int parent)\\n    {\\n        par[src] = parent;\\n        for (auto nbr : g[src])\\n        {\\n            if (nbr != parent)\\n            {\\n                dfs(nbr, src);\\n            }\\n        }\\n    }\\n    vi findPath(int node)\\n    {\\n        vi path;\\n        int parent = par[node];\\n        path.pb(node);\\n        while (parent != -1)\\n        {\\n            path.pb(parent);\\n            parent = par[parent];\\n        }\\n        reverse(path.begin(), path.end());\\n        return path;\\n    }\\n    TreeNode *reqNode(TreeNode *root, int data)\\n    {\\n        if (root == NULL)\\n            return NULL;\\n        if (root->val == data)\\n            return root;\\n        TreeNode *l = reqNode(root->left, data);\\n        TreeNode *r = reqNode(root->right, data);\\n        return l == NULL ? r : l;\\n    }\\n    TreeNode *lowestCommonAncestor(TreeNode *root, TreeNode *x, TreeNode *y)\\n    {\\n        FIO;\\n        queue<TreeNode *> q;\\n        q.push(root);\\n        while (!q.empty())\\n        {\\n            auto f = q.front();\\n            q.pop();\\n            int u = f->val;\\n            if (f->left != NULL)\\n            {\\n                int v = f->left->val;\\n                g[u].push_back(v);\\n                q.push(f->left);\\n            }\\n            if (f->right != NULL)\\n            {\\n                int v = f->right->val;\\n                g[u].push_back(v);\\n                q.push(f->right);\\n            }\\n        }\\n        dfs(root->val, -1);\\n        x_path = findPath(x->val);\\n        y_path = findPath(y->val);\\n        int lca = -1;\\n        int mn = min(x_path.size(), y_path.size());\\n        for (int i = 0; i < mn; i++)\\n        {\\n            if (x_path[i] == y_path[i])\\n            {\\n                lca = x_path[i];\\n            }\\n            else\\n            {\\n                break;\\n            }\\n        }\\n\\n        return reqNode(root, lca);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2662502,
                "title": "simple-o-h-recursive-iterative-solutions",
                "content": "**Recursive Solution**\\n```\\ndef lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n\\tif root.val > p.val and root.val > q.val: #if the root is bigger than both nodes \\n\\t\\treturn self.lowestCommonAncestor(root.left,p,q) #both nodes must be to the left of root\\n\\telif root.val < p.val and root.val < q.val: #if the root is smaller than both nodes\\n\\t\\treturn self.lowestCommonAncestor(root.right,p,q) #both nodes must be to the right of the root\\n\\treturn root #otherwise the nodes are on either side of the root or one of the nodes is the root, so we return the root\\n```\\n\\n**Iterative Solution**\\n```\\ndef lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n\\twhile True:\\n\\t\\tif root.val > p.val and root.val > q.val: #if the root is bigger than both nodes \\n\\t\\t\\troot = root.left\\n\\t\\telif root.val < p.val and root.val < q.val: #if the root is smaller than both nodes\\n\\t\\t\\troot = root.right #both nodes must be to the right of the root\\n\\t\\telse: #otherwise the nodes are on either side of the root or one of the nodes is the root, so we return the root\\n\\t\\t\\treturn root \\n```\\n\\nThese two solutions use the same insight, which is that we need to take advantage of the fact this is a binary search tree. This means that the tree has the property that, for some node ```node``` with two descendents, ```node.left.val < node.val < node.right.val```. The lowest common ancestor of the two nodes will either be a node such that ```node.val == p.val``` or ```node.val == q.val```, or a node such that ```p``` and ```q``` are on either side of it --> ```p.val < node.val < q.val``` or ```q.val < node.val < p.val```. Therefore, we just need to figure out what to do if neither of those things are true. If ```node.val > p.val and node.val > q.val```, both nodes have a smaller value than ```node```, which means that they must be to the left in our tree. Similarly, if ```node.val < p.val and node.val < q.val```, then both nodes have a bigger value than ```node```, so they must be to the right in our tree. The way we move to the right or left is slightly different between the recursive and iterative solutions, but it functions the exact same. This solution is ```O(H)```, where ```H``` is the height of the tree, since it would only ever need to look at one path down the tree. \\n\\nP.S. we use ```while True``` for the iterative solution because we are guaranteed in the problem that ```p``` and ```q``` will exist in the tree. If we were not given this information and wanted to handle the possibility that one or both of the nodes did not exist in the tree, then we could use ```while root``` and add some logic for what happens after breaking out of the ```while``` loop (when we finished looking through the tree.\\n\\n**Thanks for Reading!**\\nIf this post has been helpful, please consider upvoting! Also, if I made any mistakes or there are other optimizations, methods I didn\\'t consider, etc. please let me know!",
                "solutionTags": [
                    "Python",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\ndef lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n\\tif root.val > p.val and root.val > q.val: #if the root is bigger than both nodes \\n\\t\\treturn self.lowestCommonAncestor(root.left,p,q) #both nodes must be to the left of root\\n\\telif root.val < p.val and root.val < q.val: #if the root is smaller than both nodes\\n\\t\\treturn self.lowestCommonAncestor(root.right,p,q) #both nodes must be to the right of the root\\n\\treturn root #otherwise the nodes are on either side of the root or one of the nodes is the root, so we return the root\\n```\n```\\ndef lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n\\twhile True:\\n\\t\\tif root.val > p.val and root.val > q.val: #if the root is bigger than both nodes \\n\\t\\t\\troot = root.left\\n\\t\\telif root.val < p.val and root.val < q.val: #if the root is smaller than both nodes\\n\\t\\t\\troot = root.right #both nodes must be to the right of the root\\n\\t\\telse: #otherwise the nodes are on either side of the root or one of the nodes is the root, so we return the root\\n\\t\\t\\treturn root \\n```\n```node```\n```node.left.val < node.val < node.right.val```\n```node.val == p.val```\n```node.val == q.val```\n```p```\n```q```\n```p.val < node.val < q.val```\n```q.val < node.val < p.val```\n```node.val > p.val and node.val > q.val```\n```node```\n```node.val < p.val and node.val < q.val```\n```node```\n```O(H)```\n```H```\n```while True```\n```p```\n```q```\n```while root```\n```while```",
                "codeTag": "Python3"
            },
            {
                "id": 2413953,
                "title": "4-line-simple-solution-c",
                "content": "**Time Complexity : O(h) (h is height of tree)\\nSpace Complexity : O(h) (Recursive stack calls)**\\n```\\n \\n        if(root == p || root == q)return root;\\n        if(root->val > min(p->val,q->val) && root->val < max(q->val,p->val))return root;\\n        if(root->val > max(q->val,p->val))return lowestCommonAncestor(root->left,p,q);\\n        return lowestCommonAncestor(root->right,p,q);\\n        \\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n \\n        if(root == p || root == q)return root;\\n        if(root->val > min(p->val,q->val) && root->val < max(q->val,p->val))return root;\\n        if(root->val > max(q->val,p->val))return lowestCommonAncestor(root->left,p,q);\\n        return lowestCommonAncestor(root->right,p,q);\\n        \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1348197,
                "title": "c-solution-iterative-and-recursive",
                "content": "**Iterative**\\n```csharp\\npublic TreeNode LowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q)\\n{\\n\\twhile (root != null)\\n\\t{\\n\\t\\tif (root.val > p.val && root.val > q.val)\\n\\t\\t\\troot = root.left;\\n\\t\\telse if (root.val < p.val && root.val < q.val)\\n\\t\\t\\troot = root.right;\\n\\t\\telse\\n\\t\\t\\tbreak;\\n\\t}\\n\\n\\treturn root;\\n}\\n```\\n\\n**Recursive**\\n\\n```csharp\\npublic TreeNode LowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q)\\n{\\n\\tif (root == null) return null;\\n\\n\\tif (root.val < p.val && root.val < q.val)\\n\\t\\treturn LowestCommonAncestor(root.right, p, q);\\n\\telse if (root.val > p.val && root.val > q.val)\\n\\t\\treturn LowestCommonAncestor(root.left, p, q);\\n\\n\\treturn root;\\n}\\n```",
                "solutionTags": [
                    "Recursion",
                    "Binary Tree",
                    "Iterator"
                ],
                "code": "```csharp\\npublic TreeNode LowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q)\\n{\\n\\twhile (root != null)\\n\\t{\\n\\t\\tif (root.val > p.val && root.val > q.val)\\n\\t\\t\\troot = root.left;\\n\\t\\telse if (root.val < p.val && root.val < q.val)\\n\\t\\t\\troot = root.right;\\n\\t\\telse\\n\\t\\t\\tbreak;\\n\\t}\\n\\n\\treturn root;\\n}\\n```\n```csharp\\npublic TreeNode LowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q)\\n{\\n\\tif (root == null) return null;\\n\\n\\tif (root.val < p.val && root.val < q.val)\\n\\t\\treturn LowestCommonAncestor(root.right, p, q);\\n\\telse if (root.val > p.val && root.val > q.val)\\n\\t\\treturn LowestCommonAncestor(root.left, p, q);\\n\\n\\treturn root;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 173855,
                "title": "javascript-solution",
                "content": "```\\n// Lowest Common Ancestor must sit between p and q\\n// p < Lowest Common Ancestor < q\\nvar lowestCommonAncestor = (root, p, q) => {\\n  // Lowest Common Ancestor bigger than both p and q so we move left\\n  if (p.val < root.val && q.val < root.val) {\\n    return lowestCommonAncestor(root.left, p, q);\\n  }\\n  // Lowest Common Ancestor small than both p and q so we move right\\n  if (p.val > root.val && q.val > root.val) {\\n    return lowestCommonAncestor(root.right, p, q);\\n  }\\n  return root;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n// Lowest Common Ancestor must sit between p and q\\n// p < Lowest Common Ancestor < q\\nvar lowestCommonAncestor = (root, p, q) => {\\n  // Lowest Common Ancestor bigger than both p and q so we move left\\n  if (p.val < root.val && q.val < root.val) {\\n    return lowestCommonAncestor(root.left, p, q);\\n  }\\n  // Lowest Common Ancestor small than both p and q so we move right\\n  if (p.val > root.val && q.val > root.val) {\\n    return lowestCommonAncestor(root.right, p, q);\\n  }\\n  return root;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 65108,
                "title": "javascript-solution-if-anyone-is-interested",
                "content": "    var lowestCommonAncestor = function(root, p, q) {\\n        if (p.val < root.val && q.val < root.val) {\\n            return lowestCommonAncestor(root.left, p, q);\\n        }\\n        else if (p.val > root.val && q.val > root.val) {\\n            return lowestCommonAncestor(root.right, p, q);\\n        }\\n        else {\\n            return root;\\n        }\\n    };",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "    var lowestCommonAncestor = function(root, p, q) {\\n        if (p.val < root.val && q.val < root.val) {\\n            return lowestCommonAncestor(root.left, p, q);\\n        }\\n        else if (p.val > root.val && q.val > root.val) {\\n            return lowestCommonAncestor(root.right, p, q);\\n        }\\n        else {\\n            return root;\\n        }\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 64995,
                "title": "java-method-spends-10ms",
                "content": "public class LowestCommonAncestorofaBinarySearchTree {\\n\\n\\tpublic static TreeNode lowestCommonAncestor(TreeNode root, TreeNode p,\\n\\t\\t\\tTreeNode q) {\\n\\t\\tint min = p.val, max = q.val;\\n\\t\\tif (min > max) {\\n\\t\\t\\tmin = q.val;\\n\\t\\t\\tmax = p.val;\\n\\t\\t}\\n\\t\\twhile (true) {\\n\\t\\t\\tif (root.val < min)\\n\\t\\t\\t\\troot = root.right;\\n\\t\\t\\telse if (root.val > max)\\n\\t\\t\\t\\troot = root.left;\\n\\t\\t\\telse\\n\\t\\t\\t\\treturn root;\\n\\t\\t}\\n\\t}\\n}\\n\\n\\nplease, who can tell me a less-than-10ms method",
                "solutionTags": [
                    "Java",
                    "Iterator"
                ],
                "code": "public class LowestCommonAncestorofaBinarySearchTree {\\n\\n\\tpublic static TreeNode lowestCommonAncestor(TreeNode root, TreeNode p,\\n\\t\\t\\tTreeNode q) {\\n\\t\\tint min = p.val, max = q.val;\\n\\t\\tif (min > max) {\\n\\t\\t\\tmin = q.val;\\n\\t\\t\\tmax = p.val;\\n\\t\\t}\\n\\t\\twhile (true) {\\n\\t\\t\\tif (root.val < min)\\n\\t\\t\\t\\troot = root.right;\\n\\t\\t\\telse if (root.val > max)\\n\\t\\t\\t\\troot = root.left;\\n\\t\\t\\telse\\n\\t\\t\\t\\treturn root;\\n\\t\\t}\\n\\t}\\n}\\n\\n\\nplease, who can tell me a less-than-10ms method",
                "codeTag": "Java"
            },
            {
                "id": 65125,
                "title": "my-40ms-c-solution",
                "content": "    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n            if(!root) return root;\\n        \\n        \\tif((root->val - p->val)*(root->val - q->val)<=0) return root;\\n\\n        \\tif((root->val - p->val)>0 && (root->val - q->val)>0) return lowestCommonAncestor(root->left,p,q);\\n\\n        \\tif((root->val - p->val)<0 && (root->val - q->val)<0) return lowestCommonAncestor(root->right,p,q);\\n        \\n        }",
                "solutionTags": [],
                "code": "    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n            if(!root) return root;\\n        \\n        \\tif((root->val - p->val)*(root->val - q->val)<=0) return root;\\n\\n        \\tif((root->val - p->val)>0 && (root->val - q->val)>0) return lowestCommonAncestor(root->left,p,q);\\n\\n        \\tif((root->val - p->val)<0 && (root->val - q->val)<0) return lowestCommonAncestor(root->right,p,q);\\n        \\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 65167,
                "title": "python-easy-to-understand-recursive-solution-with-comments",
                "content": "\\n    def lowestCommonAncestor(self, root, p, q):\\n        if not root:\\n            return \\n        # p and q are on the different side of root,\\n        # or at least one of them is root\\n        if (root.val-p.val)*(root.val-q.val)<=0:\\n            return root\\n        # both p and q are on the left side of root\\n        elif root.val > p.val and root.val > q.val:\\n            return self.lowestCommonAncestor(root.left, p, q)\\n        # both p and q are on the right side of root\\n        else:\\n            return self.lowestCommonAncestor(root.right, p, q)\\n\\t\\t\\t\\n\\tdef lowestCommonAncestor(self, root, p, q):\\n        if not root:\\n            return root\\n        if (root.val-p.val)*(root.val-q.val) <= 0:\\n            return root\\n        node = root.left if (root.val > p.val and root.val > q.val) else root.right\\n        return self.lowestCommonAncestor(node, p, q)",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "\\n    def lowestCommonAncestor(self, root, p, q):\\n        if not root:\\n            return \\n        # p and q are on the different side of root,\\n        # or at least one of them is root\\n        if (root.val-p.val)*(root.val-q.val)<=0:\\n            return root\\n        # both p and q are on the left side of root\\n        elif root.val > p.val and root.val > q.val:\\n            return self.lowestCommonAncestor(root.left, p, q)\\n        # both p and q are on the right side of root\\n        else:\\n            return self.lowestCommonAncestor(root.right, p, q)\\n\\t\\t\\t\\n\\tdef lowestCommonAncestor(self, root, p, q):\\n        if not root:\\n            return root\\n        if (root.val-p.val)*(root.val-q.val) <= 0:\\n            return root\\n        node = root.left if (root.val > p.val and root.val > q.val) else root.right\\n        return self.lowestCommonAncestor(node, p, q)",
                "codeTag": "Python3"
            },
            {
                "id": 65188,
                "title": "my-accepted-java-solution",
                "content": "    public class Solution {\\n        public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n             if(root==null)\\n            \\t return null;\\n             if(p.val<root.val&&q.val<root.val)\\n             {\\n            \\t return lowestCommonAncestor(root.left,p,q);\\n             }\\n             if(p.val>root.val&&q.val>root.val)\\n             {\\n            \\t return lowestCommonAncestor(root.right,p,q);\\n             }else{\\n            \\t \\n            \\t return root;\\n             }\\n    \\t}\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n             if(root==null)\\n            \\t return null;\\n             if(p.val<root.val&&q.val<root.val)\\n             {\\n            \\t return lowestCommonAncestor(root.left,p,q);\\n             }",
                "codeTag": "Java"
            },
            {
                "id": 65194,
                "title": "accepted-c-recursive-solution",
                "content": "well, it's too simple to explain,just make use of BST\\n\\n    struct TreeNode* lowestCommonAncestor(struct TreeNode* root, struct TreeNode* p, struct TreeNode* q) {\\n        \\n        \\tif (p->val<root->val && q->val<root->val)\\n        \\t\\treturn lowestCommonAncestor(root->left,p,q);\\n        \\tif (p->val>root->val && q->val>root->val)\\n        \\t\\treturn lowestCommonAncestor(root->right,p,q);\\n        \\treturn root;\\n        }",
                "solutionTags": [],
                "code": "well, it's too simple to explain,just make use of BST\\n\\n    struct TreeNode* lowestCommonAncestor(struct TreeNode* root, struct TreeNode* p, struct TreeNode* q) {\\n        \\n        \\tif (p->val<root->val && q->val<root->val)\\n        \\t\\treturn lowestCommonAncestor(root->left,p,q);\\n        \\tif (p->val>root->val && q->val>root->val)\\n        \\t\\treturn lowestCommonAncestor(root->right,p,q);\\n        \\treturn root;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 65199,
                "title": "java-python-3-iterative-and-recursive-codes-w-brief-comments-and-analysis",
                "content": "**Iterative code**\\n\\n```java\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        while (((long)root.val - p.val) * ((long)root.val - q.val) > 0) { // root.val is not between p.val and q.val.\\n            root = root.val > p.val ? root.left : root.right; // search LCA.\\n        }\\n        return root; // found.\\n    }\\n```\\n```python\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        while (root.val - p.val )  * (root.val - q.val) > 0:\\n            root = root.left if root.val > p.val else root.right\\n        return root \\n```\\n**Analysis:**\\nTime: Average `O(logn)` worst `O(n)`, space: `O(1)`.\\n\\n----\\n\\n**Recursive code**\\n\\n```java\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if (p.val > q.val) {\\n            // make sure the 2nd argument < the 3rd.\\n            return lowestCommonAncestor(root, q, p);\\n        }\\n        if (root.val < p.val) { // root.val is not between p.val and q.val.\\n            return lowestCommonAncestor(root.right, p, q); // search LCA.\\n        }else if (root.val > q.val) { // root.val is not between p.val and q.val.\\n            return lowestCommonAncestor(root.left, p, q); // search LCA.\\n        }\\n        return root; // found.\\n    }\\n```\\n```python\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        if p.val > q.val:\\n            return self.lowestCommonAncestor(root, q, p)\\n        if root.val > q.val:\\n            return self.lowestCommonAncestor(root.left, p, q)\\n        elif root.val < p.val:\\n            return self.lowestCommonAncestor(root.right, p, q)\\n        return root\\n```\\n**Analysis:**\\n\\nTime & space: average `O(logn)`, worst `O(n)`.\\n\\n-----\\n\\n**The following are oblelete content and just for my own reference**\\n\\nA robust and flexible code should consider corner cases, such as:\\n\\n1) at least one of *root, p,* and *q* is null;\\n\\n2) at least one of *p & q* is not a node in the tree rooted at *root*.\\n\\nThe following code with *lgn* average time complexity can deal with above corner cases. \\n\\n        private boolean binarySearch(TreeNode t, TreeNode n){\\n        if(t==null) return false;\\n        if(t.val == n.val) return true;\\n        return n.val<t.val? \\n                binarySearch(t.left, n) : \\n                binarySearch(t.right, n);\\n        }\\n        public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n          if(root==null || p==null || q==null || \\n              !binarySearch(root, p) || !binarySearch(root, q)) \\n                  return null;\\n          if(p.val == q.val) return p;\\n          TreeNode r = root;\\n          while((p.val-r.val)*(q.val-r.val) > 0)\\n              r = p.val<r.val? r.left : r.right;\\n          return r;\\n        }\\n\\n\\n  [1]: https://leetcode.com/discuss/44946/my-java-solution",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```java\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        while (((long)root.val - p.val) * ((long)root.val - q.val) > 0) { // root.val is not between p.val and q.val.\\n            root = root.val > p.val ? root.left : root.right; // search LCA.\\n        }\\n        return root; // found.\\n    }\\n```\n```python\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        while (root.val - p.val )  * (root.val - q.val) > 0:\\n            root = root.left if root.val > p.val else root.right\\n        return root \\n```\n```java\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if (p.val > q.val) {\\n            // make sure the 2nd argument < the 3rd.\\n            return lowestCommonAncestor(root, q, p);\\n        }\\n        if (root.val < p.val) { // root.val is not between p.val and q.val.\\n            return lowestCommonAncestor(root.right, p, q); // search LCA.\\n        }else if (root.val > q.val) { // root.val is not between p.val and q.val.\\n            return lowestCommonAncestor(root.left, p, q); // search LCA.\\n        }\\n        return root; // found.\\n    }\\n```\n```python\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        if p.val > q.val:\\n            return self.lowestCommonAncestor(root, q, p)\\n        if root.val > q.val:\\n            return self.lowestCommonAncestor(root.left, p, q)\\n        elif root.val < p.val:\\n            return self.lowestCommonAncestor(root.right, p, q)\\n        return root\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3423810,
                "title": "java-easiest-solution-ever",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(h) where h is the height of the tree\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(N)\\n![Screenshot_20230205_171246.png](https://assets.leetcode.com/users/images/cd920865-22d7-476a-ac9d-772053c6a946_1681655015.8161445.png)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\n\\nclass Solution {\\n    \\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        \\n        // If the root is null, then there is no LCA, so return null.\\n        if(root == null){\\n            return root;\\n        }\\n\\n        // Get the value of the current node.\\n        int cur = root.val;\\n\\n        // If both p and q are greater than the current node, then the LCA is in the right subtree.\\n        if(cur < p.val && cur < q.val){\\n            return lowestCommonAncestor(root.right, p, q); // Recurse on the right subtree.\\n        }\\n        // If both p and q are less than the current node, then the LCA is in the left subtree.\\n        if(cur > p.val && cur > q.val){\\n            return lowestCommonAncestor(root.left, p, q); // Recurse on the left subtree.\\n        }\\n        // Otherwise, the current node is the LCA.\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\n\\nclass Solution {\\n    \\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        \\n        // If the root is null, then there is no LCA, so return null.\\n        if(root == null){\\n            return root;\\n        }\\n\\n        // Get the value of the current node.\\n        int cur = root.val;\\n\\n        // If both p and q are greater than the current node, then the LCA is in the right subtree.\\n        if(cur < p.val && cur < q.val){\\n            return lowestCommonAncestor(root.right, p, q); // Recurse on the right subtree.\\n        }\\n        // If both p and q are less than the current node, then the LCA is in the left subtree.\\n        if(cur > p.val && cur > q.val){\\n            return lowestCommonAncestor(root.left, p, q); // Recurse on the left subtree.\\n        }\\n        // Otherwise, the current node is the LCA.\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3272679,
                "title": "best-o-h-solution",
                "content": "# Approach 1\\nRecursive Approach\\n\\n# Complexity\\n- Time complexity:\\n$$O(h)$$ --> h is height of the BST\\n\\n- Space complexity:\\n$$O(h)$$ --> h is height of the BST\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if (root == NULL || p->val == root->val || q->val == root->val)\\n            return root;\\n        if (p->val < root->val && q->val < root->val)\\n                return lowestCommonAncestor(root->left, p, q);\\n        if (p->val > root->val && q->val > root->val)\\n                return lowestCommonAncestor(root->right, p, q); \\n        return root;\\n    }\\n};\\n```\\n\\n# Approach 2\\nIterative Approach\\n\\n# Complexity\\n- Time complexity:\\n$$O(h)$$ --> h is height of the BST\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        while (true) {\\n            if ((p->val <= root->val && q->val >= root->val) || (p->val >= root->val && q->val <= root->val))\\n                return root;\\n            if (p->val < root->val && q->val < root->val)\\n                root = root->left;\\n            else\\n                root = root->right;        \\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if (root == NULL || p->val == root->val || q->val == root->val)\\n            return root;\\n        if (p->val < root->val && q->val < root->val)\\n                return lowestCommonAncestor(root->left, p, q);\\n        if (p->val > root->val && q->val > root->val)\\n                return lowestCommonAncestor(root->right, p, q); \\n        return root;\\n    }\\n};\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        while (true) {\\n            if ((p->val <= root->val && q->val >= root->val) || (p->val >= root->val && q->val <= root->val))\\n                return root;\\n            if (p->val < root->val && q->val < root->val)\\n                root = root->left;\\n            else\\n                root = root->right;        \\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3249910,
                "title": "very-easy-solution-python-uwu",
                "content": "\\n```\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        while root:\\n            if p.val < root.val > q.val:\\n                root = root.left\\n            elif p.val > root.val < q.val:\\n                root = root.right\\n            else:\\n                return root\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        while root:\\n            if p.val < root.val > q.val:\\n                root = root.left\\n            elif p.val > root.val < q.val:\\n                root = root.right\\n            else:\\n                return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3222242,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        int current = root->val;\\n        if(p->val < current && q->val < current) {\\n            return lowestCommonAncestor(root->left, p, q);\\n        }\\n        else if(p->val > current && q->val > current) {\\n            return lowestCommonAncestor(root->right, p, q);\\n        }\\n        else{\\n            return root;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        int current = root->val;\\n        if(p->val < current && q->val < current) {\\n            return lowestCommonAncestor(root->left, p, q);\\n        }\\n        else if(p->val > current && q->val > current) {\\n            return lowestCommonAncestor(root->right, p, q);\\n        }\\n        else{\\n            return root;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2977966,
                "title": "python-easy-simple-dfs-solution-100-fast",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        if not root:\\n            return None\\n        if root.val == p.val:\\n            return p\\n        elif root.val == q.val:\\n            return q \\n        # condition when the root is the shared parent of node p and q\\n        elif root.val < max(p.val, q.val) and root.val > min(p.val, q.val):\\n            return root\\n        \\n        return self.lowestCommonAncestor(root.left, p, q) or self.lowestCommonAncestor(root.right, p, q)\\n        \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        if not root:\\n            return None\\n        if root.val == p.val:\\n            return p\\n        elif root.val == q.val:\\n            return q \\n        # condition when the root is the shared parent of node p and q\\n        elif root.val < max(p.val, q.val) and root.val > min(p.val, q.val):\\n            return root\\n        \\n        return self.lowestCommonAncestor(root.left, p, q) or self.lowestCommonAncestor(root.right, p, q)\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2708829,
                "title": "easiest-solution-ever-4-lines-solution",
                "content": "\\t\\t\\n\\t\\t\\n\\t\\tclass Solution {\\n\\t\\t\\tpublic TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n\\t\\t\\t\\tif(p.val<root.val && q.val<root.val)\\n\\t\\t\\t\\t\\treturn lowestCommonAncestor(root.left, p, q);\\n\\t\\t\\t\\tif(p.val>root.val && q.val>root.val)\\n\\t\\t\\t\\t\\treturn lowestCommonAncestor(root.right, p, q);\\n\\t\\t\\t\\treturn root;\\n\\t\\t\\t}\\n\\t\\t}",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "class Solution {\\n\\t\\t\\tpublic TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n\\t\\t\\t\\tif(p.val<root.val && q.val<root.val)\\n\\t\\t\\t\\t\\treturn lowestCommonAncestor(root.left, p, q);\\n\\t\\t\\t\\tif(p.val>root.val && q.val>root.val)\\n\\t\\t\\t\\t\\treturn lowestCommonAncestor(root.right, p, q);\\n\\t\\t\\t\\treturn root;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2414690,
                "title": "q235-c-86-9-faster-recursive-iterative-3-line-solution",
                "content": "### C++ Solution \\nFor **recursive** method\\n```\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if (root->val >  p->val && root->val >  q->val) return lowestCommonAncestor(root->left , p, q);\\n        if (root->val <  p->val && root->val <  q->val) return lowestCommonAncestor(root->right, p, q);\\n        return root;\\n    }\\n```\\n\\n**The complexity of this solution:**\\n-\\tTime: O(H)\\n-\\tSpace: O(H)\\n\\n**If you loved this solution then please up vote to motivate me \\uD83D\\uDE0A**\\n___\\nAlso, For **iterative** method\\n```\\n\\tTreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        TreeNode* current = root;\\n        while (1) {\\n            if (p->val < current->val && q->val < current->val) current = current->left;\\n            else \\n                if (p->val > current->val && q->val > current->val) current = current->right;\\n            else \\n                break;\\n        }\\n        return current;\\n    }\\n```\\n\\n**Complexity:**\\n-\\tTime: O(H)\\n-\\tSpace: O(1)\\n\\nResult:\\n![image](https://assets.leetcode.com/users/images/4c7f686a-d7c9-4fb5-84cd-95ee071a5666_1660295308.4577987.png)\\n\\n\\n**If you loved this solution then please up vote to motivate me, and enjoy your coding\\uD83D\\uDE0A**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if (root->val >  p->val && root->val >  q->val) return lowestCommonAncestor(root->left , p, q);\\n        if (root->val <  p->val && root->val <  q->val) return lowestCommonAncestor(root->right, p, q);\\n        return root;\\n    }\\n```\n```\\n\\tTreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        TreeNode* current = root;\\n        while (1) {\\n            if (p->val < current->val && q->val < current->val) current = current->left;\\n            else \\n                if (p->val > current->val && q->val > current->val) current = current->right;\\n            else \\n                break;\\n        }\\n        return current;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2413850,
                "title": "c-4-approach-recursive-iterative",
                "content": "In this question we have to find **Lowest Common Ancestor** in Binary Search Tree\\n\\n\\n### Approach 1\\n1. In this is Approach we store path of p and q node in vector\\n2. Created GetPath function that give path of p and p\\n3. When  we get Path of p and q then we\\'ll made map to find LCA\\n```\\nclass Solution {\\npublic:\\n    \\n    void GetPath(TreeNode* root, TreeNode *target,vector<TreeNode*>& path)\\n   {\\n        if(root==NULL)\\n        {\\n            return ;\\n        }\\n        \\n        path.push_back(root);\\n        if(root->val==target->val)\\n        {\\n\\n            return ;\\n        }\\n        if(root->val>target->val)\\n        {\\n            return GetPath(root->left,target,path);\\n        }\\n    \\n        else\\n        {\\n            return GetPath(root->right,target,path);\\n        }\\n        \\n    }\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        vector<TreeNode*> pathP;\\n        vector<TreeNode*> pathQ;\\n        GetPath(root,p,pathP);\\n        GetPath(root,q,pathQ);\\n        map<TreeNode*,int> findmap;\\n        for(auto i:pathP)\\n        {\\n            findmap[i]++;\\n        }\\n        for(int i=pathQ.size()-1;i>=0;i--)\\n        {\\n            if(findmap[pathQ[i]]>0)\\n            {\\n                return pathQ[i];\\n            }\\n        }\\n        \\n      \\n        return NULL;       \\n    }\\n};\\n```\\n\\n### Approach 2\\n1. root ==NULL is base condition \\n2. if any of the node root==p||root==q then we\\'ll return root \\n3. We\\'ll get  leftans and rightans \\n4. if (rightans==NULL)  return leftans;\\n5. else if(leftans==NULL) return rightans;\\n6. else return root;\\n7. This approach can work Binary Tree as well but In here we\\'ve Binary Search Tree so we can optimise it as well \\n\\n```\\n\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n      \\n        if(root==NULL)\\n            return NULL;\\n        if(root==p||root==q)\\n        \\n            return root;\\n    \\n \\n        TreeNode* leftans= lowestCommonAncestor(root->left,p,q);\\n\\n        TreeNode* rightans= lowestCommonAncestor(root->right,p,q);\\n        if(rightans==NULL)\\n        {\\n\\n            return leftans;\\n        }\\n        else if(leftans==NULL)\\n        {\\n            return rightans;\\n        }\\n        else {\\n            return root;\\n        }\\n        \\n        \\n    }\\n};\\n```\\n\\n### Approach 3\\n\\n\\n1. Root value must be between p and q node\\n2. if ((root -> val > p -> val) && (root -> val > q -> val)) then we\\'ll move in left direction\\n3.  if ((root -> val < p -> val) && (root -> val < q -> val)) then we\\'ll move in right direction\\n4.  if root->val between p and q then we\\'ll return root \\n```\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if ((root -> val > p -> val) && (root -> val > q -> val)) {\\n            return lowestCommonAncestor(root -> left, p, q);\\n        }\\n        if ((root -> val < p -> val) && (root -> val < q -> val)) {\\n            return lowestCommonAncestor(root -> right, p, q);\\n        }\\n        return root;\\n    }\\n};\\n```\\n\\n### Approach 4\\nThis is approach is same as last Apprach we doing it by while loop\\n\\n```\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n     \\n        while(root)\\n        {\\n            if(root->val>p->val&&root->val>q->val)\\n            {\\n                root=root->left;\\n            }\\n            else if(root->val<p->val&&root->val<q->val)\\n            {\\n                root=root->right;\\n            }\\n            else\\n            {\\n                return root;\\n            }\\n        }\\n        return NULL;\\n        \\n        \\n    }\\n};\\n```\\nIf you like all the approach then make sure upvote my solution",
                "solutionTags": [
                    "Binary Search",
                    "Tree",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void GetPath(TreeNode* root, TreeNode *target,vector<TreeNode*>& path)\\n   {\\n        if(root==NULL)\\n        {\\n            return ;\\n        }\\n        \\n        path.push_back(root);\\n        if(root->val==target->val)\\n        {\\n\\n            return ;\\n        }\\n        if(root->val>target->val)\\n        {\\n            return GetPath(root->left,target,path);\\n        }\\n    \\n        else\\n        {\\n            return GetPath(root->right,target,path);\\n        }\\n        \\n    }\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        vector<TreeNode*> pathP;\\n        vector<TreeNode*> pathQ;\\n        GetPath(root,p,pathP);\\n        GetPath(root,q,pathQ);\\n        map<TreeNode*,int> findmap;\\n        for(auto i:pathP)\\n        {\\n            findmap[i]++;\\n        }\\n        for(int i=pathQ.size()-1;i>=0;i--)\\n        {\\n            if(findmap[pathQ[i]]>0)\\n            {\\n                return pathQ[i];\\n            }\\n        }\\n        \\n      \\n        return NULL;       \\n    }\\n};\\n```\n```\\n\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n      \\n        if(root==NULL)\\n            return NULL;\\n        if(root==p||root==q)\\n        \\n            return root;\\n    \\n \\n        TreeNode* leftans= lowestCommonAncestor(root->left,p,q);\\n\\n        TreeNode* rightans= lowestCommonAncestor(root->right,p,q);\\n        if(rightans==NULL)\\n        {\\n\\n            return leftans;\\n        }\\n        else if(leftans==NULL)\\n        {\\n            return rightans;\\n        }\\n        else {\\n            return root;\\n        }\\n        \\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if ((root -> val > p -> val) && (root -> val > q -> val)) {\\n            return lowestCommonAncestor(root -> left, p, q);\\n        }\\n        if ((root -> val < p -> val) && (root -> val < q -> val)) {\\n            return lowestCommonAncestor(root -> right, p, q);\\n        }\\n        return root;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n     \\n        while(root)\\n        {\\n            if(root->val>p->val&&root->val>q->val)\\n            {\\n                root=root->left;\\n            }\\n            else if(root->val<p->val&&root->val<q->val)\\n            {\\n                root=root->right;\\n            }\\n            else\\n            {\\n                return root;\\n            }\\n        }\\n        return NULL;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2413537,
                "title": "java-cpp-100-faster-code-easy-solution",
                "content": "\\tPLEASE  UPVOTE IF YOU LIKE.\\n\\t\\n\\n```\\nclass Solution {\\n    \\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        \\n        if(root == null || (p.val <= root.val && q.val >= root.val) || (p.val >= root.val && q.val <= root.val))\\n            return root;\\n        else if(root.val >= p.val)\\n            return lowestCommonAncestor(root.left, p, q);\\n        else\\n            return lowestCommonAncestor(root.right, p, q);\\n    }\\n}\\n```\\n\\n\\tCPP\\n```\\nclass Solution {\\npublic:\\n\\tTreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n\\t\\tif(!root or root==p or root==q) return root;\\n\\t\\tTreeNode *l=lowestCommonAncestor(root->left,p,q);\\n\\t\\tTreeNode *r=lowestCommonAncestor(root->right,p,q);\\n\\t\\tif(l && r) return root; //if current node has p and q on respective side\\n\\t\\treturn !l?r:l;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        \\n        if(root == null || (p.val <= root.val && q.val >= root.val) || (p.val >= root.val && q.val <= root.val))\\n            return root;\\n        else if(root.val >= p.val)\\n            return lowestCommonAncestor(root.left, p, q);\\n        else\\n            return lowestCommonAncestor(root.right, p, q);\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n\\tTreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n\\t\\tif(!root or root==p or root==q) return root;\\n\\t\\tTreeNode *l=lowestCommonAncestor(root->left,p,q);\\n\\t\\tTreeNode *r=lowestCommonAncestor(root->right,p,q);\\n\\t\\tif(l && r) return root; //if current node has p and q on respective side\\n\\t\\treturn !l?r:l;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2271459,
                "title": "python-i-have-a-simple-solution-for-you",
                "content": "## I have a simple solution for you :) \\n** [Click here.](https://linktr.ee/anandchauhan)\\n\\n\\n+ Easy solution\\n```\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        cur =root\\n        while cur:\\n            if p.val > cur.val and q.val > cur.val:\\n                cur = cur.right\\n            elif p.val < cur.val and q.val < cur.val:\\n                cur = cur.left\\n            else:\\n                return cur\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        cur =root\\n        while cur:\\n            if p.val > cur.val and q.val > cur.val:\\n                cur = cur.right\\n            elif p.val < cur.val and q.val < cur.val:\\n                cur = cur.left\\n            else:\\n                return cur\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2256920,
                "title": "c-space-o-1-time-o-n-some-new-idea-explanation",
                "content": "\\n\\n# Solution\\n\\n```C++\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode*& p, TreeNode*&q) {\\n        //Case 1: one is the ancestor to another.\\n        TreeNode* node;\\n        int pval = p->val;\\n        int qval = q->val;\\n        //Case 1.1: If q is ancestor of p, then in the traveeling of finding p-> val, you can meet q  earilier. \\n        node = root;\\n        while(node->val != pval) {\\n            if(node == q) return q;\\n            node = pval < node->val?node->left:node->right;\\n        }\\n        //Case 1.2: If p is ancestor of q, then in the travelling of finding q->val, you can meet p earilier. \\n        node = root;\\n        while(node->val != qval) {\\n            if(node == p) return p;\\n            node=qval<node->val?node->left:node->right;\\n        }\\n\\n        //Case 2: no one is the ancestor to another.\\n        if(p->val == q->val) return p;  \\n        if(p->val>q->val) swap(p,q);//swap to make sure p->val<=q->val\\n        while(p->right) p=p->right;\\n        while(q->left) q=q->left;\\n        //Start to find value int the bound (begin,end)  in BST\\n        int begin=p->val, end=q->val;\\n        while(!(begin<root->val && root->val<end)) {\\n            root=(root->val > end)?root->left:root->right;\\n        }\\n\\n        return root;\\n    }\\n};\\n```\\n\\n# Explanation\\nTo solve this problem, we seperate it into two cases. \\nCase 1: one is the ancestor to another.\\nCase 2: no one is the ancestor to another.\\nIf Case 1 is not happended, then solve the case 2 \\n\\nFor the case 1, \\nCase 1.1: If q is ancestor of p, then in the traveeling of finding p-> val, you can memet q earilier. \\nCase 1.2: If p is ancestor of q, then in the travelling of finding q->val, you can meet p earilier. \\n\\nFor the case 2.\\nTo decide the nodes of p and q to see who own the value smaller than another one.\\nThe tree node with samller value is called smallNode, and another one is called largeNode.\\nThe value `begin` in right-most node of smallNode is node most close to lowest common ancestor of p and q.\\nThe value `end` in left-most node of largeNode is node most close to lowest common ancestor of p and q.\\n\\nAnd the value of lowest common ancestor must be the only one node in the interval (begin, end).\\nThus, we can find the lowest common ancestor of p & q that is the node that its value is belong to (begin,end)\\n\\n# Complexity \\n**Time Complexity O(N)**\\nWhen the BST is not balanace, then we may use O(N) to find the node. \\nWe use 5 times in BST to find the node depending on the height of BST.\\n**Space Complexity O(1)**\\nWe only declare some constant number of variable in this algorithm, \\nso the space complexity is O(1) here. \\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```C++\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode*& p, TreeNode*&q) {\\n        //Case 1: one is the ancestor to another.\\n        TreeNode* node;\\n        int pval = p->val;\\n        int qval = q->val;\\n        //Case 1.1: If q is ancestor of p, then in the traveeling of finding p-> val, you can meet q  earilier. \\n        node = root;\\n        while(node->val != pval) {\\n            if(node == q) return q;\\n            node = pval < node->val?node->left:node->right;\\n        }\\n        //Case 1.2: If p is ancestor of q, then in the travelling of finding q->val, you can meet p earilier. \\n        node = root;\\n        while(node->val != qval) {\\n            if(node == p) return p;\\n            node=qval<node->val?node->left:node->right;\\n        }\\n\\n        //Case 2: no one is the ancestor to another.\\n        if(p->val == q->val) return p;  \\n        if(p->val>q->val) swap(p,q);//swap to make sure p->val<=q->val\\n        while(p->right) p=p->right;\\n        while(q->left) q=q->left;\\n        //Start to find value int the bound (begin,end)  in BST\\n        int begin=p->val, end=q->val;\\n        while(!(begin<root->val && root->val<end)) {\\n            root=(root->val > end)?root->left:root->right;\\n        }\\n\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2059451,
                "title": "c-recursive-solution-faster-than-99-66-explained-solution",
                "content": "In this approach we will just check that values of p and q nodes are greater than root node or less than root node. If both p and q values are greater than root shift to right node of BST and if both p and q values are less than root node shift to left node otherwise return root node.\\n\\n\\'\\'\\'\\n\\n\\t\\tclass Solution {\\n\\t\\t\\n\\tpublic:\\n\\t\\tTreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n\\t\\t\\n\\t\\t\\t// Check if p and q values are less than root value to shift to left of root node\\n\\t\\t\\tif(p->val < root->val && q->val < root->val)\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn lowestCommonAncestor(root->left,p,q);\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\t// Check if p and q values are greater than root value to shift to right of root node\\n\\t\\t\\telse if(p->val > root->val && q->val > root->val)\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn lowestCommonAncestor(root->right,p,q);\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\treturn root;\\n\\t\\t}\\n\\t};\\n\\'\\'\\'",
                "solutionTags": [
                    "C",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "class Solution {\\n\\t\\t\\n\\tpublic:\\n\\t\\tTreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n\\t\\t\\n\\t\\t\\t// Check if p and q values are less than root value to shift to left of root node\\n\\t\\t\\tif(p->val < root->val && q->val < root->val)\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn lowestCommonAncestor(root->left,p,q);\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1779221,
                "title": "c-simplest-recursive-solution-using-bst-property",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if(root->val==p->val || root->val==q->val) return root;\\n        if(root->val>p->val && root->val<q->val) return root;\\n        if(root->val>q->val && root->val<p->val) return root;\\n        \\n        if(p->val>root->val && q->val>root->val) return lowestCommonAncestor(root->right, p, q);\\n        return lowestCommonAncestor(root->left, p, q);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if(root->val==p->val || root->val==q->val) return root;\\n        if(root->val>p->val && root->val<q->val) return root;\\n        if(root->val>q->val && root->val<p->val) return root;\\n        \\n        if(p->val>root->val && q->val>root->val) return lowestCommonAncestor(root->right, p, q);\\n        return lowestCommonAncestor(root->left, p, q);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1349304,
                "title": "c-clean-easy-iterative-method-explanation",
                "content": "**Solution:**\\n\\n**Approach:** \\nThis problem statement can be solved using both recursive and iterative methods. Here, we are going to talk about an easy iterative way to implement this concept `LCA`.\\n\\n* Simply start iterating from the root. Whenever, we find a node which lies between the two given nodes, we have found out the `LCA of p and q`.\\n* Otherwise, we have got `two base cases`:\\n\\t* Check if the value of root node is greater than both the given nodes. If this condition is satisfied, our `LCA` would always lie on the `left subtree`. Thus, assign value `root->left` to `root`.\\n\\t* Check if the value of root node is less than both the given nodes. If this condition is satisfied, our `LCA` would always lie on the `right subtree`. Thus, assign value `root->right` to `root`.\\n\\n```\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        while(root != NULL){\\n            if(root->val > p->val and root->val > q->val){\\n                root = root->left;\\n            }    \\n            else if(root->val < p->val and root->val < q->val){\\n                root = root->right;\\n            }\\n            else\\n                break;\\n        }\\n        return root;\\n    }\\n};\\n```\\n\\n`Time Complexity`: **`O(n)`**\\n`Space Complexity`:  **`O(1)`**\\nwhere **n** is **height** of the given **BST**.\\n\\n\\n**Feel free to share your approach or any improvements as well.**",
                "solutionTags": [
                    "C",
                    "Binary Search Tree",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        while(root != NULL){\\n            if(root->val > p->val and root->val > q->val){\\n                root = root->left;\\n            }    \\n            else if(root->val < p->val and root->val < q->val){\\n                root = root->right;\\n            }\\n            else\\n                break;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1347816,
                "title": "lowest-common-ancestor-of-a-binary-search-tree-c-recursion-with-approach",
                "content": "# **APPROACH:**\\nWe recursively traverse the BST: (LCA = Lowest Common Ancestor)\\n* If node\\u2019s value is greater than both p and q then our LCA lies in the left side of the node. \\n* If it\\u2019s is smaller than both p and p, then LCA lies on the right side. \\n* Otherwise, the root is LCA (assuming that both p and q are present in BST).\\n\\n# **ALGORITHM:**\\n1. Create a recursive function that takes a node and the two values p and q.\\n2. If the value of the current node is less than both p and q, then LCA lies in the right subtree. Call the recursive function for the right subtree.\\n3. If the value of the current node is greater than both p and q, then LCA lies in the left subtree. Call the recursive function for the left subtree.\\n4. If both the above cases are false then return the current node as LCA.\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n      if(root == NULL || root == p || root == q)\\n      {\\n          return root ;\\n      }\\n      TreeNode* left = lowestCommonAncestor(root->left ,  p ,  q);\\n      TreeNode* right = lowestCommonAncestor(root->right , p , q);\\n      if(left != NULL && right != NULL)\\n      {\\n          return root ;\\n      }\\n      else\\n      {\\n          if(left == NULL)\\n          {\\n              return right ;\\n          }\\n          return left ;\\n      }\\n    }\\n};\\n```\\n**Time Complexity: O(h)\\nSpace Complexity: O(h)\\nWhere \\'h\\' is the height of the tree**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n      if(root == NULL || root == p || root == q)\\n      {\\n          return root ;\\n      }\\n      TreeNode* left = lowestCommonAncestor(root->left ,  p ,  q);\\n      TreeNode* right = lowestCommonAncestor(root->right , p , q);\\n      if(left != NULL && right != NULL)\\n      {\\n          return root ;\\n      }\\n      else\\n      {\\n          if(left == NULL)\\n          {\\n              return right ;\\n          }\\n          return left ;\\n      }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 706182,
                "title": "java-3-line-easy-solution-o-log-n",
                "content": "```\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if(root.val < p.val && root.val < q.val) return lowestCommonAncestor(root.right, p, q);\\n        if(root.val > p.val && root.val > q.val) return lowestCommonAncestor(root.left , p, q);\\n        return root;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "class Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if(root.val < p.val && root.val < q.val) return lowestCommonAncestor(root.right, p, q);\\n        if(root.val > p.val && root.val > q.val) return lowestCommonAncestor(root.left , p, q);\\n        return root;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 65070,
                "title": "2-line-java-solution",
                "content": "    if ((p.val - root.val) * (root.val - q.val) >= 0) return root;\\n    return (p.val > root.val) ? lowestCommonAncestor(root.right, p, q) : lowestCommonAncestor(root.left, p, q);",
                "solutionTags": [],
                "code": "    if ((p.val - root.val) * (root.val - q.val) >= 0) return root;\\n    return (p.val > root.val) ? lowestCommonAncestor(root.right, p, q) : lowestCommonAncestor(root.left, p, q);",
                "codeTag": "Unknown"
            },
            {
                "id": 65088,
                "title": "rainbowsecret-c-solution",
                "content": "    class Solution {\\n    public:\\n        TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n            while( (root->val-p->val)*(root->val-q->val) > 0){\\n                root = root->val > p->val ? root->left : root->right;\\n            }\\n            return root;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n            while( (root->val-p->val)*(root->val-q->val) > 0){\\n                root = root->val > p->val ? root->left : root->right;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 65098,
                "title": "sharing-my-44ms-c-solution",
                "content": "    /**\\n     * Definition for a binary tree node.\\n     * struct TreeNode {\\n     *     int val;\\n     *     TreeNode *left;\\n     *     TreeNode *right;\\n     *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n     * };\\n     */\\n     \\n    class Solution {\\n    public:\\n        TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n            if(root == NULL)\\n                return NULL;\\n            \\n            if(root == p || root == q)\\n                return root;\\n                \\n            TreeNode* left  =  lowestCommonAncestor(root->left, p, q);\\n            TreeNode* right = lowestCommonAncestor(root->right, p, q);\\n            \\n            if(left && right)\\n                return root;\\n            \\n            else if(left)\\n                return left;\\n                \\n            else\\n                return right;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n            if(root == NULL)\\n                return NULL;\\n            \\n            if(root == p || root == q)\\n                return root;\\n                \\n            TreeNode* left  =  lowestCommonAncestor(root->left, p, q);\\n            TreeNode* right = lowestCommonAncestor(root->right, p, q);\\n            \\n            if(left && right)\\n                return root;\\n            \\n            else if(left)\\n                return left;\\n                \\n            else\\n                return right;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 65115,
                "title": "simple-while-loop-java-solution",
                "content": "    public class Solution {\\n        public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n            boolean change=true;\\n            while(change){       //when p and q on the two side of BST (or one is equal to root), exit the loop\\n                change=false;\\n                while(p.val<root.val&&q.val<root.val){\\n                    root=root.left;\\n                    change=true;\\n                }\\n                \\n                while(p.val>root.val&&q.val>root.val){\\n                    root=root.right;\\n                    change=true;\\n                }\\n            }\\n            \\n            \\n            return root;\\n            \\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n            boolean change=true;\\n            while(change){       //when p and q on the two side of BST (or one is equal to root), exit the loop\\n                change=false;\\n                while(p.val<root.val&&q.val<root.val){\\n                    root=root.left;\\n                    change=true;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 65137,
                "title": "20ms-c-solution-iterative",
                "content": "    typedef struct TreeNode tn;\\n    /* tn* lowestCommonAncestor(struct TreeNode* root, struct TreeNode* p, struct TreeNode* q) */\\n    tn* lowestCommonAncestor(tn* root, tn* p, tn* q)\\n    {\\n      /* assume p is on the left */\\n      if(p->val>q->val)\\n      {\\n        tn* tmp = p;\\n        p=q, q=tmp;\\n      }\\n      \\n      tn* lca = root;\\n      while(!(p->val<=lca->val && q->val>=lca->val))\\n      {\\n        if(p->val > lca->val)\\n          lca = lca->right;\\n        else if(q->val < lca->val)\\n          lca = lca->left;\\n      }    \\n    \\n      return lca;\\n    }",
                "solutionTags": [
                    "Binary Search",
                    "Tree"
                ],
                "code": "    typedef struct TreeNode tn;\\n    /* tn* lowestCommonAncestor(struct TreeNode* root, struct TreeNode* p, struct TreeNode* q) */\\n    tn* lowestCommonAncestor(tn* root, tn* p, tn* q)\\n    {\\n      /* assume p is on the left */\\n      if(p->val>q->val)\\n      {\\n        tn* tmp = p;\\n        p=q, q=tmp;\\n      }\\n      \\n      tn* lca = root;\\n      while(!(p->val<=lca->val && q->val>=lca->val))\\n      {\\n        if(p->val > lca->val)\\n          lca = lca->right;\\n        else if(q->val < lca->val)\\n          lca = lca->left;\\n      }    \\n    \\n      return lca;\\n    }",
                "codeTag": "Python3"
            },
            {
                "id": 65187,
                "title": "my-1-line-java-solution",
                "content": "The solution is simple:\\n\\n    return ((p.val-root.val)*(q.val-root.val)<=0) ? root : lowestCommonAncestor(p.val>root.val?root.right:root.left, p, q);",
                "solutionTags": [
                    "Java"
                ],
                "code": "The solution is simple:\\n\\n    return ((p.val-root.val)*(q.val-root.val)<=0) ? root : lowestCommonAncestor(p.val>root.val?root.right:root.left, p, q);",
                "codeTag": "Unknown"
            },
            {
                "id": 3974521,
                "title": "3-best-c-solutions-recursive-and-iterative-approach-beats-100",
                "content": "## [Similar question - LCA of binary tree](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/solutions/3959105/2-easy-c-solutions-recursive-and-iterative-approach-beats-100/?envType=list&envId=r8ctlrc6) \\n\\n## Image for simple understanding\\n![Solution](https://assets.leetcode.com/users/images/7689ea13-2767-4d54-a050-9a3de386f732_1693285333.1166608.png) \\n\\n##### Image credits to @hiepit \\n\\n# Code\\n```\\n// Recursive solution - Same as LCA of binary tree\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if(root == NULL || root == p || root == q)\\n            return root;\\n        \\n        TreeNode *leftAns = lowestCommonAncestor(root->left, p, q);\\n        TreeNode *rightAns = lowestCommonAncestor(root->right, p, q);\\n\\n        if(leftAns != NULL && rightAns != NULL)\\n            return root;\\n        else if(leftAns != NULL && rightAns == NULL)\\n            return leftAns;\\n        return rightAns;\\n    }\\n};\\n\\n// Recurisve solution - Binary search tree property\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        // If both nodes have smaller value than root, go left\\n        if(root->val > p->val && root->val > q->val){\\n            return lowestCommonAncestor(root -> left, p, q);\\n        }\\n        // If both nodes have higher value than root, go right\\n        if(root->val < p->val && root->val < q->val){\\n            return lowestCommonAncestor(root -> right, p, q);\\n        }\\n        return root;\\n    }\\n};\\n\\n// Iterative solution - Binary search tree property\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        while(root != NULL){\\n            // If both nodes have smaller value than root, go left\\n            if(root->val > p->val && root->val > q->val)\\n                root = root->left;\\n            // If both nodes have higher value than root, go right\\n            else if(root->val < p->val && root->val < q->val)\\n                root = root->right;\\n            else \\n                break;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\n// Recursive solution - Same as LCA of binary tree\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if(root == NULL || root == p || root == q)\\n            return root;\\n        \\n        TreeNode *leftAns = lowestCommonAncestor(root->left, p, q);\\n        TreeNode *rightAns = lowestCommonAncestor(root->right, p, q);\\n\\n        if(leftAns != NULL && rightAns != NULL)\\n            return root;\\n        else if(leftAns != NULL && rightAns == NULL)\\n            return leftAns;\\n        return rightAns;\\n    }\\n};\\n\\n// Recurisve solution - Binary search tree property\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        // If both nodes have smaller value than root, go left\\n        if(root->val > p->val && root->val > q->val){\\n            return lowestCommonAncestor(root -> left, p, q);\\n        }\\n        // If both nodes have higher value than root, go right\\n        if(root->val < p->val && root->val < q->val){\\n            return lowestCommonAncestor(root -> right, p, q);\\n        }\\n        return root;\\n    }\\n};\\n\\n// Iterative solution - Binary search tree property\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        while(root != NULL){\\n            // If both nodes have smaller value than root, go left\\n            if(root->val > p->val && root->val > q->val)\\n                root = root->left;\\n            // If both nodes have higher value than root, go right\\n            else if(root->val < p->val && root->val < q->val)\\n                root = root->right;\\n            else \\n                break;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3867300,
                "title": "lowest-common-ancestor-of-bst-in-java-100-fast-solution-o-n-time-o-1-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe know that in bst the two nodes p and q can lie on either sides of root or at same side of the root. Therefore, the lowest common ancestor will be the node that splits both the nodes on either side of the bst or the node which itself is either of p or q.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n![image.png](https://assets.leetcode.com/users/images/13eefeec-a9e2-4ac6-a036-1426669612a5_1691240130.2432892.png)\\n\\nWe know that in bst the two nodes p and q can lie on either sides of root or at same side of the root. For eg in the above example 1, 2 and 8 lie on opposite sides of 6 and thus 6 is LCA(2, 8).\\n\\nTherefore, we can conclude that lowest common ancestor for two nodes will the node that splits both p and q to either side of itself.\\n\\n![image.png](https://assets.leetcode.com/users/images/bf283ff0-c57d-4f15-93c2-0555da122bb4_1691240151.3338797.png)\\n\\n\\nIn example 2, we can see that both nodes p and q do not lie at left nor at right of any node thus, in such case the root is the LCA. this is because if p and q both do not lie on same side then that means that root node is one of the node from p or q. Thus, it becomes LCA.\\n\\nTherefore, we traverse the bst and move to left or right according to node value until root becomes null or we find the split in paths. Once split in paths is found or node is equal to either p or q then we return that node.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(h) {height of bst}\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1) {No extra space used}\\n\\nIf this helped you in clearing the concept and solve the question then please upvote the solution!!!\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\n\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        while(root != null){\\n            if(root.val > p.val && root.val > q.val){\\n                root = root.left;\\n            } else if(root.val < p.val && root.val < q.val){\\n                root = root.right;\\n            } else{\\n                return root;\\n            }\\n        }\\n        return null;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\n\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        while(root != null){\\n            if(root.val > p.val && root.val > q.val){\\n                root = root.left;\\n            } else if(root.val < p.val && root.val < q.val){\\n                root = root.right;\\n            } else{\\n                return root;\\n            }\\n        }\\n        return null;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3643526,
                "title": "c-simple-and-efficient-recursive-algorithm",
                "content": "This algorithm finds the lowest common ancestor of nodes p and q in a binary tree by traversing the tree recursively, checking the left and right subtrees. If one of the subtrees is NULL, it means the LCA must be in the other subtree. If both subtrees are not NULL, the current root is the LCA.\\n\\n1.If the root is NULL or equal to either of the two nodes (p or q), return the root.\\n2.Recursively call the function on the left subtree, storing the result in the variable left.\\n3.Recursively call the function on the right subtree, storing the result in the variable right.\\n4.If left is NULL, return right.\\n5.If right is NULL, return left. Otherwise, return the root.\\n```\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if(root == NULL || root == p || root == q)\\n            return root;\\n        TreeNode* left = lowestCommonAncestor(root->left,p,q);\\n        TreeNode* right = lowestCommonAncestor(root->right,p,q);\\n        if(left == NULL)\\n            return right;\\n        else if(right == NULL)\\n            return left;\\n        else return root;\\n    }\\n};\\n```\\n\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if(root == NULL || root == p || root == q)\\n            return root;\\n        TreeNode* left = lowestCommonAncestor(root->left,p,q);\\n        TreeNode* right = lowestCommonAncestor(root->right,p,q);\\n        if(left == NULL)\\n            return right;\\n        else if(right == NULL)\\n            return left;\\n        else return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3579443,
                "title": "using-bst-property-cpp-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- **Utilize the properties of the binary search tree:** `Take advantage of the fact that the binary search tree is organized in a way that values on the left subtree are less than the root, and values on the right subtree are greater than the root. This property can guide you in determining which subtree to explore based on the values of the nodes p and q.`\\n\\n- **Recurse through the tree:**` Use a recursive approach to traverse the binary search tree. Compare the values of the current node with the values of p and q to determine the lowest common ancestor. If the current node\\'s value is greater than both p and q, recurse on the left subtree. If the current node\\'s value is less than both p and q, recurse on the right subtree. By recursively traversing the tree, you can narrow down the search and find the lowest common ancestor efficiently.`\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- The function lowestCommonAncestor takes three parameters: root, p, and q.\\n- If the root is NULL, indicating the end of the tree, the function returns NULL.\\n- If the value of the root node is equal to either the value of p or q, the function returns the root node, as it is the lowest common ancestor.\\n- If the value of root is between the values of p and q, inclusive, the function returns the root node, as it is the lowest common ancestor.\\n- If the value of root is greater than both p and q, the function recursively calls lowestCommonAncestor on the left subtree (root->left) to find the lowest common ancestor.\\n- If the value of root is less than both p and q, the function recursively calls lowestCommonAncestor on the right subtree (root->right) to find the lowest common ancestor.\\n- If none of the above conditions are met, the function returns NULL, indicating that the lowest common ancestor was not found.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n`The time complexity of the provided code is O(h), where h is the height of the binary search tree. In the worst case, the binary search tree can be skewed, resulting in a time complexity of O(n), where n is the number of nodes in the tree. This is because in the worst case, we may need to traverse the entire height of the tree to reach the lowest common ancestor.`\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n`The space complexity of the code is O(h) as well, considering the space used by the recursive calls. In the worst case, the recursive call stack can have a maximum depth equal to the height of the tree. However, if the binary search tree is balanced, the height of the tree would be log(n), resulting in a space complexity of O(log n).`\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if(root==NULL) return NULL;\\n\\n        if(root->val == p->val || root->val == q->val)\\n        return root;\\n\\n        if(root->val > p->val && root->val < q->val)\\n        return root;\\n        else if(root->val > q->val && root->val < p->val)\\n        return root;\\n\\n        if(root->val > p->val && root->val > q->val)\\n        return lowestCommonAncestor(root->left,p,q);\\n        else if(root->val < p->val && root->val < q->val)\\n        return lowestCommonAncestor(root->right,p,q);\\n\\n        return NULL;\\n    }\\n};\\n```\\n![PLEASE UPVOTE.jpg](https://assets.leetcode.com/users/images/896ffe2e-eb4e-4e91-bb1f-a6ea5ff76166_1685464267.7967212.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Binary Search Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if(root==NULL) return NULL;\\n\\n        if(root->val == p->val || root->val == q->val)\\n        return root;\\n\\n        if(root->val > p->val && root->val < q->val)\\n        return root;\\n        else if(root->val > q->val && root->val < p->val)\\n        return root;\\n\\n        if(root->val > p->val && root->val > q->val)\\n        return lowestCommonAncestor(root->left,p,q);\\n        else if(root->val < p->val && root->val < q->val)\\n        return lowestCommonAncestor(root->right,p,q);\\n\\n        return NULL;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3439106,
                "title": "java-simple-recursive-solution-iterative-solution-in-o-h-with-detailed-explanation",
                "content": "# Intuition\\nSince the given binary tree is a BST, and we assume `p` and `q` will exist in this BST, the LCA of `p` and `q` actually is the first node that splits `p.val` and `q.val`, i.e. it is either `p.val <= LCA.val <= q.val` or `q.val <= LCA.val <= p.val` (since all `node.val` are unique, in reality there will be at most one \"=\"). In this case, we can simplify this problem to a simple search problem within BST.\\n\\nNote that if we do not have the constraint \"`p` and `q` will exist in this BST\", we have to traverse the entire BST to check the existence `p` and `q`. The following \"first spliting node\" method will not be applicable any more.\\n\\n# Approach\\nWe can either use recursion or iteration to solve this problem.\\n\\n---\\nRecursive approach:\\nBase case: if the root is null, then return null.\\nRecursive rule:\\n- if both `p.val` and `q.val` are smaller than `root.val`, then the LCA must be within the root\\'s left subtree, so we search the root\\'s left child;\\n- if both `p.val` and `q.val` are greater than `root.val`, then the LCA must be within the root\\'s right subtree, so we search the root\\'s right child;\\n- otherwise, `root` splits `p` and `q`, so we return root as our result.\\n\\n---\\nIterative approach:\\nThe logic is very similar to recursive approach, but by using iteration, we can avoid using O(h) space on the stack.\\nSo basically we create a pointer starting from `root`. We create a while-loop to search LCA until `root` becomes `null`.\\n- if both `p.val` and `q.val` are smaller than `root.val`, then the LCA must be within the root\\'s left subtree, so we substitute `root` by its left child and continue the loop;\\n- if both `p.val` and `q.val` are greater than `root.val`, then the LCA must be within the root\\'s right subtree, so we substitute `root` by its right child and continue the loop;\\n- otherwise, `root` splits `p` and `q`, so we return root as our result.\\n\\n# Complexity\\n- Time complexity: $$O(h)$$ for both recursive & iterative approach\\n\\n- Space complexity: $$O(h)$$ for recursive approach, $$O(1)$$ for iterative approach\\n\\n# Code\\n```\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        // Recursive approach\\n        if (root == null) return null;\\n        if (p.val < root.val && q.val < root.val) {\\n            return lowestCommonAncestor(root.left, p, q);\\n        }\\n        if (p.val > root.val && q.val > root.val) {\\n            return lowestCommonAncestor(root.right, p, q);\\n        }\\n        return root;\\n    }\\n}\\n```\\n\\n```\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        // Iterative approach\\n        TreeNode node = root;\\n        while (node != null) {\\n            if (p.val < node.val && q.val < node.val) {\\n                node = node.left;\\n            }\\n            else if (p.val > node.val && q.val > node.val) {\\n                node = node.right;\\n            }\\n            else {\\n                return node;\\n            }\\n        }\\n        return node;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        // Recursive approach\\n        if (root == null) return null;\\n        if (p.val < root.val && q.val < root.val) {\\n            return lowestCommonAncestor(root.left, p, q);\\n        }\\n        if (p.val > root.val && q.val > root.val) {\\n            return lowestCommonAncestor(root.right, p, q);\\n        }\\n        return root;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        // Iterative approach\\n        TreeNode node = root;\\n        while (node != null) {\\n            if (p.val < node.val && q.val < node.val) {\\n                node = node.left;\\n            }\\n            else if (p.val > node.val && q.val > node.val) {\\n                node = node.right;\\n            }\\n            else {\\n                return node;\\n            }\\n        }\\n        return node;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2954299,
                "title": "c-3-line-code-clean-and-simple-code",
                "content": "![image](https://assets.leetcode.com/users/images/039a21bb-7bed-4802-b673-e5ffb6782c22_1672071057.0214615.png)\\n\\n**T->O(Height of Tree) && S->O(Height of Tree) [ASS]**\\n\\n\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tTreeNode* lowestCommonAncestor(TreeNode* curr,TreeNode* p,TreeNode* q) {\\n\\t\\t\\t\\tif(!curr) return NULL;\\n\\t\\t\\t\\tif(p->val<curr->val && q->val<curr->val) return lowestCommonAncestor(curr->left,p,q);\\n\\t\\t\\t\\tif(p->val>curr->val && q->val>curr->val) return lowestCommonAncestor(curr->right,p,q);\\n\\t\\t\\t\\treturn curr;\\n\\t\\t\\t}\\n\\t\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tTreeNode* lowestCommonAncestor(TreeNode* curr,TreeNode* p,TreeNode* q) {\\n\\t\\t\\t\\tif(!curr) return NULL;\\n\\t\\t\\t\\tif(p->val<curr->val && q->val<curr->val) return lowestCommonAncestor(curr->left,p,q);\\n\\t\\t\\t\\tif(p->val>curr->val && q->val>curr->val) return lowestCommonAncestor(curr->right,p,q);\\n\\t\\t\\t\\treturn curr;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2838219,
                "title": "java-iterative",
                "content": "```\\n\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        TreeNode node = root;\\n        while (node != null) {\\n            if (node.val > p.val && node.val > q.val) {\\n                node = node.left;\\n            } else if (node.val < p.val && node.val < q.val) {\\n                node = node.right;\\n            } else return node;\\n        }\\n        return null;\\n    }\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Iterator"
                ],
                "code": "```\\n\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        TreeNode node = root;\\n        while (node != null) {\\n            if (node.val > p.val && node.val > q.val) {\\n                node = node.left;\\n            } else if (node.val < p.val && node.val < q.val) {\\n                node = node.right;\\n            } else return node;\\n        }\\n        return null;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2792989,
                "title": "c-solution-lowest-common-ancestor-of-a-binary-search-tree",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        //base case\\n        if(root == NULL)\\n            return NULL;\\n        \\n        if(root->val > p->val && root->val > q->val)\\n            return lowestCommonAncestor(root->left , p , q);\\n        \\n        else if(root->val < p->val && root->val < q->val)\\n            return lowestCommonAncestor(root->right , p , q);\\n        \\n        else\\n            return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        //base case\\n        if(root == NULL)\\n            return NULL;\\n        \\n        if(root->val > p->val && root->val > q->val)\\n            return lowestCommonAncestor(root->left , p , q);\\n        \\n        else if(root->val < p->val && root->val < q->val)\\n            return lowestCommonAncestor(root->right , p , q);\\n        \\n        else\\n            return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2786116,
                "title": "c-easy-to-understand-solution",
                "content": "# Upvote if its helps\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if(p==q) return p;\\n        if(p==root || q==root) return root;\\n        TreeNode* temp=root;\\n        while(temp){\\n            if(temp->val>p->val&& temp->val>q->val){\\n                temp=temp->left;\\n            }\\n            else if(temp->val<p->val&& temp->val<q->val){\\n                temp=temp->right;\\n            }\\n            else return temp;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if(p==q) return p;\\n        if(p==root || q==root) return root;\\n        TreeNode* temp=root;\\n        while(temp){\\n            if(temp->val>p->val&& temp->val>q->val){\\n                temp=temp->left;\\n            }\\n            else if(temp->val<p->val&& temp->val<q->val){\\n                temp=temp->right;\\n            }\\n            else return temp;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2741086,
                "title": "235-lowest-common-ancestor-of-a-binary-search-tree",
                "content": "// see the code is very easy why >> coz of bst see cases\\n// either on l and r  >> both on l >> both on r >> the root it self is the ans \\n// now see if a both val are not on l or r means one is on l and one is on r so the point where they split is the point of the lca \\n// just dry run any eg and sorted \\n// pls upvote if you like the sol :)\\n```\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) \\n    {\\n      if(root==null)\\n          return null ;\\n        if( root.val>p.val && root.val>q.val){\\n            return  lowestCommonAncestor(root.left,p,q) ;\\n        }\\n        else if(p.val >root.val && q.val> root.val){\\n            return lowestCommonAncestor(root.right,p,q) ;\\n        }\\n         return root;\\n            \\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) \\n    {\\n      if(root==null)\\n          return null ;\\n        if( root.val>p.val && root.val>q.val){\\n            return  lowestCommonAncestor(root.left,p,q) ;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2415659,
                "title": "java-javascript-python-short-clean-easy",
                "content": "```java []\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        int max = Math.max(p.val, q.val), min = Math.min(p.val, q.val);\\n        if(root.val == min || root.val == max)    return root;\\n        if(root.val < max && root.val > min)  return root;\\n        return lowestCommonAncestor(min > root.val ? root.right : root.left, p, q);\\n    }\\n}\\n```\\n```javascript []\\nvar lowestCommonAncestor = function(root, p, q) {\\n    let max = Math.max(p.val, q.val), min = Math.min(p.val, q.val)\\n    if(root.val == min || root.val == max)    return root\\n    if(root.val < max && root.val > min)  return root\\n    return lowestCommonAncestor(min > root.val ? root.right : root.left, p, q)\\n};\\n```\\n```python []\\nclass Solution(object):\\n    def lowestCommonAncestor(self, root, p, q):\\n        mx, mn = max(p.val, q.val), min(p.val, q.val)\\n        if root.val == mn or root.val == mx:\\n            return root\\n        if root.val < mx and root.val > mn:\\n            return root\\n        return self.lowestCommonAncestor(root.right if mn > root.val else root.left, p, q)\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "JavaScript"
                ],
                "code": "```java []\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        int max = Math.max(p.val, q.val), min = Math.min(p.val, q.val);\\n        if(root.val == min || root.val == max)    return root;\\n        if(root.val < max && root.val > min)  return root;\\n        return lowestCommonAncestor(min > root.val ? root.right : root.left, p, q);\\n    }\\n}\\n```\n```javascript []\\nvar lowestCommonAncestor = function(root, p, q) {\\n    let max = Math.max(p.val, q.val), min = Math.min(p.val, q.val)\\n    if(root.val == min || root.val == max)    return root\\n    if(root.val < max && root.val > min)  return root\\n    return lowestCommonAncestor(min > root.val ? root.right : root.left, p, q)\\n};\\n```\n```python []\\nclass Solution(object):\\n    def lowestCommonAncestor(self, root, p, q):\\n        mx, mn = max(p.val, q.val), min(p.val, q.val)\\n        if root.val == mn or root.val == mx:\\n            return root\\n        if root.val < mx and root.val > mn:\\n            return root\\n        return self.lowestCommonAncestor(root.right if mn > root.val else root.left, p, q)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2415215,
                "title": "lowest-ancestor-in-bst-recursion-bst-property",
                "content": "Hi,\\n\\nSince the basic principle of BST is the item to the left is less than the root and item to the right is greater than the root.\\n\\nWe have to find the root which has value inbetween given left and right.\\n\\n```\\npublic TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n\\t\\tif(p.val<root.val && q.val<root.val)\\n\\t\\t\\treturn lowestCommonAncestor(root.left, p, q);\\n\\t\\tif(p.val>root.val && q.val>root.val)\\n\\t\\t\\treturn lowestCommonAncestor(root.right, p, q);\\n\\t\\treturn root;\\n    }",
                "solutionTags": [
                    "Java",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "Hi,\\n\\nSince the basic principle of BST is the item to the left is less than the root and item to the right is greater than the root.\\n\\nWe have to find the root which has value inbetween given left and right.\\n\\n```\\npublic TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n\\t\\tif(p.val<root.val && q.val<root.val)\\n\\t\\t\\treturn lowestCommonAncestor(root.left, p, q);\\n\\t\\tif(p.val>root.val && q.val>root.val)\\n\\t\\t\\treturn lowestCommonAncestor(root.right, p, q);\\n\\t\\treturn root;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2413895,
                "title": "simple-iterative-solution",
                "content": "Simple iterative solution to get LCA.\\n```\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        TreeNode* cur = root;\\n        while (true) {\\n            if (p -> val < cur -> val && q -> val < cur -> val) {\\n                cur = cur -> left;\\n            } else if (p -> val > cur -> val && q -> val > cur -> val) {\\n                cur = cur -> right;\\n            } else {\\n                break;\\n            }\\n        }\\n        return cur;\\n    \\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search Tree",
                    "Iterator"
                ],
                "code": "```\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        TreeNode* cur = root;\\n        while (true) {\\n            if (p -> val < cur -> val && q -> val < cur -> val) {\\n                cur = cur -> left;\\n            } else if (p -> val > cur -> val && q -> val > cur -> val) {\\n                cur = cur -> right;\\n            } else {\\n                break;\\n            }\\n        }\\n        return cur;\\n    \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2288554,
                "title": "c-solution-easy-approach-with-explanation-tc-o-n-sc-o-n-recursive-stack-space",
                "content": "```\\n\\n // If this helps plz consider upvote :)\\n \\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        // Logic is simple \\n        // first point where we can\\'t able to determine whether node is on left or right part of tree is the our LCA\\n        if(root == NULL){\\n            return NULL;\\n        }\\n        \\n        int curr = root->val;\\n        \\n        // curr value is less than value of both q and p go on right sub tree\\n        if(curr < p->val && curr < q->val){\\n            return lowestCommonAncestor(root->right,p,q);\\n        }\\n        \\n        // curr value is greater than both q and p then search on left sub tree;\\n        if(curr > p->val && curr > q->val){\\n            return lowestCommonAncestor(root->left,p,q);\\n        }\\n        \\n        \\n        return root;\\n    }\\n};\\n\\n // If this helps plz consider upvote :)\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\n\\n // If this helps plz consider upvote :)\\n \\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        // Logic is simple \\n        // first point where we can\\'t able to determine whether node is on left or right part of tree is the our LCA\\n        if(root == NULL){\\n            return NULL;\\n        }\\n        \\n        int curr = root->val;\\n        \\n        // curr value is less than value of both q and p go on right sub tree\\n        if(curr < p->val && curr < q->val){\\n            return lowestCommonAncestor(root->right,p,q);\\n        }\\n        \\n        // curr value is greater than both q and p then search on left sub tree;\\n        if(curr > p->val && curr > q->val){\\n            return lowestCommonAncestor(root->left,p,q);\\n        }\\n        \\n        \\n        return root;\\n    }\\n};\\n\\n // If this helps plz consider upvote :)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2271203,
                "title": "c-short-clean-code",
                "content": "***DO UPVOTE IF IT HELPS !!!!***\\n\\t\\n\\tTreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        \\n        if(!root) return NULL;\\n        \\n        if(root->val == p->val || root->val==q->val) return root;\\n        \\n        if(root->val > p->val && root->val > q->val){\\n            return lowestCommonAncestor(root->left,p,q);\\n        }\\n        else if(root->val < p->val && root->val < q->val){\\n            return lowestCommonAncestor(root->right,p,q);\\n        }\\n        \\n        TreeNode *a=lowestCommonAncestor(root->left,p,q);\\n        TreeNode *b=lowestCommonAncestor(root->right,p,q);\\n        \\n        if(!a) return b;\\n        else if (!b) return a;\\n        else if(a && b) return root;\\n        return NULL;\\n    }",
                "solutionTags": [
                    "C",
                    "Binary Search Tree"
                ],
                "code": "***DO UPVOTE IF IT HELPS !!!!***\\n\\t\\n\\tTreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        \\n        if(!root) return NULL;\\n        \\n        if(root->val == p->val || root->val==q->val) return root;\\n        \\n        if(root->val > p->val && root->val > q->val){\\n            return lowestCommonAncestor(root->left,p,q);\\n        }\\n        else if(root->val < p->val && root->val < q->val){\\n            return lowestCommonAncestor(root->right,p,q);\\n        }\\n        \\n        TreeNode *a=lowestCommonAncestor(root->left,p,q);\\n        TreeNode *b=lowestCommonAncestor(root->right,p,q);\\n        \\n        if(!a) return b;\\n        else if (!b) return a;\\n        else if(a && b) return root;\\n        return NULL;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2101631,
                "title": "o-h-time-3-line-of-logic-with-comment-c-easy-solution",
                "content": "```\\n// if both are larger then root go right recursively\\n// if both are smaller then root go left recursively\\n// else return the root\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if(!root)   return root;\\n        if(p->val>root->val and q->val>root->val){\\n            return lowestCommonAncestor(root->right, p, q);\\n        }\\n        else if(p->val<root->val and q->val<root->val){\\n            return lowestCommonAncestor(root->left, p, q);\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n// if both are larger then root go right recursively\\n// if both are smaller then root go left recursively\\n// else return the root\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if(!root)   return root;\\n        if(p->val>root->val and q->val>root->val){\\n            return lowestCommonAncestor(root->right, p, q);\\n        }\\n        else if(p->val<root->val and q->val<root->val){\\n            return lowestCommonAncestor(root->left, p, q);\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1742451,
                "title": "c-easiest-approach",
                "content": "**Please upvote if you like this approach \\\\ solution** \\uD83D\\uDE0A\\t\\n\\n\\t\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tTreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n\\n\\t\\t\\tTreeNode* currNode = root;\\n\\n\\t\\t\\twhile(currNode != NULL)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(currNode->val > p->val && currNode->val > q->val)           \\n\\t\\t\\t\\t\\tcurrNode = currNode->left;\\n\\n\\t\\t\\t\\telse if(currNode->val < p->val && currNode->val < q->val)\\n\\t\\t\\t\\t\\tcurrNode = currNode->right;\\n\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\treturn currNode;\\n\\t\\t\\t}\\n\\t\\t\\treturn NULL;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tTreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n\\n\\t\\t\\tTreeNode* currNode = root;\\n\\n\\t\\t\\twhile(currNode != NULL)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(currNode->val > p->val && currNode->val > q->val)           \\n\\t\\t\\t\\t\\tcurrNode = currNode->left;\\n\\n\\t\\t\\t\\telse if(currNode->val < p->val && currNode->val < q->val)\\n\\t\\t\\t\\t\\tcurrNode = currNode->right;\\n\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\treturn currNode;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1652166,
                "title": "simple-recursion-solution",
                "content": "**Simple Solution**\\n```\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        //IMP :\\n        //CASE1 : If root->val > p and root->val > q then LCA might be in left-subtree\\n        //CASE2 : if root->vl < p and root->val <p then LCA might be in right-subtree\\n        //CASE3 :  if none  of the cases is correct then it might  p is in left and q is in right or vice-verse then root->val which is pointing is the LCA \\n        \\n        if(!root)return nullptr;\\n        if(root->val < p->val and root->val <q->val)\\n            return lowestCommonAncestor(root->right,p,q);\\n        if(root->val > p->val and root->val > q->val)\\n            return lowestCommonAncestor(root->left,p,q);\\n        return root;\\n         \\n    }\\n};\\n```\\n\\n**TC : O(H) H is the height of BST**\\n*if you liked the post then please upvote thats keeps me motivating*\\uD83C\\uDF88\\uD83D\\uDE01\\n**:) happy coding**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        //IMP :\\n        //CASE1 : If root->val > p and root->val > q then LCA might be in left-subtree\\n        //CASE2 : if root->vl < p and root->val <p then LCA might be in right-subtree\\n        //CASE3 :  if none  of the cases is correct then it might  p is in left and q is in right or vice-verse then root->val which is pointing is the LCA \\n        \\n        if(!root)return nullptr;\\n        if(root->val < p->val and root->val <q->val)\\n            return lowestCommonAncestor(root->right,p,q);\\n        if(root->val > p->val and root->val > q->val)\\n            return lowestCommonAncestor(root->left,p,q);\\n        return root;\\n         \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1448532,
                "title": "lowest-common-ancestor-of-a-binary-search-tree-java-recursion-solution",
                "content": "```\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if (root == null){\\n            return null;\\n        } else if (root.val > p.val && root.val > q.val){\\n            return lowestCommonAncestor(root.left, p, q);\\n        } else if (root.val < p.val && root.val < q.val){\\n\\t\\t\\treturn lowestCommonAncestor(root.right, p, q);\\n        } else {\\n            return root;\\n        }\\n    }\\n}\\n```\\n\\nIf it helped, please UPVOTE. Happy Coding and keep up the good work.\\nFeel free to give your suggestions or correct me in the comments.\\nThanks for reading.\\uD83D\\uDE43",
                "solutionTags": [
                    "Java",
                    "Binary Search Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if (root == null){\\n            return null;\\n        } else if (root.val > p.val && root.val > q.val){\\n            return lowestCommonAncestor(root.left, p, q);\\n        } else if (root.val < p.val && root.val < q.val){\\n\\t\\t\\treturn lowestCommonAncestor(root.right, p, q);\\n        } else {\\n            return root;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1433131,
                "title": "js-o-n-solution-with-explanation",
                "content": "```\\nvar lowestCommonAncestor = function(root, p, q) { \\n\\t// condition 1: if both p and q node value if less than the root node value,\\n\\t// that means that both nodes lie on its left side\\n    if(root.val > p.val && root.val > q.val) {\\n        return lowestCommonAncestor(root.left, p, q);\\n    } else if(root.val < p.val && root.val < q.val) {\\n\\t\\t// condition2: if both p and q node value is greater than the root node value, \\n\\t\\t// that means that both nodes lie on its right side\\n        return lowestCommonAncestor(root.right, p, q);\\n    }\\n\\t// condition 3: if p and q node lie on either side of the root node, that means\\n\\t// root node itself is the lowest common ancestor, so return root node\\n    return root;\\n};\\n```\\nTime Complexity = O(n)\\nSpace Complexity = O(n) [call stack]",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\nvar lowestCommonAncestor = function(root, p, q) { \\n\\t// condition 1: if both p and q node value if less than the root node value,\\n\\t// that means that both nodes lie on its left side\\n    if(root.val > p.val && root.val > q.val) {\\n        return lowestCommonAncestor(root.left, p, q);\\n    } else if(root.val < p.val && root.val < q.val) {\\n\\t\\t// condition2: if both p and q node value is greater than the root node value, \\n\\t\\t// that means that both nodes lie on its right side\\n        return lowestCommonAncestor(root.right, p, q);\\n    }\\n\\t// condition 3: if p and q node lie on either side of the root node, that means\\n\\t// root node itself is the lowest common ancestor, so return root node\\n    return root;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1348583,
                "title": "lowest-common-ancestor-of-a-binary-search-tree-recursion-commented",
                "content": "```\\n//function to check element is present or not \\n bool isPresent(TreeNode* root, TreeNode* node){\\n        if(root == NULL) return false;\\n        if(root->val == node->val) return true;\\n        return isPresent(root->left,node) | isPresent(root->right,node);\\n    }\\n    \\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n\\t//either anyone is present as a root\\n\\t// or both are present in oppsite side\\n\\t//then root will be LCA\\n        if(    root->val == p->val || root->val == q->val \\n           || (isPresent(root->left,p) && isPresent(root->right,q))\\n           || (isPresent(root->left,q) && isPresent(root->right,p))\\n          ) \\n              return root;\\n     //otherwise if both are in left side recusively call for left subtree   \\n        if(isPresent(root->left,p) && isPresent(root->left,q)){\\n            return lowestCommonAncestor(root->left, p, q);\\n        }\\n\\t\\t//o.w. right subtree\\n        else \\n            return lowestCommonAncestor(root->right, p, q);\\n        \\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n//function to check element is present or not \\n bool isPresent(TreeNode* root, TreeNode* node){\\n        if(root == NULL) return false;\\n        if(root->val == node->val) return true;\\n        return isPresent(root->left,node) | isPresent(root->right,node);\\n    }\\n    \\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n\\t//either anyone is present as a root\\n\\t// or both are present in oppsite side\\n\\t//then root will be LCA\\n        if(    root->val == p->val || root->val == q->val \\n           || (isPresent(root->left,p) && isPresent(root->right,q))\\n           || (isPresent(root->left,q) && isPresent(root->right,p))\\n          ) \\n              return root;\\n     //otherwise if both are in left side recusively call for left subtree   \\n        if(isPresent(root->left,p) && isPresent(root->left,q)){\\n            return lowestCommonAncestor(root->left, p, q);\\n        }\\n\\t\\t//o.w. right subtree\\n        else \\n            return lowestCommonAncestor(root->right, p, q);\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1295569,
                "title": "c-recursive-and-conversion-to-iteration",
                "content": "## Basic Idea of the Question\\nThis question is similar to [236. Lowest Common Ancestor of a Binary Tree](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/) except that the fact that the tree given to us is actually a Binary Search Tree helps us to find the elements more quickly.\\n\\nThe basic idea is that the Lowest Common Ancestor is a place where the paths from the root to the nodes diverge, or where one of the paths ends and the other continues.\\nThere can be one of three cases:\\n\\n1. Either one of them is the current subtree\\'s root itself.\\n2. Or they are in different subtrees.\\n3. Or they are in the same subtree.\\n\\nCases 1 and 2 are our base cases, since here the root will the LCA. Let\\'s consider these one by one to think why that is true.\\n\\n### Case 1:\\nIf one of the nodes is the root and the other one is one of the children of the root (assuming that the given nodes are not equal), then the Lowest Common Ancestor of these nodes is the node which is equal to the root, since the last common node in the paths from the root to these nodes, is that node. So we return the current root here.\\n\\n### Case 2:\\nIf the nodes are in different subtrees, then the path from the root of the tree to these nodes, will always diverge at this subtree\\'s root, thus making the current root as the LCA. So we return the current root again.\\n\\nIf both of the nodes are in the same subtree, then that means that we have not found the diverging point yet, so we recurse on whichever subtree they are in.\\n<br/>\\n## Approach\\nNow this is the exact same approach I used in the general question with Binary Trees as well. But here this approach can be made faster, since we can find whether a node exists in a particular subtree in O(1) (which was O(n) in the Binary Trees). We can check this by just comparing the node\\'s value to the value of the root. If it is less than root\\'s value, then the node is in the left subtree, else it is in the right subtree.\\nWe don\\'t have to worry about the grandparent\\'s value, since that would have already been checked in the upper levels.\\n<br/>\\n## Code\\nThe code for the above approach can be written as follows:\\n```\\nTreeNode *lowestCommonAncestor(TreeNode *root, TreeNode *p, TreeNode *q) {\\n\\tif(p == root || q == root) return root;\\n\\telse if(p->val < root->val) {\\n\\t\\t//p is in the left subtree\\n\\t\\tif(q->val < root->val) {\\n\\t\\t\\t//q is also in the left subtree\\n\\t\\t\\t//go left\\n\\t\\t\\treturn lowestCommonAncestor(root->left, p, q);\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\t//q is in the right subtree\\n\\t\\t\\t//they are in different subtrees\\n\\t\\t\\t//thus root is the LCA\\n\\t\\t\\treturn root;\\n\\t\\t}\\n\\t}\\n\\telse {\\n\\t\\t//p is in the right subtree\\n\\t\\tif(q->val > root->val) {\\n\\t\\t\\t//q is also in the right subtree\\n\\t\\t\\t//go right\\n\\t\\t\\treturn lowestCommonAncestor(root->right, p, q);\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\t//q is in the left subtree\\n\\t\\t\\t//root is the LCA\\n\\t\\t\\treturn root;\\n\\t\\t}\\n\\t}\\n}\\n```\\n\\nAs you can see, this solution is recursive, but since the recursion is only tail recursion (i.e there is only one recursive call per function call), we can easily convert this into iterative solution.\\n\\nThe iterative solution can be written as follows:\\n```\\nTreeNode *lowestCommonAncestor(TreeNode *root, TreeNode *p, TreeNode *q) {\\n\\twhile(root != p && root!= q) {\\n\\t\\tif(p->val < root->val) {\\n\\t\\t\\tif(q->val < root->val) {\\n\\t\\t\\t\\t//go left\\n\\t\\t\\t\\troot = root->left;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\t//root is the LCA\\n\\t\\t\\t\\treturn root;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tif(q->val < root->val) {\\n\\t\\t\\t\\t//root is the LCA\\n\\t\\t\\t\\treturn root;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\t//go right\\n\\t\\t\\t\\troot = root->right;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn root;\\n}\\n```\\n\\n**Time: O(h)** where h is the height of the BST, since in the worst case we would find the LCA at the second last level (when p and q are leaves). In a balanced BST, this will be O(logn), since the height is maintained O(logn) in it.\\n\\n**Space: O(h)** in the case of the recursive solution (the call stack space), and **O(1)** in the case of the iterative solution.\\n\\nFeel free to ask any doubts or suggest any corrections/improvements in the comments.\\nUpvote the post if you liked it!\\n",
                "solutionTags": [
                    "C",
                    "Binary Search Tree",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nTreeNode *lowestCommonAncestor(TreeNode *root, TreeNode *p, TreeNode *q) {\\n\\tif(p == root || q == root) return root;\\n\\telse if(p->val < root->val) {\\n\\t\\t//p is in the left subtree\\n\\t\\tif(q->val < root->val) {\\n\\t\\t\\t//q is also in the left subtree\\n\\t\\t\\t//go left\\n\\t\\t\\treturn lowestCommonAncestor(root->left, p, q);\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\t//q is in the right subtree\\n\\t\\t\\t//they are in different subtrees\\n\\t\\t\\t//thus root is the LCA\\n\\t\\t\\treturn root;\\n\\t\\t}\\n\\t}\\n\\telse {\\n\\t\\t//p is in the right subtree\\n\\t\\tif(q->val > root->val) {\\n\\t\\t\\t//q is also in the right subtree\\n\\t\\t\\t//go right\\n\\t\\t\\treturn lowestCommonAncestor(root->right, p, q);\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\t//q is in the left subtree\\n\\t\\t\\t//root is the LCA\\n\\t\\t\\treturn root;\\n\\t\\t}\\n\\t}\\n}\\n```\n```\\nTreeNode *lowestCommonAncestor(TreeNode *root, TreeNode *p, TreeNode *q) {\\n\\twhile(root != p && root!= q) {\\n\\t\\tif(p->val < root->val) {\\n\\t\\t\\tif(q->val < root->val) {\\n\\t\\t\\t\\t//go left\\n\\t\\t\\t\\troot = root->left;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\t//root is the LCA\\n\\t\\t\\t\\treturn root;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tif(q->val < root->val) {\\n\\t\\t\\t\\t//root is the LCA\\n\\t\\t\\t\\treturn root;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\t//go right\\n\\t\\t\\t\\troot = root->right;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn root;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 741744,
                "title": "swift",
                "content": "```\\nclass Solution {\\n    func lowestCommonAncestor(_ root: TreeNode?, _ p: TreeNode?, _ q: TreeNode?) -> TreeNode? {\\n        guard let root = root, let p = p, let q = q else { return nil }\\n                \\n        if root.val < p.val && root.val < q.val {\\n            return lowestCommonAncestor(root.right, p, q)\\n        } else if root.val > p.val && root.val > q.val {\\n            return lowestCommonAncestor(root.left, p, q)\\n        } else {\\n            return root\\n        }\\n        return nil\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func lowestCommonAncestor(_ root: TreeNode?, _ p: TreeNode?, _ q: TreeNode?) -> TreeNode? {\\n        guard let root = root, let p = p, let q = q else { return nil }\\n                \\n        if root.val < p.val && root.val < q.val {\\n            return lowestCommonAncestor(root.right, p, q)\\n        } else if root.val > p.val && root.val > q.val {\\n            return lowestCommonAncestor(root.left, p, q)\\n        } else {\\n            return root\\n        }\\n        return nil\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 649712,
                "title": "c-solution",
                "content": "```\\npublic class Solution {\\n    public TreeNode LowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if (root == null)\\n            return null;\\n        else if (root.val >= p.val && root.val <= q.val || root.val <= p.val && root.val >= q.val)\\n            return root;\\n        else if (root. val >= p.val)\\n            return LowestCommonAncestor(root.left, p, q);\\n        else\\n            return LowestCommonAncestor(root.right, p, q);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public TreeNode LowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if (root == null)\\n            return null;\\n        else if (root.val >= p.val && root.val <= q.val || root.val <= p.val && root.val >= q.val)\\n            return root;\\n        else if (root. val >= p.val)\\n            return LowestCommonAncestor(root.left, p, q);\\n        else\\n            return LowestCommonAncestor(root.right, p, q);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 447701,
                "title": "golang-iterative-solution",
                "content": "```go\\n/**\\n * Definition for TreeNode.\\n * type TreeNode struct {\\n *     Val int\\n *     Left *ListNode\\n *     Right *ListNode\\n * }\\n */\\nfunc lowestCommonAncestor(root, p, q *TreeNode) *TreeNode {\\n\\tval1, val2 := p.Val, q.Val\\n\\tcur := root\\n\\tfor {\\n\\t\\tswitch {\\n\\t\\tcase val1 < cur.Val && val2 < cur.Val:\\n\\t\\t\\tcur = cur.Left\\n\\t\\tcase val1 > cur.Val && val2 > cur.Val:\\n\\t\\t\\tcur = cur.Right\\n\\t\\tdefault:\\n\\t\\t\\treturn cur\\n\\t\\t}\\n\\t}\\n\\treturn root\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\n/**\\n * Definition for TreeNode.\\n * type TreeNode struct {\\n *     Val int\\n *     Left *ListNode\\n *     Right *ListNode\\n * }\\n */\\nfunc lowestCommonAncestor(root, p, q *TreeNode) *TreeNode {\\n\\tval1, val2 := p.Val, q.Val\\n\\tcur := root\\n\\tfor {\\n\\t\\tswitch {\\n\\t\\tcase val1 < cur.Val && val2 < cur.Val:\\n\\t\\t\\tcur = cur.Left\\n\\t\\tcase val1 > cur.Val && val2 > cur.Val:\\n\\t\\t\\tcur = cur.Right\\n\\t\\tdefault:\\n\\t\\t\\treturn cur\\n\\t\\t}\\n\\t}\\n\\treturn root\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 198717,
                "title": "5-lines-simple-java-solution-faster-than-100-o-1-space-complexity",
                "content": "```\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        while(root != null){\\n            if(p.val < root.val && q.val < root.val) root = root.left;\\n            else if(p.val > root.val && q.val > root.val) root = root.right;\\n            else return root;\\n        }\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        while(root != null){\\n            if(p.val < root.val && q.val < root.val) root = root.left;\\n            else if(p.val > root.val && q.val > root.val) root = root.right;\\n            else return root;\\n        }\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 168777,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def lowestCommonAncestor(self, root, p, q):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: TreeNode\\n        \"\"\"\\n        pval, qval = min(p.val,q.val), max(p.val,q.val)\\n        res = root\\n        while not pval <= res.val <= qval:\\n            if res.val < pval:\\n                res = res.right\\n            else:\\n                res = res.left\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def lowestCommonAncestor(self, root, p, q):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: TreeNode\\n        \"\"\"\\n        pval, qval = min(p.val,q.val), max(p.val,q.val)\\n        res = root\\n        while not pval <= res.val <= qval:\\n            if res.val < pval:\\n                res = res.right\\n            else:\\n                res = res.left\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 65078,
                "title": "javascript-solution",
                "content": "    var lowestCommonAncestor = function(root, p, q) {\\n        //If the value of p is less than the root and q is less than the root, go to the left\\n        if (p.val < root.val && q.val < root.val) {\\n            return lowestCommonAncestor(root.left, p, q);\\n        }\\n        //If the value of p is greater than the root and q is greater than the root, go to the right\\n        else if (p.val > root.val && q.val > root.val) {\\n            return lowestCommonAncestor(root.right, p, q);\\n        }\\n        //We found it!\\n        else {\\n            return root;\\n        }\\n    };",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "    var lowestCommonAncestor = function(root, p, q) {\\n        //If the value of p is less than the root and q is less than the root, go to the left\\n        if (p.val < root.val && q.val < root.val) {\\n            return lowestCommonAncestor(root.left, p, q);\\n        }\\n        //If the value of p is greater than the root and q is greater than the root, go to the right\\n        else if (p.val > root.val && q.val > root.val) {\\n            return lowestCommonAncestor(root.right, p, q);\\n        }\\n        //We found it!\\n        else {\\n            return root;\\n        }\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 65085,
                "title": "share-some-extension-lca-of-k-nodes-in-a-bst-or-binary-tree",
                "content": "original question 1: LCA of 2 nodes in a BST.\\n\\nsolution 1:\\n\\n    public class Solution {\\n        public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n            if (root == null || p == null || q == null)\\n                return null;\\n            \\n            TreeNode result = root; \\n            int l = min(p.val, q.val);\\n            int r = max(p.val, q.val);\\n            while (!(l <= result.val && result.val <= r))\\n                if (result.val < l)\\n                    result = result.right;\\n                else\\n                    result = result.left;\\n            return result;\\n        }\\n        int min(int a, int b){\\n            return a < b? a: b;\\n        }\\n        int max(int a, int b){\\n            return a > b? a: b;\\n        }\\n    }\\n\\nextension question 2: to find LCA of two node in binary tree, e.g., not binary search tree.\\n\\nsolution 2:\\n\\n    public class Solution {\\n        TreeNode result = null;\\n        boolean findp = false;\\n        boolean findq = false;\\n        public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n            dfs(root, p, q);\\n            return result;\\n        }\\n        int dfs(TreeNode root, TreeNode p, TreeNode q){\\n            if (root == null || (findp && findq))\\n                return 0;\\n                \\n            int cur = 0;\\n            if (root == p){\\n                cur += 2;\\n                findp = true;\\n            }\\n            if (root == q){\\n                cur +=1;\\n                findq = true;\\n            }\\n               \\n            int left = dfs(root.left, p, q);\\n            int right = dfs(root.right, p, q);\\n    \\n            if (cur + left + right == 3 && result == null)\\n                result = root;\\n            return cur + left + right;\\n        }\\n    }\\n\\nextension question 3: LCA of k nodes in BST. \\n\\nsolution 3: only need to find max and min of k nodes and then to chang root into root.left or root.right according to the relationship of root.val and [min, max]. if root.val < min, let root = root.right; if root.val > max, let root = root.left; else this root is the answer. The complexity of time is O(k + logn) generally, and O(n) worst, and space is O(logn) generally, and O(n) worst.\\n\\nextension question 4: LCA of k nodes in binary tree(with the assumption of nodes are diffrent from each other).\\n\\nsolution 4.1: time O(n), space O(k + logn) to O(n);\\n\\n        class Solution{\\n            HashSet<TreeNode> hash = new HashSet<TreeNode>();\\n            TreeNode result = null;        \\n            TreeNode lowestCommonAncestor(TreeNode root, TreeNode[] nodes, int k)\\n            {\\n                for (node: nodes)\\n                    hash.put(node);\\n                dfs(root, nodes, k);\\n                return result;\\n            }\\n            int dfs(TreeNode root, int k){\\n                if (root == null || result != null)\\n                    return 0;\\n                \\n                int cur = hash.containsKey(root)? 1: 0;\\n                int l = dfs(root.left);\\n                int r = dfs(root.right);\\n                if (cur + l + r == k && result == null)\\n                    result = root;\\n                return l + r + cur;\\n            }\\n        }\\n\\nsolution 4.2: time O(n), space O(n), to convert the binary tree to BST, then to solve it. The conversion needs inorder traversal of the original binary tree and number assignment in new BST, thus it needs O(n) time and space.Because the solution of LCA of k nodes in BST need no more time and space than this transformation, the totle time and space is as above.\\n\\nsolution 4.3: time O(n + klogk), space O(k + logn + klogn), getting huffman codings of the k nodes and then obtaining the longest common preffix of these huffman codings and then finding the TreeNode corresponding to the preffix in the binary tree.",
                "solutionTags": [
                    "Binary Search",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n        public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n            if (root == null || p == null || q == null)\\n                return null;\\n            \\n            TreeNode result = root; \\n            int l = min(p.val, q.val);\\n            int r = max(p.val, q.val);\\n            while (!(l <= result.val && result.val <= r))\\n                if (result.val < l)\\n                    result = result.right;\\n                else\\n                    result = result.left;\\n            return result;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 65107,
                "title": "3-lines-concise-python-resolution",
                "content": "    class Solution(object):\\n    def lowestCommonAncestor(self, root, p, q):\\n        if (p.val <= root.val <= q.val or q.val <= root.val <= p.val): return root.val\\n        if (p.val < root.val and q.val < root.val): return self.lowestCommonAncestor(root.left, p, q)\\n        if (p.val > root.val and q.val > root.val): return self.lowestCommonAncestor(root.right, p, q)",
                "solutionTags": [],
                "code": "    class Solution(object):\\n    def lowestCommonAncestor(self, root, p, q):\\n        if (p.val <= root.val <= q.val or q.val <= root.val <= p.val): return root.val\\n        if (p.val < root.val and q.val < root.val): return self.lowestCommonAncestor(root.left, p, q)\\n        if (p.val > root.val and q.val > root.val): return self.lowestCommonAncestor(root.right, p, q)",
                "codeTag": "Java"
            },
            {
                "id": 65121,
                "title": "python-iterative-at-116-ms",
                "content": "    def lowestCommonAncestor(self, root, p, q):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: TreeNode\\n        \"\"\"\\n        if p == q:\\n            return p\\n        if not root or not p or not q:\\n            return None\\n        min_val = min(p.val, q.val)\\n        max_val = max(p.val, q.val)\\n        \\n        curr = root\\n        while curr:\\n            if curr.val>=min_val and curr.val<=max_val:\\n                return curr\\n            elif curr.val<min_val and curr.val<max_val:\\n                curr = curr.right\\n            elif curr.val>min_val and curr.val>max_val:\\n                curr = curr.left\\n                \\n        return None",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "    def lowestCommonAncestor(self, root, p, q):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: TreeNode\\n        \"\"\"\\n        if p == q:\\n            return p\\n        if not root or not p or not q:\\n            return None\\n        min_val = min(p.val, q.val)\\n        max_val = max(p.val, q.val)\\n        \\n        curr = root\\n        while curr:\\n            if curr.val>=min_val and curr.val<=max_val:\\n                return curr\\n            elif curr.val<min_val and curr.val<max_val:\\n                curr = curr.right\\n            elif curr.val>min_val and curr.val>max_val:\\n                curr = curr.left\\n                \\n        return None",
                "codeTag": "Python3"
            },
            {
                "id": 65130,
                "title": "9ms-java-solution",
                "content": "    public class Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        \\n\\t\\tif ((p.val <= root.val && q.val >= root.val)\\n\\t\\t\\t\\t|| (p.val >= root.val && q.val <= root.val)) {\\n\\t\\t\\treturn root;\\n\\t\\t} else if (p.val < root.val && q.val < root.val) {\\n\\t\\t\\treturn lowestCommonAncestor(root.left, p, q);\\n\\t\\t}else{\\n\\t\\t\\treturn lowestCommonAncestor(root.right, p, q);\\n\\t\\t}\\n\\t\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        \\n\\t\\tif ((p.val <= root.val && q.val >= root.val)\\n\\t\\t\\t\\t|| (p.val >= root.val && q.val <= root.val)) {\\n\\t\\t\\treturn root;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 65198,
                "title": "share-my-simple-c-code",
                "content": "     struct TreeNode {\\n          int val;\\n          TreeNode *left;\\n          TreeNode *right;\\n          TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n      };\\n     \\n    class Solution {\\n    public:\\n        TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n            if(p->val == root->val || q->val == root->val || (p->val < root->val && q->val > root->val) || (q->val < root->val && p->val > root->val))\\n            {\\n            \\treturn root;\\n            }\\n            else if(p->val < root->val && q->val < root->val)\\n            {\\n            \\treturn lowestCommonAncestor(root->left,p,q);\\n            }\\n            else\\n            \\treturn lowestCommonAncestor(root->right,p,q);\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n            if(p->val == root->val || q->val == root->val || (p->val < root->val && q->val > root->val) || (q->val < root->val && p->val > root->val))\\n            {\\n            \\treturn root;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3930446,
                "title": "easy-iterative-solution-using-traversal-in-python",
                "content": "# Code\\n```\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        pv=p.val\\n        qv=q.val\\n        while(root!=None):\\n            if pv <root.val and qv<root.val:\\n                root=root.left\\n            elif pv>root.val and qv>root.val:\\n                root=root.right\\n            else:\\n                return root\\n        return root\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        pv=p.val\\n        qv=q.val\\n        while(root!=None):\\n            if pv <root.val and qv<root.val:\\n                root=root.left\\n            elif pv>root.val and qv>root.val:\\n                root=root.right\\n            else:\\n                return root\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3724176,
                "title": "easy-to-understand-c-solution-recursive-o-logn",
                "content": "# Intuition & Approach\\n\\n-If root value is strictly greater then both the given value p and q then the possible common ancestor will always be in the left side of the tree.And root value is strictly lesser then p and q then the common ancestor will always be in right side of the tree.\\n-If previous two conditions is not satisfied then current root is the answer.\\n\\n\\n\\n# Complexity\\n- Time complexity:O(logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(logn)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if(root->val>p->val && root->val>q->val)\\n        {\\n           return lowestCommonAncestor(root->left,p,q);\\n        }\\n        else if(root->val<p->val && root->val<q->val)\\n        {\\n           return lowestCommonAncestor(root->right,p,q);\\n        }\\n        else \\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if(root->val>p->val && root->val>q->val)\\n        {\\n           return lowestCommonAncestor(root->left,p,q);\\n        }\\n        else if(root->val<p->val && root->val<q->val)\\n        {\\n           return lowestCommonAncestor(root->right,p,q);\\n        }\\n        else \\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3699700,
                "title": "cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe code finds the lowest common ancestor (LCA) of two nodes p and q in a binary search tree (BST). The LCA is the deepest node in the BST that has both p and q as descendants (where we allow a node to be a descendant of itself).\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe code defines a recursive function lowestCommonAncestor() that takes three TreeNode pointers root, p, and q as arguments. Within this function, it performs the following steps:\\n\\nIf p->val and q->val are both less than the value of root->val, it means that both p and q are in the left subtree of root. Therefore, the function recursively calls itself with root->left, p, and q as arguments and returns the result.\\nIf p->val and q->val are both greater than the value of root->val, it means that both p and q are in the right subtree of root. Therefore, the function recursively calls itself with root->right, p, and q as arguments and returns the result.\\nIf neither of the above conditions is true, it means that p and q are on different sides of root, or one of them is equal to root. In this case, root is the lowest common ancestor, so it is returned.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe code traverses the BST by recursively going left or right based on the values of p and q. In the worst case, the code visits every node in the BST, resulting in a time complexity of O(n), where n is the number of nodes in the BST.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is O(1) since the code uses only a constant amount of additional space, regardless of the input size.\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    \\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if (p->val < root->val && q->val < root->val) {\\n            return lowestCommonAncestor(root->left, p, q);\\n        } else if (p->val > root->val && q->val > root->val) {\\n            return lowestCommonAncestor(root->right, p, q);\\n        } else {\\n            return root;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    \\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if (p->val < root->val && q->val < root->val) {\\n            return lowestCommonAncestor(root->left, p, q);\\n        } else if (p->val > root->val && q->val > root->val) {\\n            return lowestCommonAncestor(root->right, p, q);\\n        } else {\\n            return root;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3655741,
                "title": "c-simplest-and-crisp-solution-ever",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if(root==NULL) return NULL;\\n        if(root->val>p->val && root->val>q->val) return lowestCommonAncestor(root->left,p,q);\\n        else if(root->val<p->val && root->val<q->val) return lowestCommonAncestor(root->right,p,q);\\n        else return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if(root==NULL) return NULL;\\n        if(root->val>p->val && root->val>q->val) return lowestCommonAncestor(root->left,p,q);\\n        else if(root->val<p->val && root->val<q->val) return lowestCommonAncestor(root->right,p,q);\\n        else return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3637628,
                "title": "simple-python-5-liner-recursive-approach-w-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe first thing to look out for is with most tree problems we know that there is most likely a recursive approch to solving the problem, which is generally easier to implement. Another thing is understanding why they chose to give a Binary Search Tree (BST) vs just a regular binary tree. When finding the lowest common ancestor (LCA) we can see that the LCA will always be bounded by the min and max of the two nodes. With just a normal tree this would not be the case making the solution more difficult.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor this approach we can see a lot of the normal base cases you would have to handle are not needed here. For example making sure that you have a valid root is not needed because we know there will always be a solution, so our base case just ends up being the answer. `if min(p.val,q.val) <= root.val <= max(q.val,p.val) ` This will check if the root is bounded between the min and max, and if it is we know we have founded the LCA. If this is not the case we continue, if the root is greater than the max, since this is a BST, we know the solution must be on the left side of the tree. Same logic for if the root is less than the min.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(h) - where h is the height of the tree, since we are cutting off half the tree each time we search farther\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1) - No additional space is needed\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        if min(p.val,q.val) <= root.val <= max(q.val,p.val): \\n            return root\\n        if root.val > max(q.val,p.val): \\n            return self.lowestCommonAncestor(root.left,p,q)\\n        return self.lowestCommonAncestor(root.right, p, q)\\n             \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        if min(p.val,q.val) <= root.val <= max(q.val,p.val): \\n            return root\\n        if root.val > max(q.val,p.val): \\n            return self.lowestCommonAncestor(root.left,p,q)\\n        return self.lowestCommonAncestor(root.right, p, q)\\n             \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3510148,
                "title": "java-really-easy-to-understand-solution",
                "content": "# Intuition\\nFind path from foot to p and path from root to q and find last equal path segment.\\n\\n\\n# Complexity\\n- Time complexity:\\nI think, $$O(n)$$, please correct me if i\\'m wrong\\n\\n- Space complexity:\\nI think, $$O(n)$$, please correct me if i\\'m wrong\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\n\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        TreeNode[] pPath = path(root, p);\\n        TreeNode[] qPath = path(root, q);\\n\\n        TreeNode last = null;\\n\\n        for (int i = 0; i < pPath.length; i++) {\\n            if (pPath[i] != qPath[i]) {\\n                return last;\\n            } else {\\n                last = pPath[i];\\n            }\\n        }\\n\\n        return null;\\n    }\\n\\n    public TreeNode[] path(TreeNode root, TreeNode end) {\\n        TreeNode[] result = new TreeNode[100000];\\n        int counter = 0;\\n        TreeNode current = root;\\n        boolean found = false;\\n\\n        while (current.val != end.val) {\\n            if (current.val < end.val) {\\n                result[counter] = current;\\n                current = current.right;\\n                counter++;\\n            } else {\\n                result[counter] = current;\\n                current = current.left;\\n                counter++;\\n            }\\n        }\\n\\n        result[counter] = current;\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\n\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        TreeNode[] pPath = path(root, p);\\n        TreeNode[] qPath = path(root, q);\\n\\n        TreeNode last = null;\\n\\n        for (int i = 0; i < pPath.length; i++) {\\n            if (pPath[i] != qPath[i]) {\\n                return last;\\n            } else {\\n                last = pPath[i];\\n            }\\n        }\\n\\n        return null;\\n    }\\n\\n    public TreeNode[] path(TreeNode root, TreeNode end) {\\n        TreeNode[] result = new TreeNode[100000];\\n        int counter = 0;\\n        TreeNode current = root;\\n        boolean found = false;\\n\\n        while (current.val != end.val) {\\n            if (current.val < end.val) {\\n                result[counter] = current;\\n                current = current.right;\\n                counter++;\\n            } else {\\n                result[counter] = current;\\n                current = current.left;\\n                counter++;\\n            }\\n        }\\n\\n        result[counter] = current;\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3449104,
                "title": "python3-easy-with-explanation",
                "content": "# Code\\n```\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        curr = root\\n        while curr:\\n            #if both values are greater than root then search in right part\\n            if p.val > curr.val and q.val > curr.val: curr = curr.right\\n\\n            #if both values are less than root then search in left part\\n            elif p.val < curr.val and q.val < curr.val: curr = curr.left\\n\\n            # else means one of them is in left subtree and \\n            # one of them is in right subtree\\n            # in this case lowest common ancestor is root or curr\\n            # so just return that\\n            else: return curr\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        curr = root\\n        while curr:\\n            #if both values are greater than root then search in right part\\n            if p.val > curr.val and q.val > curr.val: curr = curr.right\\n\\n            #if both values are less than root then search in left part\\n            elif p.val < curr.val and q.val < curr.val: curr = curr.left\\n\\n            # else means one of them is in left subtree and \\n            # one of them is in right subtree\\n            # in this case lowest common ancestor is root or curr\\n            # so just return that\\n            else: return curr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3448238,
                "title": "simple-solution-in-two-way-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nGiven a binary search tree (BST) and two nodes, we need to find the lowest common ancestor (LCA) node of both nodes in the BST. A LCA is the lowest node in the tree that has both nodes as its descendants.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can solve this problem using a recursive approach. We start at the root node and check if the values of both nodes lie on either side of the root. If they are, we continue our search in the respective left or right subtree of the root. If the values of the nodes are equal or one of them is the root itself, we return the root. This is because the root is an ancestor of both nodes and it is the lowest such ancestor as we are searching from top to bottom.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this approach is O(h), where h is the height of the BST. In the worst case, the height of the tree can be equal to the number of nodes in the tree, which makes the time complexity O(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of this approach is O(h) due to the recursion stack. In the worst case, the height of the tree can be equal to the number of nodes in the tree, which makes the space complexity O(n).\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n\\n        # Using recursion\\n        if p.val < root.val and q.val < root.val:\\n            return self.lowestCommonAncestor(root.left,p,q)\\n        elif p.val > root.val and q.val > root.val:\\n            return self.lowestCommonAncestor(root.right,p,q)\\n        else:\\n            return root\\n\\n        # while root:\\n        #     if p.val < root.val and q.val < root.val:\\n        #         root = root.left\\n        #     elif p.val > root.val and q.val > root.val:\\n        #         root = root.right\\n        #     else:\\n        #         return root\\n\\n\\n         \\n                \\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n\\n        # Using recursion\\n        if p.val < root.val and q.val < root.val:\\n            return self.lowestCommonAncestor(root.left,p,q)\\n        elif p.val > root.val and q.val > root.val:\\n            return self.lowestCommonAncestor(root.right,p,q)\\n        else:\\n            return root\\n\\n        # while root:\\n        #     if p.val < root.val and q.val < root.val:\\n        #         root = root.left\\n        #     elif p.val > root.val and q.val > root.val:\\n        #         root = root.right\\n        #     else:\\n        #         return root\\n\\n\\n         \\n                \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3431458,
                "title": "i-bet-1000-you-can-understand",
                "content": "# Intuition\\nTo solve this task you should only remember BST invariant: left child value < root value and root value > right child value. It means that if root value is between children values then it is LCA. Else you should continue your search in right or left subtree of current root\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nLet $k$ = depth of tree, then time complexity will be $O(k)$ because level decreases each step\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nFunction stack will hold $O(k)$ memory\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if (root == p || root == q){\\n            return root;\\n        }\\n        if (p->val < root->val && root->val < q->val || q->val < root->val && root->val < p->val){\\n            return root;\\n        } else if (p->val < root->val && q->val < root->val){\\n            return lowestCommonAncestor(root->left, p, q);\\n        }\\n        return lowestCommonAncestor(root->right, p, q);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if (root == p || root == q){\\n            return root;\\n        }\\n        if (p->val < root->val && root->val < q->val || q->val < root->val && root->val < p->val){\\n            return root;\\n        } else if (p->val < root->val && q->val < root->val){\\n            return lowestCommonAncestor(root->left, p, q);\\n        }\\n        return lowestCommonAncestor(root->right, p, q);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3384014,
                "title": "javascript-php-recursive-iterative-approaches",
                "content": "\\nThe Lowest Common Ancestor (LCA) of a Binary Search Tree (BST) is the deepest node in the tree which has both the given nodes as its descendants. Finding the LCA of a BST is a challenging task as the tree needs to be traversed in order to identify the LCA.\\n\\nThere are two approaches that can be used to solve the problem: the Recursive Approach and the Iterative Approach. \\n**The Recursive Approach** involves breaking down the problem into subproblems and solving them one by one until the LCA is found. \\n**The Iterative Approach** utilizes a loop structure to traverse the tree and identify the LCA. \\n\\nBoth approaches have their own pros and cons and are usually used depending on the requirement and the user\\'s preference.\\n\\n\\n\\n### Recursive Approach\\n\\nThis approach uses recursion to traverse the binary tree. The logic is that if the root node is greater than both the p and q nodes, then both p and q are in the left subtree and the function recursively calls itself on the left subtree. If the root node is less than both the p and q nodes, then both p and q are in the right subtree and the function recursively calls itself on the right subtree. If neither of these conditions is true, then the root node is the Lowest Common Ancestor.\\n\\n*Time Complexity:* $$O(log N)$$, where n is the total number of nodes in the tree.\\n*Space Complexity:* $$O(log N)$$ This approach has a space complexity of O(log N) as it requires the recursive stack to store the nodes of the binary tree when the function is called.\\n\\n```javascript []\\nvar lowestCommonAncestor = function (root, p, q) {\\n    // both p and q are in the left subtree\\n    if (root.val > p.val && root.val > q.val) {\\n        return lowestCommonAncestor(root.left, p, q);\\n    }\\n    // both p and q are in the right subtree\\n    if (root.val < p.val && root.val < q.val) {\\n        return lowestCommonAncestor(root.right, p, q);\\n    }\\n\\n    return root;\\n};\\n```\\n```php []\\nclass Solution\\n{\\n    /**\\n     * @param TreeNode $root\\n     * @param TreeNode $p\\n     * @param TreeNode $q\\n     * @return TreeNode\\n     */\\n    function lowestCommonAncestor($root, $p, $q) {\\n        if ($root->val > $p->val && $root->val > $q->val) return $this->lowestCommonAncestor($root->left, $p, $q);\\n        if ($root->val < $p->val && $root->val < $q->val) return $this->lowestCommonAncestor($root->right, $p, $q);\\n        return $root;\\n    }\\n}\\n```\\n\\n\\n### Iterative Approach\\nThis approach uses an iterative method to find the Lowest Common Ancestor (LCA) of two nodes in a Binary Tree. We start by initializing a variable (root) to the root of the Binary Tree and comparing its value to the values of the two nodes. If the root\\'s value is greater than the values of both nodes, we move the root to the left child of the root. If the root\\'s value is less than the values of both nodes, we move the root to the right child of the root. If neither condition is satisfied, the root is the LCA and is returned. If none of the nodes are found, null is returned. \\n\\n*Time complexity*: $$O(log N)$$ The time complexity of this algorithm is O(log n) because it is using a Binary Search Tree (BST). BSTs have a time complexity of log(n) for searching, so this algorithm has a time complexity of O(logn).\\n*Space complexity*: $$O(1)$$ The space complexity is constant since no additional space is required to solve the problem.\\n\\n```javascript []\\nvar lowestCommonAncestor = function (root, p, q) {\\n    while (root !== null) {\\n        if (root.val > p.val && root.val > q.val) {\\n            root = root.left\\n        } else if (root.val < p.val && root.val < q.val) {\\n            root = root.right\\n        } else {\\n            return root;\\n        }\\n    }\\n    return null\\n};\\n```\\n```php []\\nclass Solution\\n{\\n    /**\\n     * @param TreeNode $root\\n     * @param TreeNode $p\\n     * @param TreeNode $q\\n     * @return TreeNode\\n     */\\n    function lowestCommonAncestor(TreeNode $root, TreeNode $p, TreeNode $q): ?TreeNode {\\n        while ($root) {\\n            if ($root->val > $p->val && $root->val > $q->val) {\\n                $root = $root->left;\\n            } elseif ($root->val < $p->val && $root->val < $q->val) {\\n                $root = $root->right;\\n            } else {\\n                return $root;\\n            }\\n        }\\n        return null;\\n    }\\n}\\n```\\n##### Thanks for reading! If you have any questions or suggestions, please leave a comment below. I would love to hear your thoughts! \\uD83D\\uDE0A\\n### **Please upvote if you found this post helpful! \\uD83D\\uDC4D**",
                "solutionTags": [
                    "JavaScript",
                    "PHP",
                    "Binary Tree"
                ],
                "code": "```javascript []\\nvar lowestCommonAncestor = function (root, p, q) {\\n    // both p and q are in the left subtree\\n    if (root.val > p.val && root.val > q.val) {\\n        return lowestCommonAncestor(root.left, p, q);\\n    }\\n    // both p and q are in the right subtree\\n    if (root.val < p.val && root.val < q.val) {\\n        return lowestCommonAncestor(root.right, p, q);\\n    }\\n\\n    return root;\\n};\\n```\n```php []\\nclass Solution\\n{\\n    /**\\n     * @param TreeNode $root\\n     * @param TreeNode $p\\n     * @param TreeNode $q\\n     * @return TreeNode\\n     */\\n    function lowestCommonAncestor($root, $p, $q) {\\n        if ($root->val > $p->val && $root->val > $q->val) return $this->lowestCommonAncestor($root->left, $p, $q);\\n        if ($root->val < $p->val && $root->val < $q->val) return $this->lowestCommonAncestor($root->right, $p, $q);\\n        return $root;\\n    }\\n}\\n```\n```javascript []\\nvar lowestCommonAncestor = function (root, p, q) {\\n    while (root !== null) {\\n        if (root.val > p.val && root.val > q.val) {\\n            root = root.left\\n        } else if (root.val < p.val && root.val < q.val) {\\n            root = root.right\\n        } else {\\n            return root;\\n        }\\n    }\\n    return null\\n};\\n```\n```php []\\nclass Solution\\n{\\n    /**\\n     * @param TreeNode $root\\n     * @param TreeNode $p\\n     * @param TreeNode $q\\n     * @return TreeNode\\n     */\\n    function lowestCommonAncestor(TreeNode $root, TreeNode $p, TreeNode $q): ?TreeNode {\\n        while ($root) {\\n            if ($root->val > $p->val && $root->val > $q->val) {\\n                $root = $root->left;\\n            } elseif ($root->val < $p->val && $root->val < $q->val) {\\n                $root = $root->right;\\n            } else {\\n                return $root;\\n            }\\n        }\\n        return null;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3204214,
                "title": "c-3line-code-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root,TreeNode* p,TreeNode* q,TreeNode* &ans){\\n        if(root == NULL)return;\\n        if(root->val<p->val&&root->val<q->val){\\n            solve(root->right,p,q,ans);\\n        }else if(root->val>p->val&&root->val>q->val){\\n            solve(root->left,p,q,ans);\\n        }else{\\n            ans = root;\\n            return;\\n        }\\n    }\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        TreeNode* ans;\\n        solve(root,p,q,ans);\\n        return ans;\\n    }\\n};```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root,TreeNode* p,TreeNode* q,TreeNode* &ans){\\n        if(root == NULL)return;\\n        if(root->val<p->val&&root->val<q->val){\\n            solve(root->right,p,q,ans);\\n        }else if(root->val>p->val&&root->val>q->val){\\n            solve(root->left,p,q,ans);\\n        }else{\\n            ans = root;\\n            return;\\n        }\\n    }\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        TreeNode* ans;\\n        solve(root,p,q,ans);\\n        return ans;\\n    }\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 3142025,
                "title": "c-simple-iterative-approach",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIn this problem, a BST is given. Every descendant on the right of the node is guaranteed to be greater than the node, and every descendant to the left of the node is lesser than it.\\n\\nTherefore, to find the lowest common ancestor, we only have to find the one, the value of which is in between the values of the given nodes.\\n\\nIf the node is not the lowest ancestor -> both of the descendants are located either to the left or to the right of it, therefore both of their values are strictly larger or smaller than its own\\n# Complexity\\n- Time complexity: $$O(h)$$ h - heigth of the tree\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        while(root->val > max(p->val, q->val) or root->val < min(p->val, q->val)) {\\n            if (root->val < min (p->val, q->val)) root = root->right;\\n            else root = root->left;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Binary Search Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        while(root->val > max(p->val, q->val) or root->val < min(p->val, q->val)) {\\n            if (root->val < min (p->val, q->val)) root = root->right;\\n            else root = root->left;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2919375,
                "title": "javascript-solution-beated-98-easy-solution",
                "content": "# Code\\n```\\nvar lowestCommonAncestor = function(root, p, q) {\\n    if(!root)\\n    return \\n    if((p.val<root.val && q.val<root.val)){\\n       return lowestCommonAncestor(root.left, p, q)\\n    }\\n    else if(p.val>root.val && q.val>root.val){\\n      return  lowestCommonAncestor(root.right, p, q)\\n    }\\nreturn root\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar lowestCommonAncestor = function(root, p, q) {\\n    if(!root)\\n    return \\n    if((p.val<root.val && q.val<root.val)){\\n       return lowestCommonAncestor(root.left, p, q)\\n    }\\n    else if(p.val>root.val && q.val>root.val){\\n      return  lowestCommonAncestor(root.right, p, q)\\n    }\\nreturn root\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2725324,
                "title": "java-dfs-and-bfs-clean-and-simple",
                "content": "### **Please Upvote** :D\\n##### 1. DFS approach:\\n```\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if (root == null) return null;\\n        int curr = root.val;\\n        \\n        if (p.val > curr && q.val > curr) {\\n            return lowestCommonAncestor(root.right, p, q);\\n        }\\n        \\n        if (p.val < curr && q.val < curr) {\\n            return lowestCommonAncestor(root.left, p, q);\\n        }\\n        \\n        return root;\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```\\n##### 2. BFS approach:\\n```\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        Queue<TreeNode> queue  = new LinkedList<>();\\n        queue.offer(root);\\n        TreeNode result = null;\\n\\n        while (!queue.isEmpty()) {\\n            TreeNode curr = queue.poll();\\n\\n            if (p.val <= curr.val && q.val >= curr.val ||\\n                p.val >= curr.val && q.val <= curr.val) {\\n                return curr;\\n            }\\n\\n            if (p.val > curr.val && q.val > curr.val) {\\n                if (curr.left != null) queue.offer(curr.right);\\n            }\\n\\n            if (p.val < curr.val && q.val < curr.val) {\\n                if (curr.right != null) queue.offer(curr.left);\\n            }\\n        }\\n\\n        return null;\\n    }\\n}\\n\\n// TC: O(n), SC: O(n)\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if (root == null) return null;\\n        int curr = root.val;\\n        \\n        if (p.val > curr && q.val > curr) {\\n            return lowestCommonAncestor(root.right, p, q);\\n        }\\n        \\n        if (p.val < curr && q.val < curr) {\\n            return lowestCommonAncestor(root.left, p, q);\\n        }\\n        \\n        return root;\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```\n```\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        Queue<TreeNode> queue  = new LinkedList<>();\\n        queue.offer(root);\\n        TreeNode result = null;\\n\\n        while (!queue.isEmpty()) {\\n            TreeNode curr = queue.poll();\\n\\n            if (p.val <= curr.val && q.val >= curr.val ||\\n                p.val >= curr.val && q.val <= curr.val) {\\n                return curr;\\n            }\\n\\n            if (p.val > curr.val && q.val > curr.val) {\\n                if (curr.left != null) queue.offer(curr.right);\\n            }\\n\\n            if (p.val < curr.val && q.val < curr.val) {\\n                if (curr.right != null) queue.offer(curr.left);\\n            }\\n        }\\n\\n        return null;\\n    }\\n}\\n\\n// TC: O(n), SC: O(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2670498,
                "title": "java-iterative-solution",
                "content": "```\\npublic TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        \\n        while( root != null){\\n            if(root.val > p.val && root.val > q.val){\\n                root = root.left;\\n            }\\n            else if(root.val < p.val && root.val < q.val){\\n                root = root.right;\\n            }else{\\n                return root;\\n            }\\n        }\\n        return root;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Iterator"
                ],
                "code": "```\\npublic TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        \\n        while( root != null){\\n            if(root.val > p.val && root.val > q.val){\\n                root = root.left;\\n            }\\n            else if(root.val < p.val && root.val < q.val){\\n                root = root.right;\\n            }else{\\n                return root;\\n            }\\n        }\\n        return root;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2569055,
                "title": "java-100-fastest-easiest-o-height-of-tree",
                "content": "![image](https://assets.leetcode.com/users/images/48de1b6f-fa84-445b-a539-28cc2b0ce473_1663040098.4296865.png)\\n* T.C : O(logN)\\n* S.C : O(1)\\n```\\nWe will travel until we find a divergent point(use the fact that we\\'ve been given a BST). \\nJust draw a BST and simulate...everything will be clear!!\\n```\\n![image](https://assets.leetcode.com/users/images/21dee653-1cd5-49c4-b31e-71c143c79796_1663040329.2819753.png)\\n```\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if(root==null)return root;\\n        if(root.val>p.val&&root.val>q.val)return lowestCommonAncestor(root.left,p,q);\\n        else if(root.val<p.val&&root.val<q.val)return lowestCommonAncestor(root.right,p,q);\\n        return root;\\n    }\\n}\\n```\\n```\\n---------------------------------------------------------PLEASE UPVOTE IF YOU LIKE!!----------------------------------------------------------\\u2014\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Iterator"
                ],
                "code": "```\\nWe will travel until we find a divergent point(use the fact that we\\'ve been given a BST). \\nJust draw a BST and simulate...everything will be clear!!\\n```\n```\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if(root==null)return root;\\n        if(root.val>p.val&&root.val>q.val)return lowestCommonAncestor(root.left,p,q);\\n        else if(root.val<p.val&&root.val<q.val)return lowestCommonAncestor(root.right,p,q);\\n        return root;\\n    }\\n}\\n```\n```\\n---------------------------------------------------------PLEASE UPVOTE IF YOU LIKE!!----------------------------------------------------------\\u2014\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2508999,
                "title": "typescript-javascript-dfs-with-comments",
                "content": "```\\nfunction lowestCommonAncestor(root: TreeNode | null, p: TreeNode | null, q: TreeNode | null): TreeNode | null {\\n  return dfs(root, p, q);\\n};\\n\\nfunction dfs(root: TreeNode | null, p: TreeNode | null, q: TreeNode | null) {\\n  // if any of the values are null, just return the value of root\\n  if([root, p, q].includes(null)) return root;\\n  \\n  // if both values are greater than root\\n  // the LCS is in right subtree\\n  if(p.val > root.val && q.val > root.val)\\n    return dfs(root.right, p, q)\\n  \\n  // if both values are less than root\\n  // then LCS is in left subtree\\n  if(p.val < root.val && q.val < root.val)\\n    return dfs(root.left, p, q);\\n  \\n  // if there\\'s a split\\n  // then we found our LCS\\n  return root;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Depth-First Search"
                ],
                "code": "```\\nfunction lowestCommonAncestor(root: TreeNode | null, p: TreeNode | null, q: TreeNode | null): TreeNode | null {\\n  return dfs(root, p, q);\\n};\\n\\nfunction dfs(root: TreeNode | null, p: TreeNode | null, q: TreeNode | null) {\\n  // if any of the values are null, just return the value of root\\n  if([root, p, q].includes(null)) return root;\\n  \\n  // if both values are greater than root\\n  // the LCS is in right subtree\\n  if(p.val > root.val && q.val > root.val)\\n    return dfs(root.right, p, q)\\n  \\n  // if both values are less than root\\n  // then LCS is in left subtree\\n  if(p.val < root.val && q.val < root.val)\\n    return dfs(root.left, p, q);\\n  \\n  // if there\\'s a split\\n  // then we found our LCS\\n  return root;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2472344,
                "title": "c-3-line-soln-o-logn",
                "content": "```\\nif (root->val < min(p->val, q->val)) return lowestCommonAncestor(root->right, p, q);\\nelse if (root->val > max(p->val, q->val)) return lowestCommonAncestor(root->left, p, q);\\nreturn root;",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nif (root->val < min(p->val, q->val)) return lowestCommonAncestor(root->right, p, q);\\nelse if (root->val > max(p->val, q->val)) return lowestCommonAncestor(root->left, p, q);\\nreturn root;",
                "codeTag": "Unknown"
            },
            {
                "id": 2463135,
                "title": "c-iterative-clean-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        while(root){\\n            if(root->val < p->val && root->val < q->val) root = root->right;\\n            else if(root->val > p->val && root->val > q->val) root = root->left;\\n            else break;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        while(root){\\n            if(root->val < p->val && root->val < q->val) root = root->right;\\n            else if(root->val > p->val && root->val > q->val) root = root->left;\\n            else break;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2441026,
                "title": "python-easy-solution-faster-than-90",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        min_val, max_val = min(p.val,q.val), max(p.val,q.val)\\n        \\n        while True:\\n            if min_val<= root.val <= max_val:\\n                return root\\n            elif max_val<root.val:\\n                root = root.left\\n            else:\\n                root = root.right\\n                \\n        \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        min_val, max_val = min(p.val,q.val), max(p.val,q.val)\\n        \\n        while True:\\n            if min_val<= root.val <= max_val:\\n                return root\\n            elif max_val<root.val:\\n                root = root.left\\n            else:\\n                root = root.right\\n                \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2425886,
                "title": "java-solution-easy-approach",
                "content": "```\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if(p.val<root.val && q.val<root.val)\\n        return lowestCommonAncestor(root.left,p,q);\\n        else if(p.val>root.val && q.val>root.val)\\n        return lowestCommonAncestor(root.right,p,q);\\n        else\\n        return root;\\n    }\\n}",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if(p.val<root.val && q.val<root.val)\\n        return lowestCommonAncestor(root.left,p,q);\\n        else if(p.val>root.val && q.val>root.val)\\n        return lowestCommonAncestor(root.right,p,q);\\n        else\\n        return root;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2415394,
                "title": "python-log-n-solution-explained",
                "content": "\\n# Time complexity correction:\\n`Log(n)` - for a balanced tree\\n`O(n)` - For imbalanced tree\\n\\n# Intuition\\n\\nThe LCA of a binary tree is the first node where the values of q and p branch in opposite directions, left and right.\\n\\nLet\\'s say given the following tree\\n\\n![image](https://assets.leetcode.com/users/images/1a7dc4e3-21bf-484c-9318-787184996ce6_1660305410.086411.png)\\n\\nIf we start at 6, to get to `0` and `4` we branch left for both.\\n\\nThen from 2 we must go opposite directions, this is the LCA node.\\n\\n# Code\\n\\n```\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        while True:\\n            if root.val > p.val and root.val > q.val: root = root.left\\n            elif root.val < p.val and root.val < q.val: root = root.right\\n\\t\\t\\t# Found LCA\\n            else: return root\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        while True:\\n            if root.val > p.val and root.val > q.val: root = root.left\\n            elif root.val < p.val and root.val < q.val: root = root.right\\n\\t\\t\\t# Found LCA\\n            else: return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2414137,
                "title": "13-ms-runtime-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        \\n        if(root == NULL || root == p || root == q)\\n        {\\n            return root;\\n        }\\n        int less = min(p->val,q->val);\\n        int more = max(p->val,q->val);\\n        \\n        while(1)\\n        {\\n            if(root == p || root == q)\\n            {\\n                return root;\\n            }\\n            if(root->val > less && root-> val < more)\\n            {\\n                return root;\\n            }\\n            if(less > root->val)\\n            {\\n                root = root->right;\\n            }\\n            else\\n            {\\n                root = root->left;\\n            }\\n        }\\n        \\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        \\n        if(root == NULL || root == p || root == q)\\n        {\\n            return root;\\n        }\\n        int less = min(p->val,q->val);\\n        int more = max(p->val,q->val);\\n        \\n        while(1)\\n        {\\n            if(root == p || root == q)\\n            {\\n                return root;\\n            }\\n            if(root->val > less && root-> val < more)\\n            {\\n                return root;\\n            }\\n            if(less > root->val)\\n            {\\n                root = root->right;\\n            }\\n            else\\n            {\\n                root = root->left;\\n            }\\n        }\\n        \\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2413997,
                "title": "recursion-simple",
                "content": "```\\n\\tTreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if(root == NULL || root == p || root == q) return root;\\n        \\n        TreeNode* l = lowestCommonAncestor(root->left ,p,q);\\n        TreeNode* r = lowestCommonAncestor(root->right,p,q);\\n        \\n        if(!l) return r;\\n        if(!r) return l;\\n        \\n        return root;\\n    }",
                "solutionTags": [
                    "C",
                    "Tree"
                ],
                "code": "```\\n\\tTreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if(root == NULL || root == p || root == q) return root;\\n        \\n        TreeNode* l = lowestCommonAncestor(root->left ,p,q);\\n        TreeNode* r = lowestCommonAncestor(root->right,p,q);\\n        \\n        if(!l) return r;\\n        if(!r) return l;\\n        \\n        return root;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2413252,
                "title": "python-binary-search-tree-technique-iterative",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        small, large = min(p.val, q.val), max(p.val, q.val)\\n        while root:\\n            if root.val < small:\\n                root = root.right\\n            elif root.val > large:\\n                root = root.left\\n            else:\\n                return root\\n        return None\\n```\\n**I hope that you\\'ve found this useful.**\\n**In that case, please upvote. It motivates me to write more such posts\\uD83D\\uDE03**\\nComment below if you have any queries.",
                "solutionTags": [
                    "Python",
                    "Binary Search Tree"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        small, large = min(p.val, q.val), max(p.val, q.val)\\n        while root:\\n            if root.val < small:\\n                root = root.right\\n            elif root.val > large:\\n                root = root.left\\n            else:\\n                return root\\n        return None\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2413209,
                "title": "c-recursion-solution",
                "content": "\\'\\'\\'\\n# class Solution {\\n# public:\\n#     TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n#           if(root==NULL || root==p || root==q)\\n#             return root;\\n#         root->left=lowestCommonAncestor(root->left,p,q);\\n#         root->right=lowestCommonAncestor(root->right,p,q);\\n#         if(root->left==NULL)\\n#             return root->right;\\n#         else if(root->right==NULL)\\n#             return root->left;\\n#         else\\n#             return root;\\n#     }\\n# };\\n# \\'\\'\\'",
                "solutionTags": [
                    "Tree",
                    "Recursion"
                ],
                "code": "class Solution {\\n# public:\\n#     TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n#           if(root==NULL || root==p || root==q)\\n#             return root;\\n#         root->left=lowestCommonAncestor(root->left,p,q);\\n#         root->right=lowestCommonAncestor(root->right,p,q);\\n#         if(root->left==NULL)\\n#             return root->right;\\n#         else if(root->right==NULL)\\n#             return root->left;\\n#         else\\n#             return root;\\n#     }",
                "codeTag": "Java"
            },
            {
                "id": 2358788,
                "title": "easy-understanding-javascript-solution",
                "content": "Property of BTS is all right subtrees of root will have greater value than root and all left subtrees of root will have lesser value than root.\\n\\nCommon ancestor will justify this condition p.val < root.val > q.val\\n\\nSo if p.val < root.val and q.val < root.val,\\nmove root to its left i.e root=root.left\\n\\nSo if p.val > root.val and q.val > root.val,\\nmove root to its right i.e root=root.right\\n\\nelse we have our root ancestor\\n\\n\\n```\\nvar lowestCommonAncestor = function(root, p, q) {\\n    while(root){\\n        if(p.val>root.val && q.val>root.val){\\n            root=root.right\\n        }else if(p.val<root.val && q.val<root.val){\\n            root=root.left\\n        }else{\\n            return root\\n        }\\n    }\\n}\\n```\\n\\nRuntime: 115 ms, faster than 65.24% of JavaScript online submissions for Lowest Common Ancestor of a Binary Search Tree.\\nMemory Usage: 51.9 MB, less than 88.07% of JavaScript online submissions for Lowest Common Ancestor of a Binary Search Tree.\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar lowestCommonAncestor = function(root, p, q) {\\n    while(root){\\n        if(p.val>root.val && q.val>root.val){\\n            root=root.right\\n        }else if(p.val<root.val && q.val<root.val){\\n            root=root.left\\n        }else{\\n            return root\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1691189,
                "content": [
                    {
                        "username": "Jayusc",
                        "content": "so this is lowest common ancestor, not smallest common ancestor. I am an idiot"
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "what a bad wording for the title!"
                    },
                    {
                        "username": "rayrogar",
                        "content": "why,why,why mr Anderson, Why the tricky title"
                    },
                    {
                        "username": "rahulnegi2021",
                        "content": "us."
                    },
                    {
                        "username": "mpostrel",
                        "content": "omg thanks for clarifying. me too :( "
                    },
                    {
                        "username": "Cyril-0110",
                        "content": "You\\'re not alone :)"
                    },
                    {
                        "username": "tunsmm0",
                        "content": "I was confused about these situation too. They mean not value of node, but place of node in the tree. So in case where p = 7 and q = 9, the lowest will 8, not 6"
                    },
                    {
                        "username": "IvanStebletsov",
                        "content": "Refreshing my knowledge about key traits of binary search tree very helped me find simple solution for this problem. I\\'d recommend you start from it.\\n\\nBST has following traits:\\n1) Both root\\'s subtrees also are binary (it is not important for solution, but just FYI);\\n2) All **LEFT** child nodes of **LEFT** subtree have values **less or equal** the value of the current node.\\n2) All **RIGHT** child nodes of **RIGHT** subtree have values **greater** the value of the current node.\\n\\nKeeping in mind these traits we can start traverse tree in depth (DFS).\\n\\nMain idea: \\n- If **current node value > p.value and q.value**, hence according to trait **\\u21162** above, it\\'s useless search common node for **p** and **q** in the **right** subtree -> continue traverse next node in **left** subtree.\\n- If **current node value < p.value and q.value**, hence according to trait **\\u21163** above, it\\'s useless search common node for **p** and **q** in the **left** subtree  -> continue traverse next node in **right** subtree\\n- If according to statements above it\\'s useless search common node in both **left** and **right** subtree, it means that you are in a right place, you have found Lowest Common Ancestor.\\n\\nUsing this idea you can solve problem both iteratively and recursively.\\n\\nIf I\\'m not mistaken time complexity will be O(logN), because every time we chose only one subtree, therefore reduce count of traversable nodes twice. Memory complexity O(1).\\n\\nHope it will be helpful."
                    },
                    {
                        "username": "vskamade206",
                        "content": "Nice One brother\\n"
                    },
                    {
                        "username": "advanced-bencoding",
                        "content": "Remember that lowestCommonAncestor is in terms of depth level and not common node value based!"
                    },
                    {
                        "username": "veekshithcb",
                        "content": "thanks I was scratching head without understanding question completely "
                    },
                    {
                        "username": "noseonarug17",
                        "content": "For anyone who got confused and frustrated because output was inexplicably `undefined` - despite the way it displays the output, it wants you to return the node itself, not the value. This was true for Javascript, anyway."
                    },
                    {
                        "username": "Spacetoaster",
                        "content": "wow, this was frustrating, thanks"
                    },
                    {
                        "username": "yfang82",
                        "content": "Hint: search for the first value that is between p and q. That will be your lowest common ancestor"
                    },
                    {
                        "username": "Noob_SWEbot",
                        "content": "This is a great hint! Should be the default hint in the problem description. "
                    },
                    {
                        "username": "rstone13",
                        "content": "That\\'s absolutely brilliant! Here I was trying to figure out how to track if p and q have been found and if the current node is a parent of both p and q and all that."
                    },
                    {
                        "username": "misters",
                        "content": "        if(root.val > p.val && root.val > q.val) return lowestCommonAncestor(root.left, p, q);\\n        else if(root.val < p.val && root.val < q.val) return lowestCommonAncestor(root.right, p, q);\\n        else return root;"
                    },
                    {
                        "username": "olejiksa",
                        "content": "[@Khushi_Mattu](/Khushi_Mattu) you can use iterative approach for this problem. Iterative search in BST runs faster"
                    },
                    {
                        "username": "khushimattu",
                        "content": "can anyone tell a better solution then this? I did with the same logic but mine only beats 13% which means it can be optimised."
                    },
                    {
                        "username": "AMATEURTOSS",
                        "content": "genius"
                    },
                    {
                        "username": "vimlife",
                        "content": "Please no answers in the discussion section. See rules"
                    },
                    {
                        "username": "onomojo",
                        "content": "I stupidly overlooked the BST part and started trying to solve it as a generic tree. Obviously that way over-complicates it. "
                    },
                    {
                        "username": "ayukumi",
                        "content": " same code will work fine for both BST as well as BT "
                    },
                    {
                        "username": "g4b0r",
                        "content": "Is there a way I can extend this question so it supports swift? Or is that something the original author has to do?"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Nothing is stopping you from translating the answer into other languages. In fact that is a great way to internalize the material."
                    },
                    {
                        "username": "cjsy",
                        "content": "if the input is: \\n[2, 5, 6]\\n5\\n6\\n\\nwhy the results is 6? Why not 2?"
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "this is not a bst bro\\n"
                    },
                    {
                        "username": "AsumalSingh",
                        "content": "because node can be a descendant of itself"
                    },
                    {
                        "username": "Sidchou",
                        "content": "[@yestrup](/yestrup) but the question doesnt mention anything about valid binary tree"
                    },
                    {
                        "username": "Sidchou",
                        "content": "yeah i got same question, why is [5,3,6,2,4,null,null,1], 6,1 expecting 5, not 2"
                    },
                    {
                        "username": "yestrup",
                        "content": "[2, 5, 6] is not a valid binary tree"
                    },
                    {
                        "username": "anujp99",
                        "content": "[@hayduke415](/hayduke415) This is because it is asking for the Lowest common ancestor, not the smallest. It is going by height/level."
                    },
                    {
                        "username": "upup1904",
                        "content": "I guess `[2,5,6]` is ambiguous.  In that case it means 5 is right child of 2 and 6 is right child of 5.  I guess?"
                    },
                    {
                        "username": "hayduke415",
                        "content": "I have the same question! wouldn\\'t the lowestcommon ancestor of 8-9 be 6?"
                    },
                    {
                        "username": "elsayedzahran789",
                        "content": "BST Problems are the best"
                    },
                    {
                        "username": "srapol",
                        "content": "nah man"
                    }
                ]
            },
            {
                "id": 1798606,
                "content": [
                    {
                        "username": "Jayusc",
                        "content": "so this is lowest common ancestor, not smallest common ancestor. I am an idiot"
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "what a bad wording for the title!"
                    },
                    {
                        "username": "rayrogar",
                        "content": "why,why,why mr Anderson, Why the tricky title"
                    },
                    {
                        "username": "rahulnegi2021",
                        "content": "us."
                    },
                    {
                        "username": "mpostrel",
                        "content": "omg thanks for clarifying. me too :( "
                    },
                    {
                        "username": "Cyril-0110",
                        "content": "You\\'re not alone :)"
                    },
                    {
                        "username": "tunsmm0",
                        "content": "I was confused about these situation too. They mean not value of node, but place of node in the tree. So in case where p = 7 and q = 9, the lowest will 8, not 6"
                    },
                    {
                        "username": "IvanStebletsov",
                        "content": "Refreshing my knowledge about key traits of binary search tree very helped me find simple solution for this problem. I\\'d recommend you start from it.\\n\\nBST has following traits:\\n1) Both root\\'s subtrees also are binary (it is not important for solution, but just FYI);\\n2) All **LEFT** child nodes of **LEFT** subtree have values **less or equal** the value of the current node.\\n2) All **RIGHT** child nodes of **RIGHT** subtree have values **greater** the value of the current node.\\n\\nKeeping in mind these traits we can start traverse tree in depth (DFS).\\n\\nMain idea: \\n- If **current node value > p.value and q.value**, hence according to trait **\\u21162** above, it\\'s useless search common node for **p** and **q** in the **right** subtree -> continue traverse next node in **left** subtree.\\n- If **current node value < p.value and q.value**, hence according to trait **\\u21163** above, it\\'s useless search common node for **p** and **q** in the **left** subtree  -> continue traverse next node in **right** subtree\\n- If according to statements above it\\'s useless search common node in both **left** and **right** subtree, it means that you are in a right place, you have found Lowest Common Ancestor.\\n\\nUsing this idea you can solve problem both iteratively and recursively.\\n\\nIf I\\'m not mistaken time complexity will be O(logN), because every time we chose only one subtree, therefore reduce count of traversable nodes twice. Memory complexity O(1).\\n\\nHope it will be helpful."
                    },
                    {
                        "username": "vskamade206",
                        "content": "Nice One brother\\n"
                    },
                    {
                        "username": "advanced-bencoding",
                        "content": "Remember that lowestCommonAncestor is in terms of depth level and not common node value based!"
                    },
                    {
                        "username": "veekshithcb",
                        "content": "thanks I was scratching head without understanding question completely "
                    },
                    {
                        "username": "noseonarug17",
                        "content": "For anyone who got confused and frustrated because output was inexplicably `undefined` - despite the way it displays the output, it wants you to return the node itself, not the value. This was true for Javascript, anyway."
                    },
                    {
                        "username": "Spacetoaster",
                        "content": "wow, this was frustrating, thanks"
                    },
                    {
                        "username": "yfang82",
                        "content": "Hint: search for the first value that is between p and q. That will be your lowest common ancestor"
                    },
                    {
                        "username": "Noob_SWEbot",
                        "content": "This is a great hint! Should be the default hint in the problem description. "
                    },
                    {
                        "username": "rstone13",
                        "content": "That\\'s absolutely brilliant! Here I was trying to figure out how to track if p and q have been found and if the current node is a parent of both p and q and all that."
                    },
                    {
                        "username": "misters",
                        "content": "        if(root.val > p.val && root.val > q.val) return lowestCommonAncestor(root.left, p, q);\\n        else if(root.val < p.val && root.val < q.val) return lowestCommonAncestor(root.right, p, q);\\n        else return root;"
                    },
                    {
                        "username": "olejiksa",
                        "content": "[@Khushi_Mattu](/Khushi_Mattu) you can use iterative approach for this problem. Iterative search in BST runs faster"
                    },
                    {
                        "username": "khushimattu",
                        "content": "can anyone tell a better solution then this? I did with the same logic but mine only beats 13% which means it can be optimised."
                    },
                    {
                        "username": "AMATEURTOSS",
                        "content": "genius"
                    },
                    {
                        "username": "vimlife",
                        "content": "Please no answers in the discussion section. See rules"
                    },
                    {
                        "username": "onomojo",
                        "content": "I stupidly overlooked the BST part and started trying to solve it as a generic tree. Obviously that way over-complicates it. "
                    },
                    {
                        "username": "ayukumi",
                        "content": " same code will work fine for both BST as well as BT "
                    },
                    {
                        "username": "g4b0r",
                        "content": "Is there a way I can extend this question so it supports swift? Or is that something the original author has to do?"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Nothing is stopping you from translating the answer into other languages. In fact that is a great way to internalize the material."
                    },
                    {
                        "username": "cjsy",
                        "content": "if the input is: \\n[2, 5, 6]\\n5\\n6\\n\\nwhy the results is 6? Why not 2?"
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "this is not a bst bro\\n"
                    },
                    {
                        "username": "AsumalSingh",
                        "content": "because node can be a descendant of itself"
                    },
                    {
                        "username": "Sidchou",
                        "content": "[@yestrup](/yestrup) but the question doesnt mention anything about valid binary tree"
                    },
                    {
                        "username": "Sidchou",
                        "content": "yeah i got same question, why is [5,3,6,2,4,null,null,1], 6,1 expecting 5, not 2"
                    },
                    {
                        "username": "yestrup",
                        "content": "[2, 5, 6] is not a valid binary tree"
                    },
                    {
                        "username": "anujp99",
                        "content": "[@hayduke415](/hayduke415) This is because it is asking for the Lowest common ancestor, not the smallest. It is going by height/level."
                    },
                    {
                        "username": "upup1904",
                        "content": "I guess `[2,5,6]` is ambiguous.  In that case it means 5 is right child of 2 and 6 is right child of 5.  I guess?"
                    },
                    {
                        "username": "hayduke415",
                        "content": "I have the same question! wouldn\\'t the lowestcommon ancestor of 8-9 be 6?"
                    },
                    {
                        "username": "elsayedzahran789",
                        "content": "BST Problems are the best"
                    },
                    {
                        "username": "srapol",
                        "content": "nah man"
                    }
                ]
            },
            {
                "id": 1705055,
                "content": [
                    {
                        "username": "Jayusc",
                        "content": "so this is lowest common ancestor, not smallest common ancestor. I am an idiot"
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "what a bad wording for the title!"
                    },
                    {
                        "username": "rayrogar",
                        "content": "why,why,why mr Anderson, Why the tricky title"
                    },
                    {
                        "username": "rahulnegi2021",
                        "content": "us."
                    },
                    {
                        "username": "mpostrel",
                        "content": "omg thanks for clarifying. me too :( "
                    },
                    {
                        "username": "Cyril-0110",
                        "content": "You\\'re not alone :)"
                    },
                    {
                        "username": "tunsmm0",
                        "content": "I was confused about these situation too. They mean not value of node, but place of node in the tree. So in case where p = 7 and q = 9, the lowest will 8, not 6"
                    },
                    {
                        "username": "IvanStebletsov",
                        "content": "Refreshing my knowledge about key traits of binary search tree very helped me find simple solution for this problem. I\\'d recommend you start from it.\\n\\nBST has following traits:\\n1) Both root\\'s subtrees also are binary (it is not important for solution, but just FYI);\\n2) All **LEFT** child nodes of **LEFT** subtree have values **less or equal** the value of the current node.\\n2) All **RIGHT** child nodes of **RIGHT** subtree have values **greater** the value of the current node.\\n\\nKeeping in mind these traits we can start traverse tree in depth (DFS).\\n\\nMain idea: \\n- If **current node value > p.value and q.value**, hence according to trait **\\u21162** above, it\\'s useless search common node for **p** and **q** in the **right** subtree -> continue traverse next node in **left** subtree.\\n- If **current node value < p.value and q.value**, hence according to trait **\\u21163** above, it\\'s useless search common node for **p** and **q** in the **left** subtree  -> continue traverse next node in **right** subtree\\n- If according to statements above it\\'s useless search common node in both **left** and **right** subtree, it means that you are in a right place, you have found Lowest Common Ancestor.\\n\\nUsing this idea you can solve problem both iteratively and recursively.\\n\\nIf I\\'m not mistaken time complexity will be O(logN), because every time we chose only one subtree, therefore reduce count of traversable nodes twice. Memory complexity O(1).\\n\\nHope it will be helpful."
                    },
                    {
                        "username": "vskamade206",
                        "content": "Nice One brother\\n"
                    },
                    {
                        "username": "advanced-bencoding",
                        "content": "Remember that lowestCommonAncestor is in terms of depth level and not common node value based!"
                    },
                    {
                        "username": "veekshithcb",
                        "content": "thanks I was scratching head without understanding question completely "
                    },
                    {
                        "username": "noseonarug17",
                        "content": "For anyone who got confused and frustrated because output was inexplicably `undefined` - despite the way it displays the output, it wants you to return the node itself, not the value. This was true for Javascript, anyway."
                    },
                    {
                        "username": "Spacetoaster",
                        "content": "wow, this was frustrating, thanks"
                    },
                    {
                        "username": "yfang82",
                        "content": "Hint: search for the first value that is between p and q. That will be your lowest common ancestor"
                    },
                    {
                        "username": "Noob_SWEbot",
                        "content": "This is a great hint! Should be the default hint in the problem description. "
                    },
                    {
                        "username": "rstone13",
                        "content": "That\\'s absolutely brilliant! Here I was trying to figure out how to track if p and q have been found and if the current node is a parent of both p and q and all that."
                    },
                    {
                        "username": "misters",
                        "content": "        if(root.val > p.val && root.val > q.val) return lowestCommonAncestor(root.left, p, q);\\n        else if(root.val < p.val && root.val < q.val) return lowestCommonAncestor(root.right, p, q);\\n        else return root;"
                    },
                    {
                        "username": "olejiksa",
                        "content": "[@Khushi_Mattu](/Khushi_Mattu) you can use iterative approach for this problem. Iterative search in BST runs faster"
                    },
                    {
                        "username": "khushimattu",
                        "content": "can anyone tell a better solution then this? I did with the same logic but mine only beats 13% which means it can be optimised."
                    },
                    {
                        "username": "AMATEURTOSS",
                        "content": "genius"
                    },
                    {
                        "username": "vimlife",
                        "content": "Please no answers in the discussion section. See rules"
                    },
                    {
                        "username": "onomojo",
                        "content": "I stupidly overlooked the BST part and started trying to solve it as a generic tree. Obviously that way over-complicates it. "
                    },
                    {
                        "username": "ayukumi",
                        "content": " same code will work fine for both BST as well as BT "
                    },
                    {
                        "username": "g4b0r",
                        "content": "Is there a way I can extend this question so it supports swift? Or is that something the original author has to do?"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Nothing is stopping you from translating the answer into other languages. In fact that is a great way to internalize the material."
                    },
                    {
                        "username": "cjsy",
                        "content": "if the input is: \\n[2, 5, 6]\\n5\\n6\\n\\nwhy the results is 6? Why not 2?"
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "this is not a bst bro\\n"
                    },
                    {
                        "username": "AsumalSingh",
                        "content": "because node can be a descendant of itself"
                    },
                    {
                        "username": "Sidchou",
                        "content": "[@yestrup](/yestrup) but the question doesnt mention anything about valid binary tree"
                    },
                    {
                        "username": "Sidchou",
                        "content": "yeah i got same question, why is [5,3,6,2,4,null,null,1], 6,1 expecting 5, not 2"
                    },
                    {
                        "username": "yestrup",
                        "content": "[2, 5, 6] is not a valid binary tree"
                    },
                    {
                        "username": "anujp99",
                        "content": "[@hayduke415](/hayduke415) This is because it is asking for the Lowest common ancestor, not the smallest. It is going by height/level."
                    },
                    {
                        "username": "upup1904",
                        "content": "I guess `[2,5,6]` is ambiguous.  In that case it means 5 is right child of 2 and 6 is right child of 5.  I guess?"
                    },
                    {
                        "username": "hayduke415",
                        "content": "I have the same question! wouldn\\'t the lowestcommon ancestor of 8-9 be 6?"
                    },
                    {
                        "username": "elsayedzahran789",
                        "content": "BST Problems are the best"
                    },
                    {
                        "username": "srapol",
                        "content": "nah man"
                    }
                ]
            },
            {
                "id": 1786219,
                "content": [
                    {
                        "username": "Jayusc",
                        "content": "so this is lowest common ancestor, not smallest common ancestor. I am an idiot"
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "what a bad wording for the title!"
                    },
                    {
                        "username": "rayrogar",
                        "content": "why,why,why mr Anderson, Why the tricky title"
                    },
                    {
                        "username": "rahulnegi2021",
                        "content": "us."
                    },
                    {
                        "username": "mpostrel",
                        "content": "omg thanks for clarifying. me too :( "
                    },
                    {
                        "username": "Cyril-0110",
                        "content": "You\\'re not alone :)"
                    },
                    {
                        "username": "tunsmm0",
                        "content": "I was confused about these situation too. They mean not value of node, but place of node in the tree. So in case where p = 7 and q = 9, the lowest will 8, not 6"
                    },
                    {
                        "username": "IvanStebletsov",
                        "content": "Refreshing my knowledge about key traits of binary search tree very helped me find simple solution for this problem. I\\'d recommend you start from it.\\n\\nBST has following traits:\\n1) Both root\\'s subtrees also are binary (it is not important for solution, but just FYI);\\n2) All **LEFT** child nodes of **LEFT** subtree have values **less or equal** the value of the current node.\\n2) All **RIGHT** child nodes of **RIGHT** subtree have values **greater** the value of the current node.\\n\\nKeeping in mind these traits we can start traverse tree in depth (DFS).\\n\\nMain idea: \\n- If **current node value > p.value and q.value**, hence according to trait **\\u21162** above, it\\'s useless search common node for **p** and **q** in the **right** subtree -> continue traverse next node in **left** subtree.\\n- If **current node value < p.value and q.value**, hence according to trait **\\u21163** above, it\\'s useless search common node for **p** and **q** in the **left** subtree  -> continue traverse next node in **right** subtree\\n- If according to statements above it\\'s useless search common node in both **left** and **right** subtree, it means that you are in a right place, you have found Lowest Common Ancestor.\\n\\nUsing this idea you can solve problem both iteratively and recursively.\\n\\nIf I\\'m not mistaken time complexity will be O(logN), because every time we chose only one subtree, therefore reduce count of traversable nodes twice. Memory complexity O(1).\\n\\nHope it will be helpful."
                    },
                    {
                        "username": "vskamade206",
                        "content": "Nice One brother\\n"
                    },
                    {
                        "username": "advanced-bencoding",
                        "content": "Remember that lowestCommonAncestor is in terms of depth level and not common node value based!"
                    },
                    {
                        "username": "veekshithcb",
                        "content": "thanks I was scratching head without understanding question completely "
                    },
                    {
                        "username": "noseonarug17",
                        "content": "For anyone who got confused and frustrated because output was inexplicably `undefined` - despite the way it displays the output, it wants you to return the node itself, not the value. This was true for Javascript, anyway."
                    },
                    {
                        "username": "Spacetoaster",
                        "content": "wow, this was frustrating, thanks"
                    },
                    {
                        "username": "yfang82",
                        "content": "Hint: search for the first value that is between p and q. That will be your lowest common ancestor"
                    },
                    {
                        "username": "Noob_SWEbot",
                        "content": "This is a great hint! Should be the default hint in the problem description. "
                    },
                    {
                        "username": "rstone13",
                        "content": "That\\'s absolutely brilliant! Here I was trying to figure out how to track if p and q have been found and if the current node is a parent of both p and q and all that."
                    },
                    {
                        "username": "misters",
                        "content": "        if(root.val > p.val && root.val > q.val) return lowestCommonAncestor(root.left, p, q);\\n        else if(root.val < p.val && root.val < q.val) return lowestCommonAncestor(root.right, p, q);\\n        else return root;"
                    },
                    {
                        "username": "olejiksa",
                        "content": "[@Khushi_Mattu](/Khushi_Mattu) you can use iterative approach for this problem. Iterative search in BST runs faster"
                    },
                    {
                        "username": "khushimattu",
                        "content": "can anyone tell a better solution then this? I did with the same logic but mine only beats 13% which means it can be optimised."
                    },
                    {
                        "username": "AMATEURTOSS",
                        "content": "genius"
                    },
                    {
                        "username": "vimlife",
                        "content": "Please no answers in the discussion section. See rules"
                    },
                    {
                        "username": "onomojo",
                        "content": "I stupidly overlooked the BST part and started trying to solve it as a generic tree. Obviously that way over-complicates it. "
                    },
                    {
                        "username": "ayukumi",
                        "content": " same code will work fine for both BST as well as BT "
                    },
                    {
                        "username": "g4b0r",
                        "content": "Is there a way I can extend this question so it supports swift? Or is that something the original author has to do?"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Nothing is stopping you from translating the answer into other languages. In fact that is a great way to internalize the material."
                    },
                    {
                        "username": "cjsy",
                        "content": "if the input is: \\n[2, 5, 6]\\n5\\n6\\n\\nwhy the results is 6? Why not 2?"
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "this is not a bst bro\\n"
                    },
                    {
                        "username": "AsumalSingh",
                        "content": "because node can be a descendant of itself"
                    },
                    {
                        "username": "Sidchou",
                        "content": "[@yestrup](/yestrup) but the question doesnt mention anything about valid binary tree"
                    },
                    {
                        "username": "Sidchou",
                        "content": "yeah i got same question, why is [5,3,6,2,4,null,null,1], 6,1 expecting 5, not 2"
                    },
                    {
                        "username": "yestrup",
                        "content": "[2, 5, 6] is not a valid binary tree"
                    },
                    {
                        "username": "anujp99",
                        "content": "[@hayduke415](/hayduke415) This is because it is asking for the Lowest common ancestor, not the smallest. It is going by height/level."
                    },
                    {
                        "username": "upup1904",
                        "content": "I guess `[2,5,6]` is ambiguous.  In that case it means 5 is right child of 2 and 6 is right child of 5.  I guess?"
                    },
                    {
                        "username": "hayduke415",
                        "content": "I have the same question! wouldn\\'t the lowestcommon ancestor of 8-9 be 6?"
                    },
                    {
                        "username": "elsayedzahran789",
                        "content": "BST Problems are the best"
                    },
                    {
                        "username": "srapol",
                        "content": "nah man"
                    }
                ]
            },
            {
                "id": 1731348,
                "content": [
                    {
                        "username": "Jayusc",
                        "content": "so this is lowest common ancestor, not smallest common ancestor. I am an idiot"
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "what a bad wording for the title!"
                    },
                    {
                        "username": "rayrogar",
                        "content": "why,why,why mr Anderson, Why the tricky title"
                    },
                    {
                        "username": "rahulnegi2021",
                        "content": "us."
                    },
                    {
                        "username": "mpostrel",
                        "content": "omg thanks for clarifying. me too :( "
                    },
                    {
                        "username": "Cyril-0110",
                        "content": "You\\'re not alone :)"
                    },
                    {
                        "username": "tunsmm0",
                        "content": "I was confused about these situation too. They mean not value of node, but place of node in the tree. So in case where p = 7 and q = 9, the lowest will 8, not 6"
                    },
                    {
                        "username": "IvanStebletsov",
                        "content": "Refreshing my knowledge about key traits of binary search tree very helped me find simple solution for this problem. I\\'d recommend you start from it.\\n\\nBST has following traits:\\n1) Both root\\'s subtrees also are binary (it is not important for solution, but just FYI);\\n2) All **LEFT** child nodes of **LEFT** subtree have values **less or equal** the value of the current node.\\n2) All **RIGHT** child nodes of **RIGHT** subtree have values **greater** the value of the current node.\\n\\nKeeping in mind these traits we can start traverse tree in depth (DFS).\\n\\nMain idea: \\n- If **current node value > p.value and q.value**, hence according to trait **\\u21162** above, it\\'s useless search common node for **p** and **q** in the **right** subtree -> continue traverse next node in **left** subtree.\\n- If **current node value < p.value and q.value**, hence according to trait **\\u21163** above, it\\'s useless search common node for **p** and **q** in the **left** subtree  -> continue traverse next node in **right** subtree\\n- If according to statements above it\\'s useless search common node in both **left** and **right** subtree, it means that you are in a right place, you have found Lowest Common Ancestor.\\n\\nUsing this idea you can solve problem both iteratively and recursively.\\n\\nIf I\\'m not mistaken time complexity will be O(logN), because every time we chose only one subtree, therefore reduce count of traversable nodes twice. Memory complexity O(1).\\n\\nHope it will be helpful."
                    },
                    {
                        "username": "vskamade206",
                        "content": "Nice One brother\\n"
                    },
                    {
                        "username": "advanced-bencoding",
                        "content": "Remember that lowestCommonAncestor is in terms of depth level and not common node value based!"
                    },
                    {
                        "username": "veekshithcb",
                        "content": "thanks I was scratching head without understanding question completely "
                    },
                    {
                        "username": "noseonarug17",
                        "content": "For anyone who got confused and frustrated because output was inexplicably `undefined` - despite the way it displays the output, it wants you to return the node itself, not the value. This was true for Javascript, anyway."
                    },
                    {
                        "username": "Spacetoaster",
                        "content": "wow, this was frustrating, thanks"
                    },
                    {
                        "username": "yfang82",
                        "content": "Hint: search for the first value that is between p and q. That will be your lowest common ancestor"
                    },
                    {
                        "username": "Noob_SWEbot",
                        "content": "This is a great hint! Should be the default hint in the problem description. "
                    },
                    {
                        "username": "rstone13",
                        "content": "That\\'s absolutely brilliant! Here I was trying to figure out how to track if p and q have been found and if the current node is a parent of both p and q and all that."
                    },
                    {
                        "username": "misters",
                        "content": "        if(root.val > p.val && root.val > q.val) return lowestCommonAncestor(root.left, p, q);\\n        else if(root.val < p.val && root.val < q.val) return lowestCommonAncestor(root.right, p, q);\\n        else return root;"
                    },
                    {
                        "username": "olejiksa",
                        "content": "[@Khushi_Mattu](/Khushi_Mattu) you can use iterative approach for this problem. Iterative search in BST runs faster"
                    },
                    {
                        "username": "khushimattu",
                        "content": "can anyone tell a better solution then this? I did with the same logic but mine only beats 13% which means it can be optimised."
                    },
                    {
                        "username": "AMATEURTOSS",
                        "content": "genius"
                    },
                    {
                        "username": "vimlife",
                        "content": "Please no answers in the discussion section. See rules"
                    },
                    {
                        "username": "onomojo",
                        "content": "I stupidly overlooked the BST part and started trying to solve it as a generic tree. Obviously that way over-complicates it. "
                    },
                    {
                        "username": "ayukumi",
                        "content": " same code will work fine for both BST as well as BT "
                    },
                    {
                        "username": "g4b0r",
                        "content": "Is there a way I can extend this question so it supports swift? Or is that something the original author has to do?"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Nothing is stopping you from translating the answer into other languages. In fact that is a great way to internalize the material."
                    },
                    {
                        "username": "cjsy",
                        "content": "if the input is: \\n[2, 5, 6]\\n5\\n6\\n\\nwhy the results is 6? Why not 2?"
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "this is not a bst bro\\n"
                    },
                    {
                        "username": "AsumalSingh",
                        "content": "because node can be a descendant of itself"
                    },
                    {
                        "username": "Sidchou",
                        "content": "[@yestrup](/yestrup) but the question doesnt mention anything about valid binary tree"
                    },
                    {
                        "username": "Sidchou",
                        "content": "yeah i got same question, why is [5,3,6,2,4,null,null,1], 6,1 expecting 5, not 2"
                    },
                    {
                        "username": "yestrup",
                        "content": "[2, 5, 6] is not a valid binary tree"
                    },
                    {
                        "username": "anujp99",
                        "content": "[@hayduke415](/hayduke415) This is because it is asking for the Lowest common ancestor, not the smallest. It is going by height/level."
                    },
                    {
                        "username": "upup1904",
                        "content": "I guess `[2,5,6]` is ambiguous.  In that case it means 5 is right child of 2 and 6 is right child of 5.  I guess?"
                    },
                    {
                        "username": "hayduke415",
                        "content": "I have the same question! wouldn\\'t the lowestcommon ancestor of 8-9 be 6?"
                    },
                    {
                        "username": "elsayedzahran789",
                        "content": "BST Problems are the best"
                    },
                    {
                        "username": "srapol",
                        "content": "nah man"
                    }
                ]
            },
            {
                "id": 1565278,
                "content": [
                    {
                        "username": "Jayusc",
                        "content": "so this is lowest common ancestor, not smallest common ancestor. I am an idiot"
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "what a bad wording for the title!"
                    },
                    {
                        "username": "rayrogar",
                        "content": "why,why,why mr Anderson, Why the tricky title"
                    },
                    {
                        "username": "rahulnegi2021",
                        "content": "us."
                    },
                    {
                        "username": "mpostrel",
                        "content": "omg thanks for clarifying. me too :( "
                    },
                    {
                        "username": "Cyril-0110",
                        "content": "You\\'re not alone :)"
                    },
                    {
                        "username": "tunsmm0",
                        "content": "I was confused about these situation too. They mean not value of node, but place of node in the tree. So in case where p = 7 and q = 9, the lowest will 8, not 6"
                    },
                    {
                        "username": "IvanStebletsov",
                        "content": "Refreshing my knowledge about key traits of binary search tree very helped me find simple solution for this problem. I\\'d recommend you start from it.\\n\\nBST has following traits:\\n1) Both root\\'s subtrees also are binary (it is not important for solution, but just FYI);\\n2) All **LEFT** child nodes of **LEFT** subtree have values **less or equal** the value of the current node.\\n2) All **RIGHT** child nodes of **RIGHT** subtree have values **greater** the value of the current node.\\n\\nKeeping in mind these traits we can start traverse tree in depth (DFS).\\n\\nMain idea: \\n- If **current node value > p.value and q.value**, hence according to trait **\\u21162** above, it\\'s useless search common node for **p** and **q** in the **right** subtree -> continue traverse next node in **left** subtree.\\n- If **current node value < p.value and q.value**, hence according to trait **\\u21163** above, it\\'s useless search common node for **p** and **q** in the **left** subtree  -> continue traverse next node in **right** subtree\\n- If according to statements above it\\'s useless search common node in both **left** and **right** subtree, it means that you are in a right place, you have found Lowest Common Ancestor.\\n\\nUsing this idea you can solve problem both iteratively and recursively.\\n\\nIf I\\'m not mistaken time complexity will be O(logN), because every time we chose only one subtree, therefore reduce count of traversable nodes twice. Memory complexity O(1).\\n\\nHope it will be helpful."
                    },
                    {
                        "username": "vskamade206",
                        "content": "Nice One brother\\n"
                    },
                    {
                        "username": "advanced-bencoding",
                        "content": "Remember that lowestCommonAncestor is in terms of depth level and not common node value based!"
                    },
                    {
                        "username": "veekshithcb",
                        "content": "thanks I was scratching head without understanding question completely "
                    },
                    {
                        "username": "noseonarug17",
                        "content": "For anyone who got confused and frustrated because output was inexplicably `undefined` - despite the way it displays the output, it wants you to return the node itself, not the value. This was true for Javascript, anyway."
                    },
                    {
                        "username": "Spacetoaster",
                        "content": "wow, this was frustrating, thanks"
                    },
                    {
                        "username": "yfang82",
                        "content": "Hint: search for the first value that is between p and q. That will be your lowest common ancestor"
                    },
                    {
                        "username": "Noob_SWEbot",
                        "content": "This is a great hint! Should be the default hint in the problem description. "
                    },
                    {
                        "username": "rstone13",
                        "content": "That\\'s absolutely brilliant! Here I was trying to figure out how to track if p and q have been found and if the current node is a parent of both p and q and all that."
                    },
                    {
                        "username": "misters",
                        "content": "        if(root.val > p.val && root.val > q.val) return lowestCommonAncestor(root.left, p, q);\\n        else if(root.val < p.val && root.val < q.val) return lowestCommonAncestor(root.right, p, q);\\n        else return root;"
                    },
                    {
                        "username": "olejiksa",
                        "content": "[@Khushi_Mattu](/Khushi_Mattu) you can use iterative approach for this problem. Iterative search in BST runs faster"
                    },
                    {
                        "username": "khushimattu",
                        "content": "can anyone tell a better solution then this? I did with the same logic but mine only beats 13% which means it can be optimised."
                    },
                    {
                        "username": "AMATEURTOSS",
                        "content": "genius"
                    },
                    {
                        "username": "vimlife",
                        "content": "Please no answers in the discussion section. See rules"
                    },
                    {
                        "username": "onomojo",
                        "content": "I stupidly overlooked the BST part and started trying to solve it as a generic tree. Obviously that way over-complicates it. "
                    },
                    {
                        "username": "ayukumi",
                        "content": " same code will work fine for both BST as well as BT "
                    },
                    {
                        "username": "g4b0r",
                        "content": "Is there a way I can extend this question so it supports swift? Or is that something the original author has to do?"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Nothing is stopping you from translating the answer into other languages. In fact that is a great way to internalize the material."
                    },
                    {
                        "username": "cjsy",
                        "content": "if the input is: \\n[2, 5, 6]\\n5\\n6\\n\\nwhy the results is 6? Why not 2?"
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "this is not a bst bro\\n"
                    },
                    {
                        "username": "AsumalSingh",
                        "content": "because node can be a descendant of itself"
                    },
                    {
                        "username": "Sidchou",
                        "content": "[@yestrup](/yestrup) but the question doesnt mention anything about valid binary tree"
                    },
                    {
                        "username": "Sidchou",
                        "content": "yeah i got same question, why is [5,3,6,2,4,null,null,1], 6,1 expecting 5, not 2"
                    },
                    {
                        "username": "yestrup",
                        "content": "[2, 5, 6] is not a valid binary tree"
                    },
                    {
                        "username": "anujp99",
                        "content": "[@hayduke415](/hayduke415) This is because it is asking for the Lowest common ancestor, not the smallest. It is going by height/level."
                    },
                    {
                        "username": "upup1904",
                        "content": "I guess `[2,5,6]` is ambiguous.  In that case it means 5 is right child of 2 and 6 is right child of 5.  I guess?"
                    },
                    {
                        "username": "hayduke415",
                        "content": "I have the same question! wouldn\\'t the lowestcommon ancestor of 8-9 be 6?"
                    },
                    {
                        "username": "elsayedzahran789",
                        "content": "BST Problems are the best"
                    },
                    {
                        "username": "srapol",
                        "content": "nah man"
                    }
                ]
            },
            {
                "id": 1737022,
                "content": [
                    {
                        "username": "Jayusc",
                        "content": "so this is lowest common ancestor, not smallest common ancestor. I am an idiot"
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "what a bad wording for the title!"
                    },
                    {
                        "username": "rayrogar",
                        "content": "why,why,why mr Anderson, Why the tricky title"
                    },
                    {
                        "username": "rahulnegi2021",
                        "content": "us."
                    },
                    {
                        "username": "mpostrel",
                        "content": "omg thanks for clarifying. me too :( "
                    },
                    {
                        "username": "Cyril-0110",
                        "content": "You\\'re not alone :)"
                    },
                    {
                        "username": "tunsmm0",
                        "content": "I was confused about these situation too. They mean not value of node, but place of node in the tree. So in case where p = 7 and q = 9, the lowest will 8, not 6"
                    },
                    {
                        "username": "IvanStebletsov",
                        "content": "Refreshing my knowledge about key traits of binary search tree very helped me find simple solution for this problem. I\\'d recommend you start from it.\\n\\nBST has following traits:\\n1) Both root\\'s subtrees also are binary (it is not important for solution, but just FYI);\\n2) All **LEFT** child nodes of **LEFT** subtree have values **less or equal** the value of the current node.\\n2) All **RIGHT** child nodes of **RIGHT** subtree have values **greater** the value of the current node.\\n\\nKeeping in mind these traits we can start traverse tree in depth (DFS).\\n\\nMain idea: \\n- If **current node value > p.value and q.value**, hence according to trait **\\u21162** above, it\\'s useless search common node for **p** and **q** in the **right** subtree -> continue traverse next node in **left** subtree.\\n- If **current node value < p.value and q.value**, hence according to trait **\\u21163** above, it\\'s useless search common node for **p** and **q** in the **left** subtree  -> continue traverse next node in **right** subtree\\n- If according to statements above it\\'s useless search common node in both **left** and **right** subtree, it means that you are in a right place, you have found Lowest Common Ancestor.\\n\\nUsing this idea you can solve problem both iteratively and recursively.\\n\\nIf I\\'m not mistaken time complexity will be O(logN), because every time we chose only one subtree, therefore reduce count of traversable nodes twice. Memory complexity O(1).\\n\\nHope it will be helpful."
                    },
                    {
                        "username": "vskamade206",
                        "content": "Nice One brother\\n"
                    },
                    {
                        "username": "advanced-bencoding",
                        "content": "Remember that lowestCommonAncestor is in terms of depth level and not common node value based!"
                    },
                    {
                        "username": "veekshithcb",
                        "content": "thanks I was scratching head without understanding question completely "
                    },
                    {
                        "username": "noseonarug17",
                        "content": "For anyone who got confused and frustrated because output was inexplicably `undefined` - despite the way it displays the output, it wants you to return the node itself, not the value. This was true for Javascript, anyway."
                    },
                    {
                        "username": "Spacetoaster",
                        "content": "wow, this was frustrating, thanks"
                    },
                    {
                        "username": "yfang82",
                        "content": "Hint: search for the first value that is between p and q. That will be your lowest common ancestor"
                    },
                    {
                        "username": "Noob_SWEbot",
                        "content": "This is a great hint! Should be the default hint in the problem description. "
                    },
                    {
                        "username": "rstone13",
                        "content": "That\\'s absolutely brilliant! Here I was trying to figure out how to track if p and q have been found and if the current node is a parent of both p and q and all that."
                    },
                    {
                        "username": "misters",
                        "content": "        if(root.val > p.val && root.val > q.val) return lowestCommonAncestor(root.left, p, q);\\n        else if(root.val < p.val && root.val < q.val) return lowestCommonAncestor(root.right, p, q);\\n        else return root;"
                    },
                    {
                        "username": "olejiksa",
                        "content": "[@Khushi_Mattu](/Khushi_Mattu) you can use iterative approach for this problem. Iterative search in BST runs faster"
                    },
                    {
                        "username": "khushimattu",
                        "content": "can anyone tell a better solution then this? I did with the same logic but mine only beats 13% which means it can be optimised."
                    },
                    {
                        "username": "AMATEURTOSS",
                        "content": "genius"
                    },
                    {
                        "username": "vimlife",
                        "content": "Please no answers in the discussion section. See rules"
                    },
                    {
                        "username": "onomojo",
                        "content": "I stupidly overlooked the BST part and started trying to solve it as a generic tree. Obviously that way over-complicates it. "
                    },
                    {
                        "username": "ayukumi",
                        "content": " same code will work fine for both BST as well as BT "
                    },
                    {
                        "username": "g4b0r",
                        "content": "Is there a way I can extend this question so it supports swift? Or is that something the original author has to do?"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Nothing is stopping you from translating the answer into other languages. In fact that is a great way to internalize the material."
                    },
                    {
                        "username": "cjsy",
                        "content": "if the input is: \\n[2, 5, 6]\\n5\\n6\\n\\nwhy the results is 6? Why not 2?"
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "this is not a bst bro\\n"
                    },
                    {
                        "username": "AsumalSingh",
                        "content": "because node can be a descendant of itself"
                    },
                    {
                        "username": "Sidchou",
                        "content": "[@yestrup](/yestrup) but the question doesnt mention anything about valid binary tree"
                    },
                    {
                        "username": "Sidchou",
                        "content": "yeah i got same question, why is [5,3,6,2,4,null,null,1], 6,1 expecting 5, not 2"
                    },
                    {
                        "username": "yestrup",
                        "content": "[2, 5, 6] is not a valid binary tree"
                    },
                    {
                        "username": "anujp99",
                        "content": "[@hayduke415](/hayduke415) This is because it is asking for the Lowest common ancestor, not the smallest. It is going by height/level."
                    },
                    {
                        "username": "upup1904",
                        "content": "I guess `[2,5,6]` is ambiguous.  In that case it means 5 is right child of 2 and 6 is right child of 5.  I guess?"
                    },
                    {
                        "username": "hayduke415",
                        "content": "I have the same question! wouldn\\'t the lowestcommon ancestor of 8-9 be 6?"
                    },
                    {
                        "username": "elsayedzahran789",
                        "content": "BST Problems are the best"
                    },
                    {
                        "username": "srapol",
                        "content": "nah man"
                    }
                ]
            },
            {
                "id": 1567231,
                "content": [
                    {
                        "username": "Jayusc",
                        "content": "so this is lowest common ancestor, not smallest common ancestor. I am an idiot"
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "what a bad wording for the title!"
                    },
                    {
                        "username": "rayrogar",
                        "content": "why,why,why mr Anderson, Why the tricky title"
                    },
                    {
                        "username": "rahulnegi2021",
                        "content": "us."
                    },
                    {
                        "username": "mpostrel",
                        "content": "omg thanks for clarifying. me too :( "
                    },
                    {
                        "username": "Cyril-0110",
                        "content": "You\\'re not alone :)"
                    },
                    {
                        "username": "tunsmm0",
                        "content": "I was confused about these situation too. They mean not value of node, but place of node in the tree. So in case where p = 7 and q = 9, the lowest will 8, not 6"
                    },
                    {
                        "username": "IvanStebletsov",
                        "content": "Refreshing my knowledge about key traits of binary search tree very helped me find simple solution for this problem. I\\'d recommend you start from it.\\n\\nBST has following traits:\\n1) Both root\\'s subtrees also are binary (it is not important for solution, but just FYI);\\n2) All **LEFT** child nodes of **LEFT** subtree have values **less or equal** the value of the current node.\\n2) All **RIGHT** child nodes of **RIGHT** subtree have values **greater** the value of the current node.\\n\\nKeeping in mind these traits we can start traverse tree in depth (DFS).\\n\\nMain idea: \\n- If **current node value > p.value and q.value**, hence according to trait **\\u21162** above, it\\'s useless search common node for **p** and **q** in the **right** subtree -> continue traverse next node in **left** subtree.\\n- If **current node value < p.value and q.value**, hence according to trait **\\u21163** above, it\\'s useless search common node for **p** and **q** in the **left** subtree  -> continue traverse next node in **right** subtree\\n- If according to statements above it\\'s useless search common node in both **left** and **right** subtree, it means that you are in a right place, you have found Lowest Common Ancestor.\\n\\nUsing this idea you can solve problem both iteratively and recursively.\\n\\nIf I\\'m not mistaken time complexity will be O(logN), because every time we chose only one subtree, therefore reduce count of traversable nodes twice. Memory complexity O(1).\\n\\nHope it will be helpful."
                    },
                    {
                        "username": "vskamade206",
                        "content": "Nice One brother\\n"
                    },
                    {
                        "username": "advanced-bencoding",
                        "content": "Remember that lowestCommonAncestor is in terms of depth level and not common node value based!"
                    },
                    {
                        "username": "veekshithcb",
                        "content": "thanks I was scratching head without understanding question completely "
                    },
                    {
                        "username": "noseonarug17",
                        "content": "For anyone who got confused and frustrated because output was inexplicably `undefined` - despite the way it displays the output, it wants you to return the node itself, not the value. This was true for Javascript, anyway."
                    },
                    {
                        "username": "Spacetoaster",
                        "content": "wow, this was frustrating, thanks"
                    },
                    {
                        "username": "yfang82",
                        "content": "Hint: search for the first value that is between p and q. That will be your lowest common ancestor"
                    },
                    {
                        "username": "Noob_SWEbot",
                        "content": "This is a great hint! Should be the default hint in the problem description. "
                    },
                    {
                        "username": "rstone13",
                        "content": "That\\'s absolutely brilliant! Here I was trying to figure out how to track if p and q have been found and if the current node is a parent of both p and q and all that."
                    },
                    {
                        "username": "misters",
                        "content": "        if(root.val > p.val && root.val > q.val) return lowestCommonAncestor(root.left, p, q);\\n        else if(root.val < p.val && root.val < q.val) return lowestCommonAncestor(root.right, p, q);\\n        else return root;"
                    },
                    {
                        "username": "olejiksa",
                        "content": "[@Khushi_Mattu](/Khushi_Mattu) you can use iterative approach for this problem. Iterative search in BST runs faster"
                    },
                    {
                        "username": "khushimattu",
                        "content": "can anyone tell a better solution then this? I did with the same logic but mine only beats 13% which means it can be optimised."
                    },
                    {
                        "username": "AMATEURTOSS",
                        "content": "genius"
                    },
                    {
                        "username": "vimlife",
                        "content": "Please no answers in the discussion section. See rules"
                    },
                    {
                        "username": "onomojo",
                        "content": "I stupidly overlooked the BST part and started trying to solve it as a generic tree. Obviously that way over-complicates it. "
                    },
                    {
                        "username": "ayukumi",
                        "content": " same code will work fine for both BST as well as BT "
                    },
                    {
                        "username": "g4b0r",
                        "content": "Is there a way I can extend this question so it supports swift? Or is that something the original author has to do?"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Nothing is stopping you from translating the answer into other languages. In fact that is a great way to internalize the material."
                    },
                    {
                        "username": "cjsy",
                        "content": "if the input is: \\n[2, 5, 6]\\n5\\n6\\n\\nwhy the results is 6? Why not 2?"
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "this is not a bst bro\\n"
                    },
                    {
                        "username": "AsumalSingh",
                        "content": "because node can be a descendant of itself"
                    },
                    {
                        "username": "Sidchou",
                        "content": "[@yestrup](/yestrup) but the question doesnt mention anything about valid binary tree"
                    },
                    {
                        "username": "Sidchou",
                        "content": "yeah i got same question, why is [5,3,6,2,4,null,null,1], 6,1 expecting 5, not 2"
                    },
                    {
                        "username": "yestrup",
                        "content": "[2, 5, 6] is not a valid binary tree"
                    },
                    {
                        "username": "anujp99",
                        "content": "[@hayduke415](/hayduke415) This is because it is asking for the Lowest common ancestor, not the smallest. It is going by height/level."
                    },
                    {
                        "username": "upup1904",
                        "content": "I guess `[2,5,6]` is ambiguous.  In that case it means 5 is right child of 2 and 6 is right child of 5.  I guess?"
                    },
                    {
                        "username": "hayduke415",
                        "content": "I have the same question! wouldn\\'t the lowestcommon ancestor of 8-9 be 6?"
                    },
                    {
                        "username": "elsayedzahran789",
                        "content": "BST Problems are the best"
                    },
                    {
                        "username": "srapol",
                        "content": "nah man"
                    }
                ]
            },
            {
                "id": 1572114,
                "content": [
                    {
                        "username": "Jayusc",
                        "content": "so this is lowest common ancestor, not smallest common ancestor. I am an idiot"
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "what a bad wording for the title!"
                    },
                    {
                        "username": "rayrogar",
                        "content": "why,why,why mr Anderson, Why the tricky title"
                    },
                    {
                        "username": "rahulnegi2021",
                        "content": "us."
                    },
                    {
                        "username": "mpostrel",
                        "content": "omg thanks for clarifying. me too :( "
                    },
                    {
                        "username": "Cyril-0110",
                        "content": "You\\'re not alone :)"
                    },
                    {
                        "username": "tunsmm0",
                        "content": "I was confused about these situation too. They mean not value of node, but place of node in the tree. So in case where p = 7 and q = 9, the lowest will 8, not 6"
                    },
                    {
                        "username": "IvanStebletsov",
                        "content": "Refreshing my knowledge about key traits of binary search tree very helped me find simple solution for this problem. I\\'d recommend you start from it.\\n\\nBST has following traits:\\n1) Both root\\'s subtrees also are binary (it is not important for solution, but just FYI);\\n2) All **LEFT** child nodes of **LEFT** subtree have values **less or equal** the value of the current node.\\n2) All **RIGHT** child nodes of **RIGHT** subtree have values **greater** the value of the current node.\\n\\nKeeping in mind these traits we can start traverse tree in depth (DFS).\\n\\nMain idea: \\n- If **current node value > p.value and q.value**, hence according to trait **\\u21162** above, it\\'s useless search common node for **p** and **q** in the **right** subtree -> continue traverse next node in **left** subtree.\\n- If **current node value < p.value and q.value**, hence according to trait **\\u21163** above, it\\'s useless search common node for **p** and **q** in the **left** subtree  -> continue traverse next node in **right** subtree\\n- If according to statements above it\\'s useless search common node in both **left** and **right** subtree, it means that you are in a right place, you have found Lowest Common Ancestor.\\n\\nUsing this idea you can solve problem both iteratively and recursively.\\n\\nIf I\\'m not mistaken time complexity will be O(logN), because every time we chose only one subtree, therefore reduce count of traversable nodes twice. Memory complexity O(1).\\n\\nHope it will be helpful."
                    },
                    {
                        "username": "vskamade206",
                        "content": "Nice One brother\\n"
                    },
                    {
                        "username": "advanced-bencoding",
                        "content": "Remember that lowestCommonAncestor is in terms of depth level and not common node value based!"
                    },
                    {
                        "username": "veekshithcb",
                        "content": "thanks I was scratching head without understanding question completely "
                    },
                    {
                        "username": "noseonarug17",
                        "content": "For anyone who got confused and frustrated because output was inexplicably `undefined` - despite the way it displays the output, it wants you to return the node itself, not the value. This was true for Javascript, anyway."
                    },
                    {
                        "username": "Spacetoaster",
                        "content": "wow, this was frustrating, thanks"
                    },
                    {
                        "username": "yfang82",
                        "content": "Hint: search for the first value that is between p and q. That will be your lowest common ancestor"
                    },
                    {
                        "username": "Noob_SWEbot",
                        "content": "This is a great hint! Should be the default hint in the problem description. "
                    },
                    {
                        "username": "rstone13",
                        "content": "That\\'s absolutely brilliant! Here I was trying to figure out how to track if p and q have been found and if the current node is a parent of both p and q and all that."
                    },
                    {
                        "username": "misters",
                        "content": "        if(root.val > p.val && root.val > q.val) return lowestCommonAncestor(root.left, p, q);\\n        else if(root.val < p.val && root.val < q.val) return lowestCommonAncestor(root.right, p, q);\\n        else return root;"
                    },
                    {
                        "username": "olejiksa",
                        "content": "[@Khushi_Mattu](/Khushi_Mattu) you can use iterative approach for this problem. Iterative search in BST runs faster"
                    },
                    {
                        "username": "khushimattu",
                        "content": "can anyone tell a better solution then this? I did with the same logic but mine only beats 13% which means it can be optimised."
                    },
                    {
                        "username": "AMATEURTOSS",
                        "content": "genius"
                    },
                    {
                        "username": "vimlife",
                        "content": "Please no answers in the discussion section. See rules"
                    },
                    {
                        "username": "onomojo",
                        "content": "I stupidly overlooked the BST part and started trying to solve it as a generic tree. Obviously that way over-complicates it. "
                    },
                    {
                        "username": "ayukumi",
                        "content": " same code will work fine for both BST as well as BT "
                    },
                    {
                        "username": "g4b0r",
                        "content": "Is there a way I can extend this question so it supports swift? Or is that something the original author has to do?"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Nothing is stopping you from translating the answer into other languages. In fact that is a great way to internalize the material."
                    },
                    {
                        "username": "cjsy",
                        "content": "if the input is: \\n[2, 5, 6]\\n5\\n6\\n\\nwhy the results is 6? Why not 2?"
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "this is not a bst bro\\n"
                    },
                    {
                        "username": "AsumalSingh",
                        "content": "because node can be a descendant of itself"
                    },
                    {
                        "username": "Sidchou",
                        "content": "[@yestrup](/yestrup) but the question doesnt mention anything about valid binary tree"
                    },
                    {
                        "username": "Sidchou",
                        "content": "yeah i got same question, why is [5,3,6,2,4,null,null,1], 6,1 expecting 5, not 2"
                    },
                    {
                        "username": "yestrup",
                        "content": "[2, 5, 6] is not a valid binary tree"
                    },
                    {
                        "username": "anujp99",
                        "content": "[@hayduke415](/hayduke415) This is because it is asking for the Lowest common ancestor, not the smallest. It is going by height/level."
                    },
                    {
                        "username": "upup1904",
                        "content": "I guess `[2,5,6]` is ambiguous.  In that case it means 5 is right child of 2 and 6 is right child of 5.  I guess?"
                    },
                    {
                        "username": "hayduke415",
                        "content": "I have the same question! wouldn\\'t the lowestcommon ancestor of 8-9 be 6?"
                    },
                    {
                        "username": "elsayedzahran789",
                        "content": "BST Problems are the best"
                    },
                    {
                        "username": "srapol",
                        "content": "nah man"
                    }
                ]
            },
            {
                "id": 1780013,
                "content": [
                    {
                        "username": "Jayusc",
                        "content": "so this is lowest common ancestor, not smallest common ancestor. I am an idiot"
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "what a bad wording for the title!"
                    },
                    {
                        "username": "rayrogar",
                        "content": "why,why,why mr Anderson, Why the tricky title"
                    },
                    {
                        "username": "rahulnegi2021",
                        "content": "us."
                    },
                    {
                        "username": "mpostrel",
                        "content": "omg thanks for clarifying. me too :( "
                    },
                    {
                        "username": "Cyril-0110",
                        "content": "You\\'re not alone :)"
                    },
                    {
                        "username": "tunsmm0",
                        "content": "I was confused about these situation too. They mean not value of node, but place of node in the tree. So in case where p = 7 and q = 9, the lowest will 8, not 6"
                    },
                    {
                        "username": "IvanStebletsov",
                        "content": "Refreshing my knowledge about key traits of binary search tree very helped me find simple solution for this problem. I\\'d recommend you start from it.\\n\\nBST has following traits:\\n1) Both root\\'s subtrees also are binary (it is not important for solution, but just FYI);\\n2) All **LEFT** child nodes of **LEFT** subtree have values **less or equal** the value of the current node.\\n2) All **RIGHT** child nodes of **RIGHT** subtree have values **greater** the value of the current node.\\n\\nKeeping in mind these traits we can start traverse tree in depth (DFS).\\n\\nMain idea: \\n- If **current node value > p.value and q.value**, hence according to trait **\\u21162** above, it\\'s useless search common node for **p** and **q** in the **right** subtree -> continue traverse next node in **left** subtree.\\n- If **current node value < p.value and q.value**, hence according to trait **\\u21163** above, it\\'s useless search common node for **p** and **q** in the **left** subtree  -> continue traverse next node in **right** subtree\\n- If according to statements above it\\'s useless search common node in both **left** and **right** subtree, it means that you are in a right place, you have found Lowest Common Ancestor.\\n\\nUsing this idea you can solve problem both iteratively and recursively.\\n\\nIf I\\'m not mistaken time complexity will be O(logN), because every time we chose only one subtree, therefore reduce count of traversable nodes twice. Memory complexity O(1).\\n\\nHope it will be helpful."
                    },
                    {
                        "username": "vskamade206",
                        "content": "Nice One brother\\n"
                    },
                    {
                        "username": "advanced-bencoding",
                        "content": "Remember that lowestCommonAncestor is in terms of depth level and not common node value based!"
                    },
                    {
                        "username": "veekshithcb",
                        "content": "thanks I was scratching head without understanding question completely "
                    },
                    {
                        "username": "noseonarug17",
                        "content": "For anyone who got confused and frustrated because output was inexplicably `undefined` - despite the way it displays the output, it wants you to return the node itself, not the value. This was true for Javascript, anyway."
                    },
                    {
                        "username": "Spacetoaster",
                        "content": "wow, this was frustrating, thanks"
                    },
                    {
                        "username": "yfang82",
                        "content": "Hint: search for the first value that is between p and q. That will be your lowest common ancestor"
                    },
                    {
                        "username": "Noob_SWEbot",
                        "content": "This is a great hint! Should be the default hint in the problem description. "
                    },
                    {
                        "username": "rstone13",
                        "content": "That\\'s absolutely brilliant! Here I was trying to figure out how to track if p and q have been found and if the current node is a parent of both p and q and all that."
                    },
                    {
                        "username": "misters",
                        "content": "        if(root.val > p.val && root.val > q.val) return lowestCommonAncestor(root.left, p, q);\\n        else if(root.val < p.val && root.val < q.val) return lowestCommonAncestor(root.right, p, q);\\n        else return root;"
                    },
                    {
                        "username": "olejiksa",
                        "content": "[@Khushi_Mattu](/Khushi_Mattu) you can use iterative approach for this problem. Iterative search in BST runs faster"
                    },
                    {
                        "username": "khushimattu",
                        "content": "can anyone tell a better solution then this? I did with the same logic but mine only beats 13% which means it can be optimised."
                    },
                    {
                        "username": "AMATEURTOSS",
                        "content": "genius"
                    },
                    {
                        "username": "vimlife",
                        "content": "Please no answers in the discussion section. See rules"
                    },
                    {
                        "username": "onomojo",
                        "content": "I stupidly overlooked the BST part and started trying to solve it as a generic tree. Obviously that way over-complicates it. "
                    },
                    {
                        "username": "ayukumi",
                        "content": " same code will work fine for both BST as well as BT "
                    },
                    {
                        "username": "g4b0r",
                        "content": "Is there a way I can extend this question so it supports swift? Or is that something the original author has to do?"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Nothing is stopping you from translating the answer into other languages. In fact that is a great way to internalize the material."
                    },
                    {
                        "username": "cjsy",
                        "content": "if the input is: \\n[2, 5, 6]\\n5\\n6\\n\\nwhy the results is 6? Why not 2?"
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "this is not a bst bro\\n"
                    },
                    {
                        "username": "AsumalSingh",
                        "content": "because node can be a descendant of itself"
                    },
                    {
                        "username": "Sidchou",
                        "content": "[@yestrup](/yestrup) but the question doesnt mention anything about valid binary tree"
                    },
                    {
                        "username": "Sidchou",
                        "content": "yeah i got same question, why is [5,3,6,2,4,null,null,1], 6,1 expecting 5, not 2"
                    },
                    {
                        "username": "yestrup",
                        "content": "[2, 5, 6] is not a valid binary tree"
                    },
                    {
                        "username": "anujp99",
                        "content": "[@hayduke415](/hayduke415) This is because it is asking for the Lowest common ancestor, not the smallest. It is going by height/level."
                    },
                    {
                        "username": "upup1904",
                        "content": "I guess `[2,5,6]` is ambiguous.  In that case it means 5 is right child of 2 and 6 is right child of 5.  I guess?"
                    },
                    {
                        "username": "hayduke415",
                        "content": "I have the same question! wouldn\\'t the lowestcommon ancestor of 8-9 be 6?"
                    },
                    {
                        "username": "elsayedzahran789",
                        "content": "BST Problems are the best"
                    },
                    {
                        "username": "srapol",
                        "content": "nah man"
                    }
                ]
            },
            {
                "id": 1691189,
                "content": [
                    {
                        "username": "Jayusc",
                        "content": "so this is lowest common ancestor, not smallest common ancestor. I am an idiot"
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "what a bad wording for the title!"
                    },
                    {
                        "username": "rayrogar",
                        "content": "why,why,why mr Anderson, Why the tricky title"
                    },
                    {
                        "username": "rahulnegi2021",
                        "content": "us."
                    },
                    {
                        "username": "mpostrel",
                        "content": "omg thanks for clarifying. me too :( "
                    },
                    {
                        "username": "Cyril-0110",
                        "content": "You\\'re not alone :)"
                    },
                    {
                        "username": "tunsmm0",
                        "content": "I was confused about these situation too. They mean not value of node, but place of node in the tree. So in case where p = 7 and q = 9, the lowest will 8, not 6"
                    },
                    {
                        "username": "IvanStebletsov",
                        "content": "Refreshing my knowledge about key traits of binary search tree very helped me find simple solution for this problem. I\\'d recommend you start from it.\\n\\nBST has following traits:\\n1) Both root\\'s subtrees also are binary (it is not important for solution, but just FYI);\\n2) All **LEFT** child nodes of **LEFT** subtree have values **less or equal** the value of the current node.\\n2) All **RIGHT** child nodes of **RIGHT** subtree have values **greater** the value of the current node.\\n\\nKeeping in mind these traits we can start traverse tree in depth (DFS).\\n\\nMain idea: \\n- If **current node value > p.value and q.value**, hence according to trait **\\u21162** above, it\\'s useless search common node for **p** and **q** in the **right** subtree -> continue traverse next node in **left** subtree.\\n- If **current node value < p.value and q.value**, hence according to trait **\\u21163** above, it\\'s useless search common node for **p** and **q** in the **left** subtree  -> continue traverse next node in **right** subtree\\n- If according to statements above it\\'s useless search common node in both **left** and **right** subtree, it means that you are in a right place, you have found Lowest Common Ancestor.\\n\\nUsing this idea you can solve problem both iteratively and recursively.\\n\\nIf I\\'m not mistaken time complexity will be O(logN), because every time we chose only one subtree, therefore reduce count of traversable nodes twice. Memory complexity O(1).\\n\\nHope it will be helpful."
                    },
                    {
                        "username": "vskamade206",
                        "content": "Nice One brother\\n"
                    },
                    {
                        "username": "advanced-bencoding",
                        "content": "Remember that lowestCommonAncestor is in terms of depth level and not common node value based!"
                    },
                    {
                        "username": "veekshithcb",
                        "content": "thanks I was scratching head without understanding question completely "
                    },
                    {
                        "username": "noseonarug17",
                        "content": "For anyone who got confused and frustrated because output was inexplicably `undefined` - despite the way it displays the output, it wants you to return the node itself, not the value. This was true for Javascript, anyway."
                    },
                    {
                        "username": "Spacetoaster",
                        "content": "wow, this was frustrating, thanks"
                    },
                    {
                        "username": "yfang82",
                        "content": "Hint: search for the first value that is between p and q. That will be your lowest common ancestor"
                    },
                    {
                        "username": "Noob_SWEbot",
                        "content": "This is a great hint! Should be the default hint in the problem description. "
                    },
                    {
                        "username": "rstone13",
                        "content": "That\\'s absolutely brilliant! Here I was trying to figure out how to track if p and q have been found and if the current node is a parent of both p and q and all that."
                    },
                    {
                        "username": "misters",
                        "content": "        if(root.val > p.val && root.val > q.val) return lowestCommonAncestor(root.left, p, q);\\n        else if(root.val < p.val && root.val < q.val) return lowestCommonAncestor(root.right, p, q);\\n        else return root;"
                    },
                    {
                        "username": "olejiksa",
                        "content": "[@Khushi_Mattu](/Khushi_Mattu) you can use iterative approach for this problem. Iterative search in BST runs faster"
                    },
                    {
                        "username": "khushimattu",
                        "content": "can anyone tell a better solution then this? I did with the same logic but mine only beats 13% which means it can be optimised."
                    },
                    {
                        "username": "AMATEURTOSS",
                        "content": "genius"
                    },
                    {
                        "username": "vimlife",
                        "content": "Please no answers in the discussion section. See rules"
                    },
                    {
                        "username": "onomojo",
                        "content": "I stupidly overlooked the BST part and started trying to solve it as a generic tree. Obviously that way over-complicates it. "
                    },
                    {
                        "username": "ayukumi",
                        "content": " same code will work fine for both BST as well as BT "
                    },
                    {
                        "username": "g4b0r",
                        "content": "Is there a way I can extend this question so it supports swift? Or is that something the original author has to do?"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Nothing is stopping you from translating the answer into other languages. In fact that is a great way to internalize the material."
                    },
                    {
                        "username": "cjsy",
                        "content": "if the input is: \\n[2, 5, 6]\\n5\\n6\\n\\nwhy the results is 6? Why not 2?"
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "this is not a bst bro\\n"
                    },
                    {
                        "username": "AsumalSingh",
                        "content": "because node can be a descendant of itself"
                    },
                    {
                        "username": "Sidchou",
                        "content": "[@yestrup](/yestrup) but the question doesnt mention anything about valid binary tree"
                    },
                    {
                        "username": "Sidchou",
                        "content": "yeah i got same question, why is [5,3,6,2,4,null,null,1], 6,1 expecting 5, not 2"
                    },
                    {
                        "username": "yestrup",
                        "content": "[2, 5, 6] is not a valid binary tree"
                    },
                    {
                        "username": "anujp99",
                        "content": "[@hayduke415](/hayduke415) This is because it is asking for the Lowest common ancestor, not the smallest. It is going by height/level."
                    },
                    {
                        "username": "upup1904",
                        "content": "I guess `[2,5,6]` is ambiguous.  In that case it means 5 is right child of 2 and 6 is right child of 5.  I guess?"
                    },
                    {
                        "username": "hayduke415",
                        "content": "I have the same question! wouldn\\'t the lowestcommon ancestor of 8-9 be 6?"
                    },
                    {
                        "username": "elsayedzahran789",
                        "content": "BST Problems are the best"
                    },
                    {
                        "username": "srapol",
                        "content": "nah man"
                    }
                ]
            },
            {
                "id": 1798606,
                "content": [
                    {
                        "username": "Jayusc",
                        "content": "so this is lowest common ancestor, not smallest common ancestor. I am an idiot"
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "what a bad wording for the title!"
                    },
                    {
                        "username": "rayrogar",
                        "content": "why,why,why mr Anderson, Why the tricky title"
                    },
                    {
                        "username": "rahulnegi2021",
                        "content": "us."
                    },
                    {
                        "username": "mpostrel",
                        "content": "omg thanks for clarifying. me too :( "
                    },
                    {
                        "username": "Cyril-0110",
                        "content": "You\\'re not alone :)"
                    },
                    {
                        "username": "tunsmm0",
                        "content": "I was confused about these situation too. They mean not value of node, but place of node in the tree. So in case where p = 7 and q = 9, the lowest will 8, not 6"
                    },
                    {
                        "username": "IvanStebletsov",
                        "content": "Refreshing my knowledge about key traits of binary search tree very helped me find simple solution for this problem. I\\'d recommend you start from it.\\n\\nBST has following traits:\\n1) Both root\\'s subtrees also are binary (it is not important for solution, but just FYI);\\n2) All **LEFT** child nodes of **LEFT** subtree have values **less or equal** the value of the current node.\\n2) All **RIGHT** child nodes of **RIGHT** subtree have values **greater** the value of the current node.\\n\\nKeeping in mind these traits we can start traverse tree in depth (DFS).\\n\\nMain idea: \\n- If **current node value > p.value and q.value**, hence according to trait **\\u21162** above, it\\'s useless search common node for **p** and **q** in the **right** subtree -> continue traverse next node in **left** subtree.\\n- If **current node value < p.value and q.value**, hence according to trait **\\u21163** above, it\\'s useless search common node for **p** and **q** in the **left** subtree  -> continue traverse next node in **right** subtree\\n- If according to statements above it\\'s useless search common node in both **left** and **right** subtree, it means that you are in a right place, you have found Lowest Common Ancestor.\\n\\nUsing this idea you can solve problem both iteratively and recursively.\\n\\nIf I\\'m not mistaken time complexity will be O(logN), because every time we chose only one subtree, therefore reduce count of traversable nodes twice. Memory complexity O(1).\\n\\nHope it will be helpful."
                    },
                    {
                        "username": "vskamade206",
                        "content": "Nice One brother\\n"
                    },
                    {
                        "username": "advanced-bencoding",
                        "content": "Remember that lowestCommonAncestor is in terms of depth level and not common node value based!"
                    },
                    {
                        "username": "veekshithcb",
                        "content": "thanks I was scratching head without understanding question completely "
                    },
                    {
                        "username": "noseonarug17",
                        "content": "For anyone who got confused and frustrated because output was inexplicably `undefined` - despite the way it displays the output, it wants you to return the node itself, not the value. This was true for Javascript, anyway."
                    },
                    {
                        "username": "Spacetoaster",
                        "content": "wow, this was frustrating, thanks"
                    },
                    {
                        "username": "yfang82",
                        "content": "Hint: search for the first value that is between p and q. That will be your lowest common ancestor"
                    },
                    {
                        "username": "Noob_SWEbot",
                        "content": "This is a great hint! Should be the default hint in the problem description. "
                    },
                    {
                        "username": "rstone13",
                        "content": "That\\'s absolutely brilliant! Here I was trying to figure out how to track if p and q have been found and if the current node is a parent of both p and q and all that."
                    },
                    {
                        "username": "misters",
                        "content": "        if(root.val > p.val && root.val > q.val) return lowestCommonAncestor(root.left, p, q);\\n        else if(root.val < p.val && root.val < q.val) return lowestCommonAncestor(root.right, p, q);\\n        else return root;"
                    },
                    {
                        "username": "olejiksa",
                        "content": "[@Khushi_Mattu](/Khushi_Mattu) you can use iterative approach for this problem. Iterative search in BST runs faster"
                    },
                    {
                        "username": "khushimattu",
                        "content": "can anyone tell a better solution then this? I did with the same logic but mine only beats 13% which means it can be optimised."
                    },
                    {
                        "username": "AMATEURTOSS",
                        "content": "genius"
                    },
                    {
                        "username": "vimlife",
                        "content": "Please no answers in the discussion section. See rules"
                    },
                    {
                        "username": "onomojo",
                        "content": "I stupidly overlooked the BST part and started trying to solve it as a generic tree. Obviously that way over-complicates it. "
                    },
                    {
                        "username": "ayukumi",
                        "content": " same code will work fine for both BST as well as BT "
                    },
                    {
                        "username": "g4b0r",
                        "content": "Is there a way I can extend this question so it supports swift? Or is that something the original author has to do?"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Nothing is stopping you from translating the answer into other languages. In fact that is a great way to internalize the material."
                    },
                    {
                        "username": "cjsy",
                        "content": "if the input is: \\n[2, 5, 6]\\n5\\n6\\n\\nwhy the results is 6? Why not 2?"
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "this is not a bst bro\\n"
                    },
                    {
                        "username": "AsumalSingh",
                        "content": "because node can be a descendant of itself"
                    },
                    {
                        "username": "Sidchou",
                        "content": "[@yestrup](/yestrup) but the question doesnt mention anything about valid binary tree"
                    },
                    {
                        "username": "Sidchou",
                        "content": "yeah i got same question, why is [5,3,6,2,4,null,null,1], 6,1 expecting 5, not 2"
                    },
                    {
                        "username": "yestrup",
                        "content": "[2, 5, 6] is not a valid binary tree"
                    },
                    {
                        "username": "anujp99",
                        "content": "[@hayduke415](/hayduke415) This is because it is asking for the Lowest common ancestor, not the smallest. It is going by height/level."
                    },
                    {
                        "username": "upup1904",
                        "content": "I guess `[2,5,6]` is ambiguous.  In that case it means 5 is right child of 2 and 6 is right child of 5.  I guess?"
                    },
                    {
                        "username": "hayduke415",
                        "content": "I have the same question! wouldn\\'t the lowestcommon ancestor of 8-9 be 6?"
                    },
                    {
                        "username": "elsayedzahran789",
                        "content": "BST Problems are the best"
                    },
                    {
                        "username": "srapol",
                        "content": "nah man"
                    }
                ]
            },
            {
                "id": 1705055,
                "content": [
                    {
                        "username": "Jayusc",
                        "content": "so this is lowest common ancestor, not smallest common ancestor. I am an idiot"
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "what a bad wording for the title!"
                    },
                    {
                        "username": "rayrogar",
                        "content": "why,why,why mr Anderson, Why the tricky title"
                    },
                    {
                        "username": "rahulnegi2021",
                        "content": "us."
                    },
                    {
                        "username": "mpostrel",
                        "content": "omg thanks for clarifying. me too :( "
                    },
                    {
                        "username": "Cyril-0110",
                        "content": "You\\'re not alone :)"
                    },
                    {
                        "username": "tunsmm0",
                        "content": "I was confused about these situation too. They mean not value of node, but place of node in the tree. So in case where p = 7 and q = 9, the lowest will 8, not 6"
                    },
                    {
                        "username": "IvanStebletsov",
                        "content": "Refreshing my knowledge about key traits of binary search tree very helped me find simple solution for this problem. I\\'d recommend you start from it.\\n\\nBST has following traits:\\n1) Both root\\'s subtrees also are binary (it is not important for solution, but just FYI);\\n2) All **LEFT** child nodes of **LEFT** subtree have values **less or equal** the value of the current node.\\n2) All **RIGHT** child nodes of **RIGHT** subtree have values **greater** the value of the current node.\\n\\nKeeping in mind these traits we can start traverse tree in depth (DFS).\\n\\nMain idea: \\n- If **current node value > p.value and q.value**, hence according to trait **\\u21162** above, it\\'s useless search common node for **p** and **q** in the **right** subtree -> continue traverse next node in **left** subtree.\\n- If **current node value < p.value and q.value**, hence according to trait **\\u21163** above, it\\'s useless search common node for **p** and **q** in the **left** subtree  -> continue traverse next node in **right** subtree\\n- If according to statements above it\\'s useless search common node in both **left** and **right** subtree, it means that you are in a right place, you have found Lowest Common Ancestor.\\n\\nUsing this idea you can solve problem both iteratively and recursively.\\n\\nIf I\\'m not mistaken time complexity will be O(logN), because every time we chose only one subtree, therefore reduce count of traversable nodes twice. Memory complexity O(1).\\n\\nHope it will be helpful."
                    },
                    {
                        "username": "vskamade206",
                        "content": "Nice One brother\\n"
                    },
                    {
                        "username": "advanced-bencoding",
                        "content": "Remember that lowestCommonAncestor is in terms of depth level and not common node value based!"
                    },
                    {
                        "username": "veekshithcb",
                        "content": "thanks I was scratching head without understanding question completely "
                    },
                    {
                        "username": "noseonarug17",
                        "content": "For anyone who got confused and frustrated because output was inexplicably `undefined` - despite the way it displays the output, it wants you to return the node itself, not the value. This was true for Javascript, anyway."
                    },
                    {
                        "username": "Spacetoaster",
                        "content": "wow, this was frustrating, thanks"
                    },
                    {
                        "username": "yfang82",
                        "content": "Hint: search for the first value that is between p and q. That will be your lowest common ancestor"
                    },
                    {
                        "username": "Noob_SWEbot",
                        "content": "This is a great hint! Should be the default hint in the problem description. "
                    },
                    {
                        "username": "rstone13",
                        "content": "That\\'s absolutely brilliant! Here I was trying to figure out how to track if p and q have been found and if the current node is a parent of both p and q and all that."
                    },
                    {
                        "username": "misters",
                        "content": "        if(root.val > p.val && root.val > q.val) return lowestCommonAncestor(root.left, p, q);\\n        else if(root.val < p.val && root.val < q.val) return lowestCommonAncestor(root.right, p, q);\\n        else return root;"
                    },
                    {
                        "username": "olejiksa",
                        "content": "[@Khushi_Mattu](/Khushi_Mattu) you can use iterative approach for this problem. Iterative search in BST runs faster"
                    },
                    {
                        "username": "khushimattu",
                        "content": "can anyone tell a better solution then this? I did with the same logic but mine only beats 13% which means it can be optimised."
                    },
                    {
                        "username": "AMATEURTOSS",
                        "content": "genius"
                    },
                    {
                        "username": "vimlife",
                        "content": "Please no answers in the discussion section. See rules"
                    },
                    {
                        "username": "onomojo",
                        "content": "I stupidly overlooked the BST part and started trying to solve it as a generic tree. Obviously that way over-complicates it. "
                    },
                    {
                        "username": "ayukumi",
                        "content": " same code will work fine for both BST as well as BT "
                    },
                    {
                        "username": "g4b0r",
                        "content": "Is there a way I can extend this question so it supports swift? Or is that something the original author has to do?"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Nothing is stopping you from translating the answer into other languages. In fact that is a great way to internalize the material."
                    },
                    {
                        "username": "cjsy",
                        "content": "if the input is: \\n[2, 5, 6]\\n5\\n6\\n\\nwhy the results is 6? Why not 2?"
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "this is not a bst bro\\n"
                    },
                    {
                        "username": "AsumalSingh",
                        "content": "because node can be a descendant of itself"
                    },
                    {
                        "username": "Sidchou",
                        "content": "[@yestrup](/yestrup) but the question doesnt mention anything about valid binary tree"
                    },
                    {
                        "username": "Sidchou",
                        "content": "yeah i got same question, why is [5,3,6,2,4,null,null,1], 6,1 expecting 5, not 2"
                    },
                    {
                        "username": "yestrup",
                        "content": "[2, 5, 6] is not a valid binary tree"
                    },
                    {
                        "username": "anujp99",
                        "content": "[@hayduke415](/hayduke415) This is because it is asking for the Lowest common ancestor, not the smallest. It is going by height/level."
                    },
                    {
                        "username": "upup1904",
                        "content": "I guess `[2,5,6]` is ambiguous.  In that case it means 5 is right child of 2 and 6 is right child of 5.  I guess?"
                    },
                    {
                        "username": "hayduke415",
                        "content": "I have the same question! wouldn\\'t the lowestcommon ancestor of 8-9 be 6?"
                    },
                    {
                        "username": "elsayedzahran789",
                        "content": "BST Problems are the best"
                    },
                    {
                        "username": "srapol",
                        "content": "nah man"
                    }
                ]
            },
            {
                "id": 1786219,
                "content": [
                    {
                        "username": "Jayusc",
                        "content": "so this is lowest common ancestor, not smallest common ancestor. I am an idiot"
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "what a bad wording for the title!"
                    },
                    {
                        "username": "rayrogar",
                        "content": "why,why,why mr Anderson, Why the tricky title"
                    },
                    {
                        "username": "rahulnegi2021",
                        "content": "us."
                    },
                    {
                        "username": "mpostrel",
                        "content": "omg thanks for clarifying. me too :( "
                    },
                    {
                        "username": "Cyril-0110",
                        "content": "You\\'re not alone :)"
                    },
                    {
                        "username": "tunsmm0",
                        "content": "I was confused about these situation too. They mean not value of node, but place of node in the tree. So in case where p = 7 and q = 9, the lowest will 8, not 6"
                    },
                    {
                        "username": "IvanStebletsov",
                        "content": "Refreshing my knowledge about key traits of binary search tree very helped me find simple solution for this problem. I\\'d recommend you start from it.\\n\\nBST has following traits:\\n1) Both root\\'s subtrees also are binary (it is not important for solution, but just FYI);\\n2) All **LEFT** child nodes of **LEFT** subtree have values **less or equal** the value of the current node.\\n2) All **RIGHT** child nodes of **RIGHT** subtree have values **greater** the value of the current node.\\n\\nKeeping in mind these traits we can start traverse tree in depth (DFS).\\n\\nMain idea: \\n- If **current node value > p.value and q.value**, hence according to trait **\\u21162** above, it\\'s useless search common node for **p** and **q** in the **right** subtree -> continue traverse next node in **left** subtree.\\n- If **current node value < p.value and q.value**, hence according to trait **\\u21163** above, it\\'s useless search common node for **p** and **q** in the **left** subtree  -> continue traverse next node in **right** subtree\\n- If according to statements above it\\'s useless search common node in both **left** and **right** subtree, it means that you are in a right place, you have found Lowest Common Ancestor.\\n\\nUsing this idea you can solve problem both iteratively and recursively.\\n\\nIf I\\'m not mistaken time complexity will be O(logN), because every time we chose only one subtree, therefore reduce count of traversable nodes twice. Memory complexity O(1).\\n\\nHope it will be helpful."
                    },
                    {
                        "username": "vskamade206",
                        "content": "Nice One brother\\n"
                    },
                    {
                        "username": "advanced-bencoding",
                        "content": "Remember that lowestCommonAncestor is in terms of depth level and not common node value based!"
                    },
                    {
                        "username": "veekshithcb",
                        "content": "thanks I was scratching head without understanding question completely "
                    },
                    {
                        "username": "noseonarug17",
                        "content": "For anyone who got confused and frustrated because output was inexplicably `undefined` - despite the way it displays the output, it wants you to return the node itself, not the value. This was true for Javascript, anyway."
                    },
                    {
                        "username": "Spacetoaster",
                        "content": "wow, this was frustrating, thanks"
                    },
                    {
                        "username": "yfang82",
                        "content": "Hint: search for the first value that is between p and q. That will be your lowest common ancestor"
                    },
                    {
                        "username": "Noob_SWEbot",
                        "content": "This is a great hint! Should be the default hint in the problem description. "
                    },
                    {
                        "username": "rstone13",
                        "content": "That\\'s absolutely brilliant! Here I was trying to figure out how to track if p and q have been found and if the current node is a parent of both p and q and all that."
                    },
                    {
                        "username": "misters",
                        "content": "        if(root.val > p.val && root.val > q.val) return lowestCommonAncestor(root.left, p, q);\\n        else if(root.val < p.val && root.val < q.val) return lowestCommonAncestor(root.right, p, q);\\n        else return root;"
                    },
                    {
                        "username": "olejiksa",
                        "content": "[@Khushi_Mattu](/Khushi_Mattu) you can use iterative approach for this problem. Iterative search in BST runs faster"
                    },
                    {
                        "username": "khushimattu",
                        "content": "can anyone tell a better solution then this? I did with the same logic but mine only beats 13% which means it can be optimised."
                    },
                    {
                        "username": "AMATEURTOSS",
                        "content": "genius"
                    },
                    {
                        "username": "vimlife",
                        "content": "Please no answers in the discussion section. See rules"
                    },
                    {
                        "username": "onomojo",
                        "content": "I stupidly overlooked the BST part and started trying to solve it as a generic tree. Obviously that way over-complicates it. "
                    },
                    {
                        "username": "ayukumi",
                        "content": " same code will work fine for both BST as well as BT "
                    },
                    {
                        "username": "g4b0r",
                        "content": "Is there a way I can extend this question so it supports swift? Or is that something the original author has to do?"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Nothing is stopping you from translating the answer into other languages. In fact that is a great way to internalize the material."
                    },
                    {
                        "username": "cjsy",
                        "content": "if the input is: \\n[2, 5, 6]\\n5\\n6\\n\\nwhy the results is 6? Why not 2?"
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "this is not a bst bro\\n"
                    },
                    {
                        "username": "AsumalSingh",
                        "content": "because node can be a descendant of itself"
                    },
                    {
                        "username": "Sidchou",
                        "content": "[@yestrup](/yestrup) but the question doesnt mention anything about valid binary tree"
                    },
                    {
                        "username": "Sidchou",
                        "content": "yeah i got same question, why is [5,3,6,2,4,null,null,1], 6,1 expecting 5, not 2"
                    },
                    {
                        "username": "yestrup",
                        "content": "[2, 5, 6] is not a valid binary tree"
                    },
                    {
                        "username": "anujp99",
                        "content": "[@hayduke415](/hayduke415) This is because it is asking for the Lowest common ancestor, not the smallest. It is going by height/level."
                    },
                    {
                        "username": "upup1904",
                        "content": "I guess `[2,5,6]` is ambiguous.  In that case it means 5 is right child of 2 and 6 is right child of 5.  I guess?"
                    },
                    {
                        "username": "hayduke415",
                        "content": "I have the same question! wouldn\\'t the lowestcommon ancestor of 8-9 be 6?"
                    },
                    {
                        "username": "elsayedzahran789",
                        "content": "BST Problems are the best"
                    },
                    {
                        "username": "srapol",
                        "content": "nah man"
                    }
                ]
            },
            {
                "id": 1731348,
                "content": [
                    {
                        "username": "Jayusc",
                        "content": "so this is lowest common ancestor, not smallest common ancestor. I am an idiot"
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "what a bad wording for the title!"
                    },
                    {
                        "username": "rayrogar",
                        "content": "why,why,why mr Anderson, Why the tricky title"
                    },
                    {
                        "username": "rahulnegi2021",
                        "content": "us."
                    },
                    {
                        "username": "mpostrel",
                        "content": "omg thanks for clarifying. me too :( "
                    },
                    {
                        "username": "Cyril-0110",
                        "content": "You\\'re not alone :)"
                    },
                    {
                        "username": "tunsmm0",
                        "content": "I was confused about these situation too. They mean not value of node, but place of node in the tree. So in case where p = 7 and q = 9, the lowest will 8, not 6"
                    },
                    {
                        "username": "IvanStebletsov",
                        "content": "Refreshing my knowledge about key traits of binary search tree very helped me find simple solution for this problem. I\\'d recommend you start from it.\\n\\nBST has following traits:\\n1) Both root\\'s subtrees also are binary (it is not important for solution, but just FYI);\\n2) All **LEFT** child nodes of **LEFT** subtree have values **less or equal** the value of the current node.\\n2) All **RIGHT** child nodes of **RIGHT** subtree have values **greater** the value of the current node.\\n\\nKeeping in mind these traits we can start traverse tree in depth (DFS).\\n\\nMain idea: \\n- If **current node value > p.value and q.value**, hence according to trait **\\u21162** above, it\\'s useless search common node for **p** and **q** in the **right** subtree -> continue traverse next node in **left** subtree.\\n- If **current node value < p.value and q.value**, hence according to trait **\\u21163** above, it\\'s useless search common node for **p** and **q** in the **left** subtree  -> continue traverse next node in **right** subtree\\n- If according to statements above it\\'s useless search common node in both **left** and **right** subtree, it means that you are in a right place, you have found Lowest Common Ancestor.\\n\\nUsing this idea you can solve problem both iteratively and recursively.\\n\\nIf I\\'m not mistaken time complexity will be O(logN), because every time we chose only one subtree, therefore reduce count of traversable nodes twice. Memory complexity O(1).\\n\\nHope it will be helpful."
                    },
                    {
                        "username": "vskamade206",
                        "content": "Nice One brother\\n"
                    },
                    {
                        "username": "advanced-bencoding",
                        "content": "Remember that lowestCommonAncestor is in terms of depth level and not common node value based!"
                    },
                    {
                        "username": "veekshithcb",
                        "content": "thanks I was scratching head without understanding question completely "
                    },
                    {
                        "username": "noseonarug17",
                        "content": "For anyone who got confused and frustrated because output was inexplicably `undefined` - despite the way it displays the output, it wants you to return the node itself, not the value. This was true for Javascript, anyway."
                    },
                    {
                        "username": "Spacetoaster",
                        "content": "wow, this was frustrating, thanks"
                    },
                    {
                        "username": "yfang82",
                        "content": "Hint: search for the first value that is between p and q. That will be your lowest common ancestor"
                    },
                    {
                        "username": "Noob_SWEbot",
                        "content": "This is a great hint! Should be the default hint in the problem description. "
                    },
                    {
                        "username": "rstone13",
                        "content": "That\\'s absolutely brilliant! Here I was trying to figure out how to track if p and q have been found and if the current node is a parent of both p and q and all that."
                    },
                    {
                        "username": "misters",
                        "content": "        if(root.val > p.val && root.val > q.val) return lowestCommonAncestor(root.left, p, q);\\n        else if(root.val < p.val && root.val < q.val) return lowestCommonAncestor(root.right, p, q);\\n        else return root;"
                    },
                    {
                        "username": "olejiksa",
                        "content": "[@Khushi_Mattu](/Khushi_Mattu) you can use iterative approach for this problem. Iterative search in BST runs faster"
                    },
                    {
                        "username": "khushimattu",
                        "content": "can anyone tell a better solution then this? I did with the same logic but mine only beats 13% which means it can be optimised."
                    },
                    {
                        "username": "AMATEURTOSS",
                        "content": "genius"
                    },
                    {
                        "username": "vimlife",
                        "content": "Please no answers in the discussion section. See rules"
                    },
                    {
                        "username": "onomojo",
                        "content": "I stupidly overlooked the BST part and started trying to solve it as a generic tree. Obviously that way over-complicates it. "
                    },
                    {
                        "username": "ayukumi",
                        "content": " same code will work fine for both BST as well as BT "
                    },
                    {
                        "username": "g4b0r",
                        "content": "Is there a way I can extend this question so it supports swift? Or is that something the original author has to do?"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Nothing is stopping you from translating the answer into other languages. In fact that is a great way to internalize the material."
                    },
                    {
                        "username": "cjsy",
                        "content": "if the input is: \\n[2, 5, 6]\\n5\\n6\\n\\nwhy the results is 6? Why not 2?"
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "this is not a bst bro\\n"
                    },
                    {
                        "username": "AsumalSingh",
                        "content": "because node can be a descendant of itself"
                    },
                    {
                        "username": "Sidchou",
                        "content": "[@yestrup](/yestrup) but the question doesnt mention anything about valid binary tree"
                    },
                    {
                        "username": "Sidchou",
                        "content": "yeah i got same question, why is [5,3,6,2,4,null,null,1], 6,1 expecting 5, not 2"
                    },
                    {
                        "username": "yestrup",
                        "content": "[2, 5, 6] is not a valid binary tree"
                    },
                    {
                        "username": "anujp99",
                        "content": "[@hayduke415](/hayduke415) This is because it is asking for the Lowest common ancestor, not the smallest. It is going by height/level."
                    },
                    {
                        "username": "upup1904",
                        "content": "I guess `[2,5,6]` is ambiguous.  In that case it means 5 is right child of 2 and 6 is right child of 5.  I guess?"
                    },
                    {
                        "username": "hayduke415",
                        "content": "I have the same question! wouldn\\'t the lowestcommon ancestor of 8-9 be 6?"
                    },
                    {
                        "username": "elsayedzahran789",
                        "content": "BST Problems are the best"
                    },
                    {
                        "username": "srapol",
                        "content": "nah man"
                    }
                ]
            },
            {
                "id": 1565278,
                "content": [
                    {
                        "username": "Jayusc",
                        "content": "so this is lowest common ancestor, not smallest common ancestor. I am an idiot"
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "what a bad wording for the title!"
                    },
                    {
                        "username": "rayrogar",
                        "content": "why,why,why mr Anderson, Why the tricky title"
                    },
                    {
                        "username": "rahulnegi2021",
                        "content": "us."
                    },
                    {
                        "username": "mpostrel",
                        "content": "omg thanks for clarifying. me too :( "
                    },
                    {
                        "username": "Cyril-0110",
                        "content": "You\\'re not alone :)"
                    },
                    {
                        "username": "tunsmm0",
                        "content": "I was confused about these situation too. They mean not value of node, but place of node in the tree. So in case where p = 7 and q = 9, the lowest will 8, not 6"
                    },
                    {
                        "username": "IvanStebletsov",
                        "content": "Refreshing my knowledge about key traits of binary search tree very helped me find simple solution for this problem. I\\'d recommend you start from it.\\n\\nBST has following traits:\\n1) Both root\\'s subtrees also are binary (it is not important for solution, but just FYI);\\n2) All **LEFT** child nodes of **LEFT** subtree have values **less or equal** the value of the current node.\\n2) All **RIGHT** child nodes of **RIGHT** subtree have values **greater** the value of the current node.\\n\\nKeeping in mind these traits we can start traverse tree in depth (DFS).\\n\\nMain idea: \\n- If **current node value > p.value and q.value**, hence according to trait **\\u21162** above, it\\'s useless search common node for **p** and **q** in the **right** subtree -> continue traverse next node in **left** subtree.\\n- If **current node value < p.value and q.value**, hence according to trait **\\u21163** above, it\\'s useless search common node for **p** and **q** in the **left** subtree  -> continue traverse next node in **right** subtree\\n- If according to statements above it\\'s useless search common node in both **left** and **right** subtree, it means that you are in a right place, you have found Lowest Common Ancestor.\\n\\nUsing this idea you can solve problem both iteratively and recursively.\\n\\nIf I\\'m not mistaken time complexity will be O(logN), because every time we chose only one subtree, therefore reduce count of traversable nodes twice. Memory complexity O(1).\\n\\nHope it will be helpful."
                    },
                    {
                        "username": "vskamade206",
                        "content": "Nice One brother\\n"
                    },
                    {
                        "username": "advanced-bencoding",
                        "content": "Remember that lowestCommonAncestor is in terms of depth level and not common node value based!"
                    },
                    {
                        "username": "veekshithcb",
                        "content": "thanks I was scratching head without understanding question completely "
                    },
                    {
                        "username": "noseonarug17",
                        "content": "For anyone who got confused and frustrated because output was inexplicably `undefined` - despite the way it displays the output, it wants you to return the node itself, not the value. This was true for Javascript, anyway."
                    },
                    {
                        "username": "Spacetoaster",
                        "content": "wow, this was frustrating, thanks"
                    },
                    {
                        "username": "yfang82",
                        "content": "Hint: search for the first value that is between p and q. That will be your lowest common ancestor"
                    },
                    {
                        "username": "Noob_SWEbot",
                        "content": "This is a great hint! Should be the default hint in the problem description. "
                    },
                    {
                        "username": "rstone13",
                        "content": "That\\'s absolutely brilliant! Here I was trying to figure out how to track if p and q have been found and if the current node is a parent of both p and q and all that."
                    },
                    {
                        "username": "misters",
                        "content": "        if(root.val > p.val && root.val > q.val) return lowestCommonAncestor(root.left, p, q);\\n        else if(root.val < p.val && root.val < q.val) return lowestCommonAncestor(root.right, p, q);\\n        else return root;"
                    },
                    {
                        "username": "olejiksa",
                        "content": "[@Khushi_Mattu](/Khushi_Mattu) you can use iterative approach for this problem. Iterative search in BST runs faster"
                    },
                    {
                        "username": "khushimattu",
                        "content": "can anyone tell a better solution then this? I did with the same logic but mine only beats 13% which means it can be optimised."
                    },
                    {
                        "username": "AMATEURTOSS",
                        "content": "genius"
                    },
                    {
                        "username": "vimlife",
                        "content": "Please no answers in the discussion section. See rules"
                    },
                    {
                        "username": "onomojo",
                        "content": "I stupidly overlooked the BST part and started trying to solve it as a generic tree. Obviously that way over-complicates it. "
                    },
                    {
                        "username": "ayukumi",
                        "content": " same code will work fine for both BST as well as BT "
                    },
                    {
                        "username": "g4b0r",
                        "content": "Is there a way I can extend this question so it supports swift? Or is that something the original author has to do?"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Nothing is stopping you from translating the answer into other languages. In fact that is a great way to internalize the material."
                    },
                    {
                        "username": "cjsy",
                        "content": "if the input is: \\n[2, 5, 6]\\n5\\n6\\n\\nwhy the results is 6? Why not 2?"
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "this is not a bst bro\\n"
                    },
                    {
                        "username": "AsumalSingh",
                        "content": "because node can be a descendant of itself"
                    },
                    {
                        "username": "Sidchou",
                        "content": "[@yestrup](/yestrup) but the question doesnt mention anything about valid binary tree"
                    },
                    {
                        "username": "Sidchou",
                        "content": "yeah i got same question, why is [5,3,6,2,4,null,null,1], 6,1 expecting 5, not 2"
                    },
                    {
                        "username": "yestrup",
                        "content": "[2, 5, 6] is not a valid binary tree"
                    },
                    {
                        "username": "anujp99",
                        "content": "[@hayduke415](/hayduke415) This is because it is asking for the Lowest common ancestor, not the smallest. It is going by height/level."
                    },
                    {
                        "username": "upup1904",
                        "content": "I guess `[2,5,6]` is ambiguous.  In that case it means 5 is right child of 2 and 6 is right child of 5.  I guess?"
                    },
                    {
                        "username": "hayduke415",
                        "content": "I have the same question! wouldn\\'t the lowestcommon ancestor of 8-9 be 6?"
                    },
                    {
                        "username": "elsayedzahran789",
                        "content": "BST Problems are the best"
                    },
                    {
                        "username": "srapol",
                        "content": "nah man"
                    }
                ]
            },
            {
                "id": 1737022,
                "content": [
                    {
                        "username": "Jayusc",
                        "content": "so this is lowest common ancestor, not smallest common ancestor. I am an idiot"
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "what a bad wording for the title!"
                    },
                    {
                        "username": "rayrogar",
                        "content": "why,why,why mr Anderson, Why the tricky title"
                    },
                    {
                        "username": "rahulnegi2021",
                        "content": "us."
                    },
                    {
                        "username": "mpostrel",
                        "content": "omg thanks for clarifying. me too :( "
                    },
                    {
                        "username": "Cyril-0110",
                        "content": "You\\'re not alone :)"
                    },
                    {
                        "username": "tunsmm0",
                        "content": "I was confused about these situation too. They mean not value of node, but place of node in the tree. So in case where p = 7 and q = 9, the lowest will 8, not 6"
                    },
                    {
                        "username": "IvanStebletsov",
                        "content": "Refreshing my knowledge about key traits of binary search tree very helped me find simple solution for this problem. I\\'d recommend you start from it.\\n\\nBST has following traits:\\n1) Both root\\'s subtrees also are binary (it is not important for solution, but just FYI);\\n2) All **LEFT** child nodes of **LEFT** subtree have values **less or equal** the value of the current node.\\n2) All **RIGHT** child nodes of **RIGHT** subtree have values **greater** the value of the current node.\\n\\nKeeping in mind these traits we can start traverse tree in depth (DFS).\\n\\nMain idea: \\n- If **current node value > p.value and q.value**, hence according to trait **\\u21162** above, it\\'s useless search common node for **p** and **q** in the **right** subtree -> continue traverse next node in **left** subtree.\\n- If **current node value < p.value and q.value**, hence according to trait **\\u21163** above, it\\'s useless search common node for **p** and **q** in the **left** subtree  -> continue traverse next node in **right** subtree\\n- If according to statements above it\\'s useless search common node in both **left** and **right** subtree, it means that you are in a right place, you have found Lowest Common Ancestor.\\n\\nUsing this idea you can solve problem both iteratively and recursively.\\n\\nIf I\\'m not mistaken time complexity will be O(logN), because every time we chose only one subtree, therefore reduce count of traversable nodes twice. Memory complexity O(1).\\n\\nHope it will be helpful."
                    },
                    {
                        "username": "vskamade206",
                        "content": "Nice One brother\\n"
                    },
                    {
                        "username": "advanced-bencoding",
                        "content": "Remember that lowestCommonAncestor is in terms of depth level and not common node value based!"
                    },
                    {
                        "username": "veekshithcb",
                        "content": "thanks I was scratching head without understanding question completely "
                    },
                    {
                        "username": "noseonarug17",
                        "content": "For anyone who got confused and frustrated because output was inexplicably `undefined` - despite the way it displays the output, it wants you to return the node itself, not the value. This was true for Javascript, anyway."
                    },
                    {
                        "username": "Spacetoaster",
                        "content": "wow, this was frustrating, thanks"
                    },
                    {
                        "username": "yfang82",
                        "content": "Hint: search for the first value that is between p and q. That will be your lowest common ancestor"
                    },
                    {
                        "username": "Noob_SWEbot",
                        "content": "This is a great hint! Should be the default hint in the problem description. "
                    },
                    {
                        "username": "rstone13",
                        "content": "That\\'s absolutely brilliant! Here I was trying to figure out how to track if p and q have been found and if the current node is a parent of both p and q and all that."
                    },
                    {
                        "username": "misters",
                        "content": "        if(root.val > p.val && root.val > q.val) return lowestCommonAncestor(root.left, p, q);\\n        else if(root.val < p.val && root.val < q.val) return lowestCommonAncestor(root.right, p, q);\\n        else return root;"
                    },
                    {
                        "username": "olejiksa",
                        "content": "[@Khushi_Mattu](/Khushi_Mattu) you can use iterative approach for this problem. Iterative search in BST runs faster"
                    },
                    {
                        "username": "khushimattu",
                        "content": "can anyone tell a better solution then this? I did with the same logic but mine only beats 13% which means it can be optimised."
                    },
                    {
                        "username": "AMATEURTOSS",
                        "content": "genius"
                    },
                    {
                        "username": "vimlife",
                        "content": "Please no answers in the discussion section. See rules"
                    },
                    {
                        "username": "onomojo",
                        "content": "I stupidly overlooked the BST part and started trying to solve it as a generic tree. Obviously that way over-complicates it. "
                    },
                    {
                        "username": "ayukumi",
                        "content": " same code will work fine for both BST as well as BT "
                    },
                    {
                        "username": "g4b0r",
                        "content": "Is there a way I can extend this question so it supports swift? Or is that something the original author has to do?"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Nothing is stopping you from translating the answer into other languages. In fact that is a great way to internalize the material."
                    },
                    {
                        "username": "cjsy",
                        "content": "if the input is: \\n[2, 5, 6]\\n5\\n6\\n\\nwhy the results is 6? Why not 2?"
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "this is not a bst bro\\n"
                    },
                    {
                        "username": "AsumalSingh",
                        "content": "because node can be a descendant of itself"
                    },
                    {
                        "username": "Sidchou",
                        "content": "[@yestrup](/yestrup) but the question doesnt mention anything about valid binary tree"
                    },
                    {
                        "username": "Sidchou",
                        "content": "yeah i got same question, why is [5,3,6,2,4,null,null,1], 6,1 expecting 5, not 2"
                    },
                    {
                        "username": "yestrup",
                        "content": "[2, 5, 6] is not a valid binary tree"
                    },
                    {
                        "username": "anujp99",
                        "content": "[@hayduke415](/hayduke415) This is because it is asking for the Lowest common ancestor, not the smallest. It is going by height/level."
                    },
                    {
                        "username": "upup1904",
                        "content": "I guess `[2,5,6]` is ambiguous.  In that case it means 5 is right child of 2 and 6 is right child of 5.  I guess?"
                    },
                    {
                        "username": "hayduke415",
                        "content": "I have the same question! wouldn\\'t the lowestcommon ancestor of 8-9 be 6?"
                    },
                    {
                        "username": "elsayedzahran789",
                        "content": "BST Problems are the best"
                    },
                    {
                        "username": "srapol",
                        "content": "nah man"
                    }
                ]
            },
            {
                "id": 1567231,
                "content": [
                    {
                        "username": "Jayusc",
                        "content": "so this is lowest common ancestor, not smallest common ancestor. I am an idiot"
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "what a bad wording for the title!"
                    },
                    {
                        "username": "rayrogar",
                        "content": "why,why,why mr Anderson, Why the tricky title"
                    },
                    {
                        "username": "rahulnegi2021",
                        "content": "us."
                    },
                    {
                        "username": "mpostrel",
                        "content": "omg thanks for clarifying. me too :( "
                    },
                    {
                        "username": "Cyril-0110",
                        "content": "You\\'re not alone :)"
                    },
                    {
                        "username": "tunsmm0",
                        "content": "I was confused about these situation too. They mean not value of node, but place of node in the tree. So in case where p = 7 and q = 9, the lowest will 8, not 6"
                    },
                    {
                        "username": "IvanStebletsov",
                        "content": "Refreshing my knowledge about key traits of binary search tree very helped me find simple solution for this problem. I\\'d recommend you start from it.\\n\\nBST has following traits:\\n1) Both root\\'s subtrees also are binary (it is not important for solution, but just FYI);\\n2) All **LEFT** child nodes of **LEFT** subtree have values **less or equal** the value of the current node.\\n2) All **RIGHT** child nodes of **RIGHT** subtree have values **greater** the value of the current node.\\n\\nKeeping in mind these traits we can start traverse tree in depth (DFS).\\n\\nMain idea: \\n- If **current node value > p.value and q.value**, hence according to trait **\\u21162** above, it\\'s useless search common node for **p** and **q** in the **right** subtree -> continue traverse next node in **left** subtree.\\n- If **current node value < p.value and q.value**, hence according to trait **\\u21163** above, it\\'s useless search common node for **p** and **q** in the **left** subtree  -> continue traverse next node in **right** subtree\\n- If according to statements above it\\'s useless search common node in both **left** and **right** subtree, it means that you are in a right place, you have found Lowest Common Ancestor.\\n\\nUsing this idea you can solve problem both iteratively and recursively.\\n\\nIf I\\'m not mistaken time complexity will be O(logN), because every time we chose only one subtree, therefore reduce count of traversable nodes twice. Memory complexity O(1).\\n\\nHope it will be helpful."
                    },
                    {
                        "username": "vskamade206",
                        "content": "Nice One brother\\n"
                    },
                    {
                        "username": "advanced-bencoding",
                        "content": "Remember that lowestCommonAncestor is in terms of depth level and not common node value based!"
                    },
                    {
                        "username": "veekshithcb",
                        "content": "thanks I was scratching head without understanding question completely "
                    },
                    {
                        "username": "noseonarug17",
                        "content": "For anyone who got confused and frustrated because output was inexplicably `undefined` - despite the way it displays the output, it wants you to return the node itself, not the value. This was true for Javascript, anyway."
                    },
                    {
                        "username": "Spacetoaster",
                        "content": "wow, this was frustrating, thanks"
                    },
                    {
                        "username": "yfang82",
                        "content": "Hint: search for the first value that is between p and q. That will be your lowest common ancestor"
                    },
                    {
                        "username": "Noob_SWEbot",
                        "content": "This is a great hint! Should be the default hint in the problem description. "
                    },
                    {
                        "username": "rstone13",
                        "content": "That\\'s absolutely brilliant! Here I was trying to figure out how to track if p and q have been found and if the current node is a parent of both p and q and all that."
                    },
                    {
                        "username": "misters",
                        "content": "        if(root.val > p.val && root.val > q.val) return lowestCommonAncestor(root.left, p, q);\\n        else if(root.val < p.val && root.val < q.val) return lowestCommonAncestor(root.right, p, q);\\n        else return root;"
                    },
                    {
                        "username": "olejiksa",
                        "content": "[@Khushi_Mattu](/Khushi_Mattu) you can use iterative approach for this problem. Iterative search in BST runs faster"
                    },
                    {
                        "username": "khushimattu",
                        "content": "can anyone tell a better solution then this? I did with the same logic but mine only beats 13% which means it can be optimised."
                    },
                    {
                        "username": "AMATEURTOSS",
                        "content": "genius"
                    },
                    {
                        "username": "vimlife",
                        "content": "Please no answers in the discussion section. See rules"
                    },
                    {
                        "username": "onomojo",
                        "content": "I stupidly overlooked the BST part and started trying to solve it as a generic tree. Obviously that way over-complicates it. "
                    },
                    {
                        "username": "ayukumi",
                        "content": " same code will work fine for both BST as well as BT "
                    },
                    {
                        "username": "g4b0r",
                        "content": "Is there a way I can extend this question so it supports swift? Or is that something the original author has to do?"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Nothing is stopping you from translating the answer into other languages. In fact that is a great way to internalize the material."
                    },
                    {
                        "username": "cjsy",
                        "content": "if the input is: \\n[2, 5, 6]\\n5\\n6\\n\\nwhy the results is 6? Why not 2?"
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "this is not a bst bro\\n"
                    },
                    {
                        "username": "AsumalSingh",
                        "content": "because node can be a descendant of itself"
                    },
                    {
                        "username": "Sidchou",
                        "content": "[@yestrup](/yestrup) but the question doesnt mention anything about valid binary tree"
                    },
                    {
                        "username": "Sidchou",
                        "content": "yeah i got same question, why is [5,3,6,2,4,null,null,1], 6,1 expecting 5, not 2"
                    },
                    {
                        "username": "yestrup",
                        "content": "[2, 5, 6] is not a valid binary tree"
                    },
                    {
                        "username": "anujp99",
                        "content": "[@hayduke415](/hayduke415) This is because it is asking for the Lowest common ancestor, not the smallest. It is going by height/level."
                    },
                    {
                        "username": "upup1904",
                        "content": "I guess `[2,5,6]` is ambiguous.  In that case it means 5 is right child of 2 and 6 is right child of 5.  I guess?"
                    },
                    {
                        "username": "hayduke415",
                        "content": "I have the same question! wouldn\\'t the lowestcommon ancestor of 8-9 be 6?"
                    },
                    {
                        "username": "elsayedzahran789",
                        "content": "BST Problems are the best"
                    },
                    {
                        "username": "srapol",
                        "content": "nah man"
                    }
                ]
            },
            {
                "id": 1572114,
                "content": [
                    {
                        "username": "Jayusc",
                        "content": "so this is lowest common ancestor, not smallest common ancestor. I am an idiot"
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "what a bad wording for the title!"
                    },
                    {
                        "username": "rayrogar",
                        "content": "why,why,why mr Anderson, Why the tricky title"
                    },
                    {
                        "username": "rahulnegi2021",
                        "content": "us."
                    },
                    {
                        "username": "mpostrel",
                        "content": "omg thanks for clarifying. me too :( "
                    },
                    {
                        "username": "Cyril-0110",
                        "content": "You\\'re not alone :)"
                    },
                    {
                        "username": "tunsmm0",
                        "content": "I was confused about these situation too. They mean not value of node, but place of node in the tree. So in case where p = 7 and q = 9, the lowest will 8, not 6"
                    },
                    {
                        "username": "IvanStebletsov",
                        "content": "Refreshing my knowledge about key traits of binary search tree very helped me find simple solution for this problem. I\\'d recommend you start from it.\\n\\nBST has following traits:\\n1) Both root\\'s subtrees also are binary (it is not important for solution, but just FYI);\\n2) All **LEFT** child nodes of **LEFT** subtree have values **less or equal** the value of the current node.\\n2) All **RIGHT** child nodes of **RIGHT** subtree have values **greater** the value of the current node.\\n\\nKeeping in mind these traits we can start traverse tree in depth (DFS).\\n\\nMain idea: \\n- If **current node value > p.value and q.value**, hence according to trait **\\u21162** above, it\\'s useless search common node for **p** and **q** in the **right** subtree -> continue traverse next node in **left** subtree.\\n- If **current node value < p.value and q.value**, hence according to trait **\\u21163** above, it\\'s useless search common node for **p** and **q** in the **left** subtree  -> continue traverse next node in **right** subtree\\n- If according to statements above it\\'s useless search common node in both **left** and **right** subtree, it means that you are in a right place, you have found Lowest Common Ancestor.\\n\\nUsing this idea you can solve problem both iteratively and recursively.\\n\\nIf I\\'m not mistaken time complexity will be O(logN), because every time we chose only one subtree, therefore reduce count of traversable nodes twice. Memory complexity O(1).\\n\\nHope it will be helpful."
                    },
                    {
                        "username": "vskamade206",
                        "content": "Nice One brother\\n"
                    },
                    {
                        "username": "advanced-bencoding",
                        "content": "Remember that lowestCommonAncestor is in terms of depth level and not common node value based!"
                    },
                    {
                        "username": "veekshithcb",
                        "content": "thanks I was scratching head without understanding question completely "
                    },
                    {
                        "username": "noseonarug17",
                        "content": "For anyone who got confused and frustrated because output was inexplicably `undefined` - despite the way it displays the output, it wants you to return the node itself, not the value. This was true for Javascript, anyway."
                    },
                    {
                        "username": "Spacetoaster",
                        "content": "wow, this was frustrating, thanks"
                    },
                    {
                        "username": "yfang82",
                        "content": "Hint: search for the first value that is between p and q. That will be your lowest common ancestor"
                    },
                    {
                        "username": "Noob_SWEbot",
                        "content": "This is a great hint! Should be the default hint in the problem description. "
                    },
                    {
                        "username": "rstone13",
                        "content": "That\\'s absolutely brilliant! Here I was trying to figure out how to track if p and q have been found and if the current node is a parent of both p and q and all that."
                    },
                    {
                        "username": "misters",
                        "content": "        if(root.val > p.val && root.val > q.val) return lowestCommonAncestor(root.left, p, q);\\n        else if(root.val < p.val && root.val < q.val) return lowestCommonAncestor(root.right, p, q);\\n        else return root;"
                    },
                    {
                        "username": "olejiksa",
                        "content": "[@Khushi_Mattu](/Khushi_Mattu) you can use iterative approach for this problem. Iterative search in BST runs faster"
                    },
                    {
                        "username": "khushimattu",
                        "content": "can anyone tell a better solution then this? I did with the same logic but mine only beats 13% which means it can be optimised."
                    },
                    {
                        "username": "AMATEURTOSS",
                        "content": "genius"
                    },
                    {
                        "username": "vimlife",
                        "content": "Please no answers in the discussion section. See rules"
                    },
                    {
                        "username": "onomojo",
                        "content": "I stupidly overlooked the BST part and started trying to solve it as a generic tree. Obviously that way over-complicates it. "
                    },
                    {
                        "username": "ayukumi",
                        "content": " same code will work fine for both BST as well as BT "
                    },
                    {
                        "username": "g4b0r",
                        "content": "Is there a way I can extend this question so it supports swift? Or is that something the original author has to do?"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Nothing is stopping you from translating the answer into other languages. In fact that is a great way to internalize the material."
                    },
                    {
                        "username": "cjsy",
                        "content": "if the input is: \\n[2, 5, 6]\\n5\\n6\\n\\nwhy the results is 6? Why not 2?"
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "this is not a bst bro\\n"
                    },
                    {
                        "username": "AsumalSingh",
                        "content": "because node can be a descendant of itself"
                    },
                    {
                        "username": "Sidchou",
                        "content": "[@yestrup](/yestrup) but the question doesnt mention anything about valid binary tree"
                    },
                    {
                        "username": "Sidchou",
                        "content": "yeah i got same question, why is [5,3,6,2,4,null,null,1], 6,1 expecting 5, not 2"
                    },
                    {
                        "username": "yestrup",
                        "content": "[2, 5, 6] is not a valid binary tree"
                    },
                    {
                        "username": "anujp99",
                        "content": "[@hayduke415](/hayduke415) This is because it is asking for the Lowest common ancestor, not the smallest. It is going by height/level."
                    },
                    {
                        "username": "upup1904",
                        "content": "I guess `[2,5,6]` is ambiguous.  In that case it means 5 is right child of 2 and 6 is right child of 5.  I guess?"
                    },
                    {
                        "username": "hayduke415",
                        "content": "I have the same question! wouldn\\'t the lowestcommon ancestor of 8-9 be 6?"
                    },
                    {
                        "username": "elsayedzahran789",
                        "content": "BST Problems are the best"
                    },
                    {
                        "username": "srapol",
                        "content": "nah man"
                    }
                ]
            },
            {
                "id": 1780013,
                "content": [
                    {
                        "username": "Jayusc",
                        "content": "so this is lowest common ancestor, not smallest common ancestor. I am an idiot"
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "what a bad wording for the title!"
                    },
                    {
                        "username": "rayrogar",
                        "content": "why,why,why mr Anderson, Why the tricky title"
                    },
                    {
                        "username": "rahulnegi2021",
                        "content": "us."
                    },
                    {
                        "username": "mpostrel",
                        "content": "omg thanks for clarifying. me too :( "
                    },
                    {
                        "username": "Cyril-0110",
                        "content": "You\\'re not alone :)"
                    },
                    {
                        "username": "tunsmm0",
                        "content": "I was confused about these situation too. They mean not value of node, but place of node in the tree. So in case where p = 7 and q = 9, the lowest will 8, not 6"
                    },
                    {
                        "username": "IvanStebletsov",
                        "content": "Refreshing my knowledge about key traits of binary search tree very helped me find simple solution for this problem. I\\'d recommend you start from it.\\n\\nBST has following traits:\\n1) Both root\\'s subtrees also are binary (it is not important for solution, but just FYI);\\n2) All **LEFT** child nodes of **LEFT** subtree have values **less or equal** the value of the current node.\\n2) All **RIGHT** child nodes of **RIGHT** subtree have values **greater** the value of the current node.\\n\\nKeeping in mind these traits we can start traverse tree in depth (DFS).\\n\\nMain idea: \\n- If **current node value > p.value and q.value**, hence according to trait **\\u21162** above, it\\'s useless search common node for **p** and **q** in the **right** subtree -> continue traverse next node in **left** subtree.\\n- If **current node value < p.value and q.value**, hence according to trait **\\u21163** above, it\\'s useless search common node for **p** and **q** in the **left** subtree  -> continue traverse next node in **right** subtree\\n- If according to statements above it\\'s useless search common node in both **left** and **right** subtree, it means that you are in a right place, you have found Lowest Common Ancestor.\\n\\nUsing this idea you can solve problem both iteratively and recursively.\\n\\nIf I\\'m not mistaken time complexity will be O(logN), because every time we chose only one subtree, therefore reduce count of traversable nodes twice. Memory complexity O(1).\\n\\nHope it will be helpful."
                    },
                    {
                        "username": "vskamade206",
                        "content": "Nice One brother\\n"
                    },
                    {
                        "username": "advanced-bencoding",
                        "content": "Remember that lowestCommonAncestor is in terms of depth level and not common node value based!"
                    },
                    {
                        "username": "veekshithcb",
                        "content": "thanks I was scratching head without understanding question completely "
                    },
                    {
                        "username": "noseonarug17",
                        "content": "For anyone who got confused and frustrated because output was inexplicably `undefined` - despite the way it displays the output, it wants you to return the node itself, not the value. This was true for Javascript, anyway."
                    },
                    {
                        "username": "Spacetoaster",
                        "content": "wow, this was frustrating, thanks"
                    },
                    {
                        "username": "yfang82",
                        "content": "Hint: search for the first value that is between p and q. That will be your lowest common ancestor"
                    },
                    {
                        "username": "Noob_SWEbot",
                        "content": "This is a great hint! Should be the default hint in the problem description. "
                    },
                    {
                        "username": "rstone13",
                        "content": "That\\'s absolutely brilliant! Here I was trying to figure out how to track if p and q have been found and if the current node is a parent of both p and q and all that."
                    },
                    {
                        "username": "misters",
                        "content": "        if(root.val > p.val && root.val > q.val) return lowestCommonAncestor(root.left, p, q);\\n        else if(root.val < p.val && root.val < q.val) return lowestCommonAncestor(root.right, p, q);\\n        else return root;"
                    },
                    {
                        "username": "olejiksa",
                        "content": "[@Khushi_Mattu](/Khushi_Mattu) you can use iterative approach for this problem. Iterative search in BST runs faster"
                    },
                    {
                        "username": "khushimattu",
                        "content": "can anyone tell a better solution then this? I did with the same logic but mine only beats 13% which means it can be optimised."
                    },
                    {
                        "username": "AMATEURTOSS",
                        "content": "genius"
                    },
                    {
                        "username": "vimlife",
                        "content": "Please no answers in the discussion section. See rules"
                    },
                    {
                        "username": "onomojo",
                        "content": "I stupidly overlooked the BST part and started trying to solve it as a generic tree. Obviously that way over-complicates it. "
                    },
                    {
                        "username": "ayukumi",
                        "content": " same code will work fine for both BST as well as BT "
                    },
                    {
                        "username": "g4b0r",
                        "content": "Is there a way I can extend this question so it supports swift? Or is that something the original author has to do?"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Nothing is stopping you from translating the answer into other languages. In fact that is a great way to internalize the material."
                    },
                    {
                        "username": "cjsy",
                        "content": "if the input is: \\n[2, 5, 6]\\n5\\n6\\n\\nwhy the results is 6? Why not 2?"
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "this is not a bst bro\\n"
                    },
                    {
                        "username": "AsumalSingh",
                        "content": "because node can be a descendant of itself"
                    },
                    {
                        "username": "Sidchou",
                        "content": "[@yestrup](/yestrup) but the question doesnt mention anything about valid binary tree"
                    },
                    {
                        "username": "Sidchou",
                        "content": "yeah i got same question, why is [5,3,6,2,4,null,null,1], 6,1 expecting 5, not 2"
                    },
                    {
                        "username": "yestrup",
                        "content": "[2, 5, 6] is not a valid binary tree"
                    },
                    {
                        "username": "anujp99",
                        "content": "[@hayduke415](/hayduke415) This is because it is asking for the Lowest common ancestor, not the smallest. It is going by height/level."
                    },
                    {
                        "username": "upup1904",
                        "content": "I guess `[2,5,6]` is ambiguous.  In that case it means 5 is right child of 2 and 6 is right child of 5.  I guess?"
                    },
                    {
                        "username": "hayduke415",
                        "content": "I have the same question! wouldn\\'t the lowestcommon ancestor of 8-9 be 6?"
                    },
                    {
                        "username": "elsayedzahran789",
                        "content": "BST Problems are the best"
                    },
                    {
                        "username": "srapol",
                        "content": "nah man"
                    }
                ]
            },
            {
                "id": 1571473,
                "content": [
                    {
                        "username": "doubledherin",
                        "content": "I'm looking at the Python version, which shows \"rtype: Treenode\", but since we need to return root.val, not root, that should be int, no?"
                    },
                    {
                        "username": "ahmedsidd45",
                        "content": "Exactly, the question is pretty confusing. The should have metioned something like \"return the root node object\" "
                    },
                    {
                        "username": "aweyiun",
                        "content": "The interface function is given two pointers and the returned value is pointer ,not value. If values of the is repeated,  say a extreme case: values are all the same. In general solution, root will be returned which considers only values of p, q not their positions in the BST.So I wonder if pointers should be considered."
                    },
                    {
                        "username": "younginterceptor",
                        "content": "It should probably be an `easy` problem"
                    },
                    {
                        "username": "MJ12_Believer",
                        "content": "its not easy you MERNcel"
                    },
                    {
                        "username": "mikeycantcode",
                        "content": "no no"
                    },
                    {
                        "username": "logancornforth",
                        "content": "What is this error?\\n\\nAttributeError: \\'int\\' object has no attribute \\'val\\'\\n    out = str(ret.val) if ret else \"null\"\\nLine 68 in _driver (Solution.py)\\n    _driver()\\nLine 77 in <module> (Solution.py)"
                    },
                    {
                        "username": "IvndjssG4",
                        "content": "The output is not as expected because the given input is not a binary search tree. In a BST, for every node, all elements in the left subtree should be less than the node\\'s value and all elements in the right subtree should be greater than the node\\'s value. But in this case, [6,2,8,0,4,7,9,null,null,3,5] is not a BST because\\n3 is in left subtree of 2 which is not less than 2, so the given tree is not a binary search tree, so the function will not work correctly on this input.\\n\\nYou can use other methods to find LCA in a binary tree, like storing the path from root to both nodes and then comparing the path to find the first different node.\\nOr, you can use a modified version of the above function that is not only comparing value but also does the comparison between p and q with the current node and it\\'s children."
                    },
                    {
                        "username": "kirany",
                        "content": "For the given example, the LCA of 3 & 5 is reported as 4. Shouldn't it be 2 as 4 itself is a descendant of 2"
                    },
                    {
                        "username": "upup1904",
                        "content": "I thought examples/wording pretty clear but maybe it should say \"deepest common ancestor\" in parents or something."
                    },
                    {
                        "username": "advanced-bencoding",
                        "content": "it is depth level, not lowest value of ancestor."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Remember the properties of a **BST** (Binary Search Tree) \n\n`Hint`"
                    },
                    {
                        "username": "throwawayHoppelhase",
                        "content": "It\\'s a BST, therefore there is an ordering on the tree :)! This should do the trick."
                    },
                    {
                        "username": "owengretzinger",
                        "content": "\"Lowest\" is very ambiguous. I (and many others as I can see) thought this meant the node with the least value. It would be helpful to include more clarity in the question! (For example, clarify that \"lowest\" means the node furthest from the root.)"
                    },
                    {
                        "username": "itsgauthamp",
                        "content": "class Solution(object):\\n    def lowestCommonAncestor(self, root, p, q):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: TreeNode\\n        \"\"\"\\n\\n        queue = [root]\\n\\n        def cans(queue):\\n            while queue:\\n                \\n                size = len(queue)\\n\\n                for i in range(size):\\n                    node = queue.pop(0)\\n                    preval = node.val\\n                    print(\"hi\")\\n\\n                    if node.left:\\n                        queue.append(node.left)\\n\\n                    if node.right:\\n                        queue.append(node.right)\\n                    if node.left:\\n                        print(preval,p.val,q.val,node.left.val)\\n                   \\n\\n                    if p == preval and q == node.left or q==node.right:  #condition 1\\n                        \\n                        return node\\n\\n                    elif (p == node.left or p==node.right) and (q == node.left or q==node.right):\\n                        print(p.val,node.left.val,node.right.val,q.val)\\n                        return node\\n                    elif q == preval and p == node.left or p==node.right:\\n                        return node\\n                        \\n\\n                 \\n        val =cans(queue)\\n        return val\\n\\n\\ncan anyone tell me why this code doesn\\'t work for [2,1] i expect it to pass condition 1"
                    }
                ]
            },
            {
                "id": 1569038,
                "content": [
                    {
                        "username": "doubledherin",
                        "content": "I'm looking at the Python version, which shows \"rtype: Treenode\", but since we need to return root.val, not root, that should be int, no?"
                    },
                    {
                        "username": "ahmedsidd45",
                        "content": "Exactly, the question is pretty confusing. The should have metioned something like \"return the root node object\" "
                    },
                    {
                        "username": "aweyiun",
                        "content": "The interface function is given two pointers and the returned value is pointer ,not value. If values of the is repeated,  say a extreme case: values are all the same. In general solution, root will be returned which considers only values of p, q not their positions in the BST.So I wonder if pointers should be considered."
                    },
                    {
                        "username": "younginterceptor",
                        "content": "It should probably be an `easy` problem"
                    },
                    {
                        "username": "MJ12_Believer",
                        "content": "its not easy you MERNcel"
                    },
                    {
                        "username": "mikeycantcode",
                        "content": "no no"
                    },
                    {
                        "username": "logancornforth",
                        "content": "What is this error?\\n\\nAttributeError: \\'int\\' object has no attribute \\'val\\'\\n    out = str(ret.val) if ret else \"null\"\\nLine 68 in _driver (Solution.py)\\n    _driver()\\nLine 77 in <module> (Solution.py)"
                    },
                    {
                        "username": "IvndjssG4",
                        "content": "The output is not as expected because the given input is not a binary search tree. In a BST, for every node, all elements in the left subtree should be less than the node\\'s value and all elements in the right subtree should be greater than the node\\'s value. But in this case, [6,2,8,0,4,7,9,null,null,3,5] is not a BST because\\n3 is in left subtree of 2 which is not less than 2, so the given tree is not a binary search tree, so the function will not work correctly on this input.\\n\\nYou can use other methods to find LCA in a binary tree, like storing the path from root to both nodes and then comparing the path to find the first different node.\\nOr, you can use a modified version of the above function that is not only comparing value but also does the comparison between p and q with the current node and it\\'s children."
                    },
                    {
                        "username": "kirany",
                        "content": "For the given example, the LCA of 3 & 5 is reported as 4. Shouldn't it be 2 as 4 itself is a descendant of 2"
                    },
                    {
                        "username": "upup1904",
                        "content": "I thought examples/wording pretty clear but maybe it should say \"deepest common ancestor\" in parents or something."
                    },
                    {
                        "username": "advanced-bencoding",
                        "content": "it is depth level, not lowest value of ancestor."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Remember the properties of a **BST** (Binary Search Tree) \n\n`Hint`"
                    },
                    {
                        "username": "throwawayHoppelhase",
                        "content": "It\\'s a BST, therefore there is an ordering on the tree :)! This should do the trick."
                    },
                    {
                        "username": "owengretzinger",
                        "content": "\"Lowest\" is very ambiguous. I (and many others as I can see) thought this meant the node with the least value. It would be helpful to include more clarity in the question! (For example, clarify that \"lowest\" means the node furthest from the root.)"
                    },
                    {
                        "username": "itsgauthamp",
                        "content": "class Solution(object):\\n    def lowestCommonAncestor(self, root, p, q):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: TreeNode\\n        \"\"\"\\n\\n        queue = [root]\\n\\n        def cans(queue):\\n            while queue:\\n                \\n                size = len(queue)\\n\\n                for i in range(size):\\n                    node = queue.pop(0)\\n                    preval = node.val\\n                    print(\"hi\")\\n\\n                    if node.left:\\n                        queue.append(node.left)\\n\\n                    if node.right:\\n                        queue.append(node.right)\\n                    if node.left:\\n                        print(preval,p.val,q.val,node.left.val)\\n                   \\n\\n                    if p == preval and q == node.left or q==node.right:  #condition 1\\n                        \\n                        return node\\n\\n                    elif (p == node.left or p==node.right) and (q == node.left or q==node.right):\\n                        print(p.val,node.left.val,node.right.val,q.val)\\n                        return node\\n                    elif q == preval and p == node.left or p==node.right:\\n                        return node\\n                        \\n\\n                 \\n        val =cans(queue)\\n        return val\\n\\n\\ncan anyone tell me why this code doesn\\'t work for [2,1] i expect it to pass condition 1"
                    }
                ]
            },
            {
                "id": 1922550,
                "content": [
                    {
                        "username": "doubledherin",
                        "content": "I'm looking at the Python version, which shows \"rtype: Treenode\", but since we need to return root.val, not root, that should be int, no?"
                    },
                    {
                        "username": "ahmedsidd45",
                        "content": "Exactly, the question is pretty confusing. The should have metioned something like \"return the root node object\" "
                    },
                    {
                        "username": "aweyiun",
                        "content": "The interface function is given two pointers and the returned value is pointer ,not value. If values of the is repeated,  say a extreme case: values are all the same. In general solution, root will be returned which considers only values of p, q not their positions in the BST.So I wonder if pointers should be considered."
                    },
                    {
                        "username": "younginterceptor",
                        "content": "It should probably be an `easy` problem"
                    },
                    {
                        "username": "MJ12_Believer",
                        "content": "its not easy you MERNcel"
                    },
                    {
                        "username": "mikeycantcode",
                        "content": "no no"
                    },
                    {
                        "username": "logancornforth",
                        "content": "What is this error?\\n\\nAttributeError: \\'int\\' object has no attribute \\'val\\'\\n    out = str(ret.val) if ret else \"null\"\\nLine 68 in _driver (Solution.py)\\n    _driver()\\nLine 77 in <module> (Solution.py)"
                    },
                    {
                        "username": "IvndjssG4",
                        "content": "The output is not as expected because the given input is not a binary search tree. In a BST, for every node, all elements in the left subtree should be less than the node\\'s value and all elements in the right subtree should be greater than the node\\'s value. But in this case, [6,2,8,0,4,7,9,null,null,3,5] is not a BST because\\n3 is in left subtree of 2 which is not less than 2, so the given tree is not a binary search tree, so the function will not work correctly on this input.\\n\\nYou can use other methods to find LCA in a binary tree, like storing the path from root to both nodes and then comparing the path to find the first different node.\\nOr, you can use a modified version of the above function that is not only comparing value but also does the comparison between p and q with the current node and it\\'s children."
                    },
                    {
                        "username": "kirany",
                        "content": "For the given example, the LCA of 3 & 5 is reported as 4. Shouldn't it be 2 as 4 itself is a descendant of 2"
                    },
                    {
                        "username": "upup1904",
                        "content": "I thought examples/wording pretty clear but maybe it should say \"deepest common ancestor\" in parents or something."
                    },
                    {
                        "username": "advanced-bencoding",
                        "content": "it is depth level, not lowest value of ancestor."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Remember the properties of a **BST** (Binary Search Tree) \n\n`Hint`"
                    },
                    {
                        "username": "throwawayHoppelhase",
                        "content": "It\\'s a BST, therefore there is an ordering on the tree :)! This should do the trick."
                    },
                    {
                        "username": "owengretzinger",
                        "content": "\"Lowest\" is very ambiguous. I (and many others as I can see) thought this meant the node with the least value. It would be helpful to include more clarity in the question! (For example, clarify that \"lowest\" means the node furthest from the root.)"
                    },
                    {
                        "username": "itsgauthamp",
                        "content": "class Solution(object):\\n    def lowestCommonAncestor(self, root, p, q):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: TreeNode\\n        \"\"\"\\n\\n        queue = [root]\\n\\n        def cans(queue):\\n            while queue:\\n                \\n                size = len(queue)\\n\\n                for i in range(size):\\n                    node = queue.pop(0)\\n                    preval = node.val\\n                    print(\"hi\")\\n\\n                    if node.left:\\n                        queue.append(node.left)\\n\\n                    if node.right:\\n                        queue.append(node.right)\\n                    if node.left:\\n                        print(preval,p.val,q.val,node.left.val)\\n                   \\n\\n                    if p == preval and q == node.left or q==node.right:  #condition 1\\n                        \\n                        return node\\n\\n                    elif (p == node.left or p==node.right) and (q == node.left or q==node.right):\\n                        print(p.val,node.left.val,node.right.val,q.val)\\n                        return node\\n                    elif q == preval and p == node.left or p==node.right:\\n                        return node\\n                        \\n\\n                 \\n        val =cans(queue)\\n        return val\\n\\n\\ncan anyone tell me why this code doesn\\'t work for [2,1] i expect it to pass condition 1"
                    }
                ]
            },
            {
                "id": 1823770,
                "content": [
                    {
                        "username": "doubledherin",
                        "content": "I'm looking at the Python version, which shows \"rtype: Treenode\", but since we need to return root.val, not root, that should be int, no?"
                    },
                    {
                        "username": "ahmedsidd45",
                        "content": "Exactly, the question is pretty confusing. The should have metioned something like \"return the root node object\" "
                    },
                    {
                        "username": "aweyiun",
                        "content": "The interface function is given two pointers and the returned value is pointer ,not value. If values of the is repeated,  say a extreme case: values are all the same. In general solution, root will be returned which considers only values of p, q not their positions in the BST.So I wonder if pointers should be considered."
                    },
                    {
                        "username": "younginterceptor",
                        "content": "It should probably be an `easy` problem"
                    },
                    {
                        "username": "MJ12_Believer",
                        "content": "its not easy you MERNcel"
                    },
                    {
                        "username": "mikeycantcode",
                        "content": "no no"
                    },
                    {
                        "username": "logancornforth",
                        "content": "What is this error?\\n\\nAttributeError: \\'int\\' object has no attribute \\'val\\'\\n    out = str(ret.val) if ret else \"null\"\\nLine 68 in _driver (Solution.py)\\n    _driver()\\nLine 77 in <module> (Solution.py)"
                    },
                    {
                        "username": "IvndjssG4",
                        "content": "The output is not as expected because the given input is not a binary search tree. In a BST, for every node, all elements in the left subtree should be less than the node\\'s value and all elements in the right subtree should be greater than the node\\'s value. But in this case, [6,2,8,0,4,7,9,null,null,3,5] is not a BST because\\n3 is in left subtree of 2 which is not less than 2, so the given tree is not a binary search tree, so the function will not work correctly on this input.\\n\\nYou can use other methods to find LCA in a binary tree, like storing the path from root to both nodes and then comparing the path to find the first different node.\\nOr, you can use a modified version of the above function that is not only comparing value but also does the comparison between p and q with the current node and it\\'s children."
                    },
                    {
                        "username": "kirany",
                        "content": "For the given example, the LCA of 3 & 5 is reported as 4. Shouldn't it be 2 as 4 itself is a descendant of 2"
                    },
                    {
                        "username": "upup1904",
                        "content": "I thought examples/wording pretty clear but maybe it should say \"deepest common ancestor\" in parents or something."
                    },
                    {
                        "username": "advanced-bencoding",
                        "content": "it is depth level, not lowest value of ancestor."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Remember the properties of a **BST** (Binary Search Tree) \n\n`Hint`"
                    },
                    {
                        "username": "throwawayHoppelhase",
                        "content": "It\\'s a BST, therefore there is an ordering on the tree :)! This should do the trick."
                    },
                    {
                        "username": "owengretzinger",
                        "content": "\"Lowest\" is very ambiguous. I (and many others as I can see) thought this meant the node with the least value. It would be helpful to include more clarity in the question! (For example, clarify that \"lowest\" means the node furthest from the root.)"
                    },
                    {
                        "username": "itsgauthamp",
                        "content": "class Solution(object):\\n    def lowestCommonAncestor(self, root, p, q):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: TreeNode\\n        \"\"\"\\n\\n        queue = [root]\\n\\n        def cans(queue):\\n            while queue:\\n                \\n                size = len(queue)\\n\\n                for i in range(size):\\n                    node = queue.pop(0)\\n                    preval = node.val\\n                    print(\"hi\")\\n\\n                    if node.left:\\n                        queue.append(node.left)\\n\\n                    if node.right:\\n                        queue.append(node.right)\\n                    if node.left:\\n                        print(preval,p.val,q.val,node.left.val)\\n                   \\n\\n                    if p == preval and q == node.left or q==node.right:  #condition 1\\n                        \\n                        return node\\n\\n                    elif (p == node.left or p==node.right) and (q == node.left or q==node.right):\\n                        print(p.val,node.left.val,node.right.val,q.val)\\n                        return node\\n                    elif q == preval and p == node.left or p==node.right:\\n                        return node\\n                        \\n\\n                 \\n        val =cans(queue)\\n        return val\\n\\n\\ncan anyone tell me why this code doesn\\'t work for [2,1] i expect it to pass condition 1"
                    }
                ]
            },
            {
                "id": 1771782,
                "content": [
                    {
                        "username": "doubledherin",
                        "content": "I'm looking at the Python version, which shows \"rtype: Treenode\", but since we need to return root.val, not root, that should be int, no?"
                    },
                    {
                        "username": "ahmedsidd45",
                        "content": "Exactly, the question is pretty confusing. The should have metioned something like \"return the root node object\" "
                    },
                    {
                        "username": "aweyiun",
                        "content": "The interface function is given two pointers and the returned value is pointer ,not value. If values of the is repeated,  say a extreme case: values are all the same. In general solution, root will be returned which considers only values of p, q not their positions in the BST.So I wonder if pointers should be considered."
                    },
                    {
                        "username": "younginterceptor",
                        "content": "It should probably be an `easy` problem"
                    },
                    {
                        "username": "MJ12_Believer",
                        "content": "its not easy you MERNcel"
                    },
                    {
                        "username": "mikeycantcode",
                        "content": "no no"
                    },
                    {
                        "username": "logancornforth",
                        "content": "What is this error?\\n\\nAttributeError: \\'int\\' object has no attribute \\'val\\'\\n    out = str(ret.val) if ret else \"null\"\\nLine 68 in _driver (Solution.py)\\n    _driver()\\nLine 77 in <module> (Solution.py)"
                    },
                    {
                        "username": "IvndjssG4",
                        "content": "The output is not as expected because the given input is not a binary search tree. In a BST, for every node, all elements in the left subtree should be less than the node\\'s value and all elements in the right subtree should be greater than the node\\'s value. But in this case, [6,2,8,0,4,7,9,null,null,3,5] is not a BST because\\n3 is in left subtree of 2 which is not less than 2, so the given tree is not a binary search tree, so the function will not work correctly on this input.\\n\\nYou can use other methods to find LCA in a binary tree, like storing the path from root to both nodes and then comparing the path to find the first different node.\\nOr, you can use a modified version of the above function that is not only comparing value but also does the comparison between p and q with the current node and it\\'s children."
                    },
                    {
                        "username": "kirany",
                        "content": "For the given example, the LCA of 3 & 5 is reported as 4. Shouldn't it be 2 as 4 itself is a descendant of 2"
                    },
                    {
                        "username": "upup1904",
                        "content": "I thought examples/wording pretty clear but maybe it should say \"deepest common ancestor\" in parents or something."
                    },
                    {
                        "username": "advanced-bencoding",
                        "content": "it is depth level, not lowest value of ancestor."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Remember the properties of a **BST** (Binary Search Tree) \n\n`Hint`"
                    },
                    {
                        "username": "throwawayHoppelhase",
                        "content": "It\\'s a BST, therefore there is an ordering on the tree :)! This should do the trick."
                    },
                    {
                        "username": "owengretzinger",
                        "content": "\"Lowest\" is very ambiguous. I (and many others as I can see) thought this meant the node with the least value. It would be helpful to include more clarity in the question! (For example, clarify that \"lowest\" means the node furthest from the root.)"
                    },
                    {
                        "username": "itsgauthamp",
                        "content": "class Solution(object):\\n    def lowestCommonAncestor(self, root, p, q):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: TreeNode\\n        \"\"\"\\n\\n        queue = [root]\\n\\n        def cans(queue):\\n            while queue:\\n                \\n                size = len(queue)\\n\\n                for i in range(size):\\n                    node = queue.pop(0)\\n                    preval = node.val\\n                    print(\"hi\")\\n\\n                    if node.left:\\n                        queue.append(node.left)\\n\\n                    if node.right:\\n                        queue.append(node.right)\\n                    if node.left:\\n                        print(preval,p.val,q.val,node.left.val)\\n                   \\n\\n                    if p == preval and q == node.left or q==node.right:  #condition 1\\n                        \\n                        return node\\n\\n                    elif (p == node.left or p==node.right) and (q == node.left or q==node.right):\\n                        print(p.val,node.left.val,node.right.val,q.val)\\n                        return node\\n                    elif q == preval and p == node.left or p==node.right:\\n                        return node\\n                        \\n\\n                 \\n        val =cans(queue)\\n        return val\\n\\n\\ncan anyone tell me why this code doesn\\'t work for [2,1] i expect it to pass condition 1"
                    }
                ]
            },
            {
                "id": 1571472,
                "content": [
                    {
                        "username": "doubledherin",
                        "content": "I'm looking at the Python version, which shows \"rtype: Treenode\", but since we need to return root.val, not root, that should be int, no?"
                    },
                    {
                        "username": "ahmedsidd45",
                        "content": "Exactly, the question is pretty confusing. The should have metioned something like \"return the root node object\" "
                    },
                    {
                        "username": "aweyiun",
                        "content": "The interface function is given two pointers and the returned value is pointer ,not value. If values of the is repeated,  say a extreme case: values are all the same. In general solution, root will be returned which considers only values of p, q not their positions in the BST.So I wonder if pointers should be considered."
                    },
                    {
                        "username": "younginterceptor",
                        "content": "It should probably be an `easy` problem"
                    },
                    {
                        "username": "MJ12_Believer",
                        "content": "its not easy you MERNcel"
                    },
                    {
                        "username": "mikeycantcode",
                        "content": "no no"
                    },
                    {
                        "username": "logancornforth",
                        "content": "What is this error?\\n\\nAttributeError: \\'int\\' object has no attribute \\'val\\'\\n    out = str(ret.val) if ret else \"null\"\\nLine 68 in _driver (Solution.py)\\n    _driver()\\nLine 77 in <module> (Solution.py)"
                    },
                    {
                        "username": "IvndjssG4",
                        "content": "The output is not as expected because the given input is not a binary search tree. In a BST, for every node, all elements in the left subtree should be less than the node\\'s value and all elements in the right subtree should be greater than the node\\'s value. But in this case, [6,2,8,0,4,7,9,null,null,3,5] is not a BST because\\n3 is in left subtree of 2 which is not less than 2, so the given tree is not a binary search tree, so the function will not work correctly on this input.\\n\\nYou can use other methods to find LCA in a binary tree, like storing the path from root to both nodes and then comparing the path to find the first different node.\\nOr, you can use a modified version of the above function that is not only comparing value but also does the comparison between p and q with the current node and it\\'s children."
                    },
                    {
                        "username": "kirany",
                        "content": "For the given example, the LCA of 3 & 5 is reported as 4. Shouldn't it be 2 as 4 itself is a descendant of 2"
                    },
                    {
                        "username": "upup1904",
                        "content": "I thought examples/wording pretty clear but maybe it should say \"deepest common ancestor\" in parents or something."
                    },
                    {
                        "username": "advanced-bencoding",
                        "content": "it is depth level, not lowest value of ancestor."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Remember the properties of a **BST** (Binary Search Tree) \n\n`Hint`"
                    },
                    {
                        "username": "throwawayHoppelhase",
                        "content": "It\\'s a BST, therefore there is an ordering on the tree :)! This should do the trick."
                    },
                    {
                        "username": "owengretzinger",
                        "content": "\"Lowest\" is very ambiguous. I (and many others as I can see) thought this meant the node with the least value. It would be helpful to include more clarity in the question! (For example, clarify that \"lowest\" means the node furthest from the root.)"
                    },
                    {
                        "username": "itsgauthamp",
                        "content": "class Solution(object):\\n    def lowestCommonAncestor(self, root, p, q):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: TreeNode\\n        \"\"\"\\n\\n        queue = [root]\\n\\n        def cans(queue):\\n            while queue:\\n                \\n                size = len(queue)\\n\\n                for i in range(size):\\n                    node = queue.pop(0)\\n                    preval = node.val\\n                    print(\"hi\")\\n\\n                    if node.left:\\n                        queue.append(node.left)\\n\\n                    if node.right:\\n                        queue.append(node.right)\\n                    if node.left:\\n                        print(preval,p.val,q.val,node.left.val)\\n                   \\n\\n                    if p == preval and q == node.left or q==node.right:  #condition 1\\n                        \\n                        return node\\n\\n                    elif (p == node.left or p==node.right) and (q == node.left or q==node.right):\\n                        print(p.val,node.left.val,node.right.val,q.val)\\n                        return node\\n                    elif q == preval and p == node.left or p==node.right:\\n                        return node\\n                        \\n\\n                 \\n        val =cans(queue)\\n        return val\\n\\n\\ncan anyone tell me why this code doesn\\'t work for [2,1] i expect it to pass condition 1"
                    }
                ]
            },
            {
                "id": 2061565,
                "content": [
                    {
                        "username": "doubledherin",
                        "content": "I'm looking at the Python version, which shows \"rtype: Treenode\", but since we need to return root.val, not root, that should be int, no?"
                    },
                    {
                        "username": "ahmedsidd45",
                        "content": "Exactly, the question is pretty confusing. The should have metioned something like \"return the root node object\" "
                    },
                    {
                        "username": "aweyiun",
                        "content": "The interface function is given two pointers and the returned value is pointer ,not value. If values of the is repeated,  say a extreme case: values are all the same. In general solution, root will be returned which considers only values of p, q not their positions in the BST.So I wonder if pointers should be considered."
                    },
                    {
                        "username": "younginterceptor",
                        "content": "It should probably be an `easy` problem"
                    },
                    {
                        "username": "MJ12_Believer",
                        "content": "its not easy you MERNcel"
                    },
                    {
                        "username": "mikeycantcode",
                        "content": "no no"
                    },
                    {
                        "username": "logancornforth",
                        "content": "What is this error?\\n\\nAttributeError: \\'int\\' object has no attribute \\'val\\'\\n    out = str(ret.val) if ret else \"null\"\\nLine 68 in _driver (Solution.py)\\n    _driver()\\nLine 77 in <module> (Solution.py)"
                    },
                    {
                        "username": "IvndjssG4",
                        "content": "The output is not as expected because the given input is not a binary search tree. In a BST, for every node, all elements in the left subtree should be less than the node\\'s value and all elements in the right subtree should be greater than the node\\'s value. But in this case, [6,2,8,0,4,7,9,null,null,3,5] is not a BST because\\n3 is in left subtree of 2 which is not less than 2, so the given tree is not a binary search tree, so the function will not work correctly on this input.\\n\\nYou can use other methods to find LCA in a binary tree, like storing the path from root to both nodes and then comparing the path to find the first different node.\\nOr, you can use a modified version of the above function that is not only comparing value but also does the comparison between p and q with the current node and it\\'s children."
                    },
                    {
                        "username": "kirany",
                        "content": "For the given example, the LCA of 3 & 5 is reported as 4. Shouldn't it be 2 as 4 itself is a descendant of 2"
                    },
                    {
                        "username": "upup1904",
                        "content": "I thought examples/wording pretty clear but maybe it should say \"deepest common ancestor\" in parents or something."
                    },
                    {
                        "username": "advanced-bencoding",
                        "content": "it is depth level, not lowest value of ancestor."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Remember the properties of a **BST** (Binary Search Tree) \n\n`Hint`"
                    },
                    {
                        "username": "throwawayHoppelhase",
                        "content": "It\\'s a BST, therefore there is an ordering on the tree :)! This should do the trick."
                    },
                    {
                        "username": "owengretzinger",
                        "content": "\"Lowest\" is very ambiguous. I (and many others as I can see) thought this meant the node with the least value. It would be helpful to include more clarity in the question! (For example, clarify that \"lowest\" means the node furthest from the root.)"
                    },
                    {
                        "username": "itsgauthamp",
                        "content": "class Solution(object):\\n    def lowestCommonAncestor(self, root, p, q):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: TreeNode\\n        \"\"\"\\n\\n        queue = [root]\\n\\n        def cans(queue):\\n            while queue:\\n                \\n                size = len(queue)\\n\\n                for i in range(size):\\n                    node = queue.pop(0)\\n                    preval = node.val\\n                    print(\"hi\")\\n\\n                    if node.left:\\n                        queue.append(node.left)\\n\\n                    if node.right:\\n                        queue.append(node.right)\\n                    if node.left:\\n                        print(preval,p.val,q.val,node.left.val)\\n                   \\n\\n                    if p == preval and q == node.left or q==node.right:  #condition 1\\n                        \\n                        return node\\n\\n                    elif (p == node.left or p==node.right) and (q == node.left or q==node.right):\\n                        print(p.val,node.left.val,node.right.val,q.val)\\n                        return node\\n                    elif q == preval and p == node.left or p==node.right:\\n                        return node\\n                        \\n\\n                 \\n        val =cans(queue)\\n        return val\\n\\n\\ncan anyone tell me why this code doesn\\'t work for [2,1] i expect it to pass condition 1"
                    }
                ]
            },
            {
                "id": 2055970,
                "content": [
                    {
                        "username": "doubledherin",
                        "content": "I'm looking at the Python version, which shows \"rtype: Treenode\", but since we need to return root.val, not root, that should be int, no?"
                    },
                    {
                        "username": "ahmedsidd45",
                        "content": "Exactly, the question is pretty confusing. The should have metioned something like \"return the root node object\" "
                    },
                    {
                        "username": "aweyiun",
                        "content": "The interface function is given two pointers and the returned value is pointer ,not value. If values of the is repeated,  say a extreme case: values are all the same. In general solution, root will be returned which considers only values of p, q not their positions in the BST.So I wonder if pointers should be considered."
                    },
                    {
                        "username": "younginterceptor",
                        "content": "It should probably be an `easy` problem"
                    },
                    {
                        "username": "MJ12_Believer",
                        "content": "its not easy you MERNcel"
                    },
                    {
                        "username": "mikeycantcode",
                        "content": "no no"
                    },
                    {
                        "username": "logancornforth",
                        "content": "What is this error?\\n\\nAttributeError: \\'int\\' object has no attribute \\'val\\'\\n    out = str(ret.val) if ret else \"null\"\\nLine 68 in _driver (Solution.py)\\n    _driver()\\nLine 77 in <module> (Solution.py)"
                    },
                    {
                        "username": "IvndjssG4",
                        "content": "The output is not as expected because the given input is not a binary search tree. In a BST, for every node, all elements in the left subtree should be less than the node\\'s value and all elements in the right subtree should be greater than the node\\'s value. But in this case, [6,2,8,0,4,7,9,null,null,3,5] is not a BST because\\n3 is in left subtree of 2 which is not less than 2, so the given tree is not a binary search tree, so the function will not work correctly on this input.\\n\\nYou can use other methods to find LCA in a binary tree, like storing the path from root to both nodes and then comparing the path to find the first different node.\\nOr, you can use a modified version of the above function that is not only comparing value but also does the comparison between p and q with the current node and it\\'s children."
                    },
                    {
                        "username": "kirany",
                        "content": "For the given example, the LCA of 3 & 5 is reported as 4. Shouldn't it be 2 as 4 itself is a descendant of 2"
                    },
                    {
                        "username": "upup1904",
                        "content": "I thought examples/wording pretty clear but maybe it should say \"deepest common ancestor\" in parents or something."
                    },
                    {
                        "username": "advanced-bencoding",
                        "content": "it is depth level, not lowest value of ancestor."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Remember the properties of a **BST** (Binary Search Tree) \n\n`Hint`"
                    },
                    {
                        "username": "throwawayHoppelhase",
                        "content": "It\\'s a BST, therefore there is an ordering on the tree :)! This should do the trick."
                    },
                    {
                        "username": "owengretzinger",
                        "content": "\"Lowest\" is very ambiguous. I (and many others as I can see) thought this meant the node with the least value. It would be helpful to include more clarity in the question! (For example, clarify that \"lowest\" means the node furthest from the root.)"
                    },
                    {
                        "username": "itsgauthamp",
                        "content": "class Solution(object):\\n    def lowestCommonAncestor(self, root, p, q):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: TreeNode\\n        \"\"\"\\n\\n        queue = [root]\\n\\n        def cans(queue):\\n            while queue:\\n                \\n                size = len(queue)\\n\\n                for i in range(size):\\n                    node = queue.pop(0)\\n                    preval = node.val\\n                    print(\"hi\")\\n\\n                    if node.left:\\n                        queue.append(node.left)\\n\\n                    if node.right:\\n                        queue.append(node.right)\\n                    if node.left:\\n                        print(preval,p.val,q.val,node.left.val)\\n                   \\n\\n                    if p == preval and q == node.left or q==node.right:  #condition 1\\n                        \\n                        return node\\n\\n                    elif (p == node.left or p==node.right) and (q == node.left or q==node.right):\\n                        print(p.val,node.left.val,node.right.val,q.val)\\n                        return node\\n                    elif q == preval and p == node.left or p==node.right:\\n                        return node\\n                        \\n\\n                 \\n        val =cans(queue)\\n        return val\\n\\n\\ncan anyone tell me why this code doesn\\'t work for [2,1] i expect it to pass condition 1"
                    }
                ]
            },
            {
                "id": 2055154,
                "content": [
                    {
                        "username": "doubledherin",
                        "content": "I'm looking at the Python version, which shows \"rtype: Treenode\", but since we need to return root.val, not root, that should be int, no?"
                    },
                    {
                        "username": "ahmedsidd45",
                        "content": "Exactly, the question is pretty confusing. The should have metioned something like \"return the root node object\" "
                    },
                    {
                        "username": "aweyiun",
                        "content": "The interface function is given two pointers and the returned value is pointer ,not value. If values of the is repeated,  say a extreme case: values are all the same. In general solution, root will be returned which considers only values of p, q not their positions in the BST.So I wonder if pointers should be considered."
                    },
                    {
                        "username": "younginterceptor",
                        "content": "It should probably be an `easy` problem"
                    },
                    {
                        "username": "MJ12_Believer",
                        "content": "its not easy you MERNcel"
                    },
                    {
                        "username": "mikeycantcode",
                        "content": "no no"
                    },
                    {
                        "username": "logancornforth",
                        "content": "What is this error?\\n\\nAttributeError: \\'int\\' object has no attribute \\'val\\'\\n    out = str(ret.val) if ret else \"null\"\\nLine 68 in _driver (Solution.py)\\n    _driver()\\nLine 77 in <module> (Solution.py)"
                    },
                    {
                        "username": "IvndjssG4",
                        "content": "The output is not as expected because the given input is not a binary search tree. In a BST, for every node, all elements in the left subtree should be less than the node\\'s value and all elements in the right subtree should be greater than the node\\'s value. But in this case, [6,2,8,0,4,7,9,null,null,3,5] is not a BST because\\n3 is in left subtree of 2 which is not less than 2, so the given tree is not a binary search tree, so the function will not work correctly on this input.\\n\\nYou can use other methods to find LCA in a binary tree, like storing the path from root to both nodes and then comparing the path to find the first different node.\\nOr, you can use a modified version of the above function that is not only comparing value but also does the comparison between p and q with the current node and it\\'s children."
                    },
                    {
                        "username": "kirany",
                        "content": "For the given example, the LCA of 3 & 5 is reported as 4. Shouldn't it be 2 as 4 itself is a descendant of 2"
                    },
                    {
                        "username": "upup1904",
                        "content": "I thought examples/wording pretty clear but maybe it should say \"deepest common ancestor\" in parents or something."
                    },
                    {
                        "username": "advanced-bencoding",
                        "content": "it is depth level, not lowest value of ancestor."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Remember the properties of a **BST** (Binary Search Tree) \n\n`Hint`"
                    },
                    {
                        "username": "throwawayHoppelhase",
                        "content": "It\\'s a BST, therefore there is an ordering on the tree :)! This should do the trick."
                    },
                    {
                        "username": "owengretzinger",
                        "content": "\"Lowest\" is very ambiguous. I (and many others as I can see) thought this meant the node with the least value. It would be helpful to include more clarity in the question! (For example, clarify that \"lowest\" means the node furthest from the root.)"
                    },
                    {
                        "username": "itsgauthamp",
                        "content": "class Solution(object):\\n    def lowestCommonAncestor(self, root, p, q):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: TreeNode\\n        \"\"\"\\n\\n        queue = [root]\\n\\n        def cans(queue):\\n            while queue:\\n                \\n                size = len(queue)\\n\\n                for i in range(size):\\n                    node = queue.pop(0)\\n                    preval = node.val\\n                    print(\"hi\")\\n\\n                    if node.left:\\n                        queue.append(node.left)\\n\\n                    if node.right:\\n                        queue.append(node.right)\\n                    if node.left:\\n                        print(preval,p.val,q.val,node.left.val)\\n                   \\n\\n                    if p == preval and q == node.left or q==node.right:  #condition 1\\n                        \\n                        return node\\n\\n                    elif (p == node.left or p==node.right) and (q == node.left or q==node.right):\\n                        print(p.val,node.left.val,node.right.val,q.val)\\n                        return node\\n                    elif q == preval and p == node.left or p==node.right:\\n                        return node\\n                        \\n\\n                 \\n        val =cans(queue)\\n        return val\\n\\n\\ncan anyone tell me why this code doesn\\'t work for [2,1] i expect it to pass condition 1"
                    }
                ]
            },
            {
                "id": 2024278,
                "content": [
                    {
                        "username": "doubledherin",
                        "content": "I'm looking at the Python version, which shows \"rtype: Treenode\", but since we need to return root.val, not root, that should be int, no?"
                    },
                    {
                        "username": "ahmedsidd45",
                        "content": "Exactly, the question is pretty confusing. The should have metioned something like \"return the root node object\" "
                    },
                    {
                        "username": "aweyiun",
                        "content": "The interface function is given two pointers and the returned value is pointer ,not value. If values of the is repeated,  say a extreme case: values are all the same. In general solution, root will be returned which considers only values of p, q not their positions in the BST.So I wonder if pointers should be considered."
                    },
                    {
                        "username": "younginterceptor",
                        "content": "It should probably be an `easy` problem"
                    },
                    {
                        "username": "MJ12_Believer",
                        "content": "its not easy you MERNcel"
                    },
                    {
                        "username": "mikeycantcode",
                        "content": "no no"
                    },
                    {
                        "username": "logancornforth",
                        "content": "What is this error?\\n\\nAttributeError: \\'int\\' object has no attribute \\'val\\'\\n    out = str(ret.val) if ret else \"null\"\\nLine 68 in _driver (Solution.py)\\n    _driver()\\nLine 77 in <module> (Solution.py)"
                    },
                    {
                        "username": "IvndjssG4",
                        "content": "The output is not as expected because the given input is not a binary search tree. In a BST, for every node, all elements in the left subtree should be less than the node\\'s value and all elements in the right subtree should be greater than the node\\'s value. But in this case, [6,2,8,0,4,7,9,null,null,3,5] is not a BST because\\n3 is in left subtree of 2 which is not less than 2, so the given tree is not a binary search tree, so the function will not work correctly on this input.\\n\\nYou can use other methods to find LCA in a binary tree, like storing the path from root to both nodes and then comparing the path to find the first different node.\\nOr, you can use a modified version of the above function that is not only comparing value but also does the comparison between p and q with the current node and it\\'s children."
                    },
                    {
                        "username": "kirany",
                        "content": "For the given example, the LCA of 3 & 5 is reported as 4. Shouldn't it be 2 as 4 itself is a descendant of 2"
                    },
                    {
                        "username": "upup1904",
                        "content": "I thought examples/wording pretty clear but maybe it should say \"deepest common ancestor\" in parents or something."
                    },
                    {
                        "username": "advanced-bencoding",
                        "content": "it is depth level, not lowest value of ancestor."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Remember the properties of a **BST** (Binary Search Tree) \n\n`Hint`"
                    },
                    {
                        "username": "throwawayHoppelhase",
                        "content": "It\\'s a BST, therefore there is an ordering on the tree :)! This should do the trick."
                    },
                    {
                        "username": "owengretzinger",
                        "content": "\"Lowest\" is very ambiguous. I (and many others as I can see) thought this meant the node with the least value. It would be helpful to include more clarity in the question! (For example, clarify that \"lowest\" means the node furthest from the root.)"
                    },
                    {
                        "username": "itsgauthamp",
                        "content": "class Solution(object):\\n    def lowestCommonAncestor(self, root, p, q):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: TreeNode\\n        \"\"\"\\n\\n        queue = [root]\\n\\n        def cans(queue):\\n            while queue:\\n                \\n                size = len(queue)\\n\\n                for i in range(size):\\n                    node = queue.pop(0)\\n                    preval = node.val\\n                    print(\"hi\")\\n\\n                    if node.left:\\n                        queue.append(node.left)\\n\\n                    if node.right:\\n                        queue.append(node.right)\\n                    if node.left:\\n                        print(preval,p.val,q.val,node.left.val)\\n                   \\n\\n                    if p == preval and q == node.left or q==node.right:  #condition 1\\n                        \\n                        return node\\n\\n                    elif (p == node.left or p==node.right) and (q == node.left or q==node.right):\\n                        print(p.val,node.left.val,node.right.val,q.val)\\n                        return node\\n                    elif q == preval and p == node.left or p==node.right:\\n                        return node\\n                        \\n\\n                 \\n        val =cans(queue)\\n        return val\\n\\n\\ncan anyone tell me why this code doesn\\'t work for [2,1] i expect it to pass condition 1"
                    }
                ]
            },
            {
                "id": 2008930,
                "content": [
                    {
                        "username": "yip1",
                        "content": "(HINT) Think of the properties of binary search! Look at the values of p and q and their placement in the tree.\\n(specifically how the placements affect our decision to traverse left or right)"
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "must visit for best solution with best explanation :\\nhttps://leetcode.com/problems/make-array-strictly-increasing/solutions/3646825/c-dynamic-programming/[leetcode]\\n\\n [@Ashish Madhup](/ashish_madhup)"
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "must visit my solutions"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "I have copy pasted my code from Question \\n**236. Lowest Common Ancestor of a Binary Tree**\\n and successfully submitted"
                    },
                    {
                        "username": "geekyshark",
                        "content": "you just unlocked clown outfit"
                    },
                    {
                        "username": "sspenst",
                        "content": "I guess it\\'s been a while since I\\'ve looked at trees, I forgot BST implies left and right are lower and greater respectively...\\n\\nMy first solution used DFS until I found both p and q while keeping track of the paths to each node, then compared the paths to see where they diverge. Obviously it becomes a lot easier if you know a BST is ordered \\uD83D\\uDE05"
                    },
                    {
                        "username": "jvpessoa10",
                        "content": "Can someone help me to understand why my solution only beats 5% of all submissions in terms of speed?\n\nI go down the tree until the nodes diverge. I assume it should be O (lg n ) Speed and O (1) Space\n\n  ```\nfun lowestCommonAncestor(root: TreeNode?, p: TreeNode?, q: TreeNode?): TreeNode? {\n\n        var ancestor: TreeNode? = null\n\n        var pCurr = root\n        var qCurr = root\n\n        while(pCurr == qCurr) {\n            ancestor = pCurr\n\n            if (p!!.`val` > pCurr!!.`val`) {\n                pCurr = pCurr?.right\n            } else if (p!!.`val` < pCurr!!.`val`) {\n                pCurr = pCurr?.left\n            }\n\n            if (q!!.`val` > qCurr!!.`val`) {\n                qCurr = qCurr?.right\n            } else if (q!!.`val` < qCurr!!.`val`) {\n                qCurr = qCurr?.left\n            }\n        }\n\n        return ancestor\n    }\n\n```\n\n"
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "Connect me on Linkdin :  linkedin.com/in/ashish-madhup-640479221"
                    },
                    {
                        "username": "toyeshingole",
                        "content": "this kinda does not make sense to me\n "
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "Connect me on Linkdin :  linkedin.com/in/ashish-madhup-640479221"
                    },
                    {
                        "username": "Naveen_Singh__",
                        "content": "The lowest common ancestor will be the node from where p node and q node will situated at opposite side to each other.\\ni.e lets say p.val < q.val\\nin that case\\nif(root.val >= p.val && root.val <= q.val)return root\\n(root node will be your lowest Common Ancestor)\\n\\nif p.val > q.val\\nin that case\\nif(root.val <= p.val && root.val >= q.val)return root\\n(root node will be your lowest Common Ancestor)  "
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "Connect me on Linkdin :  linkedin.com/in/ashish-madhup-640479221"
                    },
                    {
                        "username": "harshadrsharma",
                        "content": "This is an easy solution once you understand that it is a BST and that the nodes p and q are guaranteed to be present in the tree. Don\\'t understand why it\\'s tagged as a medium one."
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "Connect me on Linkdin :  linkedin.com/in/ashish-madhup-640479221"
                    },
                    {
                        "username": "just_sabyr",
                        "content": "What type are p and q exactly? In lowestCommonAncestor it\\'s defined as TreeNode and in the Testcases it\\'s int. Which one is the actual type?"
                    },
                    {
                        "username": "just_sabyr",
                        "content": "[@IvanStebletsov](/IvanStebletsov) oh, the error was that output must have been a node not an int"
                    },
                    {
                        "username": "IvanStebletsov",
                        "content": "TreeNode it\\'s an object, inside this object there is a property with its value named as \"val\", value is int."
                    }
                ]
            },
            {
                "id": 1932960,
                "content": [
                    {
                        "username": "yip1",
                        "content": "(HINT) Think of the properties of binary search! Look at the values of p and q and their placement in the tree.\\n(specifically how the placements affect our decision to traverse left or right)"
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "must visit for best solution with best explanation :\\nhttps://leetcode.com/problems/make-array-strictly-increasing/solutions/3646825/c-dynamic-programming/[leetcode]\\n\\n [@Ashish Madhup](/ashish_madhup)"
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "must visit my solutions"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "I have copy pasted my code from Question \\n**236. Lowest Common Ancestor of a Binary Tree**\\n and successfully submitted"
                    },
                    {
                        "username": "geekyshark",
                        "content": "you just unlocked clown outfit"
                    },
                    {
                        "username": "sspenst",
                        "content": "I guess it\\'s been a while since I\\'ve looked at trees, I forgot BST implies left and right are lower and greater respectively...\\n\\nMy first solution used DFS until I found both p and q while keeping track of the paths to each node, then compared the paths to see where they diverge. Obviously it becomes a lot easier if you know a BST is ordered \\uD83D\\uDE05"
                    },
                    {
                        "username": "jvpessoa10",
                        "content": "Can someone help me to understand why my solution only beats 5% of all submissions in terms of speed?\n\nI go down the tree until the nodes diverge. I assume it should be O (lg n ) Speed and O (1) Space\n\n  ```\nfun lowestCommonAncestor(root: TreeNode?, p: TreeNode?, q: TreeNode?): TreeNode? {\n\n        var ancestor: TreeNode? = null\n\n        var pCurr = root\n        var qCurr = root\n\n        while(pCurr == qCurr) {\n            ancestor = pCurr\n\n            if (p!!.`val` > pCurr!!.`val`) {\n                pCurr = pCurr?.right\n            } else if (p!!.`val` < pCurr!!.`val`) {\n                pCurr = pCurr?.left\n            }\n\n            if (q!!.`val` > qCurr!!.`val`) {\n                qCurr = qCurr?.right\n            } else if (q!!.`val` < qCurr!!.`val`) {\n                qCurr = qCurr?.left\n            }\n        }\n\n        return ancestor\n    }\n\n```\n\n"
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "Connect me on Linkdin :  linkedin.com/in/ashish-madhup-640479221"
                    },
                    {
                        "username": "toyeshingole",
                        "content": "this kinda does not make sense to me\n "
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "Connect me on Linkdin :  linkedin.com/in/ashish-madhup-640479221"
                    },
                    {
                        "username": "Naveen_Singh__",
                        "content": "The lowest common ancestor will be the node from where p node and q node will situated at opposite side to each other.\\ni.e lets say p.val < q.val\\nin that case\\nif(root.val >= p.val && root.val <= q.val)return root\\n(root node will be your lowest Common Ancestor)\\n\\nif p.val > q.val\\nin that case\\nif(root.val <= p.val && root.val >= q.val)return root\\n(root node will be your lowest Common Ancestor)  "
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "Connect me on Linkdin :  linkedin.com/in/ashish-madhup-640479221"
                    },
                    {
                        "username": "harshadrsharma",
                        "content": "This is an easy solution once you understand that it is a BST and that the nodes p and q are guaranteed to be present in the tree. Don\\'t understand why it\\'s tagged as a medium one."
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "Connect me on Linkdin :  linkedin.com/in/ashish-madhup-640479221"
                    },
                    {
                        "username": "just_sabyr",
                        "content": "What type are p and q exactly? In lowestCommonAncestor it\\'s defined as TreeNode and in the Testcases it\\'s int. Which one is the actual type?"
                    },
                    {
                        "username": "just_sabyr",
                        "content": "[@IvanStebletsov](/IvanStebletsov) oh, the error was that output must have been a node not an int"
                    },
                    {
                        "username": "IvanStebletsov",
                        "content": "TreeNode it\\'s an object, inside this object there is a property with its value named as \"val\", value is int."
                    }
                ]
            },
            {
                "id": 1932956,
                "content": [
                    {
                        "username": "yip1",
                        "content": "(HINT) Think of the properties of binary search! Look at the values of p and q and their placement in the tree.\\n(specifically how the placements affect our decision to traverse left or right)"
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "must visit for best solution with best explanation :\\nhttps://leetcode.com/problems/make-array-strictly-increasing/solutions/3646825/c-dynamic-programming/[leetcode]\\n\\n [@Ashish Madhup](/ashish_madhup)"
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "must visit my solutions"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "I have copy pasted my code from Question \\n**236. Lowest Common Ancestor of a Binary Tree**\\n and successfully submitted"
                    },
                    {
                        "username": "geekyshark",
                        "content": "you just unlocked clown outfit"
                    },
                    {
                        "username": "sspenst",
                        "content": "I guess it\\'s been a while since I\\'ve looked at trees, I forgot BST implies left and right are lower and greater respectively...\\n\\nMy first solution used DFS until I found both p and q while keeping track of the paths to each node, then compared the paths to see where they diverge. Obviously it becomes a lot easier if you know a BST is ordered \\uD83D\\uDE05"
                    },
                    {
                        "username": "jvpessoa10",
                        "content": "Can someone help me to understand why my solution only beats 5% of all submissions in terms of speed?\n\nI go down the tree until the nodes diverge. I assume it should be O (lg n ) Speed and O (1) Space\n\n  ```\nfun lowestCommonAncestor(root: TreeNode?, p: TreeNode?, q: TreeNode?): TreeNode? {\n\n        var ancestor: TreeNode? = null\n\n        var pCurr = root\n        var qCurr = root\n\n        while(pCurr == qCurr) {\n            ancestor = pCurr\n\n            if (p!!.`val` > pCurr!!.`val`) {\n                pCurr = pCurr?.right\n            } else if (p!!.`val` < pCurr!!.`val`) {\n                pCurr = pCurr?.left\n            }\n\n            if (q!!.`val` > qCurr!!.`val`) {\n                qCurr = qCurr?.right\n            } else if (q!!.`val` < qCurr!!.`val`) {\n                qCurr = qCurr?.left\n            }\n        }\n\n        return ancestor\n    }\n\n```\n\n"
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "Connect me on Linkdin :  linkedin.com/in/ashish-madhup-640479221"
                    },
                    {
                        "username": "toyeshingole",
                        "content": "this kinda does not make sense to me\n "
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "Connect me on Linkdin :  linkedin.com/in/ashish-madhup-640479221"
                    },
                    {
                        "username": "Naveen_Singh__",
                        "content": "The lowest common ancestor will be the node from where p node and q node will situated at opposite side to each other.\\ni.e lets say p.val < q.val\\nin that case\\nif(root.val >= p.val && root.val <= q.val)return root\\n(root node will be your lowest Common Ancestor)\\n\\nif p.val > q.val\\nin that case\\nif(root.val <= p.val && root.val >= q.val)return root\\n(root node will be your lowest Common Ancestor)  "
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "Connect me on Linkdin :  linkedin.com/in/ashish-madhup-640479221"
                    },
                    {
                        "username": "harshadrsharma",
                        "content": "This is an easy solution once you understand that it is a BST and that the nodes p and q are guaranteed to be present in the tree. Don\\'t understand why it\\'s tagged as a medium one."
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "Connect me on Linkdin :  linkedin.com/in/ashish-madhup-640479221"
                    },
                    {
                        "username": "just_sabyr",
                        "content": "What type are p and q exactly? In lowestCommonAncestor it\\'s defined as TreeNode and in the Testcases it\\'s int. Which one is the actual type?"
                    },
                    {
                        "username": "just_sabyr",
                        "content": "[@IvanStebletsov](/IvanStebletsov) oh, the error was that output must have been a node not an int"
                    },
                    {
                        "username": "IvanStebletsov",
                        "content": "TreeNode it\\'s an object, inside this object there is a property with its value named as \"val\", value is int."
                    }
                ]
            },
            {
                "id": 1932830,
                "content": [
                    {
                        "username": "yip1",
                        "content": "(HINT) Think of the properties of binary search! Look at the values of p and q and their placement in the tree.\\n(specifically how the placements affect our decision to traverse left or right)"
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "must visit for best solution with best explanation :\\nhttps://leetcode.com/problems/make-array-strictly-increasing/solutions/3646825/c-dynamic-programming/[leetcode]\\n\\n [@Ashish Madhup](/ashish_madhup)"
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "must visit my solutions"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "I have copy pasted my code from Question \\n**236. Lowest Common Ancestor of a Binary Tree**\\n and successfully submitted"
                    },
                    {
                        "username": "geekyshark",
                        "content": "you just unlocked clown outfit"
                    },
                    {
                        "username": "sspenst",
                        "content": "I guess it\\'s been a while since I\\'ve looked at trees, I forgot BST implies left and right are lower and greater respectively...\\n\\nMy first solution used DFS until I found both p and q while keeping track of the paths to each node, then compared the paths to see where they diverge. Obviously it becomes a lot easier if you know a BST is ordered \\uD83D\\uDE05"
                    },
                    {
                        "username": "jvpessoa10",
                        "content": "Can someone help me to understand why my solution only beats 5% of all submissions in terms of speed?\n\nI go down the tree until the nodes diverge. I assume it should be O (lg n ) Speed and O (1) Space\n\n  ```\nfun lowestCommonAncestor(root: TreeNode?, p: TreeNode?, q: TreeNode?): TreeNode? {\n\n        var ancestor: TreeNode? = null\n\n        var pCurr = root\n        var qCurr = root\n\n        while(pCurr == qCurr) {\n            ancestor = pCurr\n\n            if (p!!.`val` > pCurr!!.`val`) {\n                pCurr = pCurr?.right\n            } else if (p!!.`val` < pCurr!!.`val`) {\n                pCurr = pCurr?.left\n            }\n\n            if (q!!.`val` > qCurr!!.`val`) {\n                qCurr = qCurr?.right\n            } else if (q!!.`val` < qCurr!!.`val`) {\n                qCurr = qCurr?.left\n            }\n        }\n\n        return ancestor\n    }\n\n```\n\n"
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "Connect me on Linkdin :  linkedin.com/in/ashish-madhup-640479221"
                    },
                    {
                        "username": "toyeshingole",
                        "content": "this kinda does not make sense to me\n "
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "Connect me on Linkdin :  linkedin.com/in/ashish-madhup-640479221"
                    },
                    {
                        "username": "Naveen_Singh__",
                        "content": "The lowest common ancestor will be the node from where p node and q node will situated at opposite side to each other.\\ni.e lets say p.val < q.val\\nin that case\\nif(root.val >= p.val && root.val <= q.val)return root\\n(root node will be your lowest Common Ancestor)\\n\\nif p.val > q.val\\nin that case\\nif(root.val <= p.val && root.val >= q.val)return root\\n(root node will be your lowest Common Ancestor)  "
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "Connect me on Linkdin :  linkedin.com/in/ashish-madhup-640479221"
                    },
                    {
                        "username": "harshadrsharma",
                        "content": "This is an easy solution once you understand that it is a BST and that the nodes p and q are guaranteed to be present in the tree. Don\\'t understand why it\\'s tagged as a medium one."
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "Connect me on Linkdin :  linkedin.com/in/ashish-madhup-640479221"
                    },
                    {
                        "username": "just_sabyr",
                        "content": "What type are p and q exactly? In lowestCommonAncestor it\\'s defined as TreeNode and in the Testcases it\\'s int. Which one is the actual type?"
                    },
                    {
                        "username": "just_sabyr",
                        "content": "[@IvanStebletsov](/IvanStebletsov) oh, the error was that output must have been a node not an int"
                    },
                    {
                        "username": "IvanStebletsov",
                        "content": "TreeNode it\\'s an object, inside this object there is a property with its value named as \"val\", value is int."
                    }
                ]
            },
            {
                "id": 1902436,
                "content": [
                    {
                        "username": "yip1",
                        "content": "(HINT) Think of the properties of binary search! Look at the values of p and q and their placement in the tree.\\n(specifically how the placements affect our decision to traverse left or right)"
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "must visit for best solution with best explanation :\\nhttps://leetcode.com/problems/make-array-strictly-increasing/solutions/3646825/c-dynamic-programming/[leetcode]\\n\\n [@Ashish Madhup](/ashish_madhup)"
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "must visit my solutions"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "I have copy pasted my code from Question \\n**236. Lowest Common Ancestor of a Binary Tree**\\n and successfully submitted"
                    },
                    {
                        "username": "geekyshark",
                        "content": "you just unlocked clown outfit"
                    },
                    {
                        "username": "sspenst",
                        "content": "I guess it\\'s been a while since I\\'ve looked at trees, I forgot BST implies left and right are lower and greater respectively...\\n\\nMy first solution used DFS until I found both p and q while keeping track of the paths to each node, then compared the paths to see where they diverge. Obviously it becomes a lot easier if you know a BST is ordered \\uD83D\\uDE05"
                    },
                    {
                        "username": "jvpessoa10",
                        "content": "Can someone help me to understand why my solution only beats 5% of all submissions in terms of speed?\n\nI go down the tree until the nodes diverge. I assume it should be O (lg n ) Speed and O (1) Space\n\n  ```\nfun lowestCommonAncestor(root: TreeNode?, p: TreeNode?, q: TreeNode?): TreeNode? {\n\n        var ancestor: TreeNode? = null\n\n        var pCurr = root\n        var qCurr = root\n\n        while(pCurr == qCurr) {\n            ancestor = pCurr\n\n            if (p!!.`val` > pCurr!!.`val`) {\n                pCurr = pCurr?.right\n            } else if (p!!.`val` < pCurr!!.`val`) {\n                pCurr = pCurr?.left\n            }\n\n            if (q!!.`val` > qCurr!!.`val`) {\n                qCurr = qCurr?.right\n            } else if (q!!.`val` < qCurr!!.`val`) {\n                qCurr = qCurr?.left\n            }\n        }\n\n        return ancestor\n    }\n\n```\n\n"
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "Connect me on Linkdin :  linkedin.com/in/ashish-madhup-640479221"
                    },
                    {
                        "username": "toyeshingole",
                        "content": "this kinda does not make sense to me\n "
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "Connect me on Linkdin :  linkedin.com/in/ashish-madhup-640479221"
                    },
                    {
                        "username": "Naveen_Singh__",
                        "content": "The lowest common ancestor will be the node from where p node and q node will situated at opposite side to each other.\\ni.e lets say p.val < q.val\\nin that case\\nif(root.val >= p.val && root.val <= q.val)return root\\n(root node will be your lowest Common Ancestor)\\n\\nif p.val > q.val\\nin that case\\nif(root.val <= p.val && root.val >= q.val)return root\\n(root node will be your lowest Common Ancestor)  "
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "Connect me on Linkdin :  linkedin.com/in/ashish-madhup-640479221"
                    },
                    {
                        "username": "harshadrsharma",
                        "content": "This is an easy solution once you understand that it is a BST and that the nodes p and q are guaranteed to be present in the tree. Don\\'t understand why it\\'s tagged as a medium one."
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "Connect me on Linkdin :  linkedin.com/in/ashish-madhup-640479221"
                    },
                    {
                        "username": "just_sabyr",
                        "content": "What type are p and q exactly? In lowestCommonAncestor it\\'s defined as TreeNode and in the Testcases it\\'s int. Which one is the actual type?"
                    },
                    {
                        "username": "just_sabyr",
                        "content": "[@IvanStebletsov](/IvanStebletsov) oh, the error was that output must have been a node not an int"
                    },
                    {
                        "username": "IvanStebletsov",
                        "content": "TreeNode it\\'s an object, inside this object there is a property with its value named as \"val\", value is int."
                    }
                ]
            },
            {
                "id": 1893005,
                "content": [
                    {
                        "username": "yip1",
                        "content": "(HINT) Think of the properties of binary search! Look at the values of p and q and their placement in the tree.\\n(specifically how the placements affect our decision to traverse left or right)"
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "must visit for best solution with best explanation :\\nhttps://leetcode.com/problems/make-array-strictly-increasing/solutions/3646825/c-dynamic-programming/[leetcode]\\n\\n [@Ashish Madhup](/ashish_madhup)"
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "must visit my solutions"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "I have copy pasted my code from Question \\n**236. Lowest Common Ancestor of a Binary Tree**\\n and successfully submitted"
                    },
                    {
                        "username": "geekyshark",
                        "content": "you just unlocked clown outfit"
                    },
                    {
                        "username": "sspenst",
                        "content": "I guess it\\'s been a while since I\\'ve looked at trees, I forgot BST implies left and right are lower and greater respectively...\\n\\nMy first solution used DFS until I found both p and q while keeping track of the paths to each node, then compared the paths to see where they diverge. Obviously it becomes a lot easier if you know a BST is ordered \\uD83D\\uDE05"
                    },
                    {
                        "username": "jvpessoa10",
                        "content": "Can someone help me to understand why my solution only beats 5% of all submissions in terms of speed?\n\nI go down the tree until the nodes diverge. I assume it should be O (lg n ) Speed and O (1) Space\n\n  ```\nfun lowestCommonAncestor(root: TreeNode?, p: TreeNode?, q: TreeNode?): TreeNode? {\n\n        var ancestor: TreeNode? = null\n\n        var pCurr = root\n        var qCurr = root\n\n        while(pCurr == qCurr) {\n            ancestor = pCurr\n\n            if (p!!.`val` > pCurr!!.`val`) {\n                pCurr = pCurr?.right\n            } else if (p!!.`val` < pCurr!!.`val`) {\n                pCurr = pCurr?.left\n            }\n\n            if (q!!.`val` > qCurr!!.`val`) {\n                qCurr = qCurr?.right\n            } else if (q!!.`val` < qCurr!!.`val`) {\n                qCurr = qCurr?.left\n            }\n        }\n\n        return ancestor\n    }\n\n```\n\n"
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "Connect me on Linkdin :  linkedin.com/in/ashish-madhup-640479221"
                    },
                    {
                        "username": "toyeshingole",
                        "content": "this kinda does not make sense to me\n "
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "Connect me on Linkdin :  linkedin.com/in/ashish-madhup-640479221"
                    },
                    {
                        "username": "Naveen_Singh__",
                        "content": "The lowest common ancestor will be the node from where p node and q node will situated at opposite side to each other.\\ni.e lets say p.val < q.val\\nin that case\\nif(root.val >= p.val && root.val <= q.val)return root\\n(root node will be your lowest Common Ancestor)\\n\\nif p.val > q.val\\nin that case\\nif(root.val <= p.val && root.val >= q.val)return root\\n(root node will be your lowest Common Ancestor)  "
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "Connect me on Linkdin :  linkedin.com/in/ashish-madhup-640479221"
                    },
                    {
                        "username": "harshadrsharma",
                        "content": "This is an easy solution once you understand that it is a BST and that the nodes p and q are guaranteed to be present in the tree. Don\\'t understand why it\\'s tagged as a medium one."
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "Connect me on Linkdin :  linkedin.com/in/ashish-madhup-640479221"
                    },
                    {
                        "username": "just_sabyr",
                        "content": "What type are p and q exactly? In lowestCommonAncestor it\\'s defined as TreeNode and in the Testcases it\\'s int. Which one is the actual type?"
                    },
                    {
                        "username": "just_sabyr",
                        "content": "[@IvanStebletsov](/IvanStebletsov) oh, the error was that output must have been a node not an int"
                    },
                    {
                        "username": "IvanStebletsov",
                        "content": "TreeNode it\\'s an object, inside this object there is a property with its value named as \"val\", value is int."
                    }
                ]
            },
            {
                "id": 1871112,
                "content": [
                    {
                        "username": "yip1",
                        "content": "(HINT) Think of the properties of binary search! Look at the values of p and q and their placement in the tree.\\n(specifically how the placements affect our decision to traverse left or right)"
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "must visit for best solution with best explanation :\\nhttps://leetcode.com/problems/make-array-strictly-increasing/solutions/3646825/c-dynamic-programming/[leetcode]\\n\\n [@Ashish Madhup](/ashish_madhup)"
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "must visit my solutions"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "I have copy pasted my code from Question \\n**236. Lowest Common Ancestor of a Binary Tree**\\n and successfully submitted"
                    },
                    {
                        "username": "geekyshark",
                        "content": "you just unlocked clown outfit"
                    },
                    {
                        "username": "sspenst",
                        "content": "I guess it\\'s been a while since I\\'ve looked at trees, I forgot BST implies left and right are lower and greater respectively...\\n\\nMy first solution used DFS until I found both p and q while keeping track of the paths to each node, then compared the paths to see where they diverge. Obviously it becomes a lot easier if you know a BST is ordered \\uD83D\\uDE05"
                    },
                    {
                        "username": "jvpessoa10",
                        "content": "Can someone help me to understand why my solution only beats 5% of all submissions in terms of speed?\n\nI go down the tree until the nodes diverge. I assume it should be O (lg n ) Speed and O (1) Space\n\n  ```\nfun lowestCommonAncestor(root: TreeNode?, p: TreeNode?, q: TreeNode?): TreeNode? {\n\n        var ancestor: TreeNode? = null\n\n        var pCurr = root\n        var qCurr = root\n\n        while(pCurr == qCurr) {\n            ancestor = pCurr\n\n            if (p!!.`val` > pCurr!!.`val`) {\n                pCurr = pCurr?.right\n            } else if (p!!.`val` < pCurr!!.`val`) {\n                pCurr = pCurr?.left\n            }\n\n            if (q!!.`val` > qCurr!!.`val`) {\n                qCurr = qCurr?.right\n            } else if (q!!.`val` < qCurr!!.`val`) {\n                qCurr = qCurr?.left\n            }\n        }\n\n        return ancestor\n    }\n\n```\n\n"
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "Connect me on Linkdin :  linkedin.com/in/ashish-madhup-640479221"
                    },
                    {
                        "username": "toyeshingole",
                        "content": "this kinda does not make sense to me\n "
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "Connect me on Linkdin :  linkedin.com/in/ashish-madhup-640479221"
                    },
                    {
                        "username": "Naveen_Singh__",
                        "content": "The lowest common ancestor will be the node from where p node and q node will situated at opposite side to each other.\\ni.e lets say p.val < q.val\\nin that case\\nif(root.val >= p.val && root.val <= q.val)return root\\n(root node will be your lowest Common Ancestor)\\n\\nif p.val > q.val\\nin that case\\nif(root.val <= p.val && root.val >= q.val)return root\\n(root node will be your lowest Common Ancestor)  "
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "Connect me on Linkdin :  linkedin.com/in/ashish-madhup-640479221"
                    },
                    {
                        "username": "harshadrsharma",
                        "content": "This is an easy solution once you understand that it is a BST and that the nodes p and q are guaranteed to be present in the tree. Don\\'t understand why it\\'s tagged as a medium one."
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "Connect me on Linkdin :  linkedin.com/in/ashish-madhup-640479221"
                    },
                    {
                        "username": "just_sabyr",
                        "content": "What type are p and q exactly? In lowestCommonAncestor it\\'s defined as TreeNode and in the Testcases it\\'s int. Which one is the actual type?"
                    },
                    {
                        "username": "just_sabyr",
                        "content": "[@IvanStebletsov](/IvanStebletsov) oh, the error was that output must have been a node not an int"
                    },
                    {
                        "username": "IvanStebletsov",
                        "content": "TreeNode it\\'s an object, inside this object there is a property with its value named as \"val\", value is int."
                    }
                ]
            },
            {
                "id": 1844131,
                "content": [
                    {
                        "username": "yip1",
                        "content": "(HINT) Think of the properties of binary search! Look at the values of p and q and their placement in the tree.\\n(specifically how the placements affect our decision to traverse left or right)"
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "must visit for best solution with best explanation :\\nhttps://leetcode.com/problems/make-array-strictly-increasing/solutions/3646825/c-dynamic-programming/[leetcode]\\n\\n [@Ashish Madhup](/ashish_madhup)"
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "must visit my solutions"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "I have copy pasted my code from Question \\n**236. Lowest Common Ancestor of a Binary Tree**\\n and successfully submitted"
                    },
                    {
                        "username": "geekyshark",
                        "content": "you just unlocked clown outfit"
                    },
                    {
                        "username": "sspenst",
                        "content": "I guess it\\'s been a while since I\\'ve looked at trees, I forgot BST implies left and right are lower and greater respectively...\\n\\nMy first solution used DFS until I found both p and q while keeping track of the paths to each node, then compared the paths to see where they diverge. Obviously it becomes a lot easier if you know a BST is ordered \\uD83D\\uDE05"
                    },
                    {
                        "username": "jvpessoa10",
                        "content": "Can someone help me to understand why my solution only beats 5% of all submissions in terms of speed?\n\nI go down the tree until the nodes diverge. I assume it should be O (lg n ) Speed and O (1) Space\n\n  ```\nfun lowestCommonAncestor(root: TreeNode?, p: TreeNode?, q: TreeNode?): TreeNode? {\n\n        var ancestor: TreeNode? = null\n\n        var pCurr = root\n        var qCurr = root\n\n        while(pCurr == qCurr) {\n            ancestor = pCurr\n\n            if (p!!.`val` > pCurr!!.`val`) {\n                pCurr = pCurr?.right\n            } else if (p!!.`val` < pCurr!!.`val`) {\n                pCurr = pCurr?.left\n            }\n\n            if (q!!.`val` > qCurr!!.`val`) {\n                qCurr = qCurr?.right\n            } else if (q!!.`val` < qCurr!!.`val`) {\n                qCurr = qCurr?.left\n            }\n        }\n\n        return ancestor\n    }\n\n```\n\n"
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "Connect me on Linkdin :  linkedin.com/in/ashish-madhup-640479221"
                    },
                    {
                        "username": "toyeshingole",
                        "content": "this kinda does not make sense to me\n "
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "Connect me on Linkdin :  linkedin.com/in/ashish-madhup-640479221"
                    },
                    {
                        "username": "Naveen_Singh__",
                        "content": "The lowest common ancestor will be the node from where p node and q node will situated at opposite side to each other.\\ni.e lets say p.val < q.val\\nin that case\\nif(root.val >= p.val && root.val <= q.val)return root\\n(root node will be your lowest Common Ancestor)\\n\\nif p.val > q.val\\nin that case\\nif(root.val <= p.val && root.val >= q.val)return root\\n(root node will be your lowest Common Ancestor)  "
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "Connect me on Linkdin :  linkedin.com/in/ashish-madhup-640479221"
                    },
                    {
                        "username": "harshadrsharma",
                        "content": "This is an easy solution once you understand that it is a BST and that the nodes p and q are guaranteed to be present in the tree. Don\\'t understand why it\\'s tagged as a medium one."
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "Connect me on Linkdin :  linkedin.com/in/ashish-madhup-640479221"
                    },
                    {
                        "username": "just_sabyr",
                        "content": "What type are p and q exactly? In lowestCommonAncestor it\\'s defined as TreeNode and in the Testcases it\\'s int. Which one is the actual type?"
                    },
                    {
                        "username": "just_sabyr",
                        "content": "[@IvanStebletsov](/IvanStebletsov) oh, the error was that output must have been a node not an int"
                    },
                    {
                        "username": "IvanStebletsov",
                        "content": "TreeNode it\\'s an object, inside this object there is a property with its value named as \"val\", value is int."
                    }
                ]
            },
            {
                "id": 1837413,
                "content": [
                    {
                        "username": "yip1",
                        "content": "(HINT) Think of the properties of binary search! Look at the values of p and q and their placement in the tree.\\n(specifically how the placements affect our decision to traverse left or right)"
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "must visit for best solution with best explanation :\\nhttps://leetcode.com/problems/make-array-strictly-increasing/solutions/3646825/c-dynamic-programming/[leetcode]\\n\\n [@Ashish Madhup](/ashish_madhup)"
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "must visit my solutions"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "I have copy pasted my code from Question \\n**236. Lowest Common Ancestor of a Binary Tree**\\n and successfully submitted"
                    },
                    {
                        "username": "geekyshark",
                        "content": "you just unlocked clown outfit"
                    },
                    {
                        "username": "sspenst",
                        "content": "I guess it\\'s been a while since I\\'ve looked at trees, I forgot BST implies left and right are lower and greater respectively...\\n\\nMy first solution used DFS until I found both p and q while keeping track of the paths to each node, then compared the paths to see where they diverge. Obviously it becomes a lot easier if you know a BST is ordered \\uD83D\\uDE05"
                    },
                    {
                        "username": "jvpessoa10",
                        "content": "Can someone help me to understand why my solution only beats 5% of all submissions in terms of speed?\n\nI go down the tree until the nodes diverge. I assume it should be O (lg n ) Speed and O (1) Space\n\n  ```\nfun lowestCommonAncestor(root: TreeNode?, p: TreeNode?, q: TreeNode?): TreeNode? {\n\n        var ancestor: TreeNode? = null\n\n        var pCurr = root\n        var qCurr = root\n\n        while(pCurr == qCurr) {\n            ancestor = pCurr\n\n            if (p!!.`val` > pCurr!!.`val`) {\n                pCurr = pCurr?.right\n            } else if (p!!.`val` < pCurr!!.`val`) {\n                pCurr = pCurr?.left\n            }\n\n            if (q!!.`val` > qCurr!!.`val`) {\n                qCurr = qCurr?.right\n            } else if (q!!.`val` < qCurr!!.`val`) {\n                qCurr = qCurr?.left\n            }\n        }\n\n        return ancestor\n    }\n\n```\n\n"
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "Connect me on Linkdin :  linkedin.com/in/ashish-madhup-640479221"
                    },
                    {
                        "username": "toyeshingole",
                        "content": "this kinda does not make sense to me\n "
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "Connect me on Linkdin :  linkedin.com/in/ashish-madhup-640479221"
                    },
                    {
                        "username": "Naveen_Singh__",
                        "content": "The lowest common ancestor will be the node from where p node and q node will situated at opposite side to each other.\\ni.e lets say p.val < q.val\\nin that case\\nif(root.val >= p.val && root.val <= q.val)return root\\n(root node will be your lowest Common Ancestor)\\n\\nif p.val > q.val\\nin that case\\nif(root.val <= p.val && root.val >= q.val)return root\\n(root node will be your lowest Common Ancestor)  "
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "Connect me on Linkdin :  linkedin.com/in/ashish-madhup-640479221"
                    },
                    {
                        "username": "harshadrsharma",
                        "content": "This is an easy solution once you understand that it is a BST and that the nodes p and q are guaranteed to be present in the tree. Don\\'t understand why it\\'s tagged as a medium one."
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "Connect me on Linkdin :  linkedin.com/in/ashish-madhup-640479221"
                    },
                    {
                        "username": "just_sabyr",
                        "content": "What type are p and q exactly? In lowestCommonAncestor it\\'s defined as TreeNode and in the Testcases it\\'s int. Which one is the actual type?"
                    },
                    {
                        "username": "just_sabyr",
                        "content": "[@IvanStebletsov](/IvanStebletsov) oh, the error was that output must have been a node not an int"
                    },
                    {
                        "username": "IvanStebletsov",
                        "content": "TreeNode it\\'s an object, inside this object there is a property with its value named as \"val\", value is int."
                    }
                ]
            },
            {
                "id": 1799306,
                "content": [
                    {
                        "username": "yip1",
                        "content": "(HINT) Think of the properties of binary search! Look at the values of p and q and their placement in the tree.\\n(specifically how the placements affect our decision to traverse left or right)"
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "must visit for best solution with best explanation :\\nhttps://leetcode.com/problems/make-array-strictly-increasing/solutions/3646825/c-dynamic-programming/[leetcode]\\n\\n [@Ashish Madhup](/ashish_madhup)"
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "must visit my solutions"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "I have copy pasted my code from Question \\n**236. Lowest Common Ancestor of a Binary Tree**\\n and successfully submitted"
                    },
                    {
                        "username": "geekyshark",
                        "content": "you just unlocked clown outfit"
                    },
                    {
                        "username": "sspenst",
                        "content": "I guess it\\'s been a while since I\\'ve looked at trees, I forgot BST implies left and right are lower and greater respectively...\\n\\nMy first solution used DFS until I found both p and q while keeping track of the paths to each node, then compared the paths to see where they diverge. Obviously it becomes a lot easier if you know a BST is ordered \\uD83D\\uDE05"
                    },
                    {
                        "username": "jvpessoa10",
                        "content": "Can someone help me to understand why my solution only beats 5% of all submissions in terms of speed?\n\nI go down the tree until the nodes diverge. I assume it should be O (lg n ) Speed and O (1) Space\n\n  ```\nfun lowestCommonAncestor(root: TreeNode?, p: TreeNode?, q: TreeNode?): TreeNode? {\n\n        var ancestor: TreeNode? = null\n\n        var pCurr = root\n        var qCurr = root\n\n        while(pCurr == qCurr) {\n            ancestor = pCurr\n\n            if (p!!.`val` > pCurr!!.`val`) {\n                pCurr = pCurr?.right\n            } else if (p!!.`val` < pCurr!!.`val`) {\n                pCurr = pCurr?.left\n            }\n\n            if (q!!.`val` > qCurr!!.`val`) {\n                qCurr = qCurr?.right\n            } else if (q!!.`val` < qCurr!!.`val`) {\n                qCurr = qCurr?.left\n            }\n        }\n\n        return ancestor\n    }\n\n```\n\n"
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "Connect me on Linkdin :  linkedin.com/in/ashish-madhup-640479221"
                    },
                    {
                        "username": "toyeshingole",
                        "content": "this kinda does not make sense to me\n "
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "Connect me on Linkdin :  linkedin.com/in/ashish-madhup-640479221"
                    },
                    {
                        "username": "Naveen_Singh__",
                        "content": "The lowest common ancestor will be the node from where p node and q node will situated at opposite side to each other.\\ni.e lets say p.val < q.val\\nin that case\\nif(root.val >= p.val && root.val <= q.val)return root\\n(root node will be your lowest Common Ancestor)\\n\\nif p.val > q.val\\nin that case\\nif(root.val <= p.val && root.val >= q.val)return root\\n(root node will be your lowest Common Ancestor)  "
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "Connect me on Linkdin :  linkedin.com/in/ashish-madhup-640479221"
                    },
                    {
                        "username": "harshadrsharma",
                        "content": "This is an easy solution once you understand that it is a BST and that the nodes p and q are guaranteed to be present in the tree. Don\\'t understand why it\\'s tagged as a medium one."
                    },
                    {
                        "username": "ashish_madhup",
                        "content": "Connect me on Linkdin :  linkedin.com/in/ashish-madhup-640479221"
                    },
                    {
                        "username": "just_sabyr",
                        "content": "What type are p and q exactly? In lowestCommonAncestor it\\'s defined as TreeNode and in the Testcases it\\'s int. Which one is the actual type?"
                    },
                    {
                        "username": "just_sabyr",
                        "content": "[@IvanStebletsov](/IvanStebletsov) oh, the error was that output must have been a node not an int"
                    },
                    {
                        "username": "IvanStebletsov",
                        "content": "TreeNode it\\'s an object, inside this object there is a property with its value named as \"val\", value is int."
                    }
                ]
            }
        ]
    }
]