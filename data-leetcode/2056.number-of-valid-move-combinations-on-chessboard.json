[
    {
        "title": "Number of Valid Move Combinations On Chessboard",
        "question_content": "There is an 8 x 8 chessboard containing n pieces (rooks, queens, or bishops). You are given a string array pieces of length n, where pieces[i] describes the type (rook, queen, or bishop) of the ith piece. In addition, you are given a 2D integer array positions also of length n, where positions[i] = [ri, ci] indicates that the ith piece is currently at the 1-based coordinate (ri, ci) on the chessboard.\nWhen making a move for a piece, you choose a destination square that the piece will travel toward and stop on.\n\n\tA rook can only travel horizontally or vertically from (r, c) to the direction of (r+1, c), (r-1, c), (r, c+1), or (r, c-1).\n\tA queen can only travel horizontally, vertically, or diagonally from (r, c) to the direction of (r+1, c), (r-1, c), (r, c+1), (r, c-1), (r+1, c+1), (r+1, c-1), (r-1, c+1), (r-1, c-1).\n\tA bishop can only travel diagonally from (r, c) to the direction of (r+1, c+1), (r+1, c-1), (r-1, c+1), (r-1, c-1).\n\nYou must make a move for every piece on the board simultaneously. A move combination consists of all the moves performed on all the given pieces. Every second, each piece will instantaneously travel one square towards their destination if they are not already at it. All pieces start traveling at the 0th second. A move combination is invalid if, at a given time, two or more pieces occupy the same square.\nReturn the number of valid move combinations​​​​​.\nNotes:\n\n\tNo two pieces will start in the same square.\n\tYou may choose the square a piece is already on as its destination.\n\tIf two pieces are directly adjacent to each other, it is valid for them to move past each other and swap positions in one second.\n\n&nbsp;\nExample 1:\n\nInput: pieces = [\"rook\"], positions = [[1,1]]\nOutput: 15\nExplanation: The image above shows the possible squares the piece can move to.\n\nExample 2:\n\nInput: pieces = [\"queen\"], positions = [[1,1]]\nOutput: 22\nExplanation: The image above shows the possible squares the piece can move to.\n\nExample 3:\n\nInput: pieces = [\"bishop\"], positions = [[4,3]]\nOutput: 12\nExplanation: The image above shows the possible squares the piece can move to.\n\n&nbsp;\nConstraints:\n\n\tn == pieces.length \n\tn == positions.length\n\t1 <= n <= 4\n\tpieces only contains the strings \"rook\", \"queen\", and \"bishop\".\n\tThere will be at most one queen on the chessboard.\n\t1 <= xi, yi <= 8\n\tEach positions[i] is distinct.",
        "solutions": [
            {
                "id": 1549577,
                "title": "dull-and-painful",
                "content": "This is just a brute force solution with a convoluted way to generate and check combinations.\\n\\n1. For a move, we need to track both transitional and final positions.\\n\\t- For each position, we track the number of steps to get there.\\n\\t- To indicate the final position, we will use a negative number of steps.\\n2. We need to track moves independently for all pieces.\\n3. A position is `blocked` if it is:\\n\\t- a final one for another piece with smaller/same number of steps to get there, or\\n\\t- a transitional position for another piece with the same number of steps to get there.\\n4. We can stop at a position if:\\n\\t- no other pieces stopped at that position, and\\n\\t- other pieces already went through that position (transitional position with less number of steps).\\n\\n**C++**\\n```cpp\\nint dir[8][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}, {1, 1}, {1, -1}, {-1, -1}, {-1, 1}};\\nint b[4][8][8] = {};\\nint countCombinations(vector<string>& pieces, vector<vector<int>>& pos, int p = 0) {\\n    if (p >= pieces.size())\\n        return 1;\\n    int i = pos[p][0] - 1, j = pos[p][1] - 1, res = 0;\\n    for (int d = 0; d < 8; ++d) {\\n        if ((d < 4 && pieces[p] == \"bishop\" ) || (d >= 4 && pieces[p] == \"rook\"))\\n            continue;\\n        bool blocked = false;\\n        for (int step = res == 0 ? 1 : 2; !blocked; ++step) {\\n            int x = i + (step - 1) * dir[d][0], y = j + (step - 1) * dir[d][1];\\n            if (min(x, y) < 0 || max(x, y) > 7)\\n                break;\\n            bool canStop = true;\\n            for (int pp = 0; pp < p; ++pp) {\\n                canStop &= b[pp][x][y] >= 0 && b[pp][x][y] < step;\\n                blocked |= (b[pp][x][y] < 0 && -b[pp][x][y] <= step) || (b[pp][x][y] == step);\\n            }\\n            if (canStop) {\\n                b[p][x][y] = -step;\\n                res += countCombinations(pieces, pos, p + 1);\\n            }\\n            b[p][x][y] = step;\\n        }\\n        fill_n(b[p][0], 64, 0);\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint dir[8][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}, {1, 1}, {1, -1}, {-1, -1}, {-1, 1}};\\nint b[4][8][8] = {};\\nint countCombinations(vector<string>& pieces, vector<vector<int>>& pos, int p = 0) {\\n    if (p >= pieces.size())\\n        return 1;\\n    int i = pos[p][0] - 1, j = pos[p][1] - 1, res = 0;\\n    for (int d = 0; d < 8; ++d) {\\n        if ((d < 4 && pieces[p] == \"bishop\" ) || (d >= 4 && pieces[p] == \"rook\"))\\n            continue;\\n        bool blocked = false;\\n        for (int step = res == 0 ? 1 : 2; !blocked; ++step) {\\n            int x = i + (step - 1) * dir[d][0], y = j + (step - 1) * dir[d][1];\\n            if (min(x, y) < 0 || max(x, y) > 7)\\n                break;\\n            bool canStop = true;\\n            for (int pp = 0; pp < p; ++pp) {\\n                canStop &= b[pp][x][y] >= 0 && b[pp][x][y] < step;\\n                blocked |= (b[pp][x][y] < 0 && -b[pp][x][y] <= step) || (b[pp][x][y] == step);\\n            }\\n            if (canStop) {\\n                b[p][x][y] = -step;\\n                res += countCombinations(pieces, pos, p + 1);\\n            }\\n            b[p][x][y] = step;\\n        }\\n        fill_n(b[p][0], 64, 0);\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1840866,
                "title": "if-you-were-given-this-problem-during-an-actual-interview",
                "content": "```\\ndef interview()\\n\\tif you cannot provide the correct code in 30 minutes:\\n\\t\\treturn failure conditionless\\n\\telif provided bug free code in 30 minutes:\\n\\t\\treturn failure because \"we don\\'t hire persons who memorize solutions\"\\n\\telif provided some code seems to work:\\n\\t\\treturn failure because your code cannot pass some testcases\\n\\telif your code passed all testcases\\n\\t\\treturn failure because your coding style is horrible because there are no clear comments\\n\\telif your code seems work and commented well\\n\\t\\treturn failure because we didn\\'t see strong signals on your creativity\\n\\telse\\n\\t\\treturn failure with whatever excuse\\n\\treturn failure anyway without excuse, even this line never get executed\\n```",
                "solutionTags": [],
                "code": "```\\ndef interview()\\n\\tif you cannot provide the correct code in 30 minutes:\\n\\t\\treturn failure conditionless\\n\\telif provided bug free code in 30 minutes:\\n\\t\\treturn failure because \"we don\\'t hire persons who memorize solutions\"\\n\\telif provided some code seems to work:\\n\\t\\treturn failure because your code cannot pass some testcases\\n\\telif your code passed all testcases\\n\\t\\treturn failure because your coding style is horrible because there are no clear comments\\n\\telif your code seems work and commented well\\n\\t\\treturn failure because we didn\\'t see strong signals on your creativity\\n\\telse\\n\\t\\treturn failure with whatever excuse\\n\\treturn failure anyway without excuse, even this line never get executed\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1549108,
                "title": "python-short-solution-explained",
                "content": "The idea is to use bruteforce: simulate our process and check all possibilities, but do it carefully. \\n\\n1. First we need to choose direction where each figure will move, it is kept in `dirs` tuple of pairs.\\n2. Also we have `stopped_mask` variable, which is to understand if we stopped or not. For example `101` mask will mean that we stopped on the second figure and did not stop on first and third.\\n3. When we do one step, we need to decide where we continue and where we are not. For example if we have mask `101`, then we have `4` options: we can continue move for first and third figure, we can stop on one of them or stop on both.\\n4. Also we need to deal with cases when two figures are on the same place and that we did not reach out of board.\\n\\n#### Complexity\\nTime complexity is `O(29^4)` for the case of 4 queens, space complexity is `O(1)`.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def countCombinations(self, pieces, positions):\\n        positions = [tuple(x) for x in positions]\\n        self.ans = set()\\n\\n        def dfs(pos, dirs, stopped_mask):   \\n            if stopped_mask == 0: return\\n            self.ans.add(tuple(pos))\\n            for active in range(1<<len(dirs)):\\n                if stopped_mask & active != active: continue\\n                new_pos = list(pos)\\n                new_mask = stopped_mask ^ active\\n\\n                for i in range(len(new_pos)):\\n                    new_pos[i] = (new_pos[i][0] + dirs[i][0]*((new_mask>>i)&1), new_pos[i][1] + dirs[i][1]*((new_mask>>i)&1))\\n\\n                if len(Counter(new_pos)) < len(dirs): continue\\n                all_c = list(chain(*new_pos))\\n                if min(all_c) <= 0 or max(all_c) > 8: continue\\n                dfs(new_pos, dirs, new_mask)\\n\\n        poss = {}\\n        poss[\"rook\"] = ((1, 0), (-1, 0), (0, 1), (0, -1))\\n        poss[\"bishop\"] = ((1, 1), (1, -1), (-1, 1), (-1, -1))\\n        poss[\"queen\"] = ((1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (1, -1), (-1, 1), (-1, -1))\\n\\n        for dirs in product(*(poss[i] for i in pieces)):\\n            dfs(positions, dirs, (1<<len(pieces)) - 1)\\n\\n        return len(self.ans)\\n```\\n\\nIf you have any questoins, feel free to ask. If you like the solution and explanation, please **upvote!**",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def countCombinations(self, pieces, positions):\\n        positions = [tuple(x) for x in positions]\\n        self.ans = set()\\n\\n        def dfs(pos, dirs, stopped_mask):   \\n            if stopped_mask == 0: return\\n            self.ans.add(tuple(pos))\\n            for active in range(1<<len(dirs)):\\n                if stopped_mask & active != active: continue\\n                new_pos = list(pos)\\n                new_mask = stopped_mask ^ active\\n\\n                for i in range(len(new_pos)):\\n                    new_pos[i] = (new_pos[i][0] + dirs[i][0]*((new_mask>>i)&1), new_pos[i][1] + dirs[i][1]*((new_mask>>i)&1))\\n\\n                if len(Counter(new_pos)) < len(dirs): continue\\n                all_c = list(chain(*new_pos))\\n                if min(all_c) <= 0 or max(all_c) > 8: continue\\n                dfs(new_pos, dirs, new_mask)\\n\\n        poss = {}\\n        poss[\"rook\"] = ((1, 0), (-1, 0), (0, 1), (0, -1))\\n        poss[\"bishop\"] = ((1, 1), (1, -1), (-1, 1), (-1, -1))\\n        poss[\"queen\"] = ((1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (1, -1), (-1, 1), (-1, -1))\\n\\n        for dirs in product(*(poss[i] for i in pieces)):\\n            dfs(positions, dirs, (1<<len(pieces)) - 1)\\n\\n        return len(self.ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1549465,
                "title": "if-you-are-confused-by-the-description",
                "content": "Let me rephraes:\\n\\nThere are at max 4 chess pieces on the board, each chess piece pick one of its final destinations based on rules. Then each chess piece will instantaneously move to its final destination one cell at a time, each move takes one second. During this process, no two pieces can be in the same position on any second. How many possible chess board state are valid at the end?\\n\\nHopefully you understand what \"If two pieces are directly adjacent to each other, it is valid for them to move past each other and swap positions in one second.\" means now.\\n\\nQueen have around 32 final destinations. \\nBishop and Rook has ~16.\\n\\nSo we have 32 * 16 * 16 * 16 = 131,072 state.\\n\\nDFS, for every new destination, check will it clash with any previous peices. If we can place all peices, we find an answer.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>> dirsB = {{1, 1},  {-1, 1},  {1, -1}, {-1, -1}};\\n    vector<vector<int>> dirsR = {{0, 1},  {0, -1},  {1, 0}, {-1, 0}};\\n    \\n    bool isValid(int x, int y) {\\n        if (x < 0 || y < 0 || x >= 8 || y >= 8) \\n            return false;\\n        \\n        return true;\\n    }\\n    \\n    void fill(int i, vector<vector<vector<int>>> & moves, int x, int y, vector<vector<int>> & dirs) {\\n         for (int k = 0; k < 4; k++) {\\n            auto & dir = dirs[k];\\n            int ii = x + dir[0], jj = y + dir[1];\\n            int t = 1;\\n            while (isValid(ii, jj)) {\\n                moves[i].push_back({dir[0], dir[1], t}); // store the x y dir and how long it took to get its final destination.\\n                \\n                ii += dir[0];\\n                jj += dir[1];\\n                t++;\\n            }\\n        }\\n    }\\n    \\n    bool check(vector<int> pos1, vector<int> & nPos1, vector<int> pos2, vector<int> & nPos2) {\\n        // simulation, move two pieces, check if they clash for every second\\n        int t1 = nPos1.back(), t2 = nPos2.back();\\n        for (int i = 1; i <= max(t1, t2); i++) {\\n            if (i <= t1) {\\n                pos1[0] += nPos1[0];\\n                pos1[1] += nPos1[1];\\n            }\\n            \\n            if (i <= t2) {\\n                pos2[0] += nPos2[0];\\n                pos2[1] += nPos2[1];\\n            }\\n            \\n            if (pos1 == pos2)\\n                return false;\\n        }\\n        return true;\\n    }\\n    \\n    void dfs(int curr, vector<vector<int>> & newPos, vector<vector<int>>& pos, vector<vector<vector<int>>> & moves, int & ans) {\\n        if (curr >= moves.size()) {\\n            ans++;\\n            return;\\n        } \\n        \\n        for (auto & move : moves[curr]) {\\n            bool ok = true;\\n            for (int i = 0; i < newPos.size(); i++) {\\n                if (!check(pos[i], newPos[i], pos[curr], move)) {\\n                    ok = false;\\n                    break;\\n                }\\n            }\\n            \\n            if (!ok) {\\n                continue;\\n            }\\n            newPos.push_back(move);\\n            dfs(curr+1, newPos, pos, moves, ans);\\n            newPos.pop_back();\\n        }\\n    }\\n    \\n    int countCombinations(vector<string>& pieces, vector<vector<int>>& pos) {\\n        int n = pieces.size();\\n        vector<vector<vector<int>>> moves(n);\\n        \\n        for (auto & p : pos) {\\n            p[0]--;\\n            p[1]--;\\n        }\\n        \\n        for (int i = 0; i < n; i++) {\\n            int x = pos[i][0], y = pos[i][1];\\n            moves[i].push_back({0, 0, 0});\\n            if (pieces[i] == \"rook\") {\\n                fill(i, moves, x, y, dirsR);\\n            } else if (pieces[i] == \"bishop\") {\\n                fill(i, moves, x, y, dirsB);\\n            } else {\\n                fill(i, moves, x, y, dirsB);\\n                fill(i, moves, x, y, dirsR);\\n            }\\n        }\\n        vector<vector<int>> newPos;\\n        int ans = 0;\\n        dfs(0, newPos, pos, moves, ans);\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>> dirsB = {{1, 1},  {-1, 1},  {1, -1}, {-1, -1}};\\n    vector<vector<int>> dirsR = {{0, 1},  {0, -1},  {1, 0}, {-1, 0}};\\n    \\n    bool isValid(int x, int y) {\\n        if (x < 0 || y < 0 || x >= 8 || y >= 8) \\n            return false;\\n        \\n        return true;\\n    }\\n    \\n    void fill(int i, vector<vector<vector<int>>> & moves, int x, int y, vector<vector<int>> & dirs) {\\n         for (int k = 0; k < 4; k++) {\\n            auto & dir = dirs[k];\\n            int ii = x + dir[0], jj = y + dir[1];\\n            int t = 1;\\n            while (isValid(ii, jj)) {\\n                moves[i].push_back({dir[0], dir[1], t}); // store the x y dir and how long it took to get its final destination.\\n                \\n                ii += dir[0];\\n                jj += dir[1];\\n                t++;\\n            }\\n        }\\n    }\\n    \\n    bool check(vector<int> pos1, vector<int> & nPos1, vector<int> pos2, vector<int> & nPos2) {\\n        // simulation, move two pieces, check if they clash for every second\\n        int t1 = nPos1.back(), t2 = nPos2.back();\\n        for (int i = 1; i <= max(t1, t2); i++) {\\n            if (i <= t1) {\\n                pos1[0] += nPos1[0];\\n                pos1[1] += nPos1[1];\\n            }\\n            \\n            if (i <= t2) {\\n                pos2[0] += nPos2[0];\\n                pos2[1] += nPos2[1];\\n            }\\n            \\n            if (pos1 == pos2)\\n                return false;\\n        }\\n        return true;\\n    }\\n    \\n    void dfs(int curr, vector<vector<int>> & newPos, vector<vector<int>>& pos, vector<vector<vector<int>>> & moves, int & ans) {\\n        if (curr >= moves.size()) {\\n            ans++;\\n            return;\\n        } \\n        \\n        for (auto & move : moves[curr]) {\\n            bool ok = true;\\n            for (int i = 0; i < newPos.size(); i++) {\\n                if (!check(pos[i], newPos[i], pos[curr], move)) {\\n                    ok = false;\\n                    break;\\n                }\\n            }\\n            \\n            if (!ok) {\\n                continue;\\n            }\\n            newPos.push_back(move);\\n            dfs(curr+1, newPos, pos, moves, ans);\\n            newPos.pop_back();\\n        }\\n    }\\n    \\n    int countCombinations(vector<string>& pieces, vector<vector<int>>& pos) {\\n        int n = pieces.size();\\n        vector<vector<vector<int>>> moves(n);\\n        \\n        for (auto & p : pos) {\\n            p[0]--;\\n            p[1]--;\\n        }\\n        \\n        for (int i = 0; i < n; i++) {\\n            int x = pos[i][0], y = pos[i][1];\\n            moves[i].push_back({0, 0, 0});\\n            if (pieces[i] == \"rook\") {\\n                fill(i, moves, x, y, dirsR);\\n            } else if (pieces[i] == \"bishop\") {\\n                fill(i, moves, x, y, dirsB);\\n            } else {\\n                fill(i, moves, x, y, dirsB);\\n                fill(i, moves, x, y, dirsR);\\n            }\\n        }\\n        vector<vector<int>> newPos;\\n        int ans = 0;\\n        dfs(0, newPos, pos, moves, ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1549099,
                "title": "python-constant-time-check-for-each-piece",
                "content": "With the constraints of 4 pieces and 1 queen among them at most, the answer is at most 15 ** 3 * 28 = 94500 (3 rooks + 1 queen near the center). Using a set for each square to check for the presence of a piece at time t and maintain the desired state with constant time O(length of the chess board).\\n\\n```\\nclass Solution:\\n    def countCombinations(self, pieces: List[str], positions: List[List[int]]) -> int:\\n        board = [[set() for _ in range(8)] for _ in range(8)]\\n        n = len(pieces)\\n        for pos in positions:\\n            pos[0] -= 1\\n            pos[1] -= 1\\n        all_time = set(range(1, 8))\\n        def recur(i):\\n            if i == n:\\n                return 1\\n            ans = 0\\n            line = [(0, 1), (1, 0), (0, -1), (-1, 0)]\\n            diag = [(1, 1), (1, -1), (-1, 1), (-1, -1)]\\n            r, c = positions[i]\\n            if not board[r][c] & all_time:\\n                board[r][c] |= all_time\\n                ans += recur(i + 1)\\n                board[r][c].clear()\\n            directions = []\\n            if pieces[i] in (\"queen\", \"rook\"):\\n                directions.extend(line)\\n            if pieces[i] in (\"queen\", \"bishop\"):\\n                directions.extend(diag)                \\n            for dr, dc in directions:\\n                x, y = r + dr, c + dc\\n                count = 1\\n                while 0 <= x < 8 and 0 <= y < 8 and count not in board[x][y]:\\n                    board[x][y].add(count)\\n                    count += 1\\n                    rest = set(range(count, 8))\\n                    if not board[x][y] & rest:\\n                        board[x][y] |= rest\\n                        ans += recur(i + 1)\\n                        board[x][y] -= rest\\n                    x += dr\\n                    y += dc\\n                count -= 1\\n                x -= dr\\n                y -= dc\\n                while count:\\n                    board[x][y].remove(count)\\n                    count -= 1\\n                    x -= dr\\n                    y -= dc\\n            return ans\\n        return recur(0)\\n```\\n\\nThe bit mask version is even faster as it completely hides the constant factor of 8, but both easily get AC (530 ms vs. 236 ms).\\n```\\nclass Solution:\\n    def countCombinations(self, pieces: List[str], positions: List[List[int]]) -> int:\\n        board = [[0] * 8 for _ in range(8)]\\n        n = len(pieces)\\n        for pos in positions:\\n            pos[0] -= 1\\n            pos[1] -= 1\\n        all_time = 2 ** 7 - 1\\n        def recur(i):\\n            if i == n:\\n                return 1\\n            ans = 0\\n            line = [(0, 1), (1, 0), (0, -1), (-1, 0)]\\n            diag = [(1, 1), (1, -1), (-1, 1), (-1, -1)]\\n            r, c = positions[i]\\n            if not board[r][c]:\\n                board[r][c] |= all_time\\n                ans += recur(i + 1)\\n                board[r][c] -= all_time\\n            directions = []\\n            if pieces[i] in (\"queen\", \"rook\"):\\n                directions.extend(line)\\n            if pieces[i] in (\"queen\", \"bishop\"):\\n                directions.extend(diag)                \\n            for dr, dc in directions:\\n                x, y = r + dr, c + dc\\n                bit = 1\\n                rest = all_time\\n                while 0 <= x < 8 and 0 <= y < 8 and not bit & board[x][y]:\\n                    board[x][y] |= bit\\n                    rest -= bit\\n                    bit <<= 1\\n                    if not board[x][y] & rest:\\n                        board[x][y] |= rest\\n                        ans += recur(i + 1)\\n                        board[x][y] -= rest\\n                    x += dr\\n                    y += dc\\n                bit >>= 1\\n                x -= dr\\n                y -= dc\\n                while bit:\\n                    board[x][y] -= bit\\n                    bit >>= 1\\n                    x -= dr\\n                    y -= dc\\n            return ans\\n        return recur(0)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def countCombinations(self, pieces: List[str], positions: List[List[int]]) -> int:\\n        board = [[set() for _ in range(8)] for _ in range(8)]\\n        n = len(pieces)\\n        for pos in positions:\\n            pos[0] -= 1\\n            pos[1] -= 1\\n        all_time = set(range(1, 8))\\n        def recur(i):\\n            if i == n:\\n                return 1\\n            ans = 0\\n            line = [(0, 1), (1, 0), (0, -1), (-1, 0)]\\n            diag = [(1, 1), (1, -1), (-1, 1), (-1, -1)]\\n            r, c = positions[i]\\n            if not board[r][c] & all_time:\\n                board[r][c] |= all_time\\n                ans += recur(i + 1)\\n                board[r][c].clear()\\n            directions = []\\n            if pieces[i] in (\"queen\", \"rook\"):\\n                directions.extend(line)\\n            if pieces[i] in (\"queen\", \"bishop\"):\\n                directions.extend(diag)                \\n            for dr, dc in directions:\\n                x, y = r + dr, c + dc\\n                count = 1\\n                while 0 <= x < 8 and 0 <= y < 8 and count not in board[x][y]:\\n                    board[x][y].add(count)\\n                    count += 1\\n                    rest = set(range(count, 8))\\n                    if not board[x][y] & rest:\\n                        board[x][y] |= rest\\n                        ans += recur(i + 1)\\n                        board[x][y] -= rest\\n                    x += dr\\n                    y += dc\\n                count -= 1\\n                x -= dr\\n                y -= dc\\n                while count:\\n                    board[x][y].remove(count)\\n                    count -= 1\\n                    x -= dr\\n                    y -= dc\\n            return ans\\n        return recur(0)\\n```\n```\\nclass Solution:\\n    def countCombinations(self, pieces: List[str], positions: List[List[int]]) -> int:\\n        board = [[0] * 8 for _ in range(8)]\\n        n = len(pieces)\\n        for pos in positions:\\n            pos[0] -= 1\\n            pos[1] -= 1\\n        all_time = 2 ** 7 - 1\\n        def recur(i):\\n            if i == n:\\n                return 1\\n            ans = 0\\n            line = [(0, 1), (1, 0), (0, -1), (-1, 0)]\\n            diag = [(1, 1), (1, -1), (-1, 1), (-1, -1)]\\n            r, c = positions[i]\\n            if not board[r][c]:\\n                board[r][c] |= all_time\\n                ans += recur(i + 1)\\n                board[r][c] -= all_time\\n            directions = []\\n            if pieces[i] in (\"queen\", \"rook\"):\\n                directions.extend(line)\\n            if pieces[i] in (\"queen\", \"bishop\"):\\n                directions.extend(diag)                \\n            for dr, dc in directions:\\n                x, y = r + dr, c + dc\\n                bit = 1\\n                rest = all_time\\n                while 0 <= x < 8 and 0 <= y < 8 and not bit & board[x][y]:\\n                    board[x][y] |= bit\\n                    rest -= bit\\n                    bit <<= 1\\n                    if not board[x][y] & rest:\\n                        board[x][y] |= rest\\n                        ans += recur(i + 1)\\n                        board[x][y] -= rest\\n                    x += dr\\n                    y += dc\\n                bit >>= 1\\n                x -= dr\\n                y -= dc\\n                while bit:\\n                    board[x][y] -= bit\\n                    bit >>= 1\\n                    x -= dr\\n                    y -= dc\\n            return ans\\n        return recur(0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1548984,
                "title": "c-easy-logic-tricky-implementation",
                "content": "**High Level Algorithm**\\n\\t- Generate all possible combinations\\n\\t\\t- Max combinations can be (32) * (16) * (16) * (16)\\n\\t\\t\\t- 32 -> Max move of a queen (Atmost 1 queen according to question)\\n\\t\\t\\t- 16 -> Max moves of Rook or Bishop\\n\\t\\t- For each combination check whether it is a valid move or invalid move\\n\\nAlgorithm is easy, implementation is bit involved\\n\\n**Implementation Details**\\n- ***1 Generate all possible moves***\\n\\t- For this, first we check the type of piece\\n\\t- Get() funtion in code returns all possible moves of the piece\\n\\t\\t- Iterate over grid[i][j] , check if the given piece can be moved to grid[i][j] from starting location.\\n\\t\\t- See comments in code\\n- ***2 Count total combinations***\\n\\t- total = (count of combinations of piece[0]) * (count of combinations of piece[1]) ... * (count of combinations of piece[n-1])\\n\\t- In code it is stored in variable *res*\\n\\t- Note: This count contains invalid combinations as well, we need to remove that\\n\\n- ***3 Remove collision/invalid combinations***\\n\\t- For this we iterate over all possible combinations.\\n\\t\\t- For each combination we take pieces in pair of two\\n\\t\\t\\t- For each pair we check if at any point they are at same location.\\n\\t\\t\\t- If yes, then it is a collision, we return 1\\n\\t\\t\\t- Else, return 0\\n\\n\\n**TC analysis**\\nLet K be the number of combinations, max k = 29 * 15 * 15 * 15\\n- Step 1 takes atmost O(k)\\n- Step 3 takes O(k * nC2 * 8)\\n\\t- factor of nC2:  because we check all possible pairs for each combinations(size of each combination  = number of pieces = n)\\n\\t- factor of 8:  becaues in collision check we take atmost O(grid.size()), and grid.size() = 8\\n- Putting Max values, it takes O(5 * 10^6), which should be good to go.\\n\\n**Further Optimisations**\\n\\t- We can remove the factor of 8, in the collision check, but we need to derive mathematical formula for each pair.\\n\\t- We can use arrays instead of vector.\\n\\t\\n```\\nclass Solution {\\npublic:\\n    vector<int> type = {0,0,0,0};\\n    vector<long long> Pow;\\n    vector<vector<vector<int>>> pos;\\n    map<long long,int> cache;\\n\\t\\n\\t//Gets all possible combinations\\n    void Get(int type, int x, int y){\\n\\t\\n        vector<vector<int>> res;\\n        res.push_back({x,y});\\n        for(int i=1; i<=8; ++i){\\n            for(int j=1; j<=8; ++j){\\n                int dx = i-x, dy = j-y;\\n                if(i==x && j==y) continue;\\n                \\n                if(type==0 && (dx==0 || dy==0)) res.push_back({i,j}); // horizontal or vertical move\\n                else if(type==1 && (abs(dx) == abs(dy) || dx==0 || dy==0)) res.push_back({i,j});  \\n                else if(type==2 && (abs(dx) == abs(dy))) res.push_back({i,j}); //diagonal move\\n                \\n            }\\n        }\\n        pos.push_back(res);\\n        return;\\n    }\\n    \\n\\t\\n\\t\\n\\t//detect collision between two pieces\\n    int collision(int t1, vector<int> from1, vector<int>to1, int t2, vector<int>from2, vector<int>to2){\\n        long long hash = t1*Pow[0] + from1[0]*Pow[1] + from1[1]*Pow[2]\\n            + to1[0]*Pow[3] + to1[1]*Pow[4] + t2*Pow[5] + from2[0]*Pow[6] + from2[1]*Pow[7]\\n            + to2[0]*Pow[8] + to2[1]*Pow[9]; \\n        \\n        if(cache.count(hash)) return cache[hash];\\n        else if(to1 == to2)  return cache[hash] = 1;\\n        \\n        \\n\\t\\t//direction of movement\\n        int x1 = to1[0]-from1[0], y1 = to1[1]-from1[1], x2 = to2[0]-from2[0], y2 = to2[1]-from2[1];\\n        x1 = x1==0 ? 0 : x1/abs(x1);\\n        y1 = y1==0 ? 0 : y1/abs(y1);\\n        x2 = x2==0 ? 0 : x2/abs(x2);\\n        y2 = y2==0 ? 0 : y2/abs(y2);        \\n        \\n        while(from1!=to1 || from2!=to2){\\n            if(from1 == from2) return cache[hash] = 1;\\n            if(from1!=to1){ from1[0] += x1; from1[1] += y1;}\\n            if(from2!=to2){ from2[0] += x2; from2[1] += y2;}\\n        }\\n        \\n        return cache[hash] = 0;\\n    }\\n\\t\\n\\t\\n\\t// Main caller function\\n    int countCombinations(vector<string>& p, vector<vector<int>>& loc) {\\n        int n = p.size(), res = 1;\\n        cache.clear();\\n        Pow.resize(10,1);\\n        for(int i=1; i<10; ++i) Pow[i] *= Pow[i-1]*10;\\n        \\n        \\n        //Get All combinations\\n        for(int i=0; i<n; ++i){\\n            int x = loc[i][0], y = loc[i][1];\\n            if(p[i]==\"rook\") type[i] = 0;  else if(p[i]==\"queen\") type[i] = 1;  else type[i] = 2;\\n            Get(type[i],x,y);\\n            res *= pos[i].size(); //counting total combination\\n        }\\n        \\n        if(n==1) return res;\\n\\t\\t\\n\\t\\t\\n\\t\\t//removing invalid combinations now\\n        vector<int> ind(n);\\n        while(1){\\n\\t\\t\\n\\t\\t//iterating all pairs\\n            for(int i=0; i<n; ++i){\\n                int flag = 0;\\n                for(int j=i+1; j<n;++j){\\n\\t\\t\\t\\t\\t//checking collision\\n                    if(collision(\\n                        type[i],\\n                        loc[i],\\n                        pos[i][ind[i]],\\n                        type[j],\\n                        loc[j],\\n                        pos[j][ind[j]]\\n                     ))\\n                        \\n                       { res--; flag = 1; break;}\\n                }\\n                if(flag) break;\\n            }\\n            \\n\\t\\t\\t//getting next combination, iterating the indexes\\n            int flag = 0;\\n            for(int i=n-1; i>=0; --i){\\n                if(ind[i]<pos[i].size()-1) {ind[i]++; break;}\\n                else { flag++; ind[i] = 0;}\\n            }\\n            if(flag == n) break;\\n\\n        }\\n        return res;       \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> type = {0,0,0,0};\\n    vector<long long> Pow;\\n    vector<vector<vector<int>>> pos;\\n    map<long long,int> cache;\\n\\t\\n\\t//Gets all possible combinations\\n    void Get(int type, int x, int y){\\n\\t\\n        vector<vector<int>> res;\\n        res.push_back({x,y});\\n        for(int i=1; i<=8; ++i){\\n            for(int j=1; j<=8; ++j){\\n                int dx = i-x, dy = j-y;\\n                if(i==x && j==y) continue;\\n                \\n                if(type==0 && (dx==0 || dy==0)) res.push_back({i,j}); // horizontal or vertical move\\n                else if(type==1 && (abs(dx) == abs(dy) || dx==0 || dy==0)) res.push_back({i,j});  \\n                else if(type==2 && (abs(dx) == abs(dy))) res.push_back({i,j}); //diagonal move\\n                \\n            }\\n        }\\n        pos.push_back(res);\\n        return;\\n    }\\n    \\n\\t\\n\\t\\n\\t//detect collision between two pieces\\n    int collision(int t1, vector<int> from1, vector<int>to1, int t2, vector<int>from2, vector<int>to2){\\n        long long hash = t1*Pow[0] + from1[0]*Pow[1] + from1[1]*Pow[2]\\n            + to1[0]*Pow[3] + to1[1]*Pow[4] + t2*Pow[5] + from2[0]*Pow[6] + from2[1]*Pow[7]\\n            + to2[0]*Pow[8] + to2[1]*Pow[9]; \\n        \\n        if(cache.count(hash)) return cache[hash];\\n        else if(to1 == to2)  return cache[hash] = 1;\\n        \\n        \\n\\t\\t//direction of movement\\n        int x1 = to1[0]-from1[0], y1 = to1[1]-from1[1], x2 = to2[0]-from2[0], y2 = to2[1]-from2[1];\\n        x1 = x1==0 ? 0 : x1/abs(x1);\\n        y1 = y1==0 ? 0 : y1/abs(y1);\\n        x2 = x2==0 ? 0 : x2/abs(x2);\\n        y2 = y2==0 ? 0 : y2/abs(y2);        \\n        \\n        while(from1!=to1 || from2!=to2){\\n            if(from1 == from2) return cache[hash] = 1;\\n            if(from1!=to1){ from1[0] += x1; from1[1] += y1;}\\n            if(from2!=to2){ from2[0] += x2; from2[1] += y2;}\\n        }\\n        \\n        return cache[hash] = 0;\\n    }\\n\\t\\n\\t\\n\\t// Main caller function\\n    int countCombinations(vector<string>& p, vector<vector<int>>& loc) {\\n        int n = p.size(), res = 1;\\n        cache.clear();\\n        Pow.resize(10,1);\\n        for(int i=1; i<10; ++i) Pow[i] *= Pow[i-1]*10;\\n        \\n        \\n        //Get All combinations\\n        for(int i=0; i<n; ++i){\\n            int x = loc[i][0], y = loc[i][1];\\n            if(p[i]==\"rook\") type[i] = 0;  else if(p[i]==\"queen\") type[i] = 1;  else type[i] = 2;\\n            Get(type[i],x,y);\\n            res *= pos[i].size(); //counting total combination\\n        }\\n        \\n        if(n==1) return res;\\n\\t\\t\\n\\t\\t\\n\\t\\t//removing invalid combinations now\\n        vector<int> ind(n);\\n        while(1){\\n\\t\\t\\n\\t\\t//iterating all pairs\\n            for(int i=0; i<n; ++i){\\n                int flag = 0;\\n                for(int j=i+1; j<n;++j){\\n\\t\\t\\t\\t\\t//checking collision\\n                    if(collision(\\n                        type[i],\\n                        loc[i],\\n                        pos[i][ind[i]],\\n                        type[j],\\n                        loc[j],\\n                        pos[j][ind[j]]\\n                     ))\\n                        \\n                       { res--; flag = 1; break;}\\n                }\\n                if(flag) break;\\n            }\\n            \\n\\t\\t\\t//getting next combination, iterating the indexes\\n            int flag = 0;\\n            for(int i=n-1; i>=0; --i){\\n                if(ind[i]<pos[i].size()-1) {ind[i]++; break;}\\n                else { flag++; ind[i] = 0;}\\n            }\\n            if(flag == n) break;\\n\\n        }\\n        return res;       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1550204,
                "title": "java-solution-with-short-inline-comments",
                "content": "The solution is straight forward. The hardest part is understanding the definition of the problem and examples. Let me know if there are any questions.\\n\\n```java\\n public int countCombinations(String[] pieces, int[][] positions) {\\n        List<List<int[]>> allTargets = IntStream.range(0, pieces.length).mapToObj(i -> new ArrayList<int[]>()).collect(Collectors.toList());\\n        for (int i = 0; i < pieces.length; i++) {\\n            int p[] = positions[i], x = p[0], y = p[1];\\n            allTargets.get(i).add(p);//add init position as a target\\n            for (int r = 1; r <= 8; r++)\\n                for (int c = 1; c <= 8; c++)\\n                    if (r != x || c != y) {//all but not init position, it is already added\\n                        if (!pieces[i].equals(\"rook\") && (r + c == x + y || r - c == x - y))//valid target for bishop and queen\\n                            allTargets.get(i).add(new int[]{r, c});\\n                        if (!pieces[i].equals(\"bishop\") && (r == x || c == y))//valid target for rook and queen\\n                            allTargets.get(i).add(new int[]{r, c});\\n                    }\\n        }\\n        return count(0, positions, allTargets, new LinkedList<>());\\n    }\\n\\n    int count(int idx, int[][] initPositions, List<List<int[]>> allTargets, LinkedList<int[]> targets) {\\n        if (idx == initPositions.length)\\n            return valid(initPositions, targets) ? 1 : 0;\\n        int count = 0;\\n        for (int[] position : allTargets.get(idx)) {\\n            targets.add(position);\\n            count += count(idx + 1, initPositions, allTargets, targets);\\n            targets.removeLast();\\n        }\\n        return count;\\n    }\\n\\n    boolean valid(int[][] initPositions, List<int[]> targets) {\\n        List<int[]> positions = Arrays.stream(initPositions).map(int[]::clone).collect(Collectors.toList());//deep copy init positions as we are going to move towards targets\\n        for (boolean keepMoving = true; keepMoving; ) {\\n            keepMoving = false;\\n            Set<Integer> used = new HashSet<>();\\n            for (int i = 0; i < positions.size(); i++) {\\n                int verticalDirection = targets.get(i)[0] - positions.get(i)[0], horizontalDirection = targets.get(i)[1] - positions.get(i)[1];\\n                positions.get(i)[0] += Integer.compare(verticalDirection, 0);\\n                positions.get(i)[1] += Integer.compare(horizontalDirection, 0);\\n                if (verticalDirection != 0 || horizontalDirection != 0)//target is not reached\\n                    keepMoving = true;\\n                if (!used.add(13 * positions.get(i)[0] + positions.get(i)[1]))//collision with another piece\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }",
                "solutionTags": [],
                "code": "The solution is straight forward. The hardest part is understanding the definition of the problem and examples. Let me know if there are any questions.\\n\\n```java\\n public int countCombinations(String[] pieces, int[][] positions) {\\n        List<List<int[]>> allTargets = IntStream.range(0, pieces.length).mapToObj(i -> new ArrayList<int[]>()).collect(Collectors.toList());\\n        for (int i = 0; i < pieces.length; i++) {\\n            int p[] = positions[i], x = p[0], y = p[1];\\n            allTargets.get(i).add(p);//add init position as a target\\n            for (int r = 1; r <= 8; r++)\\n                for (int c = 1; c <= 8; c++)\\n                    if (r != x || c != y) {//all but not init position, it is already added\\n                        if (!pieces[i].equals(\"rook\") && (r + c == x + y || r - c == x - y))//valid target for bishop and queen\\n                            allTargets.get(i).add(new int[]{r, c});\\n                        if (!pieces[i].equals(\"bishop\") && (r == x || c == y))//valid target for rook and queen\\n                            allTargets.get(i).add(new int[]{r, c});\\n                    }\\n        }\\n        return count(0, positions, allTargets, new LinkedList<>());\\n    }\\n\\n    int count(int idx, int[][] initPositions, List<List<int[]>> allTargets, LinkedList<int[]> targets) {\\n        if (idx == initPositions.length)\\n            return valid(initPositions, targets) ? 1 : 0;\\n        int count = 0;\\n        for (int[] position : allTargets.get(idx)) {\\n            targets.add(position);\\n            count += count(idx + 1, initPositions, allTargets, targets);\\n            targets.removeLast();\\n        }\\n        return count;\\n    }\\n\\n    boolean valid(int[][] initPositions, List<int[]> targets) {\\n        List<int[]> positions = Arrays.stream(initPositions).map(int[]::clone).collect(Collectors.toList());//deep copy init positions as we are going to move towards targets\\n        for (boolean keepMoving = true; keepMoving; ) {\\n            keepMoving = false;\\n            Set<Integer> used = new HashSet<>();\\n            for (int i = 0; i < positions.size(); i++) {\\n                int verticalDirection = targets.get(i)[0] - positions.get(i)[0], horizontalDirection = targets.get(i)[1] - positions.get(i)[1];\\n                positions.get(i)[0] += Integer.compare(verticalDirection, 0);\\n                positions.get(i)[1] += Integer.compare(horizontalDirection, 0);\\n                if (verticalDirection != 0 || horizontalDirection != 0)//target is not reached\\n                    keepMoving = true;\\n                if (!used.add(13 * positions.get(i)[0] + positions.get(i)[1]))//collision with another piece\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1549211,
                "title": "java-no-tricks",
                "content": "Generate all final combinations\\nCheck wheather combinations are valid\\n```\\n// 0: rook, queen, bishop\\nint[][][] dirs = {\\n\\t\\t{{-1,0},{1,0},{0,-1},{0,1}},\\n\\t\\t{{-1,0},{1,0},{0,-1},{0,1},{1,1},{-1,-1},{-1,1},{1,-1}},\\n\\t\\t{{1,1},{-1,-1},{-1,1},{1,-1}}\\n};\\n\\npublic int countCombinations(String[] pieces, int[][] positions) {\\n\\tvar endPosition = new ArrayList[pieces.length];\\n\\tfor (int i = 0; i < pieces.length; i++) {\\n\\t\\tendPosition[i] = new ArrayList<int[][]>();\\n\\t}\\n\\tfor (int i = 0; i < pieces.length; i++) {\\n\\t\\tpositions[i][0]--;\\n\\t\\tpositions[i][1]--;\\n\\t\\tendPosition[i].add(positions[i]);\\n\\t\\tint dirIndex = 0;\\n\\t\\tswitch (pieces[i]) {\\n\\t\\tcase \"rook\":\\n\\t\\t\\tdirIndex = 0;\\n\\t\\t\\tbreak;\\n\\t\\tcase \"queen\":\\n\\t\\t\\tdirIndex = 1;\\n\\t\\t\\tbreak;\\n\\t\\tcase \"bishop\":\\n\\t\\t\\tdirIndex = 2;\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t\\tfor (var d : dirs[dirIndex]) {\\n\\t\\t\\tint r = positions[i][0];\\n\\t\\t\\tint c = positions[i][1];\\n\\t\\t\\twhile (true) {\\n\\t\\t\\t\\tr += d[0];\\n\\t\\t\\t\\tc += d[1];\\n\\t\\t\\t\\tif (r < 0 || r >= 8 || c < 0 || c >= 8) {\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tendPosition[i].add(new int[] { r, c });\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn dfs(positions, endPosition, new int[pieces.length], 0);\\n}\\n\\nprivate int dfs(int[][] positions, ArrayList[] stop, int[] stopIndex, int cur) {\\n\\tif (cur == stopIndex.length) {\\n\\t\\tvar p = new int[positions.length][2];\\n\\t\\tfor (int i = 0; i < p.length; i++) {\\n\\t\\t\\tp[i] = new int[] { positions[i][0], positions[i][1] };\\n\\t\\t}\\n\\t\\treturn check(p, stop, stopIndex);\\n\\t}\\n\\n\\tint res = 0;\\n\\tfor (int i = 0; i < stop[cur].size(); i++) {\\n\\t\\tstopIndex[cur] = i;\\n\\t\\tres += dfs(positions, stop, stopIndex, cur + 1);\\n\\t}\\n\\n\\treturn res;\\n}\\n\\nprivate int check(int[][] positions, ArrayList<int[]>[] stop, int[] stopIndex) {\\n\\tboolean keepGoing = true;\\n\\twhile (keepGoing) {\\n\\t\\tkeepGoing = false;\\n\\t\\tfor (int i = 0; i < positions.length; i++) {\\n\\t\\t\\tint diff = stop[i].get(stopIndex[i])[0] - positions[i][0];\\n\\t\\t\\tif (diff > 0) {\\n\\t\\t\\t\\tkeepGoing = true;\\n\\t\\t\\t\\tpositions[i][0]++;\\n\\t\\t\\t} else if (diff < 0) {\\n\\t\\t\\t\\tkeepGoing = true;\\n\\t\\t\\t\\tpositions[i][0]--;\\n\\t\\t\\t}\\n\\t\\t\\tdiff = stop[i].get(stopIndex[i])[1] - positions[i][1];\\n\\t\\t\\tif (diff > 0) {\\n\\t\\t\\t\\tkeepGoing = true;\\n\\t\\t\\t\\tpositions[i][1]++;\\n\\t\\t\\t} else if (diff < 0) {\\n\\t\\t\\t\\tkeepGoing = true;\\n\\t\\t\\t\\tpositions[i][1]--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tvar seen = new HashSet<Integer>();\\n\\t\\tfor (int i = 0; i < positions.length; i++) {\\n\\t\\t\\tvar key = positions[i][0] * 100 + positions[i][1];\\n\\t\\t\\tif (seen.contains(key)) {\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t}\\n\\t\\t\\tseen.add(key);\\n\\t\\t}\\n\\t}\\n\\treturn 1;\\n}\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\n// 0: rook, queen, bishop\\nint[][][] dirs = {\\n\\t\\t{{-1,0},{1,0},{0,-1},{0,1}},\\n\\t\\t{{-1,0},{1,0},{0,-1},{0,1},{1,1},{-1,-1},{-1,1},{1,-1}},\\n\\t\\t{{1,1},{-1,-1},{-1,1},{1,-1}}\\n};\\n\\npublic int countCombinations(String[] pieces, int[][] positions) {\\n\\tvar endPosition = new ArrayList[pieces.length];\\n\\tfor (int i = 0; i < pieces.length; i++) {\\n\\t\\tendPosition[i] = new ArrayList<int[][]>();\\n\\t}\\n\\tfor (int i = 0; i < pieces.length; i++) {\\n\\t\\tpositions[i][0]--;\\n\\t\\tpositions[i][1]--;\\n\\t\\tendPosition[i].add(positions[i]);\\n\\t\\tint dirIndex = 0;\\n\\t\\tswitch (pieces[i]) {\\n\\t\\tcase \"rook\":\\n\\t\\t\\tdirIndex = 0;\\n\\t\\t\\tbreak;\\n\\t\\tcase \"queen\":\\n\\t\\t\\tdirIndex = 1;\\n\\t\\t\\tbreak;\\n\\t\\tcase \"bishop\":\\n\\t\\t\\tdirIndex = 2;\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t\\tfor (var d : dirs[dirIndex]) {\\n\\t\\t\\tint r = positions[i][0];\\n\\t\\t\\tint c = positions[i][1];\\n\\t\\t\\twhile (true) {\\n\\t\\t\\t\\tr += d[0];\\n\\t\\t\\t\\tc += d[1];\\n\\t\\t\\t\\tif (r < 0 || r >= 8 || c < 0 || c >= 8) {\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tendPosition[i].add(new int[] { r, c });\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn dfs(positions, endPosition, new int[pieces.length], 0);\\n}\\n\\nprivate int dfs(int[][] positions, ArrayList[] stop, int[] stopIndex, int cur) {\\n\\tif (cur == stopIndex.length) {\\n\\t\\tvar p = new int[positions.length][2];\\n\\t\\tfor (int i = 0; i < p.length; i++) {\\n\\t\\t\\tp[i] = new int[] { positions[i][0], positions[i][1] };\\n\\t\\t}\\n\\t\\treturn check(p, stop, stopIndex);\\n\\t}\\n\\n\\tint res = 0;\\n\\tfor (int i = 0; i < stop[cur].size(); i++) {\\n\\t\\tstopIndex[cur] = i;\\n\\t\\tres += dfs(positions, stop, stopIndex, cur + 1);\\n\\t}\\n\\n\\treturn res;\\n}\\n\\nprivate int check(int[][] positions, ArrayList<int[]>[] stop, int[] stopIndex) {\\n\\tboolean keepGoing = true;\\n\\twhile (keepGoing) {\\n\\t\\tkeepGoing = false;\\n\\t\\tfor (int i = 0; i < positions.length; i++) {\\n\\t\\t\\tint diff = stop[i].get(stopIndex[i])[0] - positions[i][0];\\n\\t\\t\\tif (diff > 0) {\\n\\t\\t\\t\\tkeepGoing = true;\\n\\t\\t\\t\\tpositions[i][0]++;\\n\\t\\t\\t} else if (diff < 0) {\\n\\t\\t\\t\\tkeepGoing = true;\\n\\t\\t\\t\\tpositions[i][0]--;\\n\\t\\t\\t}\\n\\t\\t\\tdiff = stop[i].get(stopIndex[i])[1] - positions[i][1];\\n\\t\\t\\tif (diff > 0) {\\n\\t\\t\\t\\tkeepGoing = true;\\n\\t\\t\\t\\tpositions[i][1]++;\\n\\t\\t\\t} else if (diff < 0) {\\n\\t\\t\\t\\tkeepGoing = true;\\n\\t\\t\\t\\tpositions[i][1]--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tvar seen = new HashSet<Integer>();\\n\\t\\tfor (int i = 0; i < positions.length; i++) {\\n\\t\\t\\tvar key = positions[i][0] * 100 + positions[i][1];\\n\\t\\t\\tif (seen.contains(key)) {\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t}\\n\\t\\t\\tseen.add(key);\\n\\t\\t}\\n\\t}\\n\\treturn 1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1553100,
                "title": "python-very-clean-and-easy-to-follow",
                "content": "```python\\nclass Solution:\\n  def countCombinations(self, pieces: List[str], positions: List[List[int]]) -> int:\\n    n = len(pieces)\\n    rookDir = [(1, 0), (-1, 0), (0, 1), (0, -1)]\\n    bishopDir = [(1, 1), (1, -1), (-1, 1), (-1, -1)]\\n    dirsChoices = {\"rook\": rookDir,\\n                   \"bishop\": bishopDir, \"queen\": rookDir + bishopDir}\\n    ans = set()\\n\\n    def hash(board: List[List[int]]) -> Tuple:\\n      return tuple([tuple(pos) for pos in board])\\n\\n    def dfs(board: List[List[int]], dirs: List[Tuple[int, int]], activeMask: int) -> None:\\n      ans.add(hash(board))\\n      for nextActiveMask in range(1, 1 << n):\\n        if activeMask & nextActiveMask != nextActiveMask:\\n          continue\\n\\n        # make sure to copy every pos!\\n        nextBoard = [pos.copy() for pos in board]\\n\\n        # move pieces that are active in this turn\\n        for i in range(n):\\n          if (nextActiveMask >> i) & 1:\\n            nextBoard[i][0] += dirs[i][0]\\n            nextBoard[i][1] += dirs[i][1]\\n\\n        # check no two or more pieces occupy the same square\\n        if len(set(hash(nextBoard))) < len(nextBoard):\\n          continue\\n\\n        # check if all in boundary\\n        if all(1 <= x <= 8 and 1 <= y <= 8 for x, y in nextBoard):\\n          dfs(nextBoard, dirs, nextActiveMask)\\n\\n    for dirs in product(*(dirsChoices[piece] for piece in pieces)):\\n      dfs(positions, dirs, (1 << n) - 1)\\n\\n    return len(ans)\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n  def countCombinations(self, pieces: List[str], positions: List[List[int]]) -> int:\\n    n = len(pieces)\\n    rookDir = [(1, 0), (-1, 0), (0, 1), (0, -1)]\\n    bishopDir = [(1, 1), (1, -1), (-1, 1), (-1, -1)]\\n    dirsChoices = {\"rook\": rookDir,\\n                   \"bishop\": bishopDir, \"queen\": rookDir + bishopDir}\\n    ans = set()\\n\\n    def hash(board: List[List[int]]) -> Tuple:\\n      return tuple([tuple(pos) for pos in board])\\n\\n    def dfs(board: List[List[int]], dirs: List[Tuple[int, int]], activeMask: int) -> None:\\n      ans.add(hash(board))\\n      for nextActiveMask in range(1, 1 << n):\\n        if activeMask & nextActiveMask != nextActiveMask:\\n          continue\\n\\n        # make sure to copy every pos!\\n        nextBoard = [pos.copy() for pos in board]\\n\\n        # move pieces that are active in this turn\\n        for i in range(n):\\n          if (nextActiveMask >> i) & 1:\\n            nextBoard[i][0] += dirs[i][0]\\n            nextBoard[i][1] += dirs[i][1]\\n\\n        # check no two or more pieces occupy the same square\\n        if len(set(hash(nextBoard))) < len(nextBoard):\\n          continue\\n\\n        # check if all in boundary\\n        if all(1 <= x <= 8 and 1 <= y <= 8 for x, y in nextBoard):\\n          dfs(nextBoard, dirs, nextActiveMask)\\n\\n    for dirs in product(*(dirsChoices[piece] for piece in pieces)):\\n      dfs(positions, dirs, (1 << n) - 1)\\n\\n    return len(ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1549483,
                "title": "python-simple-concise-complete-search-with-memoization",
                "content": "Tried simiflying my code as much as possible. The logic is fairly simple, implemeting it is pretty hard.\\n\\n```python\\nclass Solution:\\n    def countCombinations(self, pieces: List[str], positions: List[List[int]]) -> int:\\n        \\n        moves = { \"rook\" : [ (1,0),(-1,0),(0,-1),(0,1) ],\\n                  \"bishop\" : [ (1,1),(-1,-1),(1,-1),(-1,1) ],\\n                  \"queen\" : [ (1,0),(-1,0),(0,-1),(0,1),(1,1),(-1,-1),(1,-1),(-1,1) ] }\\n\\n        # bq -> blocked cells where we can\\'t be. ( i, j, time ) as we care about time too\\n        # nbq -> same as above but it includes the current move\\n        # nxbq -> nbd and it adds the time until the end, as we will stay in this cell and wont let others pieces in\\n        \\n        @cache\\n        def search( p, bq ) -> int:\\n            if p == len( pieces ):\\n                return 1\\n\\n            res, t = 0, 0\\n            for m in moves[ pieces[p] ]:\\n                i, j = positions[p]\\n                # only start from initial position the first time.\\n                if t == 1:\\n                    i, j = i + m[0], j + m[1]\\n                nbq = bq\\n                    \\n                while i > 0 and i < 9 and j > 0 and j < 9:\\n                    if ( i, j, t ) in nbq:\\n                        break\\n                    nbq = nbq + (( i, j, t ),)\\n                    nxbq = nbq\\n\\n                    # Figure out if we can stay in this cell until the end of the game\\n                    stay = True\\n                    for nt in range( t+1, 8 ):\\n                        if ( i, j, nt ) in bq:\\n                            stay = False\\n                        nxbq = nxbq + (( i, j, nt ),)\\n\\n                    if stay:\\n                        res += search( p+1, nxbq )\\n                    i, j, t = i + m[0], j + m[1], t + 1\\n                \\n                i, j = positions[p]\\n                if ( i, j, 0 ) not in bq:\\n                    bq += (( i, j, 0 ),)\\n                t = 1\\n                    \\n            return res\\n        \\n        return search( 0, () )\\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Memoization"
                ],
                "code": "```python\\nclass Solution:\\n    def countCombinations(self, pieces: List[str], positions: List[List[int]]) -> int:\\n        \\n        moves = { \"rook\" : [ (1,0),(-1,0),(0,-1),(0,1) ],\\n                  \"bishop\" : [ (1,1),(-1,-1),(1,-1),(-1,1) ],\\n                  \"queen\" : [ (1,0),(-1,0),(0,-1),(0,1),(1,1),(-1,-1),(1,-1),(-1,1) ] }\\n\\n        # bq -> blocked cells where we can\\'t be. ( i, j, time ) as we care about time too\\n        # nbq -> same as above but it includes the current move\\n        # nxbq -> nbd and it adds the time until the end, as we will stay in this cell and wont let others pieces in\\n        \\n        @cache\\n        def search( p, bq ) -> int:\\n            if p == len( pieces ):\\n                return 1\\n\\n            res, t = 0, 0\\n            for m in moves[ pieces[p] ]:\\n                i, j = positions[p]\\n                # only start from initial position the first time.\\n                if t == 1:\\n                    i, j = i + m[0], j + m[1]\\n                nbq = bq\\n                    \\n                while i > 0 and i < 9 and j > 0 and j < 9:\\n                    if ( i, j, t ) in nbq:\\n                        break\\n                    nbq = nbq + (( i, j, t ),)\\n                    nxbq = nbq\\n\\n                    # Figure out if we can stay in this cell until the end of the game\\n                    stay = True\\n                    for nt in range( t+1, 8 ):\\n                        if ( i, j, nt ) in bq:\\n                            stay = False\\n                        nxbq = nxbq + (( i, j, nt ),)\\n\\n                    if stay:\\n                        res += search( p+1, nxbq )\\n                    i, j, t = i + m[0], j + m[1], t + 1\\n                \\n                i, j = positions[p]\\n                if ( i, j, 0 ) not in bq:\\n                    bq += (( i, j, 0 ),)\\n                t = 1\\n                    \\n            return res\\n        \\n        return search( 0, () )\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2331905,
                "title": "python3-dfs-with-backtracking-clean-code-with-comments",
                "content": "```\\nclass Solution:\\n    BOARD_SIZE = 8\\n    \\n    def diag(self, r, c):\\n        # Return all diagonal indices except (r, c)\\n        # Diagonal indices has the same r - c\\n        inv = r - c\\n        result = []\\n        for ri in range(self.BOARD_SIZE):\\n            ci = ri - inv\\n            if 0 <= ci < self.BOARD_SIZE and ri != r:\\n                result.append((ri, ci))\\n\\n        return result\\n    \\n    def reverseDiag(self, r, c):\\n        # Return all reverse diagonal indices except (r, c)\\n        # Reverse diagonal indices has the same r + c\\n        inv = r + c\\n        result = []\\n        for ri in range(self.BOARD_SIZE):\\n            ci = inv - ri\\n            if 0 <= ci < self.BOARD_SIZE and ri != r:\\n                result.append((ri, ci))\\n\\n        return result\\n    \\n    def generatePossiblePositions(self, piece, start):\\n        # Generate list of possible positions for every figure\\n        rs, cs = start[0] - 1, start[1] - 1\\n\\n        # Start position\\n        result = [(rs, cs)]\\n\\n        # Straight\\n        if piece == \"rook\" or piece == \"queen\":\\n            result.extend([(r, cs) for r in range(self.BOARD_SIZE) if r != rs])\\n            result.extend([(rs, c) for c in range(self.BOARD_SIZE) if c != cs])\\n\\n        # Diagonal\\n        if piece == \"bishop\" or piece == \"queen\":\\n            result.extend(self.diag(rs, cs))\\n            result.extend(self.reverseDiag(rs, cs))\\n\\n        return result\\n    \\n    def collide(self, start1, end1, start2, end2):\\n        # Check if two figures will collide\\n        # Collision occures if: \\n        #  - two figures have the same end points\\n        #  - one figure stands on the way of second one\\n        #\\n        # For this purpose let\\'s model each step of two pieces \\n        # and compare their positions at every time step.\\n        \\n        def steps(start, end):\\n            # Total steps that should be done\\n            return abs(end - start)\\n\\n        def step(start, end):\\n            # Step direction -1, 0, 1\\n            if steps(start, end) == 0:\\n                return 0\\n            return (end - start) / steps(start, end)\\n\\n        (rstart1, cstart1), (rend1, cend1) = start1, end1\\n        (rstart2, cstart2), (rend2, cend2) = start2, end2\\n\\n        # Find step direction for each piece\\n        rstep1, cstep1 = step(rstart1, rend1), step(cstart1, cend1)\\n        rstep2, cstep2 = step(rstart2, rend2), step(cstart2, cend2)\\n\\n        # Find maximum number of steps for each piece\\n        max_step1 = max(steps(rstart1, rend1), steps(cstart1, cend1))\\n        max_step2 = max(steps(rstart2, rend2), steps(cstart2, cend2))\\n\\n        # Move pieces step by step and compare their positions\\n        for step_i in range(max(max_step1, max_step2) + 1):\\n            step_i1 = min(step_i, max_step1)\\n            r1 = rstart1 + step_i1 * rstep1\\n            c1 = cstart1 + step_i1 * cstep1\\n\\n            step_i2 = min(step_i, max_step2)\\n            r2 = rstart2 + step_i2 * rstep2\\n            c2 = cstart2 + step_i2 * cstep2\\n\\n            # If positions are the same then collision occures\\n            if r1 == r2 and c1 == c2:\\n                return True\\n\\n        return False\\n    \\n    def countCombinations(self, pieces: List[str], positions: List[List[int]]) -> int:\\n        if len(pieces) == 0:\\n            return 0\\n\\n        n = len(pieces)\\n        \\n        # Make zero-indexed\\n        start_positions = [[r - 1, c - 1] for r, c in positions]\\n        \\n        # All possible positions\\n        possible_positions = [\\n            self.generatePossiblePositions(piece, start) \\n            for piece, start in zip(pieces, positions)\\n        ]\\n        \\n        # Let\\'s use DFS with backtracking\\n        # For that we will keep set of already occupied coordinates\\n        # and current positions of pieces\\n        occupied = set()\\n        current_positions = [None] * n  # None means that we didn\\'t placed the piece\\n        \\n        def collision(start, end):\\n            # Helper to check if moving from start to end position will collide with someone\\n            for start2, end2 in zip(start_positions, current_positions):\\n                if end2 is not None and self.collide(start, end, start2, end2):\\n                    return True\\n            return False\\n\\n        def dfs(piece_i=0):\\n            # All pieces are placed\\n            if piece_i == n:\\n                return 1\\n\\n            result = 0\\n            for position in possible_positions[piece_i]:\\n                # If position already occupied of collides with other pieces then skip it\\n                if position in occupied or collision(start_positions[piece_i], position):\\n                    continue\\n                \\n                # Occupy the position\\n                occupied.add(position)\\n                current_positions[piece_i] = position\\n                \\n                # Run DFS for next piece\\n                result += dfs(piece_i + 1)\\n                \\n                # Release the position\\n                occupied.remove(position)\\n                current_positions[piece_i] = None\\n                \\n            return result\\n\\n        return dfs()\\n```",
                "solutionTags": [
                    "Python3",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    BOARD_SIZE = 8\\n    \\n    def diag(self, r, c):\\n        # Return all diagonal indices except (r, c)\\n        # Diagonal indices has the same r - c\\n        inv = r - c\\n        result = []\\n        for ri in range(self.BOARD_SIZE):\\n            ci = ri - inv\\n            if 0 <= ci < self.BOARD_SIZE and ri != r:\\n                result.append((ri, ci))\\n\\n        return result\\n    \\n    def reverseDiag(self, r, c):\\n        # Return all reverse diagonal indices except (r, c)\\n        # Reverse diagonal indices has the same r + c\\n        inv = r + c\\n        result = []\\n        for ri in range(self.BOARD_SIZE):\\n            ci = inv - ri\\n            if 0 <= ci < self.BOARD_SIZE and ri != r:\\n                result.append((ri, ci))\\n\\n        return result\\n    \\n    def generatePossiblePositions(self, piece, start):\\n        # Generate list of possible positions for every figure\\n        rs, cs = start[0] - 1, start[1] - 1\\n\\n        # Start position\\n        result = [(rs, cs)]\\n\\n        # Straight\\n        if piece == \"rook\" or piece == \"queen\":\\n            result.extend([(r, cs) for r in range(self.BOARD_SIZE) if r != rs])\\n            result.extend([(rs, c) for c in range(self.BOARD_SIZE) if c != cs])\\n\\n        # Diagonal\\n        if piece == \"bishop\" or piece == \"queen\":\\n            result.extend(self.diag(rs, cs))\\n            result.extend(self.reverseDiag(rs, cs))\\n\\n        return result\\n    \\n    def collide(self, start1, end1, start2, end2):\\n        # Check if two figures will collide\\n        # Collision occures if: \\n        #  - two figures have the same end points\\n        #  - one figure stands on the way of second one\\n        #\\n        # For this purpose let\\'s model each step of two pieces \\n        # and compare their positions at every time step.\\n        \\n        def steps(start, end):\\n            # Total steps that should be done\\n            return abs(end - start)\\n\\n        def step(start, end):\\n            # Step direction -1, 0, 1\\n            if steps(start, end) == 0:\\n                return 0\\n            return (end - start) / steps(start, end)\\n\\n        (rstart1, cstart1), (rend1, cend1) = start1, end1\\n        (rstart2, cstart2), (rend2, cend2) = start2, end2\\n\\n        # Find step direction for each piece\\n        rstep1, cstep1 = step(rstart1, rend1), step(cstart1, cend1)\\n        rstep2, cstep2 = step(rstart2, rend2), step(cstart2, cend2)\\n\\n        # Find maximum number of steps for each piece\\n        max_step1 = max(steps(rstart1, rend1), steps(cstart1, cend1))\\n        max_step2 = max(steps(rstart2, rend2), steps(cstart2, cend2))\\n\\n        # Move pieces step by step and compare their positions\\n        for step_i in range(max(max_step1, max_step2) + 1):\\n            step_i1 = min(step_i, max_step1)\\n            r1 = rstart1 + step_i1 * rstep1\\n            c1 = cstart1 + step_i1 * cstep1\\n\\n            step_i2 = min(step_i, max_step2)\\n            r2 = rstart2 + step_i2 * rstep2\\n            c2 = cstart2 + step_i2 * cstep2\\n\\n            # If positions are the same then collision occures\\n            if r1 == r2 and c1 == c2:\\n                return True\\n\\n        return False\\n    \\n    def countCombinations(self, pieces: List[str], positions: List[List[int]]) -> int:\\n        if len(pieces) == 0:\\n            return 0\\n\\n        n = len(pieces)\\n        \\n        # Make zero-indexed\\n        start_positions = [[r - 1, c - 1] for r, c in positions]\\n        \\n        # All possible positions\\n        possible_positions = [\\n            self.generatePossiblePositions(piece, start) \\n            for piece, start in zip(pieces, positions)\\n        ]\\n        \\n        # Let\\'s use DFS with backtracking\\n        # For that we will keep set of already occupied coordinates\\n        # and current positions of pieces\\n        occupied = set()\\n        current_positions = [None] * n  # None means that we didn\\'t placed the piece\\n        \\n        def collision(start, end):\\n            # Helper to check if moving from start to end position will collide with someone\\n            for start2, end2 in zip(start_positions, current_positions):\\n                if end2 is not None and self.collide(start, end, start2, end2):\\n                    return True\\n            return False\\n\\n        def dfs(piece_i=0):\\n            # All pieces are placed\\n            if piece_i == n:\\n                return 1\\n\\n            result = 0\\n            for position in possible_positions[piece_i]:\\n                # If position already occupied of collides with other pieces then skip it\\n                if position in occupied or collision(start_positions[piece_i], position):\\n                    continue\\n                \\n                # Occupy the position\\n                occupied.add(position)\\n                current_positions[piece_i] = position\\n                \\n                # Run DFS for next piece\\n                result += dfs(piece_i + 1)\\n                \\n                # Release the position\\n                occupied.remove(position)\\n                current_positions[piece_i] = None\\n                \\n            return result\\n\\n        return dfs()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2065684,
                "title": "java-brute-force-intuitive",
                "content": "The idea is:\\n- generate all combinations of moves\\n- when all the pieces are in a combination, then simulate the move given the step of each piece\\n\\n```\\n  int directions[][] = new int[][] {\\n      {0, 0},\\n      { 0, -1 }, { 0, 1 }, { -1, 0 }, { 1, 0 }, // for rook only\\n      { 1, 1}, {1, -1}, {-1, 1}, {-1, -1}};     // for queen and bishop\\n  \\n  int count;\\n\\n  public int countCombinations(String[] pieces, int[][] positions)\\n  {\\n    dfs(pieces, positions, 0, new HashMap<>());\\n    \\n    return count;\\n  }\\n\\n  void dfs(String[] pieces, int[][] positions, int p, HashMap<Integer, int[]> board) \\n  {\\n    // for case the piece not moving\\n    boolean flag = true;  \\n    \\n    for (int d=1; d < directions.length; d++)\\n    {\\n      if ((d < 5 && pieces[p].equals(\"bishop\")) || (d > 4 && pieces[p].equals(\"rook\")))\\n          continue;\\n      \\n      for (int step = flag ? 0:1; step <= 8; step++, flag=false)\\n      {        \\n        int x = positions[p][0] + step * directions[d][0];\\n        int y = positions[p][1] + step * directions[d][1];\\n        int start = (positions[p][0] - 1) * 8 + positions[p][1];          \\n        int dest = 8 * (x - 1) + y;\\n    \\n        if (x < 1 || x > 8 || y < 1 || y > 8) \\n          break;\\n        \\n        if (board.containsKey(dest)) \\n          continue;\\n             \\n         // dest, step, type, direction, start\\n        board.put(dest, new int[] {dest, step, p, d, start}); \\n          \\n        if (board.size() == pieces.length)\\n          count += simulateMove(positions, board);\\n        else\\n          dfs(pieces, positions, p + 1, board);\\n        \\n        board.remove(dest);\\n      }\\n    }\\n  }\\n  \\n  private int simulateMove(int[][] positions, Map<Integer, int[]> board)\\n  {\\n    List<int[]> data = new ArrayList<>();\\n    Set<Integer> position = new HashSet<>();\\n    for (int piece[]: board.values()) \\n    {\\n      int d[] = new int[] {piece[0], piece[1], piece[2], piece[3], piece[4]};\\n      data.add(d);\\n      if (d[1] == 0)\\n        position.add(d[0]);\\n    }\\n    \\n    for (int i = 1; i <= 8; i++)\\n    {\\n      for (int d[]: data) \\n      {\\n        int dir[] = directions[d[3]];\\n        int x = positions[d[2]][0] + i * dir[0];\\n        int y = positions[d[2]][1] + i * dir[1];\\n        int move = 8 * (x - 1) + y;\\n      \\n        if (d[1] > 0 && x >= 1 && x <= 8 && y >= 1 && y <= 8) {\\n          if (position.contains(move)) \\n            return 0;\\n\\n          position.add(move);\\n          d[1]--;\\n          d[4] = move;\\n        }\\n      }\\n      \\n\\t  // clear the moves that are not done yet\\n      for (int d[]: data) \\n      {\\n        if (d[1] > 0)\\n          position.remove(d[4]);\\n      }\\n    }\\n    return 1;\\n  }  \\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n  int directions[][] = new int[][] {\\n      {0, 0},\\n      { 0, -1 }, { 0, 1 }, { -1, 0 }, { 1, 0 }, // for rook only\\n      { 1, 1}, {1, -1}, {-1, 1}, {-1, -1}};     // for queen and bishop\\n  \\n  int count;\\n\\n  public int countCombinations(String[] pieces, int[][] positions)\\n  {\\n    dfs(pieces, positions, 0, new HashMap<>());\\n    \\n    return count;\\n  }\\n\\n  void dfs(String[] pieces, int[][] positions, int p, HashMap<Integer, int[]> board) \\n  {\\n    // for case the piece not moving\\n    boolean flag = true;  \\n    \\n    for (int d=1; d < directions.length; d++)\\n    {\\n      if ((d < 5 && pieces[p].equals(\"bishop\")) || (d > 4 && pieces[p].equals(\"rook\")))\\n          continue;\\n      \\n      for (int step = flag ? 0:1; step <= 8; step++, flag=false)\\n      {        \\n        int x = positions[p][0] + step * directions[d][0];\\n        int y = positions[p][1] + step * directions[d][1];\\n        int start = (positions[p][0] - 1) * 8 + positions[p][1];          \\n        int dest = 8 * (x - 1) + y;\\n    \\n        if (x < 1 || x > 8 || y < 1 || y > 8) \\n          break;\\n        \\n        if (board.containsKey(dest)) \\n          continue;\\n             \\n         // dest, step, type, direction, start\\n        board.put(dest, new int[] {dest, step, p, d, start}); \\n          \\n        if (board.size() == pieces.length)\\n          count += simulateMove(positions, board);\\n        else\\n          dfs(pieces, positions, p + 1, board);\\n        \\n        board.remove(dest);\\n      }\\n    }\\n  }\\n  \\n  private int simulateMove(int[][] positions, Map<Integer, int[]> board)\\n  {\\n    List<int[]> data = new ArrayList<>();\\n    Set<Integer> position = new HashSet<>();\\n    for (int piece[]: board.values()) \\n    {\\n      int d[] = new int[] {piece[0], piece[1], piece[2], piece[3], piece[4]};\\n      data.add(d);\\n      if (d[1] == 0)\\n        position.add(d[0]);\\n    }\\n    \\n    for (int i = 1; i <= 8; i++)\\n    {\\n      for (int d[]: data) \\n      {\\n        int dir[] = directions[d[3]];\\n        int x = positions[d[2]][0] + i * dir[0];\\n        int y = positions[d[2]][1] + i * dir[1];\\n        int move = 8 * (x - 1) + y;\\n      \\n        if (d[1] > 0 && x >= 1 && x <= 8 && y >= 1 && y <= 8) {\\n          if (position.contains(move)) \\n            return 0;\\n\\n          position.add(move);\\n          d[1]--;\\n          d[4] = move;\\n        }\\n      }\\n      \\n\\t  // clear the moves that are not done yet\\n      for (int d[]: data) \\n      {\\n        if (d[1] > 0)\\n          position.remove(d[4]);\\n      }\\n    }\\n    return 1;\\n  }  \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1902871,
                "title": "python-dfs-on-each-piece-with-explanation",
                "content": "It is the python implementation inspired from [@votrubac](https://leetcode.com/problems/number-of-valid-move-combinations-on-chessboard/discuss/1549577/Dull-and-Painful)\\'s post. The idea is to get all the possible and valid stop positions of the first piece, then for each top position, get all the possible and valid stop positions for the second piece and so on. DFS is used to search for all the possibilibies of n stop positions on the chessboard. The `track` matrix is used to record the path/steps of each piece with `step + 1` value (avoiding `-0` for 0 step) in order to tell whehter the position is valid for the later piece. Negative step is used to mark that the position is occupized/stopped by a piece.\\n\\n```\\nclass Solution:\\n    def countCombinations(self, pieces: List[str], positions: List[List[int]]) -> int:\\n        self.directions = {\\n            \"rook\": [(-1, 0), (1, 0), (0, -1), (0, 1)],\\n            \"bishop\": [(-1, -1), (-1, 1), (1, -1), (1, 1)],\\n            \"queen\": [(-1, 0), (1, 0), (0, -1), (0, 1), (-1, -1), (-1, 1), (1, -1), (1, 1)]\\n        }\\n        self.ans = 0\\n        track=[[[0 for k in range(8)] for j in range(8)] for i in range(4)]\\n        self.dfs(pieces, positions, track, 0)\\n        return self.ans\\n    \\n    def dfs(self, pieces, positions, track, i):\\n        if i == len(pieces):\\n            self.ans += 1\\n            return\\n        x, y = positions[i][0]-1, positions[i][1]-1\\n        dirs = self.directions[pieces[i]]\\n        for k in range(len(dirs)):\\n            dx, dy = dirs[k][0], dirs[k][1]\\n            for step in range(8):\\n                if k > 0 and step == 0: # the 0 step is only checked once for the first direction, for the other 3 or 7 directions, it is skipped\\n                      continue\\n                nx, ny = x + step*dx, y + step*dy\\n                if nx < 0 or nx >= 8 or ny < 0 or ny >= 8:\\n                    break\\n                canStop = canAcross = True\\n                for j in range(i):\\n                    if track[j][nx][ny] < 0: # if the new position is already be occupized by the previous piece, it can not be stopped\\n                        canStop = False\\n                        if abs(track[j][nx][ny]) <= step + 1: \\n                            canAcross = False\\n                    if track[j][nx][ny] > 0:\\n                        if step + 1 <= track[j][nx][ny]:\\n                            canStop = False\\n                        if step + 1 == track[j][nx][ny]:\\n                            canAcross = False\\n                if canStop:\\n                    track[i][nx][ny] = -(step + 1) # step + 1 is used to avoid -0\\n                    self.dfs(pieces, positions, track, i+1)\\n                \\n                track[i][nx][ny] = step + 1\\n                if not canAcross:\\n                    break\\n            track[i] = [[0] * 8 for _ in range(8)] # backtracking\\n````",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def countCombinations(self, pieces: List[str], positions: List[List[int]]) -> int:\\n        self.directions = {\\n            \"rook\": [(-1, 0), (1, 0), (0, -1), (0, 1)],\\n            \"bishop\": [(-1, -1), (-1, 1), (1, -1), (1, 1)],\\n            \"queen\": [(-1, 0), (1, 0), (0, -1), (0, 1), (-1, -1), (-1, 1), (1, -1), (1, 1)]\\n        }\\n        self.ans = 0\\n        track=[[[0 for k in range(8)] for j in range(8)] for i in range(4)]\\n        self.dfs(pieces, positions, track, 0)\\n        return self.ans\\n    \\n    def dfs(self, pieces, positions, track, i):\\n        if i == len(pieces):\\n            self.ans += 1\\n            return\\n        x, y = positions[i][0]-1, positions[i][1]-1\\n        dirs = self.directions[pieces[i]]\\n        for k in range(len(dirs)):\\n            dx, dy = dirs[k][0], dirs[k][1]\\n            for step in range(8):\\n                if k > 0 and step == 0: # the 0 step is only checked once for the first direction, for the other 3 or 7 directions, it is skipped\\n                      continue\\n                nx, ny = x + step*dx, y + step*dy\\n                if nx < 0 or nx >= 8 or ny < 0 or ny >= 8:\\n                    break\\n                canStop = canAcross = True\\n                for j in range(i):\\n                    if track[j][nx][ny] < 0: # if the new position is already be occupized by the previous piece, it can not be stopped\\n                        canStop = False\\n                        if abs(track[j][nx][ny]) <= step + 1: \\n                            canAcross = False\\n                    if track[j][nx][ny] > 0:\\n                        if step + 1 <= track[j][nx][ny]:\\n                            canStop = False\\n                        if step + 1 == track[j][nx][ny]:\\n                            canAcross = False\\n                if canStop:\\n                    track[i][nx][ny] = -(step + 1) # step + 1 is used to avoid -0\\n                    self.dfs(pieces, positions, track, i+1)\\n                \\n                track[i][nx][ny] = step + 1\\n                if not canAcross:\\n                    break\\n            track[i] = [[0] * 8 for _ in range(8)] # backtracking\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1862002,
                "title": "python-backtrack-with-comments",
                "content": "1. Give each piece a direction according to its type, the direction could be `(0, 0)`, meaning the piece reached its destination\\n2. Try moving pieces with the given directions, if the move is not valid, stop. Otherwise count 1, and continue\\n3. For the next move, a piece that hasn\\'t reached its destination could either continue with its current direction, or stop. So we need to find all possible directions before next move\\n4. Repeat step 2 and 3 until all stop\\n\\n```\\n    def countCombinations(self, pieces: List[str], positions: List[List[int]]) -> int:\\n        n = len(pieces)\\n        rook_dirs = [(1, 0), (0, 1), (-1, 0), (0, -1)]\\n        bishop_dirs = [(1, 1), (-1, 1), (-1, -1), (1, -1)]\\n        \\n        dir_map = {\\n            \\'rook\\': rook_dirs + [(0, 0)],\\n            \\'bishop\\': bishop_dirs + [(0, 0)],\\n            \\'queen\\': rook_dirs + bishop_dirs + [(0, 0)]\\n        }\\n        \\n        # count num of moves can be made given positions and directions\\n        def count_moves(positions, directions):\\n            # if all pieces reached destination, there\\'s no more moves\\n            if all(direction == (0, 0) for direction in directions):\\n                return 0\\n            \\n            # do the move\\n            new_positions = [(i + di, j + dj) \\n                             for (i, j), (di, dj) in zip(positions, directions)\\n                             if 1 <= i + di <= 8 and 1 <= j + dj <= 8]\\n            \\n            # if any pieces hit the wall, or they are in the same position\\n            if len(set(new_positions)) != n:\\n                return 0\\n            \\n            # found 1 valid move\\n            n_moves = 1\\n            \\n            # get all the possible directions, recursively call to count moves\\n            for new_direction in get_directions(directions, 0, []):\\n                n_moves += count_moves(new_positions, new_direction)\\n            return n_moves\\n        \\n        # backtrack to get all possible directions combination given last directions\\n        def get_directions(dirs, curr_idx, stack):\\n            if len(stack) == n:\\n                yield stack\\n                return\\n            for i in range(curr_idx, n):\\n                stack.append(dirs[i])\\n                for d in get_directions(dirs, i + 1, stack):\\n                    yield d\\n                stack.pop()\\n                if any(dirs[i]):\\n                    stack.append((0, 0))\\n                    for d in get_directions(dirs, i + 1, stack):\\n                        yield d\\n                    stack.pop()\\n        \\n        # backtrack to get all initial directions, call count_moves() when the stack is full \\n        def init_directions_and_count(stack):\\n            n_moves = 0\\n            if len(stack) == n:\\n                n_moves += count_moves(positions, stack)\\n            else:            \\n                piece_to_add = pieces[len(stack)]            \\n                for direction in dir_map[piece_to_add]:\\n                    stack.append(direction)\\n                    n_moves += init_directions_and_count(stack)\\n                    stack.pop()\\n            return n_moves\\n        \\n        # plus one for all pieces stays at initial locations\\n        return init_directions_and_count([]) + 1\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\n    def countCombinations(self, pieces: List[str], positions: List[List[int]]) -> int:\\n        n = len(pieces)\\n        rook_dirs = [(1, 0), (0, 1), (-1, 0), (0, -1)]\\n        bishop_dirs = [(1, 1), (-1, 1), (-1, -1), (1, -1)]\\n        \\n        dir_map = {\\n            \\'rook\\': rook_dirs + [(0, 0)],\\n            \\'bishop\\': bishop_dirs + [(0, 0)],\\n            \\'queen\\': rook_dirs + bishop_dirs + [(0, 0)]\\n        }\\n        \\n        # count num of moves can be made given positions and directions\\n        def count_moves(positions, directions):\\n            # if all pieces reached destination, there\\'s no more moves\\n            if all(direction == (0, 0) for direction in directions):\\n                return 0\\n            \\n            # do the move\\n            new_positions = [(i + di, j + dj) \\n                             for (i, j), (di, dj) in zip(positions, directions)\\n                             if 1 <= i + di <= 8 and 1 <= j + dj <= 8]\\n            \\n            # if any pieces hit the wall, or they are in the same position\\n            if len(set(new_positions)) != n:\\n                return 0\\n            \\n            # found 1 valid move\\n            n_moves = 1\\n            \\n            # get all the possible directions, recursively call to count moves\\n            for new_direction in get_directions(directions, 0, []):\\n                n_moves += count_moves(new_positions, new_direction)\\n            return n_moves\\n        \\n        # backtrack to get all possible directions combination given last directions\\n        def get_directions(dirs, curr_idx, stack):\\n            if len(stack) == n:\\n                yield stack\\n                return\\n            for i in range(curr_idx, n):\\n                stack.append(dirs[i])\\n                for d in get_directions(dirs, i + 1, stack):\\n                    yield d\\n                stack.pop()\\n                if any(dirs[i]):\\n                    stack.append((0, 0))\\n                    for d in get_directions(dirs, i + 1, stack):\\n                        yield d\\n                    stack.pop()\\n        \\n        # backtrack to get all initial directions, call count_moves() when the stack is full \\n        def init_directions_and_count(stack):\\n            n_moves = 0\\n            if len(stack) == n:\\n                n_moves += count_moves(positions, stack)\\n            else:            \\n                piece_to_add = pieces[len(stack)]            \\n                for direction in dir_map[piece_to_add]:\\n                    stack.append(direction)\\n                    n_moves += init_directions_and_count(stack)\\n                    stack.pop()\\n            return n_moves\\n        \\n        # plus one for all pieces stays at initial locations\\n        return init_directions_and_count([]) + 1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1554261,
                "title": "java-brute-force",
                "content": "```\\nclass Solution {\\n    static int[][] B_DIRS= {{1,-1},{1,1},{-1,1},{-1,-1}}, R_DIRS= {{1,0},{0,1},{-1,0},{0,-1}}, \\n        Q_DIRS= {{1,-1},{1,1},{-1,1},{-1,-1},{1,0},{0,1},{-1,0},{0,-1}};\\n    static int B= 0, R= 1, Q= 2;            // piece types\\n    static int DIR= 0, MULT= 1, X= 0, Y= 1; // move ids (direction, distance multiplier), direction indexes\\n    \\n    int[] pieces;  // piece types\\n    int[][] positions; // original positions\\n    int[][] lastMove; // last generated move combination\\n    int[][] sim; // simulated position (used in isValid)\\n    int k; // number of pieces\\n    int count; // valid move combinations\\n    \\n    public int countCombinations(String[] pieces, int[][] positions) {\\n        this.k= pieces.length;\\n        this.pieces= new int[k];\\n        for(int i=0; i<k; i++)\\n            if(pieces[i].equals(\"bishop\")) this.pieces[i]= B;\\n            else if(pieces[i].equals(\"rook\")) this.pieces[i]= R;\\n            else this.pieces[i]= Q;\\n        this.positions= positions;\\n        \\n        this.count= 0;\\n        this.lastMove= new int[k][];\\n        this.sim= new int[k][2];\\n        generateCombinations(0);\\n        return this.count;\\n    }\\n    \\n\\t// generate combinations of moves for all pieces\\n    void generateCombinations(int piece){\\n        if(piece==k){\\n            count+= isValid() ? 1 : 0;\\n            return;\\n        }\\n        while(nextMove(piece))\\n            generateCombinations(piece+1);\\n        lastMove[piece]= null;\\n    }\\n    \\n\\t// generate next move for the specified piece\\n    boolean nextMove(int piece){\\n        if(lastMove[piece]==null){\\n            lastMove[piece]= new int[]{0,0}; // last move for piece i: direction index, mult [1..7]\\n            return true;\\n        }\\n        int[][] dirs= pieces[piece]==B ? B_DIRS : pieces[piece]==R ? R_DIRS : Q_DIRS;\\n        int[] last= lastMove[piece];\\n        for(;last[DIR]<dirs.length; ++last[DIR], last[MULT]=0){\\n            int dir= last[DIR];\\n            ++last[MULT];\\n            int x= positions[piece][X]+last[MULT]*dirs[dir][X], y= positions[piece][Y]+last[MULT]*dirs[dir][Y];\\n            if(x>=1 && x<=8 && y>=1 && y<=8) return true;\\n        }\\n        return false;        \\n    }\\n    \\n\\t// simulate the combination to verify if it is valid\\n    boolean isValid(){\\n        for(int piece=0; piece<k; piece++){\\n            sim[piece][X]= positions[piece][X];\\n            sim[piece][Y]= positions[piece][Y];\\n        }\\n        for(int time=1; time<=7; time++){\\n            for(int piece=0; piece<k; piece++){\\n                int[][] dirs= pieces[piece]==B ? B_DIRS : pieces[piece]==R ? R_DIRS : Q_DIRS;\\n                int[] last= lastMove[piece];\\n                int dir= last[DIR], mult= last[MULT];\\n                if(mult>=time){\\n                    sim[piece][X]+= dirs[dir][X];\\n                    sim[piece][Y]+= dirs[dir][Y];\\n                }\\n                for(int piece2= 0; piece2<piece; piece2++){\\n                    // check if collides\\n                    if(sim[piece][X]==sim[piece2][X] && sim[piece][Y]==sim[piece2][Y]){\\n                        //System.out.println(\"Collision at: \" + sim[piece][X] + \" \" + sim[piece][Y] + \", time=\" + time);\\n                        return false;\\n                    }\\n                }        \\n            }                        \\n        }\\n        return true;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    static int[][] B_DIRS= {{1,-1}",
                "codeTag": "Java"
            },
            {
                "id": 1551694,
                "title": "c-dfs-20ms-100",
                "content": "Use vis[8][8][8] (i.e. vis[round][x][y]) to record the occupation status of all positions in 8 rounds.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    void dfs(int cur, bool vis[8][8][8]) {\\n        if (cur == n) {\\n            ++res;\\n            return;\\n        }\\n        int x = poss[cur][0] - 1, y = poss[cur][1] - 1;\\n        \\n        // move.\\n        vector<pair<int, int>> dirs;\\n        if (ps[cur] == \"rook\") {\\n            dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n        } else if (ps[cur] == \"queen\") {\\n            dirs = {{-1, -1}, {-1, 0}, {-1, 1}, {0, -1}, {0, 1}, {1, -1}, {1, 0}, {1, 1}};\\n        } else {\\n            dirs = {{-1, -1}, {1, 1}, {-1, 1}, {1, -1}};\\n        }\\n        for (int i = 0; i < dirs.size(); ++i) {\\n            int dx = dirs[i].first, dy = dirs[i].second;\\n            for (int j = 1; ; ++j) {\\n                int xx = x + dx * j;\\n                int yy = y + dy * j;\\n                if (xx < 0 || xx >= 8 || yy < 0 || yy >= 8 || vis[j][xx][yy]) {\\n                    while (--j >= 1) {\\n                        int xx = x + dx * j;\\n                        int yy = y + dy * j;\\n                        vis[j][xx][yy] = false;\\n                    }\\n                    break;\\n                }\\n                vis[j][xx][yy] = true;\\n                bool ok = true;\\n                for (int k = j + 1; k < 8; ++k) {\\n                    if (vis[k][xx][yy]) {\\n                        ok = false;\\n                        break;\\n                    }\\n                }\\n                if (!ok)\\n                    continue;\\n                for (int k = j; k < 8; ++k) {\\n                    vis[k][xx][yy] = true;\\n                }\\n                dfs(cur + 1, vis);\\n                for (int k = j + 1; k < 8; ++k) {\\n                    vis[k][xx][yy] = false;\\n                }\\n            }\\n        }\\n        \\n        // stay.\\n        bool ok = true;\\n        for (int i = 1; i < 8; ++i)\\n            if (vis[i][x][y]) {\\n                ok = false;\\n                break;\\n            }\\n        if (!ok)\\n            return;\\n        for (int i = 1; i < 8; ++i)\\n            vis[i][x][y] = true;\\n        dfs(cur + 1, vis);\\n        for (int i = 1; i < 8; ++i)\\n            vis[i][x][y] = false;\\n    }\\n    \\n    int countCombinations(vector<string>& pieces, vector<vector<int>>& positions) {\\n        res = 0;\\n        ps = pieces;\\n        poss = positions;\\n        n = ps.size();\\n        bool vis[8][8][8] = {0};\\n        dfs(0, vis);\\n        return res;\\n    }\\n    \\n    int n;\\n    int res;\\n    vector<string> ps;\\n    vector<vector<int>> poss;\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    void dfs(int cur, bool vis[8][8][8]) {\\n        if (cur == n) {\\n            ++res;\\n            return;\\n        }\\n        int x = poss[cur][0] - 1, y = poss[cur][1] - 1;\\n        \\n        // move.\\n        vector<pair<int, int>> dirs;\\n        if (ps[cur] == \"rook\") {\\n            dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n        } else if (ps[cur] == \"queen\") {\\n            dirs = {{-1, -1}, {-1, 0}, {-1, 1}, {0, -1}, {0, 1}, {1, -1}, {1, 0}, {1, 1}};\\n        } else {\\n            dirs = {{-1, -1}, {1, 1}, {-1, 1}, {1, -1}};\\n        }\\n        for (int i = 0; i < dirs.size(); ++i) {\\n            int dx = dirs[i].first, dy = dirs[i].second;\\n            for (int j = 1; ; ++j) {\\n                int xx = x + dx * j;\\n                int yy = y + dy * j;\\n                if (xx < 0 || xx >= 8 || yy < 0 || yy >= 8 || vis[j][xx][yy]) {\\n                    while (--j >= 1) {\\n                        int xx = x + dx * j;\\n                        int yy = y + dy * j;\\n                        vis[j][xx][yy] = false;\\n                    }\\n                    break;\\n                }\\n                vis[j][xx][yy] = true;\\n                bool ok = true;\\n                for (int k = j + 1; k < 8; ++k) {\\n                    if (vis[k][xx][yy]) {\\n                        ok = false;\\n                        break;\\n                    }\\n                }\\n                if (!ok)\\n                    continue;\\n                for (int k = j; k < 8; ++k) {\\n                    vis[k][xx][yy] = true;\\n                }\\n                dfs(cur + 1, vis);\\n                for (int k = j + 1; k < 8; ++k) {\\n                    vis[k][xx][yy] = false;\\n                }\\n            }\\n        }\\n        \\n        // stay.\\n        bool ok = true;\\n        for (int i = 1; i < 8; ++i)\\n            if (vis[i][x][y]) {\\n                ok = false;\\n                break;\\n            }\\n        if (!ok)\\n            return;\\n        for (int i = 1; i < 8; ++i)\\n            vis[i][x][y] = true;\\n        dfs(cur + 1, vis);\\n        for (int i = 1; i < 8; ++i)\\n            vis[i][x][y] = false;\\n    }\\n    \\n    int countCombinations(vector<string>& pieces, vector<vector<int>>& positions) {\\n        res = 0;\\n        ps = pieces;\\n        poss = positions;\\n        n = ps.size();\\n        bool vis[8][8][8] = {0};\\n        dfs(0, vis);\\n        return res;\\n    }\\n    \\n    int n;\\n    int res;\\n    vector<string> ps;\\n    vector<vector<int>> poss;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1550288,
                "title": "python-dfs-hope-we-never-get-a-brute-force-problem-in-interviews",
                "content": "As `n <= 4` and the board size is `8 * 8`, we know we have to do a brute force. (Hope we never get a brute force problem in our interviews)\\nAnd we can know that each piece can move at most `7` steps in this `8 * 8` board. And if a piece decides to stay at one position, it  blocks all the other piece. So we can use a status map `T` (1-index) to track the time serial status of each position. The `i`th bit of `T[x][y]` indicates a piece is at `(x, y)` at time `i`. And a piece can either **pass** or **stay** at `(x,y)` at time `i` if it\\'s not blocked there.\\nLet\\'s initialize all bits in each `T[x][y]` to `1`. `0` indicates it\\'s been allocated to another piece. we can summarize a few rules:\\n1. Two piece cannot collide with each other: A piece can no longer pass `(x,y)` at time `i` and move further if `i`th bit of `T[x][y]` is `0`.\\n\\t1a. If a piece did a valid pass at `(x,y)` at time `i`, we should set `i`th bit of `T[x][y]` to 0 then.\\n2. If a piece decide to stay at `(x,y)` from time `i`, it cannot be conflicted with any future scenairo, including **(a)** the piece we already searched and **(b)** the piece we are to search.\\n\\t2a. If any `j`th bit `(j > i)` is already `0`, we cannot stay at `(x,y)` from time `i`. Because we are searching from the state where a previous visited piece has passed `(x,y)` at time `j`. If we stay here and block the `(x,y)`, that future cannot happen and therefore cannot be counted as a valid combination. But the piece can still pass through.\\n\\t2b. If we decide to stay at `(x,y)` from time `i`, we need to set all the `j`th bit `(j > i)` to `0`. Because we are going to stay there from now on, and if rest of pieces are settled, it can be counted as a valid combination.\\n\\t\\n\\n```\\ndef countCombinations(pieces, positions):\\n\\tD = ((), ((-1,0),(1,0),(0,-1),(0,1)),((-1,-1),(1,-1),(-1,1),(1,1)))\\n\\tP = {\"rook\":1, \"bishop\":2, \"queen\":3}\\n\\tn = len(pieces)\\n\\tM = (1<<8)-1\\n\\tT = [[M] * 9 for _ in range(9)]\\n\\t# search from ith piece\\n\\tdef dfs(i):\\n\\t\\tif i == n:\\n\\t\\t\\treturn 1\\n\\t\\tp, (x0, y0) = pieces[i], positions[i]\\n\\t\\tcnt = 0\\n\\t\\t# A piece can stay at its original position, but the counting cannot be duplicated so search here. \\n\\t\\t# No need to set 0th bit to 0 as no collision initially\\n\\t\\tif T[x0][y0] == M:  \\n\\t\\t\\tt = T[x0][y0]\\n\\t\\t\\tT[x0][y0] = 0  # set all bits to 0\\n\\t\\t\\tcnt += dfs(i+1)\\n\\t\\t\\tT[x0][y0] = t  # restore bits\\n\\t\\tfor dx, dy in D[P[p]&1]+D[P[p]&2]:\\n\\t\\t\\tx, y, b = x0+dx, y0+dy, 1\\n\\t\\t\\twhile 0 < x < 9 and 0 < y < 9 and (T[x][y] >> b & 1):  # rule 1\\n\\t\\t\\t\\tT[x][y] ^= (1 << b)  # rule 1a\\n\\t\\t\\t\\tif (T[x][y] >> b+1) == (M >> b+1):  # rule 2a\\n\\t\\t\\t\\t\\tt = T[x][y]\\n\\t\\t\\t\\t\\tT[x][y] &= (1 << b) - 1  # rule 2b\\n\\t\\t\\t\\t\\tcnt += dfs(i+1)\\n\\t\\t\\t\\t\\tT[x][y] = t  # restore\\n\\t\\t\\t\\tx, y, b = x+dx, y+dy, b+1\\n\\t\\t\\twhile b > 1:  # restore\\n\\t\\t\\t\\tT[(x:=x-dx)][(y:=y-dy)] |= (1 << (b:=b-1))\\n\\t\\treturn cnt\\n\\treturn dfs(0)\\n```",
                "solutionTags": [
                    "Python",
                    "Bitmask"
                ],
                "code": "```\\ndef countCombinations(pieces, positions):\\n\\tD = ((), ((-1,0),(1,0),(0,-1),(0,1)),((-1,-1),(1,-1),(-1,1),(1,1)))\\n\\tP = {\"rook\":1, \"bishop\":2, \"queen\":3}\\n\\tn = len(pieces)\\n\\tM = (1<<8)-1\\n\\tT = [[M] * 9 for _ in range(9)]\\n\\t# search from ith piece\\n\\tdef dfs(i):\\n\\t\\tif i == n:\\n\\t\\t\\treturn 1\\n\\t\\tp, (x0, y0) = pieces[i], positions[i]\\n\\t\\tcnt = 0\\n\\t\\t# A piece can stay at its original position, but the counting cannot be duplicated so search here. \\n\\t\\t# No need to set 0th bit to 0 as no collision initially\\n\\t\\tif T[x0][y0] == M:  \\n\\t\\t\\tt = T[x0][y0]\\n\\t\\t\\tT[x0][y0] = 0  # set all bits to 0\\n\\t\\t\\tcnt += dfs(i+1)\\n\\t\\t\\tT[x0][y0] = t  # restore bits\\n\\t\\tfor dx, dy in D[P[p]&1]+D[P[p]&2]:\\n\\t\\t\\tx, y, b = x0+dx, y0+dy, 1\\n\\t\\t\\twhile 0 < x < 9 and 0 < y < 9 and (T[x][y] >> b & 1):  # rule 1\\n\\t\\t\\t\\tT[x][y] ^= (1 << b)  # rule 1a\\n\\t\\t\\t\\tif (T[x][y] >> b+1) == (M >> b+1):  # rule 2a\\n\\t\\t\\t\\t\\tt = T[x][y]\\n\\t\\t\\t\\t\\tT[x][y] &= (1 << b) - 1  # rule 2b\\n\\t\\t\\t\\t\\tcnt += dfs(i+1)\\n\\t\\t\\t\\t\\tT[x][y] = t  # restore\\n\\t\\t\\t\\tx, y, b = x+dx, y+dy, b+1\\n\\t\\t\\twhile b > 1:  # restore\\n\\t\\t\\t\\tT[(x:=x-dx)][(y:=y-dy)] |= (1 << (b:=b-1))\\n\\t\\treturn cnt\\n\\treturn dfs(0)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1549287,
                "title": "c-recursive-solution-brute-force",
                "content": "Almost solved it during the contest (Implementation took long time). Nothing fancy just implemneting what mentioend in the problem.\\nImplemented with two functions\\n1. DFS = Build the state for each piece that is choose the number of steps to be moved(max can be 7 steps) and direction. Basically choosing the end point\\n2. BFS = At each second move the piece in choosen direction towards the destitation is possible\\n\\nNote : We can also choose not move a piece.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int bfs(vector<vector<int>>& positions,int move) {\\n\\t\\t/*\\n\\t\\t\\tPosition vector will contain 5 elements\\n\\t\\t\\t1. Inital x\\n\\t\\t\\t2. Inital y\\n\\t\\t\\t3. Direction of x\\n\\t\\t\\t4. Direction y\\n\\t\\t\\t5. steps to be moved (0 to 7)\\n\\t\\t*/\\n        int chessBoard[8][8]; // To maintain the state of board which cell is occupied\\n        memset(chessBoard, 0, sizeof(chessBoard));\\n        bool isVal = false; // To track if any element can be moved\\n        for (vector<int> &pos : positions) {\\n            int x = pos[0] + pos[4] * pos[2] , y = pos[1] + pos[4] * pos[3];\\n            if (pos[4] > move)  {\\n                isVal = true;\\n                x = pos[0] + move * pos[2], y = pos[1] + move * pos[3];\\n            }\\n            if (x < 0 || x > 7 || y < 0 || y > 7) return 0;\\n            chessBoard[x][y]++;\\n        }\\n        for (int i = 0; i < 8; i++) \\n\\t\\t\\tfor (int j = 0; j < 8; j++) \\n\\t\\t\\t\\tif (chessBoard[i][j] > 1) return 0; // More than one element\\n        int ret = 0;\\n        if (!isVal) ret = 1;\\n        else ret = bfs(positions, move + 1);\\n        return ret;\\n    }\\n    int dfs(int idx, vector<string>& pieces, vector<vector<int>>& positions) {\\n        if (idx >= pieces.size()) return bfs(positions, 0);\\n        int ret = 0;\\n        positions[idx].push_back(0);positions[idx].push_back(0);positions[idx].push_back(0);\\n        ret += dfs(idx + 1, pieces, positions); // When we decide piece will not move\\n        positions[idx].pop_back();positions[idx].pop_back();positions[idx].pop_back();\\n\\t\\t//When piece will move in choosen direction.\\n        if (pieces[idx] == \"rook\" || pieces[idx] == \"queen\") {\\n            for (int x = - 1; x <= 1; x++) if (x != 0) {\\n                for (int moves = 1; moves < 8; moves++) {\\n                    int dx = positions[idx][0] + moves * x;\\n                    if (dx >= 0 && dx < 8) {\\n                        positions[idx].push_back(x);positions[idx].push_back(0);positions[idx].push_back(moves);\\n                        ret += dfs(idx + 1, pieces, positions);\\n                        positions[idx].pop_back();positions[idx].pop_back();positions[idx].pop_back();\\n                    }\\n                }\\n            }\\n            for (int y = - 1; y <= 1; y++) if (y != 0) {\\n                for (int moves = 1; moves < 8; moves++) {\\n                    int dx = positions[idx][1] + moves * y;\\n                    if (dx >= 0 && dx < 8) {\\n                        positions[idx].push_back(0);positions[idx].push_back(y);positions[idx].push_back(moves);\\n                        ret += dfs(idx + 1, pieces, positions);\\n                        positions[idx].pop_back();positions[idx].pop_back();positions[idx].pop_back();\\n                    }\\n                }\\n            }\\n        }\\n        if (pieces[idx] == \"bishop\" || pieces[idx] == \"queen\") {\\n            for (int x = - 1; x <= 1; x++) if (x != 0) for (int y = -1; y <= 1; y++) if (y != 0) {\\n                for (int moves = 1; moves < 8; moves++) {\\n                    int dx = positions[idx][0] + moves * x;\\n                    int dy = positions[idx][1] + moves * y;\\n                    if (dx >= 0 && dx < 8 && dy >= 0 && dy < 8) {\\n                        positions[idx].push_back(x);positions[idx].push_back(y);positions[idx].push_back(moves);\\n                        ret += dfs(idx + 1, pieces, positions);\\n                        positions[idx].pop_back();positions[idx].pop_back();positions[idx].pop_back();\\n                    }\\n                }\\n            }\\n        }\\n        return ret;\\n    }\\n    int countCombinations(vector<string>& pieces, vector<vector<int>>& positions) {\\n        for (vector<int> &pos : positions)pos[0]--, pos[1]--;\\n        return dfs(0, pieces, positions);\\n        \\n    }\\n};\\n```\\nLet me know if more information is needed",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int bfs(vector<vector<int>>& positions,int move) {\\n\\t\\t/*\\n\\t\\t\\tPosition vector will contain 5 elements\\n\\t\\t\\t1. Inital x\\n\\t\\t\\t2. Inital y\\n\\t\\t\\t3. Direction of x\\n\\t\\t\\t4. Direction y\\n\\t\\t\\t5. steps to be moved (0 to 7)\\n\\t\\t*/\\n        int chessBoard[8][8]; // To maintain the state of board which cell is occupied\\n        memset(chessBoard, 0, sizeof(chessBoard));\\n        bool isVal = false; // To track if any element can be moved\\n        for (vector<int> &pos : positions) {\\n            int x = pos[0] + pos[4] * pos[2] , y = pos[1] + pos[4] * pos[3];\\n            if (pos[4] > move)  {\\n                isVal = true;\\n                x = pos[0] + move * pos[2], y = pos[1] + move * pos[3];\\n            }\\n            if (x < 0 || x > 7 || y < 0 || y > 7) return 0;\\n            chessBoard[x][y]++;\\n        }\\n        for (int i = 0; i < 8; i++) \\n\\t\\t\\tfor (int j = 0; j < 8; j++) \\n\\t\\t\\t\\tif (chessBoard[i][j] > 1) return 0; // More than one element\\n        int ret = 0;\\n        if (!isVal) ret = 1;\\n        else ret = bfs(positions, move + 1);\\n        return ret;\\n    }\\n    int dfs(int idx, vector<string>& pieces, vector<vector<int>>& positions) {\\n        if (idx >= pieces.size()) return bfs(positions, 0);\\n        int ret = 0;\\n        positions[idx].push_back(0);positions[idx].push_back(0);positions[idx].push_back(0);\\n        ret += dfs(idx + 1, pieces, positions); // When we decide piece will not move\\n        positions[idx].pop_back();positions[idx].pop_back();positions[idx].pop_back();\\n\\t\\t//When piece will move in choosen direction.\\n        if (pieces[idx] == \"rook\" || pieces[idx] == \"queen\") {\\n            for (int x = - 1; x <= 1; x++) if (x != 0) {\\n                for (int moves = 1; moves < 8; moves++) {\\n                    int dx = positions[idx][0] + moves * x;\\n                    if (dx >= 0 && dx < 8) {\\n                        positions[idx].push_back(x);positions[idx].push_back(0);positions[idx].push_back(moves);\\n                        ret += dfs(idx + 1, pieces, positions);\\n                        positions[idx].pop_back();positions[idx].pop_back();positions[idx].pop_back();\\n                    }\\n                }\\n            }\\n            for (int y = - 1; y <= 1; y++) if (y != 0) {\\n                for (int moves = 1; moves < 8; moves++) {\\n                    int dx = positions[idx][1] + moves * y;\\n                    if (dx >= 0 && dx < 8) {\\n                        positions[idx].push_back(0);positions[idx].push_back(y);positions[idx].push_back(moves);\\n                        ret += dfs(idx + 1, pieces, positions);\\n                        positions[idx].pop_back();positions[idx].pop_back();positions[idx].pop_back();\\n                    }\\n                }\\n            }\\n        }\\n        if (pieces[idx] == \"bishop\" || pieces[idx] == \"queen\") {\\n            for (int x = - 1; x <= 1; x++) if (x != 0) for (int y = -1; y <= 1; y++) if (y != 0) {\\n                for (int moves = 1; moves < 8; moves++) {\\n                    int dx = positions[idx][0] + moves * x;\\n                    int dy = positions[idx][1] + moves * y;\\n                    if (dx >= 0 && dx < 8 && dy >= 0 && dy < 8) {\\n                        positions[idx].push_back(x);positions[idx].push_back(y);positions[idx].push_back(moves);\\n                        ret += dfs(idx + 1, pieces, positions);\\n                        positions[idx].pop_back();positions[idx].pop_back();positions[idx].pop_back();\\n                    }\\n                }\\n            }\\n        }\\n        return ret;\\n    }\\n    int countCombinations(vector<string>& pieces, vector<vector<int>>& positions) {\\n        for (vector<int> &pos : positions)pos[0]--, pos[1]--;\\n        return dfs(0, pieces, positions);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3670338,
                "title": "generate-and-simulate",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int countCombinations(vector<string>& pieces, vector<vector<int>>& positions) {\\n        vector<pair<int,int>> moves{{1,0},{-1,0},{0,1},{0,-1},{1,1},{1,-1},{-1,1},{-1,-1}};\\n        vector<pair<int,int>> dest(pieces.size());\\n        vector<int> move(pieces.size());\\n        int result = 0;\\n\\n        function<bool()> simulate = [&]() {\\n            vector<vector<int>> pos = positions;\\n\\n            while(true) {\\n                bool finished = true;\\n\\n                // move all pieces by 1 square\\n                for(int i=0; i<pieces.size(); i++) {\\n                    int sx = pos[i][0]-1, sy = pos[i][1]-1;\\n                    auto [tx, ty] = dest[i];\\n\\n                    if(sx != tx or sy != ty) {\\n                        finished = false;\\n                        auto [dx, dy] = moves[move[i]];\\n                        pos[i][0] += dx;\\n                        pos[i][1] += dy;\\n                    }\\n                }\\n\\n                // check for collisions\\n                for(int i=0; i<pieces.size(); i++) {\\n                    for(int j=i+1; j<pieces.size(); j++) {\\n                        if(pos[i][0] == pos[j][0] and pos[i][1] == pos[j][1]) return false;\\n                    }\\n                }\\n\\n                if(finished) break;\\n            }\\n\\n            return true;\\n        };\\n\\n        function<void(int)> generate = [&](int i) {\\n            if(i == pieces.size()) {\\n                result += simulate();\\n                return;\\n            }\\n\\n            int start, end;\\n\\n            if(pieces[i] == \"rook\") start = 0, end = 3;\\n            else if(pieces[i] == \"bishop\") start = 4, end = 7;\\n            else start = 0, end = 7;\\n\\n            dest[i] = {positions[i][0]-1, positions[i][1]-1};\\n            generate(i+1);\\n            \\n            for(int j=start; j<=end; j++) {\\n                auto [dx, dy] = moves[j];\\n                move[i] = j;\\n\\n                for(int x = positions[i][0]-1+dx, y = positions[i][1]-1+dy; x>=0 and x<8 and y>=0 and y<8; x += dx, y += dy) {\\n                    dest[i] = {x, y};\\n                    generate(i+1);\\n                }\\n            }\\n        };\\n\\n        generate(0);\\n\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countCombinations(vector<string>& pieces, vector<vector<int>>& positions) {\\n        vector<pair<int,int>> moves{{1,0},{-1,0},{0,1},{0,-1},{1,1},{1,-1},{-1,1},{-1,-1}};\\n        vector<pair<int,int>> dest(pieces.size());\\n        vector<int> move(pieces.size());\\n        int result = 0;\\n\\n        function<bool()> simulate = [&]() {\\n            vector<vector<int>> pos = positions;\\n\\n            while(true) {\\n                bool finished = true;\\n\\n                // move all pieces by 1 square\\n                for(int i=0; i<pieces.size(); i++) {\\n                    int sx = pos[i][0]-1, sy = pos[i][1]-1;\\n                    auto [tx, ty] = dest[i];\\n\\n                    if(sx != tx or sy != ty) {\\n                        finished = false;\\n                        auto [dx, dy] = moves[move[i]];\\n                        pos[i][0] += dx;\\n                        pos[i][1] += dy;\\n                    }\\n                }\\n\\n                // check for collisions\\n                for(int i=0; i<pieces.size(); i++) {\\n                    for(int j=i+1; j<pieces.size(); j++) {\\n                        if(pos[i][0] == pos[j][0] and pos[i][1] == pos[j][1]) return false;\\n                    }\\n                }\\n\\n                if(finished) break;\\n            }\\n\\n            return true;\\n        };\\n\\n        function<void(int)> generate = [&](int i) {\\n            if(i == pieces.size()) {\\n                result += simulate();\\n                return;\\n            }\\n\\n            int start, end;\\n\\n            if(pieces[i] == \"rook\") start = 0, end = 3;\\n            else if(pieces[i] == \"bishop\") start = 4, end = 7;\\n            else start = 0, end = 7;\\n\\n            dest[i] = {positions[i][0]-1, positions[i][1]-1};\\n            generate(i+1);\\n            \\n            for(int j=start; j<=end; j++) {\\n                auto [dx, dy] = moves[j];\\n                move[i] = j;\\n\\n                for(int x = positions[i][0]-1+dx, y = positions[i][1]-1+dy; x>=0 and x<8 and y>=0 and y<8; x += dx, y += dy) {\\n                    dest[i] = {x, y};\\n                    generate(i+1);\\n                }\\n            }\\n        };\\n\\n        generate(0);\\n\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3247280,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn count_combinations(pieces: Vec<String>, positions: Vec<Vec<i32>>) -> i32 {\\n        let dir = [[0, 1], [1, 0], [0, -1], [-1, 0], [1, 1], [1, -1], [-1, -1], [-1, 1]];\\n        let mut b = [[[0; 8]; 8]; 4];\\n\\n        fn _count_combinations(\\n            pieces: &[String],\\n            pos: &[Vec<i32>],\\n            p: usize,\\n            dir: &[[i32; 2]],\\n            b: &mut [[[i32; 8]; 8]; 4],\\n        ) -> i32 {\\n            if p >= pieces.len() {\\n                return 1;\\n            }\\n            let i = pos[p][0] - 1;\\n            let j = pos[p][1] - 1;\\n            let mut res = 0;\\n            for d in 0..8 {\\n                if (d < 4 && pieces[p] == \"bishop\") || (d >= 4 && pieces[p] == \"rook\") {\\n                    continue;\\n                }\\n                let mut blocked = false;\\n                let mut step = if res == 0 { 1 } else { 2 };\\n                loop {\\n                    if blocked {\\n                        break;\\n                    }\\n                    let x = i + (step - 1) * dir[d][0];\\n                    let y = j + (step - 1) * dir[d][1];\\n                    if x.min(y) < 0 || x.max(y) > 7 {\\n                        break;\\n                    }\\n                    let (x, y) = (x as usize, y as usize);\\n                    let mut can_stop = true;\\n                    for b_pp in b.iter() {\\n                        can_stop &= b_pp[x][y] >= 0 && b_pp[x][y] < step;\\n                        blocked |= (b_pp[x][y] < 0 && -b_pp[x][y] <= step) || (b_pp[x][y] == step);\\n                    }\\n                    if can_stop {\\n                        b[p][x][y] = -step;\\n                        res += _count_combinations(pieces, pos, p + 1, dir, b);\\n                    }\\n                    b[p][x][y] = step;\\n                    step += 1;\\n                }\\n                for b_p in b[p].iter_mut() {\\n                    for b_p_x in b_p.iter_mut() {\\n                        *b_p_x = 0;\\n                    }\\n                }\\n            }\\n            res\\n        }\\n\\n        _count_combinations(&pieces, &positions, 0, &dir, &mut b)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn count_combinations(pieces: Vec<String>, positions: Vec<Vec<i32>>) -> i32 {\\n        let dir = [[0, 1], [1, 0], [0, -1], [-1, 0], [1, 1], [1, -1], [-1, -1], [-1, 1]];\\n        let mut b = [[[0; 8]; 8]; 4];\\n\\n        fn _count_combinations(\\n            pieces: &[String],\\n            pos: &[Vec<i32>],\\n            p: usize,\\n            dir: &[[i32; 2]],\\n            b: &mut [[[i32; 8]; 8]; 4],\\n        ) -> i32 {\\n            if p >= pieces.len() {\\n                return 1;\\n            }\\n            let i = pos[p][0] - 1;\\n            let j = pos[p][1] - 1;\\n            let mut res = 0;\\n            for d in 0..8 {\\n                if (d < 4 && pieces[p] == \"bishop\") || (d >= 4 && pieces[p] == \"rook\") {\\n                    continue;\\n                }\\n                let mut blocked = false;\\n                let mut step = if res == 0 { 1 } else { 2 };\\n                loop {\\n                    if blocked {\\n                        break;\\n                    }\\n                    let x = i + (step - 1) * dir[d][0];\\n                    let y = j + (step - 1) * dir[d][1];\\n                    if x.min(y) < 0 || x.max(y) > 7 {\\n                        break;\\n                    }\\n                    let (x, y) = (x as usize, y as usize);\\n                    let mut can_stop = true;\\n                    for b_pp in b.iter() {\\n                        can_stop &= b_pp[x][y] >= 0 && b_pp[x][y] < step;\\n                        blocked |= (b_pp[x][y] < 0 && -b_pp[x][y] <= step) || (b_pp[x][y] == step);\\n                    }\\n                    if can_stop {\\n                        b[p][x][y] = -step;\\n                        res += _count_combinations(pieces, pos, p + 1, dir, b);\\n                    }\\n                    b[p][x][y] = step;\\n                    step += 1;\\n                }\\n                for b_p in b[p].iter_mut() {\\n                    for b_p_x in b_p.iter_mut() {\\n                        *b_p_x = 0;\\n                    }\\n                }\\n            }\\n            res\\n        }\\n\\n        _count_combinations(&pieces, &positions, 0, &dir, &mut b)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2923103,
                "title": "question-is-confusing-and-can-do-better",
                "content": "As usual, when I see a question with many downvotes, most likely it means  that the question was confusing at best if not misleading. This question is no exception.\\n\\nAnyways, the best wording that would have helped (atleast for me) is to make the ask as \"number of all possible destinations\" to move to given the constraints of direction, collision, etc. \\n\\nAnd one example with two pieces would have helped immensely.\\n\\nAlso, easily could have made the question less verbose.",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "As usual, when I see a question with many downvotes, most likely it means  that the question was confusing at best if not misleading. This question is no exception.\\n\\nAnyways, the best wording that would have helped (atleast for me) is to make the ask as \"number of all possible destinations\" to move to given the constraints of direction, collision, etc. \\n\\nAnd one example with two pieces would have helped immensely.\\n\\nAlso, easily could have made the question less verbose.",
                "codeTag": "Unknown"
            },
            {
                "id": 2501847,
                "title": "go-explanation-exhaustive-search-faster-100",
                "content": "![image](https://assets.leetcode.com/users/images/bcf581ab-aff7-4530-b214-fe1125162e9c_1661803863.1635.png)\\n### Explanation\\n1. For each piece generate list of all reachable fields.\\n2. Generate all possible final positions of pieces using lists from step #1\\n3. Define function that checks if trajectories of piece1 startField1 -> endField1 and piece2 startField2 -> endField2 clash\\n4. Apply function from step #3 to each pair from each final posiiton from step 2. If some trajectories will clash, then current final position is invalid. Else increase answer by 1. \\n```\\ntype Field struct {\\n\\tx int\\n\\ty int\\n}\\n\\nfunc (p *Field) Equal(other Field) bool {\\n\\treturn p.x == other.x && p.y == other.y\\n}\\n\\nfunc (p *Field) MoveTowards(other Field) {\\n\\tif p.x < other.x {\\n\\t\\tp.x += 1\\n\\t}\\n\\tif p.x > other.x {\\n\\t\\tp.x -= 1\\n\\t}\\n\\tif p.y < other.y {\\n\\t\\tp.y += 1\\n\\t}\\n\\tif p.y > other.y {\\n\\t\\tp.y -= 1\\n\\t}\\n}\\n\\nfunc (p *Field) Move(dir Field) Field {\\n\\treturn Field{p.x + dir.x, p.y + dir.y}\\t\\n}\\n\\nfunc (p *Field) IsValid() bool {\\n\\treturn p.x >= 1 && p.x <= 8 && p.y >= 1 && p.y <= 8\\n}\\n\\nfunc (p *Field) Copy() Field{\\n\\treturn Field{p.x, p.y}\\n}\\n\\nfunc willClash(start1, end1, start2, end2 Field) bool {\\n\\tfor !start1.Equal(end1) || !start2.Equal(end2) {\\n\\t\\tstart1.MoveTowards(end1)\\n\\t\\tstart2.MoveTowards(end2)\\n\\t\\tif start1.Equal(start2) {\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\t}\\n\\treturn false\\n}\\n\\nfunc getPossibleMoves(piece string, startField Field) (result []Field) {\\n\\thorisontalMoves := []Field{{1, 0}, {0, 1}, {-1, 0}, {0, -1}}\\n\\tdiagnoalMoves := []Field{{1, 1}, {-1, 1}, {1, -1}, {-1, -1}}\\n\\n\\tfindAllPossibleMoves := func(startField Field, directions[] Field) (possibleMoves []Field) {\\n\\t\\tfor _, dir := range directions {\\n\\t\\t\\tcurrentField := startField.Move(dir)\\n\\t\\t\\tfor currentField.IsValid(){\\n\\t\\t\\t\\tpossibleMoves = append(possibleMoves, currentField)\\n\\t\\t\\t\\tcurrentField = currentField.Move(dir)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn\\n\\t}\\n\\n\\tresult = append(result, startField)\\n\\tswitch piece {\\n\\t\\tcase \"rook\": {\\n\\t\\t\\tresult = append(result, findAllPossibleMoves(startField, horisontalMoves)...)\\n\\t\\t}\\n\\t\\tcase \"bishop\": {\\n\\t\\t\\tresult = append(result, findAllPossibleMoves(startField, diagnoalMoves)...)\\n\\t\\t}\\n\\t\\tcase \"queen\": {\\n\\t\\t\\tresult = append(result, findAllPossibleMoves(startField, horisontalMoves)...)\\n\\t\\t\\tresult = append(result, findAllPossibleMoves(startField, diagnoalMoves)...)\\n\\t\\t}\\n\\t\\tdefault : {\\n\\t\\t\\tpanic(\"No such piece exists\")\\n\\t\\t}\\n\\t}\\n\\treturn\\n}\\n\\nfunc isValidEndFields(startFields, endFields []Field) bool {\\n\\tfor i:=0; i<len(startFields); i++ {\\n\\t\\tfor j:=0; j<i; j++ {\\n\\t\\t\\tif willClash(startFields[i], endFields[i], startFields[j], endFields[j]) {\\n\\t\\t\\t\\treturn false\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn true\\n}\\n\\nfunc countCombinations(pieces []string, positions [][]int) int {\\n\\tpiecesCount := len(pieces)\\n\\tstartFields := []Field{}\\n\\tfor _, pos := range positions {\\n\\t\\tstartFields = append(startFields, Field{pos[0], pos[1]})\\n\\t}\\n\\n\\tvar search func(pos int, endFields []Field) int \\n\\t\\n\\tsearch = func(pos int, endFields []Field) int {\\n\\t\\tif pos == piecesCount {\\n\\t\\t\\tif isValidEndFields(startFields, endFields) {\\n\\t\\t\\t\\treturn 1\\n\\t\\t\\t} else {\\n\\t\\t\\t\\treturn 0\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tres := 0\\n\\t\\tpossibleMoves := getPossibleMoves(pieces[pos], startFields[pos])\\n\\t\\tfor _, move := range possibleMoves {\\n\\t\\t\\tendFields[pos] = move\\n\\t\\t\\tres += search(pos+1, endFields)\\t\\n\\t\\t}\\n\\t\\treturn res\\n\\t}\\n\\n\\treturn search(0, make([]Field, len(pieces)))\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\ntype Field struct {\\n\\tx int\\n\\ty int\\n}\\n\\nfunc (p *Field) Equal(other Field) bool {\\n\\treturn p.x == other.x && p.y == other.y\\n}\\n\\nfunc (p *Field) MoveTowards(other Field) {\\n\\tif p.x < other.x {\\n\\t\\tp.x += 1\\n\\t}\\n\\tif p.x > other.x {\\n\\t\\tp.x -= 1\\n\\t}\\n\\tif p.y < other.y {\\n\\t\\tp.y += 1\\n\\t}\\n\\tif p.y > other.y {\\n\\t\\tp.y -= 1\\n\\t}\\n}\\n\\nfunc (p *Field) Move(dir Field) Field {\\n\\treturn Field{p.x + dir.x, p.y + dir.y}\\t\\n}\\n\\nfunc (p *Field) IsValid() bool {\\n\\treturn p.x >= 1 && p.x <= 8 && p.y >= 1 && p.y <= 8\\n}\\n\\nfunc (p *Field) Copy() Field{\\n\\treturn Field{p.x, p.y}\\n}\\n\\nfunc willClash(start1, end1, start2, end2 Field) bool {\\n\\tfor !start1.Equal(end1) || !start2.Equal(end2) {\\n\\t\\tstart1.MoveTowards(end1)\\n\\t\\tstart2.MoveTowards(end2)\\n\\t\\tif start1.Equal(start2) {\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\t}\\n\\treturn false\\n}\\n\\nfunc getPossibleMoves(piece string, startField Field) (result []Field) {\\n\\thorisontalMoves := []Field{{1, 0}, {0, 1}, {-1, 0}, {0, -1}}\\n\\tdiagnoalMoves := []Field{{1, 1}, {-1, 1}, {1, -1}, {-1, -1}}\\n\\n\\tfindAllPossibleMoves := func(startField Field, directions[] Field) (possibleMoves []Field) {\\n\\t\\tfor _, dir := range directions {\\n\\t\\t\\tcurrentField := startField.Move(dir)\\n\\t\\t\\tfor currentField.IsValid(){\\n\\t\\t\\t\\tpossibleMoves = append(possibleMoves, currentField)\\n\\t\\t\\t\\tcurrentField = currentField.Move(dir)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn\\n\\t}\\n\\n\\tresult = append(result, startField)\\n\\tswitch piece {\\n\\t\\tcase \"rook\": {\\n\\t\\t\\tresult = append(result, findAllPossibleMoves(startField, horisontalMoves)...)\\n\\t\\t}\\n\\t\\tcase \"bishop\": {\\n\\t\\t\\tresult = append(result, findAllPossibleMoves(startField, diagnoalMoves)...)\\n\\t\\t}\\n\\t\\tcase \"queen\": {\\n\\t\\t\\tresult = append(result, findAllPossibleMoves(startField, horisontalMoves)...)\\n\\t\\t\\tresult = append(result, findAllPossibleMoves(startField, diagnoalMoves)...)\\n\\t\\t}\\n\\t\\tdefault : {\\n\\t\\t\\tpanic(\"No such piece exists\")\\n\\t\\t}\\n\\t}\\n\\treturn\\n}\\n\\nfunc isValidEndFields(startFields, endFields []Field) bool {\\n\\tfor i:=0; i<len(startFields); i++ {\\n\\t\\tfor j:=0; j<i; j++ {\\n\\t\\t\\tif willClash(startFields[i], endFields[i], startFields[j], endFields[j]) {\\n\\t\\t\\t\\treturn false\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn true\\n}\\n\\nfunc countCombinations(pieces []string, positions [][]int) int {\\n\\tpiecesCount := len(pieces)\\n\\tstartFields := []Field{}\\n\\tfor _, pos := range positions {\\n\\t\\tstartFields = append(startFields, Field{pos[0], pos[1]})\\n\\t}\\n\\n\\tvar search func(pos int, endFields []Field) int \\n\\t\\n\\tsearch = func(pos int, endFields []Field) int {\\n\\t\\tif pos == piecesCount {\\n\\t\\t\\tif isValidEndFields(startFields, endFields) {\\n\\t\\t\\t\\treturn 1\\n\\t\\t\\t} else {\\n\\t\\t\\t\\treturn 0\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tres := 0\\n\\t\\tpossibleMoves := getPossibleMoves(pieces[pos], startFields[pos])\\n\\t\\tfor _, move := range possibleMoves {\\n\\t\\t\\tendFields[pos] = move\\n\\t\\t\\tres += search(pos+1, endFields)\\t\\n\\t\\t}\\n\\t\\treturn res\\n\\t}\\n\\n\\treturn search(0, make([]Field, len(pieces)))\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2451262,
                "title": "bad-problem-just-generate-all-java-90-speed",
                "content": "#### Bad Problem Statement\\nVery confusing problem statement because I don\\'t know if \\n`{Rook A, Rook B} = {[1, 1], [2, 2]}` \\n`{Rook A, Rook B} = {[2, 2], [1, 1]}` \\nare considered the same or not? \\nJudging from the example photos they give us, these 2 combinations look exactly the same, so do they count as 1 or 2?\\n\\n#### Outline\\nEach piece has all the moves specifies by the problem + `{0, 0}`, meaning not move at all.\\nso, what we can do is, generate all destinations for each piece first, and then simulate the process to make sure no piece collides in the process.\\nWe don\\'t need the board because we already have the positions give to us.\\nIn order to simulate the process properly, we will also track its direction.\\n\\n#### In Summary\\n1. Generate all destinations and the direction needed for each piece to move there.\\n2. Simulate the process and check for each piece after it moves that it doesn\\'t run into previous pieces.\\n3. If we can reach the destinations for all pieces, then add 1 to answer.\\n\\n`Runtime 60 ms (Beat 90%)`\\n`Memory 40.1 MB (Beat 100%)`\\n```Java\\nclass Solution {\\n    int[][][] all = new int[][][]{\\n        {{0, 0}, {1, 0}, {-1, 0}, {0, -1}, {0, 1}}, // Rook\\n        {{0, 0}, {1, -1}, {1, 1}, {-1, 1}, {-1, -1}}, // Bishop\\n        {{0, 0}, {1, 0}, {-1, 0}, {0, -1}, {0, 1}, {1, 1}, {1, -1}, {-1, 1}, {-1, -1}} // queen\\n    };\\n    int ROOK   = 0;\\n    int BISHOP = 1;\\n    int QUEEN  = 2;\\n    int[] type; // what type does piece[i] has?\\n    int[][] A; // our current position for each piece\\n    public int countCombinations(String[] pieces, int[][] positions) {\\n        A = positions;\\n        type = new int[pieces.length];\\n        for (int[] a : A){ // make it 0 index first\\n            a[0]--; a[1]--;\\n        }\\n        for (int i = 0; i < pieces.length; i++){ // assign the type for each piece\\n            type[i] = switch(pieces[i]){\\n                case \"rook\"   : yield ROOK;\\n                case \"bishop\" : yield BISHOP;\\n                default       : yield QUEEN;\\n            };\\n        }\\n        return choose(0, new int[A.length], new int[A.length][2]); // choose all destinations and return the sum of it\\n    }\\n\\n    private int choose(int idx, int[] dir, int[][] dest){\\n        if (idx == A.length){ // now solve for this destination\\n            return solve(0, dir, dest);\\n        }\\n        int ans = 0;\\n        for (int i = 0; i < all[type[idx]].length; i++){ // first we choose direction\\n            int[] d = all[type[idx]][i];\\n            int nx = A[idx][0] + d[0], ny = A[idx][1] + d[1];\\n            dir[idx] = i;\\n            while(nx >= 0 && nx < 8 && ny >= 0 && ny < 8){ // then we move the destination along that direction for each piece\\n                dest[idx][0] = nx; // we can add a check to make sure no dup dest, but it is not really faster.\\n                dest[idx][1] = ny;\\n                ans += choose(idx+1, dir, dest);\\n                if (i == 0){ // i = 0 -> needs to break because it doesn\\'t move\\n                    break;\\n                }\\n                nx += d[0];\\n                ny += d[1];\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    private int solve(int idx, int[] dir, int[][] dest){\\n        if (idx == A.length){ // at the end of 1 second.\\n            boolean ok = true;\\n            for (int i = 0; i < A.length && ok; i++){ // check if all pieces have reached the dest\\n                ok &= A[i][0] == dest[i][0] && A[i][1] == dest[i][1];\\n            }\\n            return ok? 1 : solve(0, dir, dest); // if yes, return 1, if not, go for the next second.\\n        }\\n        int j = dest[idx][0] == A[idx][0] && dest[idx][1] == A[idx][1]? 0 : dir[idx]; // changed dir to 0 if it is at the destination, so it doesn\\'t move\\n        int[] d = all[type[idx]][j];\\n        A[idx][0] += d[0];\\n        A[idx][1] += d[1];\\n        boolean bad = false;\\n        for (int i = 0; i < idx && !bad; i++){ // check if it collides with any previous pieces\\n            bad |= A[idx][0] == A[i][0] && A[idx][1] == A[i][1];\\n        }\\n        int ans = bad? 0 : solve(idx+1, dir, dest); // if it does, return 0, if not, solve for the next piece.\\n        A[idx][0] -= d[0];\\n        A[idx][1] -= d[1];\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```Java\\nclass Solution {\\n    int[][][] all = new int[][][]{\\n        {{0, 0}, {1, 0}, {-1, 0}, {0, -1}, {0, 1}}, // Rook\\n        {{0, 0}, {1, -1}, {1, 1}, {-1, 1}, {-1, -1}}, // Bishop\\n        {{0, 0}, {1, 0}, {-1, 0}, {0, -1}, {0, 1}, {1, 1}, {1, -1}, {-1, 1}, {-1, -1}} // queen\\n    };\\n    int ROOK   = 0;\\n    int BISHOP = 1;\\n    int QUEEN  = 2;\\n    int[] type; // what type does piece[i] has?\\n    int[][] A; // our current position for each piece\\n    public int countCombinations(String[] pieces, int[][] positions) {\\n        A = positions;\\n        type = new int[pieces.length];\\n        for (int[] a : A){ // make it 0 index first\\n            a[0]--; a[1]--;\\n        }\\n        for (int i = 0; i < pieces.length; i++){ // assign the type for each piece\\n            type[i] = switch(pieces[i]){\\n                case \"rook\"   : yield ROOK;\\n                case \"bishop\" : yield BISHOP;\\n                default       : yield QUEEN;\\n            };\\n        }\\n        return choose(0, new int[A.length], new int[A.length][2]); // choose all destinations and return the sum of it\\n    }\\n\\n    private int choose(int idx, int[] dir, int[][] dest){\\n        if (idx == A.length){ // now solve for this destination\\n            return solve(0, dir, dest);\\n        }\\n        int ans = 0;\\n        for (int i = 0; i < all[type[idx]].length; i++){ // first we choose direction\\n            int[] d = all[type[idx]][i];\\n            int nx = A[idx][0] + d[0], ny = A[idx][1] + d[1];\\n            dir[idx] = i;\\n            while(nx >= 0 && nx < 8 && ny >= 0 && ny < 8){ // then we move the destination along that direction for each piece\\n                dest[idx][0] = nx; // we can add a check to make sure no dup dest, but it is not really faster.\\n                dest[idx][1] = ny;\\n                ans += choose(idx+1, dir, dest);\\n                if (i == 0){ // i = 0 -> needs to break because it doesn\\'t move\\n                    break;\\n                }\\n                nx += d[0];\\n                ny += d[1];\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    private int solve(int idx, int[] dir, int[][] dest){\\n        if (idx == A.length){ // at the end of 1 second.\\n            boolean ok = true;\\n            for (int i = 0; i < A.length && ok; i++){ // check if all pieces have reached the dest\\n                ok &= A[i][0] == dest[i][0] && A[i][1] == dest[i][1];\\n            }\\n            return ok? 1 : solve(0, dir, dest); // if yes, return 1, if not, go for the next second.\\n        }\\n        int j = dest[idx][0] == A[idx][0] && dest[idx][1] == A[idx][1]? 0 : dir[idx]; // changed dir to 0 if it is at the destination, so it doesn\\'t move\\n        int[] d = all[type[idx]][j];\\n        A[idx][0] += d[0];\\n        A[idx][1] += d[1];\\n        boolean bad = false;\\n        for (int i = 0; i < idx && !bad; i++){ // check if it collides with any previous pieces\\n            bad |= A[idx][0] == A[i][0] && A[idx][1] == A[i][1];\\n        }\\n        int ans = bad? 0 : solve(idx+1, dir, dest); // if it does, return 0, if not, solve for the next piece.\\n        A[idx][0] -= d[0];\\n        A[idx][1] -= d[1];\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2408269,
                "title": "python-dfs-bitmask",
                "content": "Here is a python version of the dfs approach using bitmask.\\nidea:\\n(1) represent the items\\' direction with a bitmask, max choice is 8, so 3 bits is enough for each piece. at most 4 pieces. 12 bits suffices.\\n(2) for each legal direction for the pieces,  we iterate the states of the pieces status: i.e, in transition or stopped(in final position);\\n(3) in the dfs, we update the new next position and pieces status.\\n(4) all final status of the pieces are represented as a hashval in a set.\\n\\n```\\ndef countCombinations(self, pieces: List[str], positions: List[List[int]]) -> int:\\n        direct=[[-1,0], [1,0],[0,1],[0,-1],[-1,1], [1,1],[-1,-1],[1,-1]]\\n        rets=set()\\n        n=len(pieces)\\n        def dfs(pos, dirs, state):\\n            nonlocal rets,n,direct\\n            for sub in range(state+1,1,-1):\\n                substate=(sub-1)&state\\n                if substate==0:continue\\n                pos2=[ [x,y] for x,y in pos]\\n                flag=1\\n                for i in range(n):\\n                    if not ((substate>>i)&1):continue\\n                    pos2[i][0]+=direct[dirs[i]][0]\\n                    pos2[i][1]+=direct[dirs[i]][1]\\n                    if min(pos2[i])<1 or max(pos2[i])>8:\\n                        flag=0\\n                        break\\n                if flag==0:continue\\n                if duplicate(pos2):continue\\n                hashval=gethash(pos2)\\n                if hashval in rets:continue\\n                rets.add(hashval)\\n                dfs(pos2,dirs,substate)\\n                    \\n        def duplicate(pos):\\n            s=set()\\n            for x,y in pos:\\n                val=10*x+y\\n                s.add(val)\\n            return len(s)<len(pos)\\n        def gethash(pos):\\n            ret=0\\n            for x,y in pos:\\n                ret=ret*100+10*x+y\\n            return ret\\n            \\n        #main part, state: direction state \\n        for state in range(1<<(3*n)):\\n            flag=1\\n            dirs=[0]*n\\n            for k in range(n):\\n                d=(state>>(3*k))%8\\n                if pieces[k]==\\'rook\\' and d>3:\\n                    flag=0\\n                    break\\n                if pieces[k]==\\'bishop\\' and d<4:\\n                    flag=0\\n                    break\\n                dirs[k]=d\\n            if flag:\\n                dfs(positions, dirs, (1<<n)-1)\\n        return len(rets)+1",
                "solutionTags": [],
                "code": "Here is a python version of the dfs approach using bitmask.\\nidea:\\n(1) represent the items\\' direction with a bitmask, max choice is 8, so 3 bits is enough for each piece. at most 4 pieces. 12 bits suffices.\\n(2) for each legal direction for the pieces,  we iterate the states of the pieces status: i.e, in transition or stopped(in final position);\\n(3) in the dfs, we update the new next position and pieces status.\\n(4) all final status of the pieces are represented as a hashval in a set.\\n\\n```\\ndef countCombinations(self, pieces: List[str], positions: List[List[int]]) -> int:\\n        direct=[[-1,0], [1,0],[0,1],[0,-1],[-1,1], [1,1],[-1,-1],[1,-1]]\\n        rets=set()\\n        n=len(pieces)\\n        def dfs(pos, dirs, state):\\n            nonlocal rets,n,direct\\n            for sub in range(state+1,1,-1):\\n                substate=(sub-1)&state\\n                if substate==0:continue\\n                pos2=[ [x,y] for x,y in pos]\\n                flag=1\\n                for i in range(n):\\n                    if not ((substate>>i)&1):continue\\n                    pos2[i][0]+=direct[dirs[i]][0]\\n                    pos2[i][1]+=direct[dirs[i]][1]\\n                    if min(pos2[i])<1 or max(pos2[i])>8:\\n                        flag=0\\n                        break\\n                if flag==0:continue\\n                if duplicate(pos2):continue\\n                hashval=gethash(pos2)\\n                if hashval in rets:continue\\n                rets.add(hashval)\\n                dfs(pos2,dirs,substate)\\n                    \\n        def duplicate(pos):\\n            s=set()\\n            for x,y in pos:\\n                val=10*x+y\\n                s.add(val)\\n            return len(s)<len(pos)\\n        def gethash(pos):\\n            ret=0\\n            for x,y in pos:\\n                ret=ret*100+10*x+y\\n            return ret\\n            \\n        #main part, state: direction state \\n        for state in range(1<<(3*n)):\\n            flag=1\\n            dirs=[0]*n\\n            for k in range(n):\\n                d=(state>>(3*k))%8\\n                if pieces[k]==\\'rook\\' and d>3:\\n                    flag=0\\n                    break\\n                if pieces[k]==\\'bishop\\' and d<4:\\n                    flag=0\\n                    break\\n                dirs[k]=d\\n            if flag:\\n                dfs(positions, dirs, (1<<n)-1)\\n        return len(rets)+1",
                "codeTag": "Python3"
            },
            {
                "id": 2403017,
                "title": "c-a-very-clean-readable-solution-dfs-straightforward",
                "content": "#### C++\\n```c++\\nstruct point {\\n  int x, y;\\n  bool operator==(const point& other) { return x == other.x && y == other.y; }\\n  bool operator!=(const point& other) { return x != other.x || y != other.y; }\\n  void moveTowards(const point& other) {\\n    x += x == other.x ? 0 : other.x > x ? 1 : -1;\\n    y += y == other.y ? 0 : other.y > y ? 1 : -1;\\n  }\\n};\\n\\nvector<point> horizontalSteps = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\nvector<point> diagonalSteps = {{1, 1}, {1, -1}, {-1, 1}, {-1, -1}};\\n\\nclass Solution {\\n public:\\n  vector<point> positions;\\n \\n  // `rook` takes the horizontal moves, `bishop` takes the diagonal ones\\n  // `queen` takes both horizontal and diagonal\\n  vector<point> getMoves(string piece, point p) {\\n    vector<point> res{{p.x, p.y}};\\n\\n    if (piece == \"rook\" || piece == \"queen\") {\\n      for (auto step : horizontalSteps) {\\n        int i = p.x + step.x, j = p.y + step.y;\\n        while (i >= 0 && i < 8 && j >= 0 && j < 8) {\\n          res.push_back({i, j});\\n          i += step.x;\\n          j += step.y;\\n        }\\n      }\\n    }\\n\\n    if (piece == \"bishop\" || piece == \"queen\") {\\n      for (auto step : diagonalSteps) {\\n        int i = p.x + step.x, j = p.y + step.y;\\n        while (i >= 0 && i < 8 && j >= 0 && j < 8) {\\n          res.push_back({i, j});\\n          i += step.x;\\n          j += step.y;\\n        }\\n      }\\n    }\\n\\n    return res;\\n  }\\n\\n  bool willIntersect(point a, point a2, point b, point b2) {\\n    // move each start position towards the end position and see if they intersect at any time\\n    while (a != a2 || b != b2) {\\n      a.moveTowards(a2);\\n      b.moveTowards(b2);\\n\\n      if (a == b) return true;\\n    }\\n\\n    return false;\\n  }\\n\\n  bool isValidDestination(vector<point>& dest) {\\n    for (int i = 0; i < dest.size(); i++)\\n      for (int j = 0; j < i; j++)\\n        if (willIntersect(positions[i], dest[i], positions[j], dest[j])) return false;\\n\\n    return true;\\n  }\\n\\n  int dfs(int i, vector<string>& pieces, vector<point>& destination) {\\n    if (i == pieces.size()) {\\n      return isValidDestination(destination) ? 1 : 0;\\n    }\\n\\n    int res = 0;\\n    for (auto move : getMoves(pieces[i], positions[i])) {\\n      destination[i] = move;\\n      res += dfs(i + 1, pieces, destination);\\n    }\\n\\n    return res;\\n  }\\n\\n  int countCombinations(vector<string>& pieces, vector<vector<int>>& pos) {\\n    for (int i = 0; i < pieces.size(); i++) positions.push_back({pos[i][0] - 1, pos[i][1] - 1});\\n\\n    vector<point> destination(pieces.size());\\n    return dfs(0, pieces, destination);\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```c++\\nstruct point {\\n  int x, y;\\n  bool operator==(const point& other) { return x == other.x && y == other.y; }\\n  bool operator!=(const point& other) { return x != other.x || y != other.y; }\\n  void moveTowards(const point& other) {\\n    x += x == other.x ? 0 : other.x > x ? 1 : -1;\\n    y += y == other.y ? 0 : other.y > y ? 1 : -1;\\n  }\\n};\\n\\nvector<point> horizontalSteps = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\nvector<point> diagonalSteps = {{1, 1}, {1, -1}, {-1, 1}, {-1, -1}};\\n\\nclass Solution {\\n public:\\n  vector<point> positions;\\n \\n  // `rook` takes the horizontal moves, `bishop` takes the diagonal ones\\n  // `queen` takes both horizontal and diagonal\\n  vector<point> getMoves(string piece, point p) {\\n    vector<point> res{{p.x, p.y}};\\n\\n    if (piece == \"rook\" || piece == \"queen\") {\\n      for (auto step : horizontalSteps) {\\n        int i = p.x + step.x, j = p.y + step.y;\\n        while (i >= 0 && i < 8 && j >= 0 && j < 8) {\\n          res.push_back({i, j});\\n          i += step.x;\\n          j += step.y;\\n        }\\n      }\\n    }\\n\\n    if (piece == \"bishop\" || piece == \"queen\") {\\n      for (auto step : diagonalSteps) {\\n        int i = p.x + step.x, j = p.y + step.y;\\n        while (i >= 0 && i < 8 && j >= 0 && j < 8) {\\n          res.push_back({i, j});\\n          i += step.x;\\n          j += step.y;\\n        }\\n      }\\n    }\\n\\n    return res;\\n  }\\n\\n  bool willIntersect(point a, point a2, point b, point b2) {\\n    // move each start position towards the end position and see if they intersect at any time\\n    while (a != a2 || b != b2) {\\n      a.moveTowards(a2);\\n      b.moveTowards(b2);\\n\\n      if (a == b) return true;\\n    }\\n\\n    return false;\\n  }\\n\\n  bool isValidDestination(vector<point>& dest) {\\n    for (int i = 0; i < dest.size(); i++)\\n      for (int j = 0; j < i; j++)\\n        if (willIntersect(positions[i], dest[i], positions[j], dest[j])) return false;\\n\\n    return true;\\n  }\\n\\n  int dfs(int i, vector<string>& pieces, vector<point>& destination) {\\n    if (i == pieces.size()) {\\n      return isValidDestination(destination) ? 1 : 0;\\n    }\\n\\n    int res = 0;\\n    for (auto move : getMoves(pieces[i], positions[i])) {\\n      destination[i] = move;\\n      res += dfs(i + 1, pieces, destination);\\n    }\\n\\n    return res;\\n  }\\n\\n  int countCombinations(vector<string>& pieces, vector<vector<int>>& pos) {\\n    for (int i = 0; i < pieces.size(); i++) positions.push_back({pos[i][0] - 1, pos[i][1] - 1});\\n\\n    vector<point> destination(pieces.size());\\n    return dfs(0, pieces, destination);\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2100464,
                "title": "c-backtracking-on-uint8-t-8-8-clean-code-currently-beats-100",
                "content": "https://leetcode.com/submissions/detail/712499081/\\nRecursive backtracking with a 8-bit `board` array indicating whether each position is occupied at time t=0..7\\n\\n```\\nclass Solution {\\n    enum {empty, rook, bishop, queen};\\n    vector<tuple<int,int,int>> data;\\n    uint8_t board[8][8] = {};\\n    int count = 0;\\n    \\n    void move_direction(int k, int x, int y, int dx, int dy) {\\n        int t = 0;\\n        while (++t) {\\n            int i = x + t*dx;\\n            int j = y + t*dy;\\n            if (i < 0 || i >= 8 || j < 0 || j >= 8) break;\\n            uint8_t cell = board[i][j];\\n            \\n            uint8_t pass_bit = 1 << t; // can it pass through [i,j]\\n            if (cell & pass_bit) break;\\n            \\n            uint8_t dest_mask = 0xff << t; // can it stop at [i,j]\\n            if (!(cell & dest_mask)) {\\n                board[i][j] = cell | dest_mask;\\n                add_piece(k+1);\\n            }\\n            board[i][j] = cell | pass_bit;\\n        }\\n        while (--t) {\\n            int i = x + t*dx;\\n            int j = y + t*dy;\\n            board[i][j] &= ~(1 << t);\\n        }\\n    }\\n    \\n    void add_piece(int k) {\\n        if (k == data.size()) {\\n            ++count;\\n            return;\\n        }\\n        auto [piece, i, j] = data[k];\\n        if (!board[i][j]) {\\n            board[i][j] = 0xff;\\n            add_piece(k+1);\\n            board[i][j] = 0;\\n        }\\n        if (piece & rook) {\\n            move_direction(k, i, j, 1, 0);\\n            move_direction(k, i, j, -1, 0);\\n            move_direction(k, i, j, 0, 1);\\n            move_direction(k, i, j, 0, -1);\\n        }\\n        if (piece & bishop) {\\n            move_direction(k, i, j, 1, 1);\\n            move_direction(k, i, j, 1, -1);\\n            move_direction(k, i, j, -1, 1);\\n            move_direction(k, i, j, -1, -1);\\n        }\\n    }\\npublic:\\n    int countCombinations(vector<string> const& pieces, vector<vector<int>> const& positions) {\\n        for (int k = 0; k < pieces.size(); ++k) {\\n            int piece = (pieces[k] == \"rook\") ? rook :\\n                        (pieces[k] == \"bishop\") ? bishop : queen;\\n            int i = positions[k][0] - 1;\\n            int j = positions[k][1] - 1;\\n            data.emplace_back(piece, i, j);\\n        }\\n        add_piece(0);\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    enum {empty, rook, bishop, queen};\\n    vector<tuple<int,int,int>> data;\\n    uint8_t board[8][8] = {};\\n    int count = 0;\\n    \\n    void move_direction(int k, int x, int y, int dx, int dy) {\\n        int t = 0;\\n        while (++t) {\\n            int i = x + t*dx;\\n            int j = y + t*dy;\\n            if (i < 0 || i >= 8 || j < 0 || j >= 8) break;\\n            uint8_t cell = board[i][j];\\n            \\n            uint8_t pass_bit = 1 << t; // can it pass through [i,j]\\n            if (cell & pass_bit) break;\\n            \\n            uint8_t dest_mask = 0xff << t; // can it stop at [i,j]\\n            if (!(cell & dest_mask)) {\\n                board[i][j] = cell | dest_mask;\\n                add_piece(k+1);\\n            }\\n            board[i][j] = cell | pass_bit;\\n        }\\n        while (--t) {\\n            int i = x + t*dx;\\n            int j = y + t*dy;\\n            board[i][j] &= ~(1 << t);\\n        }\\n    }\\n    \\n    void add_piece(int k) {\\n        if (k == data.size()) {\\n            ++count;\\n            return;\\n        }\\n        auto [piece, i, j] = data[k];\\n        if (!board[i][j]) {\\n            board[i][j] = 0xff;\\n            add_piece(k+1);\\n            board[i][j] = 0;\\n        }\\n        if (piece & rook) {\\n            move_direction(k, i, j, 1, 0);\\n            move_direction(k, i, j, -1, 0);\\n            move_direction(k, i, j, 0, 1);\\n            move_direction(k, i, j, 0, -1);\\n        }\\n        if (piece & bishop) {\\n            move_direction(k, i, j, 1, 1);\\n            move_direction(k, i, j, 1, -1);\\n            move_direction(k, i, j, -1, 1);\\n            move_direction(k, i, j, -1, -1);\\n        }\\n    }\\npublic:\\n    int countCombinations(vector<string> const& pieces, vector<vector<int>> const& positions) {\\n        for (int k = 0; k < pieces.size(); ++k) {\\n            int piece = (pieces[k] == \"rook\") ? rook :\\n                        (pieces[k] == \"bishop\") ? bishop : queen;\\n            int i = positions[k][0] - 1;\\n            int j = positions[k][1] - 1;\\n            data.emplace_back(piece, i, j);\\n        }\\n        add_piece(0);\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2098587,
                "title": "c-no-recurssion-straight-forward-approach-clean-code",
                "content": "```\\nint dir[8][2] = { {0,1},{0,-1},{1,0},{-1,0},\\n                  {1,1},{-1,1},{1,-1},{-1,-1} }; \\nclass point{\\n  public : \\n    int x,y;\\n    point()\\n    {\\n        x=0;\\n        y=0;\\n    }\\n    point(int _x,int _y)\\n    {\\n        x=_x;\\n        y=_y;\\n    }\\n    bool operator == (point const &p)\\n    {\\n        if(x==p.x && y==p.y) return true;\\n        return false;\\n    }\\n};\\nclass segment{\\n  public : \\n    point st;\\n    point en;\\n    int d;\\n    segment(point _st,point _en,int _dir)\\n    {\\n        st=_st;\\n        en=_en;\\n        d=_dir;\\n    }\\n    bool operator == (segment const &s)\\n    {\\n        // this is intersect , true if intersect ( with respect to steps) ,else false\\n        point a=st;\\n        point b=s.st;\\n        while(!(a==en) && !(b==s.en))\\n        {\\n            a.x=a.x+dir[d][0];\\n            a.y=a.y+dir[d][1];\\n            b.x=b.x+dir[s.d][0];\\n            b.y=b.y+dir[s.d][1];\\n            if(a==b) return true;\\n        }\\n        while(!(a==en))\\n        {\\n            a.x=a.x+dir[d][0];\\n            a.y=a.y+dir[d][1];\\n            if(a==b) return true;\\n        }\\n        while(!(b==s.en))\\n        {\\n            b.x=b.x+dir[s.d][0];\\n            b.y=b.y+dir[s.d][1];\\n            if(a==b) return true;\\n        }\\n        return false;\\n    }\\n};\\n\\nbool is_not_intersecting(segment &a,segment &b,segment &c,segment &d)\\n{\\n    if(a==b) return false;\\n    if(a==c) return false;\\n    if(a==d) return false;\\n    if(b==c) return false;\\n    if(b==d) return false;\\n    if(c==d) return false;\\n    return true;\\n}\\nbool is_not_intersecting(segment &a,segment &b,segment &c)\\n{\\n    if(a==b) return false;\\n    if(a==c) return false;\\n    if(b==c) return false;\\n    return true;\\n}\\nbool is_not_intersecting(segment &a,segment &b)\\n{\\n    if(a==b) return false;\\n    return true;\\n}\\nbool is_safe(int x,int y)\\n{\\n    if(x>=1 && x<=8 && y>=1 &&y <=8) return true;\\n    return false;\\n}\\nclass Solution {\\npublic:\\n    \\n    vector < segment > get_possible_pos(int _x,int _y,string type)\\n    {\\n        int dir_st=0;\\n        int dir_en=7;\\n        if(type==\"rook\"){ dir_en=3;}\\n        if(type==\"bishop\"){ dir_st=4;}\\n        vector < segment > ans;\\n        ans.push_back(segment(point(_x,_y),point(_x,_y),8));\\n        while(dir_st<=dir_en)\\n        {\\n            int x=_x;\\n            int y=_y;\\n            x=x+dir[dir_st][0];\\n            y=y+dir[dir_st][1];\\n            while(is_safe(x,y))\\n            {\\n                ans.push_back(segment(point(_x,_y),point(x,y),dir_st));\\n                x=x+dir[dir_st][0];\\n                y=y+dir[dir_st][1];\\n            }\\n            dir_st++;\\n        }\\n        return ans;\\n    }\\n    int countCombinations(vector<string>& pc, vector<vector<int>>& pos) {\\n        int sz=pc.size();\\n        int ans=0;\\n        if(sz==1)\\n        {\\n            vector < segment > p1=get_possible_pos(pos[0][0],pos[0][1],pc[0]);\\n            ans=p1.size();\\n            return ans;\\n        }\\n        else if(sz==2)\\n        {\\n            vector < segment > p1=get_possible_pos(pos[0][0],pos[0][1],pc[0]);\\n            vector < segment > p2=get_possible_pos(pos[1][0],pos[1][1],pc[1]);\\n            cout<<p1.size()<<\" \"<<p2.size()<<\"\\\\n\";\\n            for(auto &i:p1)\\n            {\\n                for(auto &j:p2)\\n                {\\n                    if(is_not_intersecting(i,j))\\n                        ans++;\\n                }\\n            }\\n            return ans;\\n        }\\n        else if(sz==3)\\n        {\\n            vector < segment > p1=get_possible_pos(pos[0][0],pos[0][1],pc[0]);\\n            vector < segment > p2=get_possible_pos(pos[1][0],pos[1][1],pc[1]);\\n            vector < segment > p3=get_possible_pos(pos[2][0],pos[2][1],pc[2]);\\n            for(auto &i:p1)\\n            {\\n                for(auto &j:p2)\\n                {\\n                    for(auto &k:p3)\\n                    {\\n                        if(is_not_intersecting(i,j,k))\\n                        ans++;\\n                    }\\n                    \\n                }\\n            }\\n            return ans;\\n        }\\n        else if(sz==4)\\n        {\\n            vector < segment > p1=get_possible_pos(pos[0][0],pos[0][1],pc[0]);\\n            vector < segment > p2=get_possible_pos(pos[1][0],pos[1][1],pc[1]);\\n            vector < segment > p3=get_possible_pos(pos[2][0],pos[2][1],pc[2]);\\n            vector < segment > p4=get_possible_pos(pos[3][0],pos[3][1],pc[3]);\\n            for(auto &i:p1)\\n            {\\n                for(auto &j:p2)\\n                {\\n                    for(auto &k:p3)\\n                    {\\n                        for(auto &l:p4)\\n                        {\\n                            if(is_not_intersecting(i,j,k,l))\\n                            ans++;\\n                        }\\n                    }\\n                    \\n                }\\n            }\\n            return ans;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint dir[8][2] = { {0,1},{0,-1},{1,0},{-1,0},\\n                  {1,1},{-1,1},{1,-1},{-1,-1} }; \\nclass point{\\n  public : \\n    int x,y;\\n    point()\\n    {\\n        x=0;\\n        y=0;\\n    }\\n    point(int _x,int _y)\\n    {\\n        x=_x;\\n        y=_y;\\n    }\\n    bool operator == (point const &p)\\n    {\\n        if(x==p.x && y==p.y) return true;\\n        return false;\\n    }\\n};\\nclass segment{\\n  public : \\n    point st;\\n    point en;\\n    int d;\\n    segment(point _st,point _en,int _dir)\\n    {\\n        st=_st;\\n        en=_en;\\n        d=_dir;\\n    }\\n    bool operator == (segment const &s)\\n    {\\n        // this is intersect , true if intersect ( with respect to steps) ,else false\\n        point a=st;\\n        point b=s.st;\\n        while(!(a==en) && !(b==s.en))\\n        {\\n            a.x=a.x+dir[d][0];\\n            a.y=a.y+dir[d][1];\\n            b.x=b.x+dir[s.d][0];\\n            b.y=b.y+dir[s.d][1];\\n            if(a==b) return true;\\n        }\\n        while(!(a==en))\\n        {\\n            a.x=a.x+dir[d][0];\\n            a.y=a.y+dir[d][1];\\n            if(a==b) return true;\\n        }\\n        while(!(b==s.en))\\n        {\\n            b.x=b.x+dir[s.d][0];\\n            b.y=b.y+dir[s.d][1];\\n            if(a==b) return true;\\n        }\\n        return false;\\n    }\\n};\\n\\nbool is_not_intersecting(segment &a,segment &b,segment &c,segment &d)\\n{\\n    if(a==b) return false;\\n    if(a==c) return false;\\n    if(a==d) return false;\\n    if(b==c) return false;\\n    if(b==d) return false;\\n    if(c==d) return false;\\n    return true;\\n}\\nbool is_not_intersecting(segment &a,segment &b,segment &c)\\n{\\n    if(a==b) return false;\\n    if(a==c) return false;\\n    if(b==c) return false;\\n    return true;\\n}\\nbool is_not_intersecting(segment &a,segment &b)\\n{\\n    if(a==b) return false;\\n    return true;\\n}\\nbool is_safe(int x,int y)\\n{\\n    if(x>=1 && x<=8 && y>=1 &&y <=8) return true;\\n    return false;\\n}\\nclass Solution {\\npublic:\\n    \\n    vector < segment > get_possible_pos(int _x,int _y,string type)\\n    {\\n        int dir_st=0;\\n        int dir_en=7;\\n        if(type==\"rook\"){ dir_en=3;}\\n        if(type==\"bishop\"){ dir_st=4;}\\n        vector < segment > ans;\\n        ans.push_back(segment(point(_x,_y),point(_x,_y),8));\\n        while(dir_st<=dir_en)\\n        {\\n            int x=_x;\\n            int y=_y;\\n            x=x+dir[dir_st][0];\\n            y=y+dir[dir_st][1];\\n            while(is_safe(x,y))\\n            {\\n                ans.push_back(segment(point(_x,_y),point(x,y),dir_st));\\n                x=x+dir[dir_st][0];\\n                y=y+dir[dir_st][1];\\n            }\\n            dir_st++;\\n        }\\n        return ans;\\n    }\\n    int countCombinations(vector<string>& pc, vector<vector<int>>& pos) {\\n        int sz=pc.size();\\n        int ans=0;\\n        if(sz==1)\\n        {\\n            vector < segment > p1=get_possible_pos(pos[0][0],pos[0][1],pc[0]);\\n            ans=p1.size();\\n            return ans;\\n        }\\n        else if(sz==2)\\n        {\\n            vector < segment > p1=get_possible_pos(pos[0][0],pos[0][1],pc[0]);\\n            vector < segment > p2=get_possible_pos(pos[1][0],pos[1][1],pc[1]);\\n            cout<<p1.size()<<\" \"<<p2.size()<<\"\\\\n\";\\n            for(auto &i:p1)\\n            {\\n                for(auto &j:p2)\\n                {\\n                    if(is_not_intersecting(i,j))\\n                        ans++;\\n                }\\n            }\\n            return ans;\\n        }\\n        else if(sz==3)\\n        {\\n            vector < segment > p1=get_possible_pos(pos[0][0],pos[0][1],pc[0]);\\n            vector < segment > p2=get_possible_pos(pos[1][0],pos[1][1],pc[1]);\\n            vector < segment > p3=get_possible_pos(pos[2][0],pos[2][1],pc[2]);\\n            for(auto &i:p1)\\n            {\\n                for(auto &j:p2)\\n                {\\n                    for(auto &k:p3)\\n                    {\\n                        if(is_not_intersecting(i,j,k))\\n                        ans++;\\n                    }\\n                    \\n                }\\n            }\\n            return ans;\\n        }\\n        else if(sz==4)\\n        {\\n            vector < segment > p1=get_possible_pos(pos[0][0],pos[0][1],pc[0]);\\n            vector < segment > p2=get_possible_pos(pos[1][0],pos[1][1],pc[1]);\\n            vector < segment > p3=get_possible_pos(pos[2][0],pos[2][1],pc[2]);\\n            vector < segment > p4=get_possible_pos(pos[3][0],pos[3][1],pc[3]);\\n            for(auto &i:p1)\\n            {\\n                for(auto &j:p2)\\n                {\\n                    for(auto &k:p3)\\n                    {\\n                        for(auto &l:p4)\\n                        {\\n                            if(is_not_intersecting(i,j,k,l))\\n                            ans++;\\n                        }\\n                    }\\n                    \\n                }\\n            }\\n            return ans;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1986248,
                "title": "intuitive-python-solution",
                "content": "This is my solution.\\nFor each piece, we generate all possible moves.\\nWe iterate over a product of these moves and check by simulation if such configuration is valid.\\n\\n```python\\nclass Dense(NamedTuple):\\n    \"\"\" Dense representation of a single Piece move \"\"\"\\n    loc: int  # current location 0..63\\n    step: int  # current moving step\\n    dest: int  # destination location\\n\\n        \\nclass Piece:\\n    dirs = ()  # Possible directions to be defined in subclass\\n\\t\\n    def __init__(self, row: int, col: int):\\n        # start position\\n        self.row = row\\n        self.col = col  \\n\\n    def moves(self) -> Sequence[Dense]:\\n        \"\"\" Generate sequence of possible moves of this piece \"\"\"\\n        start = (self.row-1) * 8 + self.col -1\\n        # no-move is also a legal \"move\"\\n        yield Dense(loc=start, step=0, dest=start)\\n        # Consider all possible directions for this kind of piece\\n        for drow, dcol in self.dirs:\\n            row0 = self.row - 1  # starting row and col 0-indexed\\n            col0 = self.col - 1\\n            while True:  # follow this direction util out-of-bounds\\n                row0 += drow\\n                col0 += dcol\\n                if (0 <= row0 <= 7) and (0 <= col0 <= 7):\\n                    yield Dense(loc=start, step=drow * 8 + dcol, dest=row0 * 8 + col0)\\n                else:\\n                    break\\n\\nclass Rook(Piece):\\n    dirs = ((1, 0), (-1, 0), (0, 1), (0, -1))\\n\\nclass Queen(Piece):\\n    dirs = ((1, 0), (-1, 0), (0, 1), (0, -1),\\n            (-1, -1), (-1, 1), (1, -1), (1, 1))\\n\\nclass Bishop(Piece):\\n    dirs = ((-1, -1), (-1, 1), (1, -1), (1, 1))\\n\\ndef is_valid(conf: Tuple[Dense]) -> bool:\\n    \"\"\"\\n    (board) conf is a tuple of Dense objects.\\n\\tSimulate each second to verify\\n    \"\"\"\\n    # All pieces positions on current second\\n    pos = [move.loc for move in conf]\\n    while True:\\n        moved = 0  # How many pieces we have moved this second\\n        if len(set(pos)) != len(pos):\\n            # print(False, conf)\\n            return False  # some pieces are on same position\\n        for i, move in enumerate(conf): # simulate each piece step\\n            if pos[i] != move.dest:  # are whe there yet?\\n                new_pos = pos[i] + move.step\\n                pos[i] = new_pos\\n                moved += 1  # we have moved something in this second\\n        if not moved:\\n            break  # All pieces reached their destination\\n    # print(True, conf)\\n    return True\\n\\nclass Solution:\\n    def countCombinations(self, pieces: List[str], positions: List[List[int]]) -> int:\\n        kind2type = {\\n            \"rook\": Rook,\\n            \"queen\": Queen,\\n            \"bishop\": Bishop,\\n        }\\n        moves_generators = []  # for each piece, its possible moves\\n        for kind, (row, col) in zip(pieces, positions):\\n            moves_generators.append(kind2type[kind](row, col).moves())\\n        ans = 0        \\n        for conf in itertools.product(*moves_generators):\\n            if is_valid(conf):\\n                ans += 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Dense(NamedTuple):\\n    \"\"\" Dense representation of a single Piece move \"\"\"\\n    loc: int  # current location 0..63\\n    step: int  # current moving step\\n    dest: int  # destination location\\n\\n        \\nclass Piece:\\n    dirs = ()  # Possible directions to be defined in subclass\\n\\t\\n    def __init__(self, row: int, col: int):\\n        # start position\\n        self.row = row\\n        self.col = col  \\n\\n    def moves(self) -> Sequence[Dense]:\\n        \"\"\" Generate sequence of possible moves of this piece \"\"\"\\n        start = (self.row-1) * 8 + self.col -1\\n        # no-move is also a legal \"move\"\\n        yield Dense(loc=start, step=0, dest=start)\\n        # Consider all possible directions for this kind of piece\\n        for drow, dcol in self.dirs:\\n            row0 = self.row - 1  # starting row and col 0-indexed\\n            col0 = self.col - 1\\n            while True:  # follow this direction util out-of-bounds\\n                row0 += drow\\n                col0 += dcol\\n                if (0 <= row0 <= 7) and (0 <= col0 <= 7):\\n                    yield Dense(loc=start, step=drow * 8 + dcol, dest=row0 * 8 + col0)\\n                else:\\n                    break\\n\\nclass Rook(Piece):\\n    dirs = ((1, 0), (-1, 0), (0, 1), (0, -1))\\n\\nclass Queen(Piece):\\n    dirs = ((1, 0), (-1, 0), (0, 1), (0, -1),\\n            (-1, -1), (-1, 1), (1, -1), (1, 1))\\n\\nclass Bishop(Piece):\\n    dirs = ((-1, -1), (-1, 1), (1, -1), (1, 1))\\n\\ndef is_valid(conf: Tuple[Dense]) -> bool:\\n    \"\"\"\\n    (board) conf is a tuple of Dense objects.\\n\\tSimulate each second to verify\\n    \"\"\"\\n    # All pieces positions on current second\\n    pos = [move.loc for move in conf]\\n    while True:\\n        moved = 0  # How many pieces we have moved this second\\n        if len(set(pos)) != len(pos):\\n            # print(False, conf)\\n            return False  # some pieces are on same position\\n        for i, move in enumerate(conf): # simulate each piece step\\n            if pos[i] != move.dest:  # are whe there yet?\\n                new_pos = pos[i] + move.step\\n                pos[i] = new_pos\\n                moved += 1  # we have moved something in this second\\n        if not moved:\\n            break  # All pieces reached their destination\\n    # print(True, conf)\\n    return True\\n\\nclass Solution:\\n    def countCombinations(self, pieces: List[str], positions: List[List[int]]) -> int:\\n        kind2type = {\\n            \"rook\": Rook,\\n            \"queen\": Queen,\\n            \"bishop\": Bishop,\\n        }\\n        moves_generators = []  # for each piece, its possible moves\\n        for kind, (row, col) in zip(pieces, positions):\\n            moves_generators.append(kind2type[kind](row, col).moves())\\n        ans = 0        \\n        for conf in itertools.product(*moves_generators):\\n            if is_valid(conf):\\n                ans += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1984169,
                "title": "i-don-t-like-it-at-all",
                "content": "I really don\\'t like problems where you have to spend 5+ minutes just to read it.",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 1895741,
                "title": "python-short-generating-all-destinations-with-backtracking-then-simulating",
                "content": "```\\nfrom copy import deepcopy\\nclass Solution:\\n    def countCombinations(self, pieces: List[str], positions: List[List[int]]) -> int:\\n        valid_moves = [0]\\n        generate_combinations(pieces, positions, 0, [], valid_moves)\\n        return valid_moves[0]\\n        \\ndef generate_combinations(pieces,positions, piece_idx, directions, valid_moves):\\n    \\n    rook_directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\\n    bishop_directions = [(1,1), (1,-1), (-1,1), (-1,-1)]\\n    \\n    piece_mapping = { \"queen\": rook_directions + bishop_directions,\\n                       \"rook\": rook_directions,\\n                       \"bishop\": bishop_directions\\n                    }\\n    \\n    if piece_idx == len(pieces):\\n        try_combination(pieces, positions, directions, valid_moves)\\n        return\\n    \\n    \\n    position = positions[piece_idx].copy()\\n\\n    directions.append(((0,0), position))\\n    generate_combinations(pieces,positions, piece_idx + 1, directions, valid_moves)\\n    directions.pop()\\n    for direction in piece_mapping[pieces[piece_idx]]:\\n        position = positions[piece_idx].copy()\\n        position[0] += direction[0]\\n        position[1] += direction[1]\\n\\n        while 1 <= position[0] <= 8 and 1 <= position[1] <= 8:\\n            directions.append((direction, position))\\n            generate_combinations(pieces,positions, piece_idx + 1, directions, valid_moves)\\n            directions.pop()\\n            position[0] += direction[0]\\n            position[1] += direction[1]\\n\\n            \\ndef try_combination(pieces, positions, directions, valid_moves):\\n    current_positions = deepcopy(positions)\\n    while True:\\n        # stop if all pieces reached their target\\n        reached_target = True\\n        for piece_idx, (direction, target) in enumerate(directions):\\n            if current_positions[piece_idx] != target:\\n                reached_target = False\\n        if reached_target:\\n            valid_moves[0] += 1\\n            return\\n        \\n        for piece_idx, (direction, target) in enumerate(directions):\\n            if current_positions[piece_idx] != target:\\n                current_positions[piece_idx][0] += direction[0]\\n                current_positions[piece_idx][1] += direction[1]\\n        # eval piece overlap\\n        for p1, position in enumerate(current_positions):\\n            for p2, second_position in enumerate(current_positions):\\n                if p1 != p2 and position == second_position:\\n                    return\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nfrom copy import deepcopy\\nclass Solution:\\n    def countCombinations(self, pieces: List[str], positions: List[List[int]]) -> int:\\n        valid_moves = [0]\\n        generate_combinations(pieces, positions, 0, [], valid_moves)\\n        return valid_moves[0]\\n        \\ndef generate_combinations(pieces,positions, piece_idx, directions, valid_moves):\\n    \\n    rook_directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\\n    bishop_directions = [(1,1), (1,-1), (-1,1), (-1,-1)]\\n    \\n    piece_mapping = { \"queen\": rook_directions + bishop_directions,\\n                       \"rook\": rook_directions,\\n                       \"bishop\": bishop_directions\\n                    }\\n    \\n    if piece_idx == len(pieces):\\n        try_combination(pieces, positions, directions, valid_moves)\\n        return\\n    \\n    \\n    position = positions[piece_idx].copy()\\n\\n    directions.append(((0,0), position))\\n    generate_combinations(pieces,positions, piece_idx + 1, directions, valid_moves)\\n    directions.pop()\\n    for direction in piece_mapping[pieces[piece_idx]]:\\n        position = positions[piece_idx].copy()\\n        position[0] += direction[0]\\n        position[1] += direction[1]\\n\\n        while 1 <= position[0] <= 8 and 1 <= position[1] <= 8:\\n            directions.append((direction, position))\\n            generate_combinations(pieces,positions, piece_idx + 1, directions, valid_moves)\\n            directions.pop()\\n            position[0] += direction[0]\\n            position[1] += direction[1]\\n\\n            \\ndef try_combination(pieces, positions, directions, valid_moves):\\n    current_positions = deepcopy(positions)\\n    while True:\\n        # stop if all pieces reached their target\\n        reached_target = True\\n        for piece_idx, (direction, target) in enumerate(directions):\\n            if current_positions[piece_idx] != target:\\n                reached_target = False\\n        if reached_target:\\n            valid_moves[0] += 1\\n            return\\n        \\n        for piece_idx, (direction, target) in enumerate(directions):\\n            if current_positions[piece_idx] != target:\\n                current_positions[piece_idx][0] += direction[0]\\n                current_positions[piece_idx][1] += direction[1]\\n        # eval piece overlap\\n        for p1, position in enumerate(current_positions):\\n            for p2, second_position in enumerate(current_positions):\\n                if p1 != p2 and position == second_position:\\n                    return\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1570730,
                "content": [
                    {
                        "username": "wuzhenhai",
                        "content": "[\"queen\",\"bishop\"]\\n[[5,7],[3,4]]\\n\\nmy answer is 285, but the expected is 281."
                    },
                    {
                        "username": "kingsizebeast",
                        "content": "2 pieces cannot pass each other unless they are directly adjacent initially."
                    },
                    {
                        "username": "chienmian",
                        "content": "[@Jotho](/Jotho) That\\'s close. I\\'m working on my solution right now as well, but I think an adjustment can be made to your analysis:\\n> Bishop has 12 possible squares and queen has 24.\\n- Correct\\n\\n> But if queen chooses [5,6] as destination that eliminates 2 possible positions for bishop.\\n- It actually eliminates 3 possible positions for the bishop: [5, 6], [6, 7] and [7, 8]\\n\\n> If queen chooses [6,7] that eliminates 1 position for bishop.\\n- It actually eliminates 2 positions: [6, 7] and [7, 8]\\n\\nIf bishop chooses [5,2] as destination, that eliminates 1 position for queen.\\n- It actually eliminates 2 positions: [5, 2] and [6, 1]\\n\\nSo there are 7 invalid arrangements: 12*24 - 7 = 288-7 = 281\\n"
                    },
                    {
                        "username": "jotho_",
                        "content": "I got the same.\nBishop has 12 possible squares and queen has 24.  \nBut if queen chooses [5,6] as destination that eliminates 2 possible positions for bishop.  \nIf queen chooses [6,7] that eliminates 1 position for bishop.\nIf bishop chooses [5,2] as destination, that eliminates 1 position for queen.\nThere's the 4 invalid arrangements.\nI still haven't submitted a correct solution... :("
                    }
                ]
            }
        ]
    }
]