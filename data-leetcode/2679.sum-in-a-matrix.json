[
    {
        "title": "Find the Maximum Divisibility Score",
        "question_content": "You are given two 0-indexed integer arrays nums and divisors.\nThe divisibility score of divisors[i] is the number of indices j such that nums[j] is divisible by divisors[i].\nReturn the integer divisors[i] with the maximum divisibility score. If there is more than one integer with the maximum score, return the minimum of them.\n&nbsp;\nExample 1:\n\nInput: nums = [4,7,9,3,9], divisors = [5,2,3]\nOutput: 3\nExplanation: The divisibility score for every element in divisors is:\nThe divisibility score of divisors[0] is 0 since no number in nums is divisible by 5.\nThe divisibility score of divisors[1] is 1 since nums[0] is divisible by 2.\nThe divisibility score of divisors[2] is 3 since nums[2], nums[3], and nums[4] are divisible by 3.\nSince divisors[2] has the maximum divisibility score, we return it.\n\nExample 2:\n\nInput: nums = [20,14,21,10], divisors = [5,7,5]\nOutput: 5\nExplanation: The divisibility score for every element in divisors is:\nThe divisibility score of divisors[0] is 2 since nums[0] and nums[3] are divisible by 5.\nThe divisibility score of divisors[1] is 2 since nums[1] and nums[2] are divisible by 7.\nThe divisibility score of divisors[2] is 2 since nums[0] and nums[3] are divisible by 5.\nSince divisors[0], divisors[1], and divisors[2] all have the maximum divisibility score, we return the minimum of them (i.e., divisors[2]).\n\nExample 3:\n\nInput: nums = [12], divisors = [10,16]\nOutput: 10\nExplanation: The divisibility score for every element in divisors is:\nThe divisibility score of divisors[0] is 0 since no number in nums is divisible by 10.\nThe divisibility score of divisors[1] is 0 since no number in nums is divisible by 16.\nSince divisors[0] and divisors[1] both have the maximum divisibility score, we return the minimum of them (i.e., divisors[0]).\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length, divisors.length <= 1000\n\t1 <= nums[i], divisors[i] <= 109",
        "solutions": [
            {
                "id": 3422204,
                "title": "leetcode-the-hard-way-explained-line-by-line",
                "content": "C++\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int ans = -1, mx_cnt = -1;\\n        // for each divisor\\n        for (auto d : divisors) {\\n            int cnt = 0;\\n            // we check each number `x`\\n            for (auto x : nums) {\\n                // to see if `x` can be divisible by `d`\\n                if (x % d == 0) {\\n                    // if so, increase the counter by 1\\n                    cnt += 1;\\n                }\\n            }\\n            // if the counter is greater than the current max\\n            if (cnt > mx_cnt) {\\n                // then update hte current max\\n                mx_cnt = cnt;\\n                // `d` will be the possible answer\\n                ans = d;\\n            } else if (cnt == mx_cnt) {\\n                // however, if the counter is same as the current max\\n                // then we need to take the min one\\n                ans = min(ans, d);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nPython\\n\\n```py\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n        res = -1\\n        mx_cnt = -1\\n        # for each divisor\\n        for d in divisors:\\n            cnt = 0\\n            # we check each number `x`\\n            for x in nums:\\n                # to see if `x` can be divisible by `d`\\n                if x % d == 0:\\n                    # if so, increase the counter by 1\\n                    cnt += 1\\n            # if the counter is greater than the current max\\n            if cnt > mx_cnt:\\n                # then update hte current max\\n                mx_cnt = cnt\\n                # `d` will be the possible answer\\n                res = d\\n            elif cnt == mx_cnt:\\n                # however, if the counter is same as the current max\\n                # then we need to take the min one\\n                res = min(res, d)\\n        return res\\n```",
                "solutionTags": [
                    "C++",
                    "Python"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int ans = -1, mx_cnt = -1;\\n        // for each divisor\\n        for (auto d : divisors) {\\n            int cnt = 0;\\n            // we check each number `x`\\n            for (auto x : nums) {\\n                // to see if `x` can be divisible by `d`\\n                if (x % d == 0) {\\n                    // if so, increase the counter by 1\\n                    cnt += 1;\\n                }\\n            }\\n            // if the counter is greater than the current max\\n            if (cnt > mx_cnt) {\\n                // then update hte current max\\n                mx_cnt = cnt;\\n                // `d` will be the possible answer\\n                ans = d;\\n            } else if (cnt == mx_cnt) {\\n                // however, if the counter is same as the current max\\n                // then we need to take the min one\\n                ans = min(ans, d);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```py\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n        res = -1\\n        mx_cnt = -1\\n        # for each divisor\\n        for d in divisors:\\n            cnt = 0\\n            # we check each number `x`\\n            for x in nums:\\n                # to see if `x` can be divisible by `d`\\n                if x % d == 0:\\n                    # if so, increase the counter by 1\\n                    cnt += 1\\n            # if the counter is greater than the current max\\n            if cnt > mx_cnt:\\n                # then update hte current max\\n                mx_cnt = cnt\\n                # `d` will be the possible answer\\n                res = d\\n            elif cnt == mx_cnt:\\n                # however, if the counter is same as the current max\\n                # then we need to take the min one\\n                res = min(res, d)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421736,
                "title": "clean-simple-java-solution",
                "content": "\\n```java []\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        Arrays.sort(divisors);\\n        int max = 0, res = divisors[0];\\n        for(int i=0; i<divisors.length; i++){\\n            int cnt = 0;\\n            for(int j=0; j<nums.length; j++){\\n                if(nums[j] % divisors[i] == 0)  cnt++;\\n            }\\n            if(cnt > max){\\n                max = cnt;\\n                res = divisors[i];\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java []\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        Arrays.sort(divisors);\\n        int max = 0, res = divisors[0];\\n        for(int i=0; i<divisors.length; i++){\\n            int cnt = 0;\\n            for(int j=0; j<nums.length; j++){\\n                if(nums[j] % divisors[i] == 0)  cnt++;\\n            }\\n            if(cnt > max){\\n                max = cnt;\\n                res = divisors[i];\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421687,
                "title": "c-bruteforce",
                "content": "**Approach Brute Force**\\n**Count number of perfect dividend and update the answer**\\n\\n# C++ Code\\n```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int res = 0, curr = -1;\\n        for(auto &d: divisors){\\n            int score = 0;\\n            for(auto &it: nums)     \\n                score += (it % d == 0);\\n            if(score >= curr){\\n                if(score == curr)       \\n                    res = min(res, d);\\n                else                    \\n                    res = d;                    \\n                curr = score;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int res = 0, curr = -1;\\n        for(auto &d: divisors){\\n            int score = 0;\\n            for(auto &it: nums)     \\n                score += (it % d == 0);\\n            if(score >= curr){\\n                if(score == curr)       \\n                    res = min(res, d);\\n                else                    \\n                    res = d;                    \\n                curr = score;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421912,
                "title": "c-solution",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int maxcount = 0;\\n        int best_divisor = divisors[0];\\n        for (int i = 0; i < divisors.size(); i++) {\\n            int count = 0;\\n            for (int j = 0; j < nums.size(); j++) {\\n                if (nums[j] % divisors[i] == 0) {\\n                    count++;\\n                }\\n            }\\n            if(count==maxcount){\\n               best_divisor = min(best_divisor,divisors[i]);\\n            }\\n            if (count > maxcount) {\\n                maxcount = count;\\n                best_divisor = divisors[i];\\n            }\\n        }\\n        return best_divisor;\\n    }\\n};\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int maxcount = 0;\\n        int best_divisor = divisors[0];\\n        for (int i = 0; i < divisors.size(); i++) {\\n            int count = 0;\\n            for (int j = 0; j < nums.size(); j++) {\\n                if (nums[j] % divisors[i] == 0) {\\n                    count++;\\n                }\\n            }\\n            if(count==maxcount){\\n               best_divisor = min(best_divisor,divisors[i]);\\n            }\\n            if (count > maxcount) {\\n                maxcount = count;\\n                best_divisor = divisors[i];\\n            }\\n        }\\n        return best_divisor;\\n    }\\n};\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421672,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(m*n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int max=0,val=0;\\n        for(int i:divisors)\\n        {\\n            int count=0;\\n            for(int j:nums)\\n            {\\n                if(j%i==0)\\n                {\\n                    count++;\\n                }\\n            }\\n            if(count>max)\\n            {\\n                max=count;\\n                val=i;\\n            }\\n            if(count==max && i<val)\\n            {\\n                val=i;\\n            }\\n        }\\n        if(max==0 && val==0)\\n        {\\n            Arrays.sort(divisors);\\n            return divisors[0];\\n        }\\n        return val;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int max=0,val=0;\\n        for(int i:divisors)\\n        {\\n            int count=0;\\n            for(int j:nums)\\n            {\\n                if(j%i==0)\\n                {\\n                    count++;\\n                }\\n            }\\n            if(count>max)\\n            {\\n                max=count;\\n                val=i;\\n            }\\n            if(count==max && i<val)\\n            {\\n                val=i;\\n            }\\n        }\\n        if(max==0 && val==0)\\n        {\\n            Arrays.sort(divisors);\\n            return divisors[0];\\n        }\\n        return val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3426856,
                "title": "golang-100-faster-easy-solution",
                "content": "# Code\\u2705\\n```\\nimport (\\n\\t\"sort\"\\n)\\nfunc maxDivScore(nums []int, divisors []int) int {\\n   max := 0\\n   maxDiv := 0\\n   for _, div := range divisors{\\n        currentMax := 0\\n        for _, num := range nums{\\n            if num % div == 0 {\\n                currentMax += 1\\n            } \\n        }\\n        if currentMax == max {\\n            if div < maxDiv {\\n                maxDiv = div\\n            }\\n        } else if currentMax > max {\\n            maxDiv = div\\n            max = currentMax\\n        }\\n   }\\n   \\n   if max == 0 {\\n       sort.Ints(divisors)\\n       return divisors[0] \\n   }\\n   return  maxDiv\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nimport (\\n\\t\"sort\"\\n)\\nfunc maxDivScore(nums []int, divisors []int) int {\\n   max := 0\\n   maxDiv := 0\\n   for _, div := range divisors{\\n        currentMax := 0\\n        for _, num := range nums{\\n            if num % div == 0 {\\n                currentMax += 1\\n            } \\n        }\\n        if currentMax == max {\\n            if div < maxDiv {\\n                maxDiv = div\\n            }\\n        } else if currentMax > max {\\n            maxDiv = div\\n            max = currentMax\\n        }\\n   }\\n   \\n   if max == 0 {\\n       sort.Ints(divisors)\\n       return divisors[0] \\n   }\\n   return  maxDiv\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3426109,
                "title": "one-liner",
                "content": "**Python 3**\\nWe negate the divisor to avoid lambda.\\n\\n```python\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divs: List[int]) -> int:\\n        return -max([sum(n % d == 0 for n in nums), -d] for d in divs)[1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divs: List[int]) -> int:\\n        return -max([sum(n % d == 0 for n in nums), -d] for d in divs)[1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422465,
                "title": "c-brute-force",
                "content": "\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n * m)$$\\nn = div.size(), m = nums.size()\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& div) {\\n        int count = 0, divisor = 0;\\n        for(int i = 0; i < div.size(); i++) {\\n            int div_count = 0;\\n            for(int j = 0; j < nums.size(); j++) {\\n                if(nums[j] % div[i] == 0) div_count++;\\n            }\\n            if(count == div_count) {\\n                divisor = divisor == 0 ? div[i] : min(divisor, div[i]);\\n            }\\n            else if(div_count > count) {\\n                count = div_count;\\n                divisor = div[i];\\n            }\\n        }\\n        return divisor;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& div) {\\n        int count = 0, divisor = 0;\\n        for(int i = 0; i < div.size(); i++) {\\n            int div_count = 0;\\n            for(int j = 0; j < nums.size(); j++) {\\n                if(nums[j] % div[i] == 0) div_count++;\\n            }\\n            if(count == div_count) {\\n                divisor = divisor == 0 ? div[i] : min(divisor, div[i]);\\n            }\\n            else if(div_count > count) {\\n                count = div_count;\\n                divisor = div[i];\\n            }\\n        }\\n        return divisor;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421776,
                "title": "easy-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int dLen = divisors.size(),n=nums.size(),c,maxVal=0,ans=INT_MAX;\\n        \\n        for(int i=0;i<dLen;i++){\\n            c=0;\\n            for(int j=0;j<n;j++){\\n                if(nums[j]%divisors[i] == 0){\\n                    c++;\\n                }\\n            }\\n            if(c==maxVal){\\n                ans = min(ans,divisors[i]);\\n            }\\n            else if(c > maxVal){\\n                maxVal = c;\\n                ans = divisors[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int dLen = divisors.size(),n=nums.size(),c,maxVal=0,ans=INT_MAX;\\n        \\n        for(int i=0;i<dLen;i++){\\n            c=0;\\n            for(int j=0;j<n;j++){\\n                if(nums[j]%divisors[i] == 0){\\n                    c++;\\n                }\\n            }\\n            if(c==maxVal){\\n                ans = min(ans,divisors[i]);\\n            }\\n            else if(c > maxVal){\\n                maxVal = c;\\n                ans = divisors[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3442703,
                "title": "simple-python3-beats-91-6-quibler7",
                "content": "# Code\\n```\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n        res = 0 \\n        count = -1\\n        for d in divisors:\\n            curr = sum(1 for i in nums if i%d == 0)\\n            if curr > count:\\n                count = curr\\n                res = d\\n            elif curr == count:\\n                res = min(res, d)\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n        res = 0 \\n        count = -1\\n        for d in divisors:\\n            curr = sum(1 for i in nums if i%d == 0)\\n            if curr > count:\\n                count = curr\\n                res = d\\n            elif curr == count:\\n                res = min(res, d)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3435017,
                "title": "binary-search-java",
                "content": "# Approach\\nSort the nums, given the divisor , find an index that is equals or greater than divisor, then loop through the numbers starting from the index.\\n\\n# Complexity\\n- Time complexity:\\n$$O(DlogN)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    private int binarySearch(int[] nums, int target) {\\n        int i = 0;\\n        int j = nums.length;\\n        while(i < j) {\\n            int mid = i + (j - i) / 2;\\n            if(nums[mid] < target) {\\n                i = mid + 1;\\n            } else {\\n                j = mid;\\n            }\\n        }\\n        return i;\\n    }\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        Arrays.sort(nums);\\n        int max = 0;\\n        int res = divisors[0];\\n        for(int d : divisors) {\\n            int score = 0;\\n            for(int i = binarySearch(nums, d); i < nums.length; ++i) {\\n                if( nums[i] % d == 0) {\\n                    ++score;\\n                }\\n            }\\n            if(score > max) {\\n                max = score;\\n                res = d;\\n            } else if (score == max) {\\n                res = Math.min(res, d);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\\n\\n### [Optimize] Sort both nums and divisors, and limit the lower bound.\\n\\n```java\\nclass Solution {\\n    private int binarySearch(int[] nums, int target, int lo) {\\n        int hi = nums.length;\\n        while(lo < hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            if(nums[mid] < target) {\\n                lo = mid + 1;\\n            } else {\\n                hi = mid;\\n            }\\n        }\\n        return lo;\\n    }\\n\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        Arrays.sort(nums);\\n        Arrays.sort(divisors);\\n        int max = 0;\\n        int res = divisors[0];\\n        int lo = 0;\\n        for(int d : divisors) {\\n            int score = 0;\\n            lo = binarySearch(nums, d, lo);\\n            if(lo >= nums.length) {\\n                break;\\n            }\\n            for(int i = lo; i < nums.length; ++i) {\\n                if( nums[i] % d == 0) {\\n                    ++score;\\n                }\\n            }\\n            if(score > max) {\\n                max = score;\\n                res = d;\\n            } else if (score == max) {\\n                res = Math.min(res, d);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private int binarySearch(int[] nums, int target) {\\n        int i = 0;\\n        int j = nums.length;\\n        while(i < j) {\\n            int mid = i + (j - i) / 2;\\n            if(nums[mid] < target) {\\n                i = mid + 1;\\n            } else {\\n                j = mid;\\n            }\\n        }\\n        return i;\\n    }\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        Arrays.sort(nums);\\n        int max = 0;\\n        int res = divisors[0];\\n        for(int d : divisors) {\\n            int score = 0;\\n            for(int i = binarySearch(nums, d); i < nums.length; ++i) {\\n                if( nums[i] % d == 0) {\\n                    ++score;\\n                }\\n            }\\n            if(score > max) {\\n                max = score;\\n                res = d;\\n            } else if (score == max) {\\n                res = Math.min(res, d);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    private int binarySearch(int[] nums, int target, int lo) {\\n        int hi = nums.length;\\n        while(lo < hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            if(nums[mid] < target) {\\n                lo = mid + 1;\\n            } else {\\n                hi = mid;\\n            }\\n        }\\n        return lo;\\n    }\\n\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        Arrays.sort(nums);\\n        Arrays.sort(divisors);\\n        int max = 0;\\n        int res = divisors[0];\\n        int lo = 0;\\n        for(int d : divisors) {\\n            int score = 0;\\n            lo = binarySearch(nums, d, lo);\\n            if(lo >= nums.length) {\\n                break;\\n            }\\n            for(int i = lo; i < nums.length; ++i) {\\n                if( nums[i] % d == 0) {\\n                    ++score;\\n                }\\n            }\\n            if(score > max) {\\n                max = score;\\n                res = d;\\n            } else if (score == max) {\\n                res = Math.min(res, d);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3427066,
                "title": "easy-python-solution",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n        l=[]\\n        divisors.sort()\\n        for i in divisors:\\n            c=0\\n            for j in nums:\\n                if j%i==0:\\n                    c+=1\\n            l.append(c)\\n        return divisors[l.index(max(l))]\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n        l=[]\\n        divisors.sort()\\n        for i in divisors:\\n            c=0\\n            for j in nums:\\n                if j%i==0:\\n                    c+=1\\n            l.append(c)\\n        return divisors[l.index(max(l))]\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3478271,
                "title": "easy-faster-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int res = 0, curr = -1;\\n        for(auto &d: divisors){\\n            int score = 0;\\n            for(auto &it: nums)     \\n                score += (it % d == 0);\\n            if(score >= curr){\\n                if(score == curr)       \\n                    res = min(res, d);\\n                else                    \\n                    res = d;                    \\n                curr = score;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int res = 0, curr = -1;\\n        for(auto &d: divisors){\\n            int score = 0;\\n            for(auto &it: nums)     \\n                score += (it % d == 0);\\n            if(score >= curr){\\n                if(score == curr)       \\n                    res = min(res, d);\\n                else                    \\n                    res = d;                    \\n                curr = score;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3444500,
                "title": "99-fast-c-best-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n       sort(nums.begin(), nums.end());\\n        int maxi = *max_element(nums.begin(), nums.end());\\n        map<int, int>mp;\\n       for(int i = 0; i<divisors.size(); i++)\\n       {\\n           int count = 0;\\n           for(int j = divisors[i]; j<=maxi; j = j+divisors[i])\\n           {\\n               int l = lower_bound(nums.begin(), nums.end(), j)-nums.begin();\\n               int u = upper_bound(nums.begin(), nums.end(), j)-nums.begin();\\n               if(nums[l] == j)\\n               {\\n                   count = count+(u-l);\\n               }\\n           }\\n           mp[divisors[i]] = count;\\n           //cout<<count<<\" \";\\n       }\\n        \\n        int ans = INT_MIN;\\n        int max = INT_MAX;\\n        for(auto i : mp)\\n        {\\n            if(i.second>ans)\\n            {\\n                ans = i.second;\\n                max = i.first;\\n            }\\n            else if(i.second==ans)\\n            {\\n                if(i.first < max)\\n                {\\n                    max = i.first;\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n       sort(nums.begin(), nums.end());\\n        int maxi = *max_element(nums.begin(), nums.end());\\n        map<int, int>mp;\\n       for(int i = 0; i<divisors.size(); i++)\\n       {\\n           int count = 0;\\n           for(int j = divisors[i]; j<=maxi; j = j+divisors[i])\\n           {\\n               int l = lower_bound(nums.begin(), nums.end(), j)-nums.begin();\\n               int u = upper_bound(nums.begin(), nums.end(), j)-nums.begin();\\n               if(nums[l] == j)\\n               {\\n                   count = count+(u-l);\\n               }\\n           }\\n           mp[divisors[i]] = count;\\n           //cout<<count<<\" \";\\n       }\\n        \\n        int ans = INT_MIN;\\n        int max = INT_MAX;\\n        for(auto i : mp)\\n        {\\n            if(i.second>ans)\\n            {\\n                ans = i.second;\\n                max = i.first;\\n            }\\n            else if(i.second==ans)\\n            {\\n                if(i.first < max)\\n                {\\n                    max = i.first;\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3423433,
                "title": "easiest-solution-using-two-for-loops",
                "content": "# Intuition\\nUsing two for loops to iterate through the arrays.\\n\\n# Approach\\nBy taking the divisors one by one we count how many of elements of nums array are divisible by the divisors. Bycomparing with maxScore we find the divisor element with max score.\\n\\n# Complexity\\n- Time complexity:\\nO(n2)\\n\\n- Space complexity:\\nO(0)\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        Arrays.sort(divisors);\\n        int maxScore=0;\\n        int ans=0;\\n        for(int i=0; i<divisors.length; i++){\\n            int score=0;\\n            for(int j=0; j<nums.length;j++){\\n                if(nums[j]%divisors[i]==0){ //if the nums element is divisible by the divisor we increase the score by one\\n                    score++;\\n                }\\n            }\\n            if(score>maxScore){\\n//compare the score with maximum score\\n                maxScore=score;\\n                ans=divisors[i];\\n            }\\n        }\\n        \\n        if(ans==0) return divisors[0];\\n        \\n    return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        Arrays.sort(divisors);\\n        int maxScore=0;\\n        int ans=0;\\n        for(int i=0; i<divisors.length; i++){\\n            int score=0;\\n            for(int j=0; j<nums.length;j++){\\n                if(nums[j]%divisors[i]==0){ //if the nums element is divisible by the divisor we increase the score by one\\n                    score++;\\n                }\\n            }\\n            if(score>maxScore){\\n//compare the score with maximum score\\n                maxScore=score;\\n                ans=divisors[i];\\n            }\\n        }\\n        \\n        if(ans==0) return divisors[0];\\n        \\n    return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422013,
                "title": "simple-solution-in-go-and-c",
                "content": "\\n\\n# Complexity\\n- Time complexity: $$O(n*m)$$\\n<!-- Add your time complexity here, e.g.  -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc maxDivScore(nums []int, divisors []int) int {\\n    maxCount, index := 0, 0\\n    \\n    for i := 0; i < len(divisors); i++ {\\n        count := 0\\n        for j := 0; j < len(nums); j++ {\\n            if nums[j] % divisors[i] == 0 {\\n                count++\\n            }\\n        }\\n        \\n        if count > maxCount || (count == maxCount && divisors[i] < divisors[index]) {\\n            maxCount = count\\n            index = i\\n        }\\n    }\\n    \\n    return divisors[index]\\n}\\n```\\nC#\\n```\\npublic class Solution {\\n    public int MaxDivScore(int[] nums, int[] divisors) {\\n        int maxCount = 0;\\n        int index = 0;\\n        \\n        for (int i = 0; i < divisors.Length; i++) {\\n            int count = 0;\\n            for (int j = 0; j < nums.Length; j++) {\\n                if (nums[j] % divisors[i] == 0) {\\n                    count++;\\n                }\\n            }\\n            \\n            if (count > maxCount || (count == maxCount && divisors[i] < divisors[index])) {\\n                maxCount = count;\\n                index = i;\\n            }\\n        }\\n        \\n        return divisors[index];\\n    }\\n}\\n```\\n![a6c83c54-1d1a-4f26-8273-b687d119dd5b_1679889261.1494205.png](https://assets.leetcode.com/users/images/cc82e8aa-dc98-4f10-af4c-64b1528c0fb6_1680844232.130332.png)",
                "solutionTags": [
                    "C#",
                    "Go"
                ],
                "code": "```\\nfunc maxDivScore(nums []int, divisors []int) int {\\n    maxCount, index := 0, 0\\n    \\n    for i := 0; i < len(divisors); i++ {\\n        count := 0\\n        for j := 0; j < len(nums); j++ {\\n            if nums[j] % divisors[i] == 0 {\\n                count++\\n            }\\n        }\\n        \\n        if count > maxCount || (count == maxCount && divisors[i] < divisors[index]) {\\n            maxCount = count\\n            index = i\\n        }\\n    }\\n    \\n    return divisors[index]\\n}\\n```\n```\\npublic class Solution {\\n    public int MaxDivScore(int[] nums, int[] divisors) {\\n        int maxCount = 0;\\n        int index = 0;\\n        \\n        for (int i = 0; i < divisors.Length; i++) {\\n            int count = 0;\\n            for (int j = 0; j < nums.Length; j++) {\\n                if (nums[j] % divisors[i] == 0) {\\n                    count++;\\n                }\\n            }\\n            \\n            if (count > maxCount || (count == maxCount && divisors[i] < divisors[index])) {\\n                maxCount = count;\\n                index = i;\\n            }\\n        }\\n        \\n        return divisors[index];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421910,
                "title": "c-brute-force-easy-to-understand",
                "content": "````\\n\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int x = 0, y = 0,ans = INT_MAX;\\n        for(auto &i: divisors){\\n            x = 0;\\n            for(auto &j: nums){\\n                if(j%i==0){\\n                    x++;\\n                }\\n            }\\n            if(x>y){\\n                y = x;\\n                ans = i;\\n            }\\n            if(x==y){\\n                ans = min(ans,i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "````\\n\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int x = 0, y = 0,ans = INT_MAX;\\n        for(auto &i: divisors){\\n            x = 0;\\n            for(auto &j: nums){\\n                if(j%i==0){\\n                    x++;\\n                }\\n            }\\n            if(x>y){\\n                y = x;\\n                ans = i;\\n            }\\n            if(x==y){\\n                ans = min(ans,i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421860,
                "title": "c-easy-peasy-solution-with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe function maxDivisor takes in two vectors nums and divisors. It first initializes an unordered map scores to map each divisor to its     score. It then loops through each divisor in divisors, counts its score by looping through each number in nums, and updates max_score and      max_divisor if the score is greater than max_score or equal to max_score and the divisor is less than max_divisor. Finally, it returns       max_divisor\\n# Complexity\\n- Time complexity: O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        \\n        unordered_map<int, int> scores; // map each divisor to its score\\n        \\n        int max_score = 0;\\n        int max_divisor = divisors[0];\\n        \\n        for (int divisor : divisors) \\n        {\\n            scores[divisor] = 0;\\n            \\n            for (int num : nums) \\n            {\\n                if (num % divisor == 0) \\n                    scores[divisor]++;\\n            }\\n            \\n            if (scores[divisor] > max_score || (scores[divisor] == max_score && divisor < max_divisor)) \\n            {\\n                max_score = scores[divisor];\\n                max_divisor = divisor;\\n            }\\n        }\\n        \\n        return max_divisor;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        \\n        unordered_map<int, int> scores; // map each divisor to its score\\n        \\n        int max_score = 0;\\n        int max_divisor = divisors[0];\\n        \\n        for (int divisor : divisors) \\n        {\\n            scores[divisor] = 0;\\n            \\n            for (int num : nums) \\n            {\\n                if (num % divisor == 0) \\n                    scores[divisor]++;\\n            }\\n            \\n            if (scores[divisor] > max_score || (scores[divisor] == max_score && divisor < max_divisor)) \\n            {\\n                max_score = scores[divisor];\\n                max_divisor = divisor;\\n            }\\n        }\\n        \\n        return max_divisor;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421846,
                "title": "c-easytounderstand-optimalsolution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int count = 0;\\n        int hold = INT_MAX;\\n        for(int i=0;i<divisors.size();i++){\\n            int curr = 0;\\n            for(int j=0;j<nums.size();j++){\\n                if(nums[j]%divisors[i] == 0) \\n                    curr++;\\n            }\\n            if(curr > count){\\n                count = curr;\\n                hold = divisors[i];\\n            }\\n            if(curr == count && divisors[i]<hold)\\n                hold = divisors[i];\\n        }\\n        return hold;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int count = 0;\\n        int hold = INT_MAX;\\n        for(int i=0;i<divisors.size();i++){\\n            int curr = 0;\\n            for(int j=0;j<nums.size();j++){\\n                if(nums[j]%divisors[i] == 0) \\n                    curr++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3421825,
                "title": "clean-easy-solution",
                "content": "```\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n        mD = 0\\n        res = min(divisors)\\n        for d in divisors:\\n            cntr = 0\\n            for num in nums:\\n                if num%d == 0:\\n                    cntr += 1\\n            if cntr > mD:\\n                res = d\\n                mD = cntr\\n            elif cntr == mD:\\n                res = min(res,d)\\n        return res",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n        mD = 0\\n        res = min(divisors)\\n        for d in divisors:\\n            cntr = 0\\n            for num in nums:\\n                if num%d == 0:\\n                    cntr += 1\\n            if cntr > mD:\\n                res = d\\n                mD = cntr\\n            elif cntr == mD:\\n                res = min(res,d)\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 3421772,
                "title": "c-beginer-friendly",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n       int n=divisors.size();\\n        vector<int> s(n,0);\\n       vector<pair<int,int>> vec;\\n        for(int i=0;i<n;i++){\\n            int c=0;\\n            for(int j=0;j<nums.size();j++){\\n                if(nums[j]%divisors[i]==0)c++;\\n            }\\n            vec.push_back({c,divisors[i]});\\n        }\\n        sort(vec.begin(),vec.end());\\n        int x=vec[vec.size()-1].first;\\n        for(auto it: vec){\\n            if(it.first==x){\\n                return it.second;\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n       int n=divisors.size();\\n        vector<int> s(n,0);\\n       vector<pair<int,int>> vec;\\n        for(int i=0;i<n;i++){\\n            int c=0;\\n            for(int j=0;j<nums.size();j++){\\n                if(nums[j]%divisors[i]==0)c++;\\n            }\\n            vec.push_back({c,divisors[i]});\\n        }\\n        sort(vec.begin(),vec.end());\\n        int x=vec[vec.size()-1].first;\\n        for(auto it: vec){\\n            if(it.first==x){\\n                return it.second;\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3900329,
                "title": "java-beginner-bruteforce-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        \\n       \\n        int a=0;\\n        int aa=Integer.MAX_VALUE;\\n        for(int i=divisors.length-1;i>=0;i--){\\n            int d=divisors[i];\\n             int c=0;\\n            for(int j=0;j<nums.length;j++){\\n                if(nums[j]%d==0)\\n                c++;\\n            }\\n            if(c==a){\\n                aa=Math.min(aa,d);\\n\\n            }\\n            if(c>a){\\n                a=c;\\n                aa=d;\\n\\n            }\\n        }\\n        return aa;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        \\n       \\n        int a=0;\\n        int aa=Integer.MAX_VALUE;\\n        for(int i=divisors.length-1;i>=0;i--){\\n            int d=divisors[i];\\n             int c=0;\\n            for(int j=0;j<nums.length;j++){\\n                if(nums[j]%d==0)\\n                c++;\\n            }\\n            if(c==a){\\n                aa=Math.min(aa,d);\\n\\n            }\\n            if(c>a){\\n                a=c;\\n                aa=d;\\n\\n            }\\n        }\\n        return aa;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3698119,
                "title": "python-95",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n        count = 0\\n        maximal = 0\\n        result = []\\n        for divisor in divisors:\\n            for n in nums:\\n                if n % divisor == 0:\\n                    count += 1\\n            if count > maximal:\\n                maximal = count\\n                result = [divisor]\\n            elif count == maximal:\\n                result.append(divisor)\\n            count = 0\\n        return min(result)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n        count = 0\\n        maximal = 0\\n        result = []\\n        for divisor in divisors:\\n            for n in nums:\\n                if n % divisor == 0:\\n                    count += 1\\n            if count > maximal:\\n                maximal = count\\n                result = [divisor]\\n            elif count == maximal:\\n                result.append(divisor)\\n            count = 0\\n        return min(result)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3518098,
                "title": "find-the-maximum-divisibility-score-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int i, j, score, max=0, ans=divisors[0];\\n        for(i=0 ; i<divisors.size() ; i++)\\n        {\\n            score = 0;\\n            for(j=0 ; j<nums.size() ; j++)\\n            {\\n                if(nums[j]%divisors[i]==0)\\n                {\\n                    score++;\\n                }\\n            }\\n            if(score>max)\\n            {\\n                max = score;\\n                ans = divisors[i];\\n            }\\n            else if(score==max && divisors[i]<ans)\\n            {\\n                ans = divisors[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/e7d4450c-db89-4385-9fe3-6c42fad1000c_1683948810.613229.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int i, j, score, max=0, ans=divisors[0];\\n        for(i=0 ; i<divisors.size() ; i++)\\n        {\\n            score = 0;\\n            for(j=0 ; j<nums.size() ; j++)\\n            {\\n                if(nums[j]%divisors[i]==0)\\n                {\\n                    score++;\\n                }\\n            }\\n            if(score>max)\\n            {\\n                max = score;\\n                ans = divisors[i];\\n            }\\n            else if(score==max && divisors[i]<ans)\\n            {\\n                ans = divisors[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3503665,
                "title": "easy-solution-with-50-beats-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n       ArrayList<Integer> list = new ArrayList<>();\\n       ArrayList<Integer> finalList = new ArrayList<>();\\n\\n       int j = 0;\\n       while(j<divisors.length){\\n           int i = 0;\\n           int count = 0;\\n           while(i<nums.length){\\n           if(nums[i]%divisors[j] == 0){\\n               count++;\\n           }\\n           i++;\\n        }\\n        list.add(count);\\n           j++;\\n        }\\n\\n        int a = Collections.max(list);\\n        for(int m =0 ; m<list.size(); m++){\\n            if(a == list.get(m)){\\n                finalList.add(divisors[m]);\\n            }\\n        }\\n\\n\\n\\n        return Collections.min(finalList);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n       ArrayList<Integer> list = new ArrayList<>();\\n       ArrayList<Integer> finalList = new ArrayList<>();\\n\\n       int j = 0;\\n       while(j<divisors.length){\\n           int i = 0;\\n           int count = 0;\\n           while(i<nums.length){\\n           if(nums[i]%divisors[j] == 0){\\n               count++;\\n           }\\n           i++;\\n        }\\n        list.add(count);\\n           j++;\\n        }\\n\\n        int a = Collections.max(list);\\n        for(int m =0 ; m<list.size(); m++){\\n            if(a == list.get(m)){\\n                finalList.add(divisors[m]);\\n            }\\n        }\\n\\n\\n\\n        return Collections.min(finalList);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3499101,
                "title": "easy-java-solution-not-good-beats-though",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int score[][] = new int[divisors.length][2];\\n        for(int i=0; i<divisors.length; i++) {\\n            int count = 0;\\n            for(int j=0; j<nums.length; j++) {\\n                if(nums[j] % divisors[i] == 0) {\\n                    count++;\\n                }\\n            }\\n            score[i][0] = divisors[i];\\n            score[i][1] = count;\\n        }\\n        Arrays.sort(score, Comparator.comparingDouble(o -> o[1]));\\n\\n        ArrayList<Integer> ansList = new ArrayList<>();\\n        ansList.add(score[score.length-1][0]);\\n        for(int k=score.length-2; k>=0; k--) {\\n            if(score[score.length-1][1]==score[k][1]) {\\n                ansList.add(score[k][0]);\\n            }\\n        }\\n\\n        Collections.sort(ansList);\\n        return ansList.get(0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int score[][] = new int[divisors.length][2];\\n        for(int i=0; i<divisors.length; i++) {\\n            int count = 0;\\n            for(int j=0; j<nums.length; j++) {\\n                if(nums[j] % divisors[i] == 0) {\\n                    count++;\\n                }\\n            }\\n            score[i][0] = divisors[i];\\n            score[i][1] = count;\\n        }\\n        Arrays.sort(score, Comparator.comparingDouble(o -> o[1]));\\n\\n        ArrayList<Integer> ansList = new ArrayList<>();\\n        ansList.add(score[score.length-1][0]);\\n        for(int k=score.length-2; k>=0; k--) {\\n            if(score[score.length-1][1]==score[k][1]) {\\n                ansList.add(score[k][0]);\\n            }\\n        }\\n\\n        Collections.sort(ansList);\\n        return ansList.get(0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3436628,
                "title": "swift-functional-approach",
                "content": "**Functional Approach (accepted answer)**\\n```\\nclass Solution {\\n    func maxDivScore(_ nums: [Int], _ divisors: [Int]) -> Int {\\n        divisors.reduce((maxScore: -1, minDivisor: 0)) { result, divisor in\\n            let score = nums.reduce(0) { score, num in score + (num % divisor == 0 ? 1: 0) }\\n            let update = score > result.maxScore || (score == result.maxScore && divisor < result.minDivisor)\\n            return update ? (maxScore: score, minDivisor: divisor) : result\\n        }.minDivisor\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func maxDivScore(_ nums: [Int], _ divisors: [Int]) -> Int {\\n        divisors.reduce((maxScore: -1, minDivisor: 0)) { result, divisor in\\n            let score = nums.reduce(0) { score, num in score + (num % divisor == 0 ? 1: 0) }\\n            let update = score > result.maxScore || (score == result.maxScore && divisor < result.minDivisor)\\n            return update ? (maxScore: score, minDivisor: divisor) : result\\n        }.minDivisor\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3426648,
                "title": "beats-100-java-simple-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwe are takin a boolean  variable as false to check whether the count remains 0 case.\\nso what we did is we first ran the outer loop for divisor array then we run a inner loop for nums array and go on checking for the count of nums element those are divisible by divisor array element. Then we check for a condition if **(maxCount< count)** we will update it and mark as true. Else we will check for the **count==maxCount** and we will check that our res has updated or not by the help of boolean variable. if It is then we simply update res. If boolean variable remains false then we simply find min because it means no of count remains 0 for all the element.\\nAnd at last we will check boolean variable value if its true we simply return res else we return min.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nums.length*divisors.length)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        \\n  \\t\\tint maxCount = 0, res = 0,min=Integer.MAX_VALUE;\\n\\t\\tboolean isGreater=false;\\n\\n\\t\\tfor (int i = 0; i < divisors.length; i++) {\\n\\t\\t\\tint count = 0 ;\\n\\t\\t\\t//res = div[i];\\n\\n\\t\\t\\tfor (int j = 0; j < nums.length; j++) {\\n\\t\\t\\t\\tif (nums[j] % divisors[i] == 0) {\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif (maxCount < count) {\\n\\t\\t\\t\\tmaxCount = count;\\n\\t\\t\\t\\tres = divisors[i];\\n\\t\\t\\t\\tisGreater=true;\\n\\t\\t\\t}\\n            if(maxCount == count) {\\n\\t\\t\\t\\tif(res > divisors[i] && isGreater) {\\n\\t\\t\\t\\t\\tres = divisors[i];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(min>divisors[i]) {\\n\\t\\t\\t\\t\\tmin=divisors[i];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn (isGreater)?res:min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        \\n  \\t\\tint maxCount = 0, res = 0,min=Integer.MAX_VALUE;\\n\\t\\tboolean isGreater=false;\\n\\n\\t\\tfor (int i = 0; i < divisors.length; i++) {\\n\\t\\t\\tint count = 0 ;\\n\\t\\t\\t//res = div[i];\\n\\n\\t\\t\\tfor (int j = 0; j < nums.length; j++) {\\n\\t\\t\\t\\tif (nums[j] % divisors[i] == 0) {\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif (maxCount < count) {\\n\\t\\t\\t\\tmaxCount = count;\\n\\t\\t\\t\\tres = divisors[i];\\n\\t\\t\\t\\tisGreater=true;\\n\\t\\t\\t}\\n            if(maxCount == count) {\\n\\t\\t\\t\\tif(res > divisors[i] && isGreater) {\\n\\t\\t\\t\\t\\tres = divisors[i];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(min>divisors[i]) {\\n\\t\\t\\t\\t\\tmin=divisors[i];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn (isGreater)?res:min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3425957,
                "title": "brute-force-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) \\n    {\\n        int score = 0;\\n        int ans   = *min_element(divisors.begin(),divisors.end());\\n\\n        for(int i=0;i<divisors.size();i++)\\n        {\\n            int count = 0;\\n            for(int j=0;j<nums.size();j++)\\n            {\\n                   if((nums[j] % divisors[i]) == 0)\\n                   {\\n                       count++;\\t\\n                   }\\t\\t\\n            }\\n            if(count > score)\\n            {\\n                ans = divisors[i];\\n                score = count;\\n            }\\n            else if(count == score and divisors[i] < ans)\\n            {\\n                 ans = divisors[i];\\n            }\\n        }\\n        return ans;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) \\n    {\\n        int score = 0;\\n        int ans   = *min_element(divisors.begin(),divisors.end());\\n\\n        for(int i=0;i<divisors.size();i++)\\n        {\\n            int count = 0;\\n            for(int j=0;j<nums.size();j++)\\n            {\\n                   if((nums[j] % divisors[i]) == 0)\\n                   {\\n                       count++;\\t\\n                   }\\t\\t\\n            }\\n            if(count > score)\\n            {\\n                ans = divisors[i];\\n                score = count;\\n            }\\n            else if(count == score and divisors[i] < ans)\\n            {\\n                 ans = divisors[i];\\n            }\\n        }\\n        return ans;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3424758,
                "title": "c-brute-force",
                "content": "# Complexity\\n- Time complexity: $$O(n*m)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n*m)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int ans=0, ans2=0;\\n        for (int i=0; i<divisors.size(); i++){\\n            int curr=0;\\n            for (int j=0; j<nums.size(); j++){\\n                if (nums[j]%divisors[i]==0)curr++;\\n            }\\n            if (curr>ans){\\n                ans= curr;\\n                ans2= i;\\n            }\\n            else if (curr==ans && divisors[i]<divisors[ans2]){\\n                ans2=i;\\n                ans= curr;\\n            }\\n        }\\n        return divisors[ans2];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Matrix",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int ans=0, ans2=0;\\n        for (int i=0; i<divisors.size(); i++){\\n            int curr=0;\\n            for (int j=0; j<nums.size(); j++){\\n                if (nums[j]%divisors[i]==0)curr++;\\n            }\\n            if (curr>ans){\\n                ans= curr;\\n                ans2= i;\\n            }\\n            else if (curr==ans && divisors[i]<divisors[ans2]){\\n                ans2=i;\\n                ans= curr;\\n            }\\n        }\\n        return divisors[ans2];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422931,
                "title": "easy-c-solution-brute-force-map",
                "content": "# Intuition\\nBrute force approach and  to reduce repeated calculation  map is used.\\n\\n# Approach\\nBrute force +map\\n\\n# Complexity\\n- Time complexity:\\nO(n*m)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        map<int,int>mp;\\n        int maxi=INT_MIN;\\n        int ans=0;\\n        for(auto it:divisors){\\n     //avoiding repeated divisors\\n            if(mp[it]==0){\\n                for(int i=0;i<nums.size();i++){\\n                if(nums[i]%it==0){\\n                    mp[it]+=1;\\n                }\\n            }\\n            }\\n        }\\n        for(auto it:mp){\\n            if(it.second>maxi){\\n                maxi=it.second;\\n                ans=it.first;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        map<int,int>mp;\\n        int maxi=INT_MIN;\\n        int ans=0;\\n        for(auto it:divisors){\\n     //avoiding repeated divisors\\n            if(mp[it]==0){\\n                for(int i=0;i<nums.size();i++){\\n                if(nums[i]%it==0){\\n                    mp[it]+=1;\\n                }\\n            }\\n            }\\n        }\\n        for(auto it:mp){\\n            if(it.second>maxi){\\n                maxi=it.second;\\n                ans=it.first;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422913,
                "title": "146-ms",
                "content": "```rust\\nimpl Solution {\\n    pub fn max_div_score(mut a: Vec<i32>, mut b: Vec<i32>) -> i32 {\\n        a.sort(); b.sort(); let az = a.len();\\n        let (mut r, mut m, mut s, mut p) = (0, -1, 0usize, 0);\\n        for d in b {\\n            if d == p { continue } else { p = d }\\n            while s < az && a[s] < d { s += 1 }\\n            if (az - s) as i32 <= m { break }\\n            let mut c = 0;\\n            for j in s..az {\\n                if a[j] % d == 0 { c += 1 }\\n            }\\n            if c > m { r = d; m = c }\\n        }\\n        r\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn max_div_score(mut a: Vec<i32>, mut b: Vec<i32>) -> i32 {\\n        a.sort(); b.sort(); let az = a.len();\\n        let (mut r, mut m, mut s, mut p) = (0, -1, 0usize, 0);\\n        for d in b {\\n            if d == p { continue } else { p = d }\\n            while s < az && a[s] < d { s += 1 }\\n            if (az - s) as i32 <= m { break }\\n            let mut c = 0;\\n            for j in s..az {\\n                if a[j] % d == 0 { c += 1 }\\n            }\\n            if c > m { r = d; m = c }\\n        }\\n        r\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3422695,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n        ans=-1\\n        most=-1\\n        for d in divisors:\\n            cnt=sum(1 for n in nums if n%d==0)\\n            if cnt>most or cnt==most and d<ans:\\n                ans=d\\n                most=cnt\\n\\n        return ans        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n        ans=-1\\n        most=-1\\n        for d in divisors:\\n            cnt=sum(1 for n in nums if n%d==0)\\n            if cnt>most or cnt==most and d<ans:\\n                ans=d\\n                most=cnt\\n\\n        return ans        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422287,
                "title": "no-brute-force-highly-optimized-enough-for-n-1e5",
                "content": "# Approach\\nsuppose n = 20\\nAll the prime factors of 30 = {2,3,5}\\nand all the divisors of 20 = {1,2,3,6,5,10,15,30}\\nwhich can be genrated by the combination from the prime numbers.\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    vector<int> allDivisor(int n){\\n        // calculate all prime factors of n\\n        map<int,int> primes;\\n        for(long long i=2; i<=sqrt(n); i++) {\\n            while(n%i == 0) {\\n                primes[i]++;\\n                n/=i;\\n            }\\n        }\\n        if (n > 1) primes[n]++;\\n\\n        // make all divisors by primes\\n        vector<int> divisors = {1};\\n        for(auto&p: primes) {\\n            int sz = divisors.size();\\n            int cur = 1;\\n            for (int i=0; i <p.second; i++) {\\n                cur *= p.first;\\n                for (int j = 0; j < sz; j++) {\\n                    divisors.push_back(divisors[j] * cur);\\n                }\\n            }\\n        }\\n        return divisors;\\n    }\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        map<int,int> freq; // used to store the frequency of each number which is the factor if nums[i]\\n        set<int> st(begin(divisors),end(divisors)); // It\\'s for like storing the frequency of elements which is only present in divisors array. (It\\'s for space optimisation)\\n\\n        // storing the divisors of all the elements of nums[i]\\n        for(int&num: nums){\\n            auto factors = allDivisor(num);\\n            for(int&factor: factors)\\n                if(st.count(factor)) freq[factor]++;\\n        }\\n\\n        // simply checking the freq of each divisors[i] in freq map\\n        int maxfreq = -1,ans = -1,mn = 1e9;\\n        for(int&e: divisors){\\n            if(freq.count(e)){\\n                int val = freq[e];\\n                if(maxfreq < val){\\n                    maxfreq = val;\\n                    ans = e;\\n                }else if(maxfreq == val){\\n                    ans = min(ans,e);\\n                }\\n            }\\n            mn = min(mn,e);\\n        }\\n        return ans == -1 ? mn : ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Math",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    vector<int> allDivisor(int n){\\n        // calculate all prime factors of n\\n        map<int,int> primes;\\n        for(long long i=2; i<=sqrt(n); i++) {\\n            while(n%i == 0) {\\n                primes[i]++;\\n                n/=i;\\n            }\\n        }\\n        if (n > 1) primes[n]++;\\n\\n        // make all divisors by primes\\n        vector<int> divisors = {1};\\n        for(auto&p: primes) {\\n            int sz = divisors.size();\\n            int cur = 1;\\n            for (int i=0; i <p.second; i++) {\\n                cur *= p.first;\\n                for (int j = 0; j < sz; j++) {\\n                    divisors.push_back(divisors[j] * cur);\\n                }\\n            }\\n        }\\n        return divisors;\\n    }\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        map<int,int> freq; // used to store the frequency of each number which is the factor if nums[i]\\n        set<int> st(begin(divisors),end(divisors)); // It\\'s for like storing the frequency of elements which is only present in divisors array. (It\\'s for space optimisation)\\n\\n        // storing the divisors of all the elements of nums[i]\\n        for(int&num: nums){\\n            auto factors = allDivisor(num);\\n            for(int&factor: factors)\\n                if(st.count(factor)) freq[factor]++;\\n        }\\n\\n        // simply checking the freq of each divisors[i] in freq map\\n        int maxfreq = -1,ans = -1,mn = 1e9;\\n        for(int&e: divisors){\\n            if(freq.count(e)){\\n                int val = freq[e];\\n                if(maxfreq < val){\\n                    maxfreq = val;\\n                    ans = e;\\n                }else if(maxfreq == val){\\n                    ans = min(ans,e);\\n                }\\n            }\\n            mn = min(mn,e);\\n        }\\n        return ans == -1 ? mn : ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422159,
                "title": "optimized-java-solution-easy-structured-with-comments-and-approach",
                "content": "# Approach\\nWe will iterate through all the divisors and check how many of the numbers they can divide. While doing this, we will keep track of the divisor which divided maximum of numbers.\\n\\nNote: The only thing that can cause error in this problem is the edge condition. i.e. if the maximum count is same, we need to return the minimum divisor that had that score. Hence, we need to add an extra condition for it.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(M*N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int maxScore=-1;\\n        int maxElement=-1;\\n        for(int i=0;i<divisors.length;i++){\\n            // count of numbers ith divisor can divide\\n            int score=0;\\n            for(int j=0;j<nums.length;j++){\\n                if(nums[j]%divisors[i]==0)\\n                    score++;\\n            }\\n\\n            // updating max count\\n            if(score==maxScore) // edge condition\\n                maxElement=Math.min(maxElement,divisors[i]);\\n            else if(score>maxScore){\\n                maxScore=score;\\n                maxElement=divisors[i];\\n            }\\n        }\\n        return maxElement;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int maxScore=-1;\\n        int maxElement=-1;\\n        for(int i=0;i<divisors.length;i++){\\n            // count of numbers ith divisor can divide\\n            int score=0;\\n            for(int j=0;j<nums.length;j++){\\n                if(nums[j]%divisors[i]==0)\\n                    score++;\\n            }\\n\\n            // updating max count\\n            if(score==maxScore) // edge condition\\n                maxElement=Math.min(maxElement,divisors[i]);\\n            else if(score>maxScore){\\n                maxScore=score;\\n                maxElement=divisors[i];\\n            }\\n        }\\n        return maxElement;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422129,
                "title": "find-the-maximum-divisibility-score-simple-approach-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& div) {\\n        int maxcnt = 0;\\n        int ans=INT_MAX;\\n        for(int i=0;i<div.size();i++){\\n            int cnt=0;int f = 1;\\n            for(int j=0;j<nums.size();j++){\\n                if(nums[j]%div[i]==0){\\n                    cnt++;\\n                }\\n            }\\n            if(cnt>maxcnt){\\n                ans = div[i];\\n                maxcnt = cnt;\\n            }else if(cnt==maxcnt){\\n                ans = min(ans,div[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& div) {\\n        int maxcnt = 0;\\n        int ans=INT_MAX;\\n        for(int i=0;i<div.size();i++){\\n            int cnt=0;int f = 1;\\n            for(int j=0;j<nums.size();j++){\\n                if(nums[j]%div[i]==0){\\n                    cnt++;\\n                }\\n            }\\n            if(cnt>maxcnt){\\n                ans = div[i];\\n                maxcnt = cnt;\\n            }else if(cnt==maxcnt){\\n                ans = min(ans,div[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422083,
                "title": "easyapproach-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe initialize maxScore to -1 and maxDivisor to Integer.MAX_VALUE.\\n\\n Then, we loop through all the divisors in the array divisors. \\n\\nFor each divisor, we count the number of elements in the array nums that are divisible by that divisor. \\n\\nIf this count is greater than the current maximum score, we update maxScore and maxDivisor to the current divisor. \\n\\nIf the score is equal to the current maximum score, we update maxDivisor only if the current divisor is smaller than the current maximum divisor.\\n\\nFinally, we return maxDivisor as the integer with the maximum divisibility score.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO (nxn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO (1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n    int maxScore = -1;\\n    int maxDivisor = Integer.MAX_VALUE;\\n\\n    for (int divisor : divisors) {\\n        int score = 0;\\n        for (int num : nums) {\\n            if (num % divisor == 0) {\\n                score++;\\n            }\\n        }\\n        if (score > maxScore || (score == maxScore && divisor < maxDivisor)) {\\n            maxScore = score;\\n            maxDivisor = divisor;\\n        }\\n    }\\n\\n    return maxDivisor;\\n}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n    int maxScore = -1;\\n    int maxDivisor = Integer.MAX_VALUE;\\n\\n    for (int divisor : divisors) {\\n        int score = 0;\\n        for (int num : nums) {\\n            if (num % divisor == 0) {\\n                score++;\\n            }\\n        }\\n        if (score > maxScore || (score == maxScore && divisor < maxDivisor)) {\\n            maxScore = score;\\n            maxDivisor = divisor;\\n        }\\n    }\\n\\n    return maxDivisor;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422042,
                "title": "best-c-well-explained-brute-force",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ntake divisor and check for every element of num is divisible or not and count the total number of divisible number.\\nafter that store it to the map. if same divisor come more then one time then we dont calculate it multiple time it is already stored in our map. simply skip same divisor.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n***O(N * M)***\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n***O(1)***\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        map<int, int> mp;\\n        for(int i=0; i<divisors.size(); i++)    {\\n            int cnt = 0;\\n            // same number comming then skip it ::\\n            if(mp.find(divisors[i]) != mp.end())    continue;\\n\\n            // count the number of divisible element in nums\\n            for(int j=0; j<nums.size(); j++)    \\n                if(nums[j] % divisors[i] == 0)  cnt++;\\n            \\n            mp[divisors[i]] = cnt;\\n        }\\n        int ans = *min_element(divisors.begin(), divisors.end());\\n        int cnt = mp[ans];\\n        for(auto it : mp)   {\\n            if(it.second > cnt) {\\n                cnt = it.second;\\n                ans = it.first;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        map<int, int> mp;\\n        for(int i=0; i<divisors.size(); i++)    {\\n            int cnt = 0;\\n            // same number comming then skip it ::\\n            if(mp.find(divisors[i]) != mp.end())    continue;\\n\\n            // count the number of divisible element in nums\\n            for(int j=0; j<nums.size(); j++)    \\n                if(nums[j] % divisors[i] == 0)  cnt++;\\n            \\n            mp[divisors[i]] = cnt;\\n        }\\n        int ans = *min_element(divisors.begin(), divisors.end());\\n        int cnt = mp[ans];\\n        for(auto it : mp)   {\\n            if(it.second > cnt) {\\n                cnt = it.second;\\n                ans = it.first;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422041,
                "title": "c-simple-divisibility-check",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCheck if a number divides another number.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor each divisors[i]--> if nums[j] is divisible by divisors[i], then increment the divisibiltiy score of divisors[i]\\n\\n# Complexity\\n- Time complexity: O(mn), m= length of divisors, n= length of nums\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& v, vector<int>& d) {\\n        int maxD= 0, ans=*min_element(d.begin(), d.end());\\n        for(int i=0;i<d.size();i++){\\n            int c=0;\\n            for(int j=0;j<v.size();j++){\\n                if(v[j]%d[i]==0) c++;\\n            }\\n            if(c>=maxD){\\n                if(c>maxD){\\n                maxD= c; ans= d[i];\\n                }\\n                else{\\n                    ans= min(ans, d[i]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& v, vector<int>& d) {\\n        int maxD= 0, ans=*min_element(d.begin(), d.end());\\n        for(int i=0;i<d.size();i++){\\n            int c=0;\\n            for(int j=0;j<v.size();j++){\\n                if(v[j]%d[i]==0) c++;\\n            }\\n            if(c>=maxD){\\n                if(c>maxD){\\n                maxD= c; ans= d[i];\\n                }\\n                else{\\n                    ans= min(ans, d[i]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421962,
                "title": "c-solutions-beginner-friendly-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int ans = 0, most = -1; \\n        for (auto& div : divisors) {\\n            int cnt = 0; \\n            for (auto & x : nums) {\\n                if (x % div == 0) ++ cnt; \\n            }\\n            if (cnt > most || cnt == most && div < ans) {ans = div, most = cnt; }\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int ans = 0, most = -1; \\n        for (auto& div : divisors) {\\n            int cnt = 0; \\n            for (auto & x : nums) {\\n                if (x % div == 0) ++ cnt; \\n            }\\n            if (cnt > most || cnt == most && div < ans) {ans = div, most = cnt; }\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421937,
                "title": "javascript-direct-way-516ms",
                "content": "```\\nconst maxDivScore = (a, b) => {\\n    let f = [];\\n    b.map((d, i) => {\\n        let cnt = 0;\\n        for (const x of a) {\\n            if (x % d == 0) cnt++;\\n        }\\n        f.push([cnt, d]);\\n    });\\n    f.sort((x, y) => y[0] - x[0] || x[1] - y[1]);\\n    return f[0][1];\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Sort"
                ],
                "code": "```\\nconst maxDivScore = (a, b) => {\\n    let f = [];\\n    b.map((d, i) => {\\n        let cnt = 0;\\n        for (const x of a) {\\n            if (x % d == 0) cnt++;\\n        }\\n        f.push([cnt, d]);\\n    });\\n    f.sort((x, y) => y[0] - x[0] || x[1] - y[1]);\\n    return f[0][1];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3421925,
                "title": "easy-c-solution-t-c-o-nm-s-c-o-m",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe given problem asks us to find the divisor in the input array divisors that has the highest divisibility score in the input array nums.\\n\\nTo solve this problem, we need to iterate over each divisor and count the number of elements in nums that are divisible by the current divisor. We can store the score for each divisor in an unordered map. After calculating the score for each divisor, we can then find the divisor with the highest score and return it. If there are multiple divisors with the same highest score, we can break the tie by choosing the smallest divisor.\\n\\nThe intuition behind this approach is that the divisibility score for a divisor is simply the count of the number of elements in nums that are divisible by the divisor. By iterating over each divisor and counting the number of elements that are divisible by it, we can determine which divisor has the highest score. The use of an unordered map allows us to store the score for each divisor and quickly look up the score for a given divisor during the iteration.\\n\\nOverall, the approach is straightforward and efficient, with a time complexity of O(nm) and a space complexity of O(m).\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach of the given code is to use a nested loop to calculate the divisibility score of each divisor by iterating over the input array nums.\\n\\nFor each divisor, the code iterates over each element of nums and checks if the element is divisible by the current divisor. If it is, it increments the score for the divisor. Finally, the code checks which divisor has the highest score and returns it. If there are multiple divisors with the same highest score, it returns the smallest of them.\\n\\n# Complexity\\n- Time complexity: O(nm)\\n-  where n is the length of nums and m is the length of divisors. This is because for each divisor in divisors, the code iterates over each element in nums. However, since the length of divisors is at most 1000, this code should run efficiently for most practical inputs.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(m)\\n- where m is the length of divisors. This is because the code uses an unordered map to store the divisibility score for each divisor, which takes up space proportional to the number of divisors.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n          unordered_map<int, int> mp;\\n          int maxScore = 0, maxDivisor = INT_MAX;\\n\\n          for (int divisor : divisors) {\\n              mp[divisor] = 0;\\n          for (int num : nums) {\\n              if (num % divisor == 0) {\\n                mp[divisor]++;\\n              }\\n            }\\n         if (mp[divisor] > maxScore) {\\n            maxScore = mp[divisor];\\n            maxDivisor = divisor;\\n        }\\n        else if (mp[divisor] == maxScore) {\\n            maxDivisor = min(maxDivisor, divisor);\\n        }\\n      }\\n    return maxDivisor;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n          unordered_map<int, int> mp;\\n          int maxScore = 0, maxDivisor = INT_MAX;\\n\\n          for (int divisor : divisors) {\\n              mp[divisor] = 0;\\n          for (int num : nums) {\\n              if (num % divisor == 0) {\\n                mp[divisor]++;\\n              }\\n            }\\n         if (mp[divisor] > maxScore) {\\n            maxScore = mp[divisor];\\n            maxDivisor = divisor;\\n        }\\n        else if (mp[divisor] == maxScore) {\\n            maxDivisor = min(maxDivisor, divisor);\\n        }\\n      }\\n    return maxDivisor;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421905,
                "title": "ez-brute-force-again-c-java-python",
                "content": "# Intuition\\nJust count the number of divisors for each divisors[i] in nums array. Since the constraints are low, TC: O(m*n) is feasible solution.\\n\\n\\n# Complexity\\n- Time complexity:\\nO(M*N)\\n\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors)\\n    {\\n        int d = divisors.size();\\n        vector<int> res(d,0);\\n        int maxDiv = 0;\\n        for(int i=0; i<d; i++)\\n        {\\n            int div = divisors[i];\\n            for(auto x : nums)\\n            {\\n                if(x%div == 0){\\n                    res[i]++;\\n                }\\n            }\\n            maxDiv = max(maxDiv, res[i]);\\n        }\\n        \\n        int ans = INT_MAX;\\n        for(int i=0; i<d; i++)\\n        {\\n            if(res[i] == maxDiv){\\n                ans = min(ans, divisors[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int d = divisors.length;\\n        int[] res = new int[d];\\n        int maxDiv = 0;\\n        for(int i=0; i<d; i++) {\\n            int div = divisors[i];\\n            for(int x : nums) {\\n                if(x % div == 0) {\\n                    res[i]++;\\n                }\\n            }\\n            maxDiv = Math.max(maxDiv, res[i]);\\n        }\\n\\n        int ans = Integer.MAX_VALUE;\\n        for(int i=0; i<d; i++) {\\n            if(res[i] == maxDiv) {\\n                ans = Math.min(ans, divisors[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n```Python []\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n        d = len(divisors)\\n        res = [0] * d\\n        maxDiv = 0\\n        for i in range(d):\\n            div = divisors[i]\\n            for x in nums:\\n                if x % div == 0:\\n                    res[i] += 1\\n            maxDiv = max(maxDiv, res[i])\\n\\n        ans = float(\\'inf\\')\\n        for i in range(d):\\n            if res[i] == maxDiv:\\n                ans = min(ans, divisors[i])\\n        return ans\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors)\\n    {\\n        int d = divisors.size();\\n        vector<int> res(d,0);\\n        int maxDiv = 0;\\n        for(int i=0; i<d; i++)\\n        {\\n            int div = divisors[i];\\n            for(auto x : nums)\\n            {\\n                if(x%div == 0){\\n                    res[i]++;\\n                }\\n            }\\n            maxDiv = max(maxDiv, res[i]);\\n        }\\n        \\n        int ans = INT_MAX;\\n        for(int i=0; i<d; i++)\\n        {\\n            if(res[i] == maxDiv){\\n                ans = min(ans, divisors[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int d = divisors.length;\\n        int[] res = new int[d];\\n        int maxDiv = 0;\\n        for(int i=0; i<d; i++) {\\n            int div = divisors[i];\\n            for(int x : nums) {\\n                if(x % div == 0) {\\n                    res[i]++;\\n                }\\n            }\\n            maxDiv = Math.max(maxDiv, res[i]);\\n        }\\n\\n        int ans = Integer.MAX_VALUE;\\n        for(int i=0; i<d; i++) {\\n            if(res[i] == maxDiv) {\\n                ans = Math.min(ans, divisors[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\n```Python []\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n        d = len(divisors)\\n        res = [0] * d\\n        maxDiv = 0\\n        for i in range(d):\\n            div = divisors[i]\\n            for x in nums:\\n                if x % div == 0:\\n                    res[i] += 1\\n            maxDiv = max(maxDiv, res[i])\\n\\n        ans = float(\\'inf\\')\\n        for i in range(d):\\n            if res[i] == maxDiv:\\n                ans = min(ans, divisors[i])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421901,
                "title": "c-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:$$O(n*m)$$\\n\\n- Space complexity:$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& n, vector<int>& d) {\\n        int cnt1=0, cnt2=0;\\n        for (int i=0; i<d.size(); i++){\\n            int l=0;\\n            for (int j=0; j<n.size(); j++){\\n                if (n[j]%d[i]==0){\\n                    l++;\\n                }\\n            }\\n            if (l>cnt1){\\n                cnt1=l;\\n                cnt2=i;\\n            }\\n            else if (l==cnt1 && d[i]<d[cnt2]){\\n                cnt2=i;\\n                cnt1=l;\\n            }\\n        }\\n        return d[cnt2];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& n, vector<int>& d) {\\n        int cnt1=0, cnt2=0;\\n        for (int i=0; i<d.size(); i++){\\n            int l=0;\\n            for (int j=0; j<n.size(); j++){\\n                if (n[j]%d[i]==0){\\n                    l++;\\n                }\\n            }\\n            if (l>cnt1){\\n                cnt1=l;\\n                cnt2=i;\\n            }\\n            else if (l==cnt1 && d[i]<d[cnt2]){\\n                cnt2=i;\\n                cnt1=l;\\n            }\\n        }\\n        return d[cnt2];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421851,
                "title": "simple-java-solution-faster-than-100",
                "content": "# **Just do simple calculation and count which is maximum.**\\n# If you like please upvote it.\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int n = nums.length;\\n        int m = divisors.length;\\n        int min = Integer.MAX_VALUE;\\n        int max = Integer.MIN_VALUE;\\n        int[] d = new int[m];\\n        for(int i=0;i<m;i++)\\n        {\\n            int count = 0;\\n            for(int j=0;j<n;j++)\\n            {\\n                if(nums[j]%divisors[i]==0)\\n                {\\n                    count++;\\n                }\\n            }\\n            d[i] = count;\\n        }\\n        for(int i=0;i<m;i++)\\n        {\\n            if(d[i]>=max)\\n            {\\n                max = d[i];\\n            }\\n        }\\n        for(int i=0;i<m;i++)\\n        {\\n            if(d[i]==max)\\n                 min = Math.min(min,divisors[i]);\\n        }\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int n = nums.length;\\n        int m = divisors.length;\\n        int min = Integer.MAX_VALUE;\\n        int max = Integer.MIN_VALUE;\\n        int[] d = new int[m];\\n        for(int i=0;i<m;i++)\\n        {\\n            int count = 0;\\n            for(int j=0;j<n;j++)\\n            {\\n                if(nums[j]%divisors[i]==0)\\n                {\\n                    count++;\\n                }\\n            }\\n            d[i] = count;\\n        }\\n        for(int i=0;i<m;i++)\\n        {\\n            if(d[i]>=max)\\n            {\\n                max = d[i];\\n            }\\n        }\\n        for(int i=0;i<m;i++)\\n        {\\n            if(d[i]==max)\\n                 min = Math.min(min,divisors[i]);\\n        }\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421845,
                "title": "java-solution-easy-to-understand",
                "content": "# Complexity\\n- Time complexity: O(n*m) where n is length of array nums and m is length of array divisors\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int maxScore = 0;\\n        int divisor = divisors[0];\\n        for(int i = 0; i < divisors.length; i++) {\\n            int currentScore = 0;\\n            \\n            for(int j = 0; j < nums.length; j++) {\\n                if(nums[j] % divisors[i] == 0) {\\n                    currentScore++;\\n                }\\n            }\\n            if(currentScore == maxScore) {\\n                divisor = Math.min(divisor, divisors[i]);\\n            }\\n            \\n            if(currentScore > maxScore) {\\n                maxScore = currentScore;\\n                divisor = divisors[i];\\n            }\\n        }\\n        return divisor;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int maxScore = 0;\\n        int divisor = divisors[0];\\n        for(int i = 0; i < divisors.length; i++) {\\n            int currentScore = 0;\\n            \\n            for(int j = 0; j < nums.length; j++) {\\n                if(nums[j] % divisors[i] == 0) {\\n                    currentScore++;\\n                }\\n            }\\n            if(currentScore == maxScore) {\\n                divisor = Math.min(divisor, divisors[i]);\\n            }\\n            \\n            if(currentScore > maxScore) {\\n                maxScore = currentScore;\\n                divisor = divisors[i];\\n            }\\n        }\\n        return divisor;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421844,
                "title": "c-o-n-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $O(n*m)$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(1)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& div) {\\n        int n=nums.size(),m=div.size(),mx=0,ans=div[0];\\n        for(int i=0;i<m;i++){\\n            int a=0;\\n            for(int j=0;j<n;j++){\\n                if(nums[j]%div[i]==0) a++;\\n            }\\n            if(a>mx){\\n                mx=a;\\n                ans=div[i];\\n            }\\n            if(a==mx && div[i]<ans) ans=div[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& div) {\\n        int n=nums.size(),m=div.size(),mx=0,ans=div[0];\\n        for(int i=0;i<m;i++){\\n            int a=0;\\n            for(int j=0;j<n;j++){\\n                if(nums[j]%div[i]==0) a++;\\n            }\\n            if(a>mx){\\n                mx=a;\\n                ans=div[i];\\n            }\\n            if(a==mx && div[i]<ans) ans=div[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421791,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] div) {\\n        Arrays.sort(nums);\\n        int score=0;\\n        int ind=div[0];\\n        for(int i=0;i<div.length;i++){\\n            int count=0;\\n            for(int j=0;j<nums.length;j++){\\n                if(nums[j]%div[i]==0){\\n                    count++;\\n                }\\n            }\\n            if(count>score){\\n                score=count;\\n                ind=div[i];\\n            }\\n            if(count==score)\\n                ind=Math.min(ind,div[i]);\\n        }\\n        return ind;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] div) {\\n        Arrays.sort(nums);\\n        int score=0;\\n        int ind=div[0];\\n        for(int i=0;i<div.length;i++){\\n            int count=0;\\n            for(int j=0;j<nums.length;j++){\\n                if(nums[j]%div[i]==0){\\n                    count++;\\n                }\\n            }\\n            if(count>score){\\n                score=count;\\n                ind=div[i];\\n            }\\n            if(count==score)\\n                ind=Math.min(ind,div[i]);\\n        }\\n        return ind;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421789,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int max= 0;\\n        int min=0;\\n     for(int j=0;j<divisors.length;j++)\\n        {\\n        int count=0;\\n            for(int i=0;i<nums.length;i++)\\n            { if((nums[i]%divisors[j])==0)\\n            {\\n                count++;\\n            }\\n            }\\n         if(max<=count)\\n         {\\n             if(count>max)\\n             {max=count;\\n             min=divisors[j];\\n             }\\n             else\\n             {\\n                if(min==0)\\n                {\\n                    min=divisors[j];\\n                    max=count;\\n                }\\n                 else\\n                 {\\n                     if(divisors[j]<min)\\n                         min=divisors[j];\\n                 }\\n             }\\n         }\\n        \\n         \\n        }\\n        \\n        \\n        return min;\\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int max= 0;\\n        int min=0;\\n     for(int j=0;j<divisors.length;j++)\\n        {\\n        int count=0;\\n            for(int i=0;i<nums.length;i++)\\n            { if((nums[i]%divisors[j])==0)\\n            {\\n                count++;\\n            }\\n            }\\n         if(max<=count)\\n         {\\n             if(count>max)\\n             {max=count;\\n             min=divisors[j];\\n             }\\n             else\\n             {\\n                if(min==0)\\n                {\\n                    min=divisors[j];\\n                    max=count;\\n                }\\n                 else\\n                 {\\n                     if(divisors[j]<min)\\n                         min=divisors[j];\\n                 }\\n             }\\n         }\\n        \\n         \\n        }\\n        \\n        \\n        return min;\\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421758,
                "title": "easiest-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int min=0,max=0;\\n        for(int i=0;i<divisors.size();i++){\\n            int count=0;\\n            int div=divisors[i];\\n            for(int j=0;j<nums.size();j++){\\n                if(nums[j]%div==0)\\n                    count++;\\n            }\\n            if(count>=max){\\n                if(count>max){\\n                    max=count;\\n                    min=div;\\n                }\\n                else{\\n                    if(min==0)\\n                        min=div;\\n                    else{\\n                        if(div<min)\\n                            min=div;\\n                    }\\n                }\\n            }\\n        }\\n        return min;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int min=0,max=0;\\n        for(int i=0;i<divisors.size();i++){\\n            int count=0;\\n            int div=divisors[i];\\n            for(int j=0;j<nums.size();j++){\\n                if(nums[j]%div==0)\\n                    count++;\\n            }\\n            if(count>=max){\\n                if(count>max){\\n                    max=count;\\n                    min=div;\\n                }\\n                else{\\n                    if(min==0)\\n                        min=div;\\n                    else{\\n                        if(div<min)\\n                            min=div;\\n                    }\\n                }\\n            }\\n        }\\n        return min;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421742,
                "title": "c-brute-force-easy",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int max_idx = 0;\\n        int maxi = INT_MIN;\\n        for(int i = 0; i < divisors.size(); i++)\\n        {\\n            int count = 0;\\n            for(int j = 0; j < nums.size(); j++)\\n            {\\n                if(nums[j] % divisors[i] == 0)\\n                {\\n                    count++;\\n                }\\n            }\\n            if(count > maxi)\\n            {\\n                maxi = count;\\n                max_idx = i;\\n            }\\n            else if(maxi == count)\\n            {\\n                maxi = count;\\n                if(divisors[max_idx] >= divisors[i])\\n                {\\n                    max_idx = i;\\n                }\\n            }\\n        }\\n        return divisors[max_idx];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int max_idx = 0;\\n        int maxi = INT_MIN;\\n        for(int i = 0; i < divisors.size(); i++)\\n        {\\n            int count = 0;\\n            for(int j = 0; j < nums.size(); j++)\\n            {\\n                if(nums[j] % divisors[i] == 0)\\n                {\\n                    count++;\\n                }\\n            }\\n            if(count > maxi)\\n            {\\n                maxi = count;\\n                max_idx = i;\\n            }\\n            else if(maxi == count)\\n            {\\n                maxi = count;\\n                if(divisors[max_idx] >= divisors[i])\\n                {\\n                    max_idx = i;\\n                }\\n            }\\n        }\\n        return divisors[max_idx];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421707,
                "title": "c-brute-force",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int cnt=0,ans=INT_MAX;\\n        for(int i=0;i<divisors.size();i++){\\n            int c=0;\\n            for(int j=0;j<nums.size();j++){\\n                if(nums[j]%divisors[i] == 0) c+=1;\\n            }\\n            if(c>cnt){\\n                cnt = c;\\n                ans = divisors[i];\\n            }\\n            if(c==cnt && divisors[i]<ans) ans = divisors[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int cnt=0,ans=INT_MAX;\\n        for(int i=0;i<divisors.size();i++){\\n            int c=0;\\n            for(int j=0;j<nums.size();j++){\\n                if(nums[j]%divisors[i] == 0) c+=1;\\n            }\\n            if(c>cnt){\\n                cnt = c;\\n                ans = divisors[i];\\n            }\\n            if(c==cnt && divisors[i]<ans) ans = divisors[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4101892,
                "title": "one-line-solution",
                "content": "```\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:  \\n        return reduce(lambda m, d: (s, d) if (s := sum(not n%d for n in nums)) > m[0] or s == m[0] and d < m[1] else m, divisors, (0, inf))[1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:  \\n        return reduce(lambda m, d: (s, d) if (s := sum(not n%d for n in nums)) > m[0] or s == m[0] and d < m[1] else m, divisors, (0, inf))[1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4100103,
                "title": "python-dictionary",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n        d = {}\\n        for i in range(len(divisors)):\\n            c = 0\\n            for j in nums:\\n                if j % divisors[i] == 0:\\n                    c += 1\\n            if c not in list(d.values()):\\n                d.update({divisors[i] : c})\\n            else:\\n                keys = list(d.keys())\\n                values = list(d.values())\\n                k = keys[values.index(c)]\\n                if k > divisors[i] :\\n                    del d[k]\\n                    d.update({divisors[i] : c})\\n        d = dict(sorted(d.items(), key = lambda t:t[1], reverse = True))\\n        return list(d.keys())[0]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n        d = {}\\n        for i in range(len(divisors)):\\n            c = 0\\n            for j in nums:\\n                if j % divisors[i] == 0:\\n                    c += 1\\n            if c not in list(d.values()):\\n                d.update({divisors[i] : c})\\n            else:\\n                keys = list(d.keys())\\n                values = list(d.values())\\n                k = keys[values.index(c)]\\n                if k > divisors[i] :\\n                    del d[k]\\n                    d.update({divisors[i] : c})\\n        d = dict(sorted(d.items(), key = lambda t:t[1], reverse = True))\\n        return list(d.keys())[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4099773,
                "title": "best-solution-tc-o-mn-sc-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n\\n        int maxScore{-1}, divisor{};\\n\\n        for(auto i : divisors){\\n\\n            int currScore{};\\n\\n            for(auto j : nums) if(j % i == 0) currScore++;\\n            \\n            if(currScore >= maxScore){\\n                if(currScore == maxScore){\\n                    divisor = min(divisor, i);\\n                }\\n                else{\\n                    divisor = i;\\n                    maxScore = currScore;\\n                }          \\n            }\\n        }\\n\\n        return divisor;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n\\n        int maxScore{-1}, divisor{};\\n\\n        for(auto i : divisors){\\n\\n            int currScore{};\\n\\n            for(auto j : nums) if(j % i == 0) currScore++;\\n            \\n            if(currScore >= maxScore){\\n                if(currScore == maxScore){\\n                    divisor = min(divisor, i);\\n                }\\n                else{\\n                    divisor = i;\\n                    maxScore = currScore;\\n                }          \\n            }\\n        }\\n\\n        return divisor;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4073612,
                "title": "basic-java-soln-97",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int max=0,ans=divisors[0];\\n        for(int i:divisors){\\n            int c=0;\\n            for(int j:nums){\\n                if(j%i==0)\\n                    c++;\\n            }\\n            if(c>max||(c==max&&ans>i)){\\n                ans=i;\\n                max=c;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int max=0,ans=divisors[0];\\n        for(int i:divisors){\\n            int c=0;\\n            for(int j:nums){\\n                if(j%i==0)\\n                    c++;\\n            }\\n            if(c>max||(c==max&&ans>i)){\\n                ans=i;\\n                max=c;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4059500,
                "title": "beats-97-in-speed-91-in-memory",
                "content": "# Intuition\\n**just take care of current and highest score, if there is not any, return minimum of divisors**\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int ans = 0,p=0;\\n        for(int i=0; i<divisors.length; i++){\\n            int c = 0;\\n            for(int j=0; j<nums.length; j++){\\n                if(nums[j] % divisors[i]==0){\\n                    c++;\\n                }\\n            }\\n            if(c>p){\\n                ans = divisors[i];\\n                p =c;\\n            }\\n            else if(c==p){\\n                ans = Math.min(ans,divisors[i]);\\n            }\\n        }\\n        if (p==0){\\n            int min = divisors[0];\\n            for(int i = 0; i<divisors.length; i++){\\n                if(min>divisors[i]){\\n                    min = divisors[i];\\n                }\\n            }\\n            return min;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int ans = 0,p=0;\\n        for(int i=0; i<divisors.length; i++){\\n            int c = 0;\\n            for(int j=0; j<nums.length; j++){\\n                if(nums[j] % divisors[i]==0){\\n                    c++;\\n                }\\n            }\\n            if(c>p){\\n                ans = divisors[i];\\n                p =c;\\n            }\\n            else if(c==p){\\n                ans = Math.min(ans,divisors[i]);\\n            }\\n        }\\n        if (p==0){\\n            int min = divisors[0];\\n            for(int i = 0; i<divisors.length; i++){\\n                if(min>divisors[i]){\\n                    min = divisors[i];\\n                }\\n            }\\n            return min;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4055013,
                "title": "beat-97-in-memory-and-easy-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n        m=-1\\n        ans=-1\\n        for i in divisors:\\n            d=0\\n            for j in nums:\\n                if j%i==0:\\n                    d+=1\\n            if d>m or d==m and i<ans:\\n                ans=i\\n                m=d\\n        return ans\\n                \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n        m=-1\\n        ans=-1\\n        for i in divisors:\\n            d=0\\n            for j in nums:\\n                if j%i==0:\\n                    d+=1\\n            if d>m or d==m and i<ans:\\n                ans=i\\n                m=d\\n        return ans\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4043958,
                "title": "java-98-beats-beginner-friendly-but-not-too-much-optimize",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int max_div=Integer.MAX_VALUE;\\n        int prev_count=0;\\n        int res=0;\\n        boolean isGreater = false;\\n\\n\\n        for(int i=0; i<divisors.length; i++){\\n            int count=0;\\n            for(int j=0; j<nums.length; j++){\\n                if(nums[j]%divisors[i]==0) count++;\\n            }\\n            if(prev_count < count){\\n                prev_count = count;\\n                res = divisors[i];\\n                isGreater = true;\\n            }\\n            if(prev_count == count){\\n                if(res>divisors[i] && isGreater){\\n                    res = divisors[i];\\n                }\\n                if(max_div > divisors[i]){\\n                    max_div = divisors[i];\\n                }\\n            }\\n        }\\n\\n        return isGreater ? res:max_div;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int max_div=Integer.MAX_VALUE;\\n        int prev_count=0;\\n        int res=0;\\n        boolean isGreater = false;\\n\\n\\n        for(int i=0; i<divisors.length; i++){\\n            int count=0;\\n            for(int j=0; j<nums.length; j++){\\n                if(nums[j]%divisors[i]==0) count++;\\n            }\\n            if(prev_count < count){\\n                prev_count = count;\\n                res = divisors[i];\\n                isGreater = true;\\n            }\\n            if(prev_count == count){\\n                if(res>divisors[i] && isGreater){\\n                    res = divisors[i];\\n                }\\n                if(max_div > divisors[i]){\\n                    max_div = divisors[i];\\n                }\\n            }\\n        }\\n\\n        return isGreater ? res:max_div;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4024087,
                "title": "c-basic-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int mx=INT_MIN;\\n        vector<int> scores;\\n        for(int i=0; i<divisors.size(); i++){\\n            int score=0;\\n            for(int j=0; j<nums.size(); j++){\\n                if(nums[j]%divisors[i]==0){\\n                    score++;\\n                }\\n            }\\n            scores.push_back(score);\\n            mx=max(mx, score);\\n        }\\n        vector<int> mxScore;\\n        for(int i=0; i<scores.size(); i++){\\n            if(mx==scores[i]){\\n                mxScore.push_back(divisors[i]);\\n            }\\n        }\\n        int mn=INT_MAX;\\n        for(int i=0; i<mxScore.size(); i++){\\n            mn=min(mn, mxScore[i]);\\n        }\\n        return mn;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int mx=INT_MIN;\\n        vector<int> scores;\\n        for(int i=0; i<divisors.size(); i++){\\n            int score=0;\\n            for(int j=0; j<nums.size(); j++){\\n                if(nums[j]%divisors[i]==0){\\n                    score++;\\n                }\\n            }\\n            scores.push_back(score);\\n            mx=max(mx, score);\\n        }\\n        vector<int> mxScore;\\n        for(int i=0; i<scores.size(); i++){\\n            if(mx==scores[i]){\\n                mxScore.push_back(divisors[i]);\\n            }\\n        }\\n        int mn=INT_MAX;\\n        for(int i=0; i<mxScore.size(); i++){\\n            mn=min(mn, mxScore[i]);\\n        }\\n        return mn;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4001741,
                "title": "count-map-c",
                "content": "\\n# C++\\n```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int mx = 0, res = INT_MAX;\\n        map<int, int> mp;\\n        for(int d : divisors) {\\n            int cnt = 0;\\n            if(++mp[d] == 1) \\n                for(int n : nums) \\n                    cnt += (n % d == 0);\\n            if(mx == cnt) \\n                res = min(res, d);\\n            else if(mx < cnt) {\\n                res = d;\\n                mx = cnt;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int mx = 0, res = INT_MAX;\\n        map<int, int> mp;\\n        for(int d : divisors) {\\n            int cnt = 0;\\n            if(++mp[d] == 1) \\n                for(int n : nums) \\n                    cnt += (n % d == 0);\\n            if(mx == cnt) \\n                res = min(res, d);\\n            else if(mx < cnt) {\\n                res = d;\\n                mx = cnt;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3988957,
                "title": "easy-to-understand-python3-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n        scores = {}\\n\\n        for d in divisors:\\n            count = 0\\n            for i in nums:\\n                if i % d == 0:\\n                    count += 1\\n            scores[d] = count\\n        scores = list(sorted(scores.items(), key = lambda x: (-x[1], x[0])))\\n        return scores[0][0]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n        scores = {}\\n\\n        for d in divisors:\\n            count = 0\\n            for i in nums:\\n                if i % d == 0:\\n                    count += 1\\n            scores[d] = count\\n        scores = list(sorted(scores.items(), key = lambda x: (-x[1], x[0])))\\n        return scores[0][0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3976713,
                "title": "find-the-maximum-divisibility-score",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int max = Integer.MAX_VALUE;\\n        int maxi = 0;\\n        for(int i=0;i<divisors.length;i++)\\n        {\\n            int count = 0;\\n            for(int j=0;j<nums.length;j++)\\n            {\\n                if(nums[j]%divisors[i]==0)\\n                count++;\\n            }\\n            if(count>maxi)\\n            {\\n                maxi = count;\\n                max = divisors[i];\\n            }\\n            else if(count==maxi)\\n            {\\n                max = Math.min(max,divisors[i]);\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int max = Integer.MAX_VALUE;\\n        int maxi = 0;\\n        for(int i=0;i<divisors.length;i++)\\n        {\\n            int count = 0;\\n            for(int j=0;j<nums.length;j++)\\n            {\\n                if(nums[j]%divisors[i]==0)\\n                count++;\\n            }\\n            if(count>maxi)\\n            {\\n                maxi = count;\\n                max = divisors[i];\\n            }\\n            else if(count==maxi)\\n            {\\n                max = Math.min(max,divisors[i]);\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3957255,
                "title": "easy-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n       int mine=0,score=-1e8;\\n        for(auto it:divisors)\\n         {\\n           int ct=0;\\n           for(auto i:nums)\\n             {\\n               if(i%it==0)\\n                    ct++;\\n             }\\n                if(score<ct)\\n                 {\\n                   score=ct;\\n                    mine=it;\\n                 }\\n                 else if(score==ct)\\n                   {\\n                     mine=min((int)it,mine);\\n                   }\\n         }\\n         return mine;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n       int mine=0,score=-1e8;\\n        for(auto it:divisors)\\n         {\\n           int ct=0;\\n           for(auto i:nums)\\n             {\\n               if(i%it==0)\\n                    ct++;\\n             }\\n                if(score<ct)\\n                 {\\n                   score=ct;\\n                    mine=it;\\n                 }\\n                 else if(score==ct)\\n                   {\\n                     mine=min((int)it,mine);\\n                   }\\n         }\\n         return mine;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3943009,
                "title": "python3-reversed-computation-of-divisibility-score-3-lines-376-ms-beats-100",
                "content": "# Approach\\nInstead of checking if elements of `nums` are evenly divisible by the current `divisor`, check if numbers `divisor * i` are in the list of `nums`,\\nwhere `i` is in range `[1, max(nums)//divisor]` \\n\\n**Note**: it is important to use `Counter` instead of `set` because `nums` can contain duplicate numbers.\\n\\n# Code\\n```\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n        max_num = max(nums)\\n        cnt = Counter(nums)\\n        return -max((sum(cnt[d * i] for i in range(1, max_num//d + 1)), -d) for d in divisors)[1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n        max_num = max(nums)\\n        cnt = Counter(nums)\\n        return -max((sum(cnt[d * i] for i in range(1, max_num//d + 1)), -d) for d in divisors)[1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3939374,
                "title": "best-sollution-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int c = 0;\\n        int res = 0;\\n        Arrays.sort(divisors);\\n        for(int i=0;i<divisors.length;i++){\\n            int count = 0;\\n            int x = divisors[i];\\n            for(int j=0;j<nums.length;j++){\\n                int y = nums[j];\\n                if(y%x==0){\\n                    count++;\\n                }\\n            }\\n            if(count>c){\\n                res = x;\\n                c = count;\\n            }\\n        }\\n        if(res==0){\\n            res = divisors[0];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int c = 0;\\n        int res = 0;\\n        Arrays.sort(divisors);\\n        for(int i=0;i<divisors.length;i++){\\n            int count = 0;\\n            int x = divisors[i];\\n            for(int j=0;j<nums.length;j++){\\n                int y = nums[j];\\n                if(y%x==0){\\n                    count++;\\n                }\\n            }\\n            if(count>c){\\n                res = x;\\n                c = count;\\n            }\\n        }\\n        if(res==0){\\n            res = divisors[0];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3928796,
                "title": "best-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int m=0,ans;\\n        sort(divisors.begin(),divisors.end());\\n        set<int> s;\\n        for(int i=0;i<divisors.size();i++){\\n            int c=0;\\n            for(int j=0;j<nums.size();j++){\\n                if(nums[j]%divisors[i]==0){\\n                    c++;\\n                }\\n            }\\n            s.insert(c);\\n            if(c>m){\\n                m=c;\\n                ans=divisors[i];\\n            }\\n        }\\n        if(s.size()==1){\\n            return divisors[0];\\n        }\\n        else{\\n            return ans;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int m=0,ans;\\n        sort(divisors.begin(),divisors.end());\\n        set<int> s;\\n        for(int i=0;i<divisors.size();i++){\\n            int c=0;\\n            for(int j=0;j<nums.size();j++){\\n                if(nums[j]%divisors[i]==0){\\n                    c++;\\n                }\\n            }\\n            s.insert(c);\\n            if(c>m){\\n                m=c;\\n                ans=divisors[i];\\n            }\\n        }\\n        if(s.size()==1){\\n            return divisors[0];\\n        }\\n        else{\\n            return ans;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3925063,
                "title": "o-m-n-java-solution",
                "content": "# Approach\\n1. Calculate the score for `ith` divisor\\n2. if the `score` > `maxScore`, update `maxScore` and `result`\\n3. if `score` == `maxScore`, update the `result` to the **minimum** of `ith divisor` (for which we just calculated the score) and `result`\\n\\n# Complexity\\n- Time complexity: O(m*n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int maxScore = 0;\\n        int minValue = Integer.MAX_VALUE;\\n\\n        for (int divisor : divisors) {\\n            int score = 0;\\n            for (int num : nums) {\\n                if (num % divisor == 0) {\\n                    score++;\\n                }\\n            }\\n\\n            if (score > maxScore) {\\n                maxScore = score;\\n                minValue = divisor;\\n            } else if (score == maxScore) {\\n                minValue = Math.min(minValue, divisor);\\n            }\\n        }\\n\\n        return minValue;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int maxScore = 0;\\n        int minValue = Integer.MAX_VALUE;\\n\\n        for (int divisor : divisors) {\\n            int score = 0;\\n            for (int num : nums) {\\n                if (num % divisor == 0) {\\n                    score++;\\n                }\\n            }\\n\\n            if (score > maxScore) {\\n                maxScore = score;\\n                minValue = divisor;\\n            } else if (score == maxScore) {\\n                minValue = Math.min(minValue, divisor);\\n            }\\n        }\\n\\n        return minValue;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3904749,
                "title": "purely-brute-force-but-easy-to-understandable-code",
                "content": "\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n\\n        vector<int> ans;\\n        int max = INT_MIN;\\n\\n        sort(divisors.begin(),divisors.end());\\n\\n        for(int i=0;i<divisors.size();i++)\\n        {\\n            int count = 0;\\n            for(int j=0;j<nums.size();j++)\\n            {\\n                if(nums[j]%divisors[i]==0)\\n                    count++;\\n            }\\n            ans.push_back(count);\\n            if(max < count)\\n            {\\n                max = count;\\n            }\\n        }   \\n\\n        int result;\\n\\n        for(int i=0;i<ans.size();i++)\\n        {\\n                if (ans[i] == max) \\n                {\\n                result = divisors[i];\\n                break;\\n                }\\n        }\\n\\n    return result;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n\\n        vector<int> ans;\\n        int max = INT_MIN;\\n\\n        sort(divisors.begin(),divisors.end());\\n\\n        for(int i=0;i<divisors.size();i++)\\n        {\\n            int count = 0;\\n            for(int j=0;j<nums.size();j++)\\n            {\\n                if(nums[j]%divisors[i]==0)\\n                    count++;\\n            }\\n            ans.push_back(count);\\n            if(max < count)\\n            {\\n                max = count;\\n            }\\n        }   \\n\\n        int result;\\n\\n        for(int i=0;i<ans.size();i++)\\n        {\\n                if (ans[i] == max) \\n                {\\n                result = divisors[i];\\n                break;\\n                }\\n        }\\n\\n    return result;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3890473,
                "title": "max-divisibility-score",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n        num=0\\n        div=0\\n        for i in divisors:\\n            num1=0\\n            for j in nums:\\n                if j%i==0:\\n                    num1+=1\\n            if num1>num:\\n                div=i\\n                num=num1\\n            elif num1==num:\\n                div=div if div<i else i\\n        return div if div!=0 else min(divisors)\\n                    \\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n        num=0\\n        div=0\\n        for i in divisors:\\n            num1=0\\n            for j in nums:\\n                if j%i==0:\\n                    num1+=1\\n            if num1>num:\\n                div=i\\n                num=num1\\n            elif num1==num:\\n                div=div if div<i else i\\n        return div if div!=0 else min(divisors)\\n                    \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3887370,
                "title": "beginner-map-vector",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        vector<pair<int,int>>pq;\\n        int max_count=0;\\n        for(int i=0;i<divisors.size();i++){\\n            int count=0;\\n            pair<int,int>p;\\n            for(int j=0;j<nums.size();j++){\\n                if(nums[j]%divisors[i]==0){\\n                    count++;\\n                }\\n            }\\n            max_count=max(max_count,count);\\n           p.first=count;\\n           p.second=divisors[i];\\n           pq.push_back(p);\\n        }\\n        vector<int>ans;\\n        for(auto it : pq){\\n            if(it.first==max_count){\\n                ans.push_back(it.second);\\n            }\\n        }\\n        sort(ans.begin(),ans.end());\\n        return ans[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Hash Table",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        vector<pair<int,int>>pq;\\n        int max_count=0;\\n        for(int i=0;i<divisors.size();i++){\\n            int count=0;\\n            pair<int,int>p;\\n            for(int j=0;j<nums.size();j++){\\n                if(nums[j]%divisors[i]==0){\\n                    count++;\\n                }\\n            }\\n            max_count=max(max_count,count);\\n           p.first=count;\\n           p.second=divisors[i];\\n           pq.push_back(p);\\n        }\\n        vector<int>ans;\\n        for(auto it : pq){\\n            if(it.first==max_count){\\n                ans.push_back(it.second);\\n            }\\n        }\\n        sort(ans.begin(),ans.end());\\n        return ans[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3877810,
                "title": "basic-java-solution-beats-98",
                "content": "# Intuition\\nthe basic intuition is that we have to find the maximum score of an element in divisors array, so we simply iterate through the array , with a variable name max (that stores the max count of an element) and a variable ans (that stores our result if any) \\nso we iterate through the array checking with the condition if the condition satisfies we will increase the count.\\n\\nafter the inner loops complete we will check if the count value is greater or equal to our max value, if it is equal we will store the smaller element in our ans variable. else if the count is greater than max then we\\'ll simply put that value of divisor in our array and take the max as count.\\n\\nat last the ans will be our desired ans;\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n\\n        int max = 0;\\n        int ans = divisors[0];\\n        for(int i = 0 ; i<divisors.length ; i++){\\n            int count = 0;\\n\\n            for(int j = 0 ; j < nums.length; j++){\\n                if(nums[j]%divisors[i]==0){\\n                    count++;\\n                }\\n            }\\n\\n            if(count>=max){\\n                if(count==max){\\n                    ans = Math.min(divisors[i],ans);\\n                    max = Math.max(max, count);\\n                }else{                    \\n                    ans = divisors[i];\\n                    max = Math.max(max, count);            \\n                }\\n            }\\n\\n        }\\n        return ans==-1?divisors[0]:ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n\\n        int max = 0;\\n        int ans = divisors[0];\\n        for(int i = 0 ; i<divisors.length ; i++){\\n            int count = 0;\\n\\n            for(int j = 0 ; j < nums.length; j++){\\n                if(nums[j]%divisors[i]==0){\\n                    count++;\\n                }\\n            }\\n\\n            if(count>=max){\\n                if(count==max){\\n                    ans = Math.min(divisors[i],ans);\\n                    max = Math.max(max, count);\\n                }else{                    \\n                    ans = divisors[i];\\n                    max = Math.max(max, count);            \\n                }\\n            }\\n\\n        }\\n        return ans==-1?divisors[0]:ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3877597,
                "title": "python-solution-dictionary",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def maxDivScore(self, nums, divisors):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type divisors: List[int]\\n        :rtype: int\\n        \"\"\" \\n        divisors = sorted(set(divisors))\\n        d = {}\\n        for i in range(len(divisors)):\\n            c = 0\\n            for j in range(len(nums)):\\n                if nums[j] % divisors[i] == 0:\\n                    c += 1\\n            d[divisors[i]] = c\\n        print(d)\\n        v = max(d.values())\\n        print(d)\\n        sorted_items = sorted(d.items(), key=lambda x: x[0])\\n        print(sorted_items)\\n        for i in sorted_items:\\n            if i[1] == v:\\n                return i[0]\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def maxDivScore(self, nums, divisors):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type divisors: List[int]\\n        :rtype: int\\n        \"\"\" \\n        divisors = sorted(set(divisors))\\n        d = {}\\n        for i in range(len(divisors)):\\n            c = 0\\n            for j in range(len(nums)):\\n                if nums[j] % divisors[i] == 0:\\n                    c += 1\\n            d[divisors[i]] = c\\n        print(d)\\n        v = max(d.values())\\n        print(d)\\n        sorted_items = sorted(d.items(), key=lambda x: x[0])\\n        print(sorted_items)\\n        for i in sorted_items:\\n            if i[1] == v:\\n                return i[0]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3876754,
                "title": "fast-defaultdict-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n        div_score = defaultdict(int)\\n        div_max = []\\n        for div in divisors:\\n            div_score[div] = sum(1 for x in nums if x % div == 0)\\n        mx = max(count for count in div_score.values())\\n        for div, count in div_score.items():\\n            if count == mx:\\n                div_max.append(div)\\n        return min(div_max)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n        div_score = defaultdict(int)\\n        div_max = []\\n        for div in divisors:\\n            div_score[div] = sum(1 for x in nums if x % div == 0)\\n        mx = max(count for count in div_score.values())\\n        for div, count in div_score.items():\\n            if count == mx:\\n                div_max.append(div)\\n        return min(div_max)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3874695,
                "title": "java-173ms-beats-98-45",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(mn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// 173ms Beats 98.45%\\n\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n\\n        int winningDivisor = -1;\\n        int winningScore = -1;\\n\\n        for (int i = divisors.length - 1; i >= 0; --i) {\\n\\n            int curScore = 0;\\n\\n            for (int j = 0; j < nums.length; ++j) {\\n                if (nums[j] % divisors[i] == 0) {\\n                    ++curScore;\\n                }\\n            }\\n\\n            if (curScore > winningScore) {\\n                winningDivisor = divisors[i];\\n                winningScore = curScore;\\n            } else if (curScore == winningScore) {\\n                if (divisors[i] < winningDivisor) {\\n                    winningDivisor = divisors[i];\\n                    winningScore = curScore;\\n                }\\n            }\\n        }\\n\\n        return winningDivisor;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// 173ms Beats 98.45%\\n\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n\\n        int winningDivisor = -1;\\n        int winningScore = -1;\\n\\n        for (int i = divisors.length - 1; i >= 0; --i) {\\n\\n            int curScore = 0;\\n\\n            for (int j = 0; j < nums.length; ++j) {\\n                if (nums[j] % divisors[i] == 0) {\\n                    ++curScore;\\n                }\\n            }\\n\\n            if (curScore > winningScore) {\\n                winningDivisor = divisors[i];\\n                winningScore = curScore;\\n            } else if (curScore == winningScore) {\\n                if (divisors[i] < winningDivisor) {\\n                    winningDivisor = divisors[i];\\n                    winningScore = curScore;\\n                }\\n            }\\n        }\\n\\n        return winningDivisor;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3871580,
                "title": "easy-java-solution-with-more-than-95-of-beats-please-vote-me-up",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int max=0;\\n        int idx=0;\\n        for(int i=0;i<divisors.length;i++){\\n            int c=0;\\n            for(int j=0;j<nums.length;j++){\\n                if(nums[j]%divisors[i]==0){\\n                    c++;\\n                }\\n            }\\n            if(c==max){\\n                if(divisors[i]<divisors[idx]){\\n                    idx=i;\\n                }\\n            }\\n            if(c>max){\\n                max=c;\\n                idx=i;\\n            }\\n        }\\n        if(idx==0){\\n            Arrays.sort(divisors);\\n            return divisors[0];\\n        }\\n        return divisors[idx];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int max=0;\\n        int idx=0;\\n        for(int i=0;i<divisors.length;i++){\\n            int c=0;\\n            for(int j=0;j<nums.length;j++){\\n                if(nums[j]%divisors[i]==0){\\n                    c++;\\n                }\\n            }\\n            if(c==max){\\n                if(divisors[i]<divisors[idx]){\\n                    idx=i;\\n                }\\n            }\\n            if(c>max){\\n                max=c;\\n                idx=i;\\n            }\\n        }\\n        if(idx==0){\\n            Arrays.sort(divisors);\\n            return divisors[0];\\n        }\\n        return divisors[idx];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3861953,
                "title": "simple-solution-in-js",
                "content": "# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number[]} divisors\\n * @return {number}\\n */\\nvar maxDivScore = function(nums, divisors) {\\n    let max = [0];\\n    for(let i = 0; i < divisors.length; i++) {\\n        let curr = 0;\\n        for(let j = 0; j < nums.length; j++) {\\n            if(nums[j] % divisors[i] == 0) {\\n                curr++\\n            }\\n        } \\n        if(max[0] == curr && max[1] > divisors[i]) {\\n            max[1] = divisors[i]\\n        }else if(max[0] < curr) {\\n            max[0] = curr\\n            max[1] = divisors[i]\\n        }\\n    }\\n    if(!max[0]) return Math.min(...divisors)\\n    return max[1]\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number[]} divisors\\n * @return {number}\\n */\\nvar maxDivScore = function(nums, divisors) {\\n    let max = [0];\\n    for(let i = 0; i < divisors.length; i++) {\\n        let curr = 0;\\n        for(let j = 0; j < nums.length; j++) {\\n            if(nums[j] % divisors[i] == 0) {\\n                curr++\\n            }\\n        } \\n        if(max[0] == curr && max[1] > divisors[i]) {\\n            max[1] = divisors[i]\\n        }else if(max[0] < curr) {\\n            max[0] = curr\\n            max[1] = divisors[i]\\n        }\\n    }\\n    if(!max[0]) return Math.min(...divisors)\\n    return max[1]\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3855236,
                "title": "java-93ms-beats-99-and-clean-code",
                "content": "# Approach\\n1. Sort the numbers in increasing order.\\n2. For each divisor, traverse nums backwards with j (n-1..0) WHILE nums[j] >= divisor.\\n3. For each traversal keep track of current divisor\\'s currentScore. \\n    - If currentScore > maxScore, set new maxScore and new minDivisor\\n    - If currentScore == maxScore, set new minDivisor the min between minDivisor and currentDivisor.\\n4. Return minDivisor.    \\n\\n# Complexity\\n- Time complexity:$$O(n*log(n) + n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int maxDivScore = 0, minDivisor = Integer.MAX_VALUE, currentDivScore;\\n        Arrays.sort(nums);\\n        for (int divisor : divisors) {\\n            currentDivScore = 0;\\n            for (int i = nums.length -1; i >= 0 && divisor <= nums[i]; i--) {\\n                if (nums[i] % divisor == 0){\\n                    currentDivScore++;\\n                }\\n            }\\n            if(currentDivScore > maxDivScore) {\\n                maxDivScore = currentDivScore;\\n                minDivisor = divisor;\\n            } else if (currentDivScore == maxDivScore) {\\n                minDivisor = Math.min(divisor, minDivisor);\\n            }\\n        }\\n        return minDivisor;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int maxDivScore = 0, minDivisor = Integer.MAX_VALUE, currentDivScore;\\n        Arrays.sort(nums);\\n        for (int divisor : divisors) {\\n            currentDivScore = 0;\\n            for (int i = nums.length -1; i >= 0 && divisor <= nums[i]; i--) {\\n                if (nums[i] % divisor == 0){\\n                    currentDivScore++;\\n                }\\n            }\\n            if(currentDivScore > maxDivScore) {\\n                maxDivScore = currentDivScore;\\n                minDivisor = divisor;\\n            } else if (currentDivScore == maxDivScore) {\\n                minDivisor = Math.min(divisor, minDivisor);\\n            }\\n        }\\n        return minDivisor;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3849829,
                "title": "junior-ios-dev-solution-need-a-cheap-extremely-motivated-ios-dev-contact-me-pls",
                "content": "Sorry, no explanation. 10 p.m. junior ios straightforward dev solution. if you have work for me - contact pls.\\n\\n# Code\\n```\\nclass Solution {\\n    func maxDivScore(_ nums: [Int], _ divisors: [Int]) -> Int {\\n        var counter = 0\\n        var divisorValue = 0\\n\\n        for divisor in divisors {\\n            var tempCounter = 0\\n            for num in nums {\\n                if num % divisor == 0 {\\n                    tempCounter += 1\\n                }\\n            }\\n            if tempCounter == counter && divisorValue != 0 {\\n                counter = tempCounter\\n                divisorValue = min(divisorValue, divisor)\\n                continue\\n            }\\n            if tempCounter >= counter {\\n                divisorValue = divisor\\n                counter = tempCounter\\n            }\\n        }\\n\\n        return divisorValue\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func maxDivScore(_ nums: [Int], _ divisors: [Int]) -> Int {\\n        var counter = 0\\n        var divisorValue = 0\\n\\n        for divisor in divisors {\\n            var tempCounter = 0\\n            for num in nums {\\n                if num % divisor == 0 {\\n                    tempCounter += 1\\n                }\\n            }\\n            if tempCounter == counter && divisorValue != 0 {\\n                counter = tempCounter\\n                divisorValue = min(divisorValue, divisor)\\n                continue\\n            }\\n            if tempCounter >= counter {\\n                divisorValue = divisor\\n                counter = tempCounter\\n            }\\n        }\\n\\n        return divisorValue\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3835385,
                "title": "c-solution",
                "content": "```\\nint maxDivScore(vector<int>& nums, vector<int>& div) {\\n\\tint res = div[0], maxScore = 0;\\n\\tfor (int d : div) {\\n\\t\\tint curScore = 0;\\n\\t\\tfor (int n : nums)\\n\\t\\t\\tif (n % d == 0)\\n\\t\\t\\t\\tcurScore++;\\n\\t\\tif (curScore > maxScore) {\\n\\t\\t\\tmaxScore = curScore;\\n\\t\\t\\tres = d;\\n\\t\\t}\\n\\t\\tif (curScore == maxScore)\\n\\t\\t\\tres = min(res, d);\\n\\t}\\n\\treturn res;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint maxDivScore(vector<int>& nums, vector<int>& div) {\\n\\tint res = div[0], maxScore = 0;\\n\\tfor (int d : div) {\\n\\t\\tint curScore = 0;\\n\\t\\tfor (int n : nums)\\n\\t\\t\\tif (n % d == 0)\\n\\t\\t\\t\\tcurScore++;\\n\\t\\tif (curScore > maxScore) {\\n\\t\\t\\tmaxScore = curScore;\\n\\t\\t\\tres = d;\\n\\t\\t}\\n\\t\\tif (curScore == maxScore)\\n\\t\\t\\tres = min(res, d);\\n\\t}\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3833606,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        uint16_t i_u16 = 0, divSize = divisors.size(), maxDivisor = 0, maxScore = 0;\\n        int j_s32 = 0;\\n        int divScore = 0;\\n\\n        for(i_u16 = 0; i_u16 < divSize; i_u16++)\\n        {\\n            divScore = 0;\\n\\n            for(j_s32 = 0; j_s32 < nums.size(); j_s32++ )\\n            {\\n                if( nums[j_s32] % divisors[i_u16] == 0 )\\n                {\\n                    divScore++;\\n                }\\n            }\\n\\n            if(divScore > maxScore || (divScore == maxScore && divisors[i_u16] <= divisors[maxDivisor]))\\n            {\\n                maxScore = divScore;\\n                maxDivisor = i_u16;   \\n            }\\n        }\\n\\n        return divisors[maxDivisor];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        uint16_t i_u16 = 0, divSize = divisors.size(), maxDivisor = 0, maxScore = 0;\\n        int j_s32 = 0;\\n        int divScore = 0;\\n\\n        for(i_u16 = 0; i_u16 < divSize; i_u16++)\\n        {\\n            divScore = 0;\\n\\n            for(j_s32 = 0; j_s32 < nums.size(); j_s32++ )\\n            {\\n                if( nums[j_s32] % divisors[i_u16] == 0 )\\n                {\\n                    divScore++;\\n                }\\n            }\\n\\n            if(divScore > maxScore || (divScore == maxScore && divisors[i_u16] <= divisors[maxDivisor]))\\n            {\\n                maxScore = divScore;\\n                maxDivisor = i_u16;   \\n            }\\n        }\\n\\n        return divisors[maxDivisor];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3812997,
                "title": "easy-solution-in-c",
                "content": "# Intuition\\n\\n\\n# Approach\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int ans=111111111;\\n        int maxcount=-111111111;\\n        for(int i=0;i<divisors.size();i++){\\n            int count=0;\\n            for(int j=0;j<nums.size();j++){\\n                if(nums[j]%divisors[i]==0)\\n                count++;\\n            }\\n            if(maxcount<count){\\n                maxcount=count;\\n                ans=divisors[i];\\n            }\\n            else if(maxcount==count){\\n                ans=min(ans,divisors[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int ans=111111111;\\n        int maxcount=-111111111;\\n        for(int i=0;i<divisors.size();i++){\\n            int count=0;\\n            for(int j=0;j<nums.size();j++){\\n                if(nums[j]%divisors[i]==0)\\n                count++;\\n            }\\n            if(maxcount<count){\\n                maxcount=count;\\n                ans=divisors[i];\\n            }\\n            else if(maxcount==count){\\n                ans=min(ans,divisors[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3809363,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n * n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n + n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    static bool compare(pair<int,int>a, pair<int,int>b)\\n    {\\n        if(a.first > b.first)\\n        return true;\\n        if(a.first == b.first)\\n        {\\n            return a.second < b.second;\\n        }\\n        return false;\\n    }\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n       map<int,int>mp;\\n       bool flag = false;\\n       int minDivisors = INT_MAX;\\n       for(int i = 0; i < divisors.size(); i++)\\n       {\\n           if(mp.find(divisors[i]) == mp.end())\\n           {\\n               for(int j = 0; j < nums.size(); j++)\\n                {\\n                    if(nums[j] % divisors[i] == 0)\\n                    {\\n                            mp[divisors[i]]++;\\n                            flag = true;\\n                    }\\n                }\\n           }\\n            minDivisors = min(minDivisors, divisors[i]);\\n       } \\n       if(flag == false)\\n       {\\n           return minDivisors;\\n       }\\n       vector<pair<int,int>>v;\\n       for(auto it : mp)\\n       {\\n           v.push_back({it.second, it.first});\\n       }\\n       sort(v.begin(), v.end(), compare);\\n       for(auto x : v)\\n       {\\n           cout<<x.first<<\"->\"<<x.second<<endl;\\n       }\\n       if(v.size() > 0)\\n       return v[0].second;\\n       return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool compare(pair<int,int>a, pair<int,int>b)\\n    {\\n        if(a.first > b.first)\\n        return true;\\n        if(a.first == b.first)\\n        {\\n            return a.second < b.second;\\n        }\\n        return false;\\n    }\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n       map<int,int>mp;\\n       bool flag = false;\\n       int minDivisors = INT_MAX;\\n       for(int i = 0; i < divisors.size(); i++)\\n       {\\n           if(mp.find(divisors[i]) == mp.end())\\n           {\\n               for(int j = 0; j < nums.size(); j++)\\n                {\\n                    if(nums[j] % divisors[i] == 0)\\n                    {\\n                            mp[divisors[i]]++;\\n                            flag = true;\\n                    }\\n                }\\n           }\\n            minDivisors = min(minDivisors, divisors[i]);\\n       } \\n       if(flag == false)\\n       {\\n           return minDivisors;\\n       }\\n       vector<pair<int,int>>v;\\n       for(auto it : mp)\\n       {\\n           v.push_back({it.second, it.first});\\n       }\\n       sort(v.begin(), v.end(), compare);\\n       for(auto x : v)\\n       {\\n           cout<<x.first<<\"->\"<<x.second<<endl;\\n       }\\n       if(v.size() > 0)\\n       return v[0].second;\\n       return 0;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3803283,
                "title": "divisibility-score-js-count-scores-intuitive",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @param {number[]} divisors\\n * @return {number}\\n */\\nvar maxDivScore = function(nums, divisors) {\\n    divisors.sort((a, b) => a - b)\\n    scores = []\\n\\n    for (let i = 0; i < divisors.length; i++) {\\n        count = 0\\n        for (num of nums) {\\n            if (num % divisors[i] == 0) count ++\\n        }\\n        scores[i] = count\\n    }\\n\\n    maximum_score = Math.max(...scores)\\n\\n    return divisors[scores.indexOf(maximum_score)]\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number[]} divisors\\n * @return {number}\\n */\\nvar maxDivScore = function(nums, divisors) {\\n    divisors.sort((a, b) => a - b)\\n    scores = []\\n\\n    for (let i = 0; i < divisors.length; i++) {\\n        count = 0\\n        for (num of nums) {\\n            if (num % divisors[i] == 0) count ++\\n        }\\n        scores[i] = count\\n    }\\n\\n    maximum_score = Math.max(...scores)\\n\\n    return divisors[scores.indexOf(maximum_score)]\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3799305,
                "title": "very-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>&n , vector<int>&d){\\n        int mx=INT_MIN;\\n        for(auto i:d){\\n            int c=0;\\n            for(auto j:n){\\n                if(j%i==0){\\n                    c++;\\n                }\\n            }\\n            if(mx<c){\\n                mx=c;\\n            }\\n        }\\n        vector<int>v;\\n        for(auto i:d){\\n            int c=0;\\n            for(auto j:n){\\n                if(j%i==0){\\n                    c++;\\n                }\\n            }\\n            if(mx==c){\\n                v.push_back(i);\\n            }\\n        }\\n        sort(v.begin(),v.end());\\n        return v[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>&n , vector<int>&d){\\n        int mx=INT_MIN;\\n        for(auto i:d){\\n            int c=0;\\n            for(auto j:n){\\n                if(j%i==0){\\n                    c++;\\n                }\\n            }\\n            if(mx<c){\\n                mx=c;\\n            }\\n        }\\n        vector<int>v;\\n        for(auto i:d){\\n            int c=0;\\n            for(auto j:n){\\n                if(j%i==0){\\n                    c++;\\n                }\\n            }\\n            if(mx==c){\\n                v.push_back(i);\\n            }\\n        }\\n        sort(v.begin(),v.end());\\n        return v[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3779614,
                "title": "kotlin-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    fun maxDivScore(nums: IntArray, divisors: IntArray): Int {\\n        var maxDivisor = divisors.first()\\n        var maxDividedNums = 0\\n\\n        for (divisor in divisors) {\\n            var dividedNums = 0\\n\\n            for (num in nums) {\\n                if (num % divisor == 0)\\n                    dividedNums++\\n            }\\n\\n            if (dividedNums > maxDividedNums) {\\n                maxDividedNums = dividedNums\\n                maxDivisor = divisor\\n            }\\n            \\n            if (dividedNums == maxDividedNums && divisor < maxDivisor)\\n                maxDivisor = divisor\\n        }\\n\\n        return maxDivisor\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun maxDivScore(nums: IntArray, divisors: IntArray): Int {\\n        var maxDivisor = divisors.first()\\n        var maxDividedNums = 0\\n\\n        for (divisor in divisors) {\\n            var dividedNums = 0\\n\\n            for (num in nums) {\\n                if (num % divisor == 0)\\n                    dividedNums++\\n            }\\n\\n            if (dividedNums > maxDividedNums) {\\n                maxDividedNums = dividedNums\\n                maxDivisor = divisor\\n            }\\n            \\n            if (dividedNums == maxDividedNums && divisor < maxDivisor)\\n                maxDivisor = divisor\\n        }\\n\\n        return maxDivisor\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3777918,
                "title": "tried-to-optimized",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n        sorted_div = sorted(set(divisors))\\n        ans_d, ans_count = sorted_div[0], 0\\n        cnt_n = Counter(nums)\\n        for d in sorted_div:\\n            score = sum(n for num, n in cnt_n.items() if not num % d)\\n            if score > ans_count:\\n                ans_d = d\\n                ans_count = score\\n        return ans_d\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n        sorted_div = sorted(set(divisors))\\n        ans_d, ans_count = sorted_div[0], 0\\n        cnt_n = Counter(nums)\\n        for d in sorted_div:\\n            score = sum(n for num, n in cnt_n.items() if not num % d)\\n            if score > ans_count:\\n                ans_d = d\\n                ans_count = score\\n        return ans_d\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3757206,
                "title": "simple-javascript-solution",
                "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number[]} divisors\\n * @return {number}\\n */\\nvar maxDivScore = function(nums, divisors) {\\n    let maxScore = 0;\\n    let result = divisors[0];\\n    for(let divi of divisors){\\n        let score = 0;\\n        for(let num of nums){\\n            if(num % divi === 0) score++;\\n        }\\n        if (score === maxScore) result = Math.min(result, divi);\\n        if(score > maxScore){\\n            maxScore = score\\n            result = divi;\\n        }\\n    }\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number[]} divisors\\n * @return {number}\\n */\\nvar maxDivScore = function(nums, divisors) {\\n    let maxScore = 0;\\n    let result = divisors[0];\\n    for(let divi of divisors){\\n        let score = 0;\\n        for(let num of nums){\\n            if(num % divi === 0) score++;\\n        }\\n        if (score === maxScore) result = Math.min(result, divi);\\n        if(score > maxScore){\\n            maxScore = score\\n            result = divi;\\n        }\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3751919,
                "title": "java-solution-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n*n)\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int ans[]=new int[divisors.length];\\n        for(int i=0;i<divisors.length;i++){\\n            for(int j=0;j<nums.length;j++){\\n                if(nums[j]%divisors[i]==0){\\n                    ans[i]++;\\n                }\\n            }\\n        }\\n        int res=0,count=ans[0];\\n        for(int i=1;i<ans.length;i++){\\n            if(count<ans[i]){\\n                count=ans[i];\\n                res=i;\\n            }\\n            else if(count==ans[i]){\\n                if(divisors[res]>divisors[i]){\\n                    res=i;\\n                }\\n            }\\n        }\\n        return divisors[res];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int ans[]=new int[divisors.length];\\n        for(int i=0;i<divisors.length;i++){\\n            for(int j=0;j<nums.length;j++){\\n                if(nums[j]%divisors[i]==0){\\n                    ans[i]++;\\n                }\\n            }\\n        }\\n        int res=0,count=ans[0];\\n        for(int i=1;i<ans.length;i++){\\n            if(count<ans[i]){\\n                count=ans[i];\\n                res=i;\\n            }\\n            else if(count==ans[i]){\\n                if(divisors[res]>divisors[i]){\\n                    res=i;\\n                }\\n            }\\n        }\\n        return divisors[res];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3739919,
                "title": "using-map",
                "content": "# Complexity\\n- Time complexity:\\nO(n*m)  where n=nums.size() and m=divisors.size()\\n\\n- Space complexity:\\nO(m)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        map<int,int>m;\\n        int maxi=0,temp=0;\\n        for(int i=0;i<divisors.size();i++){\\n            int count=0;\\n            for(int j=0;j<nums.size();j++){\\n                if(nums[j] % divisors[i] ==0)\\n                count++;\\n            }\\n            if(count!=0)\\n            m[divisors[i]]=count;\\n        }\\n        if(m.size()==0){\\n            sort(divisors.begin(),divisors.end());\\n            return divisors[0];\\n        }\\n        for(auto i:m){\\n            if(i.second>maxi){\\n            maxi=i.second;\\n            temp=i.first;\\n            }\\n        }\\n        return temp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        map<int,int>m;\\n        int maxi=0,temp=0;\\n        for(int i=0;i<divisors.size();i++){\\n            int count=0;\\n            for(int j=0;j<nums.size();j++){\\n                if(nums[j] % divisors[i] ==0)\\n                count++;\\n            }\\n            if(count!=0)\\n            m[divisors[i]]=count;\\n        }\\n        if(m.size()==0){\\n            sort(divisors.begin(),divisors.end());\\n            return divisors[0];\\n        }\\n        for(auto i:m){\\n            if(i.second>maxi){\\n            maxi=i.second;\\n            temp=i.first;\\n            }\\n        }\\n        return temp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3737982,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        map<int,int> mp;\\n        for(auto i: divisors){\\n            if(mp[i]>0){\\n                    continue;\\n                }\\n            for(int j: nums){\\n                \\n                if(j%i==0){\\n                    mp[i]++;\\n                }\\n            }\\n        }\\n        int maxi=0;\\n        int ans=INT_MAX;\\n        for(auto i: mp){\\n             maxi=max(maxi,i.second);\\n        }\\n        for(auto i: mp){\\n            if(i.second==maxi){\\n                ans=min(ans,i.first);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        map<int,int> mp;\\n        for(auto i: divisors){\\n            if(mp[i]>0){\\n                    continue;\\n                }\\n            for(int j: nums){\\n                \\n                if(j%i==0){\\n                    mp[i]++;\\n                }\\n            }\\n        }\\n        int maxi=0;\\n        int ans=INT_MAX;\\n        for(auto i: mp){\\n             maxi=max(maxi,i.second);\\n        }\\n        for(auto i: mp){\\n            if(i.second==maxi){\\n                ans=min(ans,i.first);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3730311,
                "title": "python-simple-solution-using-zip-function",
                "content": "\\n\\n# Code\\n```\\nclass Solution(object):\\n    def maxDivScore(self, nums, divisors):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type divisors: List[int]\\n        :rtype: int\\n        \"\"\"\\n        a=[]\\n        for i in divisors:\\n            c=0\\n            for j in nums:\\n                if j%i==0:\\n                    c=c+1\\n            a.append(c)\\n        if len(set(a))==1:\\n            return min(divisors)\\n        else:\\n            m=10**10\\n            for k,l in zip(divisors,a):\\n                if l==max(a) and k<m:\\n                    m=k\\n            return m\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def maxDivScore(self, nums, divisors):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type divisors: List[int]\\n        :rtype: int\\n        \"\"\"\\n        a=[]\\n        for i in divisors:\\n            c=0\\n            for j in nums:\\n                if j%i==0:\\n                    c=c+1\\n            a.append(c)\\n        if len(set(a))==1:\\n            return min(divisors)\\n        else:\\n            m=10**10\\n            for k,l in zip(divisors,a):\\n                if l==max(a) and k<m:\\n                    m=k\\n            return m\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3728299,
                "title": "c-beginner-friendly-brute-force",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N*M)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        \\n        int ans = 0;\\n        int dev = INT_MAX;\\n\\n        for(int i=0; i<divisors.size(); i++){\\n            int cnt = 0;\\n            for(int j=0; j<nums.size(); j++){\\n                if(nums[j]%divisors[i] ==0){\\n                    cnt++;\\n                }\\n                if(cnt>ans){\\n                    dev = divisors[i];\\n                    ans = cnt;\\n                }\\n                if(ans == cnt){\\n                    dev = min(divisors[i],dev);\\n                }\\n            }\\n        }\\n        return dev;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        \\n        int ans = 0;\\n        int dev = INT_MAX;\\n\\n        for(int i=0; i<divisors.size(); i++){\\n            int cnt = 0;\\n            for(int j=0; j<nums.size(); j++){\\n                if(nums[j]%divisors[i] ==0){\\n                    cnt++;\\n                }\\n                if(cnt>ans){\\n                    dev = divisors[i];\\n                    ans = cnt;\\n                }\\n                if(ans == cnt){\\n                    dev = min(divisors[i],dev);\\n                }\\n            }\\n        }\\n        return dev;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3716608,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int minInt = Integer.MAX_VALUE;\\n        int maxCount = 0;\\n        for(int x : divisors) {\\n            int count = 0;\\n            for(int y : nums) {\\n                count += y % x == 0 ? 1 : 0;\\n            }\\n            if(count > maxCount || (count == maxCount && x < minInt)) {\\n                maxCount = count;\\n                minInt = x;\\n            }\\n        }\\n        return minInt;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int minInt = Integer.MAX_VALUE;\\n        int maxCount = 0;\\n        for(int x : divisors) {\\n            int count = 0;\\n            for(int y : nums) {\\n                count += y % x == 0 ? 1 : 0;\\n            }\\n            if(count > maxCount || (count == maxCount && x < minInt)) {\\n                maxCount = count;\\n                minInt = x;\\n            }\\n        }\\n        return minInt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3713097,
                "title": "simplest-python-solution",
                "content": "# Code\\n```\\nfrom collections import Counter\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n        nums_count = Counter(nums)\\n        max_div = {}\\n        for d in list(set(divisors)):\\n            div_count = 0\\n            for num in list(set(nums)):\\n                if num%d==0:\\n                    div_count += nums_count[num]\\n            max_div[d] = div_count\\n        max_value = max(max_div.values())\\n        keys = []\\n        for key, value in max_div.items():\\n            if max_value == value:\\n                keys.append(key)\\n        \\n        return min(keys)\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import Counter\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n        nums_count = Counter(nums)\\n        max_div = {}\\n        for d in list(set(divisors)):\\n            div_count = 0\\n            for num in list(set(nums)):\\n                if num%d==0:\\n                    div_count += nums_count[num]\\n            max_div[d] = div_count\\n        max_value = max(max_div.values())\\n        keys = []\\n        for key, value in max_div.items():\\n            if max_value == value:\\n                keys.append(key)\\n        \\n        return min(keys)\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3699616,
                "title": "nice-and-elegant-solution-in-java-beats-100-rt-and-98-memory",
                "content": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int current = 0;\\n        int output = Integer.MAX_VALUE;\\n        for (int i : divisors) {\\n            int count = 0;\\n            for (int j : nums) {\\n                if (j % i == 0) {\\n                    count++;\\n                }\\n            }\\n            if (count >= current) {\\n                if (count == current) {\\n                    output = Math.min(i, output);\\n                }\\n                if (count > current) {\\n                    current = count;\\n                    output = i;\\n                }\\n            }\\n        }\\n        return output;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int current = 0;\\n        int output = Integer.MAX_VALUE;\\n        for (int i : divisors) {\\n            int count = 0;\\n            for (int j : nums) {\\n                if (j % i == 0) {\\n                    count++;\\n                }\\n            }\\n            if (count >= current) {\\n                if (count == current) {\\n                    output = Math.min(i, output);\\n                }\\n                if (count > current) {\\n                    current = count;\\n                    output = i;\\n                }\\n            }\\n        }\\n        return output;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3691564,
                "title": "c-brute-force-approach-for-beginners",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int flag=0, temp=0, ans=INT_MAX;\\n        for(int i=0; i<divisors.size(); i++){\\n            for(int j=0; j<nums.size(); j++){\\n                if(nums[j]%divisors[i] == 0) flag++;\\n            }\\n            if(flag>temp){\\n                temp=flag;\\n                ans = divisors[i];\\n            }\\n            if(flag == temp && divisors[i]<ans)\\n            ans = divisors[i];\\n            flag=0;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int flag=0, temp=0, ans=INT_MAX;\\n        for(int i=0; i<divisors.size(); i++){\\n            for(int j=0; j<nums.size(); j++){\\n                if(nums[j]%divisors[i] == 0) flag++;\\n            }\\n            if(flag>temp){\\n                temp=flag;\\n                ans = divisors[i];\\n            }\\n            if(flag == temp && divisors[i]<ans)\\n            ans = divisors[i];\\n            flag=0;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3689076,
                "title": "java-solution-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        \\n        ArrayList<Integer> list = new ArrayList<>();\\n       ArrayList<Integer> finalList = new ArrayList<>();\\n\\n       int j = 0;\\n       while(j<divisors.length){\\n           int i = 0;\\n           int count = 0;\\n           while(i<nums.length){\\n           if(nums[i]%divisors[j] == 0){\\n               count++;\\n           }\\n           i++;\\n        }\\n        list.add(count);\\n           j++;\\n        }\\n\\n        int a = Collections.max(list);\\n        for(int m =0 ; m<list.size(); m++){\\n            if(a == list.get(m)){\\n                finalList.add(divisors[m]);\\n            }\\n        }\\n\\n\\n\\n        return Collections.min(finalList);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        \\n        ArrayList<Integer> list = new ArrayList<>();\\n       ArrayList<Integer> finalList = new ArrayList<>();\\n\\n       int j = 0;\\n       while(j<divisors.length){\\n           int i = 0;\\n           int count = 0;\\n           while(i<nums.length){\\n           if(nums[i]%divisors[j] == 0){\\n               count++;\\n           }\\n           i++;\\n        }\\n        list.add(count);\\n           j++;\\n        }\\n\\n        int a = Collections.max(list);\\n        for(int m =0 ; m<list.size(); m++){\\n            if(a == list.get(m)){\\n                finalList.add(divisors[m]);\\n            }\\n        }\\n\\n\\n\\n        return Collections.min(finalList);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3685114,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int c,max=0,d=0,min=Integer.MAX_VALUE;\\n        boolean e=false;\\n        int[] arr=new int[3];\\n        for(int i=0;i<divisors.length;i++)\\n        {\\n            c=0;\\n            for(int j=0;j<nums.length;j++)\\n            {\\n                if(nums[j]%divisors[i]==0)\\n                {\\n                    c++;\\n                   \\n\\n                }\\n\\n            }  \\n             \\n                     if(max<c)\\n                     {\\n                       max=c;\\n                       d=divisors[i]; \\n                       e=true; \\n                     } \\n                     if(max==c)\\n                     {\\n                         if(d>divisors[i] && e)\\n                         d=divisors[i];\\n                     }\\n                     if(min>divisors[i])\\n                     min=divisors[i];\\n                    \\n            \\n        }\\n       \\n       return e?d:min;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int c,max=0,d=0,min=Integer.MAX_VALUE;\\n        boolean e=false;\\n        int[] arr=new int[3];\\n        for(int i=0;i<divisors.length;i++)\\n        {\\n            c=0;\\n            for(int j=0;j<nums.length;j++)\\n            {\\n                if(nums[j]%divisors[i]==0)\\n                {\\n                    c++;\\n                   \\n\\n                }\\n\\n            }  \\n             \\n                     if(max<c)\\n                     {\\n                       max=c;\\n                       d=divisors[i]; \\n                       e=true; \\n                     } \\n                     if(max==c)\\n                     {\\n                         if(d>divisors[i] && e)\\n                         d=divisors[i];\\n                     }\\n                     if(min>divisors[i])\\n                     min=divisors[i];\\n                    \\n            \\n        }\\n       \\n       return e?d:min;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3679420,
                "title": "easy-c-solution-beginner-friendly-approach",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& div) {\\n        int ans = -1, val=-1;\\n        for(int i=0; i<div.size(); i++)\\n        {\\n            int count=0;\\n            for(int j=0; j<nums.size(); j++)\\n            {\\n                if((nums[j] % div[i])==0)\\n                    count++;\\n            }\\n            if(val < count){\\n                val = count;\\n                ans = div[i];\\n            }\\n            else if(val == count){\\n                ans = min(ans, div[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& div) {\\n        int ans = -1, val=-1;\\n        for(int i=0; i<div.size(); i++)\\n        {\\n            int count=0;\\n            for(int j=0; j<nums.size(); j++)\\n            {\\n                if((nums[j] % div[i])==0)\\n                    count++;\\n            }\\n            if(val < count){\\n                val = count;\\n                ans = div[i];\\n            }\\n            else if(val == count){\\n                ans = min(ans, div[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3674633,
                "title": "my-java-solution-brute-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        Arrays.sort(divisors);\\n        int maxi=Integer.MIN_VALUE;int cnt=0;int ans=0;\\n       for(int i=0;i<divisors.length;i++){\\n       for(int j=0;j<nums.length;j++){\\n           if(nums[j]%divisors[i]==0){\\n               cnt++;\\n           }\\n       }\\n       if(maxi!=cnt){\\n           maxi=Math.max(maxi,cnt);\\n           if(maxi==cnt){\\nans=divisors[i];\\n           }\\n           }\\n           cnt=0; \\n    }\\n    return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        Arrays.sort(divisors);\\n        int maxi=Integer.MIN_VALUE;int cnt=0;int ans=0;\\n       for(int i=0;i<divisors.length;i++){\\n       for(int j=0;j<nums.length;j++){\\n           if(nums[j]%divisors[i]==0){\\n               cnt++;\\n           }\\n       }\\n       if(maxi!=cnt){\\n           maxi=Math.max(maxi,cnt);\\n           if(maxi==cnt){\\nans=divisors[i];\\n           }\\n           }\\n           cnt=0; \\n    }\\n    return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3666026,
                "title": "java-easy-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int count=0;\\n        int div=divisors[0];\\n        for(int i=0;i<divisors.length;i++){\\n            int m=0;\\n            for(int j=0;j<nums.length;j++){\\n                if(nums[j]%divisors[i]==0){\\n                    m++;\\n                }\\n            }\\n            if(m>count){\\n                count=m;\\n                div=divisors[i];\\n            }\\n            if(m==count && divisors[i]<=div){\\n                div=divisors[i];\\n            }\\n        }\\n        return div;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int count=0;\\n        int div=divisors[0];\\n        for(int i=0;i<divisors.length;i++){\\n            int m=0;\\n            for(int j=0;j<nums.length;j++){\\n                if(nums[j]%divisors[i]==0){\\n                    m++;\\n                }\\n            }\\n            if(m>count){\\n                count=m;\\n                div=divisors[i];\\n            }\\n            if(m==count && divisors[i]<=div){\\n                div=divisors[i];\\n            }\\n        }\\n        return div;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3661629,
                "title": "python-simple-python-solution",
                "content": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Approach 1 Using Hash Map :\\n# Runtime: 4896 ms, faster than 34.58% of Python3 online submissions for Find the Maximum Divisibility Score.\\n# Memory Usage: 16.7 MB, less than 5.97% of Python3 online submissions for Find the Maximum Divisibility Score.\\n\\n\\tclass Solution:\\n\\t\\tdef maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n\\n\\t\\t\\tresult , score = float(\\'inf\\') , 0\\n\\n\\t\\t\\thash_map = {}\\n\\n\\t\\t\\tfor num in nums:\\n\\n\\t\\t\\t\\tif num not in hash_map:\\n\\t\\t\\t\\t\\thash_map[num] = 1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\thash_map[num] = hash_map[num] + 1\\n\\n\\t\\t\\tfor divisor in divisors:\\n\\n\\t\\t\\t\\tcurrent_score = 0\\n\\n\\t\\t\\t\\tfor key in hash_map:\\n\\n\\t\\t\\t\\t\\tif key % divisor == 0:\\n\\n\\t\\t\\t\\t\\t\\tcurrent_score = current_score + hash_map[key]\\n\\n\\t\\t\\t\\tif current_score == score:\\n\\t\\t\\t\\t\\tresult = min(result, divisor)\\n\\n\\t\\t\\t\\telif current_score > score:\\n\\t\\t\\t\\t\\tresult = divisor\\n\\n\\t\\t\\t\\tscore = max(score, current_score)\\n\\n\\t\\t\\treturn result\\n\\t\\t\\t\\n# Approach 2 Using Brute Force :\\n# Runtime: 4541 ms, faster than 38.63% of Python3 online submissions for Find the Maximum Divisibility Score.\\n# Memory Usage: 16.6 MB, less than 21.44% of Python3 online submissions for Find the Maximum Divisibility Score.\\n\\n\\tclass Solution:\\n\\t\\tdef maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n\\n\\t\\t\\tresult , score = float(\\'inf\\') , 0\\n\\n\\t\\t\\tfor divisor in divisors:\\n\\n\\t\\t\\t\\tcurrent_score = 0\\n\\n\\t\\t\\t\\tfor num in nums:\\n\\n\\t\\t\\t\\t\\tif num % divisor == 0:\\n\\n\\t\\t\\t\\t\\t\\tcurrent_score = current_score + 1\\n\\n\\t\\t\\t\\tif current_score == score:\\n\\t\\t\\t\\t\\tresult = min(result, divisor)\\n\\n\\t\\t\\t\\telif current_score > score:\\n\\t\\t\\t\\t\\tresult = divisor\\n\\n\\t\\t\\t\\tscore = max(score , current_score)\\n\\n\\t\\t\\treturn result\\n\\t\\t\\t\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "class Solution:\\n\\t\\tdef maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n\\n\\t\\t\\tresult , score = float(\\'inf\\') , 0\\n\\n\\t\\t\\thash_map = {}",
                "codeTag": "Java"
            },
            {
                "id": 3657639,
                "title": "time-complexity-o-m-n-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number[]} divisors\\n * @return {number}\\n */\\nvar maxDivScore = function(nums, divisors) {\\n    let maxTimeDvd = 0;\\n    let res = Infinity;\\n    \\n    for (let i = 0; i < divisors.length; i++){\\n        let currentDvd = 0;\\n        for (let j = 0; j < nums.length; j++){\\n            if (nums[j] % divisors[i] === 0) \\n                currentDvd++;\\n\\n            if (currentDvd > maxTimeDvd) {\\n                maxTimeDvd = currentDvd;\\n                res = divisors[i]\\n            }\\n            if (currentDvd === maxTimeDvd  && res > divisors[i])\\n                res = divisors[i]\\n        }\\n    }\\n\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number[]} divisors\\n * @return {number}\\n */\\nvar maxDivScore = function(nums, divisors) {\\n    let maxTimeDvd = 0;\\n    let res = Infinity;\\n    \\n    for (let i = 0; i < divisors.length; i++){\\n        let currentDvd = 0;\\n        for (let j = 0; j < nums.length; j++){\\n            if (nums[j] % divisors[i] === 0) \\n                currentDvd++;\\n\\n            if (currentDvd > maxTimeDvd) {\\n                maxTimeDvd = currentDvd;\\n                res = divisors[i]\\n            }\\n            if (currentDvd === maxTimeDvd  && res > divisors[i])\\n                res = divisors[i]\\n        }\\n    }\\n\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3657333,
                "title": "java-beats-96-22-easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int ans = divisors[0];\\n        int div = 0;\\n        for(int i = 0;i < divisors.length;i++){\\n            int n = 0;\\n            for(int j = 0;j < nums.length;j++){\\n                if(nums[j]%divisors[i] == 0)\\n                    n++;\\n            }\\n            if(div < n){\\n                div = n;\\n                ans = divisors[i];\\n            }\\n            else if(div == n && ans > divisors[i])\\n                ans = divisors[i];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int ans = divisors[0];\\n        int div = 0;\\n        for(int i = 0;i < divisors.length;i++){\\n            int n = 0;\\n            for(int j = 0;j < nums.length;j++){\\n                if(nums[j]%divisors[i] == 0)\\n                    n++;\\n            }\\n            if(div < n){\\n                div = n;\\n                ans = divisors[i];\\n            }\\n            else if(div == n && ans > divisors[i])\\n                ans = divisors[i];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3647617,
                "title": "simple-and-easy-to-understand-clear-explanation-with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO (n^2)\\n\\n- Space complexity:\\nO (1)\\n\\n# Code\\n```\\nclass Solution:\\n    def maxDivScore(self, nums, divisors):\\n        score=0\\n        val=divisors[0]    # taking val as first value , beacause if divisibility score of all elements is 0 we have to give one value\\n        for i in divisors:\\n            count=0\\n            for j in nums:\\n                if j%i==0:\\n                    count+=1\\n            if count>score:\\n                score=count\\n                val=i       # if divisbility score is greter than score then value will be element ,\\n            elif count==score:\\n                score=count\\n                val=min(val,i)   # if divisbility score is equal or both Zero , we take minimum element\\n        return val\\nobj=Solution()\\nobj.maxDivScore([20,14,21,10],[5,7,5])\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxDivScore(self, nums, divisors):\\n        score=0\\n        val=divisors[0]    # taking val as first value , beacause if divisibility score of all elements is 0 we have to give one value\\n        for i in divisors:\\n            count=0\\n            for j in nums:\\n                if j%i==0:\\n                    count+=1\\n            if count>score:\\n                score=count\\n                val=i       # if divisbility score is greter than score then value will be element ,\\n            elif count==score:\\n                score=count\\n                val=min(val,i)   # if divisbility score is equal or both Zero , we take minimum element\\n        return val\\nobj=Solution()\\nobj.maxDivScore([20,14,21,10],[5,7,5])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3645182,
                "title": "java-o-n-n-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n*n)\\n- Space complexity:\\nO(n)\\n# Code\\n```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n\\n        for(int i = 0 ; i < divisors.length ; i++){\\n            int score = 0;\\n            for(int j = 0 ; j < nums.length ; j++){\\n                if(nums[j] % divisors[i] == 0){\\n                    score++;\\n                }\\n            }\\n            map.put(divisors[i],score);\\n        }\\n\\n        int ans = -1;\\n        int max_score = 0;\\n\\n        for (Integer key : map.keySet()) {\\n            Integer value = map.get(key);\\n            if(value > max_score){\\n                max_score = value;\\n                ans = key;\\n            }else if(value == max_score && ans > key){\\n                ans = key;\\n            }\\n        }\\n\\n        if(ans == -1){\\n            return Arrays.stream(divisors).min().getAsInt();\\n        }\\n\\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n\\n        for(int i = 0 ; i < divisors.length ; i++){\\n            int score = 0;\\n            for(int j = 0 ; j < nums.length ; j++){\\n                if(nums[j] % divisors[i] == 0){\\n                    score++;\\n                }\\n            }\\n            map.put(divisors[i],score);\\n        }\\n\\n        int ans = -1;\\n        int max_score = 0;\\n\\n        for (Integer key : map.keySet()) {\\n            Integer value = map.get(key);\\n            if(value > max_score){\\n                max_score = value;\\n                ans = key;\\n            }else if(value == max_score && ans > key){\\n                ans = key;\\n            }\\n        }\\n\\n        if(ans == -1){\\n            return Arrays.stream(divisors).min().getAsInt();\\n        }\\n\\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3635185,
                "title": "trivial-c-beats-100",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        auto result = 0, ma = -1;\\n        sort(begin(divisors), end(divisors));\\n        for (const auto& divisor : divisors) {\\n            auto count = 0;\\n            for (const auto& num : nums)\\n                if (num % divisor == 0)\\n                    ++count;\\n            if (count > ma) {\\n                ma = count;\\n                result = divisor;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        auto result = 0, ma = -1;\\n        sort(begin(divisors), end(divisors));\\n        for (const auto& divisor : divisors) {\\n            auto count = 0;\\n            for (const auto& num : nums)\\n                if (num % divisor == 0)\\n                    ++count;\\n            if (count > ma) {\\n                ma = count;\\n                result = divisor;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3583234,
                "title": "easy-java-sol",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int max=-1;\\n        int ans=0;\\n        for(int i=0;i<divisors.length;i++){\\n            int div=divisors[i];\\n            int count=0;\\n            for(int j=0;j<nums.length;j++){\\n                if(nums[j]%div==0)\\n                    count++;\\n            }\\n            \\n            if(count>max){\\n                max=count;\\n                ans=div;\\n            }\\n            if(count==max){\\n                if(div<ans)\\n                    ans=div;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int max=-1;\\n        int ans=0;\\n        for(int i=0;i<divisors.length;i++){\\n            int div=divisors[i];\\n            int count=0;\\n            for(int j=0;j<nums.length;j++){\\n                if(nums[j]%div==0)\\n                    count++;\\n            }\\n            \\n            if(count>max){\\n                max=count;\\n                ans=div;\\n            }\\n            if(count==max){\\n                if(div<ans)\\n                    ans=div;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3567984,
                "title": "easy-to-understand-max-min",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(n^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& div) {\\n        int maxi=INT_MIN,x,m=INT_MAX;\\n       for(int i=0;i<div.size();i++)\\n       {\\n           int count=0;\\n           for(int j=0;j<nums.size();j++)\\n           {\\n               if(nums[j]%div[i]==0)\\n                count++;\\n           }\\n           if(maxi==count)\\n           {\\n               x=min(div[i],x);\\n           }\\n           if(maxi<count)\\n           {\\n               maxi=count;\\n               x=div[i];\\n           } \\n           \\n       } \\n       return x;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& div) {\\n        int maxi=INT_MIN,x,m=INT_MAX;\\n       for(int i=0;i<div.size();i++)\\n       {\\n           int count=0;\\n           for(int j=0;j<nums.size();j++)\\n           {\\n               if(nums[j]%div[i]==0)\\n                count++;\\n           }\\n           if(maxi==count)\\n           {\\n               x=min(div[i],x);\\n           }\\n           if(maxi<count)\\n           {\\n               maxi=count;\\n               x=div[i];\\n           } \\n           \\n       } \\n       return x;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3552046,
                "title": "find-the-maximum-divisibility-score",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n        divisors = sorted(list(set(divisors)))\\n        res_divisor = divisors[0]\\n        res_score = 0\\n        for i in range(len(divisors)):\\n            score = 0\\n            for x in nums:\\n                if x % divisors[i] == 0:\\n                    score += 1\\n            if score > res_score:\\n                res_score = score\\n                res_divisor = divisors[i]\\n        return res_divisor\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n        divisors = sorted(list(set(divisors)))\\n        res_divisor = divisors[0]\\n        res_score = 0\\n        for i in range(len(divisors)):\\n            score = 0\\n            for x in nums:\\n                if x % divisors[i] == 0:\\n                    score += 1\\n            if score > res_score:\\n                res_score = score\\n                res_divisor = divisors[i]\\n        return res_divisor\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3538823,
                "title": "find-the-maximum-divisibility-score",
                "content": "# Intuition\\nEasy Solotion| Beats 94.23% in runtime\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int max=divisors[0];\\n        int maxscore=0;\\n        for(int i=0;i<divisors.length;i++){\\n            int score=0;\\n            for(int j=0;j<nums.length;j++){\\n                if(nums[j]%divisors[i] == 0){\\n                    score++;\\n                }\\n            }\\n            if(score>maxscore){\\n                maxscore=score;\\n                max=divisors[i];\\n            }else if(score==maxscore){\\n                max=Math.min(max,divisors[i]);\\n            }\\n        }\\n\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int max=divisors[0];\\n        int maxscore=0;\\n        for(int i=0;i<divisors.length;i++){\\n            int score=0;\\n            for(int j=0;j<nums.length;j++){\\n                if(nums[j]%divisors[i] == 0){\\n                    score++;\\n                }\\n            }\\n            if(score>maxscore){\\n                maxscore=score;\\n                max=divisors[i];\\n            }else if(score==maxscore){\\n                max=Math.min(max,divisors[i]);\\n            }\\n        }\\n\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3535060,
                "title": "python3-nested-loop-based-solution-o-n-2-complexity-beats-97-3-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n        res, lst = 0, []\\n        for div in set(divisors):\\n            curr = 0\\n            for n in nums:\\n                if not n % div:\\n                    curr += 1\\n            if curr > res:\\n                res = curr\\n                lst = [div]\\n            elif curr == res:\\n                lst.append(div)\\n        return min(lst)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n        res, lst = 0, []\\n        for div in set(divisors):\\n            curr = 0\\n            for n in nums:\\n                if not n % div:\\n                    curr += 1\\n            if curr > res:\\n                res = curr\\n                lst = [div]\\n            elif curr == res:\\n                lst.append(div)\\n        return min(lst)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3532399,
                "title": "c-simple-loop-372ms-935",
                "content": "# Code\\n```\\npublic class Solution {\\n    public int MaxDivScore(int[] nums, int[] divisors) \\n    {\\n        var maxDivIdx = 0;\\n        var maxDivCount = int.MinValue;\\n\\n        for(var i = 0; i < divisors.Length; i++)    \\n        {\\n            var count = 0;\\n\\n            foreach(var n in nums)\\n                if(n % divisors[i] == 0) count++;\\n\\n            if(maxDivCount < count)\\n            {\\n                maxDivIdx = i;\\n                maxDivCount = count;\\n            }\\n            else if(maxDivCount == count && divisors[maxDivIdx] > divisors[i])\\n            {\\n                maxDivIdx = i;\\n            }\\n        }\\n\\n        return divisors[maxDivIdx];\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MaxDivScore(int[] nums, int[] divisors) \\n    {\\n        var maxDivIdx = 0;\\n        var maxDivCount = int.MinValue;\\n\\n        for(var i = 0; i < divisors.Length; i++)    \\n        {\\n            var count = 0;\\n\\n            foreach(var n in nums)\\n                if(n % divisors[i] == 0) count++;\\n\\n            if(maxDivCount < count)\\n            {\\n                maxDivIdx = i;\\n                maxDivCount = count;\\n            }\\n            else if(maxDivCount == count && divisors[maxDivIdx] > divisors[i])\\n            {\\n                maxDivIdx = i;\\n            }\\n        }\\n\\n        return divisors[maxDivIdx];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3531467,
                "title": "divisor-dilemma-score-more-soar-with-the-smallest-score",
                "content": "# Intuition\\nThe problem is asking us to calculate the divisibility score for each divisor, and return the one with the highest score. If there are multiple divisors with the highest score, we should return the smallest one. Given that we need to compare each number in the nums array with each number in the divisors array, a brute force approach with nested loops immediately comes to mind.\\n\\n# Approach\\nThe approach here involves iterating over each divisor, and for each divisor, iterating over each number in nums to check if it\\'s divisible by that divisor. We maintain two variables, maxScore and minDivisor to track the divisor with the maximum divisibility score and the minimum divisor (in case of a tie in scores).\\n\\nHere\\'s a step-by-step breakdown:\\n\\n1. Initialize maxScore to 0 and minDivisor to Infinity.\\n2. For each divisor in divisors, initialize score to 0.\\n3. For each num in nums, if num is divisible by divisor (num % divisor === 0), increment score.\\n4. After calculating score for a divisor, check if it is greater than maxScore, or if it is equal to maxScore and divisor is less than minDivisor. If either is true, update maxScore and minDivisor to the current score and divisor respectively.\\n5. After iterating over all divisors, return minDivisor.\\n\\n# Complexity\\n- Time complexity: The time complexity is O(n*m), where n is the length of the nums array and m is the length of the divisors array. This is because for each divisor, we iterate over all numbers.\\n\\n- Space complexity: The space complexity is O(1), because no additional space is used that scales with the input size. The variables maxScore, minDivisor, and score take constant space.\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number[]} divisors\\n * @return {number}\\n */\\nfunction maxDivScore (nums, divisors) {\\n    let maxScore = 0;\\n    let minDivisor = Infinity;\\n    for (let divisor of divisors) {\\n        let score = 0;\\n        for (let num of nums) {\\n            if (num % divisor === 0) {\\n                score++;\\n            }\\n        }\\n        if (score > maxScore || (score === maxScore && divisor < minDivisor)) {\\n            maxScore = score;\\n            minDivisor = divisor;\\n        }\\n    }\\n    return minDivisor;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number[]} divisors\\n * @return {number}\\n */\\nfunction maxDivScore (nums, divisors) {\\n    let maxScore = 0;\\n    let minDivisor = Infinity;\\n    for (let divisor of divisors) {\\n        let score = 0;\\n        for (let num of nums) {\\n            if (num % divisor === 0) {\\n                score++;\\n            }\\n        }\\n        if (score > maxScore || (score === maxScore && divisor < minDivisor)) {\\n            maxScore = score;\\n            minDivisor = divisor;\\n        }\\n    }\\n    return minDivisor;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3523371,
                "title": "elixir-my-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ndefmodule Solution do\\n  @spec max_div_score(nums :: [integer], divisors :: [integer]) :: integer\\n  def max_div_score(nums, divisors) do\\n    divisors |>\\n      Enum.reduce({-1, -1}, fn divisor, {ans, max_cnt} ->\\n        cnt =\\n          Enum.reduce(nums, 0, fn num, cnt ->\\n            if rem(num, divisor) == 0 do\\n              cnt + 1\\n            else\\n              cnt\\n            end\\n          end)\\n        cond do\\n          cnt > max_cnt ->\\n            {divisor, cnt}\\n          cnt == max_cnt ->\\n            {min(ans, divisor), cnt}\\n          true ->\\n            {ans, max_cnt}\\n        end\\n      end) |> elem(0)\\n  end\\nend\\n\\n```",
                "solutionTags": [
                    "Elixir"
                ],
                "code": "```\\ndefmodule Solution do\\n  @spec max_div_score(nums :: [integer], divisors :: [integer]) :: integer\\n  def max_div_score(nums, divisors) do\\n    divisors |>\\n      Enum.reduce({-1, -1}, fn divisor, {ans, max_cnt} ->\\n        cnt =\\n          Enum.reduce(nums, 0, fn num, cnt ->\\n            if rem(num, divisor) == 0 do\\n              cnt + 1\\n            else\\n              cnt\\n            end\\n          end)\\n        cond do\\n          cnt > max_cnt ->\\n            {divisor, cnt}\\n          cnt == max_cnt ->\\n            {min(ans, divisor), cnt}\\n          true ->\\n            {ans, max_cnt}\\n        end\\n      end) |> elem(0)\\n  end\\nend\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3517404,
                "title": "js-solution",
                "content": "\\n```\\n\\nconst maxDivScore = function (nums, divisors) {\\n  let output = 0;\\n  let maxCount = 0\\n  let count = 0;\\n\\n  for (const div of divisors) {\\n    \\n    for (const num of nums) {\\n      if (num % div === 0) count++;\\n    }\\n    \\n    if (count > maxCount) {\\n      maxCount = count\\n      output = div\\n    }\\n\\n    else if (count === maxCount && div < output) {\\n      output = div\\n    }\\n\\n    count = 0;\\n  }\\n\\n  return output || Math.min(...divisors)\\n};\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nconst maxDivScore = function (nums, divisors) {\\n  let output = 0;\\n  let maxCount = 0\\n  let count = 0;\\n\\n  for (const div of divisors) {\\n    \\n    for (const num of nums) {\\n      if (num % div === 0) count++;\\n    }\\n    \\n    if (count > maxCount) {\\n      maxCount = count\\n      output = div\\n    }\\n\\n    else if (count === maxCount && div < output) {\\n      output = div\\n    }\\n\\n    count = 0;\\n  }\\n\\n  return output || Math.min(...divisors)\\n};\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3513370,
                "title": "very-easy-jebasraja",
                "content": "# Intuition:Karunya university:ACCENTURE\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) \\n    {\\n        \\n        int max=-1;\\n\\nint count=0;\\n\\nint dividing=0;\\n\\nint notdividebyanyvalue=2147483647;\\n\\nfor (int i = 0; i < divisors.length; i++)\\n {\\n    for (int j = 0; j < nums.length; j++) \\n    {\\n        if (nums[j]%divisors[i]==0) \\n        {\\n            \\n            count++;\\n        \\n            if (count==max) \\n            {\\n                if (divisors[i]<dividing) \\n                {\\n                  count=max;\\n                  dividing=divisors[i];  \\n                }\\n                //max=count;\\n            }\\n\\n            else if (count>max) \\n            {\\n                max=count;\\n                dividing=divisors[i];\\n            }\\n        }\\n        else\\n        {\\n            if (divisors[i]<notdividebyanyvalue) \\n            {\\n                notdividebyanyvalue=divisors[i];\\n            }\\n        }\\n    }\\n    count=0;\\n}\\n\\nif (dividing==0)\\n{\\n   //System.out.println(notdividebyanyvalue); \\n    \\n   return notdividebyanyvalue;\\n}\\nelse\\n{\\n    return dividing;\\n    //System.out.println(dividing);\\n    //System.out.println(dividing);\\n}\\n\\n\\n\\n\\n\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) \\n    {\\n        \\n        int max=-1;\\n\\nint count=0;\\n\\nint dividing=0;\\n\\nint notdividebyanyvalue=2147483647;\\n\\nfor (int i = 0; i < divisors.length; i++)\\n {\\n    for (int j = 0; j < nums.length; j++) \\n    {\\n        if (nums[j]%divisors[i]==0) \\n        {\\n            \\n            count++;\\n        \\n            if (count==max) \\n            {\\n                if (divisors[i]<dividing) \\n                {\\n                  count=max;\\n                  dividing=divisors[i];  \\n                }\\n                //max=count;\\n            }\\n\\n            else if (count>max) \\n            {\\n                max=count;\\n                dividing=divisors[i];\\n            }\\n        }\\n        else\\n        {\\n            if (divisors[i]<notdividebyanyvalue) \\n            {\\n                notdividebyanyvalue=divisors[i];\\n            }\\n        }\\n    }\\n    count=0;\\n}\\n\\nif (dividing==0)\\n{\\n   //System.out.println(notdividebyanyvalue); \\n    \\n   return notdividebyanyvalue;\\n}\\nelse\\n{\\n    return dividing;\\n    //System.out.println(dividing);\\n    //System.out.println(dividing);\\n}\\n\\n\\n\\n\\n\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3509322,
                "title": "c-easy-linear-time-constant-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n*m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int n=nums.size(),m=divisors.size();\\n        int ans=1e9;\\n        int finalcount=-1e9;\\n        for(int i=0;i<m;i++){\\n            int cnt=0;\\n            for(int j=0;j<n;j++){\\n                if(nums[j]%divisors[i]==0) cnt++;\\n            }\\n            if(cnt>finalcount){\\n                ans=divisors[i];\\n                finalcount=cnt;\\n            }\\n            else if(cnt==finalcount) ans=min(ans,divisors[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int n=nums.size(),m=divisors.size();\\n        int ans=1e9;\\n        int finalcount=-1e9;\\n        for(int i=0;i<m;i++){\\n            int cnt=0;\\n            for(int j=0;j<n;j++){\\n                if(nums[j]%divisors[i]==0) cnt++;\\n            }\\n            if(cnt>finalcount){\\n                ans=divisors[i];\\n                finalcount=cnt;\\n            }\\n            else if(cnt==finalcount) ans=min(ans,divisors[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3509175,
                "title": "optimized-solution-space-o-1-c-c",
                "content": "# Complexity\\n- Time complexity:\\n**O(N*K)**\\n- Space complexity:\\n**O(1)**\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int max=INT_MIN,ans=INT_MAX;\\n        for(int i=0;i<divisors.size();i++){\\n            int count=0,x=divisors[i];\\n            for(int j:nums){\\n                if(j%x==0) count++;\\n            }\\n            if(count>max){\\n                max=count;\\n                ans=x;\\n            }\\n            else if(count==max){\\n                if(x<ans) ans=x;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int max=INT_MIN,ans=INT_MAX;\\n        for(int i=0;i<divisors.size();i++){\\n            int count=0,x=divisors[i];\\n            for(int j:nums){\\n                if(j%x==0) count++;\\n            }\\n            if(count>max){\\n                max=count;\\n                ans=x;\\n            }\\n            else if(count==max){\\n                if(x<ans) ans=x;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3504046,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int c,max,ans;\\n        max=Integer.MIN_VALUE;\\n        ans=0;\\n        Arrays.sort(divisors);\\n        for(int i=0;i<divisors.length;i++)\\n        {\\n            c=0;\\n            for(int j=0;j<nums.length;j++)\\n            {\\n                if(nums[j]%divisors[i]==0)\\n                {\\n                    c++;\\n                }\\n            }\\n            if(c>max)\\n            {\\n                max=c;\\n                ans=divisors[i];\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int c,max,ans;\\n        max=Integer.MIN_VALUE;\\n        ans=0;\\n        Arrays.sort(divisors);\\n        for(int i=0;i<divisors.length;i++)\\n        {\\n            c=0;\\n            for(int j=0;j<nums.length;j++)\\n            {\\n                if(nums[j]%divisors[i]==0)\\n                {\\n                    c++;\\n                }\\n            }\\n            if(c>max)\\n            {\\n                max=c;\\n                ans=divisors[i];\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3502814,
                "title": "dictionary-sort-python-solution",
                "content": "This question is similar to [2404. Most Frequent Even Element](https://leetcode.com/problems/most-frequent-even-element/solutions/3502776/dictionary-sort-python-solution/).\\n\\n# Code\\n```\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n        d = {}\\n        for di in divisors:\\n            if di not in d:\\n                c = 0\\n                for n in nums:\\n                    if n % di == 0:\\n                        c += 1\\n                d[di] = c\\n        return sorted([[k, v] for k, v in d.items()], key=lambda x: (-x[1], x[0]))[0][0]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n        d = {}\\n        for di in divisors:\\n            if di not in d:\\n                c = 0\\n                for n in nums:\\n                    if n % di == 0:\\n                        c += 1\\n                d[di] = c\\n        return sorted([[k, v] for k, v in d.items()], key=lambda x: (-x[1], x[0]))[0][0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3500317,
                "title": "c-brute-force-easy-understandable",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n            int ans=0;\\n            int maxi=0;\\n            vector<int>answ;\\n        for(int i =0; i<divisors.size(); i++){\\n              int count =0;\\n            int num = divisors[i];\\n            for(int j=0 ;j<nums.size();j++){\\n                if(nums[j]%num==0){\\n                    count++;\\n                }\\n            }\\n                if(ans == count){\\n                        maxi = maxi == 0 ? num : min(maxi,num);\\n                }\\n                else if(count>ans){\\n                        ans = count;\\n                        maxi = num;\\n                }\\n            \\n        }\\n    \\n        return maxi;\\n    }\\n}; \\n\\n```",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n            int ans=0;\\n            int maxi=0;\\n            vector<int>answ;\\n        for(int i =0; i<divisors.size(); i++){\\n              int count =0;\\n            int num = divisors[i];\\n            for(int j=0 ;j<nums.size();j++){\\n                if(nums[j]%num==0){\\n                    count++;\\n                }\\n            }\\n                if(ans == count){\\n                        maxi = maxi == 0 ? num : min(maxi,num);\\n                }\\n                else if(count>ans){\\n                        ans = count;\\n                        maxi = num;\\n                }\\n            \\n        }\\n    \\n        return maxi;\\n    }\\n}; \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3489246,
                "title": "bruteforce-short-and-simple",
                "content": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) \\n    {\\n        int maxCount=Integer.MIN_VALUE;\\n        int ans=Integer.MIN_VALUE;\\n        for(int i=0;i<divisors.length;i++)\\n        {\\n            int count=0;\\n            for(int j=0;j<nums.length;j++)\\n            {\\n                if(nums[j]%divisors[i]==0)\\n                    count++;\\n            }\\n            if(count>maxCount)\\n            {\\n                maxCount=count;\\n                ans=divisors[i];\\n            }\\n            else if(count==maxCount)\\n            {\\n                ans=Math.min(ans,divisors[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) \\n    {\\n        int maxCount=Integer.MIN_VALUE;\\n        int ans=Integer.MIN_VALUE;\\n        for(int i=0;i<divisors.length;i++)\\n        {\\n            int count=0;\\n            for(int j=0;j<nums.length;j++)\\n            {\\n                if(nums[j]%divisors[i]==0)\\n                    count++;\\n            }\\n            if(count>maxCount)\\n            {\\n                maxCount=count;\\n                ans=divisors[i];\\n            }\\n            else if(count==maxCount)\\n            {\\n                ans=Math.min(ans,divisors[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3484618,
                "title": "easy-to-understand-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int max_count = 0;\\n        int max_divisor = divisors[0];\\n        for(int divisor: divisors){\\n\\n            int count = 0;\\n            //checking for no of divisible nos.\\n            for(int number: nums){\\n                if(number % divisor == 0){\\n                    count ++;\\n                }\\n            }\\n            // checking is it the max count\\n            if(count > max_count ){\\n                max_count = count;\\n                max_divisor = divisor;\\n            }\\n            // if same count checking is it the minimum\\n            else if (count == max_count){\\n                if (max_divisor > divisor){\\n                    max_divisor = divisor;\\n                }\\n            }\\n        }\\n        return max_divisor;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int max_count = 0;\\n        int max_divisor = divisors[0];\\n        for(int divisor: divisors){\\n\\n            int count = 0;\\n            //checking for no of divisible nos.\\n            for(int number: nums){\\n                if(number % divisor == 0){\\n                    count ++;\\n                }\\n            }\\n            // checking is it the max count\\n            if(count > max_count ){\\n                max_count = count;\\n                max_divisor = divisor;\\n            }\\n            // if same count checking is it the minimum\\n            else if (count == max_count){\\n                if (max_divisor > divisor){\\n                    max_divisor = divisor;\\n                }\\n            }\\n        }\\n        return max_divisor;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3483863,
                "title": "java-brute-force",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public int maxDivScore(int[] nums, int[] divisors) {\\n    int maxi = -1, div = -1;\\n\\n    for(int d: divisors){\\n      int t = 0;\\n      for(int n: nums)\\n        if(n % d == 0) ++t;\\n      if(t > maxi) {maxi = t; div = d;}\\n      else if(t == maxi) div = div > d ? d : div;\\n    }\\n\\n    return div;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public int maxDivScore(int[] nums, int[] divisors) {\\n    int maxi = -1, div = -1;\\n\\n    for(int d: divisors){\\n      int t = 0;\\n      for(int n: nums)\\n        if(n % d == 0) ++t;\\n      if(t > maxi) {maxi = t; div = d;}\\n      else if(t == maxi) div = div > d ? d : div;\\n    }\\n\\n    return div;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3483665,
                "title": "brute-force-functional-style",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(m * n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nfunction maxDivScore(nums: number[], divisors: number[]): number {\\n  // Calculate the number of elements in `nums` that are divisible by each divisor\\n  const scores = divisors.reduce(\\n    (score: number[], divisor, idx) => {\\n      // Iterate over each element in `nums` and check if it is divisible by the current divisor\\n      nums.forEach((num) => {\\n        if (num % divisor === 0) score[idx] += 1;\\n      });\\n\\n      return score;\\n    },\\n    // Initialize the `score` array with zeros\\n    Array.from({ length: divisors.length }).map((_) => 0)\\n  );\\n\\n  // Find the maximum score\\n  const maxScore = Math.max(...scores);\\n  // Find the indices of the scores that are tied for the maximum score\\n  const tiedScoresIdxs = scores.reduce((acc: number[], score, idx) => {\\n    score === maxScore ? acc.push(idx) : acc;\\n\\n    return acc;\\n  }, []);\\n  // Map the tied score indices to their corresponding divisors\\n  const tiedScores = tiedScoresIdxs.map((scoreIdx) => divisors[scoreIdx]);\\n\\n  // Return the smallest tied score\\n  return Math.min(...tiedScores);\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction maxDivScore(nums: number[], divisors: number[]): number {\\n  // Calculate the number of elements in `nums` that are divisible by each divisor\\n  const scores = divisors.reduce(\\n    (score: number[], divisor, idx) => {\\n      // Iterate over each element in `nums` and check if it is divisible by the current divisor\\n      nums.forEach((num) => {\\n        if (num % divisor === 0) score[idx] += 1;\\n      });\\n\\n      return score;\\n    },\\n    // Initialize the `score` array with zeros\\n    Array.from({ length: divisors.length }).map((_) => 0)\\n  );\\n\\n  // Find the maximum score\\n  const maxScore = Math.max(...scores);\\n  // Find the indices of the scores that are tied for the maximum score\\n  const tiedScoresIdxs = scores.reduce((acc: number[], score, idx) => {\\n    score === maxScore ? acc.push(idx) : acc;\\n\\n    return acc;\\n  }, []);\\n  // Map the tied score indices to their corresponding divisors\\n  const tiedScores = tiedScoresIdxs.map((scoreIdx) => divisors[scoreIdx]);\\n\\n  // Return the smallest tied score\\n  return Math.min(...tiedScores);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3480048,
                "title": "java-simple-solution-bruteforce-counting",
                "content": "# Complexity\\n- Time complexity: $$O(m * n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int maxScore = 0;\\n        int divisorWithMaxScore = divisors[0];\\n        for (int divisor : divisors) {\\n            int currentScore = 0;\\n            for (int num : nums) {\\n                if (num % divisor == 0) {\\n                    currentScore++;\\n                }\\n            }\\n\\n            if (currentScore > maxScore) {\\n                maxScore = currentScore;\\n                divisorWithMaxScore = divisor;\\n            } else if (currentScore == maxScore) {\\n                divisorWithMaxScore = Math.min(divisorWithMaxScore, divisor);\\n            }\\n        }\\n\\n        return divisorWithMaxScore;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Greedy",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int maxScore = 0;\\n        int divisorWithMaxScore = divisors[0];\\n        for (int divisor : divisors) {\\n            int currentScore = 0;\\n            for (int num : nums) {\\n                if (num % divisor == 0) {\\n                    currentScore++;\\n                }\\n            }\\n\\n            if (currentScore > maxScore) {\\n                maxScore = currentScore;\\n                divisorWithMaxScore = divisor;\\n            } else if (currentScore == maxScore) {\\n                divisorWithMaxScore = Math.min(divisorWithMaxScore, divisor);\\n            }\\n        }\\n\\n        return divisorWithMaxScore;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3479671,
                "title": "brute-force-approach-easy-understanding",
                "content": "``\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& n, vector<int>& d) {\\n        int mxCnt=-1,ans=-1;\\n        for(int i=0;i<d.size();i++){\\n            int cnt=0;\\n            for(int j=0;j<n.size();j++){\\n                if(n[j]%d[i]==0){\\n                    cnt++;\\n                }\\n            }\\n            if(cnt>mxCnt){\\n                mxCnt=cnt;\\n                ans=d[i];\\n            }else if(mxCnt==cnt){\\n                ans=min(ans,d[i]);\\n            }\\n            cnt=0;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Array"
                ],
                "code": "class Solution {\\npublic:\\n    int maxDivScore(vector<int>& n, vector<int>& d) {\\n        int mxCnt=-1,ans=-1;\\n        for(int i=0;i<d.size();i++){\\n            int cnt=0;\\n            for(int j=0;j<n.size();j++){\\n                if(n[j]%d[i]==0){\\n                    cnt++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3479097,
                "title": "c-brute-force-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int maxi=-1;\\n        int ans=-1;\\n        for(auto div:divisors){\\n            int cnt=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]%div==0){\\n                cnt++;\\n            }\\n        }\\n        if(maxi<cnt){\\n            maxi=cnt;\\n            ans=div;\\n        }\\n        else if(maxi==cnt){\\n            ans=ans<div?ans:div;\\n        }\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int maxi=-1;\\n        int ans=-1;\\n        for(auto div:divisors){\\n            int cnt=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]%div==0){\\n                cnt++;\\n            }\\n        }\\n        if(maxi<cnt){\\n            maxi=cnt;\\n            ans=div;\\n        }\\n        else if(maxi==cnt){\\n            ans=ans<div?ans:div;\\n        }\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3471227,
                "title": "java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        \\n        int maxScore = -1;\\n        int ans = 0;\\n        \\n        for(int d: divisors){\\n            int count = 0;\\n            for(int i : nums){\\n                if(i % d == 0){\\n                    count++;\\n                }\\n            }\\n            if(count > maxScore){\\n                maxScore = count;\\n                ans = d;\\n            } else if(count == maxScore && ans > d){\\n                ans = d;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        \\n        int maxScore = -1;\\n        int ans = 0;\\n        \\n        for(int d: divisors){\\n            int count = 0;\\n            for(int i : nums){\\n                if(i % d == 0){\\n                    count++;\\n                }\\n            }\\n            if(count > maxScore){\\n                maxScore = count;\\n                ans = d;\\n            } else if(count == maxScore && ans > d){\\n                ans = d;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3470255,
                "title": "java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        Arrays.sort(divisors);\\n        int ans = 0;\\n        int ans1 = divisors[0];\\n        for(int i = 0; i < divisors.length; i++){\\n            int count = 0;\\n            for(int j = 0; j < nums.length; j++){\\n                    if(nums[j] % divisors[i] == 0){\\n                        count++;\\n                    }\\n                     if(ans < count){\\n                ans = count;\\n                ans1 = divisors[i];\\n            }\\n            }\\n           \\n        }\\n        return ans1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        Arrays.sort(divisors);\\n        int ans = 0;\\n        int ans1 = divisors[0];\\n        for(int i = 0; i < divisors.length; i++){\\n            int count = 0;\\n            for(int j = 0; j < nums.length; j++){\\n                    if(nums[j] % divisors[i] == 0){\\n                        count++;\\n                    }\\n                     if(ans < count){\\n                ans = count;\\n                ans1 = divisors[i];\\n            }\\n            }\\n           \\n        }\\n        return ans1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3465651,
                "title": "easy-java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int val = divisors[0];\\n        int max = -1;\\n\\n        for(int i : divisors){\\n            int count = 0;\\n            for(int j : nums){\\n                if(j%i == 0){\\n                    count++;\\n                }\\n            }\\n\\n            if(count == max){\\n                val = val > i ? i : val;\\n            }\\n\\n            if(count > max){\\n                max = count;\\n                val = i;\\n            }\\n        }\\n\\n        return val;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int val = divisors[0];\\n        int max = -1;\\n\\n        for(int i : divisors){\\n            int count = 0;\\n            for(int j : nums){\\n                if(j%i == 0){\\n                    count++;\\n                }\\n            }\\n\\n            if(count == max){\\n                val = val > i ? i : val;\\n            }\\n\\n            if(count > max){\\n                max = count;\\n                val = i;\\n            }\\n        }\\n\\n        return val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3464748,
                "title": "java-sorting-explained",
                "content": "**Idea:**\\n* Brute force count score for each divisor and take the min of such divisors which have the max score\\n* Extra space is taken by Arrays.sort. \\n* Sorting is not required but required for binary search\\n* Sorting doesn\\'t effect overall time complexity but makes the algo more efficient\\n>**T/S:** O(mn)/O(m), where m = size(nums), n = size(divisors)\\n```\\npublic int maxDivScore(int[] nums, int[] divisors) {\\n\\tvar maxScore = 0;\\n\\tvar winnerDivisor = Integer.MAX_VALUE;\\n\\tArrays.sort(nums);\\n\\n\\tfor (var divisor : divisors) {\\n\\t\\tvar i = Arrays.binarySearch(nums, divisor);\\n\\t\\tif (i < 0)\\n\\t\\t\\ti = ~i;\\n\\n\\t\\tvar score = 0;\\n\\t\\tfor (; i < nums.length; i++)\\n\\t\\t\\tif (nums[i] % divisor == 0)\\n\\t\\t\\t\\tscore++;\\n\\n\\t\\tif (score > maxScore) {\\n\\t\\t\\tmaxScore = score;\\n\\t\\t\\twinnerDivisor = divisor;\\n\\t\\t} else if (score == maxScore) {\\n\\t\\t\\twinnerDivisor = Math.min(winnerDivisor, divisor);\\n\\t\\t}\\n\\t}\\n\\n\\treturn winnerDivisor;\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int maxDivScore(int[] nums, int[] divisors) {\\n\\tvar maxScore = 0;\\n\\tvar winnerDivisor = Integer.MAX_VALUE;\\n\\tArrays.sort(nums);\\n\\n\\tfor (var divisor : divisors) {\\n\\t\\tvar i = Arrays.binarySearch(nums, divisor);\\n\\t\\tif (i < 0)\\n\\t\\t\\ti = ~i;\\n\\n\\t\\tvar score = 0;\\n\\t\\tfor (; i < nums.length; i++)\\n\\t\\t\\tif (nums[i] % divisor == 0)\\n\\t\\t\\t\\tscore++;\\n\\n\\t\\tif (score > maxScore) {\\n\\t\\t\\tmaxScore = score;\\n\\t\\t\\twinnerDivisor = divisor;\\n\\t\\t} else if (score == maxScore) {\\n\\t\\t\\twinnerDivisor = Math.min(winnerDivisor, divisor);\\n\\t\\t}\\n\\t}\\n\\n\\treturn winnerDivisor;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3464334,
                "title": "find-the-maximum-divisibility-score",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def maxDivScore(self, nums, divisors):\\n        dict1={}\\n        for i in divisors:\\n            count1=0\\n            for j in nums:\\n                if(j%i==0):\\n                    print(j,i)\\n                    print(count1)\\n                    count1+=1\\n            dict1[i]=count1\\n        maxvalue=max(dict1.values())\\n        list2=[]\\n        for key in dict1:\\n            if(dict1[key]==maxvalue):\\n                list2.append(key)\\n        return min(list2)\\n    \\n    \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def maxDivScore(self, nums, divisors):\\n        dict1={}\\n        for i in divisors:\\n            count1=0\\n            for j in nums:\\n                if(j%i==0):\\n                    print(j,i)\\n                    print(count1)\\n                    count1+=1\\n            dict1[i]=count1\\n        maxvalue=max(dict1.values())\\n        list2=[]\\n        for key in dict1:\\n            if(dict1[key]==maxvalue):\\n                list2.append(key)\\n        return min(list2)\\n    \\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3455862,
                "title": "two-solutions-hashmaps-or-two-pass",
                "content": "# Two Pass\\n```\\nclass Solution{\\npublic int maxDivScore(int[] nums, int[] divisors) {\\n    int max = -1, val = -1;\\n    for (int i : divisors) {\\n        int count = 0;\\n        for (int j : nums) {\\n            if (j % i == 0) {\\n                count++;\\n            }\\n        }\\n        if (max < count) {\\n            max = count;\\n            val = i;\\n        } else if (max == count) {\\n            val = Math.min(val, i);\\n        }\\n    }\\n    return val;\\n}\\n}\\n```\\n# HashMaps\\n```\\nclass Solution{\\npublic int maxDivScore(int[] nums, int[] divisors) {\\n    Map<Integer, Integer> map = new HashMap<>();\\n    for (int divisor : divisors) {\\n        if (!map.containsKey(divisor)) {\\n            int count = 0;\\n            for (int num : nums) {\\n                if (num % divisor == 0) {\\n                    count++;\\n                }\\n            }\\n            map.put(divisor, count);\\n        }\\n    }\\n    int maxCount = -1;\\n    int minDivisor = -1;\\n    for (int divisor : map.keySet()) {\\n        int count = map.get(divisor);\\n        if (count > maxCount) {\\n            maxCount = count;\\n            minDivisor = divisor;\\n        } else if (count == maxCount && divisor < minDivisor) {\\n            minDivisor = divisor;\\n        }\\n    }\\n    return minDivisor;\\n}\\n}\\n```\\n# Do Upvote if you find it helpful",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution{\\npublic int maxDivScore(int[] nums, int[] divisors) {\\n    int max = -1, val = -1;\\n    for (int i : divisors) {\\n        int count = 0;\\n        for (int j : nums) {\\n            if (j % i == 0) {\\n                count++;\\n            }\\n        }\\n        if (max < count) {\\n            max = count;\\n            val = i;\\n        } else if (max == count) {\\n            val = Math.min(val, i);\\n        }\\n    }\\n    return val;\\n}\\n}\\n```\n```\\nclass Solution{\\npublic int maxDivScore(int[] nums, int[] divisors) {\\n    Map<Integer, Integer> map = new HashMap<>();\\n    for (int divisor : divisors) {\\n        if (!map.containsKey(divisor)) {\\n            int count = 0;\\n            for (int num : nums) {\\n                if (num % divisor == 0) {\\n                    count++;\\n                }\\n            }\\n            map.put(divisor, count);\\n        }\\n    }\\n    int maxCount = -1;\\n    int minDivisor = -1;\\n    for (int divisor : map.keySet()) {\\n        int count = map.get(divisor);\\n        if (count > maxCount) {\\n            maxCount = count;\\n            minDivisor = divisor;\\n        } else if (count == maxCount && divisor < minDivisor) {\\n            minDivisor = divisor;\\n        }\\n    }\\n    return minDivisor;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3454920,
                "title": "easy-java-solution-leetcode-easy-explain",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n       int max=-1;\\n    int maxscore= Integer .MAX_VALUE;\\n    for(int d:divisors){\\n        int count=0;\\n        for(int n:nums){\\n            if(n%d==0)\\n            count++;\\n        }\\n        if(count>max){\\n            max=count;\\n            maxscore=d;\\n\\n        }\\n        else if(count==max){\\n         maxscore=Math.min(maxscore,d);\\n        }\\n    }\\n  return maxscore;  \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n       int max=-1;\\n    int maxscore= Integer .MAX_VALUE;\\n    for(int d:divisors){\\n        int count=0;\\n        for(int n:nums){\\n            if(n%d==0)\\n            count++;\\n        }\\n        if(count>max){\\n            max=count;\\n            maxscore=d;\\n\\n        }\\n        else if(count==max){\\n         maxscore=Math.min(maxscore,d);\\n        }\\n    }\\n  return maxscore;  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3448359,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors)\\n    {\\n        int len=nums.length;\\n        int lent=divisors.length;\\n        int min=0;\\n        int max=0;\\n        for(int i=0;i<lent;i++)\\n        {\\n            int count=0;\\n            int div=divisors[i];\\n            for(int j=0;j<len;j++)\\n            {\\n                if(nums[j]%div==0)\\n                {\\n                    count++;\\n                }\\n            }\\n            if(count>=max)\\n            {\\n                if(count>max)\\n                {\\n                    max=count;\\n                    min=div;\\n                }\\n                    \\n                    else\\n                    {\\n                        if(min==0)\\n                        {\\n                          min=div;\\n                            max=count;\\n                        }\\n                        else\\n                        {\\n                        if(div<min)\\n                        {\\n                            min=div;\\n                        }\\n                        }\\n                    }\\n                }\\n            }\\n        \\n        return min;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors)\\n    {\\n        int len=nums.length;\\n        int lent=divisors.length;\\n        int min=0;\\n        int max=0;\\n        for(int i=0;i<lent;i++)\\n        {\\n            int count=0;\\n            int div=divisors[i];\\n            for(int j=0;j<len;j++)\\n            {\\n                if(nums[j]%div==0)\\n                {\\n                    count++;\\n                }\\n            }\\n            if(count>=max)\\n            {\\n                if(count>max)\\n                {\\n                    max=count;\\n                    min=div;\\n                }\\n                    \\n                    else\\n                    {\\n                        if(min==0)\\n                        {\\n                          min=div;\\n                            max=count;\\n                        }\\n                        else\\n                        {\\n                        if(div<min)\\n                        {\\n                            min=div;\\n                        }\\n                        }\\n                    }\\n                }\\n            }\\n        \\n        return min;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3447165,
                "title": "2644-easy-to-understand-c-code-two-for-loops-accepted",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& div) \\n    {\\n        int max=INT_MIN,ans=div[0];\\n        for(int i=0;i<div.size();i++){\\n            int sum=0;\\n            for(int j=0;j<nums.size();j++){\\n                if(nums[j]%div[i]==0)\\n                    sum++;\\n            }\\n            if(sum>=max){\\n                if(sum==max)\\n                    ans=min(div[i],ans);\\n                else{\\n                    max=sum;\\n                    ans=div[i];\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& div) \\n    {\\n        int max=INT_MIN,ans=div[0];\\n        for(int i=0;i<div.size();i++){\\n            int sum=0;\\n            for(int j=0;j<nums.size();j++){\\n                if(nums[j]%div[i]==0)\\n                    sum++;\\n            }\\n            if(sum>=max){\\n                if(sum==max)\\n                    ans=min(div[i],ans);\\n                else{\\n                    max=sum;\\n                    ans=div[i];\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446317,
                "title": "easy-to-understand-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int score=0, user = divisors[0];\\n        for(int i=0; i < divisors.size(); i++){\\n            int divided=0;\\n            for(int j=0; j < nums.size(); j++){\\n                if(nums[j] % divisors[i]==0) divided++;\\n            }\\n            if(divided >= score){\\n                if(divided==score){\\n                    if(user > divisors[i]) user = divisors[i];\\n                }\\n                else user = divisors[i];\\n                score = divided;\\n            }\\n        }\\n        return user;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int score=0, user = divisors[0];\\n        for(int i=0; i < divisors.size(); i++){\\n            int divided=0;\\n            for(int j=0; j < nums.size(); j++){\\n                if(nums[j] % divisors[i]==0) divided++;\\n            }\\n            if(divided >= score){\\n                if(divided==score){\\n                    if(user > divisors[i]) user = divisors[i];\\n                }\\n                else user = divisors[i];\\n                score = divided;\\n            }\\n        }\\n        return user;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3444918,
                "title": "c-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N*logN) + O(N^2)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int ans = 0, ind = 0;\\n        sort(divisors.begin(), divisors.end());\\n        int m = nums.size(), n = divisors.size();\\n        for(int i = 0; i < n; i++){\\n            int score = 0;\\n            for(int j = 0; j < m; j++){\\n                if(nums[j] % divisors[i] == 0) score++;\\n            }\\n            if(score > ans){\\n                ans = score;\\n                ind = i;\\n            }\\n        }\\n        // if(ind == -1) return divisors[0];\\n        return divisors[ind];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int ans = 0, ind = 0;\\n        sort(divisors.begin(), divisors.end());\\n        int m = nums.size(), n = divisors.size();\\n        for(int i = 0; i < n; i++){\\n            int score = 0;\\n            for(int j = 0; j < m; j++){\\n                if(nums[j] % divisors[i] == 0) score++;\\n            }\\n            if(score > ans){\\n                ans = score;\\n                ind = i;\\n            }\\n        }\\n        // if(ind == -1) return divisors[0];\\n        return divisors[ind];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3444258,
                "title": "simple-c-solution-easy-to-understand",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(m*n), m == nums.size(), n == divisors.size()\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int ans, cnt = 0;\\n        for(int i = 0; i < divisors.size(); i++)\\n        {\\n            int cnt1 = 0;\\n            for(int j = 0; j < nums.size(); j++)\\n            {\\n                if(nums[j] % divisors[i] == 0)\\n                {\\n                    cnt1++;\\n                }\\n            }\\n            if(cnt1 > cnt)\\n            {\\n                cnt = cnt1;\\n                ans = divisors[i];\\n            }\\n            else if(cnt1 == cnt)\\n            {\\n                ans = min(ans, divisors[i]);\\n            }\\n        }\\n        if(cnt == 0)\\n        {\\n            sort(divisors.begin(), divisors.end());\\n            ans = divisors[0];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int ans, cnt = 0;\\n        for(int i = 0; i < divisors.size(); i++)\\n        {\\n            int cnt1 = 0;\\n            for(int j = 0; j < nums.size(); j++)\\n            {\\n                if(nums[j] % divisors[i] == 0)\\n                {\\n                    cnt1++;\\n                }\\n            }\\n            if(cnt1 > cnt)\\n            {\\n                cnt = cnt1;\\n                ans = divisors[i];\\n            }\\n            else if(cnt1 == cnt)\\n            {\\n                ans = min(ans, divisors[i]);\\n            }\\n        }\\n        if(cnt == 0)\\n        {\\n            sort(divisors.begin(), divisors.end());\\n            ans = divisors[0];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3443219,
                "title": "beats-92-with-explanation-solution-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nWe just Apply the brute force approach for each element in divisor we divide with each element in nums and if it is completely divisible by the divisor element we increase the count by 1 and check if the count of current pointer is less than or greater than the previous pointer (countC)\\nthen we assign the value of countC to CountP  and the highest pointer will be the item for which the count was more \\nand if the count of both the current pointer and the previous pointer are same then we check if the current highest is greater than the current item \\n(the problem says  If there is more than one integer with the maximum score, return the minimum of them.) so inorder to return the min we perform this check \\n\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number[]} divisors\\n * @return {number}\\n */\\nvar maxDivScore = function(nums, d) {\\n    \\nlet countP = 0 ;\\n        let countC = 0 ;\\n        let highest = 0;\\n\\n        for(let i = 0 ; i < d.length ; i++)\\n            {\\n                let item = d[i];\\n                countC = 0 ;\\n                \\n\\n                for(let j = 0 ; j < nums.length ; j++)\\n                    {\\n                        if( nums[j] % item === 0 )\\n                        {\\n                            countC++;\\n                        }\\n                    }\\n\\n                if(countP < countC)\\n                {\\n                    countP = countC;\\n                    highest = item;\\n                }\\n                else if(countP === countC)\\n                {\\n                    if(highest > item )\\n                    {\\n                        highest = item ;\\n                    }\\n                }\\n            }\\n\\n// this check here means that if the counterP is 0 then we check the largest number on divisor array and return the highest\\n    if(!countP) return Math.min.apply(null,d);\\n    return highest;\\n\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number[]} divisors\\n * @return {number}\\n */\\nvar maxDivScore = function(nums, d) {\\n    \\nlet countP = 0 ;\\n        let countC = 0 ;\\n        let highest = 0;\\n\\n        for(let i = 0 ; i < d.length ; i++)\\n            {\\n                let item = d[i];\\n                countC = 0 ;\\n                \\n\\n                for(let j = 0 ; j < nums.length ; j++)\\n                    {\\n                        if( nums[j] % item === 0 )\\n                        {\\n                            countC++;\\n                        }\\n                    }\\n\\n                if(countP < countC)\\n                {\\n                    countP = countC;\\n                    highest = item;\\n                }\\n                else if(countP === countC)\\n                {\\n                    if(highest > item )\\n                    {\\n                        highest = item ;\\n                    }\\n                }\\n            }\\n\\n// this check here means that if the counterP is 0 then we check the largest number on divisor array and return the highest\\n    if(!countP) return Math.min.apply(null,d);\\n    return highest;\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3443168,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(m*n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int maxi = Integer.MIN_VALUE;\\n        int element = -1;\\n        for(int i = 0; i < divisors.length; i++)\\n        {\\n            int count = 0;\\n            for(int j = 0; j < nums.length; j++)\\n            {\\n                if(nums[j] % divisors[i] == 0)\\n                {\\n                    count++;\\n                }\\n            }\\n            if(count > maxi)\\n            {\\n                maxi = count;\\n                element = divisors[i];\\n            }\\n            else if(count == maxi)\\n            {\\n                element = Math.min(element, divisors[i]);\\n            }\\n        }\\n        return element;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int maxi = Integer.MIN_VALUE;\\n        int element = -1;\\n        for(int i = 0; i < divisors.length; i++)\\n        {\\n            int count = 0;\\n            for(int j = 0; j < nums.length; j++)\\n            {\\n                if(nums[j] % divisors[i] == 0)\\n                {\\n                    count++;\\n                }\\n            }\\n            if(count > maxi)\\n            {\\n                maxi = count;\\n                element = divisors[i];\\n            }\\n            else if(count == maxi)\\n            {\\n                element = Math.min(element, divisors[i]);\\n            }\\n        }\\n        return element;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3442081,
                "title": "c-simple-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        sort(divisors.begin(),divisors.end());\\n        int ans=divisors[0];\\n        int maxi=0;\\n        for(int i=0;i<divisors.size();i++){\\n            int cnt=0;\\n            for(int j=0;j<nums.size();j++){\\n                if(nums[j]%divisors[i]==0){\\n                    cnt++;\\n                }\\n            }\\n            if(cnt>maxi){\\n                ans=divisors[i];\\n                maxi=cnt;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        sort(divisors.begin(),divisors.end());\\n        int ans=divisors[0];\\n        int maxi=0;\\n        for(int i=0;i<divisors.size();i++){\\n            int cnt=0;\\n            for(int j=0;j<nums.size();j++){\\n                if(nums[j]%divisors[i]==0){\\n                    cnt++;\\n                }\\n            }\\n            if(cnt>maxi){\\n                ans=divisors[i];\\n                maxi=cnt;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3442024,
                "title": "c-478-ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDivScore(const vector<int>& nums, const vector<int>& divisors) {\\n        unordered_set<int> unique_divisors;\\n        for(auto divisor : divisors) unique_divisors.insert(divisor);\\n\\n        int result = divisors[0], max_count = 0;\\n        for(auto divisor : unique_divisors) {\\n            int count = 0;\\n            for(auto num : nums) {\\n                if(num % divisor == 0) ++count;\\n            }\\n            if(max_count < count or max_count == count and divisor < result) {\\n                max_count = count;\\n                result = divisor;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(const vector<int>& nums, const vector<int>& divisors) {\\n        unordered_set<int> unique_divisors;\\n        for(auto divisor : divisors) unique_divisors.insert(divisor);\\n\\n        int result = divisors[0], max_count = 0;\\n        for(auto divisor : unique_divisors) {\\n            int count = 0;\\n            for(auto num : nums) {\\n                if(num % divisor == 0) ++count;\\n            }\\n            if(max_count < count or max_count == count and divisor < result) {\\n                max_count = count;\\n                result = divisor;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3441701,
                "title": "easy-js-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number[]} divisors\\n * @return {number}\\n */\\nvar maxDivScore = function(nums, divisors) {\\n    let res = divisors[0];\\n    let count =0;\\n    let max = 0;\\n    for(let a of divisors){\\n        for(let b of nums){\\n            if(b%a==0){\\n                count++;\\n            }\\n        }\\n        if(count>max){\\n            max=count;\\n            res = a;\\n        }else if(count===max){\\n            if(res>a){\\n                res=a;\\n            }\\n        }\\n        count=0;\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number[]} divisors\\n * @return {number}\\n */\\nvar maxDivScore = function(nums, divisors) {\\n    let res = divisors[0];\\n    let count =0;\\n    let max = 0;\\n    for(let a of divisors){\\n        for(let b of nums){\\n            if(b%a==0){\\n                count++;\\n            }\\n        }\\n        if(count>max){\\n            max=count;\\n            res = a;\\n        }else if(count===max){\\n            if(res>a){\\n                res=a;\\n            }\\n        }\\n        count=0;\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3441634,
                "title": "python-easy-begginers",
                "content": "**maximum divisor with lowest value when two or more have same score**\\n\\n```\\n\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n        c=0\\n        val=0\\n        ele =0\\n        divisors =sorted(divisors, reverse = True)\\n        for n in divisors:\\n            c=0\\n            for i in nums:\\n                if i%n==0:\\n                    c+=1\\n            \\n            if val<=c:\\n                val = c\\n                ele = n\\n \\xA0 \\xA0 \\xA0 \\xA0return ele\\n\\n```\\n",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n        c=0\\n        val=0\\n        ele =0\\n        divisors =sorted(divisors, reverse = True)\\n        for n in divisors:\\n            c=0\\n            for i in nums:\\n                if i%n==0:\\n                    c+=1\\n            \\n            if val<=c:\\n                val = c\\n                ele = n\\n \\xA0 \\xA0 \\xA0 \\xA0return ele\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3440624,
                "title": "c-plain-brute-force-99-space-427ms-30-space-29-6mb",
                "content": "Without any more specific domain knowledge, in particular about the commposition of `divisors` (how often we can get repeated ones or numbers that are GCDs of several others) any attempt of optimisation does not seem worth it, so let\\'s go for a crude, brutal BF here.\\n\\nWe will start by declaring three support variables:\\n* `res` is our usual accumulator variable;\\n* `maxScore` is the highest score seen so far, initially set to `-1` (ie: one less the actual minimum we can expect, that is `0`);\\n* `tmp` will store the temporary score of each divisor we will parse.\\n\\nWe will then loop for each `d` in `divisors` and:\\n* (re)set `tmp` to an initial value of `0`;\\n* for each element `n` in `nums`, we will:\\n    * check if `d` is a divisor of `n` (ie: `n % d == 0`);\\n    * increase `tmp` by `1` if so;\\n* if we have a first case, a new maximum (ie: `tmp > maxScore`), in which case we will:\\n    * update `maxScore` to be `tmp`;\\n    * update `res` to be `d`;\\n* if we have another score `tmp` equal to the previous maximum `maxScore`, we will just update `res` to be the minimum between its current value and `d`.\\n\\nOnce done, we can `return` `res` :)\\n\\n# Complexity\\n- Time complexity: $$O(d * n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```cpp\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int> &nums, vector<int> &divs) {\\n        // support variables\\n        int res, maxScore = -1, tmp;\\n        for (int d: divs) {\\n            // computing d\\'s score\\n            tmp = 0;\\n            for (int n: nums) tmp += n % d == 0;\\n            // case 1: new maxScore\\n            if (tmp > maxScore) {\\n                maxScore = tmp;\\n                res = d;\\n            }\\n            // case 2: same as maxScore\\n            else if (tmp == maxScore) res = min(res, d);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Number Theory"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int> &nums, vector<int> &divs) {\\n        // support variables\\n        int res, maxScore = -1, tmp;\\n        for (int d: divs) {\\n            // computing d\\'s score\\n            tmp = 0;\\n            for (int n: nums) tmp += n % d == 0;\\n            // case 1: new maxScore\\n            if (tmp > maxScore) {\\n                maxScore = tmp;\\n                res = d;\\n            }\\n            // case 2: same as maxScore\\n            else if (tmp == maxScore) res = min(res, d);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3439087,
                "title": "ultra-easy-python-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n        ans = 0\\n        maxi =-1\\n        for i in divisors:\\n            count = 0\\n            for j in nums:\\n                if j%i==0:\\n                    count += 1\\n            if count ==maxi:\\n                ans = min(ans,i)\\n            elif count>maxi:\\n                maxi = count\\n                ans = i\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n        ans = 0\\n        maxi =-1\\n        for i in divisors:\\n            count = 0\\n            for j in nums:\\n                if j%i==0:\\n                    count += 1\\n            if count ==maxi:\\n                ans = min(ans,i)\\n            elif count>maxi:\\n                maxi = count\\n                ans = i\\n        return ans\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1865215,
                "content": [
                    {
                        "username": "M1dn1ght",
                        "content": "tricky tricky"
                    },
                    {
                        "username": "victCh",
                        "content": "most difficult in this problem is to understansd \"If there is more than one integer with the maximum score, return the minimum of them.\""
                    },
                    {
                        "username": "Dizzy099",
                        "content": "finally solved it by brute force , please someone explain optimized way"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don\\'t think there is an optimized way. That\\'s why it\\'s an easy problem, because the expected answer is just the brute force approach"
                    },
                    {
                        "username": "20311a0436",
                        "content": "Optimised approach other than brute force?"
                    },
                    {
                        "username": "bjhhar6475",
                        "content": "You can get significantly faster (10x ~400ms instead of 4000ms) performance if instead of iterating through nums, you through multiples of the divisor. Of course, stop once you exceed the max value in nums. Specifically, hash each number and given divisor like 6, check if 6, 12, ...  max(nums) is in nums. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I was thinking there might be a way to avoid redundancies if some of the divisors divide each other... But checking for that already takes some time, and in the worst case anyway, divisors would all be prime numbers or something and there's no redundant information.\nIn the case where all numbers involved are primes, I don't think there's a better way to do it than brute force checking everything, because I don't see a good way to compress the information\n"
                    },
                    {
                        "username": "sooraj7",
                        "content": "At first the question seems to be confusing, but on grasping, it turns out to be pretty easy, just take care to return the smallest in case of conflict"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "Look for optimization of your code !! \\nHash map can useful"
                    },
                    {
                        "username": "AsrielAries0704",
                        "content": "Done, but... 9500+ms :| brute force"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "If anyone enjoys one-line solutions, I explain in great lenght one way to do it, to give beginners some syntaxic ideas to work with:\n[Check it out!](https://leetcode.com/problems/find-the-maximum-divisibility-score/solutions/3422676/python-one-liner-for-beginners/?orderBy=most_votes)"
                    }
                ]
            },
            {
                "id": 1899331,
                "content": [
                    {
                        "username": "M1dn1ght",
                        "content": "tricky tricky"
                    },
                    {
                        "username": "victCh",
                        "content": "most difficult in this problem is to understansd \"If there is more than one integer with the maximum score, return the minimum of them.\""
                    },
                    {
                        "username": "Dizzy099",
                        "content": "finally solved it by brute force , please someone explain optimized way"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don\\'t think there is an optimized way. That\\'s why it\\'s an easy problem, because the expected answer is just the brute force approach"
                    },
                    {
                        "username": "20311a0436",
                        "content": "Optimised approach other than brute force?"
                    },
                    {
                        "username": "bjhhar6475",
                        "content": "You can get significantly faster (10x ~400ms instead of 4000ms) performance if instead of iterating through nums, you through multiples of the divisor. Of course, stop once you exceed the max value in nums. Specifically, hash each number and given divisor like 6, check if 6, 12, ...  max(nums) is in nums. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I was thinking there might be a way to avoid redundancies if some of the divisors divide each other... But checking for that already takes some time, and in the worst case anyway, divisors would all be prime numbers or something and there's no redundant information.\nIn the case where all numbers involved are primes, I don't think there's a better way to do it than brute force checking everything, because I don't see a good way to compress the information\n"
                    },
                    {
                        "username": "sooraj7",
                        "content": "At first the question seems to be confusing, but on grasping, it turns out to be pretty easy, just take care to return the smallest in case of conflict"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "Look for optimization of your code !! \\nHash map can useful"
                    },
                    {
                        "username": "AsrielAries0704",
                        "content": "Done, but... 9500+ms :| brute force"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "If anyone enjoys one-line solutions, I explain in great lenght one way to do it, to give beginners some syntaxic ideas to work with:\n[Check it out!](https://leetcode.com/problems/find-the-maximum-divisibility-score/solutions/3422676/python-one-liner-for-beginners/?orderBy=most_votes)"
                    }
                ]
            },
            {
                "id": 1865680,
                "content": [
                    {
                        "username": "M1dn1ght",
                        "content": "tricky tricky"
                    },
                    {
                        "username": "victCh",
                        "content": "most difficult in this problem is to understansd \"If there is more than one integer with the maximum score, return the minimum of them.\""
                    },
                    {
                        "username": "Dizzy099",
                        "content": "finally solved it by brute force , please someone explain optimized way"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don\\'t think there is an optimized way. That\\'s why it\\'s an easy problem, because the expected answer is just the brute force approach"
                    },
                    {
                        "username": "20311a0436",
                        "content": "Optimised approach other than brute force?"
                    },
                    {
                        "username": "bjhhar6475",
                        "content": "You can get significantly faster (10x ~400ms instead of 4000ms) performance if instead of iterating through nums, you through multiples of the divisor. Of course, stop once you exceed the max value in nums. Specifically, hash each number and given divisor like 6, check if 6, 12, ...  max(nums) is in nums. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I was thinking there might be a way to avoid redundancies if some of the divisors divide each other... But checking for that already takes some time, and in the worst case anyway, divisors would all be prime numbers or something and there's no redundant information.\nIn the case where all numbers involved are primes, I don't think there's a better way to do it than brute force checking everything, because I don't see a good way to compress the information\n"
                    },
                    {
                        "username": "sooraj7",
                        "content": "At first the question seems to be confusing, but on grasping, it turns out to be pretty easy, just take care to return the smallest in case of conflict"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "Look for optimization of your code !! \\nHash map can useful"
                    },
                    {
                        "username": "AsrielAries0704",
                        "content": "Done, but... 9500+ms :| brute force"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "If anyone enjoys one-line solutions, I explain in great lenght one way to do it, to give beginners some syntaxic ideas to work with:\n[Check it out!](https://leetcode.com/problems/find-the-maximum-divisibility-score/solutions/3422676/python-one-liner-for-beginners/?orderBy=most_votes)"
                    }
                ]
            },
            {
                "id": 1864916,
                "content": [
                    {
                        "username": "M1dn1ght",
                        "content": "tricky tricky"
                    },
                    {
                        "username": "victCh",
                        "content": "most difficult in this problem is to understansd \"If there is more than one integer with the maximum score, return the minimum of them.\""
                    },
                    {
                        "username": "Dizzy099",
                        "content": "finally solved it by brute force , please someone explain optimized way"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don\\'t think there is an optimized way. That\\'s why it\\'s an easy problem, because the expected answer is just the brute force approach"
                    },
                    {
                        "username": "20311a0436",
                        "content": "Optimised approach other than brute force?"
                    },
                    {
                        "username": "bjhhar6475",
                        "content": "You can get significantly faster (10x ~400ms instead of 4000ms) performance if instead of iterating through nums, you through multiples of the divisor. Of course, stop once you exceed the max value in nums. Specifically, hash each number and given divisor like 6, check if 6, 12, ...  max(nums) is in nums. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I was thinking there might be a way to avoid redundancies if some of the divisors divide each other... But checking for that already takes some time, and in the worst case anyway, divisors would all be prime numbers or something and there's no redundant information.\nIn the case where all numbers involved are primes, I don't think there's a better way to do it than brute force checking everything, because I don't see a good way to compress the information\n"
                    },
                    {
                        "username": "sooraj7",
                        "content": "At first the question seems to be confusing, but on grasping, it turns out to be pretty easy, just take care to return the smallest in case of conflict"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "Look for optimization of your code !! \\nHash map can useful"
                    },
                    {
                        "username": "AsrielAries0704",
                        "content": "Done, but... 9500+ms :| brute force"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "If anyone enjoys one-line solutions, I explain in great lenght one way to do it, to give beginners some syntaxic ideas to work with:\n[Check it out!](https://leetcode.com/problems/find-the-maximum-divisibility-score/solutions/3422676/python-one-liner-for-beginners/?orderBy=most_votes)"
                    }
                ]
            },
            {
                "id": 2045292,
                "content": [
                    {
                        "username": "M1dn1ght",
                        "content": "tricky tricky"
                    },
                    {
                        "username": "victCh",
                        "content": "most difficult in this problem is to understansd \"If there is more than one integer with the maximum score, return the minimum of them.\""
                    },
                    {
                        "username": "Dizzy099",
                        "content": "finally solved it by brute force , please someone explain optimized way"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don\\'t think there is an optimized way. That\\'s why it\\'s an easy problem, because the expected answer is just the brute force approach"
                    },
                    {
                        "username": "20311a0436",
                        "content": "Optimised approach other than brute force?"
                    },
                    {
                        "username": "bjhhar6475",
                        "content": "You can get significantly faster (10x ~400ms instead of 4000ms) performance if instead of iterating through nums, you through multiples of the divisor. Of course, stop once you exceed the max value in nums. Specifically, hash each number and given divisor like 6, check if 6, 12, ...  max(nums) is in nums. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I was thinking there might be a way to avoid redundancies if some of the divisors divide each other... But checking for that already takes some time, and in the worst case anyway, divisors would all be prime numbers or something and there's no redundant information.\nIn the case where all numbers involved are primes, I don't think there's a better way to do it than brute force checking everything, because I don't see a good way to compress the information\n"
                    },
                    {
                        "username": "sooraj7",
                        "content": "At first the question seems to be confusing, but on grasping, it turns out to be pretty easy, just take care to return the smallest in case of conflict"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "Look for optimization of your code !! \\nHash map can useful"
                    },
                    {
                        "username": "AsrielAries0704",
                        "content": "Done, but... 9500+ms :| brute force"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "If anyone enjoys one-line solutions, I explain in great lenght one way to do it, to give beginners some syntaxic ideas to work with:\n[Check it out!](https://leetcode.com/problems/find-the-maximum-divisibility-score/solutions/3422676/python-one-liner-for-beginners/?orderBy=most_votes)"
                    }
                ]
            },
            {
                "id": 1938388,
                "content": [
                    {
                        "username": "M1dn1ght",
                        "content": "tricky tricky"
                    },
                    {
                        "username": "victCh",
                        "content": "most difficult in this problem is to understansd \"If there is more than one integer with the maximum score, return the minimum of them.\""
                    },
                    {
                        "username": "Dizzy099",
                        "content": "finally solved it by brute force , please someone explain optimized way"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don\\'t think there is an optimized way. That\\'s why it\\'s an easy problem, because the expected answer is just the brute force approach"
                    },
                    {
                        "username": "20311a0436",
                        "content": "Optimised approach other than brute force?"
                    },
                    {
                        "username": "bjhhar6475",
                        "content": "You can get significantly faster (10x ~400ms instead of 4000ms) performance if instead of iterating through nums, you through multiples of the divisor. Of course, stop once you exceed the max value in nums. Specifically, hash each number and given divisor like 6, check if 6, 12, ...  max(nums) is in nums. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I was thinking there might be a way to avoid redundancies if some of the divisors divide each other... But checking for that already takes some time, and in the worst case anyway, divisors would all be prime numbers or something and there's no redundant information.\nIn the case where all numbers involved are primes, I don't think there's a better way to do it than brute force checking everything, because I don't see a good way to compress the information\n"
                    },
                    {
                        "username": "sooraj7",
                        "content": "At first the question seems to be confusing, but on grasping, it turns out to be pretty easy, just take care to return the smallest in case of conflict"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "Look for optimization of your code !! \\nHash map can useful"
                    },
                    {
                        "username": "AsrielAries0704",
                        "content": "Done, but... 9500+ms :| brute force"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "If anyone enjoys one-line solutions, I explain in great lenght one way to do it, to give beginners some syntaxic ideas to work with:\n[Check it out!](https://leetcode.com/problems/find-the-maximum-divisibility-score/solutions/3422676/python-one-liner-for-beginners/?orderBy=most_votes)"
                    }
                ]
            },
            {
                "id": 1867685,
                "content": [
                    {
                        "username": "M1dn1ght",
                        "content": "tricky tricky"
                    },
                    {
                        "username": "victCh",
                        "content": "most difficult in this problem is to understansd \"If there is more than one integer with the maximum score, return the minimum of them.\""
                    },
                    {
                        "username": "Dizzy099",
                        "content": "finally solved it by brute force , please someone explain optimized way"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don\\'t think there is an optimized way. That\\'s why it\\'s an easy problem, because the expected answer is just the brute force approach"
                    },
                    {
                        "username": "20311a0436",
                        "content": "Optimised approach other than brute force?"
                    },
                    {
                        "username": "bjhhar6475",
                        "content": "You can get significantly faster (10x ~400ms instead of 4000ms) performance if instead of iterating through nums, you through multiples of the divisor. Of course, stop once you exceed the max value in nums. Specifically, hash each number and given divisor like 6, check if 6, 12, ...  max(nums) is in nums. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I was thinking there might be a way to avoid redundancies if some of the divisors divide each other... But checking for that already takes some time, and in the worst case anyway, divisors would all be prime numbers or something and there's no redundant information.\nIn the case where all numbers involved are primes, I don't think there's a better way to do it than brute force checking everything, because I don't see a good way to compress the information\n"
                    },
                    {
                        "username": "sooraj7",
                        "content": "At first the question seems to be confusing, but on grasping, it turns out to be pretty easy, just take care to return the smallest in case of conflict"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "Look for optimization of your code !! \\nHash map can useful"
                    },
                    {
                        "username": "AsrielAries0704",
                        "content": "Done, but... 9500+ms :| brute force"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "If anyone enjoys one-line solutions, I explain in great lenght one way to do it, to give beginners some syntaxic ideas to work with:\n[Check it out!](https://leetcode.com/problems/find-the-maximum-divisibility-score/solutions/3422676/python-one-liner-for-beginners/?orderBy=most_votes)"
                    }
                ]
            },
            {
                "id": 1865190,
                "content": [
                    {
                        "username": "M1dn1ght",
                        "content": "tricky tricky"
                    },
                    {
                        "username": "victCh",
                        "content": "most difficult in this problem is to understansd \"If there is more than one integer with the maximum score, return the minimum of them.\""
                    },
                    {
                        "username": "Dizzy099",
                        "content": "finally solved it by brute force , please someone explain optimized way"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don\\'t think there is an optimized way. That\\'s why it\\'s an easy problem, because the expected answer is just the brute force approach"
                    },
                    {
                        "username": "20311a0436",
                        "content": "Optimised approach other than brute force?"
                    },
                    {
                        "username": "bjhhar6475",
                        "content": "You can get significantly faster (10x ~400ms instead of 4000ms) performance if instead of iterating through nums, you through multiples of the divisor. Of course, stop once you exceed the max value in nums. Specifically, hash each number and given divisor like 6, check if 6, 12, ...  max(nums) is in nums. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I was thinking there might be a way to avoid redundancies if some of the divisors divide each other... But checking for that already takes some time, and in the worst case anyway, divisors would all be prime numbers or something and there's no redundant information.\nIn the case where all numbers involved are primes, I don't think there's a better way to do it than brute force checking everything, because I don't see a good way to compress the information\n"
                    },
                    {
                        "username": "sooraj7",
                        "content": "At first the question seems to be confusing, but on grasping, it turns out to be pretty easy, just take care to return the smallest in case of conflict"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "Look for optimization of your code !! \\nHash map can useful"
                    },
                    {
                        "username": "AsrielAries0704",
                        "content": "Done, but... 9500+ms :| brute force"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "If anyone enjoys one-line solutions, I explain in great lenght one way to do it, to give beginners some syntaxic ideas to work with:\n[Check it out!](https://leetcode.com/problems/find-the-maximum-divisibility-score/solutions/3422676/python-one-liner-for-beginners/?orderBy=most_votes)"
                    }
                ]
            }
        ]
    },
    {
        "title": "Minimum Number of Operations to Make All Array Elements Equal to 1",
        "question_content": "<p>You are given a <strong>0-indexed</strong>&nbsp;array <code>nums</code> consisiting of <strong>positive</strong> integers. You can do the following operation on the array <strong>any</strong> number of times:</p>\n\n<ul>\n\t<li>Select an index <code>i</code> such that <code>0 &lt;= i &lt; n - 1</code> and replace either of&nbsp;<code>nums[i]</code> or <code>nums[i+1]</code> with their gcd value.</li>\n</ul>\n\n<p>Return <em>the <strong>minimum</strong> number of operations to make all elements of </em><code>nums</code><em> equal to </em><code>1</code>. If it is impossible, return <code>-1</code>.</p>\n\n<p>The gcd of two integers is the greatest common divisor of the two integers.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [2,6,3,4]\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> We can do the following operations:\n- Choose index i = 2 and replace nums[2] with gcd(3,4) = 1. Now we have nums = [2,6,1,4].\n- Choose index i = 1 and replace nums[1] with gcd(6,1) = 1. Now we have nums = [2,1,1,4].\n- Choose index i = 0 and replace nums[0] with gcd(2,1) = 1. Now we have nums = [1,1,1,4].\n- Choose index i = 2 and replace nums[3] with gcd(1,4) = 1. Now we have nums = [1,1,1,1].\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [2,10,6,14]\n<strong>Output:</strong> -1\n<strong>Explanation:</strong> It can be shown that it is impossible to make all the elements equal to 1.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length &lt;= 50</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>6</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><b>Follow-up:</b></p>\n\n<p>The <code>O(n)</code> time complexity&nbsp;solution works, but could you find an <code>O(1)</code> constant time complexity solution?</p>\n",
        "solutions": [
            {
                "id": 3445725,
                "title": "explained-easy-gcd-and-intuition",
                "content": "# Intuition\\nQ1. When is gcd of 2 numbers =1 ? \\nA1. when both the numbers have no common factor. The gcd of 1 and any other number is always 1 itself. \\n\\nQ2. How is the property stated above beneficial?\\nA2. I just need to find the number of operations required to make any element as 1 and then the remaining n-1 elements can be made 1 in just n-1 steps where n is the size of the array. \\nElaborated: if we have a 1 at index \\u201Ci\\u201D then we would make element at i-1 => gcd(nums[i-1],nums[i]) this would make the element at index i-1 as 1 too! Then we\\u2019ll perform the same with i-2,i-3\\u2026.1 . without loss of generality we would perform the similar operations to the right of I as well! \\n\\nQ3. How do you get the minimum number of operations required to make any of the elements as 1?\\nA3. given the constraints, for any element I we can traverse through all elements (say iterator j) from i+1 to n and take their gcd. As soon as the gcd becomes 1 we can conclude that taking gcd in the reverse fashion (from nums[j] to nums[i]) would make nums[i] equal to 1. \\n\\nQ4. what if some 1s are already present in the array?\\nA4. In that case we can say that we would use the operation mentioned in A2 and make the remaining elements equal to 1. \\n\\nThe code is self-explanatory, let me know if you have any doubts! Thanks!\\n\\n\\n# Complexity\\n- Time complexity:\\nO(N^2)\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n=nums.size();\\n        int c=count(nums.begin(),nums.end(),1);     // if there is at least 1. then it\\'s easy!\\n        if(c!=0)    return n-c;\\n        int res=1e7;        // just a dummy value\\n        for(int i=0;i<n;i++){\\n            int g=nums[i];\\n            for(int j=i+1;j<n;j++){\\n                g=__gcd(g,nums[j]);\\n                if(g==1){\\n                    res=min(res,j-i+(n-1)); // number of operations to make this element 1+ number of non ones (i.e. n-1) .\\n                    break;\\n                } \\n            }\\n        }\\n        return res==1e7?-1:res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n=nums.size();\\n        int c=count(nums.begin(),nums.end(),1);     // if there is at least 1. then it\\'s easy!\\n        if(c!=0)    return n-c;\\n        int res=1e7;        // just a dummy value\\n        for(int i=0;i<n;i++){\\n            int g=nums[i];\\n            for(int j=i+1;j<n;j++){\\n                g=__gcd(g,nums[j]);\\n                if(g==1){\\n                    res=min(res,j-i+(n-1)); // number of operations to make this element 1+ number of non ones (i.e. n-1) .\\n                    break;\\n                } \\n            }\\n        }\\n        return res==1e7?-1:res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446148,
                "title": "leetcode-the-hard-way-explained-line-by-line",
                "content": "<iframe src=\"https://leetcode.com/playground/9gLg2fYc/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\"></iframe>",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Greedy"
                ],
                "code": "<iframe src=\"https://leetcode.com/playground/9gLg2fYc/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\"></iframe>",
                "codeTag": "Unknown"
            },
            {
                "id": 3445895,
                "title": "smallest-subarray-gcd-equal-to-1-very-simple-easy-to-understand-solution",
                "content": "<b> Up vote if you like the solution \\n# Approach\\n1. The key is to find at least one 1 in th the nums, once found then other can be made 1 with n -1 operations.\\n2. To have least no. of operations we need to find the smallest subarray whose gcd is 1.\\n3. For this, with greedy approach we will check each sub array and evaluate gcd and keep storing the minimum length for which GCD is 1.\\n\\nCorner case : if there is already x no. of 1s in the array, then simply needed n-x no of operation.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int minOperations(vector<int>& nums) {\\n        int t = INT_MAX, count = 0;\\n        for(auto n: nums){ if(n == 1) count++; }\\n        if(count > 0) { return nums.size() - count; }\\n        for(int i = 0; i<nums.size(); ++i ){\\n            int last = nums[i];\\n            for(int j = i+1; j < nums.size(); ++j ){\\n                last = __gcd(last, nums[j]);\\n                if(last == 1) { t = min(t, j-i); break; }\\n            }\\n        }\\n        if(t != INT_MAX) return t + nums.size()-1;\\n        return -1;\\n    }\\n};\\n```\\n\\nHere is an article of my recent interview experience - A Journey to FAANG Company, I recomand you to go through this to know which all resources I have used & how I cracked interview at Amazon:\\nhttps://leetcode.com/discuss/interview-experience/3171859/Journey-to-a-FAANG-Company-Amazon-or-SDE2-(L5)-or-Bangalore-or-Oct-2022-Accepted",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int minOperations(vector<int>& nums) {\\n        int t = INT_MAX, count = 0;\\n        for(auto n: nums){ if(n == 1) count++; }\\n        if(count > 0) { return nums.size() - count; }\\n        for(int i = 0; i<nums.size(); ++i ){\\n            int last = nums[i];\\n            for(int j = i+1; j < nums.size(); ++j ){\\n                last = __gcd(last, nums[j]);\\n                if(last == 1) { t = min(t, j-i); break; }\\n            }\\n        }\\n        if(t != INT_MAX) return t + nums.size()-1;\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445773,
                "title": "python3-gcd",
                "content": "\\n```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        ones = nums.count(1)\\n        if ones: return len(nums)-ones\\n        diff = inf \\n        for i in range(len(nums)): \\n            g = nums[i]\\n            for j in range(i+1, len(nums)):\\n                g = gcd(g, nums[j])\\n                if g == 1: diff = min(diff, j-i)\\n        return -1 if diff == inf else diff + len(nums) - 1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        ones = nums.count(1)\\n        if ones: return len(nums)-ones\\n        diff = inf \\n        for i in range(len(nums)): \\n            g = nums[i]\\n            for j in range(i+1, len(nums)):\\n                g = gcd(g, nums[j])\\n                if g == 1: diff = min(diff, j-i)\\n        return -1 if diff == inf else diff + len(nums) - 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445663,
                "title": "cpp-make-exactly-one-element-1",
                "content": "\\n\\n\\n#### Intution : \\n* If we have one element `1` then we can make all elements `1`\\n* So our task is make exacty one element `1`\\n\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int GCD = 0, n = nums.size();\\n        // If GCD of all numbers in nums not equal to 1 then we can not make all element 1 return -1\\n        for(int i = 0; i < n; i++) GCD = __gcd(nums[i], GCD);\\n        if(GCD != 1) return -1;\\n        \\n        // If number of ones in given array is present then return n - cntOne\\n        int cntOne = count(nums.begin(), nums.end(), 1);\\n        if(cntOne) return n - cntOne; \\n        \\n        // calculate how many mininum operations needed to make one element in array is 1\\n        int mi = INT_MAX;\\n        for(int i = 0; i < n; i++) {\\n            int res = nums[i];\\n            for(int j = i; j < n; j++) {\\n                res = __gcd(nums[j], res);\\n                if(res == 1) mi = min(mi, j - i);\\n            }\\n        }\\n        return n + mi - 1;\\n    }\\n};\\n```\\n>Have a good day. Happy Coding!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int GCD = 0, n = nums.size();\\n        // If GCD of all numbers in nums not equal to 1 then we can not make all element 1 return -1\\n        for(int i = 0; i < n; i++) GCD = __gcd(nums[i], GCD);\\n        if(GCD != 1) return -1;\\n        \\n        // If number of ones in given array is present then return n - cntOne\\n        int cntOne = count(nums.begin(), nums.end(), 1);\\n        if(cntOne) return n - cntOne; \\n        \\n        // calculate how many mininum operations needed to make one element in array is 1\\n        int mi = INT_MAX;\\n        for(int i = 0; i < n; i++) {\\n            int res = nums[i];\\n            for(int j = i; j < n; j++) {\\n                res = __gcd(nums[j], res);\\n                if(res == 1) mi = min(mi, j - i);\\n            }\\n        }\\n        return n + mi - 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445720,
                "title": "simple-java-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n * k)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int minOperations(int[] nums) {\\n        int n = nums.length;\\n        int c = 0;\\n        for(int i=0; i<n; i++)\\n        {\\n            if(nums[i] == 1)\\n            {\\n                c++;\\n            }\\n        }\\n        if(c > 0)\\n        {\\n            return n - c;\\n        }\\n        int ans = Integer.MAX_VALUE;\\n        for(int i=0; i<n; i++)\\n        {\\n            int num = nums[i];\\n            for(int j=i+1; j<n; j++)\\n            {\\n                num = gcd(num, nums[j]);\\n                if(num == 1)\\n                {\\n                    ans = Math.min(ans, j-i);\\n                    break;\\n                }\\n            }\\n            if(num != 1)\\n            {\\n                break;\\n            }\\n        }\\n        if(ans == Integer.MAX_VALUE)\\n        {\\n            return -1;\\n        }\\n        return n - 1 + ans;\\n    }\\n    public int gcd(int a, int b)\\n    {\\n        if(a == 0)\\n        {\\n            return b;\\n        }\\n        return gcd(b%a, a); \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(int[] nums) {\\n        int n = nums.length;\\n        int c = 0;\\n        for(int i=0; i<n; i++)\\n        {\\n            if(nums[i] == 1)\\n            {\\n                c++;\\n            }\\n        }\\n        if(c > 0)\\n        {\\n            return n - c;\\n        }\\n        int ans = Integer.MAX_VALUE;\\n        for(int i=0; i<n; i++)\\n        {\\n            int num = nums[i];\\n            for(int j=i+1; j<n; j++)\\n            {\\n                num = gcd(num, nums[j]);\\n                if(num == 1)\\n                {\\n                    ans = Math.min(ans, j-i);\\n                    break;\\n                }\\n            }\\n            if(num != 1)\\n            {\\n                break;\\n            }\\n        }\\n        if(ans == Integer.MAX_VALUE)\\n        {\\n            return -1;\\n        }\\n        return n - 1 + ans;\\n    }\\n    public int gcd(int a, int b)\\n    {\\n        if(a == 0)\\n        {\\n            return b;\\n        }\\n        return gcd(b%a, a); \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3447561,
                "title": "c-solution-o-n-most-optimised-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        int one = 0;\\n        for (int i = 0; i < n; i++) one += nums[i] == 1;\\n        if (one) return n - one;\\n        stack<int> la, ra, lg, rg;\\n        auto good = [&](){\\n            int g = 0;\\n            if (!la.empty()) g = gcd(g, lg.top());\\n            if (!ra.empty()) g = gcd(g, rg.top());\\n            return g == 1;\\n        };\\n        auto add  = [&](int x){\\n            ra.push(x);\\n            rg.push(gcd((rg.empty() ? 0 : rg.top()), x));\\n        };\\n        auto remove = [&](){\\n            if (la.empty()){\\n                while(!ra.empty()){\\n                    int x = ra.top(); la.push(x); ra.pop(), rg.pop();\\n                    lg.push(gcd((lg.empty() ? 0 : lg.top()), x));\\n                }\\n            }\\n            la.pop(), lg.pop();\\n        };\\n        int ans = n;\\n        for (int l = 0, r = 0; r < n; r++){\\n            add(nums[r]);\\n            while (l < n and good()){\\n                ans = min(ans, r - l);\\n                remove(), l++;\\n            }\\n        }\\n        if (ans == n) return -1;\\n        return n + ans - 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        int one = 0;\\n        for (int i = 0; i < n; i++) one += nums[i] == 1;\\n        if (one) return n - one;\\n        stack<int> la, ra, lg, rg;\\n        auto good = [&](){\\n            int g = 0;\\n            if (!la.empty()) g = gcd(g, lg.top());\\n            if (!ra.empty()) g = gcd(g, rg.top());\\n            return g == 1;\\n        };\\n        auto add  = [&](int x){\\n            ra.push(x);\\n            rg.push(gcd((rg.empty() ? 0 : rg.top()), x));\\n        };\\n        auto remove = [&](){\\n            if (la.empty()){\\n                while(!ra.empty()){\\n                    int x = ra.top(); la.push(x); ra.pop(), rg.pop();\\n                    lg.push(gcd((lg.empty() ? 0 : lg.top()), x));\\n                }\\n            }\\n            la.pop(), lg.pop();\\n        };\\n        int ans = n;\\n        for (int l = 0, r = 0; r < n; r++){\\n            add(nums[r]);\\n            while (l < n and good()){\\n                ans = min(ans, r - l);\\n                remove(), l++;\\n            }\\n        }\\n        if (ans == n) return -1;\\n        return n + ans - 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445880,
                "title": "o-nlog-max-a-i-solution-cpp",
                "content": "We have to find the shortest subarray with gcd equal to 1. This is a standard problem and can be solved greedily.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int g=0;\\n        int ones=0;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            g=__gcd(g,nums[i]);\\n            if(nums[i]==1)\\n                ones++;\\n        }\\n        \\n        if(g!=1)\\n            return -1;\\n        if(ones)\\n            return n-ones;\\n        \\n        int ans=1e9;\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<n;i++)\\n        {\\n            unordered_map<int,int> nmp;\\n            nmp[nums[i]]=i;\\n            \\n            for(auto &[ele,r] : mp)\\n            {\\n                int val=__gcd(ele,nums[i]);\\n                if(nmp.find(val)==nmp.end())\\n                    nmp[val]=r;\\n                else\\n                    nmp[val]=std::max(nmp[val],r);\\n            }\\n                        \\n            if(nmp.find(1)!=nmp.end())\\n                ans=std::min(ans,n-1+i-nmp[1]);\\n            \\n            swap(nmp,mp);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nTime Complexity: **O(Nlog(Max(A[i])))**\\nSpace Complexity : **O(log(Max(A[i])))**\\n\\nplease set better constraints.",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int g=0;\\n        int ones=0;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            g=__gcd(g,nums[i]);\\n            if(nums[i]==1)\\n                ones++;\\n        }\\n        \\n        if(g!=1)\\n            return -1;\\n        if(ones)\\n            return n-ones;\\n        \\n        int ans=1e9;\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<n;i++)\\n        {\\n            unordered_map<int,int> nmp;\\n            nmp[nums[i]]=i;\\n            \\n            for(auto &[ele,r] : mp)\\n            {\\n                int val=__gcd(ele,nums[i]);\\n                if(nmp.find(val)==nmp.end())\\n                    nmp[val]=r;\\n                else\\n                    nmp[val]=std::max(nmp[val],r);\\n            }\\n                        \\n            if(nmp.find(1)!=nmp.end())\\n                ans=std::min(ans,n-1+i-nmp[1]);\\n            \\n            swap(nmp,mp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3465421,
                "title": "follow-up-is-misleading",
                "content": "The follow up asks if you can find a O(1) time algorithm after assuming that you found a O(n) algorithm. Even though the input size is 50, it\\'s technically not possible to get a true O(1) time algorithm here nor should it be assumed that a O(n) time algorithm is the standard solution for this problem. The follow up should be removed or reworded as it\\'s misleading.",
                "solutionTags": [],
                "code": "The follow up asks if you can find a O(1) time algorithm after assuming that you found a O(n) algorithm. Even though the input size is 50, it\\'s technically not possible to get a true O(1) time algorithm here nor should it be assumed that a O(n) time algorithm is the standard solution for this problem. The follow up should be removed or reworded as it\\'s misleading.",
                "codeTag": "Unknown"
            },
            {
                "id": 3446929,
                "title": "gcd-simple-explanation-java",
                "content": "**\\uD83D\\uDD1D\\uD83D\\uDD1D\\u2B06\\uFE0F\\u2B06\\uFE0FPlease Upvote if you find it useful. \\u2B06\\uFE0F\\u2B06\\uFE0F\\uD83D\\uDD1D\\uD83D\\uDD1D**\\n\\n# Intuition & Approach\\n1. If there are `x` numbers of `1` present in nums, then every number other than the `1s` can be converted to `1` in `n-x` operations by taking `gcd(1, nums[i])`, where `nums[i]!=1`.\\n2. If there are zero 1s present in nums, then we might never get a 1, or we might get a 1.\\n3. Let\\'s say there is a range `[i, j]` and the GCD of this entire range is `1`. That means, we can convert one of the elements in the range `[i, j]` to `1` in `(j-i)` operations.\\n4. Now once we convert any element to `1`, we can simply convert other elements to `1` in `(n - 1)` steps. So the total number of operations would be `(j - i + n - 1)`.\\n5. The Answer would be the minimum of this value over all possible ranges, where GCD of range is `1`.\\n\\n# Complexity\\n- Time complexity:\\n`O(N^2 * log(MAX))`, where `MAX` is the maximum value in the input array.\\n\\n- Space complexity:\\n`O(log(N))`\\n\\n# Code\\n```\\nclass Solution {\\n    public int minOperations(int[] nums) {\\n        int noOfOnes = 0;\\n        for (int num : nums) {\\n            if (num == 1) noOfOnes++;\\n        }\\n        if (noOfOnes > 0) return nums.length - noOfOnes;\\n        int ans = Integer.MAX_VALUE;\\n        for (int i = 0; i < nums.length; i++) {\\n            int gcd = nums[i]; // Take initial GCD of the [i, j] range\\n            for (int j = i + 1; j < nums.length; j++) {\\n                gcd = findGCD(gcd, nums[j]);  // For every new j, take gcd(nums[j], previousGCD) \\n                if (gcd == 1) ans = Math.min(ans, j - i + nums.length - 1);\\n            }\\n        }\\n        return ans == Integer.MAX_VALUE ? -1 : ans;\\n    }\\n\\n    private int findGCD(int a, int b) {\\n        if (a == 0) return b;\\n        return findGCD(b % a, a);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(int[] nums) {\\n        int noOfOnes = 0;\\n        for (int num : nums) {\\n            if (num == 1) noOfOnes++;\\n        }\\n        if (noOfOnes > 0) return nums.length - noOfOnes;\\n        int ans = Integer.MAX_VALUE;\\n        for (int i = 0; i < nums.length; i++) {\\n            int gcd = nums[i]; // Take initial GCD of the [i, j] range\\n            for (int j = i + 1; j < nums.length; j++) {\\n                gcd = findGCD(gcd, nums[j]);  // For every new j, take gcd(nums[j], previousGCD) \\n                if (gcd == 1) ans = Math.min(ans, j - i + nums.length - 1);\\n            }\\n        }\\n        return ans == Integer.MAX_VALUE ? -1 : ans;\\n    }\\n\\n    private int findGCD(int a, int b) {\\n        if (a == 0) return b;\\n        return findGCD(b % a, a);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445980,
                "title": "c-easiest-solution-with-amazing-explanation",
                "content": "# For the Given Problem:\\n**Task:\\n\\tConvert all the numbers to 1.\\n        At One step for any index i, you can convert nums[i] or nums[i+1] to gcd of them.\\n\\t\\treturn minimum number of operations or -1(if not possible)**\\n# Solution:\\n**1. Check when answer is not possible:**\\nIf gcd of all the numbers comes out to be not 1 then answer is -1 as we can\\'t achieve our    results.  Logic: If gcd of all the numbers can\\'t be one then gcd of any two numbers can also be not equal to 1.\\n\\n**2. If answer exist.**\\n  1. Calculate count of 1 in the nums, if ct>0 then we ans is ***(length of nums -ct)***\\n     Logic: We can use 1 to make all the remaining numbers 1 and for each number it takes one step.\\n\\t2. If no 1 is present in the nums, then find out how many operation require to convert every number to 1, and select the number which is taking the least operations to convert itself to 1 and then return ***number of operation to convert that number to 1 plus remaining numbers(n-1)***\\n\\n**TC: O(n^2)**\\n\\t \\n\\tclass Solution {\\n\\tpublic:\\n    \\n    int fn(vector<int>&nums)\\n    {\\n        int n = nums.size();\\n        vector<int>ans;\\n        for(int i=0;i<n-1;i++)\\n        {\\n            int v = __gcd(nums[i],nums[i+1]);\\n            ans.push_back(v);\\n            if(v==1) return 1;\\n        }        \\n        int val = 1+fn(ans);\\n        return val;\\n    }\\n    \\n    int minOperations(vector<int>& nums) \\n    {\\n        // Step:1: ans not exist\\n        int all=nums[0];\\n        for(auto i:nums)\\n        {\\n            all = __gcd(all,i);\\n        }\\n        if(all!=1) return -1;\\n        \\n        // step:2 checking one is present or note\\n        int n = nums.size();\\n        int ct_one =0;\\n        for(auto i:nums)\\n        {\\n            if(i==1) ct_one++;\\n        }\\n        \\n        if(ct_one>0) return n-ct_one;\\n        \\n        // step-3 : checking for minimum operations.\\n        int val = fn(nums);\\n        return n-1+val;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n\\tpublic:\\n    \\n    int fn(vector<int>&nums)\\n    {\\n        int n = nums.size();\\n        vector<int>ans;\\n        for(int i=0;i<n-1;i++)\\n        {\\n            int v = __gcd(nums[i],nums[i+1]);\\n            ans.push_back(v);\\n            if(v==1) return 1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3445894,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- If we have 1 as an element, then it can be propagated to other elements since Gcd of any number and 1 is 1. \\n- So the answer is number of operations required to make any element 1 + number of remaining elements. \\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int minOperations(int[] nums) {\\n        int n = nums.length;\\n        int g = 0;\\n        int one = 0;\\n        for (int num : nums) {\\n            // Compute gcd of all elements\\n            g = gcd(g, num);\\n\\n            // Count number of ones\\n            if (num == 1) \\n                one++;\\n        }\\n        // If Gcd of all elements is not 1, then we cannot produce \\n        // a 1 in any number of operations.\\n        if (g != 1) \\n            return -1;\\n\\n        // If there are already 1s in the array, \\n        // then simply return the number of remaining elements.\\n        if (one > 0) \\n            return n-one;\\n\\n        int ans = 100000;\\n        for (int i = 0; i < n; i++) {\\n            g = 0;\\n            for (int j = i; j >= 0; j--) {\\n                g = gcd(g, nums[j]);\\n                // If GCD of the subarray becomes 1,\\n                // count the number of operations (i-j) + remaining elements (n-1)\\n                if (g == 1) {\\n                    ans = Math.min(ans, i-j+n-1);\\n                    break;\\n                }\\n            }\\n        } \\n        return ans; \\n    }\\n    \\n    static int gcd(int a, int b)\\n    {\\n        if (b == 0)\\n            return a;\\n        else\\n            return gcd(b, a % b);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(int[] nums) {\\n        int n = nums.length;\\n        int g = 0;\\n        int one = 0;\\n        for (int num : nums) {\\n            // Compute gcd of all elements\\n            g = gcd(g, num);\\n\\n            // Count number of ones\\n            if (num == 1) \\n                one++;\\n        }\\n        // If Gcd of all elements is not 1, then we cannot produce \\n        // a 1 in any number of operations.\\n        if (g != 1) \\n            return -1;\\n\\n        // If there are already 1s in the array, \\n        // then simply return the number of remaining elements.\\n        if (one > 0) \\n            return n-one;\\n\\n        int ans = 100000;\\n        for (int i = 0; i < n; i++) {\\n            g = 0;\\n            for (int j = i; j >= 0; j--) {\\n                g = gcd(g, nums[j]);\\n                // If GCD of the subarray becomes 1,\\n                // count the number of operations (i-j) + remaining elements (n-1)\\n                if (g == 1) {\\n                    ans = Math.min(ans, i-j+n-1);\\n                    break;\\n                }\\n            }\\n        } \\n        return ans; \\n    }\\n    \\n    static int gcd(int a, int b)\\n    {\\n        if (b == 0)\\n            return a;\\n        else\\n            return gcd(b, a % b);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3449499,
                "title": "python-o-n-time-solution-two-pass",
                "content": "The goal of this problem is to get **the minimun size of subarray with gcd 1**\\n\\nFor the 1st pass, \\nWe can record the gcd of the element with previous ones by traversing the array.\\nWhen gcd becomes to 1, the gcd will be reset as the current element.\\nMeanwhile, we will record this index, because it is the **ENDING** of subarray with gcd 1.\\n\\nFor the 2nd pass, \\nWe will traverse the array from each **ENDING** point BACK to index 0.\\nThe goal is to find the **BEGINING** of subarray with gcd 1 for each ENDING.\\n\\nNote the previous 2-pass traveral is performed **from left to right**.\\nWe need another 2-pass traveral **from right to left**.\\n\\n```\\ndef minOperations(self, a: List[int]) -> int:\\n\\tif 1 in a:\\n\\t\\treturn len(a)-a.count(1)\\n\\tdef check(nums):\\n\\t\\tq, x, count = [0], nums[0], len(nums)+10\\n\\t\\t# index-0 is needed since it defines the left bound of our traversal\\n\\t\\tfor i in range(len(nums)):\\n\\t\\t\\tx = gcd(nums[i], x)\\n\\t\\t\\tif x==1:\\n\\t\\t\\t\\tq, x = q+[i], nums[i] \\n\\t\\t\\t# recording the ending of subarray with gcd 1\\n\\t\\tfor k in range(len(q)-1, 0, -1):\\n\\t\\t\\tx = nums[q[k]]\\n\\t\\t\\t# searching for the beginning of subarray with each ending\\n\\t\\t\\tfor i in range(q[k], q[k-1]-1, -1):\\n\\t\\t\\t\\tx = gcd(nums[i], x)\\n\\t\\t\\t\\tif x==1:\\n\\t\\t\\t\\t\\tcount = min(count, q[k]-i+1)\\n\\t\\t\\t\\t\\tbreak\\n\\t\\treturn count\\n\\tx = min(check(a), check(a[::-1]))\\n\\t# with x-length of subarry, we need \\'x-1\\' operation to get 1\\n\\treturn len(a)+x-2 if x<=len(a) else -1\\n```",
                "solutionTags": [],
                "code": "```\\ndef minOperations(self, a: List[int]) -> int:\\n\\tif 1 in a:\\n\\t\\treturn len(a)-a.count(1)\\n\\tdef check(nums):\\n\\t\\tq, x, count = [0], nums[0], len(nums)+10\\n\\t\\t# index-0 is needed since it defines the left bound of our traversal\\n\\t\\tfor i in range(len(nums)):\\n\\t\\t\\tx = gcd(nums[i], x)\\n\\t\\t\\tif x==1:\\n\\t\\t\\t\\tq, x = q+[i], nums[i] \\n\\t\\t\\t# recording the ending of subarray with gcd 1\\n\\t\\tfor k in range(len(q)-1, 0, -1):\\n\\t\\t\\tx = nums[q[k]]\\n\\t\\t\\t# searching for the beginning of subarray with each ending\\n\\t\\t\\tfor i in range(q[k], q[k-1]-1, -1):\\n\\t\\t\\t\\tx = gcd(nums[i], x)\\n\\t\\t\\t\\tif x==1:\\n\\t\\t\\t\\t\\tcount = min(count, q[k]-i+1)\\n\\t\\t\\t\\t\\tbreak\\n\\t\\treturn count\\n\\tx = min(check(a), check(a[::-1]))\\n\\t# with x-length of subarry, we need \\'x-1\\' operation to get 1\\n\\treturn len(a)+x-2 if x<=len(a) else -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3446079,
                "title": "gcd-100-faster-c-easy-to-understand",
                "content": "![image](https://assets.leetcode.com/users/images/c4eaaed5-229a-49e3-9e72-9a74dd7a7c94_1682226829.9661312.png)\\n````\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int i,g= 0;\\n        for(i = 0; i < nums.size(); i++){\\n            g = __gcd(g,nums[i]);\\n        }\\n        if(g>1)return -1;\\n        int y = 0;\\n        for(auto &i: nums){\\n            y += (i==1);\\n        }\\n        if(y)return nums.size()-y;\\n        int x = INT_MAX,j;\\n        for(i = 0; i < nums.size(); i++){\\n            int g = 0;\\n            for(j = i; j < nums.size(); j++){\\n                g = __gcd(g,nums[j]);\\n                if(g==1)break;\\n            }\\n            if(g==1&&j-i+1<x){x = j-i+1;}\\n        }\\n        return nums.size()+x-2;\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "````\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int i,g= 0;\\n        for(i = 0; i < nums.size(); i++){\\n            g = __gcd(g,nums[i]);\\n        }\\n        if(g>1)return -1;\\n        int y = 0;\\n        for(auto &i: nums){\\n            y += (i==1);\\n        }\\n        if(y)return nums.size()-y;\\n        int x = INT_MAX,j;\\n        for(i = 0; i < nums.size(); i++){\\n            int g = 0;\\n            for(j = i; j < nums.size(); j++){\\n                g = __gcd(g,nums[j]);\\n                if(g==1)break;\\n            }\\n            if(g==1&&j-i+1<x){x = j-i+1;}\\n        }\\n        return nums.size()+x-2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445942,
                "title": "simple-c-solution-using-smallest-subarray-having-gcd-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can find smallest subarray with gcd 1, and we can make other element in n-1 operation. if gcd of whole array is greater than 1 then ans does not exist\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialise and define function for gcd and smallest subarrayy having gcd as 1.\\n2. Check if gcd of whole array is greater than 1 or not, if it is greater than 1 then return -1.\\n3. count ones and if gcd of any two consecutive number is 1 then return n-ones.\\n4. Find smallest sub array having gcd 1, ans will be length of subarray - 1 + n-1.\\n\\n# Complexity\\n- Time complexity:N*LOG(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int gcd(int a, int b)\\n    {\\n\\t  if (b == 0)\\n\\t  {\\n\\t  \\treturn a;\\n\\t  }\\n\\t  return gcd(b, a % b);\\n    }\\n    int findSmallestSubArr(vector<int> &arr, int n, int g){\\n        int ans=INT_MAX,gg=0;\\n        for(int i=0;i<n;i++){\\n            gg=arr[i];\\n            for(int j=i;j<n;j++){\\n                if(arr[j]%g!=0) break;\\n                gg=gcd(gg,arr[j]);\\n                if(gg==g){\\n                    ans=min(ans,j-i+1);\\n                }\\n            }\\n        }\\n        return ans==INT_MAX ? -1:ans;\\n    }\\n    int minOperations(vector<int>& nums) {\\n        int g=nums[0];\\n        int one=0;\\n        for(auto x:nums)\\n        {\\n            if(x==1) one++;\\n            g=gcd(g,x);\\n        }\\n        if(g>1) return -1;\\n        bool ok=false;\\n        int n=nums.size();\\n        for(int i=1;i<n;i++)\\n        {\\n            if(gcd(nums[i],nums[i-1])==1){\\n                ok=true;\\n                break;\\n            }\\n        }\\n        if(ok) return n-one;\\n  \\n      int d= findSmallestSubArr(nums,n,1);\\n       int ans=d-1+n-1;\\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Simulation",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int gcd(int a, int b)\\n    {\\n\\t  if (b == 0)\\n\\t  {\\n\\t  \\treturn a;\\n\\t  }\\n\\t  return gcd(b, a % b);\\n    }\\n    int findSmallestSubArr(vector<int> &arr, int n, int g){\\n        int ans=INT_MAX,gg=0;\\n        for(int i=0;i<n;i++){\\n            gg=arr[i];\\n            for(int j=i;j<n;j++){\\n                if(arr[j]%g!=0) break;\\n                gg=gcd(gg,arr[j]);\\n                if(gg==g){\\n                    ans=min(ans,j-i+1);\\n                }\\n            }\\n        }\\n        return ans==INT_MAX ? -1:ans;\\n    }\\n    int minOperations(vector<int>& nums) {\\n        int g=nums[0];\\n        int one=0;\\n        for(auto x:nums)\\n        {\\n            if(x==1) one++;\\n            g=gcd(g,x);\\n        }\\n        if(g>1) return -1;\\n        bool ok=false;\\n        int n=nums.size();\\n        for(int i=1;i<n;i++)\\n        {\\n            if(gcd(nums[i],nums[i-1])==1){\\n                ok=true;\\n                break;\\n            }\\n        }\\n        if(ok) return n-one;\\n  \\n      int d= findSmallestSubArr(nums,n,1);\\n       int ans=d-1+n-1;\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445685,
                "title": "brute-force-full-explained-c",
                "content": "# Intuition\\n- Is it possible to make all numbers equal to one if the $gcd$ of all elements is not $1$?\\n- What if we already have some $1$?\\n- By the limits can be solved with brute force\\n# Analysis\\nThe answer to the first question is no, since there will always be some common divisor other than one for each subset. \\n\\nNow if the $gcd$ of the whole matrix is $1$ that means that there exists at least one subset $s$ whose $gcd_s=1$ but thinking in subsets is not useful since we have to choose adjacent elements however we can observe that: \\n\\nIf we have some subset $s$ of size $k$ and $gcd_s=1$ with index $s_1, s_2,s_3,\\\\dots s_k$ and $s_i<s_{i+1} \\\\;,\\\\;\\\\; 0\\\\leq i \\\\leq k-1$ it is logical that the subarray defined by the indices $[s_1,s_k]$ will also have $gcd = 1$ and we can apply the operations in this order $(s_1, s_{1+1}), (s_{1+1},s_{1+2}), (s_{1+len-2}, s_k)$ (always changing the one on the right) where $len = s_k-s_1+1$ denotes the length of the subarray. Doing these operations we will have a $1$ at position $s_k$ let\\'s see a small example: \\n\\n$A = [6,18,9,90,45,5]$ let\\'s see that the subset $S = {2,4}$ has $gcd==1$ so the subarray $[2,5]$ also has $gcd==1$ let\\'s apply the operations on the subset $S = {2,4}$.\\n \\n$Op1 = (2,3)$  $\\\\rightarrow$ $A = [6,18,9,9,9,45,5]$\\n$Op2 = (3,4)$  $\\\\rightarrow$ $A = [6,18,9,9,9,9,9,5]$\\n$Op2 = (4,5)$  $\\\\rightarrow$ $A = [6,18,9,9,9,9,9,1,1]$\\n\\nNow, what happens when we have some $1$ in the array? we just have to propagate until we fill the array with ones and this will cost , $n-ones$ where $n$ is the size of the array. I recommend dealing with ones at the beginning, that is, find out if there are ones at the beginning and simply return $n-ones$ as the answer. \\n\\nAfter dealing with ones we have a situation where we have to create this first $1$ then propagate it, in this case the answer will be $bestcost+n-1$ where $bestCost$ is the best way to create just a $1$. now the rest is to find the best way. \\nNotice how the bounds are very small $1 \\\\leq n \\\\leq 50$ that means we can iterate over all the subarrays and check if one of them has $gcd=1$ and use the one with the shortest length, by choosing the subarray with the shortest length we will get that $bestCost = len-1$ where $len$ is the length.  \\n\\n# Approach\\n- Count the number of ones at the beginning \\n- If there is at least $1$ the answer will be $n-ones$. \\n- If not, we have to find the smallest subarray with $gcd==1$ and the answer will be $len-1 +n-1$. \\n- To check the best subarray we can use brute force, since the bounds are very small. \\n\\n# Hard version. \\nThis problem could have been a good hard problem, I don\\'t know why they decided to put a medium difficulty one.  \\n$n$ could be at most $1000$ for this solution and probably still pass in time, but what happens if $n \\\\leq 10^5$.\\n- Solution: Binary search + some data structure that allows to get gcd in range getting a solution $o(n log(n)^2)$ but you can even optimize up to $O(n log(MAX))$ without an advanced data structure. \\n\\n# Complexity \\n$O(n^2 \\\\times log(MAX))$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        int ans = 1e9;\\n        int ones = 0;\\n        for(int i = 0;i<n;i++)ones+=nums[i]==1;\\n        \\n        if(ones)return n-ones;\\n        \\n        for(int i = 0;i<n;i++){\\n            int gcd = 0;\\n            \\n            for(int j = i;j<n;j++){\\n                gcd = __gcd(gcd,nums[j]);\\n                \\n                if(gcd == 1){\\n                    int len = (j-i)+1;\\n                    ans = min(ans,(len-1)+(n-1));\\n                }\\n            }\\n            \\n         \\n        \\n        }\\n        if(ans == 1e9)ans = -1;\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        int ans = 1e9;\\n        int ones = 0;\\n        for(int i = 0;i<n;i++)ones+=nums[i]==1;\\n        \\n        if(ones)return n-ones;\\n        \\n        for(int i = 0;i<n;i++){\\n            int gcd = 0;\\n            \\n            for(int j = i;j<n;j++){\\n                gcd = __gcd(gcd,nums[j]);\\n                \\n                if(gcd == 1){\\n                    int len = (j-i)+1;\\n                    ans = min(ans,(len-1)+(n-1));\\n                }\\n            }\\n            \\n         \\n        \\n        }\\n        if(ans == 1e9)ans = -1;\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446750,
                "title": "explained-step-by-step-with-examples-very-easy-to-understand-o-n-2-python-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe key to this problem is to find the first \"1\" of GCD result. Once it has been found, it can be spread to all the rest elements by lenth of the array - 1 (len(nums)-1) steps.\\n\\nIt would be easy if the GCD of two adjacent elements is \"1\". But what if the coprime factors are far apart and require several steps to pass and meet together? Every adjacent GCDs will be calculated and stored, then the same process is done to all adjacent GCD results till a \"1\" has been found or only one result remains.\\n\\n# Explaination with examples\\n<!-- Describe your approach to solving the problem. -->\\nConsider this case: [2,6,6,6,3,9], calculate GCD for all adjacent elements. And do the same thing to the results, until there is a \"1\".\\n```\\n2 6 6 6 3 9\\n 2 6 6 3 3     step 1\\n  2 6 3 3      step 2\\n   2 3 3       step 3\\n    1 3        step 4\\n```\\nThe coprime factors are 2 and 3 and they are at two sides of the array. It takes at least 4 steps for them to meet and have the GCD \"1\". The final result will be 4 plus 6-1 steps to spread \"1\"s to the whole array. \\n\\nIf it never gets 1, then return -1. Check this case: [2,10,6,14]\\n```\\n2 10 6 14\\n 2  2  2    step 1\\n   2  2     step 2\\n    2       step 3\\n```\\n\\nAnd don\\'t forget the case that there are \"1\"s in the number array. So the array has to be checked first, and just need number of non-one elements steps to make the array full of ones.\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1), modify the array in place.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\nC++\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int ct = 0;\\n        for(int i=0; i<nums.size(); i++)\\n            if(nums[i] == 1)\\n                ct++;\\n        if(ct > 0)\\n            return nums.size() - ct;\\n        for(int steps=0; steps<nums.size()-1; steps++)\\n            for(int i=0; i<nums.size()-steps-1; i++){\\n                nums[i] = gcd(nums[i], nums[i+1]);\\n                if(nums[i] == 1)\\n                    return steps + nums.size();\\n            }\\n        return -1;\\n    }\\n};\\n```\\nPython\\n```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        ct, n = 0, len(nums)\\n        for d in nums:\\n            if d == 1:\\n                ct += 1\\n        if ct > 0:\\n            return n - ct\\n        for steps in range(n):\\n            for i in range(n - steps - 1):\\n                nums[i] = gcd(nums[i], nums[i+1])\\n                if nums[i] == 1:\\n                    return steps + n\\n        return -1\\n```",
                "solutionTags": [
                    "C++",
                    "Python3"
                ],
                "code": "```\\n2 6 6 6 3 9\\n 2 6 6 3 3     step 1\\n  2 6 3 3      step 2\\n   2 3 3       step 3\\n    1 3        step 4\\n```\n```\\n2 10 6 14\\n 2  2  2    step 1\\n   2  2     step 2\\n    2       step 3\\n```\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int ct = 0;\\n        for(int i=0; i<nums.size(); i++)\\n            if(nums[i] == 1)\\n                ct++;\\n        if(ct > 0)\\n            return nums.size() - ct;\\n        for(int steps=0; steps<nums.size()-1; steps++)\\n            for(int i=0; i<nums.size()-steps-1; i++){\\n                nums[i] = gcd(nums[i], nums[i+1]);\\n                if(nums[i] == 1)\\n                    return steps + nums.size();\\n            }\\n        return -1;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        ct, n = 0, len(nums)\\n        for d in nums:\\n            if d == 1:\\n                ct += 1\\n        if ct > 0:\\n            return n - ct\\n        for steps in range(n):\\n            for i in range(n - steps - 1):\\n                nums[i] = gcd(nums[i], nums[i+1])\\n                if nums[i] == 1:\\n                    return steps + n\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446411,
                "title": "javascript-2654-minimum-number-of-operations-to-make-all-array-elements-equal-to-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n1\\n```\\nvar minOperations = function (a) {\\n    let nori = a.length; // n original length of array\\n\\n    // edge case 1 - check if only 1 unique element exist, and that element is 1 => all ones\\n    let set = new Set(a);\\n    if (set.size === 1)\\n        if (a[0] === 1) {\\n            return 0;\\n        }\\n\\n    // edge case 2 - check if some ones exist - count ones if exist\\n    let ones = 0;\\n    for (let i = 0; i < nori; i++)\\n        if (a[i] === 1) {\\n            ones++;\\n        }\\n    if (ones) {\\n        return nori - ones;\\n    }\\n\\n    // main work - find gcds and repeatedly replace array a & repeat\\n    let cc = 0;\\n    while (a.length) {\\n        let n = a.length;\\n        let a2 = [];\\n        for (let i = 0; i < n - 1; i++) {\\n            let g = gcd(a[i], a[i + 1]);\\n            if (g === 1) {\\n                return nori + cc; // when one can become 1, others can as well\\n            }\\n            a2.push(g);\\n        }\\n        a = a2;\\n        cc++;\\n    }\\n    return -1;\\n\\n    function gcd(a, b) {\\n        if (b == 0) return a;\\n        return gcd(b, a % b);\\n    }\\n};\\n```\\n\\n---\\n\\n**Contest**\\n- https://leetcode.com/contest/weekly-contest-342/ranking/67/\\n\\n**All Answers**\\n- **Q1** - https://leetcode.com/problems/calculate-delayed-arrival-time/solutions/3446023/javascript-2651-calculate-delayed-arrival-time/?orderBy=most_votes\\n- **Q2** - https://leetcode.com/problems/sum-multiples/solutions/3446027/javascript-2652-sum-multiples/?orderBy=most_votes\\n- **Q3** - https://leetcode.com/problems/sliding-subarray-beauty/solutions/3446035/javascript-2653-sliding-subarray-beauty/?orderBy=most_votes\\n- **Q4** - https://leetcode.com/problems/minimum-number-of-operations-to-make-all-array-elements-equal-to-1/solutions/3446411/javascript-2654-minimum-number-of-operations-to-make-all-array-elements-equal-to-1/?orderBy=most_votes\\n\\n---\\n\\n![image.png](https://assets.leetcode.com/users/images/37970e7b-b559-4aa9-834c-e178df5ddaa7_1682232917.7638698.png)\\n\\n---\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minOperations = function (a) {\\n    let nori = a.length; // n original length of array\\n\\n    // edge case 1 - check if only 1 unique element exist, and that element is 1 => all ones\\n    let set = new Set(a);\\n    if (set.size === 1)\\n        if (a[0] === 1) {\\n            return 0;\\n        }\\n\\n    // edge case 2 - check if some ones exist - count ones if exist\\n    let ones = 0;\\n    for (let i = 0; i < nori; i++)\\n        if (a[i] === 1) {\\n            ones++;\\n        }\\n    if (ones) {\\n        return nori - ones;\\n    }\\n\\n    // main work - find gcds and repeatedly replace array a & repeat\\n    let cc = 0;\\n    while (a.length) {\\n        let n = a.length;\\n        let a2 = [];\\n        for (let i = 0; i < n - 1; i++) {\\n            let g = gcd(a[i], a[i + 1]);\\n            if (g === 1) {\\n                return nori + cc; // when one can become 1, others can as well\\n            }\\n            a2.push(g);\\n        }\\n        a = a2;\\n        cc++;\\n    }\\n    return -1;\\n\\n    function gcd(a, b) {\\n        if (b == 0) return a;\\n        return gcd(b, a % b);\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3446266,
                "title": "video-explanation-includes-all-the-proofs",
                "content": "# Explanation\\n\\nhttps://youtu.be/ituCxE_aoyE\\n\\n[Click here if the preview above doesn\\'t works](https://youtu.be/ituCxE_aoyE)\\n\\n# Code\\n```\\nclass Solution {    \\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        int full_gcd = 0;\\n        for (auto i : nums) full_gcd = __gcd (full_gcd, i);\\n        if (full_gcd != 1) return -1;\\n        \\n        int ones = 0;\\n        for (auto i : nums) \\n            if (i == 1) ones ++;\\n        \\n        if (ones > 0) return (n - ones);\\n        \\n        vector<int> steps_to_1 (n, n);\\n        for (int j = 0; j < n; j ++) {\\n            int& steps = steps_to_1[j];\\n            \\n            for (int l = 0; l <= j; l ++) {\\n                for (int r = j; r < n; r ++) {\\n                    int gcd = 0;\\n                    for (int i = l; i <= r; i ++) gcd = __gcd (gcd, nums[i]);\\n                    \\n                    if (gcd == 1)\\n                        steps = min (steps, r-l);\\n                }\\n            }\\n        }\\n        \\n        int min_steps_to_1 = n;\\n        for (auto i : steps_to_1) min_steps_to_1 = min (min_steps_to_1, i);\\n        \\n        return (min_steps_to_1 + n-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {    \\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        int full_gcd = 0;\\n        for (auto i : nums) full_gcd = __gcd (full_gcd, i);\\n        if (full_gcd != 1) return -1;\\n        \\n        int ones = 0;\\n        for (auto i : nums) \\n            if (i == 1) ones ++;\\n        \\n        if (ones > 0) return (n - ones);\\n        \\n        vector<int> steps_to_1 (n, n);\\n        for (int j = 0; j < n; j ++) {\\n            int& steps = steps_to_1[j];\\n            \\n            for (int l = 0; l <= j; l ++) {\\n                for (int r = j; r < n; r ++) {\\n                    int gcd = 0;\\n                    for (int i = l; i <= r; i ++) gcd = __gcd (gcd, nums[i]);\\n                    \\n                    if (gcd == 1)\\n                        steps = min (steps, r-l);\\n                }\\n            }\\n        }\\n        \\n        int min_steps_to_1 = n;\\n        for (auto i : steps_to_1) min_steps_to_1 = min (min_steps_to_1, i);\\n        \\n        return (min_steps_to_1 + n-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446118,
                "title": "easy-to-understand-python-interview-solution",
                "content": "# Intuition\\nIdea: GCD of two numbers will be 1 only if:-\\n    1. Either of two number is 1.\\n    2. They don\\'t have any common factor.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n\\n1. Check for count of 1\\'s in `nums`. If there are ones present in this `nums` then number of `operations = n - count(ones)`.\\n\\n2. Now, if there is no 1\\'s in `nums`, then just try to make 1 by calculating gcd for `nums[i]` and `nums[i+1]`. If we found gcd = 1 then, number of `operations = number of operations to achieve gcd=1` + `length of all non 1\\'s element in list (len(nums)-1)`.\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1) # not including for gcd recursion.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def gcd(self, a, b):\\n        if b == 0:\\n            return abs(a)\\n        else:\\n            return self.gcd(b, a%b)\\n        \\n    def minOperations(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        ones = nums.count(1)\\n        if ones: return n - ones\\n        ans = float(\"inf\")\\n        \\n        for l in range(n):\\n            g = nums[l]\\n            for r in range(l+1, n):\\n                g = self.gcd(g, nums[r])\\n                if g == 1:\\n                    ans = min(ans, r-l + (n-1))\\n                    break\\n        \\n        return ans if ans != float(\"inf\") else -1\\n```\\n\\n\\n## Note:\\n    - If you got something to learn from this solution please upvote, So I feel motivated doing same.\\n    - Also let me know if there is something better, I am happy to know that too.\\n\\n\\n# ********** Keep Learning @ Keep Coding **********",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def gcd(self, a, b):\\n        if b == 0:\\n            return abs(a)\\n        else:\\n            return self.gcd(b, a%b)\\n        \\n    def minOperations(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        ones = nums.count(1)\\n        if ones: return n - ones\\n        ans = float(\"inf\")\\n        \\n        for l in range(n):\\n            g = nums[l]\\n            for r in range(l+1, n):\\n                g = self.gcd(g, nums[r])\\n                if g == 1:\\n                    ans = min(ans, r-l + (n-1))\\n                    break\\n        \\n        return ans if ans != float(\"inf\") else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445772,
                "title": "cpp-simple-solution-with-explanation",
                "content": "# Description\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nYou are given a 0-indexed array nums consisiting of positive integers. You can do the following operation on the array any number of times:\\n\\nSelect an index i such that 0 <= i < n - 1 and replace either of nums[i] or nums[i+1] with their gcd value.\\nReturn the minimum number of operations to make all elements of nums equal to 1. If it is impossible, return -1.\\n\\nThe gcd of two integers is the greatest common divisor of the two integers.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nFirst, the code checks if there are any 1\\'s in the input vector. If there are, it returns the number of elements in the input vector that are not equal to 1, as we can make all the elements equal to 1 by repeatedly adding 1 to any non-1 element.\\n\\nIf there are no 1\\'s in the input vector, the code iterates through each pair of elements in the input vector and takes the GCD of each pair. If the resulting GCD ever becomes 1, the number of operations required to make all the elements equal is calculated as the difference between the indices of the two elements that produced the GCD of 1. The minimum number of operations required to make all the elements equal is updated as the minimum of its current value and the number of operations required for the current pair of elements. If it is not possible to make all the elements of the input vector equal, the function returns -1.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this C++ code is O(n^2 log(maximum value in the input vector)), where n is the size of the input vector. The nested loop iterates over all pairs of elements in the input vector and the __gcd function takes log(maximum value in the input vector) time to calculate the GCD of two numbers.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of this code is O(1) as it only uses a constant amount of extra space for storing some integer variables. However, note that the __gcd function itself might use additional memory, which is not accounted for in the space complexity analysis of this code.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    static int minOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        int cntOnes = 0;\\n        for(int i=0; i<n; i++) {\\n            if(nums[i] == 1) cntOnes++;\\n        }\\n\\n        if(cntOnes > 0) return n - cntOnes;\\n\\n        int minOps = INT_MAX;\\n        for(int i=0; i<n; i++) {\\n            int num = nums[i];\\n            for(int j=i+1; j<n; j++) {\\n                num = __gcd(num, nums[j]);\\n                if(num == 1) {\\n                    minOps = min(minOps, j-i);\\n                    break;\\n                }\\n            }\\n            if(num != 1) break;\\n        }\\n        return (minOps == INT_MAX) ? -1 : n-1+minOps;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static int minOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        int cntOnes = 0;\\n        for(int i=0; i<n; i++) {\\n            if(nums[i] == 1) cntOnes++;\\n        }\\n\\n        if(cntOnes > 0) return n - cntOnes;\\n\\n        int minOps = INT_MAX;\\n        for(int i=0; i<n; i++) {\\n            int num = nums[i];\\n            for(int j=i+1; j<n; j++) {\\n                num = __gcd(num, nums[j]);\\n                if(num == 1) {\\n                    minOps = min(minOps, j-i);\\n                    break;\\n                }\\n            }\\n            if(num != 1) break;\\n        }\\n        return (minOps == INT_MAX) ? -1 : n-1+minOps;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3716673,
                "title": "easy-c-solution-simple-approach-with-explanation-beats-100-in-memory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- We need to find **one element with value 1** and then the answer is `nums.size()-1`. If there are **k elements with value 1** then answer is `nums.size()-k`. This is because the **gcd of any value with 1 will be 1** and thus we can perform gcd of the element with 1 with its neighbouring elements to get every element equal to 1. \\n- If array does not have element with value 1 then perform gcd of adjacent elements from the start and `find the pair of elements with gcd = 1`. Starting from there, then we just need to follow the similar process as the earlier case when any element has value 1.  \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n=nums.size();\\n        int c=count(nums.begin(),nums.end(),1);     // if there is at least 1. then it\\'s easy!\\n        if(c!=0)    return n-c;\\n        int res=INT_MAX/2;        // just a dummy value\\n        for(int i=0;i<n;i++){\\n            int g=nums[i];\\n            for(int j=i+1;j<n;j++){\\n                g=__gcd(g,nums[j]);\\n                if(g==1){\\n                    res=min(res,j-i+(n-1)); // number of operations to make this element 1+ number of non ones (i.e. n-1) .\\n                    break;\\n                } \\n            }\\n        }\\n        return res==INT_MAX/2?-1:res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n=nums.size();\\n        int c=count(nums.begin(),nums.end(),1);     // if there is at least 1. then it\\'s easy!\\n        if(c!=0)    return n-c;\\n        int res=INT_MAX/2;        // just a dummy value\\n        for(int i=0;i<n;i++){\\n            int g=nums[i];\\n            for(int j=i+1;j<n;j++){\\n                g=__gcd(g,nums[j]);\\n                if(g==1){\\n                    res=min(res,j-i+(n-1)); // number of operations to make this element 1+ number of non ones (i.e. n-1) .\\n                    break;\\n                } \\n            }\\n        }\\n        return res==INT_MAX/2?-1:res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3545325,
                "title": "2654-minimum-number-of-operations-to-make-all-array-elements-equal-to-1-java",
                "content": "```\\nclass Solution {\\n    public int gcd(int a,int b)\\n    {\\n        if(b==0)\\n            return a;\\n        return gcd(b,a%b);\\n    }\\n    public int minOperations(int[] nums) {\\n        int cnt1=0,minsubarray=Integer.MAX_VALUE;\\n        for(int x:nums)\\n            if(x==1)\\n            cnt1++;\\n        \\n        if(cnt1>0)\\n            return nums.length-cnt1;\\n        \\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int curgcd=nums[i];\\n            for(int j=i+1;j<nums.length;j++)\\n            {\\n                curgcd=(gcd(curgcd,nums[j]));\\n                    if(curgcd==1)\\n                    {\\n                        minsubarray=Math.min(minsubarray,j-i);\\n                        break;\\n                    }   \\n            }\\n        }\\n        if(minsubarray!=Integer.MAX_VALUE)\\n            return minsubarray+nums.length-1;\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int gcd(int a,int b)\\n    {\\n        if(b==0)\\n            return a;\\n        return gcd(b,a%b);\\n    }\\n    public int minOperations(int[] nums) {\\n        int cnt1=0,minsubarray=Integer.MAX_VALUE;\\n        for(int x:nums)\\n            if(x==1)\\n            cnt1++;\\n        \\n        if(cnt1>0)\\n            return nums.length-cnt1;\\n        \\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int curgcd=nums[i];\\n            for(int j=i+1;j<nums.length;j++)\\n            {\\n                curgcd=(gcd(curgcd,nums[j]));\\n                    if(curgcd==1)\\n                    {\\n                        minsubarray=Math.min(minsubarray,j-i);\\n                        break;\\n                    }   \\n            }\\n        }\\n        if(minsubarray!=Integer.MAX_VALUE)\\n            return minsubarray+nums.length-1;\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3489076,
                "title": "c-brute-force",
                "content": "## Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int gcd=nums[0];\\n        for (int i=1; i<nums.size(); i++)gcd= __gcd(gcd,nums[i]);\\n        if (gcd!=1)return -1;\\n        if (count(nums.begin(),nums.end(),1)>0){\\n            return (nums.size()-count(nums.begin(),nums.end(),1));\\n        }\\n        int cnt=INT_MAX;\\n        for (int i=0; i<nums.size(); i++){\\n            int curr= nums[i];\\n            for (int j=i+1; j<nums.size(); j++){\\n                curr= __gcd(curr,nums[j]);\\n                if (curr==1){\\n                    cnt= min(cnt,j-i-1);\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return nums.size()+cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Number Theory"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int gcd=nums[0];\\n        for (int i=1; i<nums.size(); i++)gcd= __gcd(gcd,nums[i]);\\n        if (gcd!=1)return -1;\\n        if (count(nums.begin(),nums.end(),1)>0){\\n            return (nums.size()-count(nums.begin(),nums.end(),1));\\n        }\\n        int cnt=INT_MAX;\\n        for (int i=0; i<nums.size(); i++){\\n            int curr= nums[i];\\n            for (int j=i+1; j<nums.size(); j++){\\n                curr= __gcd(curr,nums[j]);\\n                if (curr==1){\\n                    cnt= min(cnt,j-i-1);\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return nums.size()+cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3476382,
                "title": "easiest-solution-c",
                "content": "```\\n int minOperations(vector<int>& nums) {\\n        \\n        int value = 0, n = nums.size(),ones = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            value = __gcd(value, nums[i]);\\n            if(nums[i] == 1)\\n                ones++;\\n        }\\n        //if the gcd of the total array is not equal to 1 then not possible\\n        if(value != 1)\\n            return -1;\\n        \\n        //gcd of 1 with any number is 1\\n        if(ones > 0)\\n            return n-ones;\\n        \\n        int min_size = 1e9;\\n        \\n        for(int i = 0; i<n; i++)\\n        {\\n            //generating all subsets\\n            for(int j = i; j<n; j++)\\n            {\\n                \\n                int val = 0;\\n                for(int k = i; k <= j; k++)\\n                {\\n                    val = __gcd(val, nums[k]);\\n                    \\n                    if(val == 1)\\n                    {\\n                        //minimum sized subarray whose gcd is 1\\n                         min_size = min(min_size, j-i+1);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        // step= minimum subarray -1, and the rest of the elements\\n        return min_size - 1 + n-1;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\n int minOperations(vector<int>& nums) {\\n        \\n        int value = 0, n = nums.size(),ones = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            value = __gcd(value, nums[i]);\\n            if(nums[i] == 1)\\n                ones++;\\n        }\\n        //if the gcd of the total array is not equal to 1 then not possible\\n        if(value != 1)\\n            return -1;\\n        \\n        //gcd of 1 with any number is 1\\n        if(ones > 0)\\n            return n-ones;\\n        \\n        int min_size = 1e9;\\n        \\n        for(int i = 0; i<n; i++)\\n        {\\n            //generating all subsets\\n            for(int j = i; j<n; j++)\\n            {\\n                \\n                int val = 0;\\n                for(int k = i; k <= j; k++)\\n                {\\n                    val = __gcd(val, nums[k]);\\n                    \\n                    if(val == 1)\\n                    {\\n                        //minimum sized subarray whose gcd is 1\\n                         min_size = min(min_size, j-i+1);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        // step= minimum subarray -1, and the rest of the elements\\n        return min_size - 1 + n-1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3476258,
                "title": "python3-solution",
                "content": "# Code\\n```\\nfrom math import gcd\\nclass Solution: \\n    def getGCDs(self, nums):\\n        gcdArr = []\\n        for i in range(len(nums) - 1):\\n            gcdArr.append(gcd(nums[i], nums[i + 1])) \\n        return gcdArr\\n    def minOperations(self, nums):\\n        if 1 in nums: return len(nums) - nums.count(1)\\n        steps = 0\\n        gcdArr = self.getGCDs(nums)\\n        while len(gcdArr) >= 1 and 1 not in gcdArr:\\n            gcdArr = self.getGCDs(gcdArr)\\n            steps += 1\\n        if 1 not in gcdArr: return -1\\n        else: steps += 1\\n        return steps + len(nums) - 1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom math import gcd\\nclass Solution: \\n    def getGCDs(self, nums):\\n        gcdArr = []\\n        for i in range(len(nums) - 1):\\n            gcdArr.append(gcd(nums[i], nums[i + 1])) \\n        return gcdArr\\n    def minOperations(self, nums):\\n        if 1 in nums: return len(nums) - nums.count(1)\\n        steps = 0\\n        gcdArr = self.getGCDs(nums)\\n        while len(gcdArr) >= 1 and 1 not in gcdArr:\\n            gcdArr = self.getGCDs(gcdArr)\\n            steps += 1\\n        if 1 not in gcdArr: return -1\\n        else: steps += 1\\n        return steps + len(nums) - 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3464767,
                "title": "a-few-solutions",
                "content": "**Case 1:** If *any* value of the input array `A` is equal to `1`, then each adjacent value (*not* equal to `1`) can be transformed into `1` via one operation, ie. `gcd(1, x) == 1` for any `x`.  Let `ok` be the count of elements equal to `1`, if `ok` exceeds `0` then return `N - ok`, ie. the count of elements *not* equal to `1`.\\n\\n**Case 2:** Otherwise let `size` be the subarray size `i..j` inclusive for which `gcd(A[i..j]) == 1`, then the minimum operations to transform a single element of the subarray to the value `1` via the gcd function `f` is `size - 1`, ie. we can think of the gcd function `f` as an \"edge\" between each adjacent pair of indices (and each \"edge\" costs one operation).  After accounting for the minimum operations to transform a single element to the value `1`, then we need an additional `N - 1` operations to transform all remaining values *not* equal to `1` to the value `1`, ie. apply **Case 1** given `ok == 1`.\\n\\n* Note: if the `gcd` of all values of the input array `A` exceeds `1`, then we return `-1`, ie. we *cannot* transform *any* element to the value `1`\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun minOperations(A: IntArray, INF: Int = (1e9 + 7).toInt()): Int {\\n        var N = A.size\\n        var ok = A.filter{ it == 1 }.size\\n        if (0 < ok)\\n            return N - ok\\n        var (best, size) = Pair(INF, INF)\\n        fun f(a: Int, b: Int): Int { return if (b == 0) a else f(b, a % b) }\\n        for (i in 0 until N) {\\n            var gcd = A[i]\\n            for (j in i + 1 until N) {\\n                gcd = f(gcd, A[j])\\n                if (gcd == 1) {\\n                    size = j - i + 1\\n                    best = Math.min(best, size - 1)\\n                    break\\n                }\\n            }\\n        }\\n        return if (best != INF) best + N - 1 else -1\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet minOperations = (A, N = A.length) => {\\n    let ok = A.filter(x => x == 1).length;\\n    if (ok)\\n        return N - ok;\\n    let [best, size] = [Infinity, Infinity];\\n    let f = (a, b) => !b ? a : f(b, a % b);\\n    for (let i = 0; i < N; ++i) {\\n        let gcd = A[i];\\n        for (let j = i + 1; j < N; ++j) {\\n            gcd = f(gcd, A[j]);\\n            if (gcd == 1) {\\n                size = j - i + 1;\\n                best = Math.min(best, size - 1);\\n                break;\\n            }\\n        }\\n    }\\n    return best != Infinity ? best + N - 1 : -1;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def minOperations(self, A: List[int]) -> int:\\n        N = len(A)\\n        ok = len([x for x in A if x == 1])\\n        if ok:\\n            return N - ok\\n        best, size = float(\\'inf\\'), float(\\'inf\\')\\n        f = lambda a, b: a if not b else f(b, a % b)\\n        for i in range(N):\\n            gcd = A[i]\\n            for j in range(i + 1, N):\\n                gcd = f(gcd, A[j])\\n                if gcd == 1:\\n                    size = j - i + 1\\n                    best = min(best, size - 1)\\n                    break\\n        return best + N - 1 if best != float(\\'inf\\') else -1\\n```\\n\\n*Rust*\\n```\\nuse std::cmp::min;\\nimpl Solution {\\n    pub fn min_operations(A: Vec<i32>) -> i32 {\\n        let INF = 1e9 as usize + 1;\\n        let N = A.len();\\n        let ok = A.iter().filter(|&x| *x == 1).collect::<Vec<&i32>>().len();\\n        if 0 < ok {\\n            return (N - ok) as i32;\\n        }\\n        let (mut best, mut size) = (INF, INF);\\n        fn f(a: i32, b: i32) -> i32 { if b == 0 { a } else { f(b, a % b) } }\\n        for i in 0..N {\\n            let mut gcd = A[i];\\n            for j in i + 1..N {\\n                gcd = f(gcd, A[j]);\\n                if gcd == 1 {\\n                    size = j - i + 1;\\n                    best = min(best, size - 1);\\n                    break;\\n                }\\n            }\\n        }\\n        if best != INF { (best + N - 1) as i32 } else { -1 }\\n    }\\n}\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using fun = function<int(int, int)>;\\n    int minOperations(VI& A, int INF = 1e9 + 7) {\\n        auto N = A.size();\\n        auto ok = count_if(A.begin(), A.end(), [](auto x) { return x == 1; });\\n        if (ok)\\n            return N - ok;\\n        auto [best, size] = make_pair(INF, INF);\\n        fun f = [&](auto a, auto b) { return !b ? a : f(b, a % b); };\\n        for (auto i{ 0 }; i < N; ++i) {\\n            auto gcd = A[i];\\n            for (auto j{ i + 1 }; j < N; ++j) {\\n                gcd = f(gcd, A[j]);\\n                if (gcd == 1) {\\n                    size = j - i + 1;\\n                    best = min(best, size - 1);\\n                    break;\\n                }\\n            }\\n        }\\n        return best != INF ? best + N - 1 : -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun minOperations(A: IntArray, INF: Int = (1e9 + 7).toInt()): Int {\\n        var N = A.size\\n        var ok = A.filter{ it == 1 }.size\\n        if (0 < ok)\\n            return N - ok\\n        var (best, size) = Pair(INF, INF)\\n        fun f(a: Int, b: Int): Int { return if (b == 0) a else f(b, a % b) }\\n        for (i in 0 until N) {\\n            var gcd = A[i]\\n            for (j in i + 1 until N) {\\n                gcd = f(gcd, A[j])\\n                if (gcd == 1) {\\n                    size = j - i + 1\\n                    best = Math.min(best, size - 1)\\n                    break\\n                }\\n            }\\n        }\\n        return if (best != INF) best + N - 1 else -1\\n    }\\n}\\n```\n```\\nlet minOperations = (A, N = A.length) => {\\n    let ok = A.filter(x => x == 1).length;\\n    if (ok)\\n        return N - ok;\\n    let [best, size] = [Infinity, Infinity];\\n    let f = (a, b) => !b ? a : f(b, a % b);\\n    for (let i = 0; i < N; ++i) {\\n        let gcd = A[i];\\n        for (let j = i + 1; j < N; ++j) {\\n            gcd = f(gcd, A[j]);\\n            if (gcd == 1) {\\n                size = j - i + 1;\\n                best = Math.min(best, size - 1);\\n                break;\\n            }\\n        }\\n    }\\n    return best != Infinity ? best + N - 1 : -1;\\n};\\n```\n```\\nclass Solution:\\n    def minOperations(self, A: List[int]) -> int:\\n        N = len(A)\\n        ok = len([x for x in A if x == 1])\\n        if ok:\\n            return N - ok\\n        best, size = float(\\'inf\\'), float(\\'inf\\')\\n        f = lambda a, b: a if not b else f(b, a % b)\\n        for i in range(N):\\n            gcd = A[i]\\n            for j in range(i + 1, N):\\n                gcd = f(gcd, A[j])\\n                if gcd == 1:\\n                    size = j - i + 1\\n                    best = min(best, size - 1)\\n                    break\\n        return best + N - 1 if best != float(\\'inf\\') else -1\\n```\n```\\nuse std::cmp::min;\\nimpl Solution {\\n    pub fn min_operations(A: Vec<i32>) -> i32 {\\n        let INF = 1e9 as usize + 1;\\n        let N = A.len();\\n        let ok = A.iter().filter(|&x| *x == 1).collect::<Vec<&i32>>().len();\\n        if 0 < ok {\\n            return (N - ok) as i32;\\n        }\\n        let (mut best, mut size) = (INF, INF);\\n        fn f(a: i32, b: i32) -> i32 { if b == 0 { a } else { f(b, a % b) } }\\n        for i in 0..N {\\n            let mut gcd = A[i];\\n            for j in i + 1..N {\\n                gcd = f(gcd, A[j]);\\n                if gcd == 1 {\\n                    size = j - i + 1;\\n                    best = min(best, size - 1);\\n                    break;\\n                }\\n            }\\n        }\\n        if best != INF { (best + N - 1) as i32 } else { -1 }\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using fun = function<int(int, int)>;\\n    int minOperations(VI& A, int INF = 1e9 + 7) {\\n        auto N = A.size();\\n        auto ok = count_if(A.begin(), A.end(), [](auto x) { return x == 1; });\\n        if (ok)\\n            return N - ok;\\n        auto [best, size] = make_pair(INF, INF);\\n        fun f = [&](auto a, auto b) { return !b ? a : f(b, a % b); };\\n        for (auto i{ 0 }; i < N; ++i) {\\n            auto gcd = A[i];\\n            for (auto j{ i + 1 }; j < N; ++j) {\\n                gcd = f(gcd, A[j]);\\n                if (gcd == 1) {\\n                    size = j - i + 1;\\n                    best = min(best, size - 1);\\n                    break;\\n                }\\n            }\\n        }\\n        return best != INF ? best + N - 1 : -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3457695,
                "title": "brute-force-simple-c-smallest-subarray-with-gcd-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe just have to find the smallest subarray with GCD 1. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe will make one 1 with that subarray with cost of length - 1.\\nThe rest n-1 elements will be changed to 1 with n-1 operations.   \\n\\n# Complexity\\n- Time complexity:O(N^3)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int minOperations(vector<int>& nums) {\\n        int gcd = nums[0];\\n        int one = 0;\\n        for(auto x: nums) \\n        {\\n            gcd = __gcd(gcd,x);\\n            one += (x==1);\\n        }\\n        if(gcd>1) return -1;\\n        int n = nums.size();\\n        if(one) return n-one;\\n        for(int len = 1;len<=n;len++)\\n        {\\n            for(int i=0;i<=n-len;i++)\\n            {\\n                int curGCD = nums[i];\\n                for(int j=0;j<len;j++)  // for current window of [i, i+len]\\n                    curGCD = __gcd(curGCD,nums[i+j]);\\n                \\n                if(curGCD == 1)\\n                    return n-1 + len-1;\\n            }\\n        }\\n        return n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int minOperations(vector<int>& nums) {\\n        int gcd = nums[0];\\n        int one = 0;\\n        for(auto x: nums) \\n        {\\n            gcd = __gcd(gcd,x);\\n            one += (x==1);\\n        }\\n        if(gcd>1) return -1;\\n        int n = nums.size();\\n        if(one) return n-one;\\n        for(int len = 1;len<=n;len++)\\n        {\\n            for(int i=0;i<=n-len;i++)\\n            {\\n                int curGCD = nums[i];\\n                for(int j=0;j<len;j++)  // for current window of [i, i+len]\\n                    curGCD = __gcd(curGCD,nums[i+j]);\\n                \\n                if(curGCD == 1)\\n                    return n-1 + len-1;\\n            }\\n        }\\n        return n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3455938,
                "title": "explained-with-comments-easy-to-understand-soln",
                "content": "```\\n    //Case 1: if nums has 1 --> number of operations = no. of non 1s (1 operations for each)\\n    //Case 2: if gcd of entire nums != 1 --> not possible --> -1\\n    //Case 3: we want to make atleast 1 1 fastest(with least no of operations)\\n    // eg. [2,6,3,4] -- gcd(2,3,6) == 1 & gcd(3,4)==1 but 3,4 is faster\\n    // so basically we need to find smallest subarray with gcd 1\\n    \\n    //Constraints are small(50) we check for each subarray \\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        int ones = count(nums.begin(),nums.end(),1);\\n        if(ones>0)\\n            return n - ones; //case 1\\n        //case3\\n        int minLength = INT_MAX;\\n        for(int i=0;i<n;i++)\\n        {\\n            int hcf = nums[i];\\n            for(int j=i;j<n;j++)\\n            {\\n                hcf = __gcd(hcf,nums[j]);\\n                if(hcf==1)\\n                {\\n                    minLength = min(minLength, j-i+1);\\n                    break; //found a subarray starting from i which has gcd = 1; we dont need to keep adding more elements --> gcd will be 1 but length increases and we need smallest subarray\\n                }    \\n            }\\n        }\\n        //case2\\n        if(minLength == INT_MAX) return -1;\\n        return (minLength-1) + n-1;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\n    //Case 1: if nums has 1 --> number of operations = no. of non 1s (1 operations for each)\\n    //Case 2: if gcd of entire nums != 1 --> not possible --> -1\\n    //Case 3: we want to make atleast 1 1 fastest(with least no of operations)\\n    // eg. [2,6,3,4] -- gcd(2,3,6) == 1 & gcd(3,4)==1 but 3,4 is faster\\n    // so basically we need to find smallest subarray with gcd 1\\n    \\n    //Constraints are small(50) we check for each subarray \\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        int ones = count(nums.begin(),nums.end(),1);\\n        if(ones>0)\\n            return n - ones; //case 1\\n        //case3\\n        int minLength = INT_MAX;\\n        for(int i=0;i<n;i++)\\n        {\\n            int hcf = nums[i];\\n            for(int j=i;j<n;j++)\\n            {\\n                hcf = __gcd(hcf,nums[j]);\\n                if(hcf==1)\\n                {\\n                    minLength = min(minLength, j-i+1);\\n                    break; //found a subarray starting from i which has gcd = 1; we dont need to keep adding more elements --> gcd will be 1 but length increases and we need smallest subarray\\n                }    \\n            }\\n        }\\n        //case2\\n        if(minLength == INT_MAX) return -1;\\n        return (minLength-1) + n-1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3455198,
                "title": "very-short-solution",
                "content": "\\n# Code\\n```\\ndef minOperations(self, nums: List[int]) -> int:\\n    n = len(nums)\\n    if 1 in nums:\\n        return n - sum(int(x==1) for x in nums)\\n    for ret in range(n-1):\\n        for i in range(n-1-ret):\\n            nums[i] = gcd(nums[i], nums[i+1])\\n            if nums[i] == 1:\\n                return ret+n\\n    return -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef minOperations(self, nums: List[int]) -> int:\\n    n = len(nums)\\n    if 1 in nums:\\n        return n - sum(int(x==1) for x in nums)\\n    for ret in range(n-1):\\n        for i in range(n-1-ret):\\n            nums[i] = gcd(nums[i], nums[i+1])\\n            if nums[i] == 1:\\n                return ret+n\\n    return -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3454051,
                "title": "c-brute-force-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:$$O(n^2)$$\\n\\n- Space complexity:$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        if(count(nums.begin(), nums.end(), 1)){\\n            return nums.size()-count(nums.begin(), nums.end(), 1);\\n        }\\n        int cnt=INT_MAX;\\n        for(int i=0; i<nums.size(); i++){\\n            int val=nums[i];\\n            for(int j=i+1; j<nums.size(); j++){\\n                val=__gcd(val, nums[j]);\\n                if(val==1){\\n                    if(j+nums.size()-1-i<cnt){\\n                        cnt=j+nums.size()-1-i;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        if(cnt==INT_MAX){\\n            return -1;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        if(count(nums.begin(), nums.end(), 1)){\\n            return nums.size()-count(nums.begin(), nums.end(), 1);\\n        }\\n        int cnt=INT_MAX;\\n        for(int i=0; i<nums.size(); i++){\\n            int val=nums[i];\\n            for(int j=i+1; j<nums.size(); j++){\\n                val=__gcd(val, nums[j]);\\n                if(val==1){\\n                    if(j+nums.size()-1-i<cnt){\\n                        cnt=j+nums.size()-1-i;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        if(cnt==INT_MAX){\\n            return -1;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3451672,
                "title": "brute-force",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n = size(nums);\\n        int gcd = 0,one = 0;\\n        for(int&e: nums){\\n            gcd = __gcd(gcd,e);\\n            if(e == 1) one++;\\n        }\\n        if(gcd != 1) return -1;\\n        if(one) return n-one;\\n        int mn=1e9;\\n        for(int i=0; i<n; ++i){\\n            gcd = nums[i];\\n            int ct = 0;\\n            for(int j=i+1; j<n; ++j){\\n                gcd = __gcd(gcd,nums[j]);\\n                ct++;\\n                if(gcd == 1){\\n                    mn = min(mn,ct);\\n                    break;\\n                }\\n            }\\n        }\\n        return n+mn-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n = size(nums);\\n        int gcd = 0,one = 0;\\n        for(int&e: nums){\\n            gcd = __gcd(gcd,e);\\n            if(e == 1) one++;\\n        }\\n        if(gcd != 1) return -1;\\n        if(one) return n-one;\\n        int mn=1e9;\\n        for(int i=0; i<n; ++i){\\n            gcd = nums[i];\\n            int ct = 0;\\n            for(int j=i+1; j<n; ++j){\\n                gcd = __gcd(gcd,nums[j]);\\n                ct++;\\n                if(gcd == 1){\\n                    mn = min(mn,ct);\\n                    break;\\n                }\\n            }\\n        }\\n        return n+mn-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3449208,
                "title": "beats-90-cpp-sol",
                "content": "# Upvote if you liked the solution \\uD83E\\uDD79\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n\\n        // finding the size of the nums\\n        int n = nums.size();\\n\\n        // To create all the no of nums equal to 1, we need one number in nums to be equal to \\'1\\' \\n        // coz the gcd of 1 equal to 1\\n\\n        // if \\'1\\' is already present in the nums then count the no of \\'1\\'\\n        int oneCount = count(nums.begin(), nums.end(), 1);\\n\\n        // number of operation to make all other no equal to one will be\\n        if(oneCount > 0){\\n            return n-oneCount;\\n        }\\n\\n        int len = INT_MAX;\\n        for(int i = 0; i<n; i++){\\n            int g = nums[i];\\n            for(int j = i+1; j<n; j++){\\n                g = gcd(g, nums[j]);\\n                if(g == 1){\\n                    len = min(len, j-i);\\n                }\\n            }\\n        }\\n\\n        if(len == INT_MAX){\\n            return -1;\\n        }\\n\\n        // len : no of operations to make a no equal to 1\\n        // n-1 : no of opeartion to make remaining all other element equal to one\\n        // total  = len + n-1\\n\\n        return len + (n-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n\\n        // finding the size of the nums\\n        int n = nums.size();\\n\\n        // To create all the no of nums equal to 1, we need one number in nums to be equal to \\'1\\' \\n        // coz the gcd of 1 equal to 1\\n\\n        // if \\'1\\' is already present in the nums then count the no of \\'1\\'\\n        int oneCount = count(nums.begin(), nums.end(), 1);\\n\\n        // number of operation to make all other no equal to one will be\\n        if(oneCount > 0){\\n            return n-oneCount;\\n        }\\n\\n        int len = INT_MAX;\\n        for(int i = 0; i<n; i++){\\n            int g = nums[i];\\n            for(int j = i+1; j<n; j++){\\n                g = gcd(g, nums[j]);\\n                if(g == 1){\\n                    len = min(len, j-i);\\n                }\\n            }\\n        }\\n\\n        if(len == INT_MAX){\\n            return -1;\\n        }\\n\\n        // len : no of operations to make a no equal to 1\\n        // n-1 : no of opeartion to make remaining all other element equal to one\\n        // total  = len + n-1\\n\\n        return len + (n-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446583,
                "title": "short-concise-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size(), nonOnes = 0, mn = 1e9;\\n        for(int i : nums) nonOnes += i != 1;\\n        \\n        for(int i=0; i<n; i++) {\\n            int g = nums[i];\\n            for(int j=i+1; j<n; j++) {\\n                g = __gcd(g, nums[j]);\\n                if(g == 1) mn = min(mn, j - i);\\n            }\\n        }\\n        return mn == 1e9 ? -1 : nonOnes + mn - 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size(), nonOnes = 0, mn = 1e9;\\n        for(int i : nums) nonOnes += i != 1;\\n        \\n        for(int i=0; i<n; i++) {\\n            int g = nums[i];\\n            for(int j=i+1; j<n; j++) {\\n                g = __gcd(g, nums[j]);\\n                if(g == 1) mn = min(mn, j - i);\\n            }\\n        }\\n        return mn == 1e9 ? -1 : nonOnes + mn - 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446195,
                "title": "easy-understandable-code-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        int x = nums[0];\\n        for(int i = 1 ; i < n ; i++){\\n            x = __gcd(x,nums[i]);\\n        }\\n        int one = 0;\\n        for(auto i : nums){\\n            if(i == 1)  one++;\\n        }\\n        if(one > 0) return n-one;\\n        if(x != 1)  return -1;\\n        int cnt = 0;\\n        while(1){\\n            vector<int> v;\\n            for(int i = 0 ; i < n-1; i++){\\n                int t = __gcd(nums[i],nums[i+1]);\\n                if(t == 1){\\n                    return n + cnt;\\n                }\\n                v.push_back(t);\\n            }\\n            cnt++;\\n            nums.resize(nums.size()-1);\\n            nums = v;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```\\n\\n\\nPlease Upvote !!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        int x = nums[0];\\n        for(int i = 1 ; i < n ; i++){\\n            x = __gcd(x,nums[i]);\\n        }\\n        int one = 0;\\n        for(auto i : nums){\\n            if(i == 1)  one++;\\n        }\\n        if(one > 0) return n-one;\\n        if(x != 1)  return -1;\\n        int cnt = 0;\\n        while(1){\\n            vector<int> v;\\n            for(int i = 0 ; i < n-1; i++){\\n                int t = __gcd(nums[i],nums[i+1]);\\n                if(t == 1){\\n                    return n + cnt;\\n                }\\n                v.push_back(t);\\n            }\\n            cnt++;\\n            nums.resize(nums.size()-1);\\n            nums = v;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446170,
                "title": "o-n-n-log-max-element-nums-i-solution",
                "content": "- If 1 exists in the array, it will be optimal to propagate it to non zero indexes\\n- Else create a one in minimum number of operations, in order to do that we will will the smallest subarray with gcd = 1, then propagate it.\\n- If no subarray exist with gcd = 1, return -1.\\n- The solution can be optimised further using segment tree.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Time complexity: O(N * N * log(max_element(nums[i]))) -->\\n    O(N * N * log(max_element(nums[i]))) \\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        map<int,int>m;\\n        int n = nums.size();\\n        for(int i = 0; i < n; i++) m[nums[i]]++;\\n        \\n        // if 1 is present in the array than we will propagate it.\\n        if(m.count(1)) return n - m[1];\\n        int ans = n + 1;\\n        \\n        // finding the smallest subarray with gcd 1.\\n        for(int i = 0; i < n; i++) {\\n            int curr = nums[i];\\n            for(int j = i + 1; j < n; j++) {\\n                curr = __gcd(curr, nums[j]);\\n                if(curr == 1) {\\n                    ans = min(ans, j - i + 1);\\n                    break;\\n                }\\n            }\\n        }\\n    \\n        // if not found return -1.\\n        if(ans == n + 1) return -1;\\n        \\n        // in order to create first 1, we will need ans - 1 operations than n - 1 operations to propagate to complete array.\\n        return ans - 1 + n - 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        map<int,int>m;\\n        int n = nums.size();\\n        for(int i = 0; i < n; i++) m[nums[i]]++;\\n        \\n        // if 1 is present in the array than we will propagate it.\\n        if(m.count(1)) return n - m[1];\\n        int ans = n + 1;\\n        \\n        // finding the smallest subarray with gcd 1.\\n        for(int i = 0; i < n; i++) {\\n            int curr = nums[i];\\n            for(int j = i + 1; j < n; j++) {\\n                curr = __gcd(curr, nums[j]);\\n                if(curr == 1) {\\n                    ans = min(ans, j - i + 1);\\n                    break;\\n                }\\n            }\\n        }\\n    \\n        // if not found return -1.\\n        if(ans == n + 1) return -1;\\n        \\n        // in order to create first 1, we will need ans - 1 operations than n - 1 operations to propagate to complete array.\\n        return ans - 1 + n - 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446029,
                "title": "easy-c-solution-smallest-subarray-with-gcd-1-clean-code",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. If vector contains integer 1 then answer is number of elements not equal to 1\\n2. If the gcd of whole array is not 1 then the answer doesn\\'t exist, return -1\\n3. Find the smallest subarray whose gcd is 1. \\n    - This (length of this subarray - 1) will be the operations required to convert an interger into 1\\n    - Answer would be **d + n - 2** (where d is length of subarray and n is size of vector) \\n\\n# Time Complexity\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n  O(`N * N * log2(M)`) where N is size of vector and M is the max element in the vector\\n\\n# Code\\n```\\nclass Solution\\n{\\npublic:\\n    int minOperations(vector<int> &v)\\n    {\\n        int n = v.size();\\n        bool f = 0;\\n        int gcd = v[0];\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (v[i] == 1) // If vector contains 1\\n            {\\n                int ans = 0;\\n                for (int i = 0; i < n; i++)\\n                {\\n                    if (v[i] != 1) \\n                        ans++;\\n                }// return number of elements not equal to 1\\n                return ans;\\n            }\\n            if (i < n - 1)\\n            {\\n                gcd = __gcd(gcd, v[i + 1]);\\n            }\\n        }\\n        if (gcd != 1) // If GCD of whole vector != 1 then return -1 \\n            return -1;\\n        \\n        int cnt=0;\\n        int ans=1e9;\\n        for (int i = 0; i < n; i++)\\n        {\\n            gcd = v[i];\\n            for (int j = i; j < n - 1; j++)\\n            {\\n                gcd = __gcd(gcd, v[j + 1]);\\n                if(gcd==1)\\n                    ans = min(ans,j-i+n);\\n                // Find minimum value of (d+n-2)\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int minOperations(vector<int> &v)\\n    {\\n        int n = v.size();\\n        bool f = 0;\\n        int gcd = v[0];\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (v[i] == 1) // If vector contains 1\\n            {\\n                int ans = 0;\\n                for (int i = 0; i < n; i++)\\n                {\\n                    if (v[i] != 1) \\n                        ans++;\\n                }// return number of elements not equal to 1\\n                return ans;\\n            }\\n            if (i < n - 1)\\n            {\\n                gcd = __gcd(gcd, v[i + 1]);\\n            }\\n        }\\n        if (gcd != 1) // If GCD of whole vector != 1 then return -1 \\n            return -1;\\n        \\n        int cnt=0;\\n        int ans=1e9;\\n        for (int i = 0; i < n; i++)\\n        {\\n            gcd = v[i];\\n            for (int j = i; j < n - 1; j++)\\n            {\\n                gcd = __gcd(gcd, v[j + 1]);\\n                if(gcd==1)\\n                    ans = min(ans,j-i+n);\\n                // Find minimum value of (d+n-2)\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445955,
                "title": "simple-observation-explained",
                "content": "# Intuition:If there is even a sigle one present we can make all the elemnts one by taking gcd of one with its adjacent elements so return size-cnt of one otherwise try to move in a subarray fashion as soon as you get your gcd equal to one it would mean that now you can make one eleent as one and keep doing this till the loop ends and return the minimum answer,so try to find shortest subarray whose gcd is equal to one.\\n\\n# Complexity\\n- Time complexity:0(n*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity:0(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n=nums.size();\\n        bool f=false;\\n        int cnt=0;\\n        int cnt1=0;\\n        int ans=INT_MAX;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==1)cnt1++;\\n        }\\n        if(cnt1)return n-cnt1;\\n        for(int i=0;i<n;i++){\\n            int g=nums[i];\\n            for(int j=i+1;j<n;j++){\\n                g=__gcd(g,nums[j]);\\n                if(g==1){\\n                    ans=min(ans,j-i+(n-1));\\n                }\\n            }\\n        }\\n        if(ans==INT_MAX)return -1;\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n=nums.size();\\n        bool f=false;\\n        int cnt=0;\\n        int cnt1=0;\\n        int ans=INT_MAX;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==1)cnt1++;\\n        }\\n        if(cnt1)return n-cnt1;\\n        for(int i=0;i<n;i++){\\n            int g=nums[i];\\n            for(int j=i+1;j<n;j++){\\n                g=__gcd(g,nums[j]);\\n                if(g==1){\\n                    ans=min(ans,j-i+(n-1));\\n                }\\n            }\\n        }\\n        if(ans==INT_MAX)return -1;\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445819,
                "title": "c-soutions-explained-line-by-line-easy-to-understand-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nGiven an array of integers, we need to find the minimum number of operations required to make all the elements of the array co-prime (i.e., having gcd equal to 1). An operation involves selecting any two elements of the array and replacing one of them with their gcd.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe first check if the array already contains 1. If yes, then we need not perform any operations since 1 is already co-prime with all the other elements. Otherwise, we loop through the array and perform gcd operations between each pair of elements starting from the current element and moving forward. We keep track of the minimum number of operations required to make the elements co-prime.\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this algorithm is O(n^2 * log(max(nums))) since we perform gcd operations between each pair of elements in the array, and the time complexity of gcd operation is log(max(nums)).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of this algorithm is O(1) since we use only a few variables to keep track of the minimum number of operations and the count of 1\\'s in the array.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        \\n        int numOnes = 0, minOps = INT_MAX;\\n        \\n        // Count the number of ones in the array\\n        for(int& num : nums){\\n            if(num == 1)\\n                numOnes++;\\n        }\\n        \\n        // If there are ones in the array, return the number of non-one elements\\n        if(numOnes != 0){\\n            return nums.size() - numOnes;\\n        }\\n        \\n        // Check all subarrays for gcd 1 and find the smallest subarray\\n        for(int i = 0; i < nums.size(); i++){\\n            int gcdVal = nums[i];\\n            for(int j = i + 1; j < nums.size(); j++){\\n                gcdVal = gcd(gcdVal, nums[j]);\\n                if(gcdVal == 1){\\n                    minOps = min(minOps, j - i);\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        // If no subarray with gcd 1 is found, return -1\\n        return minOps == INT_MAX ? -1 : nums.size() + minOps - 1;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        \\n        int numOnes = 0, minOps = INT_MAX;\\n        \\n        // Count the number of ones in the array\\n        for(int& num : nums){\\n            if(num == 1)\\n                numOnes++;\\n        }\\n        \\n        // If there are ones in the array, return the number of non-one elements\\n        if(numOnes != 0){\\n            return nums.size() - numOnes;\\n        }\\n        \\n        // Check all subarrays for gcd 1 and find the smallest subarray\\n        for(int i = 0; i < nums.size(); i++){\\n            int gcdVal = nums[i];\\n            for(int j = i + 1; j < nums.size(); j++){\\n                gcdVal = gcd(gcdVal, nums[j]);\\n                if(gcdVal == 1){\\n                    minOps = min(minOps, j - i);\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        // If no subarray with gcd 1 is found, return -1\\n        return minOps == INT_MAX ? -1 : nums.size() + minOps - 1;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445808,
                "title": "o-n-2-greedy-brute-force",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        int gcd = nums[0];\\n        for(int i = 0; i < n; i++) gcd = __gcd(gcd, nums[i]);\\n        if(gcd > 1) return -1;\\n        \\n        int minOp = INT_MAX;\\n        for(int i = 0; i < n; i++){\\n            gcd = nums[i];\\n            for(int j = i; j < n; j++){\\n                gcd = __gcd(gcd, nums[j]);\\n                if(gcd == 1){\\n                    minOp = min(minOp, (j - i));\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        if(minOp == 0) return n - count(nums.begin(), nums.end() , 1);\\n        return minOp + n - 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        int gcd = nums[0];\\n        for(int i = 0; i < n; i++) gcd = __gcd(gcd, nums[i]);\\n        if(gcd > 1) return -1;\\n        \\n        int minOp = INT_MAX;\\n        for(int i = 0; i < n; i++){\\n            gcd = nums[i];\\n            for(int j = i; j < n; j++){\\n                gcd = __gcd(gcd, nums[j]);\\n                if(gcd == 1){\\n                    minOp = min(minOp, (j - i));\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        if(minOp == 0) return n - count(nums.begin(), nums.end() , 1);\\n        return minOp + n - 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445706,
                "title": "minimum-steps-to-make-any-one-element-equal-to-1",
                "content": "```\\nclass Solution:\\n    def gcd(self, a, b):\\n        while b:\\n            a, b = b, a % b\\n        return a\\n    \\n    def minOperations(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        if nums.count(1) > 0:\\n            return n - nums.count(1)\\n        minops = float(\\'inf\\')\\n        for i in range(n):\\n            j = i\\n            g = nums[i]\\n            while j >= 0:\\n                g = self.gcd(g, nums[j])\\n                if g == 1:\\n                    break\\n                j -= 1\\n            if g == 1:\\n                minops = min(minops, i - j)\\n            j = i\\n            g = nums[i]\\n            while j < n:\\n                g = self.gcd(g, nums[j])\\n                if g == 1:\\n                    break\\n                j += 1\\n            if g == 1:\\n                minops = min(minops, j - i)\\n        if minops == float(\\'inf\\'):\\n            return -1\\n        return n - 1 + minops\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def gcd(self, a, b):\\n        while b:\\n            a, b = b, a % b\\n        return a\\n    \\n    def minOperations(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        if nums.count(1) > 0:\\n            return n - nums.count(1)\\n        minops = float(\\'inf\\')\\n        for i in range(n):\\n            j = i\\n            g = nums[i]\\n            while j >= 0:\\n                g = self.gcd(g, nums[j])\\n                if g == 1:\\n                    break\\n                j -= 1\\n            if g == 1:\\n                minops = min(minops, i - j)\\n            j = i\\n            g = nums[i]\\n            while j < n:\\n                g = self.gcd(g, nums[j])\\n                if g == 1:\\n                    break\\n                j += 1\\n            if g == 1:\\n                minops = min(minops, j - i)\\n        if minops == float(\\'inf\\'):\\n            return -1\\n        return n - 1 + minops\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445701,
                "title": "east-solution-c-understandable",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        int ope =0;\\n        for(int i=0; i<n; i++){\\n            if(nums[i]==1){\\n                ope++;\\n            }\\n            \\n        }\\n        \\n        if(ope>0){\\n            return n - ope;\\n\\n        }\\n        \\n        int ans = INT_MAX;\\n        for(int i=0; i<n; i++){\\n            int num = nums[i];\\n            for(int j = i+1; j<n; j++){\\n                num = __gcd(num,nums[j]);\\n                if(num==1){\\n                    ans = min(ans,j-i);\\n                    break;\\n                }\\n            }\\n            if(num!=1){\\n                break;\\n            }\\n            \\n        }\\n        if(ans==INT_MAX){\\n            return -1;\\n        }\\n        return n-1+ans;\\n    }\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        int ope =0;\\n        for(int i=0; i<n; i++){\\n            if(nums[i]==1){\\n                ope++;\\n            }\\n            \\n        }\\n        \\n        if(ope>0){\\n            return n - ope;\\n\\n        }\\n        \\n        int ans = INT_MAX;\\n        for(int i=0; i<n; i++){\\n            int num = nums[i];\\n            for(int j = i+1; j<n; j++){\\n                num = __gcd(num,nums[j]);\\n                if(num==1){\\n                    ans = min(ans,j-i);\\n                    break;\\n                }\\n            }\\n            if(num!=1){\\n                break;\\n            }\\n            \\n        }\\n        if(ans==INT_MAX){\\n            return -1;\\n        }\\n        return n-1+ans;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3971868,
                "title": "c-python-solution-with-explanation",
                "content": "1. if there has a 1 in nums, we can do len(nums) - 1 operations to make all element be 1.\\n2. if threre are multiple 1s, we can do len(nums) - number of 1 operations to make all element be 0.\\n3. if there are no 1 in nums, we should find a subarray whose gcd is 1, e.g., [3,6,2] in [3,6,2,4].\\n4. if a subarray whose gcd is 1 and its size is m, we just use m - 1 operations to generate a 1, and use len(nums) - 1 operations to make all element be 1, so total is m - 1 + len(nums) - 1.\\n\\nwe can eumerate left and right side of subarray to find a subarray whose gcd is 1.\\nand because of gcd(gcd(a, b), c) == gcd(gcd(b, c), a) == gcd(gcd(a, c), b), tc will less than O(n^2).\\n\\nhash map record number after gcd and its index, left side of subarray, add current number x to subarrays we get at last time, probably get a new gcd, but left side is the same.\\n![image](https://assets.leetcode.com/users/images/cabd14ec-7d4c-4d2a-80b8-9eab40f80e01_1693228767.3166149.png)\\n\\n\\ntc is O(n log(max(nums))), sc is O(log(max(nums)))\\n\\n\\n### python\\n```python\\ninf = int(1e9)\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        cnt1 = sum(1 == x for x in nums)\\n        size = len(nums)\\n        if cnt1: return size - cnt1\\n        min_size = inf\\n        g0 = defaultdict(lambda: -1)\\n        g1 = defaultdict(lambda: -1)\\n        for i, x in enumerate(nums):\\n            for y, j in g0.items():\\n                z = gcd(x, y)\\n                g1[z] = max(g1[z], j)\\n            if 1 in g1: min_size = min(min_size, i - g1[1] + 1)\\n            g1[x] = i\\n            g0.clear()\\n            g0, g1 = g1, g0\\n        return -1 if min_size == inf else min_size - 1 + size - 1 \\n```\\n### c++\\n```cpp\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int cnt1 = accumulate(nums.begin(), nums.end(), 0, [](int cnt, int &x) -> int {return cnt + (x == 1);});\\n        int size = nums.size();\\n        if (cnt1) return size - cnt1;\\n        unordered_map<int, int> g0, g1;\\n        int min_size = INT_MAX;\\n        for (int i = 0; i < size; i+=1) {\\n            int &x = nums[i];\\n            for (auto& [y, j]: g0) {\\n                int z = gcd(x, y);\\n                g1[z] = max(g1[z], j);\\n            }\\n            if (g1.count(1)) min_size = min(min_size, i - g1[1] + 1);\\n            g1[x] = i;\\n            g0.clear();\\n            swap(g0, g1);\\n        }\\n        return min_size == INT_MAX? -1: min_size - 1 + size - 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Python",
                    "C",
                    "Math",
                    "Enumeration"
                ],
                "code": "```python\\ninf = int(1e9)\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        cnt1 = sum(1 == x for x in nums)\\n        size = len(nums)\\n        if cnt1: return size - cnt1\\n        min_size = inf\\n        g0 = defaultdict(lambda: -1)\\n        g1 = defaultdict(lambda: -1)\\n        for i, x in enumerate(nums):\\n            for y, j in g0.items():\\n                z = gcd(x, y)\\n                g1[z] = max(g1[z], j)\\n            if 1 in g1: min_size = min(min_size, i - g1[1] + 1)\\n            g1[x] = i\\n            g0.clear()\\n            g0, g1 = g1, g0\\n        return -1 if min_size == inf else min_size - 1 + size - 1 \\n```\n```cpp\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int cnt1 = accumulate(nums.begin(), nums.end(), 0, [](int cnt, int &x) -> int {return cnt + (x == 1);});\\n        int size = nums.size();\\n        if (cnt1) return size - cnt1;\\n        unordered_map<int, int> g0, g1;\\n        int min_size = INT_MAX;\\n        for (int i = 0; i < size; i+=1) {\\n            int &x = nums[i];\\n            for (auto& [y, j]: g0) {\\n                int z = gcd(x, y);\\n                g1[z] = max(g1[z], j);\\n            }\\n            if (g1.count(1)) min_size = min(min_size, i - g1[1] + 1);\\n            g1[x] = i;\\n            g0.clear();\\n            swap(g0, g1);\\n        }\\n        return min_size == INT_MAX? -1: min_size - 1 + size - 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3960167,
                "title": "c-easy-o-n-2",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& a) {\\n        map<int,int> p,q;\\n        int n=a.size();\\n        for(auto i : a)\\n        if(i==1)\\n        p[i]++;\\n\\n        q=p;\\n        int ans=INT_MAX;\\n\\n        for(int i=0;i<n;i++)\\n         {\\n          int l=a[i];\\n          for(int j=i;j<n;j++)\\n          {\\n          l=__gcd(l,a[j]);\\n          if(a[j]==1)\\n          p[a[j]]--;\\n           if(l==1)\\n           {\\n               ans=min(ans,(j-i)+(n-1)-p[1]);\\n               p=q;\\n               break;\\n           }\\n          }\\n        }\\n         return ans==INT_MAX ? -1 : ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& a) {\\n        map<int,int> p,q;\\n        int n=a.size();\\n        for(auto i : a)\\n        if(i==1)\\n        p[i]++;\\n\\n        q=p;\\n        int ans=INT_MAX;\\n\\n        for(int i=0;i<n;i++)\\n         {\\n          int l=a[i];\\n          for(int j=i;j<n;j++)\\n          {\\n          l=__gcd(l,a[j]);\\n          if(a[j]==1)\\n          p[a[j]]--;\\n           if(l==1)\\n           {\\n               ans=min(ans,(j-i)+(n-1)-p[1]);\\n               p=q;\\n               break;\\n           }\\n          }\\n        }\\n         return ans==INT_MAX ? -1 : ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3958758,
                "title": "golang-o-n-2-solution-w-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc gcd(a, b int) int {\\n    for b > 0 {\\n        a, b = b, a%b\\n    }\\n\\n    return a\\n}\\n\\nfunc min(a, b int) int {\\n    if a < b {\\n        return a\\n    }\\n\\n    return b\\n}\\n\\nfunc minOperations(nums []int) int {\\n\\n    n := len(nums)\\n    ones := 0\\n\\n    for _, num := range nums {\\n        if num == 1{\\n            ones++\\n        }\\n    }\\n\\n\\n    // if there is 1s, there are gcds garanteed to be 1\\n    // so just flip any other non 1s to 1s\\n    if ones > 0 {\\n        return n - ones\\n    }\\n\\n    res := math.MaxInt64\\n\\n    for i:=0; i<n; i++ {\\n        g := nums[i]\\n        for j:=i+1; j<n; j++ {\\n            g = gcd(g, nums[j])\\n            if g == 1 {\\n                // j - i: how many flips to get first 1\\n                // n - 1: same case with there are 1s in the first place\\n                res = min(res, j - i + n - 1)\\n                break\\n            }\\n        }\\n    }\\n\\n    if res == math.MaxInt64 {\\n        return -1\\n    }\\n\\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc gcd(a, b int) int {\\n    for b > 0 {\\n        a, b = b, a%b\\n    }\\n\\n    return a\\n}\\n\\nfunc min(a, b int) int {\\n    if a < b {\\n        return a\\n    }\\n\\n    return b\\n}\\n\\nfunc minOperations(nums []int) int {\\n\\n    n := len(nums)\\n    ones := 0\\n\\n    for _, num := range nums {\\n        if num == 1{\\n            ones++\\n        }\\n    }\\n\\n\\n    // if there is 1s, there are gcds garanteed to be 1\\n    // so just flip any other non 1s to 1s\\n    if ones > 0 {\\n        return n - ones\\n    }\\n\\n    res := math.MaxInt64\\n\\n    for i:=0; i<n; i++ {\\n        g := nums[i]\\n        for j:=i+1; j<n; j++ {\\n            g = gcd(g, nums[j])\\n            if g == 1 {\\n                // j - i: how many flips to get first 1\\n                // n - 1: same case with there are 1s in the first place\\n                res = min(res, j - i + n - 1)\\n                break\\n            }\\n        }\\n    }\\n\\n    if res == math.MaxInt64 {\\n        return -1\\n    }\\n\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3859119,
                "title": "easy-c-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(n*n)\\n\\n- Space complexity:\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        int c_one = 0;\\n        for(int i=0 ;i<n ;i++){\\n            if(nums[i] == 1)\\n                c_one++;\\n        }\\n        if(c_one)\\n        return n-c_one;\\n\\n        int ans = INT_MAX;\\n\\n        for(int i=0 ;i<n ;i++){\\n            int gdc = nums[i];\\n\\n            for(int j=i+1 ;j<n ;j++){\\n                gdc = __gcd(gdc, nums[j]);\\n                if(gdc == 1)\\n                ans = min(ans, n-1 + j-i);\\n            }\\n        }\\n        if(ans==INT_MAX)\\n        return -1;\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        int c_one = 0;\\n        for(int i=0 ;i<n ;i++){\\n            if(nums[i] == 1)\\n                c_one++;\\n        }\\n        if(c_one)\\n        return n-c_one;\\n\\n        int ans = INT_MAX;\\n\\n        for(int i=0 ;i<n ;i++){\\n            int gdc = nums[i];\\n\\n            for(int j=i+1 ;j<n ;j++){\\n                gdc = __gcd(gdc, nums[j]);\\n                if(gdc == 1)\\n                ans = min(ans, n-1 + j-i);\\n            }\\n        }\\n        if(ans==INT_MAX)\\n        return -1;\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3859117,
                "title": "easy-c-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(n*n)\\n\\n- Space complexity:\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        int c_one = 0;\\n        for(int i=0 ;i<n ;i++){\\n            if(nums[i] == 1)\\n                c_one++;\\n        }\\n        if(c_one)\\n        return n-c_one;\\n\\n        int ans = INT_MAX;\\n\\n        for(int i=0 ;i<n ;i++){\\n            int gdc = nums[i];\\n\\n            for(int j=i+1 ;j<n ;j++){\\n                gdc = __gcd(gdc, nums[j]);\\n                if(gdc == 1)\\n                ans = min(ans, n-1 + j-i);\\n            }\\n        }\\n        if(ans==INT_MAX)\\n        return -1;\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        int c_one = 0;\\n        for(int i=0 ;i<n ;i++){\\n            if(nums[i] == 1)\\n                c_one++;\\n        }\\n        if(c_one)\\n        return n-c_one;\\n\\n        int ans = INT_MAX;\\n\\n        for(int i=0 ;i<n ;i++){\\n            int gdc = nums[i];\\n\\n            for(int j=i+1 ;j<n ;j++){\\n                gdc = __gcd(gdc, nums[j]);\\n                if(gdc == 1)\\n                ans = min(ans, n-1 + j-i);\\n            }\\n        }\\n        if(ans==INT_MAX)\\n        return -1;\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3733125,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int GCD=0,count=0;\\n        for(int i=0;i<nums.size();i++){\\n            GCD = __gcd(nums[i],GCD);\\n            if(nums[i]==1)count++;\\n        }\\n        if(GCD!=1)return -1;\\n        if(count>0)return nums.size()-count;\\n        int sum =INT_MAX;\\n        for(int i=0;i<nums.size();i++){\\n            GCD = nums[i];\\n            for(int j=i;j<nums.size();j++){\\n                GCD = __gcd(GCD,nums[j]);\\n                if(GCD==1)sum = min(sum,j-i);\\n            }\\n        }\\n        return  nums.size()-1+sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Number Theory"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int GCD=0,count=0;\\n        for(int i=0;i<nums.size();i++){\\n            GCD = __gcd(nums[i],GCD);\\n            if(nums[i]==1)count++;\\n        }\\n        if(GCD!=1)return -1;\\n        if(count>0)return nums.size()-count;\\n        int sum =INT_MAX;\\n        for(int i=0;i<nums.size();i++){\\n            GCD = nums[i];\\n            for(int j=i;j<nums.size();j++){\\n                GCD = __gcd(GCD,nums[j]);\\n                if(GCD==1)sum = min(sum,j-i);\\n            }\\n        }\\n        return  nums.size()-1+sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3586189,
                "title": "c-efficient-solution-subarray-upvote-if-like-it",
                "content": "# Intuition and # Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIst part, the code counts the number of occurrences of the number 1 in the nums vector. \\nIf there is at least one occurrence of 1 (one > 0), it means that the number of operations required to make all elements equal would be n - one, where n is the size of the vector and one is the count of 1s. \\n\\nThis is because you can change all the non-1 elements to 1 in n - one operations\\n\\n2nd part, the code iterates through all possible subarrays of the nums vector.\\nFor each subarray, it calculates the greatest common divisor (currGcd) of all the elements in that subarray using the gcd function.\\n\\nIf the currGcd is equal to 1, it means all elements in that subarray are ***coprime***. \\n\\nThe code then updates currLen to the minimum length required to make all elements equal, which is the minimum value between the current currLen and **(j - i) + n - 1**, where j is the end index of the subarray and i is the start index.\\n\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> O(n*n-1)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int gcd(int a ,int b){\\n        if(a%b ==0)\\n            return b;\\n        else\\n            return gcd(b,a%b);\\n    }\\n    \\n\\n    int minOperations(vector<int>& nums) {\\n        int n =nums.size();\\n        int one =0;\\n        for(int i=0 ;i<n;i++){\\n            if(nums[i] == 1)\\n                one++;\\n        }\\n        if(one>0)\\n            return n-one;\\n\\n        int currLen =INT_MAX;\\n        for(int i=0 ;i<n;i++){\\n            int currGcd = 0;\\n            for(int j=i;j<n;j++){\\n                currGcd = gcd(currGcd ,nums[j]);\\n                if(currGcd == 1){\\n                    currLen = min(currLen,(j-i)+n-1);\\n                }\\n            }\\n        }\\n        currLen = currLen == INT_MAX ? -1 : currLen;\\n        return currLen;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int gcd(int a ,int b){\\n        if(a%b ==0)\\n            return b;\\n        else\\n            return gcd(b,a%b);\\n    }\\n    \\n\\n    int minOperations(vector<int>& nums) {\\n        int n =nums.size();\\n        int one =0;\\n        for(int i=0 ;i<n;i++){\\n            if(nums[i] == 1)\\n                one++;\\n        }\\n        if(one>0)\\n            return n-one;\\n\\n        int currLen =INT_MAX;\\n        for(int i=0 ;i<n;i++){\\n            int currGcd = 0;\\n            for(int j=i;j<n;j++){\\n                currGcd = gcd(currGcd ,nums[j]);\\n                if(currGcd == 1){\\n                    currLen = min(currLen,(j-i)+n-1);\\n                }\\n            }\\n        }\\n        currLen = currLen == INT_MAX ? -1 : currLen;\\n        return currLen;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3536078,
                "title": "java-c-python-nice-solution-well-explained",
                "content": "# TL;DR\\n```java []\\nclass Solution {\\n    private static int gcd(int a, int b) {\\n        return b == 0 ? a : gcd(b, a % b);\\n    }\\n\\n    public int minOperations(int[] nums) {\\n        int ones = 0;\\n        for (int n: nums) {\\n            if (n == 1) {\\n                ones++;\\n            }\\n        }\\n        if (ones > 0) {\\n            return nums.length - ones;\\n        }\\n        int ops = Integer.MAX_VALUE;\\n        for (int i = 0; i < nums.length; i++) {\\n            int gcd = nums[i];\\n            for (int j = i + 1; j < nums.length; j++) {\\n                if ((gcd = gcd(gcd, nums[j])) == 1) {\\n                    ops = Math.min(ops, j - i + nums.length - 1);\\n                    break;\\n                }\\n            }\\n        }\\n        return ops == Integer.MAX_VALUE ? -1 : ops;\\n    }\\n}\\n```\\n``` cpp []\\nclass Solution {\\npublic:\\n    int minOperations(std::vector<int>& nums) {\\n        int onesCount = std::count(nums.begin(), nums.end(), 1);\\n        if (onesCount > 0) {\\n            return nums.size() - onesCount;\\n        }\\n\\n        int ops = INT_MAX;\\n        for (size_t i = 0; i < nums.size(); ++i) {\\n            int currentGCD = nums[i];\\n            for (size_t j = i + 1; j < nums.size(); ++j) {\\n                currentGCD = std::gcd(currentGCD, nums[j]);\\n                if (currentGCD == 1) {\\n                    ops = std::min(ops, static_cast<int>(j - i + nums.size() - 1));\\n                    break;\\n                }\\n            }\\n        }\\n        return (ops == INT_MAX) ? -1 : ops;\\n    }\\n};\\n```\\n``` python []\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        onesCount = nums.count(1)\\n        if onesCount > 0:\\n            return len(nums) - onesCount\\n\\n        ops = float(\\'inf\\')\\n        for i in range(len(nums)):\\n            currentGCD = nums[i]\\n            for j in range(i + 1, len(nums)):\\n                currentGCD = gcd(currentGCD, nums[j])\\n                if currentGCD == 1:\\n                    ops = min(ops, j - i + len(nums) - 1)\\n                    break\\n        return -1 if ops == float(\\'inf\\') else ops\\n```\\n\\n---\\n#### \\u26A0\\uFE0F Please upvote if you like this solution. \\uD83D\\uDE43\\n---\\n\\n\\n# Intuition\\n\\nAn important property of `gcd` is that it\\'s associative. This means that `gcd(a, b, c) = gcd(gcd(a, b), c) = gcd(a, gcd(b, c))`. This property allows us to calculate the gcd of more than two numbers by successively applying the gcd operation on pairs of numbers.\\n\\n# Approach\\n\\nThe key idea behind this algorithm is to find a pair of numbers (or a number and a combination of numbers) in the array whose greatest common divisor (gcd) is 1. Once we find such a combination, we can use the operation defined in the problem to replace one number in the combination with 1, and then use this 1 to turn all other numbers in the array into 1s. This idea leverages the property of the gcd function: `gcd(a, b, c) = gcd(gcd(a, b), c)`.\\n\\nTo find such a pair, we iterate over the array, and for each element at index `i`, we calculate the gcd with the rest of the elements in the array (i.e., the elements at indices `j` where `i < j < nums.length`). We start with `gcd = nums[i]` and then iteratively compute `gcd = gcd(gcd, nums[j])` for increasing values of `j`.\\n\\nIf at any point, the gcd becomes 1, it means that number `nums[j]` and some number or combination of the previous elements `nums[i..j-1]` have a gcd of 1. At this point, the minimum number of operations required to turn all elements in the array into 1s is `j - i + nums.length - 1`. Here, `j - i` is the number of operations needed to transform the subarray `nums[i..j]` into 1s (by replacing `nums[j]` with the gcd of `nums[i..j]`, which is 1), and `nums.length - 1` is the number of operations needed to transform the rest of the array into 1s.\\n\\nAfter this, we continue the iteration to check if we can find another pair or combination that allows us to turn all elements into 1s with fewer operations. \\n\\nThe algorithm continues this process for all elements in the array and keeps track of the minimum number of operations found. If no pair or combination with a gcd of 1 is found after examining the entire array, the algorithm returns -1 to indicate that it\\'s impossible to make all elements of the array equal to 1.\\n\\n# Complexity Analysis\\n\\n- The time complexity is $$O(n^2)$$ because for each element, we potentially calculate the gcd with the rest of the elements in the array.\\n\\n- The space complexity is $$O(1)$$ because we only use a constant amount of space to store the intermediate results.\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python"
                ],
                "code": "```java []\\nclass Solution {\\n    private static int gcd(int a, int b) {\\n        return b == 0 ? a : gcd(b, a % b);\\n    }\\n\\n    public int minOperations(int[] nums) {\\n        int ones = 0;\\n        for (int n: nums) {\\n            if (n == 1) {\\n                ones++;\\n            }\\n        }\\n        if (ones > 0) {\\n            return nums.length - ones;\\n        }\\n        int ops = Integer.MAX_VALUE;\\n        for (int i = 0; i < nums.length; i++) {\\n            int gcd = nums[i];\\n            for (int j = i + 1; j < nums.length; j++) {\\n                if ((gcd = gcd(gcd, nums[j])) == 1) {\\n                    ops = Math.min(ops, j - i + nums.length - 1);\\n                    break;\\n                }\\n            }\\n        }\\n        return ops == Integer.MAX_VALUE ? -1 : ops;\\n    }\\n}\\n```\n``` cpp []\\nclass Solution {\\npublic:\\n    int minOperations(std::vector<int>& nums) {\\n        int onesCount = std::count(nums.begin(), nums.end(), 1);\\n        if (onesCount > 0) {\\n            return nums.size() - onesCount;\\n        }\\n\\n        int ops = INT_MAX;\\n        for (size_t i = 0; i < nums.size(); ++i) {\\n            int currentGCD = nums[i];\\n            for (size_t j = i + 1; j < nums.size(); ++j) {\\n                currentGCD = std::gcd(currentGCD, nums[j]);\\n                if (currentGCD == 1) {\\n                    ops = std::min(ops, static_cast<int>(j - i + nums.size() - 1));\\n                    break;\\n                }\\n            }\\n        }\\n        return (ops == INT_MAX) ? -1 : ops;\\n    }\\n};\\n```\n``` python []\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        onesCount = nums.count(1)\\n        if onesCount > 0:\\n            return len(nums) - onesCount\\n\\n        ops = float(\\'inf\\')\\n        for i in range(len(nums)):\\n            currentGCD = nums[i]\\n            for j in range(i + 1, len(nums)):\\n                currentGCD = gcd(currentGCD, nums[j])\\n                if currentGCD == 1:\\n                    ops = min(ops, j - i + len(nums) - 1)\\n                    break\\n        return -1 if ops == float(\\'inf\\') else ops\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3509361,
                "title": "rust-just-works-solution-runtime-100-memory-100",
                "content": "It picks every number and travels through the array(while executing gcd on every step) until the number\\'s value is equal to one or reaches the end of the array. It also skips some numbers if it\\'s possible.\\n# Code\\n```\\nimpl Solution {\\n    pub fn min_operations(nums: Vec<i32>) -> i32 {\\n        if nums.contains(&1) {\\n            return nums.iter().filter(|n| **n != 1).count() as i32;\\n        }\\n        let mut distance: i32 = -1;\\n        let mut i = 0;\\n        while i < nums.len() {\\n            let mut cur_num = nums[i];\\n            for j in i+1..nums.len() {\\n                let g = Self::gcd(nums[j], cur_num);\\n                if g == nums[j] {\\n                    i = j-1;\\n                    break;\\n                }\\n                if g == 1 {\\n                    if distance == -1 || distance > (j - i) as i32 {\\n                        distance = (j - i) as i32;\\n                        break;\\n                    }\\n                } else {\\n                    cur_num = g;\\n                }\\n            }\\n            i += 1;\\n        }\\n        \\n        if distance == -1 {\\n            -1\\n        } else {\\n            distance - 1 + nums.len() as i32\\n        }\\n    }\\n\\n    fn gcd(a: i32, b: i32) -> i32 {\\n        let (mut a, mut b) = (a, b);\\n        while b != 0 {\\n            let temp = b;\\n            b = a % b;\\n            a = temp;\\n        }\\n        a\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn min_operations(nums: Vec<i32>) -> i32 {\\n        if nums.contains(&1) {\\n            return nums.iter().filter(|n| **n != 1).count() as i32;\\n        }\\n        let mut distance: i32 = -1;\\n        let mut i = 0;\\n        while i < nums.len() {\\n            let mut cur_num = nums[i];\\n            for j in i+1..nums.len() {\\n                let g = Self::gcd(nums[j], cur_num);\\n                if g == nums[j] {\\n                    i = j-1;\\n                    break;\\n                }\\n                if g == 1 {\\n                    if distance == -1 || distance > (j - i) as i32 {\\n                        distance = (j - i) as i32;\\n                        break;\\n                    }\\n                } else {\\n                    cur_num = g;\\n                }\\n            }\\n            i += 1;\\n        }\\n        \\n        if distance == -1 {\\n            -1\\n        } else {\\n            distance - 1 + nums.len() as i32\\n        }\\n    }\\n\\n    fn gcd(a: i32, b: i32) -> i32 {\\n        let (mut a, mut b) = (a, b);\\n        while b != 0 {\\n            let temp = b;\\n            b = a % b;\\n            a = temp;\\n        }\\n        a\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3489907,
                "title": "c-easy-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> tmp(n);\\n        int ele = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            tmp[i] = nums[i];\\n            if(nums[i]!=1)\\n            ele++;\\n        }\\n        int cnt=0;\\n        while(tmp.size()>1)\\n        {\\n            for(int i=0;i<tmp.size()-1;i++)\\n            {\\n                if(__gcd(tmp[i],tmp[i+1])==1)\\n                return cnt+ele;\\n                tmp[i] = __gcd(tmp[i],tmp[i+1]);\\n                if(tmp[i]==1)\\n                return cnt+ele;\\n            }\\n            cnt++;\\n            tmp.pop_back();\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> tmp(n);\\n        int ele = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            tmp[i] = nums[i];\\n            if(nums[i]!=1)\\n            ele++;\\n        }\\n        int cnt=0;\\n        while(tmp.size()>1)\\n        {\\n            for(int i=0;i<tmp.size()-1;i++)\\n            {\\n                if(__gcd(tmp[i],tmp[i+1])==1)\\n                return cnt+ele;\\n                tmp[i] = __gcd(tmp[i],tmp[i+1]);\\n                if(tmp[i]==1)\\n                return cnt+ele;\\n            }\\n            cnt++;\\n            tmp.pop_back();\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3489274,
                "title": "python-bruteforce-o-n-3",
                "content": "# Code\\n```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        minspan = float(\\'inf\\')\\n        for i in range(n):\\n            for j in range(i,n):\\n                curgcd = nums[i]\\n                for k in range(i,j+1):\\n                    curgcd = gcd(curgcd, nums[k])\\n                if curgcd == 1 and minspan > j - i + 1:\\n                    minspan = j - i + 1\\n        return -1 if minspan == float(\\'inf\\') else (n - nums.count(1) if minspan == 1 else minspan - 1 + n - 1)\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        minspan = float(\\'inf\\')\\n        for i in range(n):\\n            for j in range(i,n):\\n                curgcd = nums[i]\\n                for k in range(i,j+1):\\n                    curgcd = gcd(curgcd, nums[k])\\n                if curgcd == 1 and minspan > j - i + 1:\\n                    minspan = j - i + 1\\n        return -1 if minspan == float(\\'inf\\') else (n - nums.count(1) if minspan == 1 else minspan - 1 + n - 1)\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3488968,
                "title": "c-very-easy-beginner-friendly-easy-approach-solution",
                "content": "class Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n =nums.size();\\n        int c=0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==1){\\n              c++;\\n            }\\n        }\\n        if(c==n)  return 0;\\n        if(c>=1){\\n            return n-c;;\\n        }\\n        \\n        int mini=INT_MAX;\\n        for(int i=0;i<n;i++){\\n            int cg= nums[i];\\n            for(int j=i;j<n;j++){\\n                cg=__gcd(cg,nums[j]);\\n                if(cg==1){\\n                    mini=min(mini,j-i+1);\\n                }\\n                else{\\n                    continue;\\n                }\\n            }\\n        }\\n        if(mini!=INT_MAX){\\n            return mini+n-2-c;\\n        }\\n        \\n        return -1;\\n        \\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n =nums.size();\\n        int c=0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==1){\\n              c++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3478178,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn min_operations(nums: Vec<i32>) -> i32 {\\n        let n = nums.len();\\n        let mut one = 0;\\n        for i in 0..n {\\n            if nums[i] == 1 {\\n                one += 1;\\n            }\\n        }\\n        if one > 0 {\\n            return (n - one) as i32;\\n        }\\n        let mut la = vec![];\\n        let mut ra = vec![];\\n        let mut lg = vec![];\\n        let mut rg = vec![];\\n\\n        fn gcd(mut a: i32, mut b: i32) -> i32 {\\n            while b != 0 {\\n                let t = b;\\n                b = a % b;\\n                a = t;\\n            }\\n            a\\n        }\\n        \\n        fn good(la: &Vec<i32>, ra: &Vec<i32>, lg: &Vec<i32>, rg: &Vec<i32>) -> bool {\\n            let mut g = 0;\\n            if !la.is_empty() {\\n                g = gcd(g, lg[lg.len() - 1]);\\n            }\\n            if !ra.is_empty() {\\n                g = gcd(g, rg[rg.len() - 1]);\\n            }\\n            g == 1\\n        }\\n\\n        fn add(ra: &mut Vec<i32>, rg: &mut Vec<i32>, x: i32) {\\n            ra.push(x);\\n            rg.push(gcd(if rg.is_empty() { 0 } else { rg[rg.len() - 1] }, x));\\n        }\\n\\n        fn remove(la: &mut Vec<i32>, ra: &mut Vec<i32>, lg: &mut Vec<i32>, rg: &mut Vec<i32>) {\\n            if la.is_empty() {\\n                while !ra.is_empty() {\\n                    let x = ra[ra.len() - 1];\\n                    la.push(x);\\n                    ra.pop();\\n                    rg.pop();\\n                    lg.push(gcd(if lg.is_empty() { 0 } else { lg[lg.len() - 1] }, x));\\n                }\\n            }\\n            la.pop();\\n            lg.pop();\\n        }\\n\\n\\n        let mut ans = n;\\n        let (mut l, mut r) = (0, 0);\\n        while r < n {\\n            add(&mut ra, &mut rg, nums[r]);\\n            while l < n && good(&la, &ra, &lg, &rg) {\\n                ans = ans.min(r - l);\\n                remove(&mut la, &mut ra, &mut lg, &mut rg);\\n                l += 1;\\n            }\\n            r += 1;\\n        }\\n        if ans == n {\\n            return -1;\\n        }\\n        (n + ans - 1) as i32\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn min_operations(nums: Vec<i32>) -> i32 {\\n        let n = nums.len();\\n        let mut one = 0;\\n        for i in 0..n {\\n            if nums[i] == 1 {\\n                one += 1;\\n            }\\n        }\\n        if one > 0 {\\n            return (n - one) as i32;\\n        }\\n        let mut la = vec![];\\n        let mut ra = vec![];\\n        let mut lg = vec![];\\n        let mut rg = vec![];\\n\\n        fn gcd(mut a: i32, mut b: i32) -> i32 {\\n            while b != 0 {\\n                let t = b;\\n                b = a % b;\\n                a = t;\\n            }\\n            a\\n        }\\n        \\n        fn good(la: &Vec<i32>, ra: &Vec<i32>, lg: &Vec<i32>, rg: &Vec<i32>) -> bool {\\n            let mut g = 0;\\n            if !la.is_empty() {\\n                g = gcd(g, lg[lg.len() - 1]);\\n            }\\n            if !ra.is_empty() {\\n                g = gcd(g, rg[rg.len() - 1]);\\n            }\\n            g == 1\\n        }\\n\\n        fn add(ra: &mut Vec<i32>, rg: &mut Vec<i32>, x: i32) {\\n            ra.push(x);\\n            rg.push(gcd(if rg.is_empty() { 0 } else { rg[rg.len() - 1] }, x));\\n        }\\n\\n        fn remove(la: &mut Vec<i32>, ra: &mut Vec<i32>, lg: &mut Vec<i32>, rg: &mut Vec<i32>) {\\n            if la.is_empty() {\\n                while !ra.is_empty() {\\n                    let x = ra[ra.len() - 1];\\n                    la.push(x);\\n                    ra.pop();\\n                    rg.pop();\\n                    lg.push(gcd(if lg.is_empty() { 0 } else { lg[lg.len() - 1] }, x));\\n                }\\n            }\\n            la.pop();\\n            lg.pop();\\n        }\\n\\n\\n        let mut ans = n;\\n        let (mut l, mut r) = (0, 0);\\n        while r < n {\\n            add(&mut ra, &mut rg, nums[r]);\\n            while l < n && good(&la, &ra, &lg, &rg) {\\n                ans = ans.min(r - l);\\n                remove(&mut la, &mut ra, &mut lg, &mut rg);\\n                l += 1;\\n            }\\n            r += 1;\\n        }\\n        if ans == n {\\n            return -1;\\n        }\\n        (n + ans - 1) as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3464113,
                "title": "from-math-import-gcd",
                "content": "Remember the name : Debauch Casanova\\n\\n# Code\\n```\\nimport math\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        one = nums.count(1)\\n        if one: \\n            return len(nums)-one\\n        diff = float(inf) \\n        for i in range(len(nums)): \\n            g = nums[i]\\n            for j in range(i+1, len(nums)):\\n                g = gcd(g, nums[j])\\n                if g == 1: \\n                    diff = min(diff, j-i)\\n        if diff == float(inf):\\n            return -1 \\n        else:\\n            return diff + len(nums) - 1\\n```",
                "solutionTags": [
                    "Python3",
                    "Math"
                ],
                "code": "```\\nimport math\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        one = nums.count(1)\\n        if one: \\n            return len(nums)-one\\n        diff = float(inf) \\n        for i in range(len(nums)): \\n            g = nums[i]\\n            for j in range(i+1, len(nums)):\\n                g = gcd(g, nums[j])\\n                if g == 1: \\n                    diff = min(diff, j-i)\\n        if diff == float(inf):\\n            return -1 \\n        else:\\n            return diff + len(nums) - 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3462638,
                "title": "kotlin-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    fun minOperations(nums: IntArray): Int {\\n        var g = nums[0]\\n        var list = mutableListOf<Int>()\\n        var padding = 0\\n        var result = nums.size\\n        \\n        for (i in 0 until nums.size) {\\n            val n = nums[i]\\n            if (n == 1) {\\n                result--\\n            }\\n            g = gcd(g, n)\\n            if (i == nums.size - 1) continue\\n            \\n            val m = nums[i + 1]\\n            list.add(gcd(m, n))\\n        }\\n        \\n        if (g > 1) return -1\\n        \\n        while(!list.any{ it == 1 }) {\\n            padding++\\n            val nlist = mutableListOf<Int>()\\n            \\n            for (i in 0 until list.size - 1) {\\n                val n = list[i]\\n                val m = list[i + 1]\\n                \\n                nlist.add(gcd(m,n))\\n            }\\n            \\n            list = nlist\\n        }\\n\\n        return result + padding\\n    }\\n    \\n    fun gcd(a: Int, b:Int): Int = if(b != 0) gcd(b, a % b) else a\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun minOperations(nums: IntArray): Int {\\n        var g = nums[0]\\n        var list = mutableListOf<Int>()\\n        var padding = 0\\n        var result = nums.size\\n        \\n        for (i in 0 until nums.size) {\\n            val n = nums[i]\\n            if (n == 1) {\\n                result--\\n            }\\n            g = gcd(g, n)\\n            if (i == nums.size - 1) continue\\n            \\n            val m = nums[i + 1]\\n            list.add(gcd(m, n))\\n        }\\n        \\n        if (g > 1) return -1\\n        \\n        while(!list.any{ it == 1 }) {\\n            padding++\\n            val nlist = mutableListOf<Int>()\\n            \\n            for (i in 0 until list.size - 1) {\\n                val n = list[i]\\n                val m = list[i + 1]\\n                \\n                nlist.add(gcd(m,n))\\n            }\\n            \\n            list = nlist\\n        }\\n\\n        return result + padding\\n    }\\n    \\n    fun gcd(a: Int, b:Int): Int = if(b != 0) gcd(b, a % b) else a\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3462249,
                "title": "c",
                "content": "# Code\\n```\\npublic class Solution {\\n  public int MinOperations(int[] nums) {\\n    if (nums.Contains(1))\\n      return nums.Length - nums.Count(n => n == 1);\\n\\n    var res = int.MaxValue;\\n    for (var i = 0; i < nums.Length; i++) {\\n        var gcd = nums[i];\\n        for (var j = i + 1; j < nums.Length; j++) {\\n            gcd = GCD(gcd, nums[j]);\\n            if (gcd == 1){\\n                res = Math.Min(res, j - i + (nums.Length - 1));\\n                break;\\n            }\\n        } \\n    }     \\n    return res == int.MaxValue ? -1 : res;\\n  }\\n\\n  static int GCD(int num1, int num2) {\\n    while (num2 != 0) {\\n        int temp = num2;\\n        num2 = num1 % num2;\\n        num1 = temp;\\n    }\\n    return num1;\\n  }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n  public int MinOperations(int[] nums) {\\n    if (nums.Contains(1))\\n      return nums.Length - nums.Count(n => n == 1);\\n\\n    var res = int.MaxValue;\\n    for (var i = 0; i < nums.Length; i++) {\\n        var gcd = nums[i];\\n        for (var j = i + 1; j < nums.Length; j++) {\\n            gcd = GCD(gcd, nums[j]);\\n            if (gcd == 1){\\n                res = Math.Min(res, j - i + (nums.Length - 1));\\n                break;\\n            }\\n        } \\n    }     \\n    return res == int.MaxValue ? -1 : res;\\n  }\\n\\n  static int GCD(int num1, int num2) {\\n    while (num2 != 0) {\\n        int temp = num2;\\n        num2 = num1 % num2;\\n        num1 = temp;\\n    }\\n    return num1;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3460599,
                "title": "the-most-simple-not-the-most-efficient-python",
                "content": "# Code\\n```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        ans = 2 * n\\n        non_one = sum(1 for num in nums if num != 1)\\n\\n        for i in range(n):\\n            for j in range(i + 1, n):\\n                if gcd(*nums[i: j + 1]) == 1:\\n                    ans = min(ans, j - i + non_one - 1)\\n        return -1 if ans == 2 * n else ans\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        ans = 2 * n\\n        non_one = sum(1 for num in nums if num != 1)\\n\\n        for i in range(n):\\n            for j in range(i + 1, n):\\n                if gcd(*nums[i: j + 1]) == 1:\\n                    ans = min(ans, j - i + non_one - 1)\\n        return -1 if ans == 2 * n else ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3459865,
                "title": "python3-gcd-traverses-from-left-to-right-then-right-to-left-time-complexity-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nGreedy\\nUse two loops traverse the array from left to right and from right to left, respectively, to find the minimum number of operations needed to make all elements of the array equal to 1. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        cnt = nums.count(1) # to check if any 1\\'s in the nums\\n        if cnt: \\n            return len(nums) - cnt\\n        # get the minium steps from left to right\\n        i = 0\\n        mins = len(nums)\\n        g = nums[0]\\n        for j in range(len(nums)):\\n            if nums[j] == 1:\\n                cnt += 1\\n            g = math.gcd(g, nums[j])\\n            if j and math.gcd(nums[j-1], nums[j]) == g:\\n                i = j-1\\n            if g == 1:\\n                mins = min(mins, j - i)\\n                g = nums[j]\\n                i = j\\n        # get the minium steps from right to left\\n        j = len(nums) - 1\\n        g = nums[-1]\\n        for i in range(len(nums)-1, -1, -1):\\n            g = math.gcd(g, nums[i])\\n            if i < len(nums) - 1 and math.gcd(nums[i], nums[i+1]) == g:\\n                j = i + 1\\n            if g == 1:\\n                mins = min(mins, j - i)\\n                g = nums[i]\\n                j = i\\n        return -1 if mins == len(nums) else mins + len(nums) - 1\\n\\n\\n\\n\\n\\n        \\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        cnt = nums.count(1) # to check if any 1\\'s in the nums\\n        if cnt: \\n            return len(nums) - cnt\\n        # get the minium steps from left to right\\n        i = 0\\n        mins = len(nums)\\n        g = nums[0]\\n        for j in range(len(nums)):\\n            if nums[j] == 1:\\n                cnt += 1\\n            g = math.gcd(g, nums[j])\\n            if j and math.gcd(nums[j-1], nums[j]) == g:\\n                i = j-1\\n            if g == 1:\\n                mins = min(mins, j - i)\\n                g = nums[j]\\n                i = j\\n        # get the minium steps from right to left\\n        j = len(nums) - 1\\n        g = nums[-1]\\n        for i in range(len(nums)-1, -1, -1):\\n            g = math.gcd(g, nums[i])\\n            if i < len(nums) - 1 and math.gcd(nums[i], nums[i+1]) == g:\\n                j = i + 1\\n            if g == 1:\\n                mins = min(mins, j - i)\\n                g = nums[i]\\n                j = i\\n        return -1 if mins == len(nums) else mins + len(nums) - 1\\n\\n\\n\\n\\n\\n        \\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3459753,
                "title": "easily-understandable-solution-uses-gcd-property-and-implementation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nHere the question asked us to make the whole array 1 by using gcd of adjacent .\\nso the intuition is that gcd of two or more number becomes 1 when their is no common factor between them and another thing is that gcd of any number with 1 is always 1.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSo, first we need to check that in the given array whether thier is 1 present or not ,if 1 is present then we can make the whole array 1 by just applying the n- countof(1) operation . You can understand it easily just dry run it with some tcs.\\nNow if 1 is not present then our goal is to find the smallest subarray whose gcd is 1 . We are doing this because once we create a single one from that subarray then in exactly n-1 moves we can make whole array equal to 1 .\\nso ans becomes smallest subarray of gcd 1 + n-1 moves.\\nBelow is the implementation of this..\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2) As nested for loop is running.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int ct=0;\\n        int n=nums.size();\\n        for(auto i:nums)if(i==1)ct++;\\n        if(ct>0)return n-ct;\\n        int ans=INT_MAX;\\n        for(int i=0;i<n;i++){\\n            int an=nums[i];\\n            for(int j=i+1;j<n;j++){\\n                an=__gcd(an,nums[j]);\\n                if(an==1){\\n                    ans=min(ans,j-i);\\n                    break;\\n                }\\n            }\\n            }\\n        if(ans==INT_MAX)return -1;\\n        return ans+n-1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int ct=0;\\n        int n=nums.size();\\n        for(auto i:nums)if(i==1)ct++;\\n        if(ct>0)return n-ct;\\n        int ans=INT_MAX;\\n        for(int i=0;i<n;i++){\\n            int an=nums[i];\\n            for(int j=i+1;j<n;j++){\\n                an=__gcd(an,nums[j]);\\n                if(an==1){\\n                    ans=min(ans,j-i);\\n                    break;\\n                }\\n            }\\n            }\\n        if(ans==INT_MAX)return -1;\\n        return ans+n-1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3459697,
                "title": "beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minOperations(int[] nums) {\\n        int noOfOne = 0;\\n        for(int i = 0; i < nums.length; i++){\\n            if(nums[i] == 1)\\n               noOfOne++;\\n        }\\n\\n        if(noOfOne > 0)\\n          return nums.length - noOfOne;\\n        \\n        int currLen = Integer.MAX_VALUE;\\n        for(int i = 0; i < nums.length; i++){\\n            int currGcd = nums[i];\\n            for(int j = i + 1; j < nums.length; j++){\\n                 currGcd = gcd(currGcd, nums[j]);\\n                \\n                if(currGcd == 1){\\n                    currLen = Math.min(currLen, j - i + nums.length - 1);\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return (currLen == Integer.MAX_VALUE) ? -1 : currLen;\\n    }\\n\\n    public int gcd(int a, int b){\\n        if(b == 0) return a;\\n        return gcd(b, a % b);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(int[] nums) {\\n        int noOfOne = 0;\\n        for(int i = 0; i < nums.length; i++){\\n            if(nums[i] == 1)\\n               noOfOne++;\\n        }\\n\\n        if(noOfOne > 0)\\n          return nums.length - noOfOne;\\n        \\n        int currLen = Integer.MAX_VALUE;\\n        for(int i = 0; i < nums.length; i++){\\n            int currGcd = nums[i];\\n            for(int j = i + 1; j < nums.length; j++){\\n                 currGcd = gcd(currGcd, nums[j]);\\n                \\n                if(currGcd == 1){\\n                    currLen = Math.min(currLen, j - i + nums.length - 1);\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return (currLen == Integer.MAX_VALUE) ? -1 : currLen;\\n    }\\n\\n    public int gcd(int a, int b){\\n        if(b == 0) return a;\\n        return gcd(b, a % b);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3457911,
                "title": "fully-explained-easy-c",
                "content": "# Approach and Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n=nums.size();\\n        //Case-1: If there are \\'count\\' number of ones in nums array, then (n-count) will be the min ops, because each non-ones is gonna take 1 step to convert into 1, and (n-count) are the no-ones.\\n\\n        //Let\\'s count ones\\n        int count=0;\\n        for(auto num: nums) {\\n            if(num==1) {\\n                count++;\\n            }\\n        }\\n        if(count>0) {\\n            return n-count;\\n        }\\n\\n        //Case-2: If there are no ones in the array, the we\\'ll follow below algorithm\\n\\n        /*\\n        e.g. 4,8,6,9\\n        if any one of the above elements become 1, then rest will take (n-1) steps to get converted into 1.\\n        So, for example 6 takes x steps to get converted into 1, so overall (x+(n-1))steps will be required by the array to convert all into 1\\n        But then we\\'ll need to check for each element and find the minimal of (x+(n-1)) among all.\\n        It\\'s gonna take O(n2) time\\n\\n        By the way, how to find those x steps, so in the above example, 4 & 9 have gcd 1, and since it is given in the question that we can only change adjacent element to 1, so for 9 to convert into 1, it\\'s gonna take 3 steps i.e.(j-i) steps, where j is index of 9 and i is index of 4. \\n\\n        Hence the optimised approach is to find the smallest subarray, whose gcd is one so, we\\'ll have the minimum j-i value, and hence minimum x value and hence minimum (x+(n-1)) value !\\n        */\\n\\n        int x=INT_MAX;\\n\\n        for(int i=0;i<n-1;i++) {\\n\\n            int g=nums[i];\\n            for(int j=i+1;j<n;j++) {\\n\\n                g=__gcd(g,nums[j]);\\n\\n                if(g==1) {\\n                    x=min(x,j-i);\\n                    break;\\n                }\\n            }\\n        }\\n        //now we have got the minimum x\\n\\n        if(x!=INT_MAX) {\\n            return (x+(n-1));\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n=nums.size();\\n        //Case-1: If there are \\'count\\' number of ones in nums array, then (n-count) will be the min ops, because each non-ones is gonna take 1 step to convert into 1, and (n-count) are the no-ones.\\n\\n        //Let\\'s count ones\\n        int count=0;\\n        for(auto num: nums) {\\n            if(num==1) {\\n                count++;\\n            }\\n        }\\n        if(count>0) {\\n            return n-count;\\n        }\\n\\n        //Case-2: If there are no ones in the array, the we\\'ll follow below algorithm\\n\\n        /*\\n        e.g. 4,8,6,9\\n        if any one of the above elements become 1, then rest will take (n-1) steps to get converted into 1.\\n        So, for example 6 takes x steps to get converted into 1, so overall (x+(n-1))steps will be required by the array to convert all into 1\\n        But then we\\'ll need to check for each element and find the minimal of (x+(n-1)) among all.\\n        It\\'s gonna take O(n2) time\\n\\n        By the way, how to find those x steps, so in the above example, 4 & 9 have gcd 1, and since it is given in the question that we can only change adjacent element to 1, so for 9 to convert into 1, it\\'s gonna take 3 steps i.e.(j-i) steps, where j is index of 9 and i is index of 4. \\n\\n        Hence the optimised approach is to find the smallest subarray, whose gcd is one so, we\\'ll have the minimum j-i value, and hence minimum x value and hence minimum (x+(n-1)) value !\\n        */\\n\\n        int x=INT_MAX;\\n\\n        for(int i=0;i<n-1;i++) {\\n\\n            int g=nums[i];\\n            for(int j=i+1;j<n;j++) {\\n\\n                g=__gcd(g,nums[j]);\\n\\n                if(g==1) {\\n                    x=min(x,j-i);\\n                    break;\\n                }\\n            }\\n        }\\n        //now we have got the minimum x\\n\\n        if(x!=INT_MAX) {\\n            return (x+(n-1));\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3457084,
                "title": "java-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minOperations(int[] nums) {\\n        int n = nums.length;\\n        int min = 100, ones = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] == 1) {\\n                ones++;\\n                min = 1;\\n                continue;\\n            }\\n            for (int j = i + 1, a = nums[i]; j < n && j - i < min; j++) {\\n                int b = nums[j];\\n                while (b != 0) {\\n                    int t = a % b;\\n                    a = b;\\n                    b = t;\\n                }\\n                if (a == 1) min = j - i;\\n            }\\n        }\\n        return min < 100 ? n - 1 + min - ones : -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(int[] nums) {\\n        int n = nums.length;\\n        int min = 100, ones = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] == 1) {\\n                ones++;\\n                min = 1;\\n                continue;\\n            }\\n            for (int j = i + 1, a = nums[i]; j < n && j - i < min; j++) {\\n                int b = nums[j];\\n                while (b != 0) {\\n                    int t = a % b;\\n                    a = b;\\n                    b = t;\\n                }\\n                if (a == 1) min = j - i;\\n            }\\n        }\\n        return min < 100 ? n - 1 + min - ones : -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3455515,
                "title": "c-find-smallest-subarray-with-gcd-of-1",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        vector<int> gcfs(nums);\\n        int pivot = -1, groupsz = 0; // to find smallest subarray [pivot, pivot+groupsz) to have gcd of 1\\n        while(pivot == -1 && ++groupsz <= nums.size()) {\\n            for(int i = 0; i <= nums.size() - groupsz; ++i) {\\n                if( (gcfs[i] = gcd(gcfs[i], nums[i + groupsz - 1])) == 1 ) {\\n                    pivot = i;\\n                    break;\\n                }\\n            }\\n        }\\n        if(groupsz > nums.size()) return -1;\\n        nums[pivot] = 1;\\n        return groupsz - 1 + count_if(nums.begin(), nums.end(), binder2nd(not_equal_to<int>(), 1));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        vector<int> gcfs(nums);\\n        int pivot = -1, groupsz = 0; // to find smallest subarray [pivot, pivot+groupsz) to have gcd of 1\\n        while(pivot == -1 && ++groupsz <= nums.size()) {\\n            for(int i = 0; i <= nums.size() - groupsz; ++i) {\\n                if( (gcfs[i] = gcd(gcfs[i], nums[i + groupsz - 1])) == 1 ) {\\n                    pivot = i;\\n                    break;\\n                }\\n            }\\n        }\\n        if(groupsz > nums.size()) return -1;\\n        nums[pivot] = 1;\\n        return groupsz - 1 + count_if(nums.begin(), nums.end(), binder2nd(not_equal_to<int>(), 1));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3453390,
                "title": "python3",
                "content": "# Code\\n```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        n1 = sum(i==1 for i in nums)      \\n        l = len(nums)\\n        res = l-n1\\n\\n        while l>1:\\n            new_nums = []\\n            for i in range(l-1):\\n                add = math.gcd(nums[i], nums[i + 1])\\n                if add == 1:\\n                    return res\\n                new_nums.append(add)\\n            nums = new_nums\\n            l = len(nums)\\n            res += 1\\n        return -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        n1 = sum(i==1 for i in nums)      \\n        l = len(nums)\\n        res = l-n1\\n\\n        while l>1:\\n            new_nums = []\\n            for i in range(l-1):\\n                add = math.gcd(nums[i], nums[i + 1])\\n                if add == 1:\\n                    return res\\n                new_nums.append(add)\\n            nums = new_nums\\n            l = len(nums)\\n            res += 1\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3452354,
                "title": "python-find-min-subarray-with-gcd-1",
                "content": "This one is tricky.\\n\\n1. Find if the array has at least `1`. As `gcd(x, 1) => 1`, If yes, then you can turn in into all `1` in `N - count_of_1`\\n2. If there\\'s no `1` we need to findout if we can find `1` or not. If we can, we need to find the smallest subarray with `gcd(subarray) = 1`. This will require `len(subarray) - 1` operations to make at least one `1`, if possible. The result is *number of operations to make at least `1` one + number of elements that needs to be turned into 1 except that one `1` that we made earlier*\\n\\n```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        N = len(nums)\\n        \\n        ones = sum((1 for n in nums if n == 1))\\n        if ones:\\n            return N - ones\\n        \\n        min_subarray = float(inf)\\n        for start in range(N - 1):\\n            i = start\\n            c = nums[i]\\n            while i < N - 1 and c != 1:\\n                c = gcd(c, nums[i + 1])\\n                i += 1\\n            if c == 1:\\n                min_subarray = min(min_subarray, i - start + 1)\\n        \\n        if min_subarray == float(inf):\\n            return -1\\n        \\n        return min_subarray - 1 + N - 1\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        N = len(nums)\\n        \\n        ones = sum((1 for n in nums if n == 1))\\n        if ones:\\n            return N - ones\\n        \\n        min_subarray = float(inf)\\n        for start in range(N - 1):\\n            i = start\\n            c = nums[i]\\n            while i < N - 1 and c != 1:\\n                c = gcd(c, nums[i + 1])\\n                i += 1\\n            if c == 1:\\n                min_subarray = min(min_subarray, i - start + 1)\\n        \\n        if min_subarray == float(inf):\\n            return -1\\n        \\n        return min_subarray - 1 + N - 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3452267,
                "title": "python3-segment-tree-o-n-log-n-shortest-subarray-with-gcd-as-1",
                "content": "Follow the same logic as many other discussions:\\n* Check edge cases.\\n* Find the shortest subarray with GCD as 1 by sliding window: first move pointer hi to the right until GCD of nums[lo:hi] is 1, then shrink pointer lo from the left until it is no longer 1; after that move on to the next window...\\n* Use segment tree to calculate GCD of range nums[lo:hi] efficiently in O(log n).\\n```\\n    def minOperations(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        \\n\\t\\t# edge case 1: check existence of 1\\n        c1 = nums.count(1)\\n        if c1 > 0:\\n            return n - c1\\n        \\n\\t\\t# edge case 2: impossible if GCD of all numbers is not 1\\n        if gcd(*nums) != 1:\\n            return -1\\n        \\n\\t\\t# initialize segment tree: tree[i] = gcd(tree[k]: k + 1 has bit prefix as i + 1)\\n        tree = [0] * (n - 1) + nums\\n        for i in range(n - 2, -1, -1):\\n            tree[i] = gcd(tree[2*i + 1], tree[2*i + 2])\\n        \\n\\t\\t# helper function to calculate GCD of range nums[lo:hi]\\n        def gcd_range(lo, hi):\\n            g = nums[lo]\\n            lo += n - 1\\n            hi += n - 1 \\n            while lo < hi:\\n                if lo % 2 == 0:\\n                    g = gcd(g, tree[lo])\\n                    lo += 1\\n                if hi % 2 == 0:\\n                    hi -= 1\\n                    g = gcd(g, tree[hi])\\n                lo = (lo - 1) // 2\\n                hi = (hi - 1) // 2\\n            return g\\n        \\n        # find shortest subarray with GCD as 1\\n        w = n \\n        lo = hi = 1        \\n        g = nums[0]\\n        while hi < n:\\n            g = gcd(g, nums[hi])\\n            hi += 1\\n            if g == 1:\\n                while (g := gcd_range(lo, hi)) == 1:\\n                    lo += 1\\n                w = min(w, hi - lo + 1)\\n\\n        return n - 2 + w\\n```",
                "solutionTags": [
                    "Two Pointers",
                    "Tree",
                    "Sliding Window"
                ],
                "code": "```\\n    def minOperations(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        \\n\\t\\t# edge case 1: check existence of 1\\n        c1 = nums.count(1)\\n        if c1 > 0:\\n            return n - c1\\n        \\n\\t\\t# edge case 2: impossible if GCD of all numbers is not 1\\n        if gcd(*nums) != 1:\\n            return -1\\n        \\n\\t\\t# initialize segment tree: tree[i] = gcd(tree[k]: k + 1 has bit prefix as i + 1)\\n        tree = [0] * (n - 1) + nums\\n        for i in range(n - 2, -1, -1):\\n            tree[i] = gcd(tree[2*i + 1], tree[2*i + 2])\\n        \\n\\t\\t# helper function to calculate GCD of range nums[lo:hi]\\n        def gcd_range(lo, hi):\\n            g = nums[lo]\\n            lo += n - 1\\n            hi += n - 1 \\n            while lo < hi:\\n                if lo % 2 == 0:\\n                    g = gcd(g, tree[lo])\\n                    lo += 1\\n                if hi % 2 == 0:\\n                    hi -= 1\\n                    g = gcd(g, tree[hi])\\n                lo = (lo - 1) // 2\\n                hi = (hi - 1) // 2\\n            return g\\n        \\n        # find shortest subarray with GCD as 1\\n        w = n \\n        lo = hi = 1        \\n        g = nums[0]\\n        while hi < n:\\n            g = gcd(g, nums[hi])\\n            hi += 1\\n            if g == 1:\\n                while (g := gcd_range(lo, hi)) == 1:\\n                    lo += 1\\n                w = min(w, hi - lo + 1)\\n\\n        return n - 2 + w\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3451358,
                "title": "easy-explained-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nJust think what will happen if there is atleast one \\'1\\' in the array then simply ans will be n-(number of 1\\'s).\\n\\nif 1 is not present then we have to find 2 elements such that their gcd is 1 then count the steps to do so. final answer will be :-\\n---->  steps required + n-steps.\\n\\nSee solution for clean code.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n=nums.size();\\n        int c=count(nums.begin(), nums.end(), 1);\\n        if(c!=0) return n-c;\\n        int ans=INT_MAX;\\n\\n        for(int i=0; i<n; i++){\\n            int gcd=nums[i];\\n            for(int j=i+1; j<n; j++){\\n                gcd=__gcd(gcd, nums[j]);\\n\\n                if(gcd==1){\\n                    ans=min(ans, j-i+n-1);\\n                    break;\\n                }\\n            }\\n        }\\n        return ans==INT_MAX? -1:ans;\\n    }\\n};\\n\\n// 2 6 3 4\\n// 2 2 1 -1\\n    \\n// 6 10 15\\n// 2 1 -2\\n\\n\\n// 6 10 15\\n// 2 10 15\\n// 2 1  15\\n// 1 1 15\\n// 1 1 1\\n    \\n// 2*3\\n// 2*5\\n// 3*5\\n\\n\\n// 1*2\\n// 2*3\\n// 1*3\\n// 2*2\\n\\n\\n// 010\\n// 110\\n// 011\\n// 100\\n    \\n    \\n// 0010\\n// 1010\\n// 0110\\n// 1110\\n\\n\\n// 2 6 3 9 4\\n// 2 6 3 9 1\\n// 2 6 3 1 1\\n// 2 1 3 1 1\\n// 1 1 3 1 1\\n// 1 1 1 1 1\\n\\n\\n\\n// If the gcd is 1, then we can start iterating through the array, keeping track of the current gcd of the current element and its neighbor to the right. If the current gcd is not already 1, we keep expanding the current gcd to the right until we reach the end of the array or the current gcd becomes 1. We count the number of operations needed to make the current gcd equal to 1 and move on to the next element.\\n\\n// Finally, we return the total number of operations needed to make all elements 1.\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n=nums.size();\\n        int c=count(nums.begin(), nums.end(), 1);\\n        if(c!=0) return n-c;\\n        int ans=INT_MAX;\\n\\n        for(int i=0; i<n; i++){\\n            int gcd=nums[i];\\n            for(int j=i+1; j<n; j++){\\n                gcd=__gcd(gcd, nums[j]);\\n\\n                if(gcd==1){\\n                    ans=min(ans, j-i+n-1);\\n                    break;\\n                }\\n            }\\n        }\\n        return ans==INT_MAX? -1:ans;\\n    }\\n};\\n\\n// 2 6 3 4\\n// 2 2 1 -1\\n    \\n// 6 10 15\\n// 2 1 -2\\n\\n\\n// 6 10 15\\n// 2 10 15\\n// 2 1  15\\n// 1 1 15\\n// 1 1 1\\n    \\n// 2*3\\n// 2*5\\n// 3*5\\n\\n\\n// 1*2\\n// 2*3\\n// 1*3\\n// 2*2\\n\\n\\n// 010\\n// 110\\n// 011\\n// 100\\n    \\n    \\n// 0010\\n// 1010\\n// 0110\\n// 1110\\n\\n\\n// 2 6 3 9 4\\n// 2 6 3 9 1\\n// 2 6 3 1 1\\n// 2 1 3 1 1\\n// 1 1 3 1 1\\n// 1 1 1 1 1\\n\\n\\n\\n// If the gcd is 1, then we can start iterating through the array, keeping track of the current gcd of the current element and its neighbor to the right. If the current gcd is not already 1, we keep expanding the current gcd to the right until we reach the end of the array or the current gcd becomes 1. We count the number of operations needed to make the current gcd equal to 1 and move on to the next element.\\n\\n// Finally, we return the total number of operations needed to make all elements 1.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3451320,
                "title": "c-solution-o-n-2-approach",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        unordered_map<int,int> mp;\\n        int g = nums[0];\\n        for(auto i : nums) {mp[i]++; g = __gcd(g, i);}\\n        if(g > 1) return -1;\\n        if(mp[1] > 0) return n-mp[1];\\n        for(int i=0;i<n-1;i++) if(__gcd(nums[i], nums[i+1]) == 1) return n;\\n        int count = 1e9;\\n        for(int ind=0;ind<n;ind++){\\n            g = 0;\\n            int cnt = 0, gc = 0;\\n            for(int i=ind;i<n;i++){\\n                g = __gcd(g, nums[i]);\\n                if(g == 1){\\n                    int k = nums[i];\\n                    int j = i-1; gc = nums[j];\\n                    while(__gcd(gc,k) != 1){\\n                        j--; cnt++;\\n                        gc = __gcd(gc, nums[j]);\\n                    }\\n                    break;\\n                }\\n            }\\n            if(cnt > 0) count = min(count, cnt);\\n        }\\n        return n + count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        unordered_map<int,int> mp;\\n        int g = nums[0];\\n        for(auto i : nums) {mp[i]++; g = __gcd(g, i);}\\n        if(g > 1) return -1;\\n        if(mp[1] > 0) return n-mp[1];\\n        for(int i=0;i<n-1;i++) if(__gcd(nums[i], nums[i+1]) == 1) return n;\\n        int count = 1e9;\\n        for(int ind=0;ind<n;ind++){\\n            g = 0;\\n            int cnt = 0, gc = 0;\\n            for(int i=ind;i<n;i++){\\n                g = __gcd(g, nums[i]);\\n                if(g == 1){\\n                    int k = nums[i];\\n                    int j = i-1; gc = nums[j];\\n                    while(__gcd(gc,k) != 1){\\n                        j--; cnt++;\\n                        gc = __gcd(gc, nums[j]);\\n                    }\\n                    break;\\n                }\\n            }\\n            if(cnt > 0) count = min(count, cnt);\\n        }\\n        return n + count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3451155,
                "title": "intuitive-simulation-greedy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    int gcd(int a, int b) {\\n        if (a < b) swap(a, b);\\n        if (b == 0) return a;\\n\\n        return gcd(b, a % b);\\n    }\\n\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int len = nums.size();\\n        int ones = 0;\\n        for (auto n : nums) {\\n            ones += n == 1;\\n        }\\n\\n        \\n        bool one = false;\\n        int step = -1;\\n\\n        while (nums.size() > 1 and !one) {\\n            vector<int> next;\\n            for (int i = 0; i < nums.size() - 1; ++i) {\\n                next.push_back(gcd(nums[i], nums[i + 1]));\\n                if (next.back() == 1) {\\n                    one = true;\\n                    break;\\n                }\\n            }\\n            nums = next;\\n            ++step;\\n        }\\n\\n        if (!one) return -1;\\n\\n        return len + step - ones;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n\\n    int gcd(int a, int b) {\\n        if (a < b) swap(a, b);\\n        if (b == 0) return a;\\n\\n        return gcd(b, a % b);\\n    }\\n\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int len = nums.size();\\n        int ones = 0;\\n        for (auto n : nums) {\\n            ones += n == 1;\\n        }\\n\\n        \\n        bool one = false;\\n        int step = -1;\\n\\n        while (nums.size() > 1 and !one) {\\n            vector<int> next;\\n            for (int i = 0; i < nums.size() - 1; ++i) {\\n                next.push_back(gcd(nums[i], nums[i + 1]));\\n                if (next.back() == 1) {\\n                    one = true;\\n                    break;\\n                }\\n            }\\n            nums = next;\\n            ++step;\\n        }\\n\\n        if (!one) return -1;\\n\\n        return len + step - ones;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3450295,
                "title": "o-n-2-solution-in-cpp",
                "content": "\\n# Complexity\\n- Time complexity: ``O(n^2)``\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: ``O(1)``\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int ans = INT_MAX, cnt = 0, n = nums.size();\\n        for(int i = 0; i < n; i++){\\n            if(nums[i] == 1){\\n                cnt++;\\n            }\\n        }\\n        if(cnt > 0){\\n            return n - cnt;\\n        }\\n        for(int i = 0; i < n; ++i){\\n            int gcd = nums[i];\\n            for(int j = i + 1; j < n; ++j){\\n                gcd = __gcd(gcd, nums[j]);\\n                if(gcd == 1){\\n                    ans = min(ans, n - 1 + j - i);\\n                }\\n            }\\n        }\\n        \\n        \\n        return ans == INT_MAX? -1 : ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int ans = INT_MAX, cnt = 0, n = nums.size();\\n        for(int i = 0; i < n; i++){\\n            if(nums[i] == 1){\\n                cnt++;\\n            }\\n        }\\n        if(cnt > 0){\\n            return n - cnt;\\n        }\\n        for(int i = 0; i < n; ++i){\\n            int gcd = nums[i];\\n            for(int j = i + 1; j < n; ++j){\\n                gcd = __gcd(gcd, nums[j]);\\n                if(gcd == 1){\\n                    ans = min(ans, n - 1 + j - i);\\n                }\\n            }\\n        }\\n        \\n        \\n        return ans == INT_MAX? -1 : ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3450166,
                "title": "c-solution",
                "content": "# Code\\n```\\npublic class Solution\\n{\\n    public int MinOperations(int[] nums)\\n    {\\n        if (nums.Contains(1))\\n            return nums.Length - nums.Count(n => n == 1);\\n\\n        var result = -1;\\n\\n        for (var i = 0; i < nums.Length; i++)\\n            for (var j = i; j < nums.Length; j++)\\n            {\\n                var d = nums.Skip(i).Take(j - i + 1).Aggregate(nums[j], Gcd);\\n\\n                if (d != 1)\\n                    continue;\\n\\n                result = result == -1\\n                    ? j - i + 1\\n                    : Math.Min(result, j - i + 1);\\n            }\\n\\n        return result == -1 ? -1 : nums.Length + result - 2;\\n    }\\n\\n    private static int Gcd(int a, int b)\\n    {\\n        return b == 0 ? a : Gcd(b, a % b);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public int MinOperations(int[] nums)\\n    {\\n        if (nums.Contains(1))\\n            return nums.Length - nums.Count(n => n == 1);\\n\\n        var result = -1;\\n\\n        for (var i = 0; i < nums.Length; i++)\\n            for (var j = i; j < nums.Length; j++)\\n            {\\n                var d = nums.Skip(i).Take(j - i + 1).Aggregate(nums[j], Gcd);\\n\\n                if (d != 1)\\n                    continue;\\n\\n                result = result == -1\\n                    ? j - i + 1\\n                    : Math.Min(result, j - i + 1);\\n            }\\n\\n        return result == -1 ? -1 : nums.Length + result - 2;\\n    }\\n\\n    private static int Gcd(int a, int b)\\n    {\\n        return b == 0 ? a : Gcd(b, a % b);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3449155,
                "title": "easy-explanation-java-code-silly-observation-need-to-solve-this-problem",
                "content": "**IF YOU LIKE THE SOLUTION THEN UPVOTE IT PLEASE**\\n```\\nclass Solution {\\n    public int minOperations(int[] nums) {\\n        \\n        int n = nums.length;\\n        int ele = nums[0],numOpe = 0;\\n        \\n        //check if how many 1 present already\\n        //another check if the whole array gcd is not one atleast then not possible to make all one;\\n        for(int i = 0; i < n; i++)\\n        {\\n            ele = gcd(nums[i],ele);\\n            \\n            if(nums[i] == 1)\\n                numOpe++;\\n        }\\n        if(ele != 1)return -1;\\n        \\n        //number of not one element\\n        int notOne = n - numOpe; \\n        \\n        \\n        /*\\n        calculate no operation to make atleast single one\\n        as the n constraint 50 we can use broute force method\\n        why we use broute foce\\n        let\\'s consider one example\\n        e.g : 2,4,6,3\\n        if you computer all those ele single time then it\\n        atleast min single one operation is 3 but actually it\\'s two\\n        how? \\n        gcd(4,3) --> 1\\n        */\\n        int finalMinOperationAtleastOne = Integer.MAX_VALUE;\\n        for(int i = 0; i < n; i++)\\n        {\\n            ele = nums[i];\\n            int minOpeAtleastOne = 0;\\n            for(int j = i+1; j < n; j++)\\n            {\\n                ele = gcd(ele,nums[j]);\\n                minOpeAtleastOne++;\\n                if(ele == 1){\\n                    finalMinOperationAtleastOne = Math.min(finalMinOperationAtleastOne,minOpeAtleastOne);\\n                    break;\\n                }\\n            }\\n        }\\n        \\n       //-1 because we already calculate one those gcd during interation\\n    return finalMinOperationAtleastOne + notOne - 1;\\n        \\n    }\\n    private int gcd(int a, int b)\\n    {\\n        if(a == 0)\\n            return b;\\n        return gcd(b%a,a);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "Array",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(int[] nums) {\\n        \\n        int n = nums.length;\\n        int ele = nums[0],numOpe = 0;\\n        \\n        //check if how many 1 present already\\n        //another check if the whole array gcd is not one atleast then not possible to make all one;\\n        for(int i = 0; i < n; i++)\\n        {\\n            ele = gcd(nums[i],ele);\\n            \\n            if(nums[i] == 1)\\n                numOpe++;\\n        }\\n        if(ele != 1)return -1;\\n        \\n        //number of not one element\\n        int notOne = n - numOpe; \\n        \\n        \\n        /*\\n        calculate no operation to make atleast single one\\n        as the n constraint 50 we can use broute force method\\n        why we use broute foce\\n        let\\'s consider one example\\n        e.g : 2,4,6,3\\n        if you computer all those ele single time then it\\n        atleast min single one operation is 3 but actually it\\'s two\\n        how? \\n        gcd(4,3) --> 1\\n        */\\n        int finalMinOperationAtleastOne = Integer.MAX_VALUE;\\n        for(int i = 0; i < n; i++)\\n        {\\n            ele = nums[i];\\n            int minOpeAtleastOne = 0;\\n            for(int j = i+1; j < n; j++)\\n            {\\n                ele = gcd(ele,nums[j]);\\n                minOpeAtleastOne++;\\n                if(ele == 1){\\n                    finalMinOperationAtleastOne = Math.min(finalMinOperationAtleastOne,minOpeAtleastOne);\\n                    break;\\n                }\\n            }\\n        }\\n        \\n       //-1 because we already calculate one those gcd during interation\\n    return finalMinOperationAtleastOne + notOne - 1;\\n        \\n    }\\n    private int gcd(int a, int b)\\n    {\\n        if(a == 0)\\n            return b;\\n        return gcd(b%a,a);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3448987,
                "title": "python-solution",
                "content": "# Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf 1 is in the array, the result is length of array - number of 1.\\nElse we tries to find the smallest subset that has gcd of 1, the result would be the length of the array + length of subset - 1\\nIf we cannot find such subset, it is impossible to achieve the goal, so we return -1\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        if 1 in nums: return len(nums) - nums.count(1)\\n        self.res = [0, 100]\\n        def dfs(st, i, val):\\n            if i - st >= self.res[1] - self.res[0]:\\n                return\\n            if val == 1:\\n                if self.res[1] - self.res[0] > (i - st):\\n                    self.res = [st, i]\\n                return\\n            if i == len(nums): return\\n            dfs(st, i+1, math.gcd(val, nums[i]))\\n        \\n        for i in range(len(nums)):\\n            dfs(i, i+1, nums[i])\\n        \\n        return -1 if self.res == [0, 100] else len(nums) + (self.res[1] - self.res[0] - 2)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        if 1 in nums: return len(nums) - nums.count(1)\\n        self.res = [0, 100]\\n        def dfs(st, i, val):\\n            if i - st >= self.res[1] - self.res[0]:\\n                return\\n            if val == 1:\\n                if self.res[1] - self.res[0] > (i - st):\\n                    self.res = [st, i]\\n                return\\n            if i == len(nums): return\\n            dfs(st, i+1, math.gcd(val, nums[i]))\\n        \\n        for i in range(len(nums)):\\n            dfs(i, i+1, nums[i])\\n        \\n        return -1 if self.res == [0, 100] else len(nums) + (self.res[1] - self.res[0] - 2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3448477,
                "title": "clean-and-explanatory-code-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMain intention is to make anyhow one element of the array as 1 which will help make all the elements as 1.\\n\\nIF GCD of complete array is not 1, then its impossible to have a element be made 1 which will make entire 1..\\nIf the array already consists of 1s, then no of operations = (n - no. of ones)\\n\\nIf no 1s are present, then we have to perform operations to make 1 and then total operations = **\"operations to make 1\"** + (n - 1)operations to make rest of the normal elements as 1. \\n\\nFor **\"operations to make 1\"**,\\nWe find the minimum size array which has a gcd of 1. The min size array will result in less operations to make a element 1. Then the rest no of operations need to make other operations 1 = (n - 1).\\nNote:- The -1 is because of the element which has been made 1 by gcd operations in the minimum size array.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBrute Force since constraints allow us\\n# Complexity\\n- Time complexity: O(N*3)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        int ones = 0, val = 0;\\n        for(auto ele: nums)\\n        {\\n            val = __gcd(val, ele);\\n            if(ele == 1)\\n                ones++;\\n        }\\n        \\n        //base cases of impossibility\\n        if(val != 1)\\n            return -1;\\n        \\n        //base case of some 1s being already present\\n        if(ones != 0)\\n            return n - ones;\\n        \\n        //if no 1s are present, and we need to make all elements 1\\n        int min_sz = 100;\\n        for(int i = 0; i < n; i++)\\n            for(int j = i; j < n; j++)\\n            {\\n                int el = 0;\\n                for(int k = i; k <= j; k++)\\n                {\\n                    el = __gcd(el, nums[k]);\\n                }\\n                if(el == 1)\\n                    min_sz = min(min_sz, j - i + 1);\\n            }\\n        \\n        return (min_sz - 1) + (n - 1);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        int ones = 0, val = 0;\\n        for(auto ele: nums)\\n        {\\n            val = __gcd(val, ele);\\n            if(ele == 1)\\n                ones++;\\n        }\\n        \\n        //base cases of impossibility\\n        if(val != 1)\\n            return -1;\\n        \\n        //base case of some 1s being already present\\n        if(ones != 0)\\n            return n - ones;\\n        \\n        //if no 1s are present, and we need to make all elements 1\\n        int min_sz = 100;\\n        for(int i = 0; i < n; i++)\\n            for(int j = i; j < n; j++)\\n            {\\n                int el = 0;\\n                for(int k = i; k <= j; k++)\\n                {\\n                    el = __gcd(el, nums[k]);\\n                }\\n                if(el == 1)\\n                    min_sz = min(min_sz, j - i + 1);\\n            }\\n        \\n        return (min_sz - 1) + (n - 1);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3448373,
                "title": "simple-gcd-concept-solution",
                "content": "# Intuition\\n```\\n2 consecutive numbers gcd=1;__gcd(5,6)=1, __gcd(45,46)=1;\\n__gcd(1,any number)=1;\\n```\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int cnt=0,maxi=INT_MAX;\\n        for(int x:nums){\\n            if(x==1)cnt++;\\n        }\\n        if(cnt>0){\\n            return nums.size()-cnt;\\n        }\\n        for(int i=0;i<nums.size();i++){\\n            int last=nums[i];\\n            for(int j=i+1;j<nums.size();j++){\\n                last=__gcd(last,nums[j]);\\n                if(last==1){\\n                    maxi=min(maxi,j-i);\\n                    break;\\n                }\\n            }\\n        }\\n        if(maxi!=INT_MAX){\\n            return maxi+nums.size()-1;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n2 consecutive numbers gcd=1;__gcd(5,6)=1, __gcd(45,46)=1;\\n__gcd(1,any number)=1;\\n```\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int cnt=0,maxi=INT_MAX;\\n        for(int x:nums){\\n            if(x==1)cnt++;\\n        }\\n        if(cnt>0){\\n            return nums.size()-cnt;\\n        }\\n        for(int i=0;i<nums.size();i++){\\n            int last=nums[i];\\n            for(int j=i+1;j<nums.size();j++){\\n                last=__gcd(last,nums[j]);\\n                if(last==1){\\n                    maxi=min(maxi,j-i);\\n                    break;\\n                }\\n            }\\n        }\\n        if(maxi!=INT_MAX){\\n            return maxi+nums.size()-1;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3447564,
                "title": "simple-brute-force-with-explanation-using-gcd-10-line-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int countOne=0;\\n        for(auto x: nums){\\n            if(x==1){\\n               countOne++;\\n            }\\n        }\\n        if(countOne>0){\\n             // 1 1 1 8 3 7\\n            return (nums.size() - countOne);\\n        }else{\\n            // 3 4 2 6\\n            // 1,1,1,1 8 10\\n            /// check if any pair gcd become 1;\\n            int ans=INT_MAX;\\n            int n = nums.size();\\n            for(int i=0;i<n-1;i++){\\n                int gcd = nums[i];\\n                for(int j=i+1;j<n;j++){\\n                    gcd = __gcd(gcd,nums[j]);\\n                    if(gcd==1){\\n                        // if means we start from the index i , and till jth index and which will make one value as 1 , in the\\n                        // operation of j-i, and then we will use this 1 to make all n-1 to become 1;\\n                        ans=min(ans,j-i+(n-1));\\n                    }\\n                }\\n            }\\n             if(ans==INT_MAX) ans=-1;\\n            return ans;\\n            \\n        }\\n    }\\n};\\n\\n// 6,10,15\\n// 6,2,15\\n// 6,2,1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int countOne=0;\\n        for(auto x: nums){\\n            if(x==1){\\n               countOne++;\\n            }\\n        }\\n        if(countOne>0){\\n             // 1 1 1 8 3 7\\n            return (nums.size() - countOne);\\n        }else{\\n            // 3 4 2 6\\n            // 1,1,1,1 8 10\\n            /// check if any pair gcd become 1;\\n            int ans=INT_MAX;\\n            int n = nums.size();\\n            for(int i=0;i<n-1;i++){\\n                int gcd = nums[i];\\n                for(int j=i+1;j<n;j++){\\n                    gcd = __gcd(gcd,nums[j]);\\n                    if(gcd==1){\\n                        // if means we start from the index i , and till jth index and which will make one value as 1 , in the\\n                        // operation of j-i, and then we will use this 1 to make all n-1 to become 1;\\n                        ans=min(ans,j-i+(n-1));\\n                    }\\n                }\\n            }\\n             if(ans==INT_MAX) ans=-1;\\n            return ans;\\n            \\n        }\\n    }\\n};\\n\\n// 6,10,15\\n// 6,2,15\\n// 6,2,1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3447558,
                "title": "python-3-find-shortest-subarray-with-gcd-1",
                "content": "```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        \\n        n = len(nums)      \\n            \\n        vis = deque()\\n        \\n        def check(cands):\\n            tmp = cands[0]\\n            for i in range(1, len(cands)):\\n                tmp = math.gcd(tmp, cands[i])\\n                if tmp == 1: return True\\n            return tmp == 1\\n                \\n        \\n        size = n + 1\\n        for j in range(len(nums)):\\n            vis.append(nums[j])\\n            while vis and check(vis):\\n                size = min(size, len(vis))                \\n                vis.popleft()\\n        \\n\\t\\t# if 1 already existed, then just need to change non-1 elements\\n        if size == 1:\\n            return sum(num > 1 for num in nums)\\n\\t\\t# not able to find the subarray\\n        elif size == n + 1:\\n            return -1\\n        # all element > 1 but could find a subarray\\n\\t\\t# the ops need to transform the subarray to have at least one 1 is (size - 1), and then transofrm the rest of elements is (n - 1)\\n\\t\\telse:\\n            return n - 1 + size - 1\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        \\n        n = len(nums)      \\n            \\n        vis = deque()\\n        \\n        def check(cands):\\n            tmp = cands[0]\\n            for i in range(1, len(cands)):\\n                tmp = math.gcd(tmp, cands[i])\\n                if tmp == 1: return True\\n            return tmp == 1\\n                \\n        \\n        size = n + 1\\n        for j in range(len(nums)):\\n            vis.append(nums[j])\\n            while vis and check(vis):\\n                size = min(size, len(vis))                \\n                vis.popleft()\\n        \\n\\t\\t# if 1 already existed, then just need to change non-1 elements\\n        if size == 1:\\n            return sum(num > 1 for num in nums)\\n\\t\\t# not able to find the subarray\\n        elif size == n + 1:\\n            return -1\\n        # all element > 1 but could find a subarray\\n\\t\\t# the ops need to transform the subarray to have at least one 1 is (size - 1), and then transofrm the rest of elements is (n - 1)\\n\\t\\telse:\\n            return n - 1 + size - 1\\n",
                "codeTag": "Java"
            },
            {
                "id": 3447549,
                "title": "python-simple-maths",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minOperations(self, nums):\\n        n, ones, diff = len(nums), nums.count(1), float(\"inf\")\\n\\n        if ones: return n-ones\\n\\n        for i in range(n):\\n            val = nums[i]\\n            for j in range(i+1,n):\\n                val = gcd(val,nums[j])\\n                if val == 1: diff = min(diff,j-i+1)\\n\\n        return -1 if diff == float(\"inf\") else diff + n - 2\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums):\\n        n, ones, diff = len(nums), nums.count(1), float(\"inf\")\\n\\n        if ones: return n-ones\\n\\n        for i in range(n):\\n            val = nums[i]\\n            for j in range(i+1,n):\\n                val = gcd(val,nums[j])\\n                if val == 1: diff = min(diff,j-i+1)\\n\\n        return -1 if diff == float(\"inf\") else diff + n - 2\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3447440,
                "title": "my-thought-process-to-approach-it",
                "content": "Let\\'s estimate the lower/upper bound of the minimum number of operations to see\\nwhat happens.\\n\\n## Lower Bound\\n\\nIf we are lucky, each operation will convert a number to 1, then the lower bound\\nis `n = length(nums)`, or more precisely, `n - count(1, nums)`.\\nWhen this happens?\\nObviously, if we have 1 in the input array, we can spread it to the whole array.\\n\\nSo we have this pseudocode:\\n\\n```python\\ndef solve(nums: list[int]):\\n    if nums.contains(1):\\n        return nums.len() - nums.count(1)\\n    else:\\n        ...\\n```\\n\\n## Upper Bound\\n\\nThen we estimate the upper bound. The case there is no 1.\\n\\nThings start to become complex.\\n\\nLet us start with a simple example.\\nWe have two numbers: `[a, b]`, let `g = gcd(a, b)`.\\nWe might have this operation sequence:\\n\\n```\\na1 <- g\\nb1 <- gcd(a1, b) = gcd(g, b) = g\\na2 <- gcd(a1, b1) = gcd(g, g) = g\\n...\\n```\\n\\nYou might noticed that more operations are meaningless, because\\nthe result is always `g`, that means we can do at most 2 operations for 2\\nelements array, if it will succeed to make them to be 1.\\n\\nIt\\'s a good sign.\\nLet\\'s see what happens for 3 elements array `[a, b, c]`.\\nThis is a possible operation sequence:\\n\\n```\\na1 <- gcd(a, b)\\nb1 <- gcd(a1, b) = gcd(gcd(a, b), b) = gcd(a, b)\\nc1 <- gcd(b1, c) = gcd(gcd(a, b), c) = gcd(a, b, c)\\na2 <- gcd(a1, b1) = gcd(a, b)\\nb2 <- gcd(b2, c1) = gcd(a, b, c)\\nc2 <- gcd(b2, c1) = gcd(a, b, c)\\n...\\n```\\n\\nLook what happens! the new `a` will always be one of `gcd(a, b)`, `gcd(a, b, c)`\\nthe new `b` will always be one of `gcd(a, b)`, `gcd(b, c)`, or `gcd(a, b, c)`.\\n\\nIf these gcd values don\\'t contain 1, then it fails. Otherwise, we can do at most\\n2 operations to make the array appears 1.\\n\\nFinally, we can do at most `n-1` operations to make the `n` length array appears 1.\\n\\n## Generalize\\n\\nIn this case, suppose `nums[i]` will be the first 1, it might be the values\\n\\n```\\ngcd(nums[i], nums[i+1])\\ngcd(nums[i], nums[i+1], nums[i+2])\\n...\\ngcd(nums[i-1], nums[i])\\ngcd(nums[i-2], nums[i-1], nums[i])\\n...\\ngcd(nums[i-1], nums[i], nums[i+1])\\n...\\n```\\n\\nAny gcd of a subarray that contains `nums[i]` might be the first 1.\\n\\nWe can enumerate all subarrays to find the minimum length subarray that gcd is 1.\\n\\nFinally, the pseudocode:\\n\\n```python\\ndef solve(nums: list[int]):\\n    if nums.contains(1):\\n        return nums.len() - nums.count(1)\\n    else:\\n        min_len = inf\\n        for subarray in subarrays_of(nums):\\n            if gcd(subarray) == 1:\\n                min_len = min(min_len, subarray.len())\\n        if min_len == inf:\\n            return -1\\n        else:\\n            return (nums.len() - 1) + (min_len - 1)\\n```\\n\\n# Code\\n\\n```scheme\\n(define (min-operations nums)\\n  (define inf #e1e9)\\n  (define min-len inf)\\n  (define n (length nums))\\n  (for* ([j (inclusive-range 1 n)]\\n         [i j])\\n    (when (= 1 (apply gcd (sublist nums i j)))\\n      (set! min-len (min min-len (- j i)))))\\n\\n  (if (= min-len inf)\\n      -1\\n      (+ (- n (max 1 (count (\\u03BB (x) (= x 1)) nums)))\\n         (- min-len 1))))\\n\\n(define (sublist lst from to)\\n  (drop (take lst to) from))\\n\\n```\\n\\n## Conclusion\\n\\nThe only important idea is to estimate the space of the result.\\n\\nUpvote if you like it.\\n",
                "solutionTags": [
                    "Racket"
                ],
                "code": "```python\\ndef solve(nums: list[int]):\\n    if nums.contains(1):\\n        return nums.len() - nums.count(1)\\n    else:\\n        ...\\n```\n```\\na1 <- g\\nb1 <- gcd(a1, b) = gcd(g, b) = g\\na2 <- gcd(a1, b1) = gcd(g, g) = g\\n...\\n```\n```\\na1 <- gcd(a, b)\\nb1 <- gcd(a1, b) = gcd(gcd(a, b), b) = gcd(a, b)\\nc1 <- gcd(b1, c) = gcd(gcd(a, b), c) = gcd(a, b, c)\\na2 <- gcd(a1, b1) = gcd(a, b)\\nb2 <- gcd(b2, c1) = gcd(a, b, c)\\nc2 <- gcd(b2, c1) = gcd(a, b, c)\\n...\\n```\n```\\ngcd(nums[i], nums[i+1])\\ngcd(nums[i], nums[i+1], nums[i+2])\\n...\\ngcd(nums[i-1], nums[i])\\ngcd(nums[i-2], nums[i-1], nums[i])\\n...\\ngcd(nums[i-1], nums[i], nums[i+1])\\n...\\n```\n```python\\ndef solve(nums: list[int]):\\n    if nums.contains(1):\\n        return nums.len() - nums.count(1)\\n    else:\\n        min_len = inf\\n        for subarray in subarrays_of(nums):\\n            if gcd(subarray) == 1:\\n                min_len = min(min_len, subarray.len())\\n        if min_len == inf:\\n            return -1\\n        else:\\n            return (nums.len() - 1) + (min_len - 1)\\n```\n```scheme\\n(define (min-operations nums)\\n  (define inf #e1e9)\\n  (define min-len inf)\\n  (define n (length nums))\\n  (for* ([j (inclusive-range 1 n)]\\n         [i j])\\n    (when (= 1 (apply gcd (sublist nums i j)))\\n      (set! min-len (min min-len (- j i)))))\\n\\n  (if (= min-len inf)\\n      -1\\n      (+ (- n (max 1 (count (\\u03BB (x) (= x 1)) nums)))\\n         (- min-len 1))))\\n\\n(define (sublist lst from to)\\n  (drop (take lst to) from))\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3447413,
                "title": "c-math-easy-understanding-n-2",
                "content": "shortest subarray having gcd==1\\n```\\nclass Solution {\\npublic:\\n    int gcd(int a,int b){\\n        \\n        int maxi=1;\\n        for(int i=1;i<=min(a,b);i++){\\n            if(a%i==0 && b%i==0){\\n                maxi=max(maxi,i);\\n            }\\n        }\\n        return maxi;\\n    }\\n    int minOperations(vector<int>& nums) {\\n        \\n        bool flag=0;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            if(nums[i]%2!=0){\\n                flag=1;\\n                break;\\n            }\\n        }\\n        if(flag==0){\\n            return -1;\\n        }\\n        int count=0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==1){\\n                count++;\\n            }\\n        }\\n        if(count>=1){\\n            return n-count;\\n        }\\n        flag=0;\\n        for(int i=0;i<n-1;i++){\\n            \\n            if(gcd(nums[i],nums[i+1])==1){\\n                flag=1;\\n                break;\\n            }\\n        }\\n        if(flag==1){\\n            return n;\\n        }\\n        int mini=1e9;\\n        for(int i=0;i<n;i++){\\n            int g=nums[i];\\n            for(int j=i+1;j<n;j++){\\n                g=gcd(g,nums[j]);\\n                if(g==1){\\n                    mini=min(mini,j-i+n-1);\\n                }\\n            }\\n        }\\n        return mini>=1e9? -1:mini;\\n    }\\n};",
                "solutionTags": [
                    "Math"
                ],
                "code": "class Solution {\\npublic:\\n    int gcd(int a,int b){\\n        \\n        int maxi=1;\\n        for(int i=1;i<=min(a,b);i++){\\n            if(a%i==0 && b%i==0){\\n                maxi=max(maxi,i);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3446670,
                "title": "simple-easy-to-understand-solution-with-explanation-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCase 1: If GCD of all the numbers in the array is greater than 1 then it is impossible to make elements equal to 1.\\nCalculate gcdValue by taking GCD of all numbers. \\nIf gcdValue > 1 then return -1.\\n\\nCase 2: If we have atleast one 1 value in the array then using this values we can make the entire array to 1 as GCD(a, 1) = 1.\\nif we have x number of ones in the array then we can make the array to 1 in N-x operations where N is the number of elements in the array.\\n\\nCase 3: If don\\'t have any 1 in the array then we will find the subarray with minimum no. of elements which will give the GCD as 1. Now that subarray will take j-i operations to make one integer in the array as 1. Once we have 1 in the array we can make the remaining array to 1 in N-1 operations. So our total no. of operations will be (j-i) + (N-1).\\n\\n\\n# Complexity\\n- Time complexity: O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int gcd(int A, int B) {\\n        if(B == 0) {\\n            return A;\\n        }\\n        return gcd(B, A%B);\\n    }\\n    public int minOperations(int[] nums) {\\n        // Intuition - \\n        // Case 1: If GCD of all the numbers in the array is greater than 1 then it is impossible to make elements equal to 1.\\n        // Calculate gcdValue by taking GCD of all numbers. \\n        // If gcdValue > 1 then return -1.\\n\\n        // Case 2: If we have atleast one 1 value in the array then using this values we can make the entire array to 1 as GCD(a, 1) = 1.\\n        // if we have x number of ones in the array then we can make the array to 1 in N-x operations where N is the number of elements in the array.\\n\\n        // Case 3: If don\\'t have any 1 in the array then we will find the subarray with minimum no. of elements which will give the GCD as 1. Now that subarray will take j-i operations to make one integer in the array as 1. Once we have 1 in the array we can make the remaining array to 1 in N-1 operations. So our total no. of operations will be (j-i) + (N-1).\\n\\n\\n        // Time Complexity = O(N^2)\\n        // Space Complexity = O(1)\\n\\n\\n        int N = nums.length;\\n        int gcdValue = nums[0];\\n        int ones = 0;\\n        if(gcdValue == 1) {\\n            ones++;\\n        } \\n        for(int i = 1; i < N; i++) {\\n            if(nums[i] == 1) {\\n                ones++;\\n            }\\n            if(gcdValue > 1) {\\n                gcdValue = gcd(gcdValue, nums[i]);\\n            }\\n        }\\n        if(gcdValue > 1) {\\n            return -1;\\n        }\\n        if(ones > 0) {\\n            return N - ones;\\n        }\\n        int ans = Integer.MAX_VALUE;\\n        for(int i = 0; i < N; i++) {\\n            int value = nums[i];\\n            for(int j = i+1; j < N; j++) {\\n                value = gcd(value, nums[j]);\\n                if(value == 1) {\\n                    ans = Math.min(ans, (j-i) + (N-1));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int gcd(int A, int B) {\\n        if(B == 0) {\\n            return A;\\n        }\\n        return gcd(B, A%B);\\n    }\\n    public int minOperations(int[] nums) {\\n        // Intuition - \\n        // Case 1: If GCD of all the numbers in the array is greater than 1 then it is impossible to make elements equal to 1.\\n        // Calculate gcdValue by taking GCD of all numbers. \\n        // If gcdValue > 1 then return -1.\\n\\n        // Case 2: If we have atleast one 1 value in the array then using this values we can make the entire array to 1 as GCD(a, 1) = 1.\\n        // if we have x number of ones in the array then we can make the array to 1 in N-x operations where N is the number of elements in the array.\\n\\n        // Case 3: If don\\'t have any 1 in the array then we will find the subarray with minimum no. of elements which will give the GCD as 1. Now that subarray will take j-i operations to make one integer in the array as 1. Once we have 1 in the array we can make the remaining array to 1 in N-1 operations. So our total no. of operations will be (j-i) + (N-1).\\n\\n\\n        // Time Complexity = O(N^2)\\n        // Space Complexity = O(1)\\n\\n\\n        int N = nums.length;\\n        int gcdValue = nums[0];\\n        int ones = 0;\\n        if(gcdValue == 1) {\\n            ones++;\\n        } \\n        for(int i = 1; i < N; i++) {\\n            if(nums[i] == 1) {\\n                ones++;\\n            }\\n            if(gcdValue > 1) {\\n                gcdValue = gcd(gcdValue, nums[i]);\\n            }\\n        }\\n        if(gcdValue > 1) {\\n            return -1;\\n        }\\n        if(ones > 0) {\\n            return N - ones;\\n        }\\n        int ans = Integer.MAX_VALUE;\\n        for(int i = 0; i < N; i++) {\\n            int value = nums[i];\\n            for(int j = i+1; j < N; j++) {\\n                value = gcd(value, nums[j]);\\n                if(value == 1) {\\n                    ans = Math.min(ans, (j-i) + (N-1));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446481,
                "title": "easy-simple-solution-c-code-c-c",
                "content": "# Intuition\\nTo find Minimum Number of Operations to Make All Array Elements Equal to 1\\n\\n# Approach\\nFirst find the total  number of 1 in the nums vector. The answer will be size(nums)- number of ones.\\n\\n\\nIf  1 not present then find if there exist a pair of consecutive coprime numbers. The answer in that case will also be size(nums).\\n\\n\\nNow make each element of nums from i=0 to n-2 be nums[i]=gcd(nums[i],nums[i+1]). Do this till it is further not possible or a 1 is found in the nums vector. Count the number of times this operation is performed. At the end if 1 is found then the answer will be        size(nums)-1+count(number of operations).\\n\\nOtherwise the final answer will be -1.\\n# Code\\n```\\nclass Solution {\\npublic:   \\n    int minOperations(vector<int>& nums) {\\n        int prime=0;\\n        int n=nums.size();\\n        map<int,int> mpp;\\n        for(int i=0;i<n;i++)\\n        {\\n            mpp[nums[i]]++;\\n        }\\n        if(mpp[1]==n)\\n        {\\n            return 0;\\n        }\\n        if(mpp[1]>0)\\n        {\\n            return (n-mpp[1]);\\n        }\\n        int p=0;\\n        for(int i=0;i<n-1;i++)\\n        {\\n            if(__gcd(nums[i],nums[i+1])==1)\\n            {   \\n                p++;\\n            }\\n        }\\n        if(p>0)\\n        {\\n            return n;\\n        }\\n        \\n        \\n        \\n        \\n        \\n\\n        bool test=true;\\n        int count=0, o=0;\\n        while(test)\\n        {\\n            vector<int> prev=nums;\\n            \\n           \\n            for(int i=0;i<n-1;i++)\\n            {\\n                nums[i]=__gcd(nums[i],nums[i+1]);\\n            }\\n            \\n             o=0;\\n            for(int i=0;i<n;i++)\\n            {\\n                if(nums[i]==1)\\n                {\\n                    o++;\\n                }\\n            }\\n            \\n            \\n            \\n            if(nums==prev)\\n            {\\n                test=false;\\n                break;\\n            }\\n            count++;\\n            if(o>0)\\n            {\\n                break;\\n            }\\n            prev=nums;\\n        }\\n      \\n        int one=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]==1)\\n            {\\n                one++;\\n            }\\n        }\\n        if(one>0)\\n        return (n-1+count);\\n        \\n         return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:   \\n    int minOperations(vector<int>& nums) {\\n        int prime=0;\\n        int n=nums.size();\\n        map<int,int> mpp;\\n        for(int i=0;i<n;i++)\\n        {\\n            mpp[nums[i]]++;\\n        }\\n        if(mpp[1]==n)\\n        {\\n            return 0;\\n        }\\n        if(mpp[1]>0)\\n        {\\n            return (n-mpp[1]);\\n        }\\n        int p=0;\\n        for(int i=0;i<n-1;i++)\\n        {\\n            if(__gcd(nums[i],nums[i+1])==1)\\n            {   \\n                p++;\\n            }\\n        }\\n        if(p>0)\\n        {\\n            return n;\\n        }\\n        \\n        \\n        \\n        \\n        \\n\\n        bool test=true;\\n        int count=0, o=0;\\n        while(test)\\n        {\\n            vector<int> prev=nums;\\n            \\n           \\n            for(int i=0;i<n-1;i++)\\n            {\\n                nums[i]=__gcd(nums[i],nums[i+1]);\\n            }\\n            \\n             o=0;\\n            for(int i=0;i<n;i++)\\n            {\\n                if(nums[i]==1)\\n                {\\n                    o++;\\n                }\\n            }\\n            \\n            \\n            \\n            if(nums==prev)\\n            {\\n                test=false;\\n                break;\\n            }\\n            count++;\\n            if(o>0)\\n            {\\n                break;\\n            }\\n            prev=nums;\\n        }\\n      \\n        int one=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]==1)\\n            {\\n                one++;\\n            }\\n        }\\n        if(one>0)\\n        return (n-1+count);\\n        \\n         return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446384,
                "title": "tricky-math-solution-could-not-able-to-solve-in-contest-but-able-to-solve-in-15mins-after-the-conte",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWith my experience I can say that GCD problems are bit complicated but after getting the logic it is pretty straight forward. Try to solve it with cool mind.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIn these problem we have 2 scenarious.\\n- Answer is -1\\n    - We should perform gcd for all n elements. If the gcd>1 then we can say that we can\\'t make all elements to 1. so the answer would be -1.\\n- Answer exists\\n    - For each pair, we calculate the greatest common divisor (GCD) of the pair using the __gcd function, which is a built-in function in C++ that calculates the GCD of two integers. It continues to calculate the GCD of the pair with the previous elements until the GCD is equal to 1. When the GCD becomes 1, the function records the length of the subarray between the two elements as the current answer, and then breaks out of the loop.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& v) {\\n        int n=v.size();\\n        int f=0,c=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(v[i]==1)\\n                f=1;\\n            if(v[i]!=1)\\n                c++;\\n        }\\n        if(f==1)\\n            return c;\\n        int ans=500;\\n        for(int i=1;i<n;i++)\\n        {\\n            int j=i-1,g=v[i];\\n            while(j>=0)\\n            {\\n                g=__gcd(g,v[j]);\\n                if(g==1)\\n                {\\n                    ans=min(ans,i-j);\\n                    break;\\n                }\\n                j--;\\n            }\\n        }\\n        if(ans==500)\\n            return -1;\\n        return n+ans-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& v) {\\n        int n=v.size();\\n        int f=0,c=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(v[i]==1)\\n                f=1;\\n            if(v[i]!=1)\\n                c++;\\n        }\\n        if(f==1)\\n            return c;\\n        int ans=500;\\n        for(int i=1;i<n;i++)\\n        {\\n            int j=i-1,g=v[i];\\n            while(j>=0)\\n            {\\n                g=__gcd(g,v[j]);\\n                if(g==1)\\n                {\\n                    ans=min(ans,i-j);\\n                    break;\\n                }\\n                j--;\\n            }\\n        }\\n        if(ans==500)\\n            return -1;\\n        return n+ans-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446378,
                "title": "easy-c-solution-in-three-cases",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**First Case**: If number of ones in array is non-zero than answer will (arr.size()-count of ones).\\n**Second Case**: As length of array is small. Then travel all subarray and find if gcd of that subarray is one. If its gcd is one then you can make any one element of that subarray as one in (subarray.size()-1) steps by taking repetative gcd with  any one single element. And take minimum sized subarray. Now with that element as one you can make other element as one in (array.size()-1) steps. So final answer will be((MinimumSizedSubarray.size()-1)+(array.size()-1)). \\n**Third Case**: if you cannot find any subarray with gcd equals one then return -1;\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n         int n=nums.size(),ans=INT_MAX,cnt=0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==1){\\n                cnt++;\\n            }\\n     int gc=0;\\n        for(int j=i;j<n;j++){\\n            gc=__gcd(gc,nums[j]);\\n        \\n            if(gc==1){\\n                ans=min(ans,j-i+1);\\n            }\\n        }\\n        }\\n        if(cnt>0){\\n            return n-cnt;\\n        }\\n        if(ans==INT_MAX){\\n            return -1;\\n        }\\n        long long int res=n+ans-2;\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n         int n=nums.size(),ans=INT_MAX,cnt=0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==1){\\n                cnt++;\\n            }\\n     int gc=0;\\n        for(int j=i;j<n;j++){\\n            gc=__gcd(gc,nums[j]);\\n        \\n            if(gc==1){\\n                ans=min(ans,j-i+1);\\n            }\\n        }\\n        }\\n        if(cnt>0){\\n            return n-cnt;\\n        }\\n        if(ans==INT_MAX){\\n            return -1;\\n        }\\n        long long int res=n+ans-2;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446339,
                "title": "simple-c-solution-intutive",
                "content": "```\\nclass Solution {\\npublic:\\n\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size();\\n\\n        int cnt = count(nums.begin(),nums.end(),1);\\n        if(cnt != 0) return n - cnt;\\n\\n        int res = INT_MAX;\\n        for(int i=0; i<nums.size(); i++){\\n            int x = nums[i];\\n            for(int j= i+1; j<nums.size(); j++){\\n                x = __gcd(x,nums[j]);\\n                if(x == 1){\\n                    res = min(res,(j-i)+(n-1)); // Min steps req to make GCD of this subarray 1 + (n-1) steps to make the remaining elment equals to 1.\\n                }\\n            }\\n        }\\n\\n        return res == INT_MAX ? -1 : res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size();\\n\\n        int cnt = count(nums.begin(),nums.end(),1);\\n        if(cnt != 0) return n - cnt;\\n\\n        int res = INT_MAX;\\n        for(int i=0; i<nums.size(); i++){\\n            int x = nums[i];\\n            for(int j= i+1; j<nums.size(); j++){\\n                x = __gcd(x,nums[j]);\\n                if(x == 1){\\n                    res = min(res,(j-i)+(n-1)); // Min steps req to make GCD of this subarray 1 + (n-1) steps to make the remaining elment equals to 1.\\n                }\\n            }\\n        }\\n\\n        return res == INT_MAX ? -1 : res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446315,
                "title": "my-solution",
                "content": "```\\n/**\\n * Time Complexity: O(n * n)\\n * Space Complexity: O(1)\\n * where `n` is the length of the vector `nums`\\n */\\nclass Solution {\\n public:\\n  int minOperations(const vector<int> &nums) {\\n    constexpr int one = 1;\\n    const int n = static_cast<int>(nums.size());\\n    int ones = 0;\\n    int min_length = n + 1;\\n    for (int start = 0; start < n; ++start) {\\n      if (nums[start] == one) {\\n        ++ones;\\n      }\\n      \\n      int g = nums[start];\\n      int end = start + 1;\\n      for (; ones == 0 && end < min(start + min_length, n); ++end) {\\n        g = gcd(g, nums[end]);\\n        if (g == 1) {\\n          break;\\n        }\\n      }\\n      if (g == one) {\\n        min_length = end - start + 1;\\n      }\\n    }\\n    \\n    return min_length == n + 1 ? -1 : (min_length - 1) + (n - 1) - ones;\\n  }\\n  \\n private:\\n  int gcd(const int a, const int b) {\\n    if (a == 0) {\\n      return b;\\n    }\\n    return gcd(b % a, a);\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Time Complexity: O(n * n)\\n * Space Complexity: O(1)\\n * where `n` is the length of the vector `nums`\\n */\\nclass Solution {\\n public:\\n  int minOperations(const vector<int> &nums) {\\n    constexpr int one = 1;\\n    const int n = static_cast<int>(nums.size());\\n    int ones = 0;\\n    int min_length = n + 1;\\n    for (int start = 0; start < n; ++start) {\\n      if (nums[start] == one) {\\n        ++ones;\\n      }\\n      \\n      int g = nums[start];\\n      int end = start + 1;\\n      for (; ones == 0 && end < min(start + min_length, n); ++end) {\\n        g = gcd(g, nums[end]);\\n        if (g == 1) {\\n          break;\\n        }\\n      }\\n      if (g == one) {\\n        min_length = end - start + 1;\\n      }\\n    }\\n    \\n    return min_length == n + 1 ? -1 : (min_length - 1) + (n - 1) - ones;\\n  }\\n  \\n private:\\n  int gcd(const int a, const int b) {\\n    if (a == 0) {\\n      return b;\\n    }\\n    return gcd(b % a, a);\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446177,
                "title": "best-clean-c-code-greedy",
                "content": "# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n### PLease Upvote if u liked my Solution\\uD83E\\uDD17\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size(),count=0,count_1=0,x=nums[0],mini=n;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==1)\\n                count_1++;\\n            x=__gcd(x,nums[i]);\\n        }\\n        if(count_1 != 0)\\n            return n - count_1;\\n        if(x != 1)\\n            return -1;\\n        for(int i=0;i<n-1;i++){\\n            x=nums[i];\\n            for(int j=i+1;j<n;j++){\\n                x=__gcd(x,nums[j]);\\n                if(x == 1){\\n                    mini = min(mini,j-i-1);\\n                    break;\\n                }\\n            }\\n        }\\n        return n + mini;\\n    }\\n};\\n```\\n![e2515d84-99cf-4499-80fb-fe458e1bbae2_1678932606.8004954.png](https://assets.leetcode.com/users/images/05af26e6-16dc-4493-aaf4-0d1cee2faea2_1682228417.2335925.png)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size(),count=0,count_1=0,x=nums[0],mini=n;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==1)\\n                count_1++;\\n            x=__gcd(x,nums[i]);\\n        }\\n        if(count_1 != 0)\\n            return n - count_1;\\n        if(x != 1)\\n            return -1;\\n        for(int i=0;i<n-1;i++){\\n            x=nums[i];\\n            for(int j=i+1;j<n;j++){\\n                x=__gcd(x,nums[j]);\\n                if(x == 1){\\n                    mini = min(mini,j-i-1);\\n                    break;\\n                }\\n            }\\n        }\\n        return n + mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446131,
                "title": "simple-very-easy-normal-brute-force-solution-gcd-c",
                "content": "# Complexity\\n- Time complexity: $$O(n^2)$$\\n\\n- Space complexity: $$O(1)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int minOperations(vector<int>& nums) {\\n        int n=nums.size();\\n        int ones = 0;\\n        int ans=INT_MAX;\\n\\n        for(int i=0; i<n; i++){\\n            if(nums[i]==1) ones++;\\n        }\\n        if(ones>0) return n-ones;\\n        \\n        for(int i=0; i<n; i++){\\n            for(int j=i+1; j<n; j++){\\n                nums[i]= __gcd(nums[i], nums[j]);\\n                if(nums[i]==1){\\n                    ans=min(ans,j-i);\\n                    break;\\n                }\\n            }\\n            if(nums[i]!=1) break;\\n        }\\n\\n        if(ans==INT_MAX) return -1;\\n        return n-1+ans;\\n    }\\n};\\n\\n```\\n\\n# Kindly, it you got the code solution, Do UPVOTE!\\n![upvote.png](https://assets.leetcode.com/users/images/83c566a6-16a0-43b4-8296-a2b2c44dd240_1682227798.0569692.png)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int minOperations(vector<int>& nums) {\\n        int n=nums.size();\\n        int ones = 0;\\n        int ans=INT_MAX;\\n\\n        for(int i=0; i<n; i++){\\n            if(nums[i]==1) ones++;\\n        }\\n        if(ones>0) return n-ones;\\n        \\n        for(int i=0; i<n; i++){\\n            for(int j=i+1; j<n; j++){\\n                nums[i]= __gcd(nums[i], nums[j]);\\n                if(nums[i]==1){\\n                    ans=min(ans,j-i);\\n                    break;\\n                }\\n            }\\n            if(nums[i]!=1) break;\\n        }\\n\\n        if(ans==INT_MAX) return -1;\\n        return n-1+ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446130,
                "title": "esay-to-understand-beginer-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        int res = 1e7;\\n        int c=count(nums.begin(),nums.end(),1);\\n        if(c!=0){\\n            return n-c;\\n        }\\n        for(int i=0;i<n;i++){\\n            int k=nums[i];\\n            for(int j=i+1;j<n;j++){\\n                k=__gcd(k,nums[j]);\\n                if(k==1){\\n                    res=min(res,j-i+(n-1));\\n                    break;\\n                }\\n            }\\n        \\n        }\\n\\nreturn res==1e7?-1:res;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        int res = 1e7;\\n        int c=count(nums.begin(),nums.end(),1);\\n        if(c!=0){\\n            return n-c;\\n        }\\n        for(int i=0;i<n;i++){\\n            int k=nums[i];\\n            for(int j=i+1;j<n;j++){\\n                k=__gcd(k,nums[j]);\\n                if(k==1){\\n                    res=min(res,j-i+(n-1));\\n                    break;\\n                }\\n            }\\n        \\n        }\\n\\nreturn res==1e7?-1:res;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446120,
                "title": "java-gcd-euclid-s-algorithm-easy-and-simple-solution",
                "content": "**Time Complexity : - O(n^2)**\\n**Space Complexity : - O(1)**\\n```\\nclass Solution {\\n    public int minOperations(int[] nums) {\\n        int cntOne = 0;\\n        for (int n : nums) if (n == 1) cntOne++;\\n        if (cntOne != 0) return nums.length - cntOne;\\n        int res = Integer.MAX_VALUE;\\n        for (int i = 0; i < nums.length; i++) {\\n            int num = nums[i];\\n            for (int j = i + 1; j < nums.length; j++) {\\n                num = gcd(num, nums[j]);\\n                if (num == 1) {\\n                    res = Math.min(res, (j-i+(nums.length-1)));\\n                    break;\\n                }\\n            }\\n        }\\n        return res == Integer.MAX_VALUE ? -1 : res;\\n    }\\n\\t\\n\\t// Euclidean algorithm to Find GCD of two number \\n    private int gcd(int n1, int n2) {\\n        while (n2 != 0) {\\n            int m = n1 % n2;\\n            n1 = n2;\\n            n2 = m;\\n        }\\n        return n1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(int[] nums) {\\n        int cntOne = 0;\\n        for (int n : nums) if (n == 1) cntOne++;\\n        if (cntOne != 0) return nums.length - cntOne;\\n        int res = Integer.MAX_VALUE;\\n        for (int i = 0; i < nums.length; i++) {\\n            int num = nums[i];\\n            for (int j = i + 1; j < nums.length; j++) {\\n                num = gcd(num, nums[j]);\\n                if (num == 1) {\\n                    res = Math.min(res, (j-i+(nums.length-1)));\\n                    break;\\n                }\\n            }\\n        }\\n        return res == Integer.MAX_VALUE ? -1 : res;\\n    }\\n\\t\\n\\t// Euclidean algorithm to Find GCD of two number \\n    private int gcd(int n1, int n2) {\\n        while (n2 != 0) {\\n            int m = n1 % n2;\\n            n1 = n2;\\n            n2 = m;\\n        }\\n        return n1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446100,
                "title": "easy-to-understand-c-code",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        int countOnes = count(nums.begin(), nums.end(), 1);  \\n        if(countOnes != 0) return n - countOnes;\\n        int res = INT_MAX;     \\n        for(int i = 0; i < n; i++){\\n            int totalGcdValue = nums[i];\\n            for(int j = i + 1; j < n; j++){\\n                totalGcdValue = __gcd(totalGcdValue, nums[j]);\\n                if(totalGcdValue == 1){\\n                    res = min(res, j - i + (n-1)); \\n                    break;\\n                } \\n            }\\n        }\\n        return res == INT_MAX ? -1 : res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        int countOnes = count(nums.begin(), nums.end(), 1);  \\n        if(countOnes != 0) return n - countOnes;\\n        int res = INT_MAX;     \\n        for(int i = 0; i < n; i++){\\n            int totalGcdValue = nums[i];\\n            for(int j = i + 1; j < n; j++){\\n                totalGcdValue = __gcd(totalGcdValue, nums[j]);\\n                if(totalGcdValue == 1){\\n                    res = min(res, j - i + (n-1)); \\n                    break;\\n                } \\n            }\\n        }\\n        return res == INT_MAX ? -1 : res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446094,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        ones=nums.count(1)\\n        if ones:\\n            return n-ones\\n        diff=inf\\n        for i in range(n):\\n            g=nums[i] \\n\\n            for j in range(i+1,n):\\n                g=gcd(g,nums[j])\\n                if g==1:\\n                    diff=min(diff,j-i)\\n\\n\\n        return -1 if diff==inf else  diff+n-1                     \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        ones=nums.count(1)\\n        if ones:\\n            return n-ones\\n        diff=inf\\n        for i in range(n):\\n            g=nums[i] \\n\\n            for j in range(i+1,n):\\n                g=gcd(g,nums[j])\\n                if g==1:\\n                    diff=min(diff,j-i)\\n\\n\\n        return -1 if diff==inf else  diff+n-1                     \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446091,
                "title": "find-the-smallest-subarray-with-gcd-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        \\n        int count = 0;\\n        int gcdd = 1;\\n        int n = nums.size();\\n        int countone = 0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i] == 1){\\n                countone++;\\n            }\\n        }\\n        // find the samllest subarray with gcd = 1\\n        int len = 1e9;\\n        if(countone>0)return  n - countone;\\n        for(int i = 0;i<nums.size();i++){\\n            int val = nums[i];\\n            for(int j = i+1;j<nums.size();j++){\\n                val = __gcd(val,nums[j]);\\n                if(val == 1){\\n                    len = min(len,(j-i));\\n                }\\n            }\\n        }\\n        if(len == 1e9)return -1;\\n        return nums.size() + len -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        \\n        int count = 0;\\n        int gcdd = 1;\\n        int n = nums.size();\\n        int countone = 0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i] == 1){\\n                countone++;\\n            }\\n        }\\n        // find the samllest subarray with gcd = 1\\n        int len = 1e9;\\n        if(countone>0)return  n - countone;\\n        for(int i = 0;i<nums.size();i++){\\n            int val = nums[i];\\n            for(int j = i+1;j<nums.size();j++){\\n                val = __gcd(val,nums[j]);\\n                if(val == 1){\\n                    len = min(len,(j-i));\\n                }\\n            }\\n        }\\n        if(len == 1e9)return -1;\\n        return nums.size() + len -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446081,
                "title": "gcd-java-find-smallest-way-to-compute-first-1",
                "content": "```\\nclass Solution {\\n\\n    int getgcd(int a, int b) {\\n        int soln = 1;\\n\\n        for (int i = 1; i <= a && i <= b; ++i) {\\n            if (a % i == 0 && b % i == 0) soln = i;\\n        }\\n        return soln;\\n    }\\n\\n    public boolean computeGCD(int[] nums, int i, int j) {\\n        int t = nums[i];\\n        for (int itr = i + 1; itr <= j; itr++) {\\n            t = getgcd(t, nums[itr]);\\n            if (t == 1) return true;\\n        }\\n        return false;\\n    }\\n\\n    public int minOperations(int[] nums) {\\n        int onecount = 0;\\n        for (int i : nums) if (i == 1) onecount++;\\n        if (onecount != 0) return nums.length - onecount;\\n        int min = Integer.MAX_VALUE;\\n        for (int i = 0; i < nums.length; i++) {\\n            for (int j = i + 1; j < nums.length; j++) {\\n                if (computeGCD(nums, i, j)) {\\n                    min = Math.min(min, j - i - 1 + nums.length);\\n                    break;\\n                }\\n            }\\n        }\\n        return min == Integer.MAX_VALUE ? -1 : min;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    int getgcd(int a, int b) {\\n        int soln = 1;\\n\\n        for (int i = 1; i <= a && i <= b; ++i) {\\n            if (a % i == 0 && b % i == 0) soln = i;\\n        }\\n        return soln;\\n    }\\n\\n    public boolean computeGCD(int[] nums, int i, int j) {\\n        int t = nums[i];\\n        for (int itr = i + 1; itr <= j; itr++) {\\n            t = getgcd(t, nums[itr]);\\n            if (t == 1) return true;\\n        }\\n        return false;\\n    }\\n\\n    public int minOperations(int[] nums) {\\n        int onecount = 0;\\n        for (int i : nums) if (i == 1) onecount++;\\n        if (onecount != 0) return nums.length - onecount;\\n        int min = Integer.MAX_VALUE;\\n        for (int i = 0; i < nums.length; i++) {\\n            for (int j = i + 1; j < nums.length; j++) {\\n                if (computeGCD(nums, i, j)) {\\n                    min = Math.min(min, j - i - 1 + nums.length);\\n                    break;\\n                }\\n            }\\n        }\\n        return min == Integer.MAX_VALUE ? -1 : min;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446017,
                "title": "shortest-sub-array-with-gcd-1",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n ^ 2)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        N = len(nums)\\n\\n        # If there is 1 in the array, return number of non-one directly\\n        ones = nums.count(1)\\n        if ones:\\n            return N - ones\\n        \\n        # Find shortest sub-array with gcd 1\\n        def shortest():\\n            ans = N + 1\\n            for i in range(N):\\n                cur = nums[i]\\n                for j in range(i + 1, N):\\n                    cur = gcd(cur, nums[j])\\n                    if cur == 1:\\n                        ans = min(ans, j - i + 1)\\n            return ans\\n\\n        L = shortest()\\n        return -1 if L == N + 1 else N + L - 2\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        N = len(nums)\\n\\n        # If there is 1 in the array, return number of non-one directly\\n        ones = nums.count(1)\\n        if ones:\\n            return N - ones\\n        \\n        # Find shortest sub-array with gcd 1\\n        def shortest():\\n            ans = N + 1\\n            for i in range(N):\\n                cur = nums[i]\\n                for j in range(i + 1, N):\\n                    cur = gcd(cur, nums[j])\\n                    if cur == 1:\\n                        ans = min(ans, j - i + 1)\\n            return ans\\n\\n        L = shortest()\\n        return -1 if L == N + 1 else N + L - 2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446008,
                "title": "gcd",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        \\n        n=len(nums)\\n        ones_count = nums.count(1)\\n\\n        if ones_count: \\n            return len(nums)-ones_count\\n\\n        steps = inf \\n\\n        for i in range(len(nums)): \\n            g = nums[i]\\n            for j in range(i+1, len(nums)):\\n                g = gcd(g, nums[j])\\n                if g == 1: \\n                    steps = min(steps, j-i)\\n\\n        return -1 if steps == inf else steps + n - 1\\n                \\n\\n\\n        \\n        \\n        \\n        \\n        \\n    \\n            \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        \\n        n=len(nums)\\n        ones_count = nums.count(1)\\n\\n        if ones_count: \\n            return len(nums)-ones_count\\n\\n        steps = inf \\n\\n        for i in range(len(nums)): \\n            g = nums[i]\\n            for j in range(i+1, len(nums)):\\n                g = gcd(g, nums[j])\\n                if g == 1: \\n                    steps = min(steps, j-i)\\n\\n        return -1 if steps == inf else steps + n - 1\\n                \\n\\n\\n        \\n        \\n        \\n        \\n        \\n    \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445960,
                "title": "gcd-of-multiple-numbers",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo find gcd of multiple numbers\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ncall gcd n-1 times to find gcd of n numbers\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nn^3 log(m)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nn\\n\\n# Code\\n```\\nclass Solution:\\n    def gcd(self, a, b):\\n        if b > a:\\n            a, b = b, a\\n        assert a >= b\\n        if b == 0:\\n            return a\\n        return self.gcd(b, a%b)\\n    \\n    def possible(self, stt, end):\\n        if stt == end:\\n            return self.nums[stt] == 1\\n        cur = self.nums[stt]\\n        for i in range(stt+1, end+1):\\n            cur = self.gcd(cur, self.nums[i])\\n        return cur == 1\\n    \\n    def minOperations(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        self.nums = nums\\n        c1 = 0\\n        for v in nums:\\n            if v == 1:\\n                c1 += 1\\n        if c1 > 0:\\n            return n-c1\\n        for m in range(2, n+1):\\n            for i in range(n-m+1):\\n                if self.possible(i, i+m-1):\\n                    return n-1 + (m-1)\\n        return -1\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def gcd(self, a, b):\\n        if b > a:\\n            a, b = b, a\\n        assert a >= b\\n        if b == 0:\\n            return a\\n        return self.gcd(b, a%b)\\n    \\n    def possible(self, stt, end):\\n        if stt == end:\\n            return self.nums[stt] == 1\\n        cur = self.nums[stt]\\n        for i in range(stt+1, end+1):\\n            cur = self.gcd(cur, self.nums[i])\\n        return cur == 1\\n    \\n    def minOperations(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        self.nums = nums\\n        c1 = 0\\n        for v in nums:\\n            if v == 1:\\n                c1 += 1\\n        if c1 > 0:\\n            return n-c1\\n        for m in range(2, n+1):\\n            for i in range(n-m+1):\\n                if self.possible(i, i+m-1):\\n                    return n-1 + (m-1)\\n        return -1\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445957,
                "title": "gcd-of-multiple-numbers",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo find gcd of multiple numbers\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ncall gcd n-1 times to find gcd of n numbers\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nn^3 log(m)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nn\\n\\n# Code\\n```\\nclass Solution:\\n    def gcd(self, a, b):\\n        if b > a:\\n            a, b = b, a\\n        assert a >= b\\n        if b == 0:\\n            return a\\n        return self.gcd(b, a%b)\\n    \\n    def possible(self, stt, end):\\n        if stt == end:\\n            return self.nums[stt] == 1\\n        cur = self.nums[stt]\\n        for i in range(stt+1, end+1):\\n            cur = self.gcd(cur, self.nums[i])\\n        return cur == 1\\n    \\n    def minOperations(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        self.nums = nums\\n        c1 = 0\\n        for v in nums:\\n            if v == 1:\\n                c1 += 1\\n        if c1 > 0:\\n            return n-c1\\n        for m in range(2, n+1):\\n            for i in range(n-m+1):\\n                if self.possible(i, i+m-1):\\n                    return n-1 + (m-1)\\n        return -1\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def gcd(self, a, b):\\n        if b > a:\\n            a, b = b, a\\n        assert a >= b\\n        if b == 0:\\n            return a\\n        return self.gcd(b, a%b)\\n    \\n    def possible(self, stt, end):\\n        if stt == end:\\n            return self.nums[stt] == 1\\n        cur = self.nums[stt]\\n        for i in range(stt+1, end+1):\\n            cur = self.gcd(cur, self.nums[i])\\n        return cur == 1\\n    \\n    def minOperations(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        self.nums = nums\\n        c1 = 0\\n        for v in nums:\\n            if v == 1:\\n                c1 += 1\\n        if c1 > 0:\\n            return n-c1\\n        for m in range(2, n+1):\\n            for i in range(n-m+1):\\n                if self.possible(i, i+m-1):\\n                    return n-1 + (m-1)\\n        return -1\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445941,
                "title": "c-java-brute-force-intuitive",
                "content": "## Explanation\\nCount the number of 1\\'s present in the array. If there are any 1\\'s present in the array, we can directly return the count of all elements except 1\\'s, as we can spread the 1\\'s by with the GCD operation. \\n\\nIf no 1\\'s are present , then a brute force approach is to iterate over all elements for each element and find the GCD of a subarray. If it equals to 1, then it means that we can convert it to 1 in `j - i` (length of subarray) steps.\\n\\nFind the minimum length of such subarray and return `n - minLength + 1`. If no subarray with GCD of 1 is found, return -1. \\n\\n## Code\\n\\n```C++ []\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int ones = 0, n = size(nums);\\n        for(int &val:nums) if(val==1) ones++;\\n        if(ones) return n - ones;\\n        else{\\n            int ans = 1e8;\\n            for(int i = 0; i < n; i++){\\n                int curr = nums[i];\\n                for(int j = i+1; j < n; j++){\\n                    curr = __gcd(curr, nums[j]);\\n                    if(curr == 1) {\\n                        ans = min(ans, j-i);\\n                        break;\\n                    }\\n                }\\n                if(curr != 1) break;\\n            }\\n            return ans==1e8?-1:(n+ans-1);\\n        }\\n        return 0;\\n    }\\n};\\n```\\n```Java []\\nimport java.util.Arrays;\\n\\nclass Solution {\\n    public int minOperations(int[] nums) {\\n        int ones = 0, n = nums.length;\\n        for(int val : nums) {\\n            if(val == 1) {\\n                ones++;\\n            }\\n        }\\n        if(ones != 0) {\\n            return n - ones;\\n        }\\n        else {\\n            int ans = 100000000;\\n            for(int i = 0; i < n; i++) {\\n                int curr = nums[i];\\n                for(int j = i + 1; j < n; j++) {\\n                    curr = gcd(curr, nums[j]);\\n                    if(curr == 1) {\\n                        ans = Math.min(ans, j - i);\\n                        break;\\n                    }\\n                }\\n                if(curr != 1) {\\n                    break;\\n                }\\n            }\\n            return ans == 100000000 ? -1 : (n + ans - 1);\\n        }\\n    }\\n\\n    private int gcd(int a, int b) {\\n        if(b == 0) {\\n            return a;\\n        }\\n        return gcd(b, a % b);\\n    }\\n}\\n```\\n\\n## Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Greedy"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int ones = 0, n = size(nums);\\n        for(int &val:nums) if(val==1) ones++;\\n        if(ones) return n - ones;\\n        else{\\n            int ans = 1e8;\\n            for(int i = 0; i < n; i++){\\n                int curr = nums[i];\\n                for(int j = i+1; j < n; j++){\\n                    curr = __gcd(curr, nums[j]);\\n                    if(curr == 1) {\\n                        ans = min(ans, j-i);\\n                        break;\\n                    }\\n                }\\n                if(curr != 1) break;\\n            }\\n            return ans==1e8?-1:(n+ans-1);\\n        }\\n        return 0;\\n    }\\n};\\n```\n```Java []\\nimport java.util.Arrays;\\n\\nclass Solution {\\n    public int minOperations(int[] nums) {\\n        int ones = 0, n = nums.length;\\n        for(int val : nums) {\\n            if(val == 1) {\\n                ones++;\\n            }\\n        }\\n        if(ones != 0) {\\n            return n - ones;\\n        }\\n        else {\\n            int ans = 100000000;\\n            for(int i = 0; i < n; i++) {\\n                int curr = nums[i];\\n                for(int j = i + 1; j < n; j++) {\\n                    curr = gcd(curr, nums[j]);\\n                    if(curr == 1) {\\n                        ans = Math.min(ans, j - i);\\n                        break;\\n                    }\\n                }\\n                if(curr != 1) {\\n                    break;\\n                }\\n            }\\n            return ans == 100000000 ? -1 : (n + ans - 1);\\n        }\\n    }\\n\\n    private int gcd(int a, int b) {\\n        if(b == 0) {\\n            return a;\\n        }\\n        return gcd(b, a % b);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445937,
                "title": "easiest-c-logic",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int minOperations(vector<int>& nums) {\\n       int nonOnes = 0 ;\\n        for(auto x:nums){\\n            if(x!=1) nonOnes++ ;\\n        }    \\n        \\n        if(nonOnes==0) return 0;\\n        \\n        // atleast 1 is present \\n        if(nonOnes!=nums.size()) return nonOnes ;\\n        \\n        int howFast = 1e9 ;\\n        // how fast can I create a one \\n        for(int i=0; i<nums.size()-1; i++)\\n        {\\n            int step = 1 ;\\n            int gcd=__gcd(nums[i],nums[i+1]) ;\\n            for(int j=i+2; j<nums.size(); j++){\\n                if(gcd==1) break ;\\n                gcd=__gcd(gcd,nums[j]) ;\\n                step++;\\n            }\\n            if(gcd==1){\\n                howFast =  min(howFast,step) ;\\n            }\\n        }\\n        \\n        \\n        if(howFast==1e9) return -1; \\n        \\n        return howFast+nums.size()-1; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int minOperations(vector<int>& nums) {\\n       int nonOnes = 0 ;\\n        for(auto x:nums){\\n            if(x!=1) nonOnes++ ;\\n        }    \\n        \\n        if(nonOnes==0) return 0;\\n        \\n        // atleast 1 is present \\n        if(nonOnes!=nums.size()) return nonOnes ;\\n        \\n        int howFast = 1e9 ;\\n        // how fast can I create a one \\n        for(int i=0; i<nums.size()-1; i++)\\n        {\\n            int step = 1 ;\\n            int gcd=__gcd(nums[i],nums[i+1]) ;\\n            for(int j=i+2; j<nums.size(); j++){\\n                if(gcd==1) break ;\\n                gcd=__gcd(gcd,nums[j]) ;\\n                step++;\\n            }\\n            if(gcd==1){\\n                howFast =  min(howFast,step) ;\\n            }\\n        }\\n        \\n        \\n        if(howFast==1e9) return -1; \\n        \\n        return howFast+nums.size()-1; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445932,
                "title": "c-intuitive-simple-approach-explained",
                "content": "# Intuition\\nAs soon as we will have a 1 in the array the whole array can be converted to ones by a single operation for each element.\\n\\n# Approach\\nInitially check if there are any ones in the array. If yes, then simply return the count of non-one values in the array.\\n\\nOtherwise:\\nKeep on checking if all the elements in the array are equal or not and if all elements are equal and not equal to 1 then its impossible to convert the array to all ones.\\n\\nFind the minimum number of operations to convert any element to one. As we are using adjacent elements we can keep on traversing the given array and save the gcd of them in the same array as the previous values don\\'t matter anymore.\\n\\nAs we have the minimum number of operations to convert a single element to one. Now, the minimum number of operations to convert the whole array to ones is the number of non-one values in the array i.e. n - 1.\\n\\n# Complexity\\n- Time complexity: O(M * N) where M denotes number of operations to convert an element to 1 (0 < M < N)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int N = nums.size();\\n\\n        // initial check for ones\\n        int c1 = 0;\\n        for(int i = 0; i < N; i++) {\\n            if(nums[i] == 1)\\n                c1++;\\n        }\\n        if(c1)\\n            return N - c1;\\n        \\n        int n = nums.size();\\n        int ans = 0;\\n        bool found1 = false;\\n        while(!found1 && n > 0) {\\n            // checking if we have a 1 in the modified array\\n            for(int i = 0; i < n; i++) {\\n                if(nums[i] == 1)\\n                    found1 = true;\\n            }\\n            // ans contains the minimum number of operations to get first 1\\n            // this 1 will be used to convert every other element to 1\\n            if(found1)\\n                ans += N - 1;\\n            else {\\n                // searching for first 1\\n                ans++;\\n                int equalC = 0;\\n                for(int i = 0; i < n - 1; i++) {\\n                    if(nums[i] == nums[i + 1])\\n                        equalC++;\\n                }\\n                // if all elements are equal and are not 1\\n                // its impossible to convert the array\\n                if(nums[0] != 1 && equalC + 1 == n)\\n                    return -1;\\n                // next array\\n                for(int i = 0; i < n - 1; i++)\\n                    nums[i] = __gcd(nums[i], nums[i + 1]);\\n                n--;\\n            }\\n        }\\n        if(n == 0)\\n            return -1;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int N = nums.size();\\n\\n        // initial check for ones\\n        int c1 = 0;\\n        for(int i = 0; i < N; i++) {\\n            if(nums[i] == 1)\\n                c1++;\\n        }\\n        if(c1)\\n            return N - c1;\\n        \\n        int n = nums.size();\\n        int ans = 0;\\n        bool found1 = false;\\n        while(!found1 && n > 0) {\\n            // checking if we have a 1 in the modified array\\n            for(int i = 0; i < n; i++) {\\n                if(nums[i] == 1)\\n                    found1 = true;\\n            }\\n            // ans contains the minimum number of operations to get first 1\\n            // this 1 will be used to convert every other element to 1\\n            if(found1)\\n                ans += N - 1;\\n            else {\\n                // searching for first 1\\n                ans++;\\n                int equalC = 0;\\n                for(int i = 0; i < n - 1; i++) {\\n                    if(nums[i] == nums[i + 1])\\n                        equalC++;\\n                }\\n                // if all elements are equal and are not 1\\n                // its impossible to convert the array\\n                if(nums[0] != 1 && equalC + 1 == n)\\n                    return -1;\\n                // next array\\n                for(int i = 0; i < n - 1; i++)\\n                    nums[i] = __gcd(nums[i], nums[i + 1]);\\n                n--;\\n            }\\n        }\\n        if(n == 0)\\n            return -1;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445902,
                "title": "beginner-solution-easy-beats-100",
                "content": "# Complexity\\n- Time complexity:\\nO(n*n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int minOperations(vector<int>& nums) \\n    {\\n        int ans=INT_MAX;\\n        int jat = 0;\\n        for(int i=0; i<nums.size(); i++) \\n        {\\n            if(nums[i] == 1) \\n            {\\n                jat++;\\n            }\\n        }\\n        \\n        if(jat > 0) return nums.size() - jat;\\n        \\n        for(int i=0; i<nums.size(); i++) \\n        {\\n            int num1 = nums[i];\\n            for(int j=i+1; j<nums.size(); j++) \\n            {\\n                num1 = __gcd(num1, nums[j]);\\n                if(num1 == 1) {\\n                    ans = min(ans, j-i);\\n                    break;\\n                }\\n            }\\n        }\\n        if(ans == INT_MAX) return -1;\\n        return nums.size()-1+ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int minOperations(vector<int>& nums) \\n    {\\n        int ans=INT_MAX;\\n        int jat = 0;\\n        for(int i=0; i<nums.size(); i++) \\n        {\\n            if(nums[i] == 1) \\n            {\\n                jat++;\\n            }\\n        }\\n        \\n        if(jat > 0) return nums.size() - jat;\\n        \\n        for(int i=0; i<nums.size(); i++) \\n        {\\n            int num1 = nums[i];\\n            for(int j=i+1; j<nums.size(); j++) \\n            {\\n                num1 = __gcd(num1, nums[j]);\\n                if(num1 == 1) {\\n                    ans = min(ans, j-i);\\n                    break;\\n                }\\n            }\\n        }\\n        if(ans == INT_MAX) return -1;\\n        return nums.size()-1+ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445889,
                "title": "javascript-with-explaination",
                "content": "run an iteration though the array and update all gcd value.\\nif it cannot be one then no matter how many time we do gcd the arrray will be the same.\\ndo gcd on all elements and increase operations by 1.\\nif the values changed then run again. if they dont change and dont have a 1 it means its not possible.\\n\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar minOperations = function(nums) {\\n        let n=nums.length;\\n    let possible=false;\\n    let onePresent=false;\\n    var ans=0;\\n    var count=0;\\n    for(let i=0;i<nums.length;i++){\\n        if(nums[i]==1)count++;\\n    }\\n    if(count>0)return n-count;\\n    const gcd=(a,b)=>{\\n        while(b!=0){\\n            r=a%b;\\n            a=b;\\n            b=r;\\n        }\\n        return a;\\n    }\\n    oldArray=[...nums];\\n    var changed=true;\\n    while(changed==true){\\n        changed=false;\\n        for(let i=0;i<n-1;i++){\\n       nums[i]=gcd(nums[i],nums[i+1]);    \\n    } \\n         for(let i=0;i<n-1;i++){\\n       if(nums[i]==1){\\n           return ans+nums.length;\\n       }\\n    }\\n        for(let i=0;i<n;i++){\\n            if(nums[i]!=oldArray[i]){\\n                changed=true;\\n                ans++;\\n                break;\\n            }\\n        }\\n        oldArray=[...nums]\\n    }\\n\\n\\n    return -1;  \\n\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar minOperations = function(nums) {\\n        let n=nums.length;\\n    let possible=false;\\n    let onePresent=false;\\n    var ans=0;\\n    var count=0;\\n    for(let i=0;i<nums.length;i++){\\n        if(nums[i]==1)count++;\\n    }\\n    if(count>0)return n-count;\\n    const gcd=(a,b)=>{\\n        while(b!=0){\\n            r=a%b;\\n            a=b;\\n            b=r;\\n        }\\n        return a;\\n    }\\n    oldArray=[...nums];\\n    var changed=true;\\n    while(changed==true){\\n        changed=false;\\n        for(let i=0;i<n-1;i++){\\n       nums[i]=gcd(nums[i],nums[i+1]);    \\n    } \\n         for(let i=0;i<n-1;i++){\\n       if(nums[i]==1){\\n           return ans+nums.length;\\n       }\\n    }\\n        for(let i=0;i<n;i++){\\n            if(nums[i]!=oldArray[i]){\\n                changed=true;\\n                ans++;\\n                break;\\n            }\\n        }\\n        oldArray=[...nums]\\n    }\\n\\n\\n    return -1;  \\n\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3445859,
                "title": "c-9-liners-solution",
                "content": "```\\nint minOperations(vector<int>& nums) \\n{\\n\\tint n=nums.size(),c=nums[0],ones=nums[0]==1;\\n\\tfor(int i=1;i<n;i++) c=__gcd(c,nums[i]),ones+=nums[i]==1;\\n\\tif(c!=1) return -1;\\n\\twhile(true)\\n\\t{\\n\\t\\tfor(int i=0;i<n-1;i++)\\n\\t\\t{\\n\\t\\t\\tnums[i]=__gcd(nums[i],nums[i+1]);\\n\\t\\t\\tif(nums[i]==1) return 2*nums.size()-n-ones;\\n\\t\\t}\\n\\t\\tn--;\\n\\t}\\n\\treturn -1;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint minOperations(vector<int>& nums) \\n{\\n\\tint n=nums.size(),c=nums[0],ones=nums[0]==1;\\n\\tfor(int i=1;i<n;i++) c=__gcd(c,nums[i]),ones+=nums[i]==1;\\n\\tif(c!=1) return -1;\\n\\twhile(true)\\n\\t{\\n\\t\\tfor(int i=0;i<n-1;i++)\\n\\t\\t{\\n\\t\\t\\tnums[i]=__gcd(nums[i],nums[i+1]);\\n\\t\\t\\tif(nums[i]==1) return 2*nums.size()-n-ones;\\n\\t\\t}\\n\\t\\tn--;\\n\\t}\\n\\treturn -1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3445857,
                "title": "c-simple-easy-intuitive-solution-youtube-solution",
                "content": "Do Checkhttps://youtu.be/mmi8OHGLFyA\\n```\\nclass Solution {\\npublic:\\n    \\n    int minOperations(vector<int>& nums) {\\n        int gcd  = nums[0];\\n        int cnt =0;\\n        int p = gcd;\\n        int f=1;\\n        for(auto c:nums){\\n            gcd = __gcd(c,gcd);\\n            if(c>1) cnt++;\\n            int r = __gcd(p,c);\\n            if( r == 1) { f = 0;}\\n            p=c;\\n        }\\n        if(gcd > 1) return -1;\\n       \\n        if(f == 0)\\n        return cnt;\\n        \\n        \\n        int c = INT_MAX;\\n        for(int i=0;i<nums.size();i++){\\n            gcd = nums[i];\\n            for(int j=i;j<nums.size();j++){\\n                gcd = __gcd(gcd, nums[j]);\\n            \\n            if(gcd == 1){\\n                c=min(c,j-i);\\n            }\\n            }\\n        }\\n        return cnt-1 + c ;\\n       \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int minOperations(vector<int>& nums) {\\n        int gcd  = nums[0];\\n        int cnt =0;\\n        int p = gcd;\\n        int f=1;\\n        for(auto c:nums){\\n            gcd = __gcd(c,gcd);\\n            if(c>1) cnt++;\\n            int r = __gcd(p,c);\\n            if( r == 1) { f = 0;}\\n            p=c;\\n        }\\n        if(gcd > 1) return -1;\\n       \\n        if(f == 0)\\n        return cnt;\\n        \\n        \\n        int c = INT_MAX;\\n        for(int i=0;i<nums.size();i++){\\n            gcd = nums[i];\\n            for(int j=i;j<nums.size();j++){\\n                gcd = __gcd(gcd, nums[j]);\\n            \\n            if(gcd == 1){\\n                c=min(c,j-i);\\n            }\\n            }\\n        }\\n        return cnt-1 + c ;\\n       \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445829,
                "title": "python-dp",
                "content": "**Idea:**\\n- The size is small 50 so we can hash all the array and do dp on it.\\n- For each pair in array we do ans = min(ans, 1 + dp(new array with replacement as gcd)) if that replacement not equal value itself\\n- Speed up: if gcd == 1 we return all non 1s\\n\\n\\n```python\\nclass Solution:\\n    def minOperations(self, A: List[int]) -> int:\\n        N = len(A)\\n        @cache\\n        def dp(A):\\n            if sum(A) == N: return 0\\n            A = list(A)\\n            ans = inf\\n            for i in range(N-1):\\n                \\n                c = gcd(A[i],A[i+1])\\n                if c == 1:\\n                    s = 0\\n                    for x in A:\\n                        if x != 1:\\n                            s += 1\\n                    return s\\n                if A[i] != c:\\n                    x = A[i]\\n                    A[i] = c\\n                    ans = min(ans, 1 + dp(tuple(A)))\\n                    A[i] = x\\n                \\n                if A[i+1] != c:\\n                    x = A[i+1]\\n                    A[i+1] = c\\n                    ans = min(ans, 1 + dp(tuple(A)))\\n                    A[i+1] = x\\n            return ans\\n        \\n        ans = dp(tuple(A))\\n        \\n        return  -1  if inf == ans else ans\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```python\\nclass Solution:\\n    def minOperations(self, A: List[int]) -> int:\\n        N = len(A)\\n        @cache\\n        def dp(A):\\n            if sum(A) == N: return 0\\n            A = list(A)\\n            ans = inf\\n            for i in range(N-1):\\n                \\n                c = gcd(A[i],A[i+1])\\n                if c == 1:\\n                    s = 0\\n                    for x in A:\\n                        if x != 1:\\n                            s += 1\\n                    return s\\n                if A[i] != c:\\n                    x = A[i]\\n                    A[i] = c\\n                    ans = min(ans, 1 + dp(tuple(A)))\\n                    A[i] = x\\n                \\n                if A[i+1] != c:\\n                    x = A[i+1]\\n                    A[i+1] = c\\n                    ans = min(ans, 1 + dp(tuple(A)))\\n                    A[i+1] = x\\n            return ans\\n        \\n        ans = dp(tuple(A))\\n        \\n        return  -1  if inf == ans else ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445823,
                "title": "brute-force-o-n-2",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf there is a one in the array you can spread it to an adjacent indice every iteration in a loop until the whole array is one because the gcd(a, 1) = 1. If there is no one but we knew the smallest window where the gcd(values in window) = 1. then the min operations would be the length of the array  + window - 2. Since no values are one in the array, we must perform an operation on every indice. We must also add the size of the smallest window - 2 because we have to create a one to spread throughout the array first. We subtract two because if 2 adjacent elements in the array has a gcd of one then the min operations is the size of the array (we create a one in the first operation) else its the size of the array + elements in excess of two.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1a) if there are ones in the array returns length of array - number of ones\\n1b) find smallest window to create a gcd of 1 and return length of the array + window - 2\\n# Complexity\\n- Time complexity: O((N^2)*logN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minOperations(int[] nums) {\\n        int ones = 0;\\n        for (int num : nums)\\n            if (num == 1)\\n                ones++;\\n        if (ones > 0)\\n            return nums.length - ones;\\n        int minLength = Integer.MAX_VALUE;\\n        int n = nums.length;\\n        for (int i = 0; i < n; i++) {\\n            int val = nums[i];\\n            for (int j = i + 1; j < n; j++) {\\n                val = gcd(val, nums[j]);\\n                if (val == 1) {\\n                    if (j - i + 1 < minLength) {\\n                        minLength = j - i + 1;\\n                    }\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        if (minLength == Integer.MAX_VALUE)\\n            return -1;\\n        return n + (minLength - 2);\\n    }\\n    \\n    private int gcd(int a, int b) {\\n        if (b > a)\\n            return gcd(b, a);\\n        else if (b == 0)\\n            return a;\\n        int rem = a % b;\\n        return gcd(b, rem);\\n    }\\n    \\n    \\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(int[] nums) {\\n        int ones = 0;\\n        for (int num : nums)\\n            if (num == 1)\\n                ones++;\\n        if (ones > 0)\\n            return nums.length - ones;\\n        int minLength = Integer.MAX_VALUE;\\n        int n = nums.length;\\n        for (int i = 0; i < n; i++) {\\n            int val = nums[i];\\n            for (int j = i + 1; j < n; j++) {\\n                val = gcd(val, nums[j]);\\n                if (val == 1) {\\n                    if (j - i + 1 < minLength) {\\n                        minLength = j - i + 1;\\n                    }\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        if (minLength == Integer.MAX_VALUE)\\n            return -1;\\n        return n + (minLength - 2);\\n    }\\n    \\n    private int gcd(int a, int b) {\\n        if (b > a)\\n            return gcd(b, a);\\n        else if (b == 0)\\n            return a;\\n        int rem = a % b;\\n        return gcd(b, rem);\\n    }\\n    \\n    \\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445820,
                "title": "java-intuitive-solution",
                "content": "```\\nclass Solution {\\n    int getGcd(int val1, int val2)\\n    {\\n        if (val1 == 0) return val2;\\n        return getGcd(val2 % val1, val1);\\n    }\\n    public int minOperations(int[] arr) {\\n        int onesCount = 0, n = arr.length, min = Integer.MAX_VALUE;;\\n        for (int i = 0; i < n; i++) if (arr[i] == 1) onesCount++;\\n        if (onesCount != 0) return n - onesCount;\\n\\n        for (int i = 0; i < n; i++) {\\n            int gcd = arr[i];\\n            for (int j = i + 1; j < n; j++) {\\n                gcd = getGcd(arr[j], gcd);\\n                if (gcd == 1) {\\n                    min = Math.min(min, j - i);\\n                    break;\\n                }\\n            }\\n        }\\n\\n        if (min == Integer.MAX_VALUE) return -1; \\n        return n + min - 1; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int getGcd(int val1, int val2)\\n    {\\n        if (val1 == 0) return val2;\\n        return getGcd(val2 % val1, val1);\\n    }\\n    public int minOperations(int[] arr) {\\n        int onesCount = 0, n = arr.length, min = Integer.MAX_VALUE;;\\n        for (int i = 0; i < n; i++) if (arr[i] == 1) onesCount++;\\n        if (onesCount != 0) return n - onesCount;\\n\\n        for (int i = 0; i < n; i++) {\\n            int gcd = arr[i];\\n            for (int j = i + 1; j < n; j++) {\\n                gcd = getGcd(arr[j], gcd);\\n                if (gcd == 1) {\\n                    min = Math.min(min, j - i);\\n                    break;\\n                }\\n            }\\n        }\\n\\n        if (min == Integer.MAX_VALUE) return -1; \\n        return n + min - 1; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445785,
                "title": "best-solution-ever-hindi",
                "content": "# Intuition\\nbest solution ever\\n# Approach\\nin hindi\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public static int minOperations(int[] nums) {\\n        int n = nums.length;\\n        int coo = 0;\\n        for(int i=0; i<n; i++) {\\n            if(nums[i] == 1) {\\n                coo++;\\n            }\\n        }\\n        \\n        \\n        \\n        \\n        if(coo > 0) {\\n            return n - coo;\\n        }\\n        \\n        \\n        \\n        int ans = Integer.MAX_VALUE;\\n        for(int i=0; i<n; i++) {\\n            int num = nums[i];\\n            for(int j=i+1; j<n; j++) {\\n                num = gcd(num, nums[j]);\\n                if(num == 1) {\\n                    ans = Math.min(ans, j-i);\\n                    break;\\n                }\\n            }\\n            if(num != 1) {\\n                break;\\n            }\\n        }\\n        if(ans == Integer.MAX_VALUE) {\\n            return -1;\\n        }\\n        return n-1+ans;\\n    }\\n    \\n    public static int gcd(int a, int b) {\\n        if(a == 0) {\\n            return b;\\n        }\\n        return gcd(b%a, a);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public static int minOperations(int[] nums) {\\n        int n = nums.length;\\n        int coo = 0;\\n        for(int i=0; i<n; i++) {\\n            if(nums[i] == 1) {\\n                coo++;\\n            }\\n        }\\n        \\n        \\n        \\n        \\n        if(coo > 0) {\\n            return n - coo;\\n        }\\n        \\n        \\n        \\n        int ans = Integer.MAX_VALUE;\\n        for(int i=0; i<n; i++) {\\n            int num = nums[i];\\n            for(int j=i+1; j<n; j++) {\\n                num = gcd(num, nums[j]);\\n                if(num == 1) {\\n                    ans = Math.min(ans, j-i);\\n                    break;\\n                }\\n            }\\n            if(num != 1) {\\n                break;\\n            }\\n        }\\n        if(ans == Integer.MAX_VALUE) {\\n            return -1;\\n        }\\n        return n-1+ans;\\n    }\\n    \\n    public static int gcd(int a, int b) {\\n        if(a == 0) {\\n            return b;\\n        }\\n        return gcd(b%a, a);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445778,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size() ;\\n        int ones = 0 ;\\n        for(int i = 0; i < n; i++)\\n            if(nums[i] == 1)\\n                ones++ ;\\n        if(ones > 0)\\n            return n - ones ;\\n        \\n        int ret = INT_MAX ;\\n        for(int i = 0; i < n; i++){\\n            vector<int>numT = nums ;\\n            for(int j = i+1; j < n; j++){\\n                numT[j] = gcd(numT[j], numT[j-1]);\\n                if(numT[j] == 1)\\n                    ret = min(ret , j-i + n-1) ;\\n            }\\n        }       \\n        return (ret== INT_MAX) ? -1 : ret  ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size() ;\\n        int ones = 0 ;\\n        for(int i = 0; i < n; i++)\\n            if(nums[i] == 1)\\n                ones++ ;\\n        if(ones > 0)\\n            return n - ones ;\\n        \\n        int ret = INT_MAX ;\\n        for(int i = 0; i < n; i++){\\n            vector<int>numT = nums ;\\n            for(int j = i+1; j < n; j++){\\n                numT[j] = gcd(numT[j], numT[j-1]);\\n                if(numT[j] == 1)\\n                    ret = min(ret , j-i + n-1) ;\\n            }\\n        }       \\n        return (ret== INT_MAX) ? -1 : ret  ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445775,
                "title": "python-o-n-2",
                "content": "# Code\\n```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        if 1 in nums:\\n            return sum(num!=1 for num in nums)\\n        small = inf\\n        g = nums[:]\\n        for di in range(1, len(nums)):\\n            for i in range(len(nums)):\\n                if i + di >= len(nums):\\n                    break\\n                g[i] = gcd(g[i], nums[i+di])\\n                if g[i] == 1:\\n                    return di-1+len(nums)\\n        return -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        if 1 in nums:\\n            return sum(num!=1 for num in nums)\\n        small = inf\\n        g = nums[:]\\n        for di in range(1, len(nums)):\\n            for i in range(len(nums)):\\n                if i + di >= len(nums):\\n                    break\\n                g[i] = gcd(g[i], nums[i+di])\\n                if g[i] == 1:\\n                    return di-1+len(nums)\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445723,
                "title": "c-easy-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        \\n        int k=0,mini=INT_MAX;\\n        for(int&i:nums){\\n            if(i==1)\\n                k++;\\n        }\\n        if(k!=0){\\n            return nums.size()-k;\\n        }\\n        for(int i=0;i<nums.size();i++){\\n            int p=nums[i];\\n            for(int j=i+1;j<nums.size();j++){\\n                p=gcd(p,nums[j]);\\n                if(p==1){\\n                    mini=min(mini,j-i);\\n                    break;\\n                }\\n            }\\n        }\\n        return mini==INT_MAX?-1:nums.size()+mini-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        \\n        int k=0,mini=INT_MAX;\\n        for(int&i:nums){\\n            if(i==1)\\n                k++;\\n        }\\n        if(k!=0){\\n            return nums.size()-k;\\n        }\\n        for(int i=0;i<nums.size();i++){\\n            int p=nums[i];\\n            for(int j=i+1;j<nums.size();j++){\\n                p=gcd(p,nums[j]);\\n                if(p==1){\\n                    mini=min(mini,j-i);\\n                    break;\\n                }\\n            }\\n        }\\n        return mini==INT_MAX?-1:nums.size()+mini-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445719,
                "title": "no-need-of-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& a) {\\n        int n=a.size();\\n        bool check=false;\\n        int gcd=0,num;\\n        for(int i=0;i<n;i++){\\n            gcd=__gcd(gcd,a[i]);\\n        }\\n        if(gcd!=1) return -1;\\n        //check number of 1\\'s;\\n        int cnt=0;\\n        for(int i=0;i<n;i++){\\n            if(a[i]==1) cnt++;\\n        }\\n        if(cnt) return n-cnt;\\n        else {\\n            for(int i=1;i<n;i++){\\n                for(int j=0;j<n-i;j++){\\n                    gcd=0;\\n                    for(int k=j;k<=j+i;k++){\\n                        // cout<<j<<\" \"<<k<<endl;\\n                        gcd=__gcd(a[k],gcd);\\n                    }\\n                    if(gcd==1){\\n                        // cout<<i<<endl;\\n                        num=i+n-1;\\n                        check=true;\\n                        break;\\n                    }\\n                }\\n                if(check) break;\\n            }\\n        }\\n        return num;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& a) {\\n        int n=a.size();\\n        bool check=false;\\n        int gcd=0,num;\\n        for(int i=0;i<n;i++){\\n            gcd=__gcd(gcd,a[i]);\\n        }\\n        if(gcd!=1) return -1;\\n        //check number of 1\\'s;\\n        int cnt=0;\\n        for(int i=0;i<n;i++){\\n            if(a[i]==1) cnt++;\\n        }\\n        if(cnt) return n-cnt;\\n        else {\\n            for(int i=1;i<n;i++){\\n                for(int j=0;j<n-i;j++){\\n                    gcd=0;\\n                    for(int k=j;k<=j+i;k++){\\n                        // cout<<j<<\" \"<<k<<endl;\\n                        gcd=__gcd(a[k],gcd);\\n                    }\\n                    if(gcd==1){\\n                        // cout<<i<<endl;\\n                        num=i+n-1;\\n                        check=true;\\n                        break;\\n                    }\\n                }\\n                if(check) break;\\n            }\\n        }\\n        return num;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3445700,
                "title": "the-edge-case-that-costed-most-of-us-1-wa-c-intuition-explained",
                "content": "![image.png](https://assets.leetcode.com/users/images/121a8662-6e86-4218-87fd-323f5b913c7c_1682222218.3598685.png)\\n\\nSo, here is the test case that should be given maximum credit for taking the responsibility to decrease the accuracy of the problem to less than 25%.\\n```\\nnums = [1,1]\\n```\\n\\n\\n\\n<!--# Intuition\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!--# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!--- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Approach\\nLooking at the constraints will give a hint that we can loop through the array more than one time. So lets go through all the subarrays and find the size of the subarray with minimum size having GCD as 1.\\nSo to achieve the first 1 in the array will take size of subarray -1 moves. To make all the elements equal to 1 will take more nums.size()-1 moves.\\n\\n**Handling the edge case:** Check if there are already 1s existing in the array. If yes then just return nums.size()-no of ones present in the array. \\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int len=INT_MAX,hcf=nums[0];\\n        int flag=(nums[0]==1?1:0);\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            hcf=__gcd(nums[i],hcf);\\n            if(nums[i]==1)flag++;\\n        }\\n        if(flag>0)\\n            return nums.size()-(flag); \\n        if(hcf!=1)\\n            return -1;\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            hcf=nums[i];\\n            for(int j=i+1;j<nums.size();j++)\\n            {\\n                hcf=__gcd(nums[j],hcf);\\n                if(hcf==1)\\n                {\\n                    len=min(len,j-i);\\n                    break;\\n                }\\n            }\\n        }\\n        if(len==INT_MAX)return -1;\\n        return len+nums.size()-1;\\n    }\\n};\\n```\\n\\n**Please Upvote if u could relate with me or liked the approach**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nnums = [1,1]\\n```\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int len=INT_MAX,hcf=nums[0];\\n        int flag=(nums[0]==1?1:0);\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            hcf=__gcd(nums[i],hcf);\\n            if(nums[i]==1)flag++;\\n        }\\n        if(flag>0)\\n            return nums.size()-(flag); \\n        if(hcf!=1)\\n            return -1;\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            hcf=nums[i];\\n            for(int j=i+1;j<nums.size();j++)\\n            {\\n                hcf=__gcd(nums[j],hcf);\\n                if(hcf==1)\\n                {\\n                    len=min(len,j-i);\\n                    break;\\n                }\\n            }\\n        }\\n        if(len==INT_MAX)return -1;\\n        return len+nums.size()-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445674,
                "title": "c-simple-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int GCD(int a,int b)\\n    {\\n        if(b == 0)\\n            return a;\\n        return GCD(b,a%b);\\n    }\\n    \\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        int countone = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i] == 1)\\n                countone++;\\n        }\\n        if(countone > 0)\\n             return n-countone;\\n        \\n        int minop = INT_MAX;\\n        for(int i=0;i<n-1;i++)\\n        {\\n            int gcdres = nums[i];\\n            for(int j=i+1;j<n;j++)\\n            {\\n                gcdres = GCD(nums[j],gcdres);\\n                if(gcdres == 1)\\n                {\\n                    minop = min(minop,j-i+1);\\n                    break;\\n                }\\n            }\\n        }\\n        if(minop == INT_MAX)\\n            return -1;\\n        return n+minop-2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int GCD(int a,int b)\\n    {\\n        if(b == 0)\\n            return a;\\n        return GCD(b,a%b);\\n    }\\n    \\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        int countone = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i] == 1)\\n                countone++;\\n        }\\n        if(countone > 0)\\n             return n-countone;\\n        \\n        int minop = INT_MAX;\\n        for(int i=0;i<n-1;i++)\\n        {\\n            int gcdres = nums[i];\\n            for(int j=i+1;j<n;j++)\\n            {\\n                gcdres = GCD(nums[j],gcdres);\\n                if(gcdres == 1)\\n                {\\n                    minop = min(minop,j-i+1);\\n                    break;\\n                }\\n            }\\n        }\\n        if(minop == INT_MAX)\\n            return -1;\\n        return n+minop-2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445673,
                "title": "minimum-size-subarray-with-gcd-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int com=nums[0], oc=0;\\n        // com is the cumulative gcd\\n        //oc means one count\\n        if(nums[0]==1){oc++;}\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            if(nums[i]==1){oc++;}\\n            com=__gcd(com,nums[i]);\\n        }\\n        // if there is some common factor between every element then its impossible to make array 1\\n        if(com!=1){return -1;}\\n        //if there is even a single one in the array then we can convert any element to 1 with a single operation\\n        // so in this case the total operations required = the number of non one elements\\n        if(oc){return nums.size()-oc;}\\n        \\n        // here we try to find the subarray of minimum size whose gcd=1\\n        int mini=INT_MAX;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int com=nums[i];\\n            for(int j=i;j<nums.size();j++)\\n            {\\n                com=__gcd(nums[j],com);\\n                if(com==1){\\n                    mini=min(mini,j-i+1);break;\\n                }\\n            }\\n        }\\n        //mini-2 is the extra operations required to make an element 1 in the array and once we get a single 1 we can convert all elements to 1 each with a single operation\\n        return nums.size()+(mini-2);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int com=nums[0], oc=0;\\n        // com is the cumulative gcd\\n        //oc means one count\\n        if(nums[0]==1){oc++;}\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            if(nums[i]==1){oc++;}\\n            com=__gcd(com,nums[i]);\\n        }\\n        // if there is some common factor between every element then its impossible to make array 1\\n        if(com!=1){return -1;}\\n        //if there is even a single one in the array then we can convert any element to 1 with a single operation\\n        // so in this case the total operations required = the number of non one elements\\n        if(oc){return nums.size()-oc;}\\n        \\n        // here we try to find the subarray of minimum size whose gcd=1\\n        int mini=INT_MAX;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int com=nums[i];\\n            for(int j=i;j<nums.size();j++)\\n            {\\n                com=__gcd(nums[j],com);\\n                if(com==1){\\n                    mini=min(mini,j-i+1);break;\\n                }\\n            }\\n        }\\n        //mini-2 is the extra operations required to make an element 1 in the array and once we get a single 1 we can convert all elements to 1 each with a single operation\\n        return nums.size()+(mini-2);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445670,
                "title": "i-will-stop-as-soon-as-i-find-number-1-greedy",
                "content": "I am just trying to find the number 1 because gcd of anynumber with 1 will be 1 and we want to make elements to 1 .\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums,int ans = INT_MAX,int ones = 0) {\\n        for(auto ele:nums)ones+=ele==1;\\n        if(ones > 0)  return (int)nums.size() - ones;\\n        for(int i=0; i<(int)nums.size(); i++) {\\n            auto ele = nums[i];\\n            for(int j=i+1;j<(int)nums.size(); j++) {\\n                ele = gcd(ele, nums[j]);\\n                if(ele == 1) {\\n                    ans = min(ans, j-i);\\n                    break;\\n                }\\n            }\\n            if(!ele)break;\\n        }\\n        return ans == INT_MAX?-1:(int)nums.size() -1+ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums,int ans = INT_MAX,int ones = 0) {\\n        for(auto ele:nums)ones+=ele==1;\\n        if(ones > 0)  return (int)nums.size() - ones;\\n        for(int i=0; i<(int)nums.size(); i++) {\\n            auto ele = nums[i];\\n            for(int j=i+1;j<(int)nums.size(); j++) {\\n                ele = gcd(ele, nums[j]);\\n                if(ele == 1) {\\n                    ans = min(ans, j-i);\\n                    break;\\n                }\\n            }\\n            if(!ele)break;\\n        }\\n        return ans == INT_MAX?-1:(int)nums.size() -1+ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3460557,
                "title": "java-simple-solution-o-n-k-gcd",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nObervations  : \\n    1 - If GCD of whole array is not equal to 1 then we cannot convert the array to 1 so return -1;\\n    2 - Find the smallest subarray whose GCD is 1 then use the formula to calculate the final answer.\\n\\n    Formula is designed is based on the conditions - \\n        answer = total no.of elements - 1 + minimum size of the subarray whose gcd = 1\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    private int gcd(int a,int b){\\n        if(a == 0){\\n            return b;\\n        }\\n\\n        return gcd(b % a,a);\\n    }\\n    public int minOperations(int[] nums) {\\n        int n = nums.length;\\n        int cnt = 0;\\n        int gcd = 0;\\n        for(int i : nums){\\n            if(i == 1){\\n                cnt++;\\n            }\\n            gcd = gcd(gcd,i);\\n        }\\n\\n        if(gcd != 1){\\n            return -1;\\n        }\\n        if(cnt > 0){\\n            return n - cnt;\\n        }\\n\\n        int ans = Integer.MAX_VALUE;\\n        for(int i = 0;i < n;i++){\\n            int num = nums[i];\\n            for(int j = i + 1;j < n;j++){\\n                num = gcd(num,nums[j]);\\n                if(num == 1){\\n                    ans = Math.min(ans,j - i);\\n                    break;\\n                }\\n            }\\n        }\\n        return n - 1 + ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    private int gcd(int a,int b){\\n        if(a == 0){\\n            return b;\\n        }\\n\\n        return gcd(b % a,a);\\n    }\\n    public int minOperations(int[] nums) {\\n        int n = nums.length;\\n        int cnt = 0;\\n        int gcd = 0;\\n        for(int i : nums){\\n            if(i == 1){\\n                cnt++;\\n            }\\n            gcd = gcd(gcd,i);\\n        }\\n\\n        if(gcd != 1){\\n            return -1;\\n        }\\n        if(cnt > 0){\\n            return n - cnt;\\n        }\\n\\n        int ans = Integer.MAX_VALUE;\\n        for(int i = 0;i < n;i++){\\n            int num = nums[i];\\n            for(int j = i + 1;j < n;j++){\\n                num = gcd(num,nums[j]);\\n                if(num == 1){\\n                    ans = Math.min(ans,j - i);\\n                    break;\\n                }\\n            }\\n        }\\n        return n - 1 + ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1873923,
                "content": [
                    {
                        "username": "rideau",
                        "content": "Does anybody know how solve this in O(1) time? Is this even possible?"
                    },
                    {
                        "username": "brinuke",
                        "content": "Pay no attention to that follow-up. The person who wrote it was drunk."
                    },
                    {
                        "username": "User___",
                        "content": "Did you manage to solve it in $$O(n)$$? Just wondering, since you\\'re asking about $$O(1)$$ (which I feel isn\\'t possible)"
                    },
                    {
                        "username": "SergeyTT",
                        "content": "I think it's quite easy to prove that it impossible to solve this problem in O(1) time complexity.\nImaging you have an array of length N, for which the asnwer is \"-1\" - that is, you cannot make all elements equal to 1 using any number of operations. Now, insert number \"1\" at a random index of the array, and now you can make all other numbers equal to 1. In order to find this \"1\" you need O(N) time complexity."
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, your reasoning is absolutely correct. As per the problem, you need to inspect each element of the array to determine if the number 1 is present or if a pair of numbers exists such that their greatest common divisor (gcd) is 1. This requires at least linear time, O(N), where N is the length of the array.\\n\\nAs you\\'ve aptly illustrated, the presence of a single 1 in the array changes the entire outcome of the problem. Without examining each element, we cannot determine the presence or absence of such a crucial value. This necessitates iterating through the array at least once, thereby confirming that the problem cannot be solved in constant time, O(1)."
                    },
                    {
                        "username": "SlickGeek",
                        "content": "\"...but could you find an O(1) constant time complexity solution?\" Is it actually possible to solve this problem in constant time? I don\\'t know if there\\'s something I am not seeing or understanding, but I don\\'t think that is possible.\\nThe solution I came up with runs in N^2 and beats 71%."
                    },
                    {
                        "username": "bparanj",
                        "content": "[@rideau](/rideau) see [@Sergey TT](/SergeyTT)\\'s respose"
                    },
                    {
                        "username": "rideau",
                        "content": "Any updates? Im also interested "
                    },
                    {
                        "username": "sanjitj7",
                        "content": "EDIT: I have spotted my n00b mistake\n\nI think this test case is incorrect!\n\n>Input: nums = [2,10,6,14]\n>Output: -1\n>Explanation: It can be shown that it is impossible to make all the elements equal to 1\n\n[2,10,6,14]\n[2,10,3,14]  (i = 2)\n[2,10,3,1]   (i = 2)\n[2,10,1,1]\n[2,1,1,1]\n[1,1,1,1]\n\nThis caused a lot of confusion to me."
                    },
                    {
                        "username": "sanjitj7",
                        "content": "oh scheisse, I was taking num/GCD there \\uD83D\\uDE05 "
                    },
                    {
                        "username": "srk696772",
                        "content": "Bro GCD(6,14) == 2 ,  \nnot 3"
                    },
                    {
                        "username": "bekbossyn_kassymkhan",
                        "content": "gcd(6 & 14) = 2 , gcd(10,6)=2 also \n:)"
                    },
                    {
                        "username": "gaurav1903",
                        "content": "What\\'s the O(N) solution??"
                    },
                    {
                        "username": "bparanj",
                        "content": "The O(N) solution leverages the fact that if we can find two numbers in the array whose greatest common divisor (gcd) is 1, then the minimum number of operations required is the size of the array minus 1.\\n\\nTo achieve this in linear time, we can use the Sieve of Eratosthenes, a well-known algorithm for finding all prime numbers up to a given limit. This algorithm can be used to find the smallest prime factor for each number in the array, which is a prerequisite for finding two numbers with gcd 1.\\n\\nHere are the steps of the algorithm:\\n\\n1. Compute the smallest prime factor for each number up to max(nums) using the Sieve of Eratosthenes.\\n2. For each number in nums, if its smallest prime factor divides another number in nums, we can assume that the gcd of these two numbers is 1.\\n3. If we find such a pair, the minimum number of operations required is the size of the array minus 1.\\n4. If no such pair exists, we cannot make all elements equal to 1, so we return -1.\\n\\nNote: As the Sieve of Eratosthenes requires O(N log log N) time complexity, this solution is not strictly linear. However, it is significantly more efficient than an O(N^2) solution when dealing with large inputs.\\n\\nThis solution assumes that the input numbers are not too large (e.g., within the range of an integer). If the numbers can be very large, we need a different approach because the Sieve of Eratosthenes may not be feasible. For example, we could use a probabilistic algorithm to find a pair of numbers with gcd 1, but this would not guarantee a correct answer in all cases.\\n\\nAlso, it\\'s important to note that this approach doesn\\'t give the exact number of operations if no \"1\" is found in the array; it only checks for the possibility of making all elements equal to 1. Calculating the exact number of operations in such a case can be a more complex problem and is likely to require more than linear time."
                    },
                    {
                        "username": "ZX007java",
                        "content": "Good day ! Can anyone give me answer : why set [2, 6, 3, 4] have answer is equal 4, BUT SET [4, 2, 6, 3] have answer is equal 5 ???"
                    },
                    {
                        "username": "bparanj",
                        "content": "This discrepancy arises from the order in which we are allowed to perform the gcd operations on the array.\\n\\nFor the array [2, 6, 3, 4]:\\n\\n1. We can select index 2 (i.e., the number 3) and take the gcd with the number at index 3 (i.e., the number 4), and replace 3 with gcd(3, 4) = 1. Array becomes [2, 6, 1, 4].\\n2. We can then select index 1 (i.e., the number 6) and take the gcd with the number at index 2 (i.e., the number 1), and replace 6 with gcd(6, 1) = 1. Array becomes [2, 1, 1, 4].\\n3. Then, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [1, 1, 1, 4].\\n4. Finally, select index 2 (i.e., the number 1) and take the gcd with the number at index 3 (i.e., the number 4), and replace 4 with gcd(1, 4) = 1. Array becomes [1, 1, 1, 1].\\n\\nTotal operations = 4.\\n\\nFor the array [4, 2, 6, 3]:\\n\\n1. We can select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 6), and replace 2 with gcd(2, 6) = 2. Array becomes [4, 2, 6, 3].\\n2. Repeat step 1. Array still is [4, 2, 6, 3].\\n3. Repeat step 1 again. Array still is [4, 2, 6, 3].\\n4. Finally, select index 3 (i.e., the number 3) and take the gcd with the number at index 2 (i.e., the number 6), and replace 3 with gcd(3, 6) = 3. Array becomes [4, 2, 6, 1].\\n5. Now, select index 0 (i.e., the number 4) and take the gcd with the number at index 1 (i.e., the number 2), and replace 4 with gcd(4, 2) = 2. Array becomes [2, 2, 6, 1].\\n6. Next, select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 6), and replace 2 with gcd(2, 6) = 2. Array still is [2, 2, 6, 1].\\n7. Repeat step 6. Array still is [2, 2, 6, 1].\\n8. Repeat step 6 again. Array still is [2, 2, 6, 1].\\n9. Repeat step 6 once more. Array still is [2, 2, 6, 1].\\n10. Finally, select index 2 (i.e., the number 6) and take the gcd with the number at index 3 (i.e., the number 1), and replace 6 with gcd(6, 1) = 1. Array becomes [2, \\n\\n2, 1, 1].\\n11. Now, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 2), and replace 2 with gcd(2, 2) = 2. Array still is [2, 2, 1, 1].\\n12. Repeat step 11. Array still is [2, 2, 1, 1].\\n13. Repeat step 11 again. Array still is [2, 2, 1, 1].\\n14. Finally, select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [2, 1, 1, 1].\\n15. Now, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [1, 1, 1, 1].\\n\\nTotal operations = 15.\\n\\nThis demonstrates how the order of the array can affect the total number of operations required to achieve all elements as 1. The most optimized way to get all elements to 1 can depend on the order of elements in the array."
                    },
                    {
                        "username": "ZX007java",
                        "content": "[@s_m99](/s_m99) THANK YOU !!! CONSECUTIVE !!!"
                    },
                    {
                        "username": "s_m99",
                        "content": "You can only calculate gcd\\'s of 2 **consecutive** numbers and replace either of them. So in set [4,2,6,3] to make 3 into 1 we require two operations instead of one in [2,6,3,4] "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Damn, that was a great problem but... Medium, really? Am I just getting dumber? \nTook me quite lot of time and tryhard to see the solution.\nAnd that's gotta be the lowest acceptance rate I've seen for a medium problem\n\nAlso, python has a built-in gcd function apparently. Lesson learned; next time, no need to face my anxieties trying to remember my number theory classes to implement the Euclidean algo myself"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "Anyone explain or hint"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "light hint: how many steps would it take to get your first one in the array? And once you have a one, how many more steps do you need to turn everything into a one?"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "I am not able to understand the question\\nit says \\nselect index i and change num[i] or num[i+1] with their GCD and people have used n^2 loop to check every pair"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement asks for the minimum number of operations required to make all elements of an array equal to 1, by replacing either nums[i] or nums[i+1] with their gcd (greatest common divisor).\\n\\nThe problem solution is implemented with an O(n^2) approach, and this is why:\\n\\n1. You iterate over each element in the array (first loop).\\n2. For each element, you check for a contiguous segment in the array where the gcd of the numbers in the segment equals 1 (second loop). If such a segment is found, you store the length of that segment minus 1 (because one element is already 1 and doesn\\'t need any operation).\\n3. The result of the algorithm is the minimum length of these segments (if any) plus the number of elements outside these segments (because each of these will need one operation to become 1, by taking the gcd with 1).\\n\\nThe algorithm needs to check all pairs of elements because the array isn\\'t necessarily sorted, and any pair (i, j) with i < j can potentially form a contiguous segment where the gcd of the numbers is 1. So, an element nums[i] might be replaced by the gcd of nums[i] and nums[j] for some j > i.\\n"
                    },
                    {
                        "username": "User___",
                        "content": "[@cartesPerforees](/cartesPerforees) Is that $$O(n)$$?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I think you understand the question, it's just the solutions that you don't understand.\nWe check every pair to find the closest elements that could lead to a gcd of 1. Then we propagate the gcd neighbor-by-neighbor"
                    }
                ]
            },
            {
                "id": 1878342,
                "content": [
                    {
                        "username": "rideau",
                        "content": "Does anybody know how solve this in O(1) time? Is this even possible?"
                    },
                    {
                        "username": "brinuke",
                        "content": "Pay no attention to that follow-up. The person who wrote it was drunk."
                    },
                    {
                        "username": "User___",
                        "content": "Did you manage to solve it in $$O(n)$$? Just wondering, since you\\'re asking about $$O(1)$$ (which I feel isn\\'t possible)"
                    },
                    {
                        "username": "SergeyTT",
                        "content": "I think it's quite easy to prove that it impossible to solve this problem in O(1) time complexity.\nImaging you have an array of length N, for which the asnwer is \"-1\" - that is, you cannot make all elements equal to 1 using any number of operations. Now, insert number \"1\" at a random index of the array, and now you can make all other numbers equal to 1. In order to find this \"1\" you need O(N) time complexity."
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, your reasoning is absolutely correct. As per the problem, you need to inspect each element of the array to determine if the number 1 is present or if a pair of numbers exists such that their greatest common divisor (gcd) is 1. This requires at least linear time, O(N), where N is the length of the array.\\n\\nAs you\\'ve aptly illustrated, the presence of a single 1 in the array changes the entire outcome of the problem. Without examining each element, we cannot determine the presence or absence of such a crucial value. This necessitates iterating through the array at least once, thereby confirming that the problem cannot be solved in constant time, O(1)."
                    },
                    {
                        "username": "SlickGeek",
                        "content": "\"...but could you find an O(1) constant time complexity solution?\" Is it actually possible to solve this problem in constant time? I don\\'t know if there\\'s something I am not seeing or understanding, but I don\\'t think that is possible.\\nThe solution I came up with runs in N^2 and beats 71%."
                    },
                    {
                        "username": "bparanj",
                        "content": "[@rideau](/rideau) see [@Sergey TT](/SergeyTT)\\'s respose"
                    },
                    {
                        "username": "rideau",
                        "content": "Any updates? Im also interested "
                    },
                    {
                        "username": "sanjitj7",
                        "content": "EDIT: I have spotted my n00b mistake\n\nI think this test case is incorrect!\n\n>Input: nums = [2,10,6,14]\n>Output: -1\n>Explanation: It can be shown that it is impossible to make all the elements equal to 1\n\n[2,10,6,14]\n[2,10,3,14]  (i = 2)\n[2,10,3,1]   (i = 2)\n[2,10,1,1]\n[2,1,1,1]\n[1,1,1,1]\n\nThis caused a lot of confusion to me."
                    },
                    {
                        "username": "sanjitj7",
                        "content": "oh scheisse, I was taking num/GCD there \\uD83D\\uDE05 "
                    },
                    {
                        "username": "srk696772",
                        "content": "Bro GCD(6,14) == 2 ,  \nnot 3"
                    },
                    {
                        "username": "bekbossyn_kassymkhan",
                        "content": "gcd(6 & 14) = 2 , gcd(10,6)=2 also \n:)"
                    },
                    {
                        "username": "gaurav1903",
                        "content": "What\\'s the O(N) solution??"
                    },
                    {
                        "username": "bparanj",
                        "content": "The O(N) solution leverages the fact that if we can find two numbers in the array whose greatest common divisor (gcd) is 1, then the minimum number of operations required is the size of the array minus 1.\\n\\nTo achieve this in linear time, we can use the Sieve of Eratosthenes, a well-known algorithm for finding all prime numbers up to a given limit. This algorithm can be used to find the smallest prime factor for each number in the array, which is a prerequisite for finding two numbers with gcd 1.\\n\\nHere are the steps of the algorithm:\\n\\n1. Compute the smallest prime factor for each number up to max(nums) using the Sieve of Eratosthenes.\\n2. For each number in nums, if its smallest prime factor divides another number in nums, we can assume that the gcd of these two numbers is 1.\\n3. If we find such a pair, the minimum number of operations required is the size of the array minus 1.\\n4. If no such pair exists, we cannot make all elements equal to 1, so we return -1.\\n\\nNote: As the Sieve of Eratosthenes requires O(N log log N) time complexity, this solution is not strictly linear. However, it is significantly more efficient than an O(N^2) solution when dealing with large inputs.\\n\\nThis solution assumes that the input numbers are not too large (e.g., within the range of an integer). If the numbers can be very large, we need a different approach because the Sieve of Eratosthenes may not be feasible. For example, we could use a probabilistic algorithm to find a pair of numbers with gcd 1, but this would not guarantee a correct answer in all cases.\\n\\nAlso, it\\'s important to note that this approach doesn\\'t give the exact number of operations if no \"1\" is found in the array; it only checks for the possibility of making all elements equal to 1. Calculating the exact number of operations in such a case can be a more complex problem and is likely to require more than linear time."
                    },
                    {
                        "username": "ZX007java",
                        "content": "Good day ! Can anyone give me answer : why set [2, 6, 3, 4] have answer is equal 4, BUT SET [4, 2, 6, 3] have answer is equal 5 ???"
                    },
                    {
                        "username": "bparanj",
                        "content": "This discrepancy arises from the order in which we are allowed to perform the gcd operations on the array.\\n\\nFor the array [2, 6, 3, 4]:\\n\\n1. We can select index 2 (i.e., the number 3) and take the gcd with the number at index 3 (i.e., the number 4), and replace 3 with gcd(3, 4) = 1. Array becomes [2, 6, 1, 4].\\n2. We can then select index 1 (i.e., the number 6) and take the gcd with the number at index 2 (i.e., the number 1), and replace 6 with gcd(6, 1) = 1. Array becomes [2, 1, 1, 4].\\n3. Then, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [1, 1, 1, 4].\\n4. Finally, select index 2 (i.e., the number 1) and take the gcd with the number at index 3 (i.e., the number 4), and replace 4 with gcd(1, 4) = 1. Array becomes [1, 1, 1, 1].\\n\\nTotal operations = 4.\\n\\nFor the array [4, 2, 6, 3]:\\n\\n1. We can select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 6), and replace 2 with gcd(2, 6) = 2. Array becomes [4, 2, 6, 3].\\n2. Repeat step 1. Array still is [4, 2, 6, 3].\\n3. Repeat step 1 again. Array still is [4, 2, 6, 3].\\n4. Finally, select index 3 (i.e., the number 3) and take the gcd with the number at index 2 (i.e., the number 6), and replace 3 with gcd(3, 6) = 3. Array becomes [4, 2, 6, 1].\\n5. Now, select index 0 (i.e., the number 4) and take the gcd with the number at index 1 (i.e., the number 2), and replace 4 with gcd(4, 2) = 2. Array becomes [2, 2, 6, 1].\\n6. Next, select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 6), and replace 2 with gcd(2, 6) = 2. Array still is [2, 2, 6, 1].\\n7. Repeat step 6. Array still is [2, 2, 6, 1].\\n8. Repeat step 6 again. Array still is [2, 2, 6, 1].\\n9. Repeat step 6 once more. Array still is [2, 2, 6, 1].\\n10. Finally, select index 2 (i.e., the number 6) and take the gcd with the number at index 3 (i.e., the number 1), and replace 6 with gcd(6, 1) = 1. Array becomes [2, \\n\\n2, 1, 1].\\n11. Now, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 2), and replace 2 with gcd(2, 2) = 2. Array still is [2, 2, 1, 1].\\n12. Repeat step 11. Array still is [2, 2, 1, 1].\\n13. Repeat step 11 again. Array still is [2, 2, 1, 1].\\n14. Finally, select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [2, 1, 1, 1].\\n15. Now, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [1, 1, 1, 1].\\n\\nTotal operations = 15.\\n\\nThis demonstrates how the order of the array can affect the total number of operations required to achieve all elements as 1. The most optimized way to get all elements to 1 can depend on the order of elements in the array."
                    },
                    {
                        "username": "ZX007java",
                        "content": "[@s_m99](/s_m99) THANK YOU !!! CONSECUTIVE !!!"
                    },
                    {
                        "username": "s_m99",
                        "content": "You can only calculate gcd\\'s of 2 **consecutive** numbers and replace either of them. So in set [4,2,6,3] to make 3 into 1 we require two operations instead of one in [2,6,3,4] "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Damn, that was a great problem but... Medium, really? Am I just getting dumber? \nTook me quite lot of time and tryhard to see the solution.\nAnd that's gotta be the lowest acceptance rate I've seen for a medium problem\n\nAlso, python has a built-in gcd function apparently. Lesson learned; next time, no need to face my anxieties trying to remember my number theory classes to implement the Euclidean algo myself"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "Anyone explain or hint"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "light hint: how many steps would it take to get your first one in the array? And once you have a one, how many more steps do you need to turn everything into a one?"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "I am not able to understand the question\\nit says \\nselect index i and change num[i] or num[i+1] with their GCD and people have used n^2 loop to check every pair"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement asks for the minimum number of operations required to make all elements of an array equal to 1, by replacing either nums[i] or nums[i+1] with their gcd (greatest common divisor).\\n\\nThe problem solution is implemented with an O(n^2) approach, and this is why:\\n\\n1. You iterate over each element in the array (first loop).\\n2. For each element, you check for a contiguous segment in the array where the gcd of the numbers in the segment equals 1 (second loop). If such a segment is found, you store the length of that segment minus 1 (because one element is already 1 and doesn\\'t need any operation).\\n3. The result of the algorithm is the minimum length of these segments (if any) plus the number of elements outside these segments (because each of these will need one operation to become 1, by taking the gcd with 1).\\n\\nThe algorithm needs to check all pairs of elements because the array isn\\'t necessarily sorted, and any pair (i, j) with i < j can potentially form a contiguous segment where the gcd of the numbers is 1. So, an element nums[i] might be replaced by the gcd of nums[i] and nums[j] for some j > i.\\n"
                    },
                    {
                        "username": "User___",
                        "content": "[@cartesPerforees](/cartesPerforees) Is that $$O(n)$$?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I think you understand the question, it's just the solutions that you don't understand.\nWe check every pair to find the closest elements that could lead to a gcd of 1. Then we propagate the gcd neighbor-by-neighbor"
                    }
                ]
            },
            {
                "id": 1873206,
                "content": [
                    {
                        "username": "rideau",
                        "content": "Does anybody know how solve this in O(1) time? Is this even possible?"
                    },
                    {
                        "username": "brinuke",
                        "content": "Pay no attention to that follow-up. The person who wrote it was drunk."
                    },
                    {
                        "username": "User___",
                        "content": "Did you manage to solve it in $$O(n)$$? Just wondering, since you\\'re asking about $$O(1)$$ (which I feel isn\\'t possible)"
                    },
                    {
                        "username": "SergeyTT",
                        "content": "I think it's quite easy to prove that it impossible to solve this problem in O(1) time complexity.\nImaging you have an array of length N, for which the asnwer is \"-1\" - that is, you cannot make all elements equal to 1 using any number of operations. Now, insert number \"1\" at a random index of the array, and now you can make all other numbers equal to 1. In order to find this \"1\" you need O(N) time complexity."
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, your reasoning is absolutely correct. As per the problem, you need to inspect each element of the array to determine if the number 1 is present or if a pair of numbers exists such that their greatest common divisor (gcd) is 1. This requires at least linear time, O(N), where N is the length of the array.\\n\\nAs you\\'ve aptly illustrated, the presence of a single 1 in the array changes the entire outcome of the problem. Without examining each element, we cannot determine the presence or absence of such a crucial value. This necessitates iterating through the array at least once, thereby confirming that the problem cannot be solved in constant time, O(1)."
                    },
                    {
                        "username": "SlickGeek",
                        "content": "\"...but could you find an O(1) constant time complexity solution?\" Is it actually possible to solve this problem in constant time? I don\\'t know if there\\'s something I am not seeing or understanding, but I don\\'t think that is possible.\\nThe solution I came up with runs in N^2 and beats 71%."
                    },
                    {
                        "username": "bparanj",
                        "content": "[@rideau](/rideau) see [@Sergey TT](/SergeyTT)\\'s respose"
                    },
                    {
                        "username": "rideau",
                        "content": "Any updates? Im also interested "
                    },
                    {
                        "username": "sanjitj7",
                        "content": "EDIT: I have spotted my n00b mistake\n\nI think this test case is incorrect!\n\n>Input: nums = [2,10,6,14]\n>Output: -1\n>Explanation: It can be shown that it is impossible to make all the elements equal to 1\n\n[2,10,6,14]\n[2,10,3,14]  (i = 2)\n[2,10,3,1]   (i = 2)\n[2,10,1,1]\n[2,1,1,1]\n[1,1,1,1]\n\nThis caused a lot of confusion to me."
                    },
                    {
                        "username": "sanjitj7",
                        "content": "oh scheisse, I was taking num/GCD there \\uD83D\\uDE05 "
                    },
                    {
                        "username": "srk696772",
                        "content": "Bro GCD(6,14) == 2 ,  \nnot 3"
                    },
                    {
                        "username": "bekbossyn_kassymkhan",
                        "content": "gcd(6 & 14) = 2 , gcd(10,6)=2 also \n:)"
                    },
                    {
                        "username": "gaurav1903",
                        "content": "What\\'s the O(N) solution??"
                    },
                    {
                        "username": "bparanj",
                        "content": "The O(N) solution leverages the fact that if we can find two numbers in the array whose greatest common divisor (gcd) is 1, then the minimum number of operations required is the size of the array minus 1.\\n\\nTo achieve this in linear time, we can use the Sieve of Eratosthenes, a well-known algorithm for finding all prime numbers up to a given limit. This algorithm can be used to find the smallest prime factor for each number in the array, which is a prerequisite for finding two numbers with gcd 1.\\n\\nHere are the steps of the algorithm:\\n\\n1. Compute the smallest prime factor for each number up to max(nums) using the Sieve of Eratosthenes.\\n2. For each number in nums, if its smallest prime factor divides another number in nums, we can assume that the gcd of these two numbers is 1.\\n3. If we find such a pair, the minimum number of operations required is the size of the array minus 1.\\n4. If no such pair exists, we cannot make all elements equal to 1, so we return -1.\\n\\nNote: As the Sieve of Eratosthenes requires O(N log log N) time complexity, this solution is not strictly linear. However, it is significantly more efficient than an O(N^2) solution when dealing with large inputs.\\n\\nThis solution assumes that the input numbers are not too large (e.g., within the range of an integer). If the numbers can be very large, we need a different approach because the Sieve of Eratosthenes may not be feasible. For example, we could use a probabilistic algorithm to find a pair of numbers with gcd 1, but this would not guarantee a correct answer in all cases.\\n\\nAlso, it\\'s important to note that this approach doesn\\'t give the exact number of operations if no \"1\" is found in the array; it only checks for the possibility of making all elements equal to 1. Calculating the exact number of operations in such a case can be a more complex problem and is likely to require more than linear time."
                    },
                    {
                        "username": "ZX007java",
                        "content": "Good day ! Can anyone give me answer : why set [2, 6, 3, 4] have answer is equal 4, BUT SET [4, 2, 6, 3] have answer is equal 5 ???"
                    },
                    {
                        "username": "bparanj",
                        "content": "This discrepancy arises from the order in which we are allowed to perform the gcd operations on the array.\\n\\nFor the array [2, 6, 3, 4]:\\n\\n1. We can select index 2 (i.e., the number 3) and take the gcd with the number at index 3 (i.e., the number 4), and replace 3 with gcd(3, 4) = 1. Array becomes [2, 6, 1, 4].\\n2. We can then select index 1 (i.e., the number 6) and take the gcd with the number at index 2 (i.e., the number 1), and replace 6 with gcd(6, 1) = 1. Array becomes [2, 1, 1, 4].\\n3. Then, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [1, 1, 1, 4].\\n4. Finally, select index 2 (i.e., the number 1) and take the gcd with the number at index 3 (i.e., the number 4), and replace 4 with gcd(1, 4) = 1. Array becomes [1, 1, 1, 1].\\n\\nTotal operations = 4.\\n\\nFor the array [4, 2, 6, 3]:\\n\\n1. We can select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 6), and replace 2 with gcd(2, 6) = 2. Array becomes [4, 2, 6, 3].\\n2. Repeat step 1. Array still is [4, 2, 6, 3].\\n3. Repeat step 1 again. Array still is [4, 2, 6, 3].\\n4. Finally, select index 3 (i.e., the number 3) and take the gcd with the number at index 2 (i.e., the number 6), and replace 3 with gcd(3, 6) = 3. Array becomes [4, 2, 6, 1].\\n5. Now, select index 0 (i.e., the number 4) and take the gcd with the number at index 1 (i.e., the number 2), and replace 4 with gcd(4, 2) = 2. Array becomes [2, 2, 6, 1].\\n6. Next, select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 6), and replace 2 with gcd(2, 6) = 2. Array still is [2, 2, 6, 1].\\n7. Repeat step 6. Array still is [2, 2, 6, 1].\\n8. Repeat step 6 again. Array still is [2, 2, 6, 1].\\n9. Repeat step 6 once more. Array still is [2, 2, 6, 1].\\n10. Finally, select index 2 (i.e., the number 6) and take the gcd with the number at index 3 (i.e., the number 1), and replace 6 with gcd(6, 1) = 1. Array becomes [2, \\n\\n2, 1, 1].\\n11. Now, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 2), and replace 2 with gcd(2, 2) = 2. Array still is [2, 2, 1, 1].\\n12. Repeat step 11. Array still is [2, 2, 1, 1].\\n13. Repeat step 11 again. Array still is [2, 2, 1, 1].\\n14. Finally, select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [2, 1, 1, 1].\\n15. Now, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [1, 1, 1, 1].\\n\\nTotal operations = 15.\\n\\nThis demonstrates how the order of the array can affect the total number of operations required to achieve all elements as 1. The most optimized way to get all elements to 1 can depend on the order of elements in the array."
                    },
                    {
                        "username": "ZX007java",
                        "content": "[@s_m99](/s_m99) THANK YOU !!! CONSECUTIVE !!!"
                    },
                    {
                        "username": "s_m99",
                        "content": "You can only calculate gcd\\'s of 2 **consecutive** numbers and replace either of them. So in set [4,2,6,3] to make 3 into 1 we require two operations instead of one in [2,6,3,4] "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Damn, that was a great problem but... Medium, really? Am I just getting dumber? \nTook me quite lot of time and tryhard to see the solution.\nAnd that's gotta be the lowest acceptance rate I've seen for a medium problem\n\nAlso, python has a built-in gcd function apparently. Lesson learned; next time, no need to face my anxieties trying to remember my number theory classes to implement the Euclidean algo myself"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "Anyone explain or hint"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "light hint: how many steps would it take to get your first one in the array? And once you have a one, how many more steps do you need to turn everything into a one?"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "I am not able to understand the question\\nit says \\nselect index i and change num[i] or num[i+1] with their GCD and people have used n^2 loop to check every pair"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement asks for the minimum number of operations required to make all elements of an array equal to 1, by replacing either nums[i] or nums[i+1] with their gcd (greatest common divisor).\\n\\nThe problem solution is implemented with an O(n^2) approach, and this is why:\\n\\n1. You iterate over each element in the array (first loop).\\n2. For each element, you check for a contiguous segment in the array where the gcd of the numbers in the segment equals 1 (second loop). If such a segment is found, you store the length of that segment minus 1 (because one element is already 1 and doesn\\'t need any operation).\\n3. The result of the algorithm is the minimum length of these segments (if any) plus the number of elements outside these segments (because each of these will need one operation to become 1, by taking the gcd with 1).\\n\\nThe algorithm needs to check all pairs of elements because the array isn\\'t necessarily sorted, and any pair (i, j) with i < j can potentially form a contiguous segment where the gcd of the numbers is 1. So, an element nums[i] might be replaced by the gcd of nums[i] and nums[j] for some j > i.\\n"
                    },
                    {
                        "username": "User___",
                        "content": "[@cartesPerforees](/cartesPerforees) Is that $$O(n)$$?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I think you understand the question, it's just the solutions that you don't understand.\nWe check every pair to find the closest elements that could lead to a gcd of 1. Then we propagate the gcd neighbor-by-neighbor"
                    }
                ]
            },
            {
                "id": 1871447,
                "content": [
                    {
                        "username": "rideau",
                        "content": "Does anybody know how solve this in O(1) time? Is this even possible?"
                    },
                    {
                        "username": "brinuke",
                        "content": "Pay no attention to that follow-up. The person who wrote it was drunk."
                    },
                    {
                        "username": "User___",
                        "content": "Did you manage to solve it in $$O(n)$$? Just wondering, since you\\'re asking about $$O(1)$$ (which I feel isn\\'t possible)"
                    },
                    {
                        "username": "SergeyTT",
                        "content": "I think it's quite easy to prove that it impossible to solve this problem in O(1) time complexity.\nImaging you have an array of length N, for which the asnwer is \"-1\" - that is, you cannot make all elements equal to 1 using any number of operations. Now, insert number \"1\" at a random index of the array, and now you can make all other numbers equal to 1. In order to find this \"1\" you need O(N) time complexity."
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, your reasoning is absolutely correct. As per the problem, you need to inspect each element of the array to determine if the number 1 is present or if a pair of numbers exists such that their greatest common divisor (gcd) is 1. This requires at least linear time, O(N), where N is the length of the array.\\n\\nAs you\\'ve aptly illustrated, the presence of a single 1 in the array changes the entire outcome of the problem. Without examining each element, we cannot determine the presence or absence of such a crucial value. This necessitates iterating through the array at least once, thereby confirming that the problem cannot be solved in constant time, O(1)."
                    },
                    {
                        "username": "SlickGeek",
                        "content": "\"...but could you find an O(1) constant time complexity solution?\" Is it actually possible to solve this problem in constant time? I don\\'t know if there\\'s something I am not seeing or understanding, but I don\\'t think that is possible.\\nThe solution I came up with runs in N^2 and beats 71%."
                    },
                    {
                        "username": "bparanj",
                        "content": "[@rideau](/rideau) see [@Sergey TT](/SergeyTT)\\'s respose"
                    },
                    {
                        "username": "rideau",
                        "content": "Any updates? Im also interested "
                    },
                    {
                        "username": "sanjitj7",
                        "content": "EDIT: I have spotted my n00b mistake\n\nI think this test case is incorrect!\n\n>Input: nums = [2,10,6,14]\n>Output: -1\n>Explanation: It can be shown that it is impossible to make all the elements equal to 1\n\n[2,10,6,14]\n[2,10,3,14]  (i = 2)\n[2,10,3,1]   (i = 2)\n[2,10,1,1]\n[2,1,1,1]\n[1,1,1,1]\n\nThis caused a lot of confusion to me."
                    },
                    {
                        "username": "sanjitj7",
                        "content": "oh scheisse, I was taking num/GCD there \\uD83D\\uDE05 "
                    },
                    {
                        "username": "srk696772",
                        "content": "Bro GCD(6,14) == 2 ,  \nnot 3"
                    },
                    {
                        "username": "bekbossyn_kassymkhan",
                        "content": "gcd(6 & 14) = 2 , gcd(10,6)=2 also \n:)"
                    },
                    {
                        "username": "gaurav1903",
                        "content": "What\\'s the O(N) solution??"
                    },
                    {
                        "username": "bparanj",
                        "content": "The O(N) solution leverages the fact that if we can find two numbers in the array whose greatest common divisor (gcd) is 1, then the minimum number of operations required is the size of the array minus 1.\\n\\nTo achieve this in linear time, we can use the Sieve of Eratosthenes, a well-known algorithm for finding all prime numbers up to a given limit. This algorithm can be used to find the smallest prime factor for each number in the array, which is a prerequisite for finding two numbers with gcd 1.\\n\\nHere are the steps of the algorithm:\\n\\n1. Compute the smallest prime factor for each number up to max(nums) using the Sieve of Eratosthenes.\\n2. For each number in nums, if its smallest prime factor divides another number in nums, we can assume that the gcd of these two numbers is 1.\\n3. If we find such a pair, the minimum number of operations required is the size of the array minus 1.\\n4. If no such pair exists, we cannot make all elements equal to 1, so we return -1.\\n\\nNote: As the Sieve of Eratosthenes requires O(N log log N) time complexity, this solution is not strictly linear. However, it is significantly more efficient than an O(N^2) solution when dealing with large inputs.\\n\\nThis solution assumes that the input numbers are not too large (e.g., within the range of an integer). If the numbers can be very large, we need a different approach because the Sieve of Eratosthenes may not be feasible. For example, we could use a probabilistic algorithm to find a pair of numbers with gcd 1, but this would not guarantee a correct answer in all cases.\\n\\nAlso, it\\'s important to note that this approach doesn\\'t give the exact number of operations if no \"1\" is found in the array; it only checks for the possibility of making all elements equal to 1. Calculating the exact number of operations in such a case can be a more complex problem and is likely to require more than linear time."
                    },
                    {
                        "username": "ZX007java",
                        "content": "Good day ! Can anyone give me answer : why set [2, 6, 3, 4] have answer is equal 4, BUT SET [4, 2, 6, 3] have answer is equal 5 ???"
                    },
                    {
                        "username": "bparanj",
                        "content": "This discrepancy arises from the order in which we are allowed to perform the gcd operations on the array.\\n\\nFor the array [2, 6, 3, 4]:\\n\\n1. We can select index 2 (i.e., the number 3) and take the gcd with the number at index 3 (i.e., the number 4), and replace 3 with gcd(3, 4) = 1. Array becomes [2, 6, 1, 4].\\n2. We can then select index 1 (i.e., the number 6) and take the gcd with the number at index 2 (i.e., the number 1), and replace 6 with gcd(6, 1) = 1. Array becomes [2, 1, 1, 4].\\n3. Then, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [1, 1, 1, 4].\\n4. Finally, select index 2 (i.e., the number 1) and take the gcd with the number at index 3 (i.e., the number 4), and replace 4 with gcd(1, 4) = 1. Array becomes [1, 1, 1, 1].\\n\\nTotal operations = 4.\\n\\nFor the array [4, 2, 6, 3]:\\n\\n1. We can select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 6), and replace 2 with gcd(2, 6) = 2. Array becomes [4, 2, 6, 3].\\n2. Repeat step 1. Array still is [4, 2, 6, 3].\\n3. Repeat step 1 again. Array still is [4, 2, 6, 3].\\n4. Finally, select index 3 (i.e., the number 3) and take the gcd with the number at index 2 (i.e., the number 6), and replace 3 with gcd(3, 6) = 3. Array becomes [4, 2, 6, 1].\\n5. Now, select index 0 (i.e., the number 4) and take the gcd with the number at index 1 (i.e., the number 2), and replace 4 with gcd(4, 2) = 2. Array becomes [2, 2, 6, 1].\\n6. Next, select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 6), and replace 2 with gcd(2, 6) = 2. Array still is [2, 2, 6, 1].\\n7. Repeat step 6. Array still is [2, 2, 6, 1].\\n8. Repeat step 6 again. Array still is [2, 2, 6, 1].\\n9. Repeat step 6 once more. Array still is [2, 2, 6, 1].\\n10. Finally, select index 2 (i.e., the number 6) and take the gcd with the number at index 3 (i.e., the number 1), and replace 6 with gcd(6, 1) = 1. Array becomes [2, \\n\\n2, 1, 1].\\n11. Now, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 2), and replace 2 with gcd(2, 2) = 2. Array still is [2, 2, 1, 1].\\n12. Repeat step 11. Array still is [2, 2, 1, 1].\\n13. Repeat step 11 again. Array still is [2, 2, 1, 1].\\n14. Finally, select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [2, 1, 1, 1].\\n15. Now, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [1, 1, 1, 1].\\n\\nTotal operations = 15.\\n\\nThis demonstrates how the order of the array can affect the total number of operations required to achieve all elements as 1. The most optimized way to get all elements to 1 can depend on the order of elements in the array."
                    },
                    {
                        "username": "ZX007java",
                        "content": "[@s_m99](/s_m99) THANK YOU !!! CONSECUTIVE !!!"
                    },
                    {
                        "username": "s_m99",
                        "content": "You can only calculate gcd\\'s of 2 **consecutive** numbers and replace either of them. So in set [4,2,6,3] to make 3 into 1 we require two operations instead of one in [2,6,3,4] "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Damn, that was a great problem but... Medium, really? Am I just getting dumber? \nTook me quite lot of time and tryhard to see the solution.\nAnd that's gotta be the lowest acceptance rate I've seen for a medium problem\n\nAlso, python has a built-in gcd function apparently. Lesson learned; next time, no need to face my anxieties trying to remember my number theory classes to implement the Euclidean algo myself"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "Anyone explain or hint"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "light hint: how many steps would it take to get your first one in the array? And once you have a one, how many more steps do you need to turn everything into a one?"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "I am not able to understand the question\\nit says \\nselect index i and change num[i] or num[i+1] with their GCD and people have used n^2 loop to check every pair"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement asks for the minimum number of operations required to make all elements of an array equal to 1, by replacing either nums[i] or nums[i+1] with their gcd (greatest common divisor).\\n\\nThe problem solution is implemented with an O(n^2) approach, and this is why:\\n\\n1. You iterate over each element in the array (first loop).\\n2. For each element, you check for a contiguous segment in the array where the gcd of the numbers in the segment equals 1 (second loop). If such a segment is found, you store the length of that segment minus 1 (because one element is already 1 and doesn\\'t need any operation).\\n3. The result of the algorithm is the minimum length of these segments (if any) plus the number of elements outside these segments (because each of these will need one operation to become 1, by taking the gcd with 1).\\n\\nThe algorithm needs to check all pairs of elements because the array isn\\'t necessarily sorted, and any pair (i, j) with i < j can potentially form a contiguous segment where the gcd of the numbers is 1. So, an element nums[i] might be replaced by the gcd of nums[i] and nums[j] for some j > i.\\n"
                    },
                    {
                        "username": "User___",
                        "content": "[@cartesPerforees](/cartesPerforees) Is that $$O(n)$$?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I think you understand the question, it's just the solutions that you don't understand.\nWe check every pair to find the closest elements that could lead to a gcd of 1. Then we propagate the gcd neighbor-by-neighbor"
                    }
                ]
            },
            {
                "id": 1898536,
                "content": [
                    {
                        "username": "rideau",
                        "content": "Does anybody know how solve this in O(1) time? Is this even possible?"
                    },
                    {
                        "username": "brinuke",
                        "content": "Pay no attention to that follow-up. The person who wrote it was drunk."
                    },
                    {
                        "username": "User___",
                        "content": "Did you manage to solve it in $$O(n)$$? Just wondering, since you\\'re asking about $$O(1)$$ (which I feel isn\\'t possible)"
                    },
                    {
                        "username": "SergeyTT",
                        "content": "I think it's quite easy to prove that it impossible to solve this problem in O(1) time complexity.\nImaging you have an array of length N, for which the asnwer is \"-1\" - that is, you cannot make all elements equal to 1 using any number of operations. Now, insert number \"1\" at a random index of the array, and now you can make all other numbers equal to 1. In order to find this \"1\" you need O(N) time complexity."
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, your reasoning is absolutely correct. As per the problem, you need to inspect each element of the array to determine if the number 1 is present or if a pair of numbers exists such that their greatest common divisor (gcd) is 1. This requires at least linear time, O(N), where N is the length of the array.\\n\\nAs you\\'ve aptly illustrated, the presence of a single 1 in the array changes the entire outcome of the problem. Without examining each element, we cannot determine the presence or absence of such a crucial value. This necessitates iterating through the array at least once, thereby confirming that the problem cannot be solved in constant time, O(1)."
                    },
                    {
                        "username": "SlickGeek",
                        "content": "\"...but could you find an O(1) constant time complexity solution?\" Is it actually possible to solve this problem in constant time? I don\\'t know if there\\'s something I am not seeing or understanding, but I don\\'t think that is possible.\\nThe solution I came up with runs in N^2 and beats 71%."
                    },
                    {
                        "username": "bparanj",
                        "content": "[@rideau](/rideau) see [@Sergey TT](/SergeyTT)\\'s respose"
                    },
                    {
                        "username": "rideau",
                        "content": "Any updates? Im also interested "
                    },
                    {
                        "username": "sanjitj7",
                        "content": "EDIT: I have spotted my n00b mistake\n\nI think this test case is incorrect!\n\n>Input: nums = [2,10,6,14]\n>Output: -1\n>Explanation: It can be shown that it is impossible to make all the elements equal to 1\n\n[2,10,6,14]\n[2,10,3,14]  (i = 2)\n[2,10,3,1]   (i = 2)\n[2,10,1,1]\n[2,1,1,1]\n[1,1,1,1]\n\nThis caused a lot of confusion to me."
                    },
                    {
                        "username": "sanjitj7",
                        "content": "oh scheisse, I was taking num/GCD there \\uD83D\\uDE05 "
                    },
                    {
                        "username": "srk696772",
                        "content": "Bro GCD(6,14) == 2 ,  \nnot 3"
                    },
                    {
                        "username": "bekbossyn_kassymkhan",
                        "content": "gcd(6 & 14) = 2 , gcd(10,6)=2 also \n:)"
                    },
                    {
                        "username": "gaurav1903",
                        "content": "What\\'s the O(N) solution??"
                    },
                    {
                        "username": "bparanj",
                        "content": "The O(N) solution leverages the fact that if we can find two numbers in the array whose greatest common divisor (gcd) is 1, then the minimum number of operations required is the size of the array minus 1.\\n\\nTo achieve this in linear time, we can use the Sieve of Eratosthenes, a well-known algorithm for finding all prime numbers up to a given limit. This algorithm can be used to find the smallest prime factor for each number in the array, which is a prerequisite for finding two numbers with gcd 1.\\n\\nHere are the steps of the algorithm:\\n\\n1. Compute the smallest prime factor for each number up to max(nums) using the Sieve of Eratosthenes.\\n2. For each number in nums, if its smallest prime factor divides another number in nums, we can assume that the gcd of these two numbers is 1.\\n3. If we find such a pair, the minimum number of operations required is the size of the array minus 1.\\n4. If no such pair exists, we cannot make all elements equal to 1, so we return -1.\\n\\nNote: As the Sieve of Eratosthenes requires O(N log log N) time complexity, this solution is not strictly linear. However, it is significantly more efficient than an O(N^2) solution when dealing with large inputs.\\n\\nThis solution assumes that the input numbers are not too large (e.g., within the range of an integer). If the numbers can be very large, we need a different approach because the Sieve of Eratosthenes may not be feasible. For example, we could use a probabilistic algorithm to find a pair of numbers with gcd 1, but this would not guarantee a correct answer in all cases.\\n\\nAlso, it\\'s important to note that this approach doesn\\'t give the exact number of operations if no \"1\" is found in the array; it only checks for the possibility of making all elements equal to 1. Calculating the exact number of operations in such a case can be a more complex problem and is likely to require more than linear time."
                    },
                    {
                        "username": "ZX007java",
                        "content": "Good day ! Can anyone give me answer : why set [2, 6, 3, 4] have answer is equal 4, BUT SET [4, 2, 6, 3] have answer is equal 5 ???"
                    },
                    {
                        "username": "bparanj",
                        "content": "This discrepancy arises from the order in which we are allowed to perform the gcd operations on the array.\\n\\nFor the array [2, 6, 3, 4]:\\n\\n1. We can select index 2 (i.e., the number 3) and take the gcd with the number at index 3 (i.e., the number 4), and replace 3 with gcd(3, 4) = 1. Array becomes [2, 6, 1, 4].\\n2. We can then select index 1 (i.e., the number 6) and take the gcd with the number at index 2 (i.e., the number 1), and replace 6 with gcd(6, 1) = 1. Array becomes [2, 1, 1, 4].\\n3. Then, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [1, 1, 1, 4].\\n4. Finally, select index 2 (i.e., the number 1) and take the gcd with the number at index 3 (i.e., the number 4), and replace 4 with gcd(1, 4) = 1. Array becomes [1, 1, 1, 1].\\n\\nTotal operations = 4.\\n\\nFor the array [4, 2, 6, 3]:\\n\\n1. We can select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 6), and replace 2 with gcd(2, 6) = 2. Array becomes [4, 2, 6, 3].\\n2. Repeat step 1. Array still is [4, 2, 6, 3].\\n3. Repeat step 1 again. Array still is [4, 2, 6, 3].\\n4. Finally, select index 3 (i.e., the number 3) and take the gcd with the number at index 2 (i.e., the number 6), and replace 3 with gcd(3, 6) = 3. Array becomes [4, 2, 6, 1].\\n5. Now, select index 0 (i.e., the number 4) and take the gcd with the number at index 1 (i.e., the number 2), and replace 4 with gcd(4, 2) = 2. Array becomes [2, 2, 6, 1].\\n6. Next, select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 6), and replace 2 with gcd(2, 6) = 2. Array still is [2, 2, 6, 1].\\n7. Repeat step 6. Array still is [2, 2, 6, 1].\\n8. Repeat step 6 again. Array still is [2, 2, 6, 1].\\n9. Repeat step 6 once more. Array still is [2, 2, 6, 1].\\n10. Finally, select index 2 (i.e., the number 6) and take the gcd with the number at index 3 (i.e., the number 1), and replace 6 with gcd(6, 1) = 1. Array becomes [2, \\n\\n2, 1, 1].\\n11. Now, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 2), and replace 2 with gcd(2, 2) = 2. Array still is [2, 2, 1, 1].\\n12. Repeat step 11. Array still is [2, 2, 1, 1].\\n13. Repeat step 11 again. Array still is [2, 2, 1, 1].\\n14. Finally, select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [2, 1, 1, 1].\\n15. Now, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [1, 1, 1, 1].\\n\\nTotal operations = 15.\\n\\nThis demonstrates how the order of the array can affect the total number of operations required to achieve all elements as 1. The most optimized way to get all elements to 1 can depend on the order of elements in the array."
                    },
                    {
                        "username": "ZX007java",
                        "content": "[@s_m99](/s_m99) THANK YOU !!! CONSECUTIVE !!!"
                    },
                    {
                        "username": "s_m99",
                        "content": "You can only calculate gcd\\'s of 2 **consecutive** numbers and replace either of them. So in set [4,2,6,3] to make 3 into 1 we require two operations instead of one in [2,6,3,4] "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Damn, that was a great problem but... Medium, really? Am I just getting dumber? \nTook me quite lot of time and tryhard to see the solution.\nAnd that's gotta be the lowest acceptance rate I've seen for a medium problem\n\nAlso, python has a built-in gcd function apparently. Lesson learned; next time, no need to face my anxieties trying to remember my number theory classes to implement the Euclidean algo myself"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "Anyone explain or hint"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "light hint: how many steps would it take to get your first one in the array? And once you have a one, how many more steps do you need to turn everything into a one?"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "I am not able to understand the question\\nit says \\nselect index i and change num[i] or num[i+1] with their GCD and people have used n^2 loop to check every pair"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement asks for the minimum number of operations required to make all elements of an array equal to 1, by replacing either nums[i] or nums[i+1] with their gcd (greatest common divisor).\\n\\nThe problem solution is implemented with an O(n^2) approach, and this is why:\\n\\n1. You iterate over each element in the array (first loop).\\n2. For each element, you check for a contiguous segment in the array where the gcd of the numbers in the segment equals 1 (second loop). If such a segment is found, you store the length of that segment minus 1 (because one element is already 1 and doesn\\'t need any operation).\\n3. The result of the algorithm is the minimum length of these segments (if any) plus the number of elements outside these segments (because each of these will need one operation to become 1, by taking the gcd with 1).\\n\\nThe algorithm needs to check all pairs of elements because the array isn\\'t necessarily sorted, and any pair (i, j) with i < j can potentially form a contiguous segment where the gcd of the numbers is 1. So, an element nums[i] might be replaced by the gcd of nums[i] and nums[j] for some j > i.\\n"
                    },
                    {
                        "username": "User___",
                        "content": "[@cartesPerforees](/cartesPerforees) Is that $$O(n)$$?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I think you understand the question, it's just the solutions that you don't understand.\nWe check every pair to find the closest elements that could lead to a gcd of 1. Then we propagate the gcd neighbor-by-neighbor"
                    }
                ]
            },
            {
                "id": 1880916,
                "content": [
                    {
                        "username": "rideau",
                        "content": "Does anybody know how solve this in O(1) time? Is this even possible?"
                    },
                    {
                        "username": "brinuke",
                        "content": "Pay no attention to that follow-up. The person who wrote it was drunk."
                    },
                    {
                        "username": "User___",
                        "content": "Did you manage to solve it in $$O(n)$$? Just wondering, since you\\'re asking about $$O(1)$$ (which I feel isn\\'t possible)"
                    },
                    {
                        "username": "SergeyTT",
                        "content": "I think it's quite easy to prove that it impossible to solve this problem in O(1) time complexity.\nImaging you have an array of length N, for which the asnwer is \"-1\" - that is, you cannot make all elements equal to 1 using any number of operations. Now, insert number \"1\" at a random index of the array, and now you can make all other numbers equal to 1. In order to find this \"1\" you need O(N) time complexity."
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, your reasoning is absolutely correct. As per the problem, you need to inspect each element of the array to determine if the number 1 is present or if a pair of numbers exists such that their greatest common divisor (gcd) is 1. This requires at least linear time, O(N), where N is the length of the array.\\n\\nAs you\\'ve aptly illustrated, the presence of a single 1 in the array changes the entire outcome of the problem. Without examining each element, we cannot determine the presence or absence of such a crucial value. This necessitates iterating through the array at least once, thereby confirming that the problem cannot be solved in constant time, O(1)."
                    },
                    {
                        "username": "SlickGeek",
                        "content": "\"...but could you find an O(1) constant time complexity solution?\" Is it actually possible to solve this problem in constant time? I don\\'t know if there\\'s something I am not seeing or understanding, but I don\\'t think that is possible.\\nThe solution I came up with runs in N^2 and beats 71%."
                    },
                    {
                        "username": "bparanj",
                        "content": "[@rideau](/rideau) see [@Sergey TT](/SergeyTT)\\'s respose"
                    },
                    {
                        "username": "rideau",
                        "content": "Any updates? Im also interested "
                    },
                    {
                        "username": "sanjitj7",
                        "content": "EDIT: I have spotted my n00b mistake\n\nI think this test case is incorrect!\n\n>Input: nums = [2,10,6,14]\n>Output: -1\n>Explanation: It can be shown that it is impossible to make all the elements equal to 1\n\n[2,10,6,14]\n[2,10,3,14]  (i = 2)\n[2,10,3,1]   (i = 2)\n[2,10,1,1]\n[2,1,1,1]\n[1,1,1,1]\n\nThis caused a lot of confusion to me."
                    },
                    {
                        "username": "sanjitj7",
                        "content": "oh scheisse, I was taking num/GCD there \\uD83D\\uDE05 "
                    },
                    {
                        "username": "srk696772",
                        "content": "Bro GCD(6,14) == 2 ,  \nnot 3"
                    },
                    {
                        "username": "bekbossyn_kassymkhan",
                        "content": "gcd(6 & 14) = 2 , gcd(10,6)=2 also \n:)"
                    },
                    {
                        "username": "gaurav1903",
                        "content": "What\\'s the O(N) solution??"
                    },
                    {
                        "username": "bparanj",
                        "content": "The O(N) solution leverages the fact that if we can find two numbers in the array whose greatest common divisor (gcd) is 1, then the minimum number of operations required is the size of the array minus 1.\\n\\nTo achieve this in linear time, we can use the Sieve of Eratosthenes, a well-known algorithm for finding all prime numbers up to a given limit. This algorithm can be used to find the smallest prime factor for each number in the array, which is a prerequisite for finding two numbers with gcd 1.\\n\\nHere are the steps of the algorithm:\\n\\n1. Compute the smallest prime factor for each number up to max(nums) using the Sieve of Eratosthenes.\\n2. For each number in nums, if its smallest prime factor divides another number in nums, we can assume that the gcd of these two numbers is 1.\\n3. If we find such a pair, the minimum number of operations required is the size of the array minus 1.\\n4. If no such pair exists, we cannot make all elements equal to 1, so we return -1.\\n\\nNote: As the Sieve of Eratosthenes requires O(N log log N) time complexity, this solution is not strictly linear. However, it is significantly more efficient than an O(N^2) solution when dealing with large inputs.\\n\\nThis solution assumes that the input numbers are not too large (e.g., within the range of an integer). If the numbers can be very large, we need a different approach because the Sieve of Eratosthenes may not be feasible. For example, we could use a probabilistic algorithm to find a pair of numbers with gcd 1, but this would not guarantee a correct answer in all cases.\\n\\nAlso, it\\'s important to note that this approach doesn\\'t give the exact number of operations if no \"1\" is found in the array; it only checks for the possibility of making all elements equal to 1. Calculating the exact number of operations in such a case can be a more complex problem and is likely to require more than linear time."
                    },
                    {
                        "username": "ZX007java",
                        "content": "Good day ! Can anyone give me answer : why set [2, 6, 3, 4] have answer is equal 4, BUT SET [4, 2, 6, 3] have answer is equal 5 ???"
                    },
                    {
                        "username": "bparanj",
                        "content": "This discrepancy arises from the order in which we are allowed to perform the gcd operations on the array.\\n\\nFor the array [2, 6, 3, 4]:\\n\\n1. We can select index 2 (i.e., the number 3) and take the gcd with the number at index 3 (i.e., the number 4), and replace 3 with gcd(3, 4) = 1. Array becomes [2, 6, 1, 4].\\n2. We can then select index 1 (i.e., the number 6) and take the gcd with the number at index 2 (i.e., the number 1), and replace 6 with gcd(6, 1) = 1. Array becomes [2, 1, 1, 4].\\n3. Then, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [1, 1, 1, 4].\\n4. Finally, select index 2 (i.e., the number 1) and take the gcd with the number at index 3 (i.e., the number 4), and replace 4 with gcd(1, 4) = 1. Array becomes [1, 1, 1, 1].\\n\\nTotal operations = 4.\\n\\nFor the array [4, 2, 6, 3]:\\n\\n1. We can select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 6), and replace 2 with gcd(2, 6) = 2. Array becomes [4, 2, 6, 3].\\n2. Repeat step 1. Array still is [4, 2, 6, 3].\\n3. Repeat step 1 again. Array still is [4, 2, 6, 3].\\n4. Finally, select index 3 (i.e., the number 3) and take the gcd with the number at index 2 (i.e., the number 6), and replace 3 with gcd(3, 6) = 3. Array becomes [4, 2, 6, 1].\\n5. Now, select index 0 (i.e., the number 4) and take the gcd with the number at index 1 (i.e., the number 2), and replace 4 with gcd(4, 2) = 2. Array becomes [2, 2, 6, 1].\\n6. Next, select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 6), and replace 2 with gcd(2, 6) = 2. Array still is [2, 2, 6, 1].\\n7. Repeat step 6. Array still is [2, 2, 6, 1].\\n8. Repeat step 6 again. Array still is [2, 2, 6, 1].\\n9. Repeat step 6 once more. Array still is [2, 2, 6, 1].\\n10. Finally, select index 2 (i.e., the number 6) and take the gcd with the number at index 3 (i.e., the number 1), and replace 6 with gcd(6, 1) = 1. Array becomes [2, \\n\\n2, 1, 1].\\n11. Now, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 2), and replace 2 with gcd(2, 2) = 2. Array still is [2, 2, 1, 1].\\n12. Repeat step 11. Array still is [2, 2, 1, 1].\\n13. Repeat step 11 again. Array still is [2, 2, 1, 1].\\n14. Finally, select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [2, 1, 1, 1].\\n15. Now, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [1, 1, 1, 1].\\n\\nTotal operations = 15.\\n\\nThis demonstrates how the order of the array can affect the total number of operations required to achieve all elements as 1. The most optimized way to get all elements to 1 can depend on the order of elements in the array."
                    },
                    {
                        "username": "ZX007java",
                        "content": "[@s_m99](/s_m99) THANK YOU !!! CONSECUTIVE !!!"
                    },
                    {
                        "username": "s_m99",
                        "content": "You can only calculate gcd\\'s of 2 **consecutive** numbers and replace either of them. So in set [4,2,6,3] to make 3 into 1 we require two operations instead of one in [2,6,3,4] "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Damn, that was a great problem but... Medium, really? Am I just getting dumber? \nTook me quite lot of time and tryhard to see the solution.\nAnd that's gotta be the lowest acceptance rate I've seen for a medium problem\n\nAlso, python has a built-in gcd function apparently. Lesson learned; next time, no need to face my anxieties trying to remember my number theory classes to implement the Euclidean algo myself"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "Anyone explain or hint"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "light hint: how many steps would it take to get your first one in the array? And once you have a one, how many more steps do you need to turn everything into a one?"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "I am not able to understand the question\\nit says \\nselect index i and change num[i] or num[i+1] with their GCD and people have used n^2 loop to check every pair"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement asks for the minimum number of operations required to make all elements of an array equal to 1, by replacing either nums[i] or nums[i+1] with their gcd (greatest common divisor).\\n\\nThe problem solution is implemented with an O(n^2) approach, and this is why:\\n\\n1. You iterate over each element in the array (first loop).\\n2. For each element, you check for a contiguous segment in the array where the gcd of the numbers in the segment equals 1 (second loop). If such a segment is found, you store the length of that segment minus 1 (because one element is already 1 and doesn\\'t need any operation).\\n3. The result of the algorithm is the minimum length of these segments (if any) plus the number of elements outside these segments (because each of these will need one operation to become 1, by taking the gcd with 1).\\n\\nThe algorithm needs to check all pairs of elements because the array isn\\'t necessarily sorted, and any pair (i, j) with i < j can potentially form a contiguous segment where the gcd of the numbers is 1. So, an element nums[i] might be replaced by the gcd of nums[i] and nums[j] for some j > i.\\n"
                    },
                    {
                        "username": "User___",
                        "content": "[@cartesPerforees](/cartesPerforees) Is that $$O(n)$$?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I think you understand the question, it's just the solutions that you don't understand.\nWe check every pair to find the closest elements that could lead to a gcd of 1. Then we propagate the gcd neighbor-by-neighbor"
                    }
                ]
            },
            {
                "id": 1872644,
                "content": [
                    {
                        "username": "rideau",
                        "content": "Does anybody know how solve this in O(1) time? Is this even possible?"
                    },
                    {
                        "username": "brinuke",
                        "content": "Pay no attention to that follow-up. The person who wrote it was drunk."
                    },
                    {
                        "username": "User___",
                        "content": "Did you manage to solve it in $$O(n)$$? Just wondering, since you\\'re asking about $$O(1)$$ (which I feel isn\\'t possible)"
                    },
                    {
                        "username": "SergeyTT",
                        "content": "I think it's quite easy to prove that it impossible to solve this problem in O(1) time complexity.\nImaging you have an array of length N, for which the asnwer is \"-1\" - that is, you cannot make all elements equal to 1 using any number of operations. Now, insert number \"1\" at a random index of the array, and now you can make all other numbers equal to 1. In order to find this \"1\" you need O(N) time complexity."
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, your reasoning is absolutely correct. As per the problem, you need to inspect each element of the array to determine if the number 1 is present or if a pair of numbers exists such that their greatest common divisor (gcd) is 1. This requires at least linear time, O(N), where N is the length of the array.\\n\\nAs you\\'ve aptly illustrated, the presence of a single 1 in the array changes the entire outcome of the problem. Without examining each element, we cannot determine the presence or absence of such a crucial value. This necessitates iterating through the array at least once, thereby confirming that the problem cannot be solved in constant time, O(1)."
                    },
                    {
                        "username": "SlickGeek",
                        "content": "\"...but could you find an O(1) constant time complexity solution?\" Is it actually possible to solve this problem in constant time? I don\\'t know if there\\'s something I am not seeing or understanding, but I don\\'t think that is possible.\\nThe solution I came up with runs in N^2 and beats 71%."
                    },
                    {
                        "username": "bparanj",
                        "content": "[@rideau](/rideau) see [@Sergey TT](/SergeyTT)\\'s respose"
                    },
                    {
                        "username": "rideau",
                        "content": "Any updates? Im also interested "
                    },
                    {
                        "username": "sanjitj7",
                        "content": "EDIT: I have spotted my n00b mistake\n\nI think this test case is incorrect!\n\n>Input: nums = [2,10,6,14]\n>Output: -1\n>Explanation: It can be shown that it is impossible to make all the elements equal to 1\n\n[2,10,6,14]\n[2,10,3,14]  (i = 2)\n[2,10,3,1]   (i = 2)\n[2,10,1,1]\n[2,1,1,1]\n[1,1,1,1]\n\nThis caused a lot of confusion to me."
                    },
                    {
                        "username": "sanjitj7",
                        "content": "oh scheisse, I was taking num/GCD there \\uD83D\\uDE05 "
                    },
                    {
                        "username": "srk696772",
                        "content": "Bro GCD(6,14) == 2 ,  \nnot 3"
                    },
                    {
                        "username": "bekbossyn_kassymkhan",
                        "content": "gcd(6 & 14) = 2 , gcd(10,6)=2 also \n:)"
                    },
                    {
                        "username": "gaurav1903",
                        "content": "What\\'s the O(N) solution??"
                    },
                    {
                        "username": "bparanj",
                        "content": "The O(N) solution leverages the fact that if we can find two numbers in the array whose greatest common divisor (gcd) is 1, then the minimum number of operations required is the size of the array minus 1.\\n\\nTo achieve this in linear time, we can use the Sieve of Eratosthenes, a well-known algorithm for finding all prime numbers up to a given limit. This algorithm can be used to find the smallest prime factor for each number in the array, which is a prerequisite for finding two numbers with gcd 1.\\n\\nHere are the steps of the algorithm:\\n\\n1. Compute the smallest prime factor for each number up to max(nums) using the Sieve of Eratosthenes.\\n2. For each number in nums, if its smallest prime factor divides another number in nums, we can assume that the gcd of these two numbers is 1.\\n3. If we find such a pair, the minimum number of operations required is the size of the array minus 1.\\n4. If no such pair exists, we cannot make all elements equal to 1, so we return -1.\\n\\nNote: As the Sieve of Eratosthenes requires O(N log log N) time complexity, this solution is not strictly linear. However, it is significantly more efficient than an O(N^2) solution when dealing with large inputs.\\n\\nThis solution assumes that the input numbers are not too large (e.g., within the range of an integer). If the numbers can be very large, we need a different approach because the Sieve of Eratosthenes may not be feasible. For example, we could use a probabilistic algorithm to find a pair of numbers with gcd 1, but this would not guarantee a correct answer in all cases.\\n\\nAlso, it\\'s important to note that this approach doesn\\'t give the exact number of operations if no \"1\" is found in the array; it only checks for the possibility of making all elements equal to 1. Calculating the exact number of operations in such a case can be a more complex problem and is likely to require more than linear time."
                    },
                    {
                        "username": "ZX007java",
                        "content": "Good day ! Can anyone give me answer : why set [2, 6, 3, 4] have answer is equal 4, BUT SET [4, 2, 6, 3] have answer is equal 5 ???"
                    },
                    {
                        "username": "bparanj",
                        "content": "This discrepancy arises from the order in which we are allowed to perform the gcd operations on the array.\\n\\nFor the array [2, 6, 3, 4]:\\n\\n1. We can select index 2 (i.e., the number 3) and take the gcd with the number at index 3 (i.e., the number 4), and replace 3 with gcd(3, 4) = 1. Array becomes [2, 6, 1, 4].\\n2. We can then select index 1 (i.e., the number 6) and take the gcd with the number at index 2 (i.e., the number 1), and replace 6 with gcd(6, 1) = 1. Array becomes [2, 1, 1, 4].\\n3. Then, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [1, 1, 1, 4].\\n4. Finally, select index 2 (i.e., the number 1) and take the gcd with the number at index 3 (i.e., the number 4), and replace 4 with gcd(1, 4) = 1. Array becomes [1, 1, 1, 1].\\n\\nTotal operations = 4.\\n\\nFor the array [4, 2, 6, 3]:\\n\\n1. We can select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 6), and replace 2 with gcd(2, 6) = 2. Array becomes [4, 2, 6, 3].\\n2. Repeat step 1. Array still is [4, 2, 6, 3].\\n3. Repeat step 1 again. Array still is [4, 2, 6, 3].\\n4. Finally, select index 3 (i.e., the number 3) and take the gcd with the number at index 2 (i.e., the number 6), and replace 3 with gcd(3, 6) = 3. Array becomes [4, 2, 6, 1].\\n5. Now, select index 0 (i.e., the number 4) and take the gcd with the number at index 1 (i.e., the number 2), and replace 4 with gcd(4, 2) = 2. Array becomes [2, 2, 6, 1].\\n6. Next, select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 6), and replace 2 with gcd(2, 6) = 2. Array still is [2, 2, 6, 1].\\n7. Repeat step 6. Array still is [2, 2, 6, 1].\\n8. Repeat step 6 again. Array still is [2, 2, 6, 1].\\n9. Repeat step 6 once more. Array still is [2, 2, 6, 1].\\n10. Finally, select index 2 (i.e., the number 6) and take the gcd with the number at index 3 (i.e., the number 1), and replace 6 with gcd(6, 1) = 1. Array becomes [2, \\n\\n2, 1, 1].\\n11. Now, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 2), and replace 2 with gcd(2, 2) = 2. Array still is [2, 2, 1, 1].\\n12. Repeat step 11. Array still is [2, 2, 1, 1].\\n13. Repeat step 11 again. Array still is [2, 2, 1, 1].\\n14. Finally, select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [2, 1, 1, 1].\\n15. Now, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [1, 1, 1, 1].\\n\\nTotal operations = 15.\\n\\nThis demonstrates how the order of the array can affect the total number of operations required to achieve all elements as 1. The most optimized way to get all elements to 1 can depend on the order of elements in the array."
                    },
                    {
                        "username": "ZX007java",
                        "content": "[@s_m99](/s_m99) THANK YOU !!! CONSECUTIVE !!!"
                    },
                    {
                        "username": "s_m99",
                        "content": "You can only calculate gcd\\'s of 2 **consecutive** numbers and replace either of them. So in set [4,2,6,3] to make 3 into 1 we require two operations instead of one in [2,6,3,4] "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Damn, that was a great problem but... Medium, really? Am I just getting dumber? \nTook me quite lot of time and tryhard to see the solution.\nAnd that's gotta be the lowest acceptance rate I've seen for a medium problem\n\nAlso, python has a built-in gcd function apparently. Lesson learned; next time, no need to face my anxieties trying to remember my number theory classes to implement the Euclidean algo myself"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "Anyone explain or hint"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "light hint: how many steps would it take to get your first one in the array? And once you have a one, how many more steps do you need to turn everything into a one?"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "I am not able to understand the question\\nit says \\nselect index i and change num[i] or num[i+1] with their GCD and people have used n^2 loop to check every pair"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement asks for the minimum number of operations required to make all elements of an array equal to 1, by replacing either nums[i] or nums[i+1] with their gcd (greatest common divisor).\\n\\nThe problem solution is implemented with an O(n^2) approach, and this is why:\\n\\n1. You iterate over each element in the array (first loop).\\n2. For each element, you check for a contiguous segment in the array where the gcd of the numbers in the segment equals 1 (second loop). If such a segment is found, you store the length of that segment minus 1 (because one element is already 1 and doesn\\'t need any operation).\\n3. The result of the algorithm is the minimum length of these segments (if any) plus the number of elements outside these segments (because each of these will need one operation to become 1, by taking the gcd with 1).\\n\\nThe algorithm needs to check all pairs of elements because the array isn\\'t necessarily sorted, and any pair (i, j) with i < j can potentially form a contiguous segment where the gcd of the numbers is 1. So, an element nums[i] might be replaced by the gcd of nums[i] and nums[j] for some j > i.\\n"
                    },
                    {
                        "username": "User___",
                        "content": "[@cartesPerforees](/cartesPerforees) Is that $$O(n)$$?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I think you understand the question, it's just the solutions that you don't understand.\nWe check every pair to find the closest elements that could lead to a gcd of 1. Then we propagate the gcd neighbor-by-neighbor"
                    }
                ]
            },
            {
                "id": 1871729,
                "content": [
                    {
                        "username": "rideau",
                        "content": "Does anybody know how solve this in O(1) time? Is this even possible?"
                    },
                    {
                        "username": "brinuke",
                        "content": "Pay no attention to that follow-up. The person who wrote it was drunk."
                    },
                    {
                        "username": "User___",
                        "content": "Did you manage to solve it in $$O(n)$$? Just wondering, since you\\'re asking about $$O(1)$$ (which I feel isn\\'t possible)"
                    },
                    {
                        "username": "SergeyTT",
                        "content": "I think it's quite easy to prove that it impossible to solve this problem in O(1) time complexity.\nImaging you have an array of length N, for which the asnwer is \"-1\" - that is, you cannot make all elements equal to 1 using any number of operations. Now, insert number \"1\" at a random index of the array, and now you can make all other numbers equal to 1. In order to find this \"1\" you need O(N) time complexity."
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, your reasoning is absolutely correct. As per the problem, you need to inspect each element of the array to determine if the number 1 is present or if a pair of numbers exists such that their greatest common divisor (gcd) is 1. This requires at least linear time, O(N), where N is the length of the array.\\n\\nAs you\\'ve aptly illustrated, the presence of a single 1 in the array changes the entire outcome of the problem. Without examining each element, we cannot determine the presence or absence of such a crucial value. This necessitates iterating through the array at least once, thereby confirming that the problem cannot be solved in constant time, O(1)."
                    },
                    {
                        "username": "SlickGeek",
                        "content": "\"...but could you find an O(1) constant time complexity solution?\" Is it actually possible to solve this problem in constant time? I don\\'t know if there\\'s something I am not seeing or understanding, but I don\\'t think that is possible.\\nThe solution I came up with runs in N^2 and beats 71%."
                    },
                    {
                        "username": "bparanj",
                        "content": "[@rideau](/rideau) see [@Sergey TT](/SergeyTT)\\'s respose"
                    },
                    {
                        "username": "rideau",
                        "content": "Any updates? Im also interested "
                    },
                    {
                        "username": "sanjitj7",
                        "content": "EDIT: I have spotted my n00b mistake\n\nI think this test case is incorrect!\n\n>Input: nums = [2,10,6,14]\n>Output: -1\n>Explanation: It can be shown that it is impossible to make all the elements equal to 1\n\n[2,10,6,14]\n[2,10,3,14]  (i = 2)\n[2,10,3,1]   (i = 2)\n[2,10,1,1]\n[2,1,1,1]\n[1,1,1,1]\n\nThis caused a lot of confusion to me."
                    },
                    {
                        "username": "sanjitj7",
                        "content": "oh scheisse, I was taking num/GCD there \\uD83D\\uDE05 "
                    },
                    {
                        "username": "srk696772",
                        "content": "Bro GCD(6,14) == 2 ,  \nnot 3"
                    },
                    {
                        "username": "bekbossyn_kassymkhan",
                        "content": "gcd(6 & 14) = 2 , gcd(10,6)=2 also \n:)"
                    },
                    {
                        "username": "gaurav1903",
                        "content": "What\\'s the O(N) solution??"
                    },
                    {
                        "username": "bparanj",
                        "content": "The O(N) solution leverages the fact that if we can find two numbers in the array whose greatest common divisor (gcd) is 1, then the minimum number of operations required is the size of the array minus 1.\\n\\nTo achieve this in linear time, we can use the Sieve of Eratosthenes, a well-known algorithm for finding all prime numbers up to a given limit. This algorithm can be used to find the smallest prime factor for each number in the array, which is a prerequisite for finding two numbers with gcd 1.\\n\\nHere are the steps of the algorithm:\\n\\n1. Compute the smallest prime factor for each number up to max(nums) using the Sieve of Eratosthenes.\\n2. For each number in nums, if its smallest prime factor divides another number in nums, we can assume that the gcd of these two numbers is 1.\\n3. If we find such a pair, the minimum number of operations required is the size of the array minus 1.\\n4. If no such pair exists, we cannot make all elements equal to 1, so we return -1.\\n\\nNote: As the Sieve of Eratosthenes requires O(N log log N) time complexity, this solution is not strictly linear. However, it is significantly more efficient than an O(N^2) solution when dealing with large inputs.\\n\\nThis solution assumes that the input numbers are not too large (e.g., within the range of an integer). If the numbers can be very large, we need a different approach because the Sieve of Eratosthenes may not be feasible. For example, we could use a probabilistic algorithm to find a pair of numbers with gcd 1, but this would not guarantee a correct answer in all cases.\\n\\nAlso, it\\'s important to note that this approach doesn\\'t give the exact number of operations if no \"1\" is found in the array; it only checks for the possibility of making all elements equal to 1. Calculating the exact number of operations in such a case can be a more complex problem and is likely to require more than linear time."
                    },
                    {
                        "username": "ZX007java",
                        "content": "Good day ! Can anyone give me answer : why set [2, 6, 3, 4] have answer is equal 4, BUT SET [4, 2, 6, 3] have answer is equal 5 ???"
                    },
                    {
                        "username": "bparanj",
                        "content": "This discrepancy arises from the order in which we are allowed to perform the gcd operations on the array.\\n\\nFor the array [2, 6, 3, 4]:\\n\\n1. We can select index 2 (i.e., the number 3) and take the gcd with the number at index 3 (i.e., the number 4), and replace 3 with gcd(3, 4) = 1. Array becomes [2, 6, 1, 4].\\n2. We can then select index 1 (i.e., the number 6) and take the gcd with the number at index 2 (i.e., the number 1), and replace 6 with gcd(6, 1) = 1. Array becomes [2, 1, 1, 4].\\n3. Then, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [1, 1, 1, 4].\\n4. Finally, select index 2 (i.e., the number 1) and take the gcd with the number at index 3 (i.e., the number 4), and replace 4 with gcd(1, 4) = 1. Array becomes [1, 1, 1, 1].\\n\\nTotal operations = 4.\\n\\nFor the array [4, 2, 6, 3]:\\n\\n1. We can select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 6), and replace 2 with gcd(2, 6) = 2. Array becomes [4, 2, 6, 3].\\n2. Repeat step 1. Array still is [4, 2, 6, 3].\\n3. Repeat step 1 again. Array still is [4, 2, 6, 3].\\n4. Finally, select index 3 (i.e., the number 3) and take the gcd with the number at index 2 (i.e., the number 6), and replace 3 with gcd(3, 6) = 3. Array becomes [4, 2, 6, 1].\\n5. Now, select index 0 (i.e., the number 4) and take the gcd with the number at index 1 (i.e., the number 2), and replace 4 with gcd(4, 2) = 2. Array becomes [2, 2, 6, 1].\\n6. Next, select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 6), and replace 2 with gcd(2, 6) = 2. Array still is [2, 2, 6, 1].\\n7. Repeat step 6. Array still is [2, 2, 6, 1].\\n8. Repeat step 6 again. Array still is [2, 2, 6, 1].\\n9. Repeat step 6 once more. Array still is [2, 2, 6, 1].\\n10. Finally, select index 2 (i.e., the number 6) and take the gcd with the number at index 3 (i.e., the number 1), and replace 6 with gcd(6, 1) = 1. Array becomes [2, \\n\\n2, 1, 1].\\n11. Now, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 2), and replace 2 with gcd(2, 2) = 2. Array still is [2, 2, 1, 1].\\n12. Repeat step 11. Array still is [2, 2, 1, 1].\\n13. Repeat step 11 again. Array still is [2, 2, 1, 1].\\n14. Finally, select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [2, 1, 1, 1].\\n15. Now, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [1, 1, 1, 1].\\n\\nTotal operations = 15.\\n\\nThis demonstrates how the order of the array can affect the total number of operations required to achieve all elements as 1. The most optimized way to get all elements to 1 can depend on the order of elements in the array."
                    },
                    {
                        "username": "ZX007java",
                        "content": "[@s_m99](/s_m99) THANK YOU !!! CONSECUTIVE !!!"
                    },
                    {
                        "username": "s_m99",
                        "content": "You can only calculate gcd\\'s of 2 **consecutive** numbers and replace either of them. So in set [4,2,6,3] to make 3 into 1 we require two operations instead of one in [2,6,3,4] "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Damn, that was a great problem but... Medium, really? Am I just getting dumber? \nTook me quite lot of time and tryhard to see the solution.\nAnd that's gotta be the lowest acceptance rate I've seen for a medium problem\n\nAlso, python has a built-in gcd function apparently. Lesson learned; next time, no need to face my anxieties trying to remember my number theory classes to implement the Euclidean algo myself"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "Anyone explain or hint"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "light hint: how many steps would it take to get your first one in the array? And once you have a one, how many more steps do you need to turn everything into a one?"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "I am not able to understand the question\\nit says \\nselect index i and change num[i] or num[i+1] with their GCD and people have used n^2 loop to check every pair"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement asks for the minimum number of operations required to make all elements of an array equal to 1, by replacing either nums[i] or nums[i+1] with their gcd (greatest common divisor).\\n\\nThe problem solution is implemented with an O(n^2) approach, and this is why:\\n\\n1. You iterate over each element in the array (first loop).\\n2. For each element, you check for a contiguous segment in the array where the gcd of the numbers in the segment equals 1 (second loop). If such a segment is found, you store the length of that segment minus 1 (because one element is already 1 and doesn\\'t need any operation).\\n3. The result of the algorithm is the minimum length of these segments (if any) plus the number of elements outside these segments (because each of these will need one operation to become 1, by taking the gcd with 1).\\n\\nThe algorithm needs to check all pairs of elements because the array isn\\'t necessarily sorted, and any pair (i, j) with i < j can potentially form a contiguous segment where the gcd of the numbers is 1. So, an element nums[i] might be replaced by the gcd of nums[i] and nums[j] for some j > i.\\n"
                    },
                    {
                        "username": "User___",
                        "content": "[@cartesPerforees](/cartesPerforees) Is that $$O(n)$$?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I think you understand the question, it's just the solutions that you don't understand.\nWe check every pair to find the closest elements that could lead to a gcd of 1. Then we propagate the gcd neighbor-by-neighbor"
                    }
                ]
            },
            {
                "id": 1871577,
                "content": [
                    {
                        "username": "rideau",
                        "content": "Does anybody know how solve this in O(1) time? Is this even possible?"
                    },
                    {
                        "username": "brinuke",
                        "content": "Pay no attention to that follow-up. The person who wrote it was drunk."
                    },
                    {
                        "username": "User___",
                        "content": "Did you manage to solve it in $$O(n)$$? Just wondering, since you\\'re asking about $$O(1)$$ (which I feel isn\\'t possible)"
                    },
                    {
                        "username": "SergeyTT",
                        "content": "I think it's quite easy to prove that it impossible to solve this problem in O(1) time complexity.\nImaging you have an array of length N, for which the asnwer is \"-1\" - that is, you cannot make all elements equal to 1 using any number of operations. Now, insert number \"1\" at a random index of the array, and now you can make all other numbers equal to 1. In order to find this \"1\" you need O(N) time complexity."
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, your reasoning is absolutely correct. As per the problem, you need to inspect each element of the array to determine if the number 1 is present or if a pair of numbers exists such that their greatest common divisor (gcd) is 1. This requires at least linear time, O(N), where N is the length of the array.\\n\\nAs you\\'ve aptly illustrated, the presence of a single 1 in the array changes the entire outcome of the problem. Without examining each element, we cannot determine the presence or absence of such a crucial value. This necessitates iterating through the array at least once, thereby confirming that the problem cannot be solved in constant time, O(1)."
                    },
                    {
                        "username": "SlickGeek",
                        "content": "\"...but could you find an O(1) constant time complexity solution?\" Is it actually possible to solve this problem in constant time? I don\\'t know if there\\'s something I am not seeing or understanding, but I don\\'t think that is possible.\\nThe solution I came up with runs in N^2 and beats 71%."
                    },
                    {
                        "username": "bparanj",
                        "content": "[@rideau](/rideau) see [@Sergey TT](/SergeyTT)\\'s respose"
                    },
                    {
                        "username": "rideau",
                        "content": "Any updates? Im also interested "
                    },
                    {
                        "username": "sanjitj7",
                        "content": "EDIT: I have spotted my n00b mistake\n\nI think this test case is incorrect!\n\n>Input: nums = [2,10,6,14]\n>Output: -1\n>Explanation: It can be shown that it is impossible to make all the elements equal to 1\n\n[2,10,6,14]\n[2,10,3,14]  (i = 2)\n[2,10,3,1]   (i = 2)\n[2,10,1,1]\n[2,1,1,1]\n[1,1,1,1]\n\nThis caused a lot of confusion to me."
                    },
                    {
                        "username": "sanjitj7",
                        "content": "oh scheisse, I was taking num/GCD there \\uD83D\\uDE05 "
                    },
                    {
                        "username": "srk696772",
                        "content": "Bro GCD(6,14) == 2 ,  \nnot 3"
                    },
                    {
                        "username": "bekbossyn_kassymkhan",
                        "content": "gcd(6 & 14) = 2 , gcd(10,6)=2 also \n:)"
                    },
                    {
                        "username": "gaurav1903",
                        "content": "What\\'s the O(N) solution??"
                    },
                    {
                        "username": "bparanj",
                        "content": "The O(N) solution leverages the fact that if we can find two numbers in the array whose greatest common divisor (gcd) is 1, then the minimum number of operations required is the size of the array minus 1.\\n\\nTo achieve this in linear time, we can use the Sieve of Eratosthenes, a well-known algorithm for finding all prime numbers up to a given limit. This algorithm can be used to find the smallest prime factor for each number in the array, which is a prerequisite for finding two numbers with gcd 1.\\n\\nHere are the steps of the algorithm:\\n\\n1. Compute the smallest prime factor for each number up to max(nums) using the Sieve of Eratosthenes.\\n2. For each number in nums, if its smallest prime factor divides another number in nums, we can assume that the gcd of these two numbers is 1.\\n3. If we find such a pair, the minimum number of operations required is the size of the array minus 1.\\n4. If no such pair exists, we cannot make all elements equal to 1, so we return -1.\\n\\nNote: As the Sieve of Eratosthenes requires O(N log log N) time complexity, this solution is not strictly linear. However, it is significantly more efficient than an O(N^2) solution when dealing with large inputs.\\n\\nThis solution assumes that the input numbers are not too large (e.g., within the range of an integer). If the numbers can be very large, we need a different approach because the Sieve of Eratosthenes may not be feasible. For example, we could use a probabilistic algorithm to find a pair of numbers with gcd 1, but this would not guarantee a correct answer in all cases.\\n\\nAlso, it\\'s important to note that this approach doesn\\'t give the exact number of operations if no \"1\" is found in the array; it only checks for the possibility of making all elements equal to 1. Calculating the exact number of operations in such a case can be a more complex problem and is likely to require more than linear time."
                    },
                    {
                        "username": "ZX007java",
                        "content": "Good day ! Can anyone give me answer : why set [2, 6, 3, 4] have answer is equal 4, BUT SET [4, 2, 6, 3] have answer is equal 5 ???"
                    },
                    {
                        "username": "bparanj",
                        "content": "This discrepancy arises from the order in which we are allowed to perform the gcd operations on the array.\\n\\nFor the array [2, 6, 3, 4]:\\n\\n1. We can select index 2 (i.e., the number 3) and take the gcd with the number at index 3 (i.e., the number 4), and replace 3 with gcd(3, 4) = 1. Array becomes [2, 6, 1, 4].\\n2. We can then select index 1 (i.e., the number 6) and take the gcd with the number at index 2 (i.e., the number 1), and replace 6 with gcd(6, 1) = 1. Array becomes [2, 1, 1, 4].\\n3. Then, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [1, 1, 1, 4].\\n4. Finally, select index 2 (i.e., the number 1) and take the gcd with the number at index 3 (i.e., the number 4), and replace 4 with gcd(1, 4) = 1. Array becomes [1, 1, 1, 1].\\n\\nTotal operations = 4.\\n\\nFor the array [4, 2, 6, 3]:\\n\\n1. We can select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 6), and replace 2 with gcd(2, 6) = 2. Array becomes [4, 2, 6, 3].\\n2. Repeat step 1. Array still is [4, 2, 6, 3].\\n3. Repeat step 1 again. Array still is [4, 2, 6, 3].\\n4. Finally, select index 3 (i.e., the number 3) and take the gcd with the number at index 2 (i.e., the number 6), and replace 3 with gcd(3, 6) = 3. Array becomes [4, 2, 6, 1].\\n5. Now, select index 0 (i.e., the number 4) and take the gcd with the number at index 1 (i.e., the number 2), and replace 4 with gcd(4, 2) = 2. Array becomes [2, 2, 6, 1].\\n6. Next, select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 6), and replace 2 with gcd(2, 6) = 2. Array still is [2, 2, 6, 1].\\n7. Repeat step 6. Array still is [2, 2, 6, 1].\\n8. Repeat step 6 again. Array still is [2, 2, 6, 1].\\n9. Repeat step 6 once more. Array still is [2, 2, 6, 1].\\n10. Finally, select index 2 (i.e., the number 6) and take the gcd with the number at index 3 (i.e., the number 1), and replace 6 with gcd(6, 1) = 1. Array becomes [2, \\n\\n2, 1, 1].\\n11. Now, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 2), and replace 2 with gcd(2, 2) = 2. Array still is [2, 2, 1, 1].\\n12. Repeat step 11. Array still is [2, 2, 1, 1].\\n13. Repeat step 11 again. Array still is [2, 2, 1, 1].\\n14. Finally, select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [2, 1, 1, 1].\\n15. Now, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [1, 1, 1, 1].\\n\\nTotal operations = 15.\\n\\nThis demonstrates how the order of the array can affect the total number of operations required to achieve all elements as 1. The most optimized way to get all elements to 1 can depend on the order of elements in the array."
                    },
                    {
                        "username": "ZX007java",
                        "content": "[@s_m99](/s_m99) THANK YOU !!! CONSECUTIVE !!!"
                    },
                    {
                        "username": "s_m99",
                        "content": "You can only calculate gcd\\'s of 2 **consecutive** numbers and replace either of them. So in set [4,2,6,3] to make 3 into 1 we require two operations instead of one in [2,6,3,4] "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Damn, that was a great problem but... Medium, really? Am I just getting dumber? \nTook me quite lot of time and tryhard to see the solution.\nAnd that's gotta be the lowest acceptance rate I've seen for a medium problem\n\nAlso, python has a built-in gcd function apparently. Lesson learned; next time, no need to face my anxieties trying to remember my number theory classes to implement the Euclidean algo myself"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "Anyone explain or hint"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "light hint: how many steps would it take to get your first one in the array? And once you have a one, how many more steps do you need to turn everything into a one?"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "I am not able to understand the question\\nit says \\nselect index i and change num[i] or num[i+1] with their GCD and people have used n^2 loop to check every pair"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement asks for the minimum number of operations required to make all elements of an array equal to 1, by replacing either nums[i] or nums[i+1] with their gcd (greatest common divisor).\\n\\nThe problem solution is implemented with an O(n^2) approach, and this is why:\\n\\n1. You iterate over each element in the array (first loop).\\n2. For each element, you check for a contiguous segment in the array where the gcd of the numbers in the segment equals 1 (second loop). If such a segment is found, you store the length of that segment minus 1 (because one element is already 1 and doesn\\'t need any operation).\\n3. The result of the algorithm is the minimum length of these segments (if any) plus the number of elements outside these segments (because each of these will need one operation to become 1, by taking the gcd with 1).\\n\\nThe algorithm needs to check all pairs of elements because the array isn\\'t necessarily sorted, and any pair (i, j) with i < j can potentially form a contiguous segment where the gcd of the numbers is 1. So, an element nums[i] might be replaced by the gcd of nums[i] and nums[j] for some j > i.\\n"
                    },
                    {
                        "username": "User___",
                        "content": "[@cartesPerforees](/cartesPerforees) Is that $$O(n)$$?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I think you understand the question, it's just the solutions that you don't understand.\nWe check every pair to find the closest elements that could lead to a gcd of 1. Then we propagate the gcd neighbor-by-neighbor"
                    }
                ]
            },
            {
                "id": 1873923,
                "content": [
                    {
                        "username": "rideau",
                        "content": "Does anybody know how solve this in O(1) time? Is this even possible?"
                    },
                    {
                        "username": "brinuke",
                        "content": "Pay no attention to that follow-up. The person who wrote it was drunk."
                    },
                    {
                        "username": "User___",
                        "content": "Did you manage to solve it in $$O(n)$$? Just wondering, since you\\'re asking about $$O(1)$$ (which I feel isn\\'t possible)"
                    },
                    {
                        "username": "SergeyTT",
                        "content": "I think it's quite easy to prove that it impossible to solve this problem in O(1) time complexity.\nImaging you have an array of length N, for which the asnwer is \"-1\" - that is, you cannot make all elements equal to 1 using any number of operations. Now, insert number \"1\" at a random index of the array, and now you can make all other numbers equal to 1. In order to find this \"1\" you need O(N) time complexity."
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, your reasoning is absolutely correct. As per the problem, you need to inspect each element of the array to determine if the number 1 is present or if a pair of numbers exists such that their greatest common divisor (gcd) is 1. This requires at least linear time, O(N), where N is the length of the array.\\n\\nAs you\\'ve aptly illustrated, the presence of a single 1 in the array changes the entire outcome of the problem. Without examining each element, we cannot determine the presence or absence of such a crucial value. This necessitates iterating through the array at least once, thereby confirming that the problem cannot be solved in constant time, O(1)."
                    },
                    {
                        "username": "SlickGeek",
                        "content": "\"...but could you find an O(1) constant time complexity solution?\" Is it actually possible to solve this problem in constant time? I don\\'t know if there\\'s something I am not seeing or understanding, but I don\\'t think that is possible.\\nThe solution I came up with runs in N^2 and beats 71%."
                    },
                    {
                        "username": "bparanj",
                        "content": "[@rideau](/rideau) see [@Sergey TT](/SergeyTT)\\'s respose"
                    },
                    {
                        "username": "rideau",
                        "content": "Any updates? Im also interested "
                    },
                    {
                        "username": "sanjitj7",
                        "content": "EDIT: I have spotted my n00b mistake\n\nI think this test case is incorrect!\n\n>Input: nums = [2,10,6,14]\n>Output: -1\n>Explanation: It can be shown that it is impossible to make all the elements equal to 1\n\n[2,10,6,14]\n[2,10,3,14]  (i = 2)\n[2,10,3,1]   (i = 2)\n[2,10,1,1]\n[2,1,1,1]\n[1,1,1,1]\n\nThis caused a lot of confusion to me."
                    },
                    {
                        "username": "sanjitj7",
                        "content": "oh scheisse, I was taking num/GCD there \\uD83D\\uDE05 "
                    },
                    {
                        "username": "srk696772",
                        "content": "Bro GCD(6,14) == 2 ,  \nnot 3"
                    },
                    {
                        "username": "bekbossyn_kassymkhan",
                        "content": "gcd(6 & 14) = 2 , gcd(10,6)=2 also \n:)"
                    },
                    {
                        "username": "gaurav1903",
                        "content": "What\\'s the O(N) solution??"
                    },
                    {
                        "username": "bparanj",
                        "content": "The O(N) solution leverages the fact that if we can find two numbers in the array whose greatest common divisor (gcd) is 1, then the minimum number of operations required is the size of the array minus 1.\\n\\nTo achieve this in linear time, we can use the Sieve of Eratosthenes, a well-known algorithm for finding all prime numbers up to a given limit. This algorithm can be used to find the smallest prime factor for each number in the array, which is a prerequisite for finding two numbers with gcd 1.\\n\\nHere are the steps of the algorithm:\\n\\n1. Compute the smallest prime factor for each number up to max(nums) using the Sieve of Eratosthenes.\\n2. For each number in nums, if its smallest prime factor divides another number in nums, we can assume that the gcd of these two numbers is 1.\\n3. If we find such a pair, the minimum number of operations required is the size of the array minus 1.\\n4. If no such pair exists, we cannot make all elements equal to 1, so we return -1.\\n\\nNote: As the Sieve of Eratosthenes requires O(N log log N) time complexity, this solution is not strictly linear. However, it is significantly more efficient than an O(N^2) solution when dealing with large inputs.\\n\\nThis solution assumes that the input numbers are not too large (e.g., within the range of an integer). If the numbers can be very large, we need a different approach because the Sieve of Eratosthenes may not be feasible. For example, we could use a probabilistic algorithm to find a pair of numbers with gcd 1, but this would not guarantee a correct answer in all cases.\\n\\nAlso, it\\'s important to note that this approach doesn\\'t give the exact number of operations if no \"1\" is found in the array; it only checks for the possibility of making all elements equal to 1. Calculating the exact number of operations in such a case can be a more complex problem and is likely to require more than linear time."
                    },
                    {
                        "username": "ZX007java",
                        "content": "Good day ! Can anyone give me answer : why set [2, 6, 3, 4] have answer is equal 4, BUT SET [4, 2, 6, 3] have answer is equal 5 ???"
                    },
                    {
                        "username": "bparanj",
                        "content": "This discrepancy arises from the order in which we are allowed to perform the gcd operations on the array.\\n\\nFor the array [2, 6, 3, 4]:\\n\\n1. We can select index 2 (i.e., the number 3) and take the gcd with the number at index 3 (i.e., the number 4), and replace 3 with gcd(3, 4) = 1. Array becomes [2, 6, 1, 4].\\n2. We can then select index 1 (i.e., the number 6) and take the gcd with the number at index 2 (i.e., the number 1), and replace 6 with gcd(6, 1) = 1. Array becomes [2, 1, 1, 4].\\n3. Then, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [1, 1, 1, 4].\\n4. Finally, select index 2 (i.e., the number 1) and take the gcd with the number at index 3 (i.e., the number 4), and replace 4 with gcd(1, 4) = 1. Array becomes [1, 1, 1, 1].\\n\\nTotal operations = 4.\\n\\nFor the array [4, 2, 6, 3]:\\n\\n1. We can select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 6), and replace 2 with gcd(2, 6) = 2. Array becomes [4, 2, 6, 3].\\n2. Repeat step 1. Array still is [4, 2, 6, 3].\\n3. Repeat step 1 again. Array still is [4, 2, 6, 3].\\n4. Finally, select index 3 (i.e., the number 3) and take the gcd with the number at index 2 (i.e., the number 6), and replace 3 with gcd(3, 6) = 3. Array becomes [4, 2, 6, 1].\\n5. Now, select index 0 (i.e., the number 4) and take the gcd with the number at index 1 (i.e., the number 2), and replace 4 with gcd(4, 2) = 2. Array becomes [2, 2, 6, 1].\\n6. Next, select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 6), and replace 2 with gcd(2, 6) = 2. Array still is [2, 2, 6, 1].\\n7. Repeat step 6. Array still is [2, 2, 6, 1].\\n8. Repeat step 6 again. Array still is [2, 2, 6, 1].\\n9. Repeat step 6 once more. Array still is [2, 2, 6, 1].\\n10. Finally, select index 2 (i.e., the number 6) and take the gcd with the number at index 3 (i.e., the number 1), and replace 6 with gcd(6, 1) = 1. Array becomes [2, \\n\\n2, 1, 1].\\n11. Now, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 2), and replace 2 with gcd(2, 2) = 2. Array still is [2, 2, 1, 1].\\n12. Repeat step 11. Array still is [2, 2, 1, 1].\\n13. Repeat step 11 again. Array still is [2, 2, 1, 1].\\n14. Finally, select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [2, 1, 1, 1].\\n15. Now, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [1, 1, 1, 1].\\n\\nTotal operations = 15.\\n\\nThis demonstrates how the order of the array can affect the total number of operations required to achieve all elements as 1. The most optimized way to get all elements to 1 can depend on the order of elements in the array."
                    },
                    {
                        "username": "ZX007java",
                        "content": "[@s_m99](/s_m99) THANK YOU !!! CONSECUTIVE !!!"
                    },
                    {
                        "username": "s_m99",
                        "content": "You can only calculate gcd\\'s of 2 **consecutive** numbers and replace either of them. So in set [4,2,6,3] to make 3 into 1 we require two operations instead of one in [2,6,3,4] "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Damn, that was a great problem but... Medium, really? Am I just getting dumber? \nTook me quite lot of time and tryhard to see the solution.\nAnd that's gotta be the lowest acceptance rate I've seen for a medium problem\n\nAlso, python has a built-in gcd function apparently. Lesson learned; next time, no need to face my anxieties trying to remember my number theory classes to implement the Euclidean algo myself"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "Anyone explain or hint"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "light hint: how many steps would it take to get your first one in the array? And once you have a one, how many more steps do you need to turn everything into a one?"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "I am not able to understand the question\\nit says \\nselect index i and change num[i] or num[i+1] with their GCD and people have used n^2 loop to check every pair"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement asks for the minimum number of operations required to make all elements of an array equal to 1, by replacing either nums[i] or nums[i+1] with their gcd (greatest common divisor).\\n\\nThe problem solution is implemented with an O(n^2) approach, and this is why:\\n\\n1. You iterate over each element in the array (first loop).\\n2. For each element, you check for a contiguous segment in the array where the gcd of the numbers in the segment equals 1 (second loop). If such a segment is found, you store the length of that segment minus 1 (because one element is already 1 and doesn\\'t need any operation).\\n3. The result of the algorithm is the minimum length of these segments (if any) plus the number of elements outside these segments (because each of these will need one operation to become 1, by taking the gcd with 1).\\n\\nThe algorithm needs to check all pairs of elements because the array isn\\'t necessarily sorted, and any pair (i, j) with i < j can potentially form a contiguous segment where the gcd of the numbers is 1. So, an element nums[i] might be replaced by the gcd of nums[i] and nums[j] for some j > i.\\n"
                    },
                    {
                        "username": "User___",
                        "content": "[@cartesPerforees](/cartesPerforees) Is that $$O(n)$$?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I think you understand the question, it's just the solutions that you don't understand.\nWe check every pair to find the closest elements that could lead to a gcd of 1. Then we propagate the gcd neighbor-by-neighbor"
                    }
                ]
            },
            {
                "id": 1878342,
                "content": [
                    {
                        "username": "rideau",
                        "content": "Does anybody know how solve this in O(1) time? Is this even possible?"
                    },
                    {
                        "username": "brinuke",
                        "content": "Pay no attention to that follow-up. The person who wrote it was drunk."
                    },
                    {
                        "username": "User___",
                        "content": "Did you manage to solve it in $$O(n)$$? Just wondering, since you\\'re asking about $$O(1)$$ (which I feel isn\\'t possible)"
                    },
                    {
                        "username": "SergeyTT",
                        "content": "I think it's quite easy to prove that it impossible to solve this problem in O(1) time complexity.\nImaging you have an array of length N, for which the asnwer is \"-1\" - that is, you cannot make all elements equal to 1 using any number of operations. Now, insert number \"1\" at a random index of the array, and now you can make all other numbers equal to 1. In order to find this \"1\" you need O(N) time complexity."
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, your reasoning is absolutely correct. As per the problem, you need to inspect each element of the array to determine if the number 1 is present or if a pair of numbers exists such that their greatest common divisor (gcd) is 1. This requires at least linear time, O(N), where N is the length of the array.\\n\\nAs you\\'ve aptly illustrated, the presence of a single 1 in the array changes the entire outcome of the problem. Without examining each element, we cannot determine the presence or absence of such a crucial value. This necessitates iterating through the array at least once, thereby confirming that the problem cannot be solved in constant time, O(1)."
                    },
                    {
                        "username": "SlickGeek",
                        "content": "\"...but could you find an O(1) constant time complexity solution?\" Is it actually possible to solve this problem in constant time? I don\\'t know if there\\'s something I am not seeing or understanding, but I don\\'t think that is possible.\\nThe solution I came up with runs in N^2 and beats 71%."
                    },
                    {
                        "username": "bparanj",
                        "content": "[@rideau](/rideau) see [@Sergey TT](/SergeyTT)\\'s respose"
                    },
                    {
                        "username": "rideau",
                        "content": "Any updates? Im also interested "
                    },
                    {
                        "username": "sanjitj7",
                        "content": "EDIT: I have spotted my n00b mistake\n\nI think this test case is incorrect!\n\n>Input: nums = [2,10,6,14]\n>Output: -1\n>Explanation: It can be shown that it is impossible to make all the elements equal to 1\n\n[2,10,6,14]\n[2,10,3,14]  (i = 2)\n[2,10,3,1]   (i = 2)\n[2,10,1,1]\n[2,1,1,1]\n[1,1,1,1]\n\nThis caused a lot of confusion to me."
                    },
                    {
                        "username": "sanjitj7",
                        "content": "oh scheisse, I was taking num/GCD there \\uD83D\\uDE05 "
                    },
                    {
                        "username": "srk696772",
                        "content": "Bro GCD(6,14) == 2 ,  \nnot 3"
                    },
                    {
                        "username": "bekbossyn_kassymkhan",
                        "content": "gcd(6 & 14) = 2 , gcd(10,6)=2 also \n:)"
                    },
                    {
                        "username": "gaurav1903",
                        "content": "What\\'s the O(N) solution??"
                    },
                    {
                        "username": "bparanj",
                        "content": "The O(N) solution leverages the fact that if we can find two numbers in the array whose greatest common divisor (gcd) is 1, then the minimum number of operations required is the size of the array minus 1.\\n\\nTo achieve this in linear time, we can use the Sieve of Eratosthenes, a well-known algorithm for finding all prime numbers up to a given limit. This algorithm can be used to find the smallest prime factor for each number in the array, which is a prerequisite for finding two numbers with gcd 1.\\n\\nHere are the steps of the algorithm:\\n\\n1. Compute the smallest prime factor for each number up to max(nums) using the Sieve of Eratosthenes.\\n2. For each number in nums, if its smallest prime factor divides another number in nums, we can assume that the gcd of these two numbers is 1.\\n3. If we find such a pair, the minimum number of operations required is the size of the array minus 1.\\n4. If no such pair exists, we cannot make all elements equal to 1, so we return -1.\\n\\nNote: As the Sieve of Eratosthenes requires O(N log log N) time complexity, this solution is not strictly linear. However, it is significantly more efficient than an O(N^2) solution when dealing with large inputs.\\n\\nThis solution assumes that the input numbers are not too large (e.g., within the range of an integer). If the numbers can be very large, we need a different approach because the Sieve of Eratosthenes may not be feasible. For example, we could use a probabilistic algorithm to find a pair of numbers with gcd 1, but this would not guarantee a correct answer in all cases.\\n\\nAlso, it\\'s important to note that this approach doesn\\'t give the exact number of operations if no \"1\" is found in the array; it only checks for the possibility of making all elements equal to 1. Calculating the exact number of operations in such a case can be a more complex problem and is likely to require more than linear time."
                    },
                    {
                        "username": "ZX007java",
                        "content": "Good day ! Can anyone give me answer : why set [2, 6, 3, 4] have answer is equal 4, BUT SET [4, 2, 6, 3] have answer is equal 5 ???"
                    },
                    {
                        "username": "bparanj",
                        "content": "This discrepancy arises from the order in which we are allowed to perform the gcd operations on the array.\\n\\nFor the array [2, 6, 3, 4]:\\n\\n1. We can select index 2 (i.e., the number 3) and take the gcd with the number at index 3 (i.e., the number 4), and replace 3 with gcd(3, 4) = 1. Array becomes [2, 6, 1, 4].\\n2. We can then select index 1 (i.e., the number 6) and take the gcd with the number at index 2 (i.e., the number 1), and replace 6 with gcd(6, 1) = 1. Array becomes [2, 1, 1, 4].\\n3. Then, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [1, 1, 1, 4].\\n4. Finally, select index 2 (i.e., the number 1) and take the gcd with the number at index 3 (i.e., the number 4), and replace 4 with gcd(1, 4) = 1. Array becomes [1, 1, 1, 1].\\n\\nTotal operations = 4.\\n\\nFor the array [4, 2, 6, 3]:\\n\\n1. We can select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 6), and replace 2 with gcd(2, 6) = 2. Array becomes [4, 2, 6, 3].\\n2. Repeat step 1. Array still is [4, 2, 6, 3].\\n3. Repeat step 1 again. Array still is [4, 2, 6, 3].\\n4. Finally, select index 3 (i.e., the number 3) and take the gcd with the number at index 2 (i.e., the number 6), and replace 3 with gcd(3, 6) = 3. Array becomes [4, 2, 6, 1].\\n5. Now, select index 0 (i.e., the number 4) and take the gcd with the number at index 1 (i.e., the number 2), and replace 4 with gcd(4, 2) = 2. Array becomes [2, 2, 6, 1].\\n6. Next, select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 6), and replace 2 with gcd(2, 6) = 2. Array still is [2, 2, 6, 1].\\n7. Repeat step 6. Array still is [2, 2, 6, 1].\\n8. Repeat step 6 again. Array still is [2, 2, 6, 1].\\n9. Repeat step 6 once more. Array still is [2, 2, 6, 1].\\n10. Finally, select index 2 (i.e., the number 6) and take the gcd with the number at index 3 (i.e., the number 1), and replace 6 with gcd(6, 1) = 1. Array becomes [2, \\n\\n2, 1, 1].\\n11. Now, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 2), and replace 2 with gcd(2, 2) = 2. Array still is [2, 2, 1, 1].\\n12. Repeat step 11. Array still is [2, 2, 1, 1].\\n13. Repeat step 11 again. Array still is [2, 2, 1, 1].\\n14. Finally, select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [2, 1, 1, 1].\\n15. Now, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [1, 1, 1, 1].\\n\\nTotal operations = 15.\\n\\nThis demonstrates how the order of the array can affect the total number of operations required to achieve all elements as 1. The most optimized way to get all elements to 1 can depend on the order of elements in the array."
                    },
                    {
                        "username": "ZX007java",
                        "content": "[@s_m99](/s_m99) THANK YOU !!! CONSECUTIVE !!!"
                    },
                    {
                        "username": "s_m99",
                        "content": "You can only calculate gcd\\'s of 2 **consecutive** numbers and replace either of them. So in set [4,2,6,3] to make 3 into 1 we require two operations instead of one in [2,6,3,4] "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Damn, that was a great problem but... Medium, really? Am I just getting dumber? \nTook me quite lot of time and tryhard to see the solution.\nAnd that's gotta be the lowest acceptance rate I've seen for a medium problem\n\nAlso, python has a built-in gcd function apparently. Lesson learned; next time, no need to face my anxieties trying to remember my number theory classes to implement the Euclidean algo myself"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "Anyone explain or hint"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "light hint: how many steps would it take to get your first one in the array? And once you have a one, how many more steps do you need to turn everything into a one?"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "I am not able to understand the question\\nit says \\nselect index i and change num[i] or num[i+1] with their GCD and people have used n^2 loop to check every pair"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement asks for the minimum number of operations required to make all elements of an array equal to 1, by replacing either nums[i] or nums[i+1] with their gcd (greatest common divisor).\\n\\nThe problem solution is implemented with an O(n^2) approach, and this is why:\\n\\n1. You iterate over each element in the array (first loop).\\n2. For each element, you check for a contiguous segment in the array where the gcd of the numbers in the segment equals 1 (second loop). If such a segment is found, you store the length of that segment minus 1 (because one element is already 1 and doesn\\'t need any operation).\\n3. The result of the algorithm is the minimum length of these segments (if any) plus the number of elements outside these segments (because each of these will need one operation to become 1, by taking the gcd with 1).\\n\\nThe algorithm needs to check all pairs of elements because the array isn\\'t necessarily sorted, and any pair (i, j) with i < j can potentially form a contiguous segment where the gcd of the numbers is 1. So, an element nums[i] might be replaced by the gcd of nums[i] and nums[j] for some j > i.\\n"
                    },
                    {
                        "username": "User___",
                        "content": "[@cartesPerforees](/cartesPerforees) Is that $$O(n)$$?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I think you understand the question, it's just the solutions that you don't understand.\nWe check every pair to find the closest elements that could lead to a gcd of 1. Then we propagate the gcd neighbor-by-neighbor"
                    }
                ]
            },
            {
                "id": 1873206,
                "content": [
                    {
                        "username": "rideau",
                        "content": "Does anybody know how solve this in O(1) time? Is this even possible?"
                    },
                    {
                        "username": "brinuke",
                        "content": "Pay no attention to that follow-up. The person who wrote it was drunk."
                    },
                    {
                        "username": "User___",
                        "content": "Did you manage to solve it in $$O(n)$$? Just wondering, since you\\'re asking about $$O(1)$$ (which I feel isn\\'t possible)"
                    },
                    {
                        "username": "SergeyTT",
                        "content": "I think it's quite easy to prove that it impossible to solve this problem in O(1) time complexity.\nImaging you have an array of length N, for which the asnwer is \"-1\" - that is, you cannot make all elements equal to 1 using any number of operations. Now, insert number \"1\" at a random index of the array, and now you can make all other numbers equal to 1. In order to find this \"1\" you need O(N) time complexity."
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, your reasoning is absolutely correct. As per the problem, you need to inspect each element of the array to determine if the number 1 is present or if a pair of numbers exists such that their greatest common divisor (gcd) is 1. This requires at least linear time, O(N), where N is the length of the array.\\n\\nAs you\\'ve aptly illustrated, the presence of a single 1 in the array changes the entire outcome of the problem. Without examining each element, we cannot determine the presence or absence of such a crucial value. This necessitates iterating through the array at least once, thereby confirming that the problem cannot be solved in constant time, O(1)."
                    },
                    {
                        "username": "SlickGeek",
                        "content": "\"...but could you find an O(1) constant time complexity solution?\" Is it actually possible to solve this problem in constant time? I don\\'t know if there\\'s something I am not seeing or understanding, but I don\\'t think that is possible.\\nThe solution I came up with runs in N^2 and beats 71%."
                    },
                    {
                        "username": "bparanj",
                        "content": "[@rideau](/rideau) see [@Sergey TT](/SergeyTT)\\'s respose"
                    },
                    {
                        "username": "rideau",
                        "content": "Any updates? Im also interested "
                    },
                    {
                        "username": "sanjitj7",
                        "content": "EDIT: I have spotted my n00b mistake\n\nI think this test case is incorrect!\n\n>Input: nums = [2,10,6,14]\n>Output: -1\n>Explanation: It can be shown that it is impossible to make all the elements equal to 1\n\n[2,10,6,14]\n[2,10,3,14]  (i = 2)\n[2,10,3,1]   (i = 2)\n[2,10,1,1]\n[2,1,1,1]\n[1,1,1,1]\n\nThis caused a lot of confusion to me."
                    },
                    {
                        "username": "sanjitj7",
                        "content": "oh scheisse, I was taking num/GCD there \\uD83D\\uDE05 "
                    },
                    {
                        "username": "srk696772",
                        "content": "Bro GCD(6,14) == 2 ,  \nnot 3"
                    },
                    {
                        "username": "bekbossyn_kassymkhan",
                        "content": "gcd(6 & 14) = 2 , gcd(10,6)=2 also \n:)"
                    },
                    {
                        "username": "gaurav1903",
                        "content": "What\\'s the O(N) solution??"
                    },
                    {
                        "username": "bparanj",
                        "content": "The O(N) solution leverages the fact that if we can find two numbers in the array whose greatest common divisor (gcd) is 1, then the minimum number of operations required is the size of the array minus 1.\\n\\nTo achieve this in linear time, we can use the Sieve of Eratosthenes, a well-known algorithm for finding all prime numbers up to a given limit. This algorithm can be used to find the smallest prime factor for each number in the array, which is a prerequisite for finding two numbers with gcd 1.\\n\\nHere are the steps of the algorithm:\\n\\n1. Compute the smallest prime factor for each number up to max(nums) using the Sieve of Eratosthenes.\\n2. For each number in nums, if its smallest prime factor divides another number in nums, we can assume that the gcd of these two numbers is 1.\\n3. If we find such a pair, the minimum number of operations required is the size of the array minus 1.\\n4. If no such pair exists, we cannot make all elements equal to 1, so we return -1.\\n\\nNote: As the Sieve of Eratosthenes requires O(N log log N) time complexity, this solution is not strictly linear. However, it is significantly more efficient than an O(N^2) solution when dealing with large inputs.\\n\\nThis solution assumes that the input numbers are not too large (e.g., within the range of an integer). If the numbers can be very large, we need a different approach because the Sieve of Eratosthenes may not be feasible. For example, we could use a probabilistic algorithm to find a pair of numbers with gcd 1, but this would not guarantee a correct answer in all cases.\\n\\nAlso, it\\'s important to note that this approach doesn\\'t give the exact number of operations if no \"1\" is found in the array; it only checks for the possibility of making all elements equal to 1. Calculating the exact number of operations in such a case can be a more complex problem and is likely to require more than linear time."
                    },
                    {
                        "username": "ZX007java",
                        "content": "Good day ! Can anyone give me answer : why set [2, 6, 3, 4] have answer is equal 4, BUT SET [4, 2, 6, 3] have answer is equal 5 ???"
                    },
                    {
                        "username": "bparanj",
                        "content": "This discrepancy arises from the order in which we are allowed to perform the gcd operations on the array.\\n\\nFor the array [2, 6, 3, 4]:\\n\\n1. We can select index 2 (i.e., the number 3) and take the gcd with the number at index 3 (i.e., the number 4), and replace 3 with gcd(3, 4) = 1. Array becomes [2, 6, 1, 4].\\n2. We can then select index 1 (i.e., the number 6) and take the gcd with the number at index 2 (i.e., the number 1), and replace 6 with gcd(6, 1) = 1. Array becomes [2, 1, 1, 4].\\n3. Then, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [1, 1, 1, 4].\\n4. Finally, select index 2 (i.e., the number 1) and take the gcd with the number at index 3 (i.e., the number 4), and replace 4 with gcd(1, 4) = 1. Array becomes [1, 1, 1, 1].\\n\\nTotal operations = 4.\\n\\nFor the array [4, 2, 6, 3]:\\n\\n1. We can select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 6), and replace 2 with gcd(2, 6) = 2. Array becomes [4, 2, 6, 3].\\n2. Repeat step 1. Array still is [4, 2, 6, 3].\\n3. Repeat step 1 again. Array still is [4, 2, 6, 3].\\n4. Finally, select index 3 (i.e., the number 3) and take the gcd with the number at index 2 (i.e., the number 6), and replace 3 with gcd(3, 6) = 3. Array becomes [4, 2, 6, 1].\\n5. Now, select index 0 (i.e., the number 4) and take the gcd with the number at index 1 (i.e., the number 2), and replace 4 with gcd(4, 2) = 2. Array becomes [2, 2, 6, 1].\\n6. Next, select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 6), and replace 2 with gcd(2, 6) = 2. Array still is [2, 2, 6, 1].\\n7. Repeat step 6. Array still is [2, 2, 6, 1].\\n8. Repeat step 6 again. Array still is [2, 2, 6, 1].\\n9. Repeat step 6 once more. Array still is [2, 2, 6, 1].\\n10. Finally, select index 2 (i.e., the number 6) and take the gcd with the number at index 3 (i.e., the number 1), and replace 6 with gcd(6, 1) = 1. Array becomes [2, \\n\\n2, 1, 1].\\n11. Now, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 2), and replace 2 with gcd(2, 2) = 2. Array still is [2, 2, 1, 1].\\n12. Repeat step 11. Array still is [2, 2, 1, 1].\\n13. Repeat step 11 again. Array still is [2, 2, 1, 1].\\n14. Finally, select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [2, 1, 1, 1].\\n15. Now, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [1, 1, 1, 1].\\n\\nTotal operations = 15.\\n\\nThis demonstrates how the order of the array can affect the total number of operations required to achieve all elements as 1. The most optimized way to get all elements to 1 can depend on the order of elements in the array."
                    },
                    {
                        "username": "ZX007java",
                        "content": "[@s_m99](/s_m99) THANK YOU !!! CONSECUTIVE !!!"
                    },
                    {
                        "username": "s_m99",
                        "content": "You can only calculate gcd\\'s of 2 **consecutive** numbers and replace either of them. So in set [4,2,6,3] to make 3 into 1 we require two operations instead of one in [2,6,3,4] "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Damn, that was a great problem but... Medium, really? Am I just getting dumber? \nTook me quite lot of time and tryhard to see the solution.\nAnd that's gotta be the lowest acceptance rate I've seen for a medium problem\n\nAlso, python has a built-in gcd function apparently. Lesson learned; next time, no need to face my anxieties trying to remember my number theory classes to implement the Euclidean algo myself"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "Anyone explain or hint"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "light hint: how many steps would it take to get your first one in the array? And once you have a one, how many more steps do you need to turn everything into a one?"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "I am not able to understand the question\\nit says \\nselect index i and change num[i] or num[i+1] with their GCD and people have used n^2 loop to check every pair"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement asks for the minimum number of operations required to make all elements of an array equal to 1, by replacing either nums[i] or nums[i+1] with their gcd (greatest common divisor).\\n\\nThe problem solution is implemented with an O(n^2) approach, and this is why:\\n\\n1. You iterate over each element in the array (first loop).\\n2. For each element, you check for a contiguous segment in the array where the gcd of the numbers in the segment equals 1 (second loop). If such a segment is found, you store the length of that segment minus 1 (because one element is already 1 and doesn\\'t need any operation).\\n3. The result of the algorithm is the minimum length of these segments (if any) plus the number of elements outside these segments (because each of these will need one operation to become 1, by taking the gcd with 1).\\n\\nThe algorithm needs to check all pairs of elements because the array isn\\'t necessarily sorted, and any pair (i, j) with i < j can potentially form a contiguous segment where the gcd of the numbers is 1. So, an element nums[i] might be replaced by the gcd of nums[i] and nums[j] for some j > i.\\n"
                    },
                    {
                        "username": "User___",
                        "content": "[@cartesPerforees](/cartesPerforees) Is that $$O(n)$$?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I think you understand the question, it's just the solutions that you don't understand.\nWe check every pair to find the closest elements that could lead to a gcd of 1. Then we propagate the gcd neighbor-by-neighbor"
                    }
                ]
            },
            {
                "id": 1871447,
                "content": [
                    {
                        "username": "rideau",
                        "content": "Does anybody know how solve this in O(1) time? Is this even possible?"
                    },
                    {
                        "username": "brinuke",
                        "content": "Pay no attention to that follow-up. The person who wrote it was drunk."
                    },
                    {
                        "username": "User___",
                        "content": "Did you manage to solve it in $$O(n)$$? Just wondering, since you\\'re asking about $$O(1)$$ (which I feel isn\\'t possible)"
                    },
                    {
                        "username": "SergeyTT",
                        "content": "I think it's quite easy to prove that it impossible to solve this problem in O(1) time complexity.\nImaging you have an array of length N, for which the asnwer is \"-1\" - that is, you cannot make all elements equal to 1 using any number of operations. Now, insert number \"1\" at a random index of the array, and now you can make all other numbers equal to 1. In order to find this \"1\" you need O(N) time complexity."
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, your reasoning is absolutely correct. As per the problem, you need to inspect each element of the array to determine if the number 1 is present or if a pair of numbers exists such that their greatest common divisor (gcd) is 1. This requires at least linear time, O(N), where N is the length of the array.\\n\\nAs you\\'ve aptly illustrated, the presence of a single 1 in the array changes the entire outcome of the problem. Without examining each element, we cannot determine the presence or absence of such a crucial value. This necessitates iterating through the array at least once, thereby confirming that the problem cannot be solved in constant time, O(1)."
                    },
                    {
                        "username": "SlickGeek",
                        "content": "\"...but could you find an O(1) constant time complexity solution?\" Is it actually possible to solve this problem in constant time? I don\\'t know if there\\'s something I am not seeing or understanding, but I don\\'t think that is possible.\\nThe solution I came up with runs in N^2 and beats 71%."
                    },
                    {
                        "username": "bparanj",
                        "content": "[@rideau](/rideau) see [@Sergey TT](/SergeyTT)\\'s respose"
                    },
                    {
                        "username": "rideau",
                        "content": "Any updates? Im also interested "
                    },
                    {
                        "username": "sanjitj7",
                        "content": "EDIT: I have spotted my n00b mistake\n\nI think this test case is incorrect!\n\n>Input: nums = [2,10,6,14]\n>Output: -1\n>Explanation: It can be shown that it is impossible to make all the elements equal to 1\n\n[2,10,6,14]\n[2,10,3,14]  (i = 2)\n[2,10,3,1]   (i = 2)\n[2,10,1,1]\n[2,1,1,1]\n[1,1,1,1]\n\nThis caused a lot of confusion to me."
                    },
                    {
                        "username": "sanjitj7",
                        "content": "oh scheisse, I was taking num/GCD there \\uD83D\\uDE05 "
                    },
                    {
                        "username": "srk696772",
                        "content": "Bro GCD(6,14) == 2 ,  \nnot 3"
                    },
                    {
                        "username": "bekbossyn_kassymkhan",
                        "content": "gcd(6 & 14) = 2 , gcd(10,6)=2 also \n:)"
                    },
                    {
                        "username": "gaurav1903",
                        "content": "What\\'s the O(N) solution??"
                    },
                    {
                        "username": "bparanj",
                        "content": "The O(N) solution leverages the fact that if we can find two numbers in the array whose greatest common divisor (gcd) is 1, then the minimum number of operations required is the size of the array minus 1.\\n\\nTo achieve this in linear time, we can use the Sieve of Eratosthenes, a well-known algorithm for finding all prime numbers up to a given limit. This algorithm can be used to find the smallest prime factor for each number in the array, which is a prerequisite for finding two numbers with gcd 1.\\n\\nHere are the steps of the algorithm:\\n\\n1. Compute the smallest prime factor for each number up to max(nums) using the Sieve of Eratosthenes.\\n2. For each number in nums, if its smallest prime factor divides another number in nums, we can assume that the gcd of these two numbers is 1.\\n3. If we find such a pair, the minimum number of operations required is the size of the array minus 1.\\n4. If no such pair exists, we cannot make all elements equal to 1, so we return -1.\\n\\nNote: As the Sieve of Eratosthenes requires O(N log log N) time complexity, this solution is not strictly linear. However, it is significantly more efficient than an O(N^2) solution when dealing with large inputs.\\n\\nThis solution assumes that the input numbers are not too large (e.g., within the range of an integer). If the numbers can be very large, we need a different approach because the Sieve of Eratosthenes may not be feasible. For example, we could use a probabilistic algorithm to find a pair of numbers with gcd 1, but this would not guarantee a correct answer in all cases.\\n\\nAlso, it\\'s important to note that this approach doesn\\'t give the exact number of operations if no \"1\" is found in the array; it only checks for the possibility of making all elements equal to 1. Calculating the exact number of operations in such a case can be a more complex problem and is likely to require more than linear time."
                    },
                    {
                        "username": "ZX007java",
                        "content": "Good day ! Can anyone give me answer : why set [2, 6, 3, 4] have answer is equal 4, BUT SET [4, 2, 6, 3] have answer is equal 5 ???"
                    },
                    {
                        "username": "bparanj",
                        "content": "This discrepancy arises from the order in which we are allowed to perform the gcd operations on the array.\\n\\nFor the array [2, 6, 3, 4]:\\n\\n1. We can select index 2 (i.e., the number 3) and take the gcd with the number at index 3 (i.e., the number 4), and replace 3 with gcd(3, 4) = 1. Array becomes [2, 6, 1, 4].\\n2. We can then select index 1 (i.e., the number 6) and take the gcd with the number at index 2 (i.e., the number 1), and replace 6 with gcd(6, 1) = 1. Array becomes [2, 1, 1, 4].\\n3. Then, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [1, 1, 1, 4].\\n4. Finally, select index 2 (i.e., the number 1) and take the gcd with the number at index 3 (i.e., the number 4), and replace 4 with gcd(1, 4) = 1. Array becomes [1, 1, 1, 1].\\n\\nTotal operations = 4.\\n\\nFor the array [4, 2, 6, 3]:\\n\\n1. We can select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 6), and replace 2 with gcd(2, 6) = 2. Array becomes [4, 2, 6, 3].\\n2. Repeat step 1. Array still is [4, 2, 6, 3].\\n3. Repeat step 1 again. Array still is [4, 2, 6, 3].\\n4. Finally, select index 3 (i.e., the number 3) and take the gcd with the number at index 2 (i.e., the number 6), and replace 3 with gcd(3, 6) = 3. Array becomes [4, 2, 6, 1].\\n5. Now, select index 0 (i.e., the number 4) and take the gcd with the number at index 1 (i.e., the number 2), and replace 4 with gcd(4, 2) = 2. Array becomes [2, 2, 6, 1].\\n6. Next, select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 6), and replace 2 with gcd(2, 6) = 2. Array still is [2, 2, 6, 1].\\n7. Repeat step 6. Array still is [2, 2, 6, 1].\\n8. Repeat step 6 again. Array still is [2, 2, 6, 1].\\n9. Repeat step 6 once more. Array still is [2, 2, 6, 1].\\n10. Finally, select index 2 (i.e., the number 6) and take the gcd with the number at index 3 (i.e., the number 1), and replace 6 with gcd(6, 1) = 1. Array becomes [2, \\n\\n2, 1, 1].\\n11. Now, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 2), and replace 2 with gcd(2, 2) = 2. Array still is [2, 2, 1, 1].\\n12. Repeat step 11. Array still is [2, 2, 1, 1].\\n13. Repeat step 11 again. Array still is [2, 2, 1, 1].\\n14. Finally, select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [2, 1, 1, 1].\\n15. Now, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [1, 1, 1, 1].\\n\\nTotal operations = 15.\\n\\nThis demonstrates how the order of the array can affect the total number of operations required to achieve all elements as 1. The most optimized way to get all elements to 1 can depend on the order of elements in the array."
                    },
                    {
                        "username": "ZX007java",
                        "content": "[@s_m99](/s_m99) THANK YOU !!! CONSECUTIVE !!!"
                    },
                    {
                        "username": "s_m99",
                        "content": "You can only calculate gcd\\'s of 2 **consecutive** numbers and replace either of them. So in set [4,2,6,3] to make 3 into 1 we require two operations instead of one in [2,6,3,4] "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Damn, that was a great problem but... Medium, really? Am I just getting dumber? \nTook me quite lot of time and tryhard to see the solution.\nAnd that's gotta be the lowest acceptance rate I've seen for a medium problem\n\nAlso, python has a built-in gcd function apparently. Lesson learned; next time, no need to face my anxieties trying to remember my number theory classes to implement the Euclidean algo myself"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "Anyone explain or hint"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "light hint: how many steps would it take to get your first one in the array? And once you have a one, how many more steps do you need to turn everything into a one?"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "I am not able to understand the question\\nit says \\nselect index i and change num[i] or num[i+1] with their GCD and people have used n^2 loop to check every pair"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement asks for the minimum number of operations required to make all elements of an array equal to 1, by replacing either nums[i] or nums[i+1] with their gcd (greatest common divisor).\\n\\nThe problem solution is implemented with an O(n^2) approach, and this is why:\\n\\n1. You iterate over each element in the array (first loop).\\n2. For each element, you check for a contiguous segment in the array where the gcd of the numbers in the segment equals 1 (second loop). If such a segment is found, you store the length of that segment minus 1 (because one element is already 1 and doesn\\'t need any operation).\\n3. The result of the algorithm is the minimum length of these segments (if any) plus the number of elements outside these segments (because each of these will need one operation to become 1, by taking the gcd with 1).\\n\\nThe algorithm needs to check all pairs of elements because the array isn\\'t necessarily sorted, and any pair (i, j) with i < j can potentially form a contiguous segment where the gcd of the numbers is 1. So, an element nums[i] might be replaced by the gcd of nums[i] and nums[j] for some j > i.\\n"
                    },
                    {
                        "username": "User___",
                        "content": "[@cartesPerforees](/cartesPerforees) Is that $$O(n)$$?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I think you understand the question, it's just the solutions that you don't understand.\nWe check every pair to find the closest elements that could lead to a gcd of 1. Then we propagate the gcd neighbor-by-neighbor"
                    }
                ]
            },
            {
                "id": 1898536,
                "content": [
                    {
                        "username": "rideau",
                        "content": "Does anybody know how solve this in O(1) time? Is this even possible?"
                    },
                    {
                        "username": "brinuke",
                        "content": "Pay no attention to that follow-up. The person who wrote it was drunk."
                    },
                    {
                        "username": "User___",
                        "content": "Did you manage to solve it in $$O(n)$$? Just wondering, since you\\'re asking about $$O(1)$$ (which I feel isn\\'t possible)"
                    },
                    {
                        "username": "SergeyTT",
                        "content": "I think it's quite easy to prove that it impossible to solve this problem in O(1) time complexity.\nImaging you have an array of length N, for which the asnwer is \"-1\" - that is, you cannot make all elements equal to 1 using any number of operations. Now, insert number \"1\" at a random index of the array, and now you can make all other numbers equal to 1. In order to find this \"1\" you need O(N) time complexity."
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, your reasoning is absolutely correct. As per the problem, you need to inspect each element of the array to determine if the number 1 is present or if a pair of numbers exists such that their greatest common divisor (gcd) is 1. This requires at least linear time, O(N), where N is the length of the array.\\n\\nAs you\\'ve aptly illustrated, the presence of a single 1 in the array changes the entire outcome of the problem. Without examining each element, we cannot determine the presence or absence of such a crucial value. This necessitates iterating through the array at least once, thereby confirming that the problem cannot be solved in constant time, O(1)."
                    },
                    {
                        "username": "SlickGeek",
                        "content": "\"...but could you find an O(1) constant time complexity solution?\" Is it actually possible to solve this problem in constant time? I don\\'t know if there\\'s something I am not seeing or understanding, but I don\\'t think that is possible.\\nThe solution I came up with runs in N^2 and beats 71%."
                    },
                    {
                        "username": "bparanj",
                        "content": "[@rideau](/rideau) see [@Sergey TT](/SergeyTT)\\'s respose"
                    },
                    {
                        "username": "rideau",
                        "content": "Any updates? Im also interested "
                    },
                    {
                        "username": "sanjitj7",
                        "content": "EDIT: I have spotted my n00b mistake\n\nI think this test case is incorrect!\n\n>Input: nums = [2,10,6,14]\n>Output: -1\n>Explanation: It can be shown that it is impossible to make all the elements equal to 1\n\n[2,10,6,14]\n[2,10,3,14]  (i = 2)\n[2,10,3,1]   (i = 2)\n[2,10,1,1]\n[2,1,1,1]\n[1,1,1,1]\n\nThis caused a lot of confusion to me."
                    },
                    {
                        "username": "sanjitj7",
                        "content": "oh scheisse, I was taking num/GCD there \\uD83D\\uDE05 "
                    },
                    {
                        "username": "srk696772",
                        "content": "Bro GCD(6,14) == 2 ,  \nnot 3"
                    },
                    {
                        "username": "bekbossyn_kassymkhan",
                        "content": "gcd(6 & 14) = 2 , gcd(10,6)=2 also \n:)"
                    },
                    {
                        "username": "gaurav1903",
                        "content": "What\\'s the O(N) solution??"
                    },
                    {
                        "username": "bparanj",
                        "content": "The O(N) solution leverages the fact that if we can find two numbers in the array whose greatest common divisor (gcd) is 1, then the minimum number of operations required is the size of the array minus 1.\\n\\nTo achieve this in linear time, we can use the Sieve of Eratosthenes, a well-known algorithm for finding all prime numbers up to a given limit. This algorithm can be used to find the smallest prime factor for each number in the array, which is a prerequisite for finding two numbers with gcd 1.\\n\\nHere are the steps of the algorithm:\\n\\n1. Compute the smallest prime factor for each number up to max(nums) using the Sieve of Eratosthenes.\\n2. For each number in nums, if its smallest prime factor divides another number in nums, we can assume that the gcd of these two numbers is 1.\\n3. If we find such a pair, the minimum number of operations required is the size of the array minus 1.\\n4. If no such pair exists, we cannot make all elements equal to 1, so we return -1.\\n\\nNote: As the Sieve of Eratosthenes requires O(N log log N) time complexity, this solution is not strictly linear. However, it is significantly more efficient than an O(N^2) solution when dealing with large inputs.\\n\\nThis solution assumes that the input numbers are not too large (e.g., within the range of an integer). If the numbers can be very large, we need a different approach because the Sieve of Eratosthenes may not be feasible. For example, we could use a probabilistic algorithm to find a pair of numbers with gcd 1, but this would not guarantee a correct answer in all cases.\\n\\nAlso, it\\'s important to note that this approach doesn\\'t give the exact number of operations if no \"1\" is found in the array; it only checks for the possibility of making all elements equal to 1. Calculating the exact number of operations in such a case can be a more complex problem and is likely to require more than linear time."
                    },
                    {
                        "username": "ZX007java",
                        "content": "Good day ! Can anyone give me answer : why set [2, 6, 3, 4] have answer is equal 4, BUT SET [4, 2, 6, 3] have answer is equal 5 ???"
                    },
                    {
                        "username": "bparanj",
                        "content": "This discrepancy arises from the order in which we are allowed to perform the gcd operations on the array.\\n\\nFor the array [2, 6, 3, 4]:\\n\\n1. We can select index 2 (i.e., the number 3) and take the gcd with the number at index 3 (i.e., the number 4), and replace 3 with gcd(3, 4) = 1. Array becomes [2, 6, 1, 4].\\n2. We can then select index 1 (i.e., the number 6) and take the gcd with the number at index 2 (i.e., the number 1), and replace 6 with gcd(6, 1) = 1. Array becomes [2, 1, 1, 4].\\n3. Then, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [1, 1, 1, 4].\\n4. Finally, select index 2 (i.e., the number 1) and take the gcd with the number at index 3 (i.e., the number 4), and replace 4 with gcd(1, 4) = 1. Array becomes [1, 1, 1, 1].\\n\\nTotal operations = 4.\\n\\nFor the array [4, 2, 6, 3]:\\n\\n1. We can select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 6), and replace 2 with gcd(2, 6) = 2. Array becomes [4, 2, 6, 3].\\n2. Repeat step 1. Array still is [4, 2, 6, 3].\\n3. Repeat step 1 again. Array still is [4, 2, 6, 3].\\n4. Finally, select index 3 (i.e., the number 3) and take the gcd with the number at index 2 (i.e., the number 6), and replace 3 with gcd(3, 6) = 3. Array becomes [4, 2, 6, 1].\\n5. Now, select index 0 (i.e., the number 4) and take the gcd with the number at index 1 (i.e., the number 2), and replace 4 with gcd(4, 2) = 2. Array becomes [2, 2, 6, 1].\\n6. Next, select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 6), and replace 2 with gcd(2, 6) = 2. Array still is [2, 2, 6, 1].\\n7. Repeat step 6. Array still is [2, 2, 6, 1].\\n8. Repeat step 6 again. Array still is [2, 2, 6, 1].\\n9. Repeat step 6 once more. Array still is [2, 2, 6, 1].\\n10. Finally, select index 2 (i.e., the number 6) and take the gcd with the number at index 3 (i.e., the number 1), and replace 6 with gcd(6, 1) = 1. Array becomes [2, \\n\\n2, 1, 1].\\n11. Now, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 2), and replace 2 with gcd(2, 2) = 2. Array still is [2, 2, 1, 1].\\n12. Repeat step 11. Array still is [2, 2, 1, 1].\\n13. Repeat step 11 again. Array still is [2, 2, 1, 1].\\n14. Finally, select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [2, 1, 1, 1].\\n15. Now, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [1, 1, 1, 1].\\n\\nTotal operations = 15.\\n\\nThis demonstrates how the order of the array can affect the total number of operations required to achieve all elements as 1. The most optimized way to get all elements to 1 can depend on the order of elements in the array."
                    },
                    {
                        "username": "ZX007java",
                        "content": "[@s_m99](/s_m99) THANK YOU !!! CONSECUTIVE !!!"
                    },
                    {
                        "username": "s_m99",
                        "content": "You can only calculate gcd\\'s of 2 **consecutive** numbers and replace either of them. So in set [4,2,6,3] to make 3 into 1 we require two operations instead of one in [2,6,3,4] "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Damn, that was a great problem but... Medium, really? Am I just getting dumber? \nTook me quite lot of time and tryhard to see the solution.\nAnd that's gotta be the lowest acceptance rate I've seen for a medium problem\n\nAlso, python has a built-in gcd function apparently. Lesson learned; next time, no need to face my anxieties trying to remember my number theory classes to implement the Euclidean algo myself"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "Anyone explain or hint"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "light hint: how many steps would it take to get your first one in the array? And once you have a one, how many more steps do you need to turn everything into a one?"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "I am not able to understand the question\\nit says \\nselect index i and change num[i] or num[i+1] with their GCD and people have used n^2 loop to check every pair"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement asks for the minimum number of operations required to make all elements of an array equal to 1, by replacing either nums[i] or nums[i+1] with their gcd (greatest common divisor).\\n\\nThe problem solution is implemented with an O(n^2) approach, and this is why:\\n\\n1. You iterate over each element in the array (first loop).\\n2. For each element, you check for a contiguous segment in the array where the gcd of the numbers in the segment equals 1 (second loop). If such a segment is found, you store the length of that segment minus 1 (because one element is already 1 and doesn\\'t need any operation).\\n3. The result of the algorithm is the minimum length of these segments (if any) plus the number of elements outside these segments (because each of these will need one operation to become 1, by taking the gcd with 1).\\n\\nThe algorithm needs to check all pairs of elements because the array isn\\'t necessarily sorted, and any pair (i, j) with i < j can potentially form a contiguous segment where the gcd of the numbers is 1. So, an element nums[i] might be replaced by the gcd of nums[i] and nums[j] for some j > i.\\n"
                    },
                    {
                        "username": "User___",
                        "content": "[@cartesPerforees](/cartesPerforees) Is that $$O(n)$$?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I think you understand the question, it's just the solutions that you don't understand.\nWe check every pair to find the closest elements that could lead to a gcd of 1. Then we propagate the gcd neighbor-by-neighbor"
                    }
                ]
            },
            {
                "id": 1880916,
                "content": [
                    {
                        "username": "rideau",
                        "content": "Does anybody know how solve this in O(1) time? Is this even possible?"
                    },
                    {
                        "username": "brinuke",
                        "content": "Pay no attention to that follow-up. The person who wrote it was drunk."
                    },
                    {
                        "username": "User___",
                        "content": "Did you manage to solve it in $$O(n)$$? Just wondering, since you\\'re asking about $$O(1)$$ (which I feel isn\\'t possible)"
                    },
                    {
                        "username": "SergeyTT",
                        "content": "I think it's quite easy to prove that it impossible to solve this problem in O(1) time complexity.\nImaging you have an array of length N, for which the asnwer is \"-1\" - that is, you cannot make all elements equal to 1 using any number of operations. Now, insert number \"1\" at a random index of the array, and now you can make all other numbers equal to 1. In order to find this \"1\" you need O(N) time complexity."
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, your reasoning is absolutely correct. As per the problem, you need to inspect each element of the array to determine if the number 1 is present or if a pair of numbers exists such that their greatest common divisor (gcd) is 1. This requires at least linear time, O(N), where N is the length of the array.\\n\\nAs you\\'ve aptly illustrated, the presence of a single 1 in the array changes the entire outcome of the problem. Without examining each element, we cannot determine the presence or absence of such a crucial value. This necessitates iterating through the array at least once, thereby confirming that the problem cannot be solved in constant time, O(1)."
                    },
                    {
                        "username": "SlickGeek",
                        "content": "\"...but could you find an O(1) constant time complexity solution?\" Is it actually possible to solve this problem in constant time? I don\\'t know if there\\'s something I am not seeing or understanding, but I don\\'t think that is possible.\\nThe solution I came up with runs in N^2 and beats 71%."
                    },
                    {
                        "username": "bparanj",
                        "content": "[@rideau](/rideau) see [@Sergey TT](/SergeyTT)\\'s respose"
                    },
                    {
                        "username": "rideau",
                        "content": "Any updates? Im also interested "
                    },
                    {
                        "username": "sanjitj7",
                        "content": "EDIT: I have spotted my n00b mistake\n\nI think this test case is incorrect!\n\n>Input: nums = [2,10,6,14]\n>Output: -1\n>Explanation: It can be shown that it is impossible to make all the elements equal to 1\n\n[2,10,6,14]\n[2,10,3,14]  (i = 2)\n[2,10,3,1]   (i = 2)\n[2,10,1,1]\n[2,1,1,1]\n[1,1,1,1]\n\nThis caused a lot of confusion to me."
                    },
                    {
                        "username": "sanjitj7",
                        "content": "oh scheisse, I was taking num/GCD there \\uD83D\\uDE05 "
                    },
                    {
                        "username": "srk696772",
                        "content": "Bro GCD(6,14) == 2 ,  \nnot 3"
                    },
                    {
                        "username": "bekbossyn_kassymkhan",
                        "content": "gcd(6 & 14) = 2 , gcd(10,6)=2 also \n:)"
                    },
                    {
                        "username": "gaurav1903",
                        "content": "What\\'s the O(N) solution??"
                    },
                    {
                        "username": "bparanj",
                        "content": "The O(N) solution leverages the fact that if we can find two numbers in the array whose greatest common divisor (gcd) is 1, then the minimum number of operations required is the size of the array minus 1.\\n\\nTo achieve this in linear time, we can use the Sieve of Eratosthenes, a well-known algorithm for finding all prime numbers up to a given limit. This algorithm can be used to find the smallest prime factor for each number in the array, which is a prerequisite for finding two numbers with gcd 1.\\n\\nHere are the steps of the algorithm:\\n\\n1. Compute the smallest prime factor for each number up to max(nums) using the Sieve of Eratosthenes.\\n2. For each number in nums, if its smallest prime factor divides another number in nums, we can assume that the gcd of these two numbers is 1.\\n3. If we find such a pair, the minimum number of operations required is the size of the array minus 1.\\n4. If no such pair exists, we cannot make all elements equal to 1, so we return -1.\\n\\nNote: As the Sieve of Eratosthenes requires O(N log log N) time complexity, this solution is not strictly linear. However, it is significantly more efficient than an O(N^2) solution when dealing with large inputs.\\n\\nThis solution assumes that the input numbers are not too large (e.g., within the range of an integer). If the numbers can be very large, we need a different approach because the Sieve of Eratosthenes may not be feasible. For example, we could use a probabilistic algorithm to find a pair of numbers with gcd 1, but this would not guarantee a correct answer in all cases.\\n\\nAlso, it\\'s important to note that this approach doesn\\'t give the exact number of operations if no \"1\" is found in the array; it only checks for the possibility of making all elements equal to 1. Calculating the exact number of operations in such a case can be a more complex problem and is likely to require more than linear time."
                    },
                    {
                        "username": "ZX007java",
                        "content": "Good day ! Can anyone give me answer : why set [2, 6, 3, 4] have answer is equal 4, BUT SET [4, 2, 6, 3] have answer is equal 5 ???"
                    },
                    {
                        "username": "bparanj",
                        "content": "This discrepancy arises from the order in which we are allowed to perform the gcd operations on the array.\\n\\nFor the array [2, 6, 3, 4]:\\n\\n1. We can select index 2 (i.e., the number 3) and take the gcd with the number at index 3 (i.e., the number 4), and replace 3 with gcd(3, 4) = 1. Array becomes [2, 6, 1, 4].\\n2. We can then select index 1 (i.e., the number 6) and take the gcd with the number at index 2 (i.e., the number 1), and replace 6 with gcd(6, 1) = 1. Array becomes [2, 1, 1, 4].\\n3. Then, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [1, 1, 1, 4].\\n4. Finally, select index 2 (i.e., the number 1) and take the gcd with the number at index 3 (i.e., the number 4), and replace 4 with gcd(1, 4) = 1. Array becomes [1, 1, 1, 1].\\n\\nTotal operations = 4.\\n\\nFor the array [4, 2, 6, 3]:\\n\\n1. We can select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 6), and replace 2 with gcd(2, 6) = 2. Array becomes [4, 2, 6, 3].\\n2. Repeat step 1. Array still is [4, 2, 6, 3].\\n3. Repeat step 1 again. Array still is [4, 2, 6, 3].\\n4. Finally, select index 3 (i.e., the number 3) and take the gcd with the number at index 2 (i.e., the number 6), and replace 3 with gcd(3, 6) = 3. Array becomes [4, 2, 6, 1].\\n5. Now, select index 0 (i.e., the number 4) and take the gcd with the number at index 1 (i.e., the number 2), and replace 4 with gcd(4, 2) = 2. Array becomes [2, 2, 6, 1].\\n6. Next, select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 6), and replace 2 with gcd(2, 6) = 2. Array still is [2, 2, 6, 1].\\n7. Repeat step 6. Array still is [2, 2, 6, 1].\\n8. Repeat step 6 again. Array still is [2, 2, 6, 1].\\n9. Repeat step 6 once more. Array still is [2, 2, 6, 1].\\n10. Finally, select index 2 (i.e., the number 6) and take the gcd with the number at index 3 (i.e., the number 1), and replace 6 with gcd(6, 1) = 1. Array becomes [2, \\n\\n2, 1, 1].\\n11. Now, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 2), and replace 2 with gcd(2, 2) = 2. Array still is [2, 2, 1, 1].\\n12. Repeat step 11. Array still is [2, 2, 1, 1].\\n13. Repeat step 11 again. Array still is [2, 2, 1, 1].\\n14. Finally, select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [2, 1, 1, 1].\\n15. Now, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [1, 1, 1, 1].\\n\\nTotal operations = 15.\\n\\nThis demonstrates how the order of the array can affect the total number of operations required to achieve all elements as 1. The most optimized way to get all elements to 1 can depend on the order of elements in the array."
                    },
                    {
                        "username": "ZX007java",
                        "content": "[@s_m99](/s_m99) THANK YOU !!! CONSECUTIVE !!!"
                    },
                    {
                        "username": "s_m99",
                        "content": "You can only calculate gcd\\'s of 2 **consecutive** numbers and replace either of them. So in set [4,2,6,3] to make 3 into 1 we require two operations instead of one in [2,6,3,4] "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Damn, that was a great problem but... Medium, really? Am I just getting dumber? \nTook me quite lot of time and tryhard to see the solution.\nAnd that's gotta be the lowest acceptance rate I've seen for a medium problem\n\nAlso, python has a built-in gcd function apparently. Lesson learned; next time, no need to face my anxieties trying to remember my number theory classes to implement the Euclidean algo myself"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "Anyone explain or hint"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "light hint: how many steps would it take to get your first one in the array? And once you have a one, how many more steps do you need to turn everything into a one?"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "I am not able to understand the question\\nit says \\nselect index i and change num[i] or num[i+1] with their GCD and people have used n^2 loop to check every pair"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement asks for the minimum number of operations required to make all elements of an array equal to 1, by replacing either nums[i] or nums[i+1] with their gcd (greatest common divisor).\\n\\nThe problem solution is implemented with an O(n^2) approach, and this is why:\\n\\n1. You iterate over each element in the array (first loop).\\n2. For each element, you check for a contiguous segment in the array where the gcd of the numbers in the segment equals 1 (second loop). If such a segment is found, you store the length of that segment minus 1 (because one element is already 1 and doesn\\'t need any operation).\\n3. The result of the algorithm is the minimum length of these segments (if any) plus the number of elements outside these segments (because each of these will need one operation to become 1, by taking the gcd with 1).\\n\\nThe algorithm needs to check all pairs of elements because the array isn\\'t necessarily sorted, and any pair (i, j) with i < j can potentially form a contiguous segment where the gcd of the numbers is 1. So, an element nums[i] might be replaced by the gcd of nums[i] and nums[j] for some j > i.\\n"
                    },
                    {
                        "username": "User___",
                        "content": "[@cartesPerforees](/cartesPerforees) Is that $$O(n)$$?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I think you understand the question, it's just the solutions that you don't understand.\nWe check every pair to find the closest elements that could lead to a gcd of 1. Then we propagate the gcd neighbor-by-neighbor"
                    }
                ]
            },
            {
                "id": 1872644,
                "content": [
                    {
                        "username": "rideau",
                        "content": "Does anybody know how solve this in O(1) time? Is this even possible?"
                    },
                    {
                        "username": "brinuke",
                        "content": "Pay no attention to that follow-up. The person who wrote it was drunk."
                    },
                    {
                        "username": "User___",
                        "content": "Did you manage to solve it in $$O(n)$$? Just wondering, since you\\'re asking about $$O(1)$$ (which I feel isn\\'t possible)"
                    },
                    {
                        "username": "SergeyTT",
                        "content": "I think it's quite easy to prove that it impossible to solve this problem in O(1) time complexity.\nImaging you have an array of length N, for which the asnwer is \"-1\" - that is, you cannot make all elements equal to 1 using any number of operations. Now, insert number \"1\" at a random index of the array, and now you can make all other numbers equal to 1. In order to find this \"1\" you need O(N) time complexity."
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, your reasoning is absolutely correct. As per the problem, you need to inspect each element of the array to determine if the number 1 is present or if a pair of numbers exists such that their greatest common divisor (gcd) is 1. This requires at least linear time, O(N), where N is the length of the array.\\n\\nAs you\\'ve aptly illustrated, the presence of a single 1 in the array changes the entire outcome of the problem. Without examining each element, we cannot determine the presence or absence of such a crucial value. This necessitates iterating through the array at least once, thereby confirming that the problem cannot be solved in constant time, O(1)."
                    },
                    {
                        "username": "SlickGeek",
                        "content": "\"...but could you find an O(1) constant time complexity solution?\" Is it actually possible to solve this problem in constant time? I don\\'t know if there\\'s something I am not seeing or understanding, but I don\\'t think that is possible.\\nThe solution I came up with runs in N^2 and beats 71%."
                    },
                    {
                        "username": "bparanj",
                        "content": "[@rideau](/rideau) see [@Sergey TT](/SergeyTT)\\'s respose"
                    },
                    {
                        "username": "rideau",
                        "content": "Any updates? Im also interested "
                    },
                    {
                        "username": "sanjitj7",
                        "content": "EDIT: I have spotted my n00b mistake\n\nI think this test case is incorrect!\n\n>Input: nums = [2,10,6,14]\n>Output: -1\n>Explanation: It can be shown that it is impossible to make all the elements equal to 1\n\n[2,10,6,14]\n[2,10,3,14]  (i = 2)\n[2,10,3,1]   (i = 2)\n[2,10,1,1]\n[2,1,1,1]\n[1,1,1,1]\n\nThis caused a lot of confusion to me."
                    },
                    {
                        "username": "sanjitj7",
                        "content": "oh scheisse, I was taking num/GCD there \\uD83D\\uDE05 "
                    },
                    {
                        "username": "srk696772",
                        "content": "Bro GCD(6,14) == 2 ,  \nnot 3"
                    },
                    {
                        "username": "bekbossyn_kassymkhan",
                        "content": "gcd(6 & 14) = 2 , gcd(10,6)=2 also \n:)"
                    },
                    {
                        "username": "gaurav1903",
                        "content": "What\\'s the O(N) solution??"
                    },
                    {
                        "username": "bparanj",
                        "content": "The O(N) solution leverages the fact that if we can find two numbers in the array whose greatest common divisor (gcd) is 1, then the minimum number of operations required is the size of the array minus 1.\\n\\nTo achieve this in linear time, we can use the Sieve of Eratosthenes, a well-known algorithm for finding all prime numbers up to a given limit. This algorithm can be used to find the smallest prime factor for each number in the array, which is a prerequisite for finding two numbers with gcd 1.\\n\\nHere are the steps of the algorithm:\\n\\n1. Compute the smallest prime factor for each number up to max(nums) using the Sieve of Eratosthenes.\\n2. For each number in nums, if its smallest prime factor divides another number in nums, we can assume that the gcd of these two numbers is 1.\\n3. If we find such a pair, the minimum number of operations required is the size of the array minus 1.\\n4. If no such pair exists, we cannot make all elements equal to 1, so we return -1.\\n\\nNote: As the Sieve of Eratosthenes requires O(N log log N) time complexity, this solution is not strictly linear. However, it is significantly more efficient than an O(N^2) solution when dealing with large inputs.\\n\\nThis solution assumes that the input numbers are not too large (e.g., within the range of an integer). If the numbers can be very large, we need a different approach because the Sieve of Eratosthenes may not be feasible. For example, we could use a probabilistic algorithm to find a pair of numbers with gcd 1, but this would not guarantee a correct answer in all cases.\\n\\nAlso, it\\'s important to note that this approach doesn\\'t give the exact number of operations if no \"1\" is found in the array; it only checks for the possibility of making all elements equal to 1. Calculating the exact number of operations in such a case can be a more complex problem and is likely to require more than linear time."
                    },
                    {
                        "username": "ZX007java",
                        "content": "Good day ! Can anyone give me answer : why set [2, 6, 3, 4] have answer is equal 4, BUT SET [4, 2, 6, 3] have answer is equal 5 ???"
                    },
                    {
                        "username": "bparanj",
                        "content": "This discrepancy arises from the order in which we are allowed to perform the gcd operations on the array.\\n\\nFor the array [2, 6, 3, 4]:\\n\\n1. We can select index 2 (i.e., the number 3) and take the gcd with the number at index 3 (i.e., the number 4), and replace 3 with gcd(3, 4) = 1. Array becomes [2, 6, 1, 4].\\n2. We can then select index 1 (i.e., the number 6) and take the gcd with the number at index 2 (i.e., the number 1), and replace 6 with gcd(6, 1) = 1. Array becomes [2, 1, 1, 4].\\n3. Then, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [1, 1, 1, 4].\\n4. Finally, select index 2 (i.e., the number 1) and take the gcd with the number at index 3 (i.e., the number 4), and replace 4 with gcd(1, 4) = 1. Array becomes [1, 1, 1, 1].\\n\\nTotal operations = 4.\\n\\nFor the array [4, 2, 6, 3]:\\n\\n1. We can select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 6), and replace 2 with gcd(2, 6) = 2. Array becomes [4, 2, 6, 3].\\n2. Repeat step 1. Array still is [4, 2, 6, 3].\\n3. Repeat step 1 again. Array still is [4, 2, 6, 3].\\n4. Finally, select index 3 (i.e., the number 3) and take the gcd with the number at index 2 (i.e., the number 6), and replace 3 with gcd(3, 6) = 3. Array becomes [4, 2, 6, 1].\\n5. Now, select index 0 (i.e., the number 4) and take the gcd with the number at index 1 (i.e., the number 2), and replace 4 with gcd(4, 2) = 2. Array becomes [2, 2, 6, 1].\\n6. Next, select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 6), and replace 2 with gcd(2, 6) = 2. Array still is [2, 2, 6, 1].\\n7. Repeat step 6. Array still is [2, 2, 6, 1].\\n8. Repeat step 6 again. Array still is [2, 2, 6, 1].\\n9. Repeat step 6 once more. Array still is [2, 2, 6, 1].\\n10. Finally, select index 2 (i.e., the number 6) and take the gcd with the number at index 3 (i.e., the number 1), and replace 6 with gcd(6, 1) = 1. Array becomes [2, \\n\\n2, 1, 1].\\n11. Now, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 2), and replace 2 with gcd(2, 2) = 2. Array still is [2, 2, 1, 1].\\n12. Repeat step 11. Array still is [2, 2, 1, 1].\\n13. Repeat step 11 again. Array still is [2, 2, 1, 1].\\n14. Finally, select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [2, 1, 1, 1].\\n15. Now, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [1, 1, 1, 1].\\n\\nTotal operations = 15.\\n\\nThis demonstrates how the order of the array can affect the total number of operations required to achieve all elements as 1. The most optimized way to get all elements to 1 can depend on the order of elements in the array."
                    },
                    {
                        "username": "ZX007java",
                        "content": "[@s_m99](/s_m99) THANK YOU !!! CONSECUTIVE !!!"
                    },
                    {
                        "username": "s_m99",
                        "content": "You can only calculate gcd\\'s of 2 **consecutive** numbers and replace either of them. So in set [4,2,6,3] to make 3 into 1 we require two operations instead of one in [2,6,3,4] "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Damn, that was a great problem but... Medium, really? Am I just getting dumber? \nTook me quite lot of time and tryhard to see the solution.\nAnd that's gotta be the lowest acceptance rate I've seen for a medium problem\n\nAlso, python has a built-in gcd function apparently. Lesson learned; next time, no need to face my anxieties trying to remember my number theory classes to implement the Euclidean algo myself"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "Anyone explain or hint"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "light hint: how many steps would it take to get your first one in the array? And once you have a one, how many more steps do you need to turn everything into a one?"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "I am not able to understand the question\\nit says \\nselect index i and change num[i] or num[i+1] with their GCD and people have used n^2 loop to check every pair"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement asks for the minimum number of operations required to make all elements of an array equal to 1, by replacing either nums[i] or nums[i+1] with their gcd (greatest common divisor).\\n\\nThe problem solution is implemented with an O(n^2) approach, and this is why:\\n\\n1. You iterate over each element in the array (first loop).\\n2. For each element, you check for a contiguous segment in the array where the gcd of the numbers in the segment equals 1 (second loop). If such a segment is found, you store the length of that segment minus 1 (because one element is already 1 and doesn\\'t need any operation).\\n3. The result of the algorithm is the minimum length of these segments (if any) plus the number of elements outside these segments (because each of these will need one operation to become 1, by taking the gcd with 1).\\n\\nThe algorithm needs to check all pairs of elements because the array isn\\'t necessarily sorted, and any pair (i, j) with i < j can potentially form a contiguous segment where the gcd of the numbers is 1. So, an element nums[i] might be replaced by the gcd of nums[i] and nums[j] for some j > i.\\n"
                    },
                    {
                        "username": "User___",
                        "content": "[@cartesPerforees](/cartesPerforees) Is that $$O(n)$$?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I think you understand the question, it's just the solutions that you don't understand.\nWe check every pair to find the closest elements that could lead to a gcd of 1. Then we propagate the gcd neighbor-by-neighbor"
                    }
                ]
            },
            {
                "id": 1871729,
                "content": [
                    {
                        "username": "rideau",
                        "content": "Does anybody know how solve this in O(1) time? Is this even possible?"
                    },
                    {
                        "username": "brinuke",
                        "content": "Pay no attention to that follow-up. The person who wrote it was drunk."
                    },
                    {
                        "username": "User___",
                        "content": "Did you manage to solve it in $$O(n)$$? Just wondering, since you\\'re asking about $$O(1)$$ (which I feel isn\\'t possible)"
                    },
                    {
                        "username": "SergeyTT",
                        "content": "I think it's quite easy to prove that it impossible to solve this problem in O(1) time complexity.\nImaging you have an array of length N, for which the asnwer is \"-1\" - that is, you cannot make all elements equal to 1 using any number of operations. Now, insert number \"1\" at a random index of the array, and now you can make all other numbers equal to 1. In order to find this \"1\" you need O(N) time complexity."
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, your reasoning is absolutely correct. As per the problem, you need to inspect each element of the array to determine if the number 1 is present or if a pair of numbers exists such that their greatest common divisor (gcd) is 1. This requires at least linear time, O(N), where N is the length of the array.\\n\\nAs you\\'ve aptly illustrated, the presence of a single 1 in the array changes the entire outcome of the problem. Without examining each element, we cannot determine the presence or absence of such a crucial value. This necessitates iterating through the array at least once, thereby confirming that the problem cannot be solved in constant time, O(1)."
                    },
                    {
                        "username": "SlickGeek",
                        "content": "\"...but could you find an O(1) constant time complexity solution?\" Is it actually possible to solve this problem in constant time? I don\\'t know if there\\'s something I am not seeing or understanding, but I don\\'t think that is possible.\\nThe solution I came up with runs in N^2 and beats 71%."
                    },
                    {
                        "username": "bparanj",
                        "content": "[@rideau](/rideau) see [@Sergey TT](/SergeyTT)\\'s respose"
                    },
                    {
                        "username": "rideau",
                        "content": "Any updates? Im also interested "
                    },
                    {
                        "username": "sanjitj7",
                        "content": "EDIT: I have spotted my n00b mistake\n\nI think this test case is incorrect!\n\n>Input: nums = [2,10,6,14]\n>Output: -1\n>Explanation: It can be shown that it is impossible to make all the elements equal to 1\n\n[2,10,6,14]\n[2,10,3,14]  (i = 2)\n[2,10,3,1]   (i = 2)\n[2,10,1,1]\n[2,1,1,1]\n[1,1,1,1]\n\nThis caused a lot of confusion to me."
                    },
                    {
                        "username": "sanjitj7",
                        "content": "oh scheisse, I was taking num/GCD there \\uD83D\\uDE05 "
                    },
                    {
                        "username": "srk696772",
                        "content": "Bro GCD(6,14) == 2 ,  \nnot 3"
                    },
                    {
                        "username": "bekbossyn_kassymkhan",
                        "content": "gcd(6 & 14) = 2 , gcd(10,6)=2 also \n:)"
                    },
                    {
                        "username": "gaurav1903",
                        "content": "What\\'s the O(N) solution??"
                    },
                    {
                        "username": "bparanj",
                        "content": "The O(N) solution leverages the fact that if we can find two numbers in the array whose greatest common divisor (gcd) is 1, then the minimum number of operations required is the size of the array minus 1.\\n\\nTo achieve this in linear time, we can use the Sieve of Eratosthenes, a well-known algorithm for finding all prime numbers up to a given limit. This algorithm can be used to find the smallest prime factor for each number in the array, which is a prerequisite for finding two numbers with gcd 1.\\n\\nHere are the steps of the algorithm:\\n\\n1. Compute the smallest prime factor for each number up to max(nums) using the Sieve of Eratosthenes.\\n2. For each number in nums, if its smallest prime factor divides another number in nums, we can assume that the gcd of these two numbers is 1.\\n3. If we find such a pair, the minimum number of operations required is the size of the array minus 1.\\n4. If no such pair exists, we cannot make all elements equal to 1, so we return -1.\\n\\nNote: As the Sieve of Eratosthenes requires O(N log log N) time complexity, this solution is not strictly linear. However, it is significantly more efficient than an O(N^2) solution when dealing with large inputs.\\n\\nThis solution assumes that the input numbers are not too large (e.g., within the range of an integer). If the numbers can be very large, we need a different approach because the Sieve of Eratosthenes may not be feasible. For example, we could use a probabilistic algorithm to find a pair of numbers with gcd 1, but this would not guarantee a correct answer in all cases.\\n\\nAlso, it\\'s important to note that this approach doesn\\'t give the exact number of operations if no \"1\" is found in the array; it only checks for the possibility of making all elements equal to 1. Calculating the exact number of operations in such a case can be a more complex problem and is likely to require more than linear time."
                    },
                    {
                        "username": "ZX007java",
                        "content": "Good day ! Can anyone give me answer : why set [2, 6, 3, 4] have answer is equal 4, BUT SET [4, 2, 6, 3] have answer is equal 5 ???"
                    },
                    {
                        "username": "bparanj",
                        "content": "This discrepancy arises from the order in which we are allowed to perform the gcd operations on the array.\\n\\nFor the array [2, 6, 3, 4]:\\n\\n1. We can select index 2 (i.e., the number 3) and take the gcd with the number at index 3 (i.e., the number 4), and replace 3 with gcd(3, 4) = 1. Array becomes [2, 6, 1, 4].\\n2. We can then select index 1 (i.e., the number 6) and take the gcd with the number at index 2 (i.e., the number 1), and replace 6 with gcd(6, 1) = 1. Array becomes [2, 1, 1, 4].\\n3. Then, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [1, 1, 1, 4].\\n4. Finally, select index 2 (i.e., the number 1) and take the gcd with the number at index 3 (i.e., the number 4), and replace 4 with gcd(1, 4) = 1. Array becomes [1, 1, 1, 1].\\n\\nTotal operations = 4.\\n\\nFor the array [4, 2, 6, 3]:\\n\\n1. We can select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 6), and replace 2 with gcd(2, 6) = 2. Array becomes [4, 2, 6, 3].\\n2. Repeat step 1. Array still is [4, 2, 6, 3].\\n3. Repeat step 1 again. Array still is [4, 2, 6, 3].\\n4. Finally, select index 3 (i.e., the number 3) and take the gcd with the number at index 2 (i.e., the number 6), and replace 3 with gcd(3, 6) = 3. Array becomes [4, 2, 6, 1].\\n5. Now, select index 0 (i.e., the number 4) and take the gcd with the number at index 1 (i.e., the number 2), and replace 4 with gcd(4, 2) = 2. Array becomes [2, 2, 6, 1].\\n6. Next, select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 6), and replace 2 with gcd(2, 6) = 2. Array still is [2, 2, 6, 1].\\n7. Repeat step 6. Array still is [2, 2, 6, 1].\\n8. Repeat step 6 again. Array still is [2, 2, 6, 1].\\n9. Repeat step 6 once more. Array still is [2, 2, 6, 1].\\n10. Finally, select index 2 (i.e., the number 6) and take the gcd with the number at index 3 (i.e., the number 1), and replace 6 with gcd(6, 1) = 1. Array becomes [2, \\n\\n2, 1, 1].\\n11. Now, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 2), and replace 2 with gcd(2, 2) = 2. Array still is [2, 2, 1, 1].\\n12. Repeat step 11. Array still is [2, 2, 1, 1].\\n13. Repeat step 11 again. Array still is [2, 2, 1, 1].\\n14. Finally, select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [2, 1, 1, 1].\\n15. Now, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [1, 1, 1, 1].\\n\\nTotal operations = 15.\\n\\nThis demonstrates how the order of the array can affect the total number of operations required to achieve all elements as 1. The most optimized way to get all elements to 1 can depend on the order of elements in the array."
                    },
                    {
                        "username": "ZX007java",
                        "content": "[@s_m99](/s_m99) THANK YOU !!! CONSECUTIVE !!!"
                    },
                    {
                        "username": "s_m99",
                        "content": "You can only calculate gcd\\'s of 2 **consecutive** numbers and replace either of them. So in set [4,2,6,3] to make 3 into 1 we require two operations instead of one in [2,6,3,4] "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Damn, that was a great problem but... Medium, really? Am I just getting dumber? \nTook me quite lot of time and tryhard to see the solution.\nAnd that's gotta be the lowest acceptance rate I've seen for a medium problem\n\nAlso, python has a built-in gcd function apparently. Lesson learned; next time, no need to face my anxieties trying to remember my number theory classes to implement the Euclidean algo myself"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "Anyone explain or hint"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "light hint: how many steps would it take to get your first one in the array? And once you have a one, how many more steps do you need to turn everything into a one?"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "I am not able to understand the question\\nit says \\nselect index i and change num[i] or num[i+1] with their GCD and people have used n^2 loop to check every pair"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement asks for the minimum number of operations required to make all elements of an array equal to 1, by replacing either nums[i] or nums[i+1] with their gcd (greatest common divisor).\\n\\nThe problem solution is implemented with an O(n^2) approach, and this is why:\\n\\n1. You iterate over each element in the array (first loop).\\n2. For each element, you check for a contiguous segment in the array where the gcd of the numbers in the segment equals 1 (second loop). If such a segment is found, you store the length of that segment minus 1 (because one element is already 1 and doesn\\'t need any operation).\\n3. The result of the algorithm is the minimum length of these segments (if any) plus the number of elements outside these segments (because each of these will need one operation to become 1, by taking the gcd with 1).\\n\\nThe algorithm needs to check all pairs of elements because the array isn\\'t necessarily sorted, and any pair (i, j) with i < j can potentially form a contiguous segment where the gcd of the numbers is 1. So, an element nums[i] might be replaced by the gcd of nums[i] and nums[j] for some j > i.\\n"
                    },
                    {
                        "username": "User___",
                        "content": "[@cartesPerforees](/cartesPerforees) Is that $$O(n)$$?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I think you understand the question, it's just the solutions that you don't understand.\nWe check every pair to find the closest elements that could lead to a gcd of 1. Then we propagate the gcd neighbor-by-neighbor"
                    }
                ]
            },
            {
                "id": 1871577,
                "content": [
                    {
                        "username": "rideau",
                        "content": "Does anybody know how solve this in O(1) time? Is this even possible?"
                    },
                    {
                        "username": "brinuke",
                        "content": "Pay no attention to that follow-up. The person who wrote it was drunk."
                    },
                    {
                        "username": "User___",
                        "content": "Did you manage to solve it in $$O(n)$$? Just wondering, since you\\'re asking about $$O(1)$$ (which I feel isn\\'t possible)"
                    },
                    {
                        "username": "SergeyTT",
                        "content": "I think it's quite easy to prove that it impossible to solve this problem in O(1) time complexity.\nImaging you have an array of length N, for which the asnwer is \"-1\" - that is, you cannot make all elements equal to 1 using any number of operations. Now, insert number \"1\" at a random index of the array, and now you can make all other numbers equal to 1. In order to find this \"1\" you need O(N) time complexity."
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, your reasoning is absolutely correct. As per the problem, you need to inspect each element of the array to determine if the number 1 is present or if a pair of numbers exists such that their greatest common divisor (gcd) is 1. This requires at least linear time, O(N), where N is the length of the array.\\n\\nAs you\\'ve aptly illustrated, the presence of a single 1 in the array changes the entire outcome of the problem. Without examining each element, we cannot determine the presence or absence of such a crucial value. This necessitates iterating through the array at least once, thereby confirming that the problem cannot be solved in constant time, O(1)."
                    },
                    {
                        "username": "SlickGeek",
                        "content": "\"...but could you find an O(1) constant time complexity solution?\" Is it actually possible to solve this problem in constant time? I don\\'t know if there\\'s something I am not seeing or understanding, but I don\\'t think that is possible.\\nThe solution I came up with runs in N^2 and beats 71%."
                    },
                    {
                        "username": "bparanj",
                        "content": "[@rideau](/rideau) see [@Sergey TT](/SergeyTT)\\'s respose"
                    },
                    {
                        "username": "rideau",
                        "content": "Any updates? Im also interested "
                    },
                    {
                        "username": "sanjitj7",
                        "content": "EDIT: I have spotted my n00b mistake\n\nI think this test case is incorrect!\n\n>Input: nums = [2,10,6,14]\n>Output: -1\n>Explanation: It can be shown that it is impossible to make all the elements equal to 1\n\n[2,10,6,14]\n[2,10,3,14]  (i = 2)\n[2,10,3,1]   (i = 2)\n[2,10,1,1]\n[2,1,1,1]\n[1,1,1,1]\n\nThis caused a lot of confusion to me."
                    },
                    {
                        "username": "sanjitj7",
                        "content": "oh scheisse, I was taking num/GCD there \\uD83D\\uDE05 "
                    },
                    {
                        "username": "srk696772",
                        "content": "Bro GCD(6,14) == 2 ,  \nnot 3"
                    },
                    {
                        "username": "bekbossyn_kassymkhan",
                        "content": "gcd(6 & 14) = 2 , gcd(10,6)=2 also \n:)"
                    },
                    {
                        "username": "gaurav1903",
                        "content": "What\\'s the O(N) solution??"
                    },
                    {
                        "username": "bparanj",
                        "content": "The O(N) solution leverages the fact that if we can find two numbers in the array whose greatest common divisor (gcd) is 1, then the minimum number of operations required is the size of the array minus 1.\\n\\nTo achieve this in linear time, we can use the Sieve of Eratosthenes, a well-known algorithm for finding all prime numbers up to a given limit. This algorithm can be used to find the smallest prime factor for each number in the array, which is a prerequisite for finding two numbers with gcd 1.\\n\\nHere are the steps of the algorithm:\\n\\n1. Compute the smallest prime factor for each number up to max(nums) using the Sieve of Eratosthenes.\\n2. For each number in nums, if its smallest prime factor divides another number in nums, we can assume that the gcd of these two numbers is 1.\\n3. If we find such a pair, the minimum number of operations required is the size of the array minus 1.\\n4. If no such pair exists, we cannot make all elements equal to 1, so we return -1.\\n\\nNote: As the Sieve of Eratosthenes requires O(N log log N) time complexity, this solution is not strictly linear. However, it is significantly more efficient than an O(N^2) solution when dealing with large inputs.\\n\\nThis solution assumes that the input numbers are not too large (e.g., within the range of an integer). If the numbers can be very large, we need a different approach because the Sieve of Eratosthenes may not be feasible. For example, we could use a probabilistic algorithm to find a pair of numbers with gcd 1, but this would not guarantee a correct answer in all cases.\\n\\nAlso, it\\'s important to note that this approach doesn\\'t give the exact number of operations if no \"1\" is found in the array; it only checks for the possibility of making all elements equal to 1. Calculating the exact number of operations in such a case can be a more complex problem and is likely to require more than linear time."
                    },
                    {
                        "username": "ZX007java",
                        "content": "Good day ! Can anyone give me answer : why set [2, 6, 3, 4] have answer is equal 4, BUT SET [4, 2, 6, 3] have answer is equal 5 ???"
                    },
                    {
                        "username": "bparanj",
                        "content": "This discrepancy arises from the order in which we are allowed to perform the gcd operations on the array.\\n\\nFor the array [2, 6, 3, 4]:\\n\\n1. We can select index 2 (i.e., the number 3) and take the gcd with the number at index 3 (i.e., the number 4), and replace 3 with gcd(3, 4) = 1. Array becomes [2, 6, 1, 4].\\n2. We can then select index 1 (i.e., the number 6) and take the gcd with the number at index 2 (i.e., the number 1), and replace 6 with gcd(6, 1) = 1. Array becomes [2, 1, 1, 4].\\n3. Then, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [1, 1, 1, 4].\\n4. Finally, select index 2 (i.e., the number 1) and take the gcd with the number at index 3 (i.e., the number 4), and replace 4 with gcd(1, 4) = 1. Array becomes [1, 1, 1, 1].\\n\\nTotal operations = 4.\\n\\nFor the array [4, 2, 6, 3]:\\n\\n1. We can select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 6), and replace 2 with gcd(2, 6) = 2. Array becomes [4, 2, 6, 3].\\n2. Repeat step 1. Array still is [4, 2, 6, 3].\\n3. Repeat step 1 again. Array still is [4, 2, 6, 3].\\n4. Finally, select index 3 (i.e., the number 3) and take the gcd with the number at index 2 (i.e., the number 6), and replace 3 with gcd(3, 6) = 3. Array becomes [4, 2, 6, 1].\\n5. Now, select index 0 (i.e., the number 4) and take the gcd with the number at index 1 (i.e., the number 2), and replace 4 with gcd(4, 2) = 2. Array becomes [2, 2, 6, 1].\\n6. Next, select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 6), and replace 2 with gcd(2, 6) = 2. Array still is [2, 2, 6, 1].\\n7. Repeat step 6. Array still is [2, 2, 6, 1].\\n8. Repeat step 6 again. Array still is [2, 2, 6, 1].\\n9. Repeat step 6 once more. Array still is [2, 2, 6, 1].\\n10. Finally, select index 2 (i.e., the number 6) and take the gcd with the number at index 3 (i.e., the number 1), and replace 6 with gcd(6, 1) = 1. Array becomes [2, \\n\\n2, 1, 1].\\n11. Now, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 2), and replace 2 with gcd(2, 2) = 2. Array still is [2, 2, 1, 1].\\n12. Repeat step 11. Array still is [2, 2, 1, 1].\\n13. Repeat step 11 again. Array still is [2, 2, 1, 1].\\n14. Finally, select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [2, 1, 1, 1].\\n15. Now, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [1, 1, 1, 1].\\n\\nTotal operations = 15.\\n\\nThis demonstrates how the order of the array can affect the total number of operations required to achieve all elements as 1. The most optimized way to get all elements to 1 can depend on the order of elements in the array."
                    },
                    {
                        "username": "ZX007java",
                        "content": "[@s_m99](/s_m99) THANK YOU !!! CONSECUTIVE !!!"
                    },
                    {
                        "username": "s_m99",
                        "content": "You can only calculate gcd\\'s of 2 **consecutive** numbers and replace either of them. So in set [4,2,6,3] to make 3 into 1 we require two operations instead of one in [2,6,3,4] "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Damn, that was a great problem but... Medium, really? Am I just getting dumber? \nTook me quite lot of time and tryhard to see the solution.\nAnd that's gotta be the lowest acceptance rate I've seen for a medium problem\n\nAlso, python has a built-in gcd function apparently. Lesson learned; next time, no need to face my anxieties trying to remember my number theory classes to implement the Euclidean algo myself"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "Anyone explain or hint"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "light hint: how many steps would it take to get your first one in the array? And once you have a one, how many more steps do you need to turn everything into a one?"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "I am not able to understand the question\\nit says \\nselect index i and change num[i] or num[i+1] with their GCD and people have used n^2 loop to check every pair"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement asks for the minimum number of operations required to make all elements of an array equal to 1, by replacing either nums[i] or nums[i+1] with their gcd (greatest common divisor).\\n\\nThe problem solution is implemented with an O(n^2) approach, and this is why:\\n\\n1. You iterate over each element in the array (first loop).\\n2. For each element, you check for a contiguous segment in the array where the gcd of the numbers in the segment equals 1 (second loop). If such a segment is found, you store the length of that segment minus 1 (because one element is already 1 and doesn\\'t need any operation).\\n3. The result of the algorithm is the minimum length of these segments (if any) plus the number of elements outside these segments (because each of these will need one operation to become 1, by taking the gcd with 1).\\n\\nThe algorithm needs to check all pairs of elements because the array isn\\'t necessarily sorted, and any pair (i, j) with i < j can potentially form a contiguous segment where the gcd of the numbers is 1. So, an element nums[i] might be replaced by the gcd of nums[i] and nums[j] for some j > i.\\n"
                    },
                    {
                        "username": "User___",
                        "content": "[@cartesPerforees](/cartesPerforees) Is that $$O(n)$$?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I think you understand the question, it's just the solutions that you don't understand.\nWe check every pair to find the closest elements that could lead to a gcd of 1. Then we propagate the gcd neighbor-by-neighbor"
                    }
                ]
            }
        ]
    },
    {
        "title": "Count Artist Occurrences On Spotify Ranking List",
        "question_content": null,
        "solutions": [],
        "discussions": []
    },
    {
        "title": "Sum in a Matrix",
        "question_content": "<p>You are given a <strong>0-indexed</strong> 2D integer array <code>nums</code>. Initially, your score is <code>0</code>. Perform the following operations until the matrix becomes empty:</p>\n\n<ol>\n\t<li>From each row in the matrix, select the largest number and remove it. In the case of a tie, it does not matter which number is chosen.</li>\n\t<li>Identify the highest number amongst all those removed in step 1. Add that number to your <strong>score</strong>.</li>\n</ol>\n\n<p>Return <em>the final <strong>score</strong>.</em></p>\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [[7,2,1],[6,4,2],[6,5,3],[3,2,1]]\n<strong>Output:</strong> 15\n<strong>Explanation:</strong> In the first operation, we remove 7, 6, 6, and 3. We then add 7 to our score. Next, we remove 2, 4, 5, and 2. We add 5 to our score. Lastly, we remove 1, 2, 3, and 1. We add 3 to our score. Thus, our final score is 7 + 5 + 3 = 15.\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [[1]]\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> We remove 1 and add it to the answer. We return 1.</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 300</code></li>\n\t<li><code>1 &lt;= nums[i].length &lt;= 500</code></li>\n\t<li><code>0 &lt;= nums[i][j] &lt;= 10<sup>3</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 3520226,
                "title": "very-simple-easy-to-understand-solution",
                "content": "<b> Up vote if you like the solution </b>\\n\\n# Approach\\n1. Sort the matrix on each row.\\n2. Then traverse the matrix column wise and keep adding the max value on each column to ans.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int ans = 0;\\n        for(int i = 0; i < nums.size(); ++i){\\n            sort(nums[i].begin(), nums[i].end());\\n        }\\n        for(int c = 0; c < nums[0].size(); ++c){\\n            int t = 0;\\n            for(int r = 0; r <nums.size(); ++r){\\n                t = max(t, nums[r][c]);\\n            }\\n            ans += t;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n<b> Here is an article of my last interview experience - A Journey to FAANG Company, I recomand you to go through this to know which all resources I have used & how I cracked interview at Amazon:\\nhttps://leetcode.com/discuss/interview-experience/3171859/Journey-to-a-FAANG-Company-Amazon-or-SDE2-(L5)-or-Bangalore-or-Oct-2022-Accepted",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int ans = 0;\\n        for(int i = 0; i < nums.size(); ++i){\\n            sort(nums[i].begin(), nums[i].end());\\n        }\\n        for(int c = 0; c < nums[0].size(); ++c){\\n            int t = 0;\\n            for(int r = 0; r <nums.size(); ++r){\\n                t = max(t, nums[r][c]);\\n            }\\n            ans += t;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521285,
                "title": "c-don-t-trash-your-cache-fast",
                "content": "# Approach 1: sort and traverse row wise (112ms, 100%?)\\n\\nFor a large matrix traversing it column wise would be really bad for cache locality and work against all CPU memory prefetching. We can avoid this be just keep a vector for the max values in each column and process row by row.\\n\\n```cpp\\n    static int matrixSum(vector<vector<int>>& nums) {\\n        const int cols = size(nums[0]);\\n        vector<int> maxs(cols);\\n        for (vector<int>& row : nums) {\\n            sort(begin(row), end(row));\\n            for (int c = 0; c < cols; ++c)\\n                maxs[c] = max(maxs[c], row[c]);\\n        }\\n        return reduce(begin(maxs), end(maxs));\\n    }\\n```\\n\\n**Complexity Analysis**\\nWith a matrix of $$r$$ rows and $$c$$ columns the\\n\\n* Time complexity is $$O(r * c \\\\log c)$$ as we need to sort each row and sorting is the dominating factor and the\\n\\n* Space complexity is $$O(c)$$ as we need to keep the max for each column.\\n\\n_As always: Feedback, questions, and comments are welcome. Leaving an up-vote sparks joy! :)_\\n\\n**p.s. Join us on the [LeetCode The Hard Way Discord Server](https://discord.gg/hFUyVyWy2E)!**\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\n    static int matrixSum(vector<vector<int>>& nums) {\\n        const int cols = size(nums[0]);\\n        vector<int> maxs(cols);\\n        for (vector<int>& row : nums) {\\n            sort(begin(row), end(row));\\n            for (int c = 0; c < cols; ++c)\\n                maxs[c] = max(maxs[c], row[c]);\\n        }\\n        return reduce(begin(maxs), end(maxs));\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3520728,
                "title": "one-liner",
                "content": "**Python 3**\\n```python\\nclass Solution:\\n    def matrixSum(self, nums: List[List[int]]) -> int:\\n        return sum(max(col) for col in zip(*[sorted(row) for row in nums]))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def matrixSum(self, nums: List[List[int]]) -> int:\\n        return sum(max(col) for col in zip(*[sorted(row) for row in nums]))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520279,
                "title": "java-simple-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n            int ans=0;\\n        for(int []row:nums)\\n        {\\n                Arrays.sort(row);\\n        }\\n            for(int i=0;i<nums[0].length;i++)\\n            {\\n                    int m=0;\\n                    for(int j=0;j<nums.length;j++)\\n                    {\\n                            if(m<nums[j][i])\\n                                    m=nums[j][i];\\n                    }\\n                    ans+=m;\\n            }\\n            return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n            int ans=0;\\n        for(int []row:nums)\\n        {\\n                Arrays.sort(row);\\n        }\\n            for(int i=0;i<nums[0].length;i++)\\n            {\\n                    int m=0;\\n                    for(int j=0;j<nums.length;j++)\\n                    {\\n                            if(m<nums[j][i])\\n                                    m=nums[j][i];\\n                    }\\n                    ans+=m;\\n            }\\n            return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522624,
                "title": "sort-and-count",
                "content": "\\n\\n```py\\nclass Solution:\\n    def matrixSum(self, nums: List[List[int]]) -> int:\\n        m, n = len(nums), len(nums[0])\\n        res = 0\\n        # sort each row\\n        for num in nums: num.sort()\\n        # for each column, \\n        for j in range(n):\\n            # we look for the highest number\\n            mx = 0\\n            for i in range(m): mx = max(mx, nums[i][j])\\n            # then add that number to the score\\n            res += mx\\n        return res\\n```\\n\\n\\n\\n```\\nclass Solution:\\n    def matrixSum(self, nums: List[List[int]]) -> int:\\n        res = 0\\n        # we first sort the rows, then transpose the input\\n        # in this way, we can just use max to find the higher number\\n        for col in zip(*[sorted(row) for row in nums]):\\n            # [\\n            #     (1, 2, 3, 1), \\n            #     (2, 4, 5, 2), \\n            #     (7, 6, 6, 3)\\n            # ]\\n            res += max(col)\\n        return res\\n```\\n\\n**p.s. Join us on the LeetCode The Hard Way Discord Study Group for timely discussion! Link in bio.**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```py\\nclass Solution:\\n    def matrixSum(self, nums: List[List[int]]) -> int:\\n        m, n = len(nums), len(nums[0])\\n        res = 0\\n        # sort each row\\n        for num in nums: num.sort()\\n        # for each column, \\n        for j in range(n):\\n            # we look for the highest number\\n            mx = 0\\n            for i in range(m): mx = max(mx, nums[i][j])\\n            # then add that number to the score\\n            res += mx\\n        return res\\n```\n```\\nclass Solution:\\n    def matrixSum(self, nums: List[List[int]]) -> int:\\n        res = 0\\n        # we first sort the rows, then transpose the input\\n        # in this way, we can just use max to find the higher number\\n        for col in zip(*[sorted(row) for row in nums]):\\n            # [\\n            #     (1, 2, 3, 1), \\n            #     (2, 4, 5, 2), \\n            #     (7, 6, 6, 3)\\n            # ]\\n            res += max(col)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520438,
                "title": "simple-c-solution-using-sorting-space-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n*m*log(m))\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n     int matrixSum(vector<vector<int>>& nums) {\\n         \\n        int ans = 0;\\n        int row = nums.size();\\n        int col = nums[0].size();\\n         for(int i = 0 ; i < row ; i++)\\n         {\\n            sort(nums[i].begin(),nums[i].end());\\n         }\\n        for(int i = 0 ; i < col ; i++)\\n        {\\n            int max = 0;\\n            for(int j = 0 ; j < row ; j++)\\n            {\\n                if(max < nums[j][i]) max = nums[j][i];\\n            }\\n            ans += max;\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sort",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     int matrixSum(vector<vector<int>>& nums) {\\n         \\n        int ans = 0;\\n        int row = nums.size();\\n        int col = nums[0].size();\\n         for(int i = 0 ; i < row ; i++)\\n         {\\n            sort(nums[i].begin(),nums[i].end());\\n         }\\n        for(int i = 0 ; i < col ; i++)\\n        {\\n            int max = 0;\\n            for(int j = 0 ; j < row ; j++)\\n            {\\n                if(max < nums[j][i]) max = nums[j][i];\\n            }\\n            ans += max;\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520878,
                "title": "c-sort-each-find-max-each-columns",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int ans = 0;\\n        int i,j,x,m=nums.size(),n = nums[0].size();\\n        for(auto &i: nums){\\n            sort(i.begin(),i.end());\\n        }\\n        for(j = 0; j < n; j++){\\n            x = 0;\\n            for(i = 0; i < m; i++){\\n                x = max(x,nums[i][j]);\\n            }\\n            ans += x;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sort",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int ans = 0;\\n        int i,j,x,m=nums.size(),n = nums[0].size();\\n        for(auto &i: nums){\\n            sort(i.begin(),i.end());\\n        }\\n        for(j = 0; j < n; j++){\\n            x = 0;\\n            for(i = 0; i < m; i++){\\n                x = max(x,nums[i][j]);\\n            }\\n            ans += x;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520755,
                "title": "full-proper-step-by-step-explanation-simplest-solution",
                "content": "# Intuition\\nThe problem provides a 2D array called `nums`, where each element represents an integer. The goal is to calculate the final score by following these steps until the matrix becomes empty:\\n\\n1. For each row in the matrix, select the largest number and remove it. In case of a tie, it does not matter which number is chosen.\\n2. Identify the highest number among all those removed in step 1.\\n3. Add that highest number to the score.\\n4. Repeat steps 1-3 until the matrix becomes empty.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Initialize a variable `score` to keep track of the total score, and a variable `maxNum` to store the highest number encountered.\\n2. Iterate through the rows of the matrix and find the largest number in each row. You can do this by traversing each row and keeping track of the maximum number found so far.\\n3. After finding the largest number in each row, remove that number from the matrix.\\n4. Update the `maxNum` variable by comparing it with the largest number found in step 2. If the largest number is greater than `maxNum`, update `maxNum` accordingly.\\n5. Add `maxNum` to the `score` variable.\\n6. Repeat steps 2 to 5 until the matrix becomes empty, i.e., all elements are removed.\\n7. Return the final `score`.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int score = 0;\\n\\n        while (!nums.empty()) {\\n            int maxNum = INT_MIN;\\n\\n            for (int i = 0; i < nums.size(); i++) {\\n                if (!nums[i].empty()) {\\n                    int rowMax = *max_element(nums[i].begin(), nums[i].end());\\n                    maxNum = max(maxNum, rowMax);\\n                    nums[i].erase(find(nums[i].begin(), nums[i].end(), rowMax));\\n\\n                    if (nums[i].empty()) {\\n                        nums.erase(nums.begin() + i);\\n                        i--;\\n                    }\\n                }\\n            }\\n\\n            score += maxNum;\\n        }\\n\\n        return score;\\n    }\\n};\\n```\\n![images.jpeg](https://assets.leetcode.com/users/images/fd982757-a62d-4497-92b0-d6afef451dc2_1683998758.3136413.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int score = 0;\\n\\n        while (!nums.empty()) {\\n            int maxNum = INT_MIN;\\n\\n            for (int i = 0; i < nums.size(); i++) {\\n                if (!nums[i].empty()) {\\n                    int rowMax = *max_element(nums[i].begin(), nums[i].end());\\n                    maxNum = max(maxNum, rowMax);\\n                    nums[i].erase(find(nums[i].begin(), nums[i].end(), rowMax));\\n\\n                    if (nums[i].empty()) {\\n                        nums.erase(nums.begin() + i);\\n                        i--;\\n                    }\\n                }\\n            }\\n\\n            score += maxNum;\\n        }\\n\\n        return score;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520395,
                "title": "very-simple-fast-and-easy-solution-in-python3",
                "content": "first sort every row , then find the max element in each column and sum them up ( here , I made a array of max element from every column )\\n```\\nimport numpy as np\\nclass Solution:\\n    def matrixSum(self, nums: List[List[int]]) -> int:\\n        ans = 0\\n        for i in nums:\\n            i.sort()\\n        arr = np.array(nums)\\n        x = np.amax(arr,axis= 0)\\n        return sum(x)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\nimport numpy as np\\nclass Solution:\\n    def matrixSum(self, nums: List[List[int]]) -> int:\\n        ans = 0\\n        for i in nums:\\n            i.sort()\\n        arr = np.array(nums)\\n        x = np.amax(arr,axis= 0)\\n        return sum(x)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520288,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n        int ans=0;\\n        for(int i=0;i<nums.length;i++){\\n            Arrays.sort(nums[i]);\\n        }\\n        for(int i=0;i<nums[0].length;i++){\\n            int max=0;\\n            for(int j=0;j<nums.length;j++){\\n                max=Math.max(max,nums[j][i]);\\n            }\\n            ans+=max;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n        int ans=0;\\n        for(int i=0;i<nums.length;i++){\\n            Arrays.sort(nums[i]);\\n        }\\n        for(int i=0;i<nums[0].length;i++){\\n            int max=0;\\n            for(int j=0;j<nums.length;j++){\\n                max=Math.max(max,nums[j][i]);\\n            }\\n            ans+=max;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520225,
                "title": "python-elegant-short-straightforward-vs-python-magic",
                "content": "# Complexity\\n- Time complexity: $$O(n * m * \\\\log_{2} m)$$\\n- Space complexity: $$O(n * m)$$\\n\\n# Straightforward version\\n\\n```\\nclass Solution:\\n    def matrixSum(self, nums: List[List[int]]) -> int:\\n        rows = [sorted(row) for row in nums]\\n        return sum(max(row[i] for row in rows) for i in range(len(rows[0])))\\n```\\n\\n# Python Built-In Magic)\\n```\\nclass Solution:\\n    def matrixSum(self, nums: List[List[int]]) -> int:\\n        return sum(map(max, zip(*map(sorted, nums))))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def matrixSum(self, nums: List[List[int]]) -> int:\\n        rows = [sorted(row) for row in nums]\\n        return sum(max(row[i] for row in rows) for i in range(len(rows[0])))\\n```\n```\\nclass Solution:\\n    def matrixSum(self, nums: List[List[int]]) -> int:\\n        return sum(map(max, zip(*map(sorted, nums))))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522380,
                "title": "sort-the-rows-100-beats-simple-and-easy-to-understand-c-solution",
                "content": "# Intuition\\nsort the rows of matrix and add the maximum of each column to the result.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int n=nums.size();\\n        int m=nums[0].size();\\n        for(int i=0;i<n;i++)\\n        {\\n            sort(nums[i].begin(),nums[i].end(),greater<int>());\\n        }\\n        int ans=0,temp=0;\\n        for(int i=0;i<m;i++)\\n        {  temp=0;\\n            for(int j=0;j<n;j++)\\n            {\\n                temp=max(temp,nums[j][i]);\\n            }\\n         ans+=temp;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int n=nums.size();\\n        int m=nums[0].size();\\n        for(int i=0;i<n;i++)\\n        {\\n            sort(nums[i].begin(),nums[i].end(),greater<int>());\\n        }\\n        int ans=0,temp=0;\\n        for(int i=0;i<m;i++)\\n        {  temp=0;\\n            for(int j=0;j<n;j++)\\n            {\\n                temp=max(temp,nums[j][i]);\\n            }\\n         ans+=temp;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520683,
                "title": "very-simple-solution-100-fast-sorting",
                "content": "# Intuition\\n- Sort each row of the matrix in ascending order. This ensures that the largest number in each row is at the end.\\n\\n- Iterate over each column and find the maximum number among all the elements in that column. Since the rows are sorted, the largest number in each column will be at the last index of that column.\\n\\n- Add the maximum number found in step 2 to the score. This represents the highest number among all the numbers removed from the matrix.\\n\\n- Repeat steps 2-3 until all the numbers in the matrix are removed. This means performing steps 2-3 for each column until there are no more numbers left in the matrix.\\n\\n- Return the final score, which represents the sum of the highest numbers from each column.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe approach is to first sort each row to ensure that the largest number is at the end. Then, by iterating over each column, we find the maximum number and add it to the score. This process is repeated until all numbers are removed from the matrix. The final score is returned as the result.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- **Time complexity:** Sorting each row: O(n * m * log(m)), where n is the number of rows and m is the number of columns.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- **Space complexity:** The given solution has a space complexity of O(1) since it does not use any additional data structures\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# C++\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int sum=0;\\n        for(int i=0;i<nums.size();i++)\\n            sort(nums[i].begin(), nums[i].end());\\n    \\n        for(int i=0;i<nums[0].size();i++){\\n            int maxi=0;\\n            for(int j=0;j<nums.size();j++){\\n                maxi=max(nums[j][i],maxi);\\n            }\\n            sum+=maxi;\\n        }\\n        return sum;\\n    }\\n};\\n```\\n\\n# Java\\n```\\nimport java.util.Arrays;\\n\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n        int sum = 0;\\n        \\n        for (int i = 0; i < nums.length; i++)\\n            Arrays.sort(nums[i]);\\n        \\n        for (int i = 0; i < nums[0].length; i++) {\\n            int maxi = 0;\\n            for (int j = 0; j < nums.length; j++) {\\n                maxi = Math.max(nums[j][i], maxi);\\n            }\\n            sum += maxi;\\n        }\\n        \\n        return sum;\\n    }\\n}\\n\\n```\\n\\n# Python\\n```\\nclass Solution:\\n    def matrixSum(self, nums: List[List[int]]) -> int:\\n        total_sum = 0\\n        \\n        for row in nums:\\n            row.sort()\\n        \\n        for i in range(len(nums[0])):\\n            maxi = 0\\n            for j in range(len(nums)):\\n                maxi = max(nums[j][i], maxi)\\n            total_sum += maxi\\n        \\n        return total_sum\\n\\n\\n```\\n\\n# JavaScript\\n```\\n/**\\n * @param {number[][]} nums\\n * @return {number}\\n */\\nvar matrixSum = function(nums) {\\n    let sum = 0;\\n    \\n    for (let i = 0; i < nums.length; i++) {\\n        nums[i].sort((a, b) => a - b);\\n    }\\n    \\n    for (let i = 0; i < nums[0].length; i++) {\\n        let maxi = 0;\\n        for (let j = 0; j < nums.length; j++) {\\n            maxi = Math.max(nums[j][i], maxi);\\n        }\\n        sum += maxi;\\n    }\\n    \\n    return sum;\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "JavaScript",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int sum=0;\\n        for(int i=0;i<nums.size();i++)\\n            sort(nums[i].begin(), nums[i].end());\\n    \\n        for(int i=0;i<nums[0].size();i++){\\n            int maxi=0;\\n            for(int j=0;j<nums.size();j++){\\n                maxi=max(nums[j][i],maxi);\\n            }\\n            sum+=maxi;\\n        }\\n        return sum;\\n    }\\n};\\n```\n```\\nimport java.util.Arrays;\\n\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n        int sum = 0;\\n        \\n        for (int i = 0; i < nums.length; i++)\\n            Arrays.sort(nums[i]);\\n        \\n        for (int i = 0; i < nums[0].length; i++) {\\n            int maxi = 0;\\n            for (int j = 0; j < nums.length; j++) {\\n                maxi = Math.max(nums[j][i], maxi);\\n            }\\n            sum += maxi;\\n        }\\n        \\n        return sum;\\n    }\\n}\\n\\n```\n```\\nclass Solution:\\n    def matrixSum(self, nums: List[List[int]]) -> int:\\n        total_sum = 0\\n        \\n        for row in nums:\\n            row.sort()\\n        \\n        for i in range(len(nums[0])):\\n            maxi = 0\\n            for j in range(len(nums)):\\n                maxi = max(nums[j][i], maxi)\\n            total_sum += maxi\\n        \\n        return total_sum\\n\\n\\n```\n```\\n/**\\n * @param {number[][]} nums\\n * @return {number}\\n */\\nvar matrixSum = function(nums) {\\n    let sum = 0;\\n    \\n    for (let i = 0; i < nums.length; i++) {\\n        nums[i].sort((a, b) => a - b);\\n    }\\n    \\n    for (let i = 0; i < nums[0].length; i++) {\\n        let maxi = 0;\\n        for (let j = 0; j < nums.length; j++) {\\n            maxi = Math.max(nums[j][i], maxi);\\n        }\\n        sum += maxi;\\n    }\\n    \\n    return sum;\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520335,
                "title": "python-1-liner",
                "content": "# **Explanation**\\nSort each row, sum up the max of each column.\\n<br>\\n\\n# **Complexity**\\nTime `O(mnlogn)`\\nSpace `O(mn)`\\n<br>\\n\\n\\n**Python, 1-line**\\n```py\\n    def matrixSum(self, A: List[List[int]]) -> int:\\n        return sum(max(a) for a in zip(sorted(a) for a in A))\\n```\\n\\n**Python, shorter 1-line**\\n```py\\n    def matrixSum(self, A: List[List[int]]) -> int:\\n        return sum(map(max, zip(*map(sorted, A))))\\n```\\n",
                "solutionTags": [],
                "code": "```py\\n    def matrixSum(self, A: List[List[int]]) -> int:\\n        return sum(max(a) for a in zip(sorted(a) for a in A))\\n```\n```py\\n    def matrixSum(self, A: List[List[int]]) -> int:\\n        return sum(map(max, zip(*map(sorted, A))))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3583277,
                "title": "i-hope-this-solution-helps-you-beats-98-5-lines-code",
                "content": "# Intuition\\nThe first thought that comes to mind when solving this problem is to sort each row of the matrix in descending order. This will ensure that the largest numbers in each row are at the top. Next, we can transpose the matrix, which will swap the rows and columns. This will give us a new matrix where each column is a sorted list of the numbers from the original matrix. Finally, we can simply sum the maximum value from each column.\\n\\n# Approach\\nHere is a more detailed explanation of the approach:\\n\\nSort each row of the matrix in descending order.\\nTranspose the matrix.\\nSum the maximum value from each column.\\n# Complexity\\nThe time complexity of this algorithm is O(n^2), where n is the number of rows in the matrix. This is because the first step, sorting each row, takes O(n log n) time. The second step, transposing the matrix, takes O(n^2) time. And the third step, summing the maximum value from each column, takes O(n) time.\\n\\nThe space complexity of this algorithm is O(n^2), where n is the number of rows in the matrix. This is because we need to store the sorted rows of the matrix in memory, which takes O(n^2) space\\n\\n# Code\\n```\\nclass Solution:\\n    def matrixSum(self, nums: List[List[int]]) -> int:\\n        new_nums = []\\n        for row in nums:\\n            new_nums.append(sorted(row,reverse=True))\\n        trans=zip(*new_nums)\\n        s=0\\n        for i in trans:\\n            s+=max(i)\\n        return s\\n```",
                "solutionTags": [
                    "Python3",
                    "Sorting",
                    "Heap (Priority Queue)",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\nclass Solution:\\n    def matrixSum(self, nums: List[List[int]]) -> int:\\n        new_nums = []\\n        for row in nums:\\n            new_nums.append(sorted(row,reverse=True))\\n        trans=zip(*new_nums)\\n        s=0\\n        for i in trans:\\n            s+=max(i)\\n        return s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3525797,
                "title": "java-simple-sort-rows",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1, sort all rows;\\n2, find the largest of each column for each round, then add to result\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(M * N log N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\npublic int matrixSum(int[][] nums) {\\n    int m = nums.length,n = nums[0].length, res = 0;\\n    for (int i = 0; i < m; i++) Arrays.sort(nums[i]);\\n    for (int j = 0; j < n; j++) {\\n        int tmp = 0;\\n        for (int i = 0; i < m; i++) tmp = Math.max(tmp, nums[i][j]);\\n        res += tmp;\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int matrixSum(int[][] nums) {\\n    int m = nums.length,n = nums[0].length, res = 0;\\n    for (int i = 0; i < m; i++) Arrays.sort(nums[i]);\\n    for (int j = 0; j < n; j++) {\\n        int tmp = 0;\\n        for (int i = 0; i < m; i++) tmp = Math.max(tmp, nums[i][j]);\\n        res += tmp;\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3520542,
                "title": "c-fully-explained-with-approach-easiest-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n\\nstep 1: Solve the given 2D vector.\\n        -> your new matrix is: \\n        **1 2 7\\n        2 4 6\\n        3 5 6\\n        1 2 3**\\nStep 2: Take the last element from each row, and find max from these:\\nthus, your last element from col 3 will be: 7, 6, 6, 3\\n\\n-> now max from these is 7 thus we add that to the ans variable, which was initially assigned to 0\\n\\n# Complexity\\n- Time complexity:O(n^2 * log(n))\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   \\n    int matrixSum(vector<vector<int>>& nums) {\\n        int ans = 0;\\n        //nums.size() -> row\\n        //nums[0].size() -> col\\n\\n        //sort the vector\\n        for(int i = 0 ; i < nums.size(); i++){    \\n            sort(nums[i].begin(), nums[i].end());\\n            \\n        }\\n        //logic\\n        for(int i = 0 ; i < nums[0].size(); i++){\\n            \\n            int mx = 0;\\n            \\n            for(int j =0 ; j < nums.size(); j++){\\n                mx = max(mx, nums[j][i]);\\n            }\\n            ans += mx; \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   \\n    int matrixSum(vector<vector<int>>& nums) {\\n        int ans = 0;\\n        //nums.size() -> row\\n        //nums[0].size() -> col\\n\\n        //sort the vector\\n        for(int i = 0 ; i < nums.size(); i++){    \\n            sort(nums[i].begin(), nums[i].end());\\n            \\n        }\\n        //logic\\n        for(int i = 0 ; i < nums[0].size(); i++){\\n            \\n            int mx = 0;\\n            \\n            for(int j =0 ; j < nums.size(); j++){\\n                mx = max(mx, nums[j][i]);\\n            }\\n            ans += mx; \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520378,
                "title": "step-by-step-approach-easy-java-solution",
                "content": "# Intuition\\nUse arraylist Data Structure.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1) Make a 2d ArrayList to add all the values from nums array.\\n2) Now, get max element from from each row.\\n```\\nmax = Collections.max(al.get(i));\\n```\\n3) Now add all max values in a ArrayList `arr` and to find max from that `arr`.\\n```\\nint maxe = Collections.max(arr);\\ncount += maxe;\\n```\\n4) return that count.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- $$O(n^2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n        int n = nums.length, max = Integer.MIN_VALUE, temp = 0, count = 0;\\n        int m = nums[0].length;\\n        List<Integer> arr = new ArrayList<>();\\n        List<List<Integer>> al = new ArrayList<>();\\n        for(int i = 0; i < n; i++){\\n            al.add(new ArrayList<>());\\n        }\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < m; j++){\\n                al.get(i).add(nums[i][j]);\\n            }\\n        }\\n        while(al.get(0).size() != 0){\\n            for(int i = 0; i < n; i++){\\n                max = Collections.max(al.get(i));\\n                arr.add(max);\\n                al.get(i).remove(Integer.valueOf(max));\\n            }\\n            int maxe = Collections.max(arr);\\n            count += maxe;\\n            arr = new ArrayList<>();\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nmax = Collections.max(al.get(i));\\n```\n```\\nint maxe = Collections.max(arr);\\ncount += maxe;\\n```\n```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n        int n = nums.length, max = Integer.MIN_VALUE, temp = 0, count = 0;\\n        int m = nums[0].length;\\n        List<Integer> arr = new ArrayList<>();\\n        List<List<Integer>> al = new ArrayList<>();\\n        for(int i = 0; i < n; i++){\\n            al.add(new ArrayList<>());\\n        }\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < m; j++){\\n                al.get(i).add(nums[i][j]);\\n            }\\n        }\\n        while(al.get(0).size() != 0){\\n            for(int i = 0; i < n; i++){\\n                max = Collections.max(al.get(i));\\n                arr.add(max);\\n                al.get(i).remove(Integer.valueOf(max));\\n            }\\n            int maxe = Collections.max(arr);\\n            count += maxe;\\n            arr = new ArrayList<>();\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520320,
                "title": "easy-to-understand-java-solution",
                "content": "# Intuition\\n**First sort the array rowwise then add maximum for each column.**\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n        int score = 0;\\n        int n = nums.length;\\n        int m = nums[0].length;\\n        for(int[] a :nums)\\n        {\\n            Arrays.sort(a);\\n        }\\n        for(int i=0;i<m;i++)\\n        {\\n            int max = 0;\\n            for(int j=0;j<n;j++)\\n            {\\n                max = Math.max(max,nums[j][i]);\\n            }\\n            score+=max;\\n        }\\n        return score;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n        int score = 0;\\n        int n = nums.length;\\n        int m = nums[0].length;\\n        for(int[] a :nums)\\n        {\\n            Arrays.sort(a);\\n        }\\n        for(int i=0;i<m;i++)\\n        {\\n            int max = 0;\\n            for(int j=0;j<n;j++)\\n            {\\n                max = Math.max(max,nums[j][i]);\\n            }\\n            score+=max;\\n        }\\n        return score;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520282,
                "title": "java-solution-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n        int score = 0;\\n        \\n        for(int i = 0; i < nums.length; i++) {\\n            Arrays.sort(nums[i]);\\n        }\\n        \\n        for(int col = 0; col < nums[0].length; col++) {\\n            int max = nums[0][col];\\n            for(int row = 0; row < nums.length; row++) {\\n                if(nums[row][col] > max) {\\n                    max = nums[row][col];\\n                }\\n            }\\n            score += max;\\n        }\\n        return score;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n        int score = 0;\\n        \\n        for(int i = 0; i < nums.length; i++) {\\n            Arrays.sort(nums[i]);\\n        }\\n        \\n        for(int col = 0; col < nums[0].length; col++) {\\n            int max = nums[0][col];\\n            for(int row = 0; row < nums.length; row++) {\\n                if(nums[row][col] > max) {\\n                    max = nums[row][col];\\n                }\\n            }\\n            score += max;\\n        }\\n        return score;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520209,
                "title": "day-408-easy-100-python-java-c-explained",
                "content": "# Please Upvote as it really motivates me \\uD83C\\uDD99\\uD83C\\uDD99\\uD83C\\uDD99\\niterates over each column of the matrix and finds the maximum element in that column by iterating over each row. It then removes the maximum element from each row and adds the maximum element found to the sum. This process is repeated for each column, and the final sum is returned.\\n# Complexity\\nThe time complexity of this solution is O(n^2), where n is the number of elements in the matrix, since we need to iterate over each element in the matrix. The space complexity is also O(n^2), since we need to store the matrix in memory.\\n\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```python []\\ndef matrixSum(self, nums: List[List[int]]) -> int:\\n    sum=0\\n    for j in range(len(nums[0])):\\n        gmax=0\\n        for i in range(len(nums)):\\n            gmax=max(gmax,max(nums[i]))\\n            nums[i].remove(max(nums[i]))\\n        sum+=gmax;\\n    return sum   \\n```\\n```c++ []\\n int matrixSum(vector<vector<int>>& nums) {\\n        int sum = 0;\\n        for (int j = 0; j < nums[0].size(); j++) {\\n            int gmax = 0;\\n            for (int i = 0; i < nums.size(); i++) {\\n                gmax = max(gmax, *max_element(nums[i].begin(), nums[i].end()));\\n                nums[i].erase(max_element(nums[i].begin(), nums[i].end()));\\n            }\\n            sum += gmax;\\n        }\\n        return sum;\\n    }\\n```\\n```java []\\npublic int matrixSum(List<List<Integer>> nums) {\\n        int sum = 0;\\n        for (int j = 0; j < nums.get(0).size(); j++) {\\n            int gmax = 0;\\n            for (int i = 0; i < nums.size(); i++) {\\n                gmax = Math.max(gmax, Collections.max(nums.get(i)));\\n                nums.get(i).remove(Collections.max(nums.get(i)));\\n            }\\n            sum += gmax;\\n        }\\n        return sum;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3"
                ],
                "code": "```python []\\ndef matrixSum(self, nums: List[List[int]]) -> int:\\n    sum=0\\n    for j in range(len(nums[0])):\\n        gmax=0\\n        for i in range(len(nums)):\\n            gmax=max(gmax,max(nums[i]))\\n            nums[i].remove(max(nums[i]))\\n        sum+=gmax;\\n    return sum   \\n```\n```c++ []\\n int matrixSum(vector<vector<int>>& nums) {\\n        int sum = 0;\\n        for (int j = 0; j < nums[0].size(); j++) {\\n            int gmax = 0;\\n            for (int i = 0; i < nums.size(); i++) {\\n                gmax = max(gmax, *max_element(nums[i].begin(), nums[i].end()));\\n                nums[i].erase(max_element(nums[i].begin(), nums[i].end()));\\n            }\\n            sum += gmax;\\n        }\\n        return sum;\\n    }\\n```\n```java []\\npublic int matrixSum(List<List<Integer>> nums) {\\n        int sum = 0;\\n        for (int j = 0; j < nums.get(0).size(); j++) {\\n            int gmax = 0;\\n            for (int i = 0; i < nums.size(); i++) {\\n                gmax = Math.max(gmax, Collections.max(nums.get(i)));\\n                nums.get(i).remove(Collections.max(nums.get(i)));\\n            }\\n            sum += gmax;\\n        }\\n        return sum;\\n    }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3766700,
                "title": "simple-c-approach-best-and-easy-to-understand-for-begginer",
                "content": "# Approach\\nSort the matrix. After sorting all the greatest element will lie to the end of vector[i]. Compare all the last element of the vector[i] and find the largest one and store it in to a vector v. Run a loop while m(length of matrix[0]) > 0 and for each iteration do the same. Return the sum of vector v.\\n\\n# Complexity\\n- Time complexity:\\nO(m*n) where m is the length of vector[0] and n is length of vector<vector<int>>\\n\\n- Space complexity:\\nO(m*n) where m is the length of vector[0] and n is length of vector<vector<int>>\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n\\n        int n = nums.size();\\n        int m = nums[0].size();\\n\\n        //Sorting the Matrix\\n        sort(nums.begin(),nums.end());\\n\\n        for(int i=0;i<n;i++){\\n            sort(nums[i].begin(),nums[i].end());\\n        }\\n\\n        //Checking whether the matrix is sorted or not\\n        //for(auto x:nums){\\n            //for(auto y:x){\\n            //    cout<<y<<\" \";\\n            //}\\n          //  cout<<endl;\\n        //}\\n\\n        int maxi = -1; //-1 because the value of matrix >= 0. Given in constraint\\n\\n        vector<int> v;\\n\\n        //Running a loop till m is +ve number\\n\\n        while(m > 0){\\n            //Finding the greatest element from each row and \\n            for(int i=0;i<n;i++){\\n                maxi = max(maxi,nums[i][m-1]); \\n            }\\n            //Storing maximum value to the vector v\\n            v.push_back(maxi);\\n            // Reasssigning value of maxi for next iteration.\\n            maxi=-1;          \\n            m--;\\n        }    \\n\\n        int ans=0;\\n        for(auto x:v){\\n            ans +=x;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n\\n        int n = nums.size();\\n        int m = nums[0].size();\\n\\n        //Sorting the Matrix\\n        sort(nums.begin(),nums.end());\\n\\n        for(int i=0;i<n;i++){\\n            sort(nums[i].begin(),nums[i].end());\\n        }\\n\\n        //Checking whether the matrix is sorted or not\\n        //for(auto x:nums){\\n            //for(auto y:x){\\n            //    cout<<y<<\" \";\\n            //}\\n          //  cout<<endl;\\n        //}\\n\\n        int maxi = -1; //-1 because the value of matrix >= 0. Given in constraint\\n\\n        vector<int> v;\\n\\n        //Running a loop till m is +ve number\\n\\n        while(m > 0){\\n            //Finding the greatest element from each row and \\n            for(int i=0;i<n;i++){\\n                maxi = max(maxi,nums[i][m-1]); \\n            }\\n            //Storing maximum value to the vector v\\n            v.push_back(maxi);\\n            // Reasssigning value of maxi for next iteration.\\n            maxi=-1;          \\n            m--;\\n        }    \\n\\n        int ans=0;\\n        for(auto x:v){\\n            ans +=x;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3556439,
                "title": "python-simple-and-clean-beats-99-99",
                "content": "### Please upvote if you find this helpful. \\u270C\\n<img src=\"https://assets.leetcode.com/users/images/b8e25620-d320-420a-ae09-94c7453bd033_1678818986.7001078.jpeg\" alt=\"Cute Robot - Stable diffusion\" width=\"200\"/>\\n\\n*This is an NFT*\\n\\n# Intuition\\nThe problem asks us to repeatedly remove the largest number from each row of the matrix and add the maximum of those numbers to our score. One way to approach this problem is to sort each row of the matrix in descending order so that we can easily access the largest number in each row.\\n\\n# Approach\\n1. Sort each row of the input matrix in descending order.\\n2. Initialize a variable `res` to store the result.\\n3. Iterate through the columns of the matrix:\\n    1. Initialize a variable `curr` to store the maximum value in the current column.\\n    2. Iterate through the rows of the matrix and update `curr` with the maximum value in the current column.\\n    3. Add `curr` to `res`.\\n4. Return `res`.\\n\\n# Complexity\\n- Time complexity: $$O(nm \\\\log m)$$\\nThe time complexity of this solution is dominated by the sorting step, which takes $$O(nm \\\\log m)$$ time, where `n` is the number of rows and `m` is the number of columns in the input matrix.\\n\\n- Space complexity: $$O(1)$$\\nThe space complexity of this solution is constant since we only use a few variables to keep track of intermediate results.\\n\\n# Code\\n```\\nclass Solution:\\n    def matrixSum(self, nums: List[List[int]]) -> int:\\n        for row in nums:\\n            row.sort(reverse=True)\\n        res = 0\\n        n,m = len(nums),len(nums[0])\\n        for i in range(m):\\n            curr = -1\\n            for j in range(n):\\n                curr = max(curr,nums[j][i])\\n            res += curr\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\nclass Solution:\\n    def matrixSum(self, nums: List[List[int]]) -> int:\\n        for row in nums:\\n            row.sort(reverse=True)\\n        res = 0\\n        n,m = len(nums),len(nums[0])\\n        for i in range(m):\\n            curr = -1\\n            for j in range(n):\\n                curr = max(curr,nums[j][i])\\n            res += curr\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3549636,
                "title": "c-easy-solution",
                "content": "\\nclass Solution {\\npublic:\\n\\n    int matrixSum(vector<vector<int>>& nums) {\\n\\n        int row = nums.size();\\n        int col = nums[0].size();\\n        int ans =0;\\n \\n        for(int i=0; i<row; i++){\\n            sort(nums[i].begin(),nums[i].end());\\n        }\\n\\n        for(int i=0; i<col; i++){\\n            int maxi = INT_MIN;\\n            for(int j=0; j<row; j++){\\n                maxi = max(maxi,nums[j][i]);             \\n            }\\n            ans+=maxi;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sorting",
                    "Matrix"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int matrixSum(vector<vector<int>>& nums) {\\n\\n        int row = nums.size();\\n        int col = nums[0].size();\\n        int ans =0;\\n \\n        for(int i=0; i<row; i++){\\n            sort(nums[i].begin(),nums[i].end());\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3542731,
                "title": "simple-solution-using-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n         int sum=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            Arrays.sort(nums[i]);\\n\\n        }\\n       for(int i=0;i<nums[0].length;i++)\\n       {\\n            int max = 0;\\n            for(int j=0;j<nums.length;j++)\\n            {\\n                max = Math.max(max,nums[j][i]);\\n            }\\n            sum+=max;\\n       }\\n       return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n         int sum=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            Arrays.sort(nums[i]);\\n\\n        }\\n       for(int i=0;i<nums[0].length;i++)\\n       {\\n            int max = 0;\\n            for(int j=0;j<nums.length;j++)\\n            {\\n                max = Math.max(max,nums[j][i]);\\n            }\\n            sum+=max;\\n       }\\n       return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3542480,
                "title": "2679-sum-in-a-matrix-java",
                "content": "```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n        for(int x[]:nums)\\n            Arrays.sort(x);\\n        int ans=0;\\n        for(int i=0;i<nums[0].length;i++)\\n        {\\n            int max=Integer.MIN_VALUE;\\n          for(int j=0;j<nums.length;j++)\\n            {\\n                max=Math.max(nums[j][i],max);\\n            }\\n          ans+=max;\\n        } \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n        for(int x[]:nums)\\n            Arrays.sort(x);\\n        int ans=0;\\n        for(int i=0;i<nums[0].length;i++)\\n        {\\n            int max=Integer.MIN_VALUE;\\n          for(int j=0;j<nums.length;j++)\\n            {\\n                max=Math.max(nums[j][i],max);\\n            }\\n          ans+=max;\\n        } \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3539514,
                "title": "o-n-2-log-n-time-o-1-space-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int n = nums.size();\\n        int m = nums[0].size();\\n        for(int i = 0;i < n;i++){\\n            sort(nums[i].begin(),nums[i].end(),greater());\\n        }\\n        int maxi = 0,score = 0;\\n        for(int c = 0;c < m;c++){\\n            maxi = 0;\\n            for(int r = 0;r < n;r++){\\n                maxi = max(maxi,nums[r][c]);\\n                nums[r][c] = 0;\\n            }\\n            score += maxi;\\n        }\\n        return score;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int n = nums.size();\\n        int m = nums[0].size();\\n        for(int i = 0;i < n;i++){\\n            sort(nums[i].begin(),nums[i].end(),greater());\\n        }\\n        int maxi = 0,score = 0;\\n        for(int c = 0;c < m;c++){\\n            maxi = 0;\\n            for(int r = 0;r < n;r++){\\n                maxi = max(maxi,nums[r][c]);\\n                nums[r][c] = 0;\\n            }\\n            score += maxi;\\n        }\\n        return score;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3523052,
                "title": "c-brute-force-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:$$O(n^2*logn)$$\\n\\n- Space complexity:$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int ans=0;\\n        for(int i=0; i<nums.size(); i++){    \\n            sort(nums[i].begin(), nums[i].end());\\n        }\\n        for(int i=0; i<nums[0].size(); i++){\\n            int cnt=0;\\n            for(int j=0; j<nums.size(); j++){\\n                cnt=max(cnt, nums[j][i]);\\n            }\\n            ans+=cnt;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int ans=0;\\n        for(int i=0; i<nums.size(); i++){    \\n            sort(nums[i].begin(), nums[i].end());\\n        }\\n        for(int i=0; i<nums[0].size(); i++){\\n            int cnt=0;\\n            for(int j=0; j<nums.size(); j++){\\n                cnt=max(cnt, nums[j][i]);\\n            }\\n            ans+=cnt;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522395,
                "title": "java-solution-using-loops-and-sorting",
                "content": "\\n \\n# Approach\\n1. Sort the `internal 1-D arrays`.\\n2. Then take the `last element` from every row then find the max from there \\n3. Add in score;\\n4. Now take `second last element` from every row then find max from all of these Add in score;\\n5. Do this while first column is not reached;\\n\\n# Complexity\\n- Time complexity:O(n*n(logn))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n         int score=0;\\n        for(int i=0;i<nums.length;i++){\\n            Arrays.sort(nums[i]);\\n        }\\n        for(int j=0;j<nums[0].length;j++)\\n        { int max=nums[0][nums[0].length-j-1];\\n            for(int i=0;i<nums.length;i++) {\\n                if (nums[i][nums[0].length - j - 1] > max) {\\n                    max = nums[i][nums[0].length - j - 1];\\n                }\\n            }\\n                score+=max;\\n\\n            }\\n        return score;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n         int score=0;\\n        for(int i=0;i<nums.length;i++){\\n            Arrays.sort(nums[i]);\\n        }\\n        for(int j=0;j<nums[0].length;j++)\\n        { int max=nums[0][nums[0].length-j-1];\\n            for(int i=0;i<nums.length;i++) {\\n                if (nums[i][nums[0].length - j - 1] > max) {\\n                    max = nums[i][nums[0].length - j - 1];\\n                }\\n            }\\n                score+=max;\\n\\n            }\\n        return score;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522254,
                "title": "c-brute-force",
                "content": "\\n# Complexity\\n- Time complexity: $$O(m * n * m)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n * m)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int n = nums.size(), m = nums[0].size();\\n        vector<vector<int>> vis(n, vector<int>(m));\\n        int max_sum = 0;\\n        for(int t = 0; t < m; t++) {\\n            int ult_max = 0;\\n            for(int i = 0; i < n; i++) {\\n                int maxi = 0, col = 0;\\n                for(int j = 0; j < m; j++) {\\n                    if(nums[i][j] > maxi && vis[i][j] == 0) {\\n                        maxi = nums[i][j];\\n                        col = j;\\n                    }\\n                }\\n                vis[i][col] = 1;\\n                ult_max = max(ult_max, maxi);\\n            }\\n            max_sum += ult_max;\\n        }\\n        return max_sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int n = nums.size(), m = nums[0].size();\\n        vector<vector<int>> vis(n, vector<int>(m));\\n        int max_sum = 0;\\n        for(int t = 0; t < m; t++) {\\n            int ult_max = 0;\\n            for(int i = 0; i < n; i++) {\\n                int maxi = 0, col = 0;\\n                for(int j = 0; j < m; j++) {\\n                    if(nums[i][j] > maxi && vis[i][j] == 0) {\\n                        maxi = nums[i][j];\\n                        col = j;\\n                    }\\n                }\\n                vis[i][col] = 1;\\n                ult_max = max(ult_max, maxi);\\n            }\\n            max_sum += ult_max;\\n        }\\n        return max_sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521981,
                "title": "100-fast-and-memory-efficient-c-solution-sorting",
                "content": "## Complexity\\n- Time complexity: $$O(n*m)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n*m)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int score=0; int n= nums.size(); int m= nums[0].size();\\n        for (int i=0; i<n; i++){\\n            sort(nums[i].begin(),nums[i].end());\\n        }\\n        for (int i=0; i<m; i++){\\n            int maxi=0;\\n            for (int j=0; j<n; j++){\\n                maxi= max(maxi,nums[j][i]);\\n            }\\n            score+= maxi;\\n        }\\n        \\n        return score;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Sort",
                    "Sorting",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int score=0; int n= nums.size(); int m= nums[0].size();\\n        for (int i=0; i<n; i++){\\n            sort(nums[i].begin(),nums[i].end());\\n        }\\n        for (int i=0; i<m; i++){\\n            int maxi=0;\\n            for (int j=0; j<n; j++){\\n                maxi= max(maxi,nums[j][i]);\\n            }\\n            score+= maxi;\\n        }\\n        \\n        return score;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521707,
                "title": "python3-sorting-very-easy-to-understand-solution",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def matrixSum(self, nums: List[List[int]]) -> int:\\n        score=0\\n        \\n        for j in nums:\\n            j.sort()\\n            j.reverse()\\n        for i in range(len(nums[0])):\\n            cur_max=nums[0][i]\\n            for k in range(len(nums)):\\n                cur_max=max(cur_max,nums[k][i])\\n            #print(cur_max)\\n            score+=cur_max\\n        return score\\n            \\n            \\n            \\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def matrixSum(self, nums: List[List[int]]) -> int:\\n        score=0\\n        \\n        for j in nums:\\n            j.sort()\\n            j.reverse()\\n        for i in range(len(nums[0])):\\n            cur_max=nums[0][i]\\n            for k in range(len(nums)):\\n                cur_max=max(cur_max,nums[k][i])\\n            #print(cur_max)\\n            score+=cur_max\\n        return score\\n            \\n            \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521164,
                "title": "easy-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int n = nums.size();\\n        int m = nums[0].size();\\n        for(auto &k : nums){\\n            sort(k.begin(), k.end());\\n        }\\n        int ans = 0;\\n        for(int i = 0; i < m; i++){\\n            int maxm = -1;\\n            for(int j = 0; j < n; j++){\\n                maxm = max(maxm, nums[j][i]);\\n            }\\n            ans += maxm;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int n = nums.size();\\n        int m = nums[0].size();\\n        for(auto &k : nums){\\n            sort(k.begin(), k.end());\\n        }\\n        int ans = 0;\\n        for(int i = 0; i < m; i++){\\n            int maxm = -1;\\n            for(int j = 0; j < n; j++){\\n                maxm = max(maxm, nums[j][i]);\\n            }\\n            ans += maxm;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520927,
                "title": "easy-java-solution-prioritqueue",
                "content": "\\n- Time complexity: O(n*n)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n\\n      int count=0;\\n      int ans[]=new int[nums[0].length];\\n      for(int i=0;i<nums.length;i++)\\n      {\\n          PriorityQueue<Integer> q= new PriorityQueue<>();\\n          for(int j=0;j<nums[0].length;j++)\\n          {\\n              q.add(nums[i][j]);\\n          }\\n         \\n         for(int k=0;k<ans.length;k++)\\n         {\\n             int a=q.poll();\\n             if(ans[k]<a)\\n             {\\n                 ans[k]=a;\\n             }\\n         }\\n\\n      }\\n      for(int n:ans) count+=n;  \\n      return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n\\n      int count=0;\\n      int ans[]=new int[nums[0].length];\\n      for(int i=0;i<nums.length;i++)\\n      {\\n          PriorityQueue<Integer> q= new PriorityQueue<>();\\n          for(int j=0;j<nums[0].length;j++)\\n          {\\n              q.add(nums[i][j]);\\n          }\\n         \\n         for(int k=0;k<ans.length;k++)\\n         {\\n             int a=q.poll();\\n             if(ans[k]<a)\\n             {\\n                 ans[k]=a;\\n             }\\n         }\\n\\n      }\\n      for(int n:ans) count+=n;  \\n      return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520856,
                "title": "intuitive-solution",
                "content": "# Intuition\\nRead this line again and again...\\nReally important\\n\"From each row in the matrix, select the largest number and remove it. In the case of a tie, it does not matter which number is chosen.\"\\n\\n# Approach\\nWe sorted the array as we always needed largest element of the row at the first location and we read the question carefully it is written that \"From each row in the matrix, select the largest number and remove it. In the case of a tie, it does not matter which number is chosen.\" ROW so i sorted and then reverse the array so i can have a decreasing sorted array which helped me. \\n# Complexity\\n- Time complexity:\\nO(N^2 log N)\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n        int max_length=0;\\n        for(int []i:nums) {\\n            max_length = Math.max(i.length, max_length);\\n            Arrays.sort(i);\\n            reverse(i);\\n        }\\n        int score=0;\\n        for(int i=0;i<max_length;i++){\\n            int num=0;\\n            for(int j=0;j<nums.length;j++) {\\n                if (nums[j].length > i) {\\n                    num = Math.max(nums[j][i], num);\\n                }\\n            }\\n            score += num;\\n        }\\n        return score;\\n    }\\n    public static void reverse(int[] arr){\\n        int i=0;\\n        int j=arr.length-1;\\n        while(i<=j){\\n            int temp=arr[i];\\n            arr[i]=arr[j];\\n            arr[j]=temp;\\n            i++;\\n            j--;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n        int max_length=0;\\n        for(int []i:nums) {\\n            max_length = Math.max(i.length, max_length);\\n            Arrays.sort(i);\\n            reverse(i);\\n        }\\n        int score=0;\\n        for(int i=0;i<max_length;i++){\\n            int num=0;\\n            for(int j=0;j<nums.length;j++) {\\n                if (nums[j].length > i) {\\n                    num = Math.max(nums[j][i], num);\\n                }\\n            }\\n            score += num;\\n        }\\n        return score;\\n    }\\n    public static void reverse(int[] arr){\\n        int i=0;\\n        int j=arr.length-1;\\n        while(i<=j){\\n            int temp=arr[i];\\n            arr[i]=arr[j];\\n            arr[j]=temp;\\n            i++;\\n            j--;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520838,
                "title": "c-sorting-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n      sort(nums.begin(),nums.end());\\n        vector<vector<int>> n;\\n        for(auto it: nums){\\n            sort(it.begin(),it.end());\\n            vector<int> ds;\\n            for(auto i: it){\\n                ds.push_back(i);\\n            }\\n            n.push_back(ds);\\n        }\\n        int res=0;\\n       for(int i=0;i<nums[0].size();i++){\\n            vector<int> ans;\\n            for(int j=0;j<nums.size();j++){\\n                ans.push_back(n[j][i]);\\n            }\\n            sort(ans.begin(),ans.end());\\n            res+=ans[ans.size()-1];\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n      sort(nums.begin(),nums.end());\\n        vector<vector<int>> n;\\n        for(auto it: nums){\\n            sort(it.begin(),it.end());\\n            vector<int> ds;\\n            for(auto i: it){\\n                ds.push_back(i);\\n            }\\n            n.push_back(ds);\\n        }\\n        int res=0;\\n       for(int i=0;i<nums[0].size();i++){\\n            vector<int> ans;\\n            for(int j=0;j<nums.size();j++){\\n                ans.push_back(n[j][i]);\\n            }\\n            sort(ans.begin(),ans.end());\\n            res+=ans[ans.size()-1];\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520545,
                "title": "python3-solution-one-line",
                "content": "\\n\\n```\\nclass Solution:\\n    def matrixSum(self, nums: List[List[int]]) -> int:\\n        return sum(map(max,zip(*map(sorted,nums))))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def matrixSum(self, nums: List[List[int]]) -> int:\\n        return sum(map(max,zip(*map(sorted,nums))))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520525,
                "title": "well-explained-easy-to-understand-c-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf we sort all the rows of the matrix then, the last value at the last column of each matrix will be the max value of that row. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Sort Each Row \\n- Traverse from the last column to the first column and find out the find out the max value of that column. Add it to the score.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n^2)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int m=nums.size();\\n        int n=nums[0].size();\\n        int score=0;\\n        for(int i=0;i<m;i++){\\n            sort(nums[i].begin(),nums[i].end());\\n        }\\n        for(int i=n-1;i>=0;i--){\\n            int maxi=INT_MIN;\\n            for(int j=0;j<m;j++){\\n                if(nums[j][i]>maxi){\\n                    maxi=nums[j][i];\\n                }\\n            }\\n            score+=maxi;\\n        }\\n        return score;\\n    }\\n};\\n```\\n# Please Upvote if it was helpful\\u2B06\\uFE0F",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int m=nums.size();\\n        int n=nums[0].size();\\n        int score=0;\\n        for(int i=0;i<m;i++){\\n            sort(nums[i].begin(),nums[i].end());\\n        }\\n        for(int i=n-1;i>=0;i--){\\n            int maxi=INT_MIN;\\n            for(int j=0;j<m;j++){\\n                if(nums[j][i]>maxi){\\n                    maxi=nums[j][i];\\n                }\\n            }\\n            score+=maxi;\\n        }\\n        return score;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520458,
                "title": "why-we-need-to-sort-easy-explanation",
                "content": "The approach is simple but only thing people are confused is why we have to sort? can\\'t we just iterate through each row for each column.\\n\\nExplanation : \\nThe reason for sorting is because we have to select max value from each row instead of just iterating through each row and column randomly. \\n\\n Suppose we have \\n\\n 7 4 6\\n 3 2 1\\n 9 8 7\\n\\n1st iteration we have to select Max(7,3,9) because these are the largest numbers in each row.\\n2nd iteration we have to select Max(6,2,8) because these are the largest numbers in each row after removing (7,3,9) in first iteration .\\nIf you carefully observe here 6 is located at index - 2 but ( 2 and 8) are located at index 1 so that\\'s why we have to sort them so that all maximum numbers will be together.\\n\\nAfter sorting : \\n4 6 7\\n1 2 3\\n7 8 9 \\n\\nAfter sorting if we observe all Max pairs are together \\nMAX(7,3,9)\\nMAX(6,2,8)\\nMAX(4,1,7)\\n\\n# Code\\n```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n\\n       // We need to sort it first - Explanation is given above\\n       for(int[] i : nums)\\n           Arrays.sort(i);\\n\\n        int total = 0;\\n        for(int col = 0; col < nums[0].length; col++){\\n            int max = Integer.MIN_VALUE;\\n            for(int row = 0; row < nums.length; row++){\\n                max = Math.max(nums[row][col],max);\\n            }\\n            total += max;\\n        }\\n        \\n        return total;\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n\\n       // We need to sort it first - Explanation is given above\\n       for(int[] i : nums)\\n           Arrays.sort(i);\\n\\n        int total = 0;\\n        for(int col = 0; col < nums[0].length; col++){\\n            int max = Integer.MIN_VALUE;\\n            for(int row = 0; row < nums.length; row++){\\n                max = Math.max(nums[row][col],max);\\n            }\\n            total += max;\\n        }\\n        \\n        return total;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520440,
                "title": "sort-and-sum",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int ans = 0, n = size(nums), m = size(nums[0]);\\n        for(auto&e: nums){\\n            sort(begin(e),end(e));\\n        }\\n        for(int i=0; i<m; ++i){\\n            int mx = -1e9;\\n            for(int j=0; j<n; ++j){\\n                mx = max(mx,nums[j][i]);\\n            }\\n            ans += mx;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Sort",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int ans = 0, n = size(nums), m = size(nums[0]);\\n        for(auto&e: nums){\\n            sort(begin(e),end(e));\\n        }\\n        for(int i=0; i<m; ++i){\\n            int mx = -1e9;\\n            for(int j=0; j<n; ++j){\\n                mx = max(mx,nums[j][i]);\\n            }\\n            ans += mx;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520369,
                "title": "c-easy-solution-for-beginner-o-n-2-time-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:o(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:o(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        for(int i=0;i<nums.size();i++){\\n            sort(nums[i].begin(),nums[i].end(),greater<int>());\\n        }\\n        int ans=0;\\n        for(int i=0;i<nums[0].size();i++){\\n            int temp=0;\\n           for(int j=0;j<nums.size();j++){\\n               temp=max(temp,nums[j][i]);\\n           }\\n            ans=ans+temp;\\n        }\\n       return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        for(int i=0;i<nums.size();i++){\\n            sort(nums[i].begin(),nums[i].end(),greater<int>());\\n        }\\n        int ans=0;\\n        for(int i=0;i<nums[0].size();i++){\\n            int temp=0;\\n           for(int j=0;j<nums.size();j++){\\n               temp=max(temp,nums[j][i]);\\n           }\\n            ans=ans+temp;\\n        }\\n       return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520358,
                "title": "super-easy-to-understand-c",
                "content": "\\n**If you like my solution please upvote!**\\n```\\nint matrixSum(vector<vector<int>>& v) {\\n        \\n        int n = v.size();\\n        int m = v[0].size();\\n        int ans = 0;\\n       for(int i =0; i<n; i++)\\n           sort(v[i].begin(), v[i].end());   // Sorting each row\\n       \\n            for(int j =m-1; j>=0; j--) //traversing from the last column\\n            {\\n                int local =-1e9; // stores maximum of each column\\n                 for(int i =0; i<n ; i++)\\n                 {\\n                     local = max(local, v[i][j]);\\n                 }\\n                ans+=local;  //Adding the maximum of each row to answer\\n            }\\n            \\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nint matrixSum(vector<vector<int>>& v) {\\n        \\n        int n = v.size();\\n        int m = v[0].size();\\n        int ans = 0;\\n       for(int i =0; i<n; i++)\\n           sort(v[i].begin(), v[i].end());   // Sorting each row\\n       \\n            for(int j =m-1; j>=0; j--) //traversing from the last column\\n            {\\n                int local =-1e9; // stores maximum of each column\\n                 for(int i =0; i<n ; i++)\\n                 {\\n                     local = max(local, v[i][j]);\\n                 }\\n                ans+=local;  //Adding the maximum of each row to answer\\n            }\\n            \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3520346,
                "title": "python-sort",
                "content": "```\\nclass Solution:\\n    def matrixSum(self, nums: List[List[int]]) -> int:\\n        \\n        for row in nums:\\n            row.sort()\\n        ans = 0\\n        for i in range(len(nums[0]) - 1, -1, -1):\\n            current_ans = float(\\'-inf\\')\\n            for j in range(len(nums)):\\n                current_ans = max(current_ans, nums[j][i])\\n            ans += current_ans\\n        return ans\\n```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def matrixSum(self, nums: List[List[int]]) -> int:\\n        \\n        for row in nums:\\n            row.sort()\\n        ans = 0\\n        for i in range(len(nums[0]) - 1, -1, -1):\\n            current_ans = float(\\'-inf\\')\\n            for j in range(len(nums)):\\n                current_ans = max(current_ans, nums[j][i])\\n            ans += current_ans\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520345,
                "title": "very-easy-java-code-with-explaination-for-beginners",
                "content": "# Algorithm Steps\\nAlgorithm for the matrixSum method in the Solution class:\\n\\n1. Create a method called \"matrixSum\" that takes a 2D integer array called \"nums\" as input and returns an integer.\\n2. For each row \"num\" in the \"nums\" array, do the following:\\n   a. Sort the elements in the row using the \"Arrays.sort\" method.\\n3. Initialize an integer variable called \"res\" to 0.\\n4. For each column in the \"nums\" array, do the following:\\n   a. Initialize an integer variable called \"max\" to the minimum value of an integer using the constant \"Integer.MIN_VALUE\".\\n   b. For each row in the \"nums\" array, do the following:\\n      i. Get the element at the current row and column using the index notation \"nums[j][i]\".\\n      ii. If the element is greater than \"max\", set \"max\" to the value of the element.\\n   c. Add the value of \"max\" to the \"res\" variable.\\n5. After processing all the columns in the \"nums\" array, return the value of \"res\" as the sum of the maximum elements in each column.\\n\\nOverall, this algorithm finds the maximum element in each column of a 2D integer array, adds up all the maximum elements, and returns the sum as the result. The algorithm achieves this by sorting each row in the array first, and then iterating through each column and finding the maximum element in that column.\\n\\n# Code\\n```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n        for (int[] num : nums) {\\n            Arrays.sort(num);\\n        }\\n        int res = 0;\\n        for(int i = nums[0].length-1; i>=0;i--){\\n            int max = Integer.MIN_VALUE;\\n            for(int j = 0; j<nums.length; j++){\\n                max = Math.max(max,nums[j][i]);\\n            }\\n            res+=max;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n        for (int[] num : nums) {\\n            Arrays.sort(num);\\n        }\\n        int res = 0;\\n        for(int i = nums[0].length-1; i>=0;i--){\\n            int max = Integer.MIN_VALUE;\\n            for(int j = 0; j<nums.length; j++){\\n                max = Math.max(max,nums[j][i]);\\n            }\\n            res+=max;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520287,
                "title": "simple-java-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n       for(int num[]:nums){\\n           Arrays.sort(num);\\n       }\\n      int ans=0;\\n       \\n           for(int i=0;i<nums[0].length;i++){\\n                int max=Integer.MIN_VALUE;\\n               for(int j=0;j<nums.length;j++){\\n                    max=Math.max(max,nums[j][i]) ; \\n               }\\n               ans=ans+max;\\n            \\n          }\\n        return ans;\\n         \\n         }\\n}\\n       // 1 2 7   00    01 \\n       // 2 4 6   10    11\\n       // 3 5 6   20    21\\n       // 1 2 3   30   31\\n    \\n    \\n   \\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n       for(int num[]:nums){\\n           Arrays.sort(num);\\n       }\\n      int ans=0;\\n       \\n           for(int i=0;i<nums[0].length;i++){\\n                int max=Integer.MIN_VALUE;\\n               for(int j=0;j<nums.length;j++){\\n                    max=Math.max(max,nums[j][i]) ; \\n               }\\n               ans=ans+max;\\n            \\n          }\\n        return ans;\\n         \\n         }\\n}\\n       // 1 2 7   00    01 \\n       // 2 4 6   10    11\\n       // 3 5 6   20    21\\n       // 1 2 3   30   31\\n    \\n    \\n   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520243,
                "title": "c-easy",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int r=nums.size(), c=nums[0].size();\\n        int ans=0;\\n        \\n        for(int i=0;i<r;i++){\\n           sort(nums[i].begin(),nums[i].end());\\n        }\\n        for(int j=0;j<c;j++){\\n            int val=0;\\n            for(int i=0;i<r;i++){\\n                val=max(val,nums[i][j]);\\n            }\\n            ans += val;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int r=nums.size(), c=nums[0].size();\\n        int ans=0;\\n        \\n        for(int i=0;i<r;i++){\\n           sort(nums[i].begin(),nums[i].end());\\n        }\\n        for(int j=0;j<c;j++){\\n            int val=0;\\n            for(int i=0;i<r;i++){\\n                val=max(val,nums[i][j]);\\n            }\\n            ans += val;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520218,
                "title": "c-easy-and-simple-solution",
                "content": "***Guy\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE. By doing that it motivate\\'s me to create more better post like this \\u270D\\uFE0F***\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int score=0;\\n        \\n        \\n        for(int i=0;i<nums.size();i++){\\n            sort(nums[i].begin(),nums[i].end());\\n        }\\n        for(int i=0;i<nums[0].size();i++){\\n            int maxi=0;\\n            for(int j=0;j<nums.size();j++){\\n                \\n                maxi=max(maxi,nums[j][i]);\\n            }\\n            \\n            score+=maxi;\\n        }\\n        return score;\\n    }\\n};\\n```\\n***Guy\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE. By doing that it motivate\\'s me to create more better post like this \\u270D\\uFE0F***",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int score=0;\\n        \\n        \\n        for(int i=0;i<nums.size();i++){\\n            sort(nums[i].begin(),nums[i].end());\\n        }\\n        for(int i=0;i<nums[0].size();i++){\\n            int maxi=0;\\n            for(int j=0;j<nums.size();j++){\\n                \\n                maxi=max(maxi,nums[j][i]);\\n            }\\n            \\n            score+=maxi;\\n        }\\n        return score;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4102550,
                "title": "track-the-priority-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n make the map with int and priority_queue \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\npriority_queue for get the maximum always from the each new time .\\n# Complexity\\n- Time complexity:O(n*n*log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n*n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        unordered_map<int,priority_queue<int>>mp;\\n        int n=nums.size(),m=nums[0].size();\\n        for(int i=0;i<n;++i)\\n        {\\n            for(auto it:nums[i])\\n            {\\n                mp[i].push(it);\\n            }\\n        }\\n      \\n        int sum=0;\\n        while(m--)\\n        {     \\n            int maxi=INT_MIN;\\n            for(auto  &it:mp)\\n            {\\n                int cur=it.second.top();\\n                it.second.pop();\\n                maxi=max(maxi,cur);\\n            }\\n            sum+=maxi;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        unordered_map<int,priority_queue<int>>mp;\\n        int n=nums.size(),m=nums[0].size();\\n        for(int i=0;i<n;++i)\\n        {\\n            for(auto it:nums[i])\\n            {\\n                mp[i].push(it);\\n            }\\n        }\\n      \\n        int sum=0;\\n        while(m--)\\n        {     \\n            int maxi=INT_MIN;\\n            for(auto  &it:mp)\\n            {\\n                int cur=it.second.top();\\n                it.second.pop();\\n                maxi=max(maxi,cur);\\n            }\\n            sum+=maxi;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4101974,
                "title": "sum-in-a-matrix",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    /**\\n     * @param Integer[][] $nums\\n     * @return Integer\\n     */\\n    function matrixSum($nums)\\n    {\\n        $totals = [];\\n        foreach ($nums as $_k => $subnum) {\\n            rsort($subnum);\\n            $i = 0;\\n            while ($i < count($subnum)) {\\n                if (!isset($totals[$i]) || $subnum[$i] >= $totals[$i]) {\\n                    $totals[$i] = $subnum[$i];\\n                }\\n                $i++;\\n            }\\n        }\\n        return array_sum($totals);\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nclass Solution {\\n\\n    /**\\n     * @param Integer[][] $nums\\n     * @return Integer\\n     */\\n    function matrixSum($nums)\\n    {\\n        $totals = [];\\n        foreach ($nums as $_k => $subnum) {\\n            rsort($subnum);\\n            $i = 0;\\n            while ($i < count($subnum)) {\\n                if (!isset($totals[$i]) || $subnum[$i] >= $totals[$i]) {\\n                    $totals[$i] = $subnum[$i];\\n                }\\n                $i++;\\n            }\\n        }\\n        return array_sum($totals);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4080394,
                "title": "easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int row = nums.size();\\n        int col = nums[0].size();\\n\\n        for(int i=0;i<row;i++) {\\n            sort(nums[i].begin(),nums[i].end(),greater<int>());\\n        }\\n\\n        int score = 0;\\n\\n        for(int i=0;i<col;i++) {\\n            priority_queue<int> maxHeap;\\n\\n            for(int j=0;j<row;j++) {\\n                maxHeap.push(nums[j][i]);\\n            }\\n\\n            int x = maxHeap.top();\\n            score += x;\\n        }\\n\\n        return score;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int row = nums.size();\\n        int col = nums[0].size();\\n\\n        for(int i=0;i<row;i++) {\\n            sort(nums[i].begin(),nums[i].end(),greater<int>());\\n        }\\n\\n        int score = 0;\\n\\n        for(int i=0;i<col;i++) {\\n            priority_queue<int> maxHeap;\\n\\n            for(int j=0;j<row;j++) {\\n                maxHeap.push(nums[j][i]);\\n            }\\n\\n            int x = maxHeap.top();\\n            score += x;\\n        }\\n\\n        return score;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4076482,
                "title": "using-priority-queue",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        vector<priority_queue<int>> pq;\\n\\n        for(auto it: nums)\\n        {\\n            priority_queue<int> temp;\\n            for(auto ix: it)\\n            {\\n                temp.push(ix);\\n            }\\n            pq.push_back(temp);\\n        }\\n\\n        int ans = 0;\\n        int n = nums[0].size();\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            int mx = INT_MIN;\\n            for(auto &it: pq)\\n            {\\n                int top = it.top();\\n                mx = max(mx, top);\\n                it.pop();\\n            }\\n            ans += mx;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        vector<priority_queue<int>> pq;\\n\\n        for(auto it: nums)\\n        {\\n            priority_queue<int> temp;\\n            for(auto ix: it)\\n            {\\n                temp.push(ix);\\n            }\\n            pq.push_back(temp);\\n        }\\n\\n        int ans = 0;\\n        int n = nums[0].size();\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            int mx = INT_MIN;\\n            for(auto &it: pq)\\n            {\\n                int top = it.top();\\n                mx = max(mx, top);\\n                it.pop();\\n            }\\n            ans += mx;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4068593,
                "title": "sort-and-iterate",
                "content": "# Intuition\\nSort each row\\n# Approach\\nSort each row and perform the operations column by columns. No need to change the actual array in any way. For example, there is no need to find the max cell and set it to zero or something.\\n\\n# Complexity\\n- Time complexity:\\nAssume nums has n rows and m columns THEN: O(n*mlogm + n*m)\\n- Space complexity:\\nO(1), note python sorting (Tim sort) is in place.\\n# Code\\n```\\nclass Solution:\\n    def matrixSum(self, nums: List[List[int]]) -> int:\\n\\n        # Assume nums has n rows and m columns\\n        # T: O(n*mlogm + n*m) | S: O(1)\\n        def initial(nums):\\n\\n            # sort every row\\n            for row in nums:\\n                row.sort(reverse=True)\\n\\n            # iterate through each column form left to right\\n            res = 0\\n            for col in range(0, len(nums[0])):\\n                \\n                maxVal = -1\\n                for row in range(0, len(nums)):\\n                    targetCell = nums[row][col]\\n                    maxVal = max(maxVal, targetCell)\\n\\n                res += maxVal\\n\\n            return res\\n\\n        return initial(nums)\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def matrixSum(self, nums: List[List[int]]) -> int:\\n\\n        # Assume nums has n rows and m columns\\n        # T: O(n*mlogm + n*m) | S: O(1)\\n        def initial(nums):\\n\\n            # sort every row\\n            for row in nums:\\n                row.sort(reverse=True)\\n\\n            # iterate through each column form left to right\\n            res = 0\\n            for col in range(0, len(nums[0])):\\n                \\n                maxVal = -1\\n                for row in range(0, len(nums)):\\n                    targetCell = nums[row][col]\\n                    maxVal = max(maxVal, targetCell)\\n\\n                res += maxVal\\n\\n            return res\\n\\n        return initial(nums)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4068470,
                "title": "used-sorting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n\\n# Complexity\\n- Time complexity:\\nThe sorting has a time complexity of O(m * log(m)), where \\'m\\' is the length of the subarray.\\nyou have \\'n\\' subarrays (where \\'n\\' is the length of the nums array), the total time complexity for this part is O(n * m * log(m));\\nFinding Maximum Values: iterate over the columns (i.e., the elements in each subarray) and find the maximum value for each column. This part has a time complexity of O(m * n) because you\\'re iterating over all \\'n\\' subarrays and looking at each of their \\'m\\' elements once\\n\\noverall: O(n * m * log(m))\\n\\n- Space complexity:\\nusing some additional memory to keep track of the maximum values for each column. Specifically, we\\'re using an array of length \\'m\\' to store the maximum values.\\nO(m)\\n\\n# Code\\n```\\n/**\\n * @param {number[][]} nums\\n * @return {number}\\n */\\nvar matrixSum = function(nums) {\\n    \\n    if(!Array.isArray(nums) && nums.length === 0 ) return 0;\\n    \\n    let finalscore = 0;\\n\\n    nums.forEach((item) => {\\n        item.sort((a,b) => b - a)\\n    })\\n    for(let i = 0; i < nums[0].length; i++ ){\\n        finalscore += Math.max(...nums.map((item) => item[i]));\\n    }\\n    return finalscore;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} nums\\n * @return {number}\\n */\\nvar matrixSum = function(nums) {\\n    \\n    if(!Array.isArray(nums) && nums.length === 0 ) return 0;\\n    \\n    let finalscore = 0;\\n\\n    nums.forEach((item) => {\\n        item.sort((a,b) => b - a)\\n    })\\n    for(let i = 0; i < nums[0].length; i++ ){\\n        finalscore += Math.max(...nums.map((item) => item[i]));\\n    }\\n    return finalscore;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4064369,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n    int s=0;\\n    for(int i=0;i<nums.length;i++){\\n        Arrays.sort(nums[i]);\\n    }\\n    for(int i=0;i<nums[0].length;i++){\\n        int m=0;\\n        for(int j=0;j<nums.length;j++){\\n            m=Math.max(m,nums[j][i]);\\n        }\\n        s+=m;\\n    }\\n    \\n\\n    return s;\\n    }    \\n    }\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n    int s=0;\\n    for(int i=0;i<nums.length;i++){\\n        Arrays.sort(nums[i]);\\n    }\\n    for(int i=0;i<nums[0].length;i++){\\n        int m=0;\\n        for(int j=0;j<nums.length;j++){\\n            m=Math.max(m,nums[j][i]);\\n        }\\n        s+=m;\\n    }\\n    \\n\\n    return s;\\n    }    \\n    }\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4047126,
                "title": "java-easy-solution-beat-90-10ms-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n        int sum=0;\\n        for(int [] arr:nums){\\n            Arrays.sort(arr);\\n          \\n        }\\n      \\n        int max=Integer.MIN_VALUE;\\n        int c=nums[0].length-1;\\n        for(int i=c;i>=0;i--){\\n            for(int j=0;j<nums.length;j++){\\n                max=Math.max(max,nums[j][i]);\\n\\n            }\\n            sum+=max;\\n            max=Integer.MIN_VALUE;\\n        }\\n        return sum;\\n     \\n     \\n      \\n    }\\n}\\n\\n \\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n        int sum=0;\\n        for(int [] arr:nums){\\n            Arrays.sort(arr);\\n          \\n        }\\n      \\n        int max=Integer.MIN_VALUE;\\n        int c=nums[0].length-1;\\n        for(int i=c;i>=0;i--){\\n            for(int j=0;j<nums.length;j++){\\n                max=Math.max(max,nums[j][i]);\\n\\n            }\\n            sum+=max;\\n            max=Integer.MIN_VALUE;\\n        }\\n        return sum;\\n     \\n     \\n      \\n    }\\n}\\n\\n \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4046323,
                "title": "simple-logic-just-sort-and-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(R*C)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int r=nums.size();\\n        int c=nums[0].size();\\n        int i,j;\\n        int max=0;\\n        int k;\\n        int m;\\n        for(i=0;i<r;i++){\\n           sort(nums[i].begin(),nums[i].end());\\n        }\\n        \\n       for(i=0;i<c;i++){\\n           m=0;\\n           for(j=0;j<r;j++){\\n               \\n               if(m<nums[j][i]){\\n                   m=nums[j][i];\\n               }\\n           }\\n           max=max+m;\\n       }\\n\\n        return max;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int r=nums.size();\\n        int c=nums[0].size();\\n        int i,j;\\n        int max=0;\\n        int k;\\n        int m;\\n        for(i=0;i<r;i++){\\n           sort(nums[i].begin(),nums[i].end());\\n        }\\n        \\n       for(i=0;i<c;i++){\\n           m=0;\\n           for(j=0;j<r;j++){\\n               \\n               if(m<nums[j][i]){\\n                   m=nums[j][i];\\n               }\\n           }\\n           max=max+m;\\n       }\\n\\n        return max;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4040256,
                "title": "simple-solution-with-o-1-space-complexity",
                "content": "# Intuition\\nSort all the rows seperately of the matrix\\n# Approach\\nOnce the rows are sorted then chooose the max from each column and add it to total\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n\\n        int rowSize = nums.size();\\n        int colSize = nums[0].size();\\n\\n        for(int row=0;row<nums.size();row++)\\n        {\\n            sort(nums[row].begin(),nums[row].end());\\n        }\\n        int total =0;\\n        int max =INT_MIN;\\n        for(int col=0;col<colSize;col++)\\n        {\\n            max =INT_MIN;\\n            for(int row=0;row<rowSize;row++)\\n            {\\n                if (nums[row][col] >max )\\n                {\\n                    max = nums[row][col];\\n                }\\n            }\\n            total = total + max;\\n\\n        }\\n        return total;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n\\n        int rowSize = nums.size();\\n        int colSize = nums[0].size();\\n\\n        for(int row=0;row<nums.size();row++)\\n        {\\n            sort(nums[row].begin(),nums[row].end());\\n        }\\n        int total =0;\\n        int max =INT_MIN;\\n        for(int col=0;col<colSize;col++)\\n        {\\n            max =INT_MIN;\\n            for(int row=0;row<rowSize;row++)\\n            {\\n                if (nums[row][col] >max )\\n                {\\n                    max = nums[row][col];\\n                }\\n            }\\n            total = total + max;\\n\\n        }\\n        return total;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4034494,
                "title": "java-easy-solution-beats-upto-65-good-luck",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n        for(int i=0;i<nums.length;i++){\\n            Arrays.sort(nums[i]);\\n        }\\n        int score = 0;\\n        for(int i=0;i<nums[0].length;i++){\\n            int max = Integer.MIN_VALUE;\\n            for(int j=0;j<nums.length;j++){\\n                max = Math.max(max,nums[j][nums[0].length-i-1]);\\n            }\\n            score += max;\\n        }\\n        return score;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n        for(int i=0;i<nums.length;i++){\\n            Arrays.sort(nums[i]);\\n        }\\n        int score = 0;\\n        for(int i=0;i<nums[0].length;i++){\\n            int max = Integer.MIN_VALUE;\\n            for(int j=0;j<nums.length;j++){\\n                max = Math.max(max,nums[j][nums[0].length-i-1]);\\n            }\\n            score += max;\\n        }\\n        return score;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4029492,
                "title": "very-simple-easy-and-concise-c-sol",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        for(int i=0;i<nums.size();i++){\\n            sort(nums[i].begin(),nums[i].end());\\n        }\\n        int score=0;\\n        for(int i=0;i<nums[0].size();i++){\\n            int val=0;\\n            for(int j=0;j<nums.size();j++){\\n                val=max(val,nums[j][i]);\\n            }\\n            score+=val;\\n        }\\n        return score;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        for(int i=0;i<nums.size();i++){\\n            sort(nums[i].begin(),nums[i].end());\\n        }\\n        int score=0;\\n        for(int i=0;i<nums[0].size();i++){\\n            int val=0;\\n            for(int j=0;j<nums.size();j++){\\n                val=max(val,nums[j][i]);\\n            }\\n            score+=val;\\n        }\\n        return score;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4022350,
                "title": "rather-dumb-solution",
                "content": "# Intuition\\nPriority queue, I want to put everything into priority queue.\\n\\n# Approach\\nTurn each row of the matrix into priority queue. Next, for each column, get top of priority queue, keep the local column maximum. At the end of the loop, add the local column maximum to answer.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nFirst loop will take $$O(i*j=N)$$\\n\\nThe second loop is a little bit tricky,\\n\\nIt will iterate through j column, each column has i rows, but since we\\'re using priority queue, the access of largest number is $$O(1)$$, so I think the complexity is still $$O(i*j=N)$$\\n\\nSo overall the complexity is $$O(2N) = O(N)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#include<algorithm>\\n\\nclass Solution {\\npublic:\\n    vector<priority_queue<int>> v;\\n    int matrixSum(vector<vector<int>>& nums) {\\n        for(int i = 0; i < nums.size(); i++) {\\n            priority_queue<int> pq;\\n            v.push_back(pq);\\n            for(int j = 0; j < nums[i].size(); j++) v[i].push(nums[i][j]);\\n        }\\n        int ans = 0;\\n        for(int k = 0; k < nums[0].size(); k++) {\\n            int colMax = 0;\\n            for(int i = 0; i < v.size(); i++) {\\n                colMax = max(colMax, v[i].top());\\n                v[i].pop();\\n            }\\n            ans += colMax;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include<algorithm>\\n\\nclass Solution {\\npublic:\\n    vector<priority_queue<int>> v;\\n    int matrixSum(vector<vector<int>>& nums) {\\n        for(int i = 0; i < nums.size(); i++) {\\n            priority_queue<int> pq;\\n            v.push_back(pq);\\n            for(int j = 0; j < nums[i].size(); j++) v[i].push(nums[i][j]);\\n        }\\n        int ans = 0;\\n        for(int k = 0; k < nums[0].size(); k++) {\\n            int colMax = 0;\\n            for(int i = 0; i < v.size(); i++) {\\n                colMax = max(colMax, v[i].top());\\n                v[i].pop();\\n            }\\n            ans += colMax;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4019562,
                "title": "typescript-javascript-solution",
                "content": "```ts\\nfunction matrixSum(nums: number[][]): number {\\n    nums.forEach(arr => arr.sort((a, b) => b - a));\\n    let sum: number = 0;\\n    const length: number = nums[0].length;\\n    for(let i = 0; i < length; i++){\\n        const setNums: Set<number> = new Set();\\n        for(let num of nums) setNums.add(num[i]);\\n        sum += Math.max(...setNums);\\n    }\\n    return sum;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```ts\\nfunction matrixSum(nums: number[][]): number {\\n    nums.forEach(arr => arr.sort((a, b) => b - a));\\n    let sum: number = 0;\\n    const length: number = nums[0].length;\\n    for(let i = 0; i < length; i++){\\n        const setNums: Set<number> = new Set();\\n        for(let num of nums) setNums.add(num[i]);\\n        sum += Math.max(...setNums);\\n    }\\n    return sum;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3992170,
                "title": "java-easy-sorting-apporach",
                "content": "```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n        int sum=0;\\n         for(int i=0;i<nums.length;i++)\\n             {\\n                 Arrays.sort(nums[i]);\\n             }\\n        for(int i=0;i<nums[0].length;i++){\\n            int max=0;\\n            for(int j=0;j<nums.length;j++)\\n            {\\n                max=Math.max(max,nums[j][i]);\\n            }\\n            sum+=max;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n        int sum=0;\\n         for(int i=0;i<nums.length;i++)\\n             {\\n                 Arrays.sort(nums[i]);\\n             }\\n        for(int i=0;i<nums[0].length;i++){\\n            int max=0;\\n            for(int j=0;j<nums.length;j++)\\n            {\\n                max=Math.max(max,nums[j][i]);\\n            }\\n            sum+=max;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3990067,
                "title": "beginner-friendly-best-java-solution-beats-100-in-runtime-fastest",
                "content": "# Code\\n```\\nimport java.util.Arrays;\\n\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n        for(int[] eachRow: nums){\\n            Arrays.sort(eachRow);\\n        }\\n        int rows = nums.length;\\n        int cols = nums[0].length;\\n        return helper_matrixSum(nums, rows, cols);\\n    }\\n\\n    int helper_matrixSum(int[][] nums, int rows, int cols){\\n        int score = 0;\\n        for(int i=0; i<cols; i++){\\n            int maxii = -1;\\n            for(int j=0; j<rows; j++){\\n                maxii = Math.max(maxii, nums[j][i]);\\n            }\\n            score += maxii;\\n        }\\n        return score;\\n    }\\n}\\n        \\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.Arrays;\\n\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n        for(int[] eachRow: nums){\\n            Arrays.sort(eachRow);\\n        }\\n        int rows = nums.length;\\n        int cols = nums[0].length;\\n        return helper_matrixSum(nums, rows, cols);\\n    }\\n\\n    int helper_matrixSum(int[][] nums, int rows, int cols){\\n        int score = 0;\\n        for(int i=0; i<cols; i++){\\n            int maxii = -1;\\n            for(int j=0; j<rows; j++){\\n                maxii = Math.max(maxii, nums[j][i]);\\n            }\\n            score += maxii;\\n        }\\n        return score;\\n    }\\n}\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3984794,
                "title": "the-easiest-solution-that-beats-90-of-typescript-users-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction matrixSum(nums: number[][]): number {\\n  const arrayLength = nums.length;\\n\\n  for (let i = 0; i < arrayLength; i++) {\\n    nums[i] = nums[i].sort((a, b) => a - b);\\n  }\\n\\n  let sum = 0;\\n\\n  while (nums[arrayLength - 1].length !== 0) {\\n    let max = 0;\\n    for (let i = 0; i < arrayLength; i++) {\\n      const lastElement = nums[i].pop();\\n\\n      if (lastElement > max) max = lastElement;\\n    }\\n\\n    sum += max;\\n  }\\n\\n  return sum;\\n}\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction matrixSum(nums: number[][]): number {\\n  const arrayLength = nums.length;\\n\\n  for (let i = 0; i < arrayLength; i++) {\\n    nums[i] = nums[i].sort((a, b) => a - b);\\n  }\\n\\n  let sum = 0;\\n\\n  while (nums[arrayLength - 1].length !== 0) {\\n    let max = 0;\\n    for (let i = 0; i < arrayLength; i++) {\\n      const lastElement = nums[i].pop();\\n\\n      if (lastElement > max) max = lastElement;\\n    }\\n\\n    sum += max;\\n  }\\n\\n  return sum;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3981341,
                "title": "sorting-c-jai-shree-ram",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n1)Initialize a variable score to keep track of your total score.\\n\\n2)Loop until the matrix nums is not empty:\\n\\n3)For each row, find the maximum number. Since it doesn\\'t matter which number you choose in case of a tie, you can use any method to find the maximum, such as sorting the row or using a priority queue.\\n4)Remove the maximum number from each row.\\nAfter processing all rows, identify the maximum number among the removed numbers. Add this maximum to your score.\\n\\n5)Repeat steps 2 and 3 until all rows are empty.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe problem revolves around selecting the largest available numbers smartly in order to maximize the final score. By always choosing the maximum in each step, you ensure that you\\'re adding the largest possible numbers to your score. This intuition leads to a simple and efficient solution for the problem.\\n\\n# Complexity\\n- Time complexity:O(n * m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(m)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n\\n        int n=nums.size();\\n        int m=nums[0].size();\\n\\n        int maximum=0;\\n        int score=0;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n           sort(nums[i].begin(),nums[i].end());\\n        }\\n\\n        // FIRST COLUMN KO FIX KARDIYA ,ISKE BAAD US COL MEIN MAX ELEMENT NIKALA AUR USKO SCORE MEIN ADD KARDIYA .///   AISA EXACTLY HAR ROW KE LIYE KARO\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n               maximum=max(nums[j][i],maximum);\\n            }\\n            score+=maximum;\\n        }\\n        return score;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sorting",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n\\n        int n=nums.size();\\n        int m=nums[0].size();\\n\\n        int maximum=0;\\n        int score=0;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n           sort(nums[i].begin(),nums[i].end());\\n        }\\n\\n        // FIRST COLUMN KO FIX KARDIYA ,ISKE BAAD US COL MEIN MAX ELEMENT NIKALA AUR USKO SCORE MEIN ADD KARDIYA .///   AISA EXACTLY HAR ROW KE LIYE KARO\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n               maximum=max(nums[j][i],maximum);\\n            }\\n            score+=maximum;\\n        }\\n        return score;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3980532,
                "title": "shortest-easiest-clean-clear-straight-forward-solution-must-try",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& v) {\\n        vector<int>p;\\n        int sum=0;\\n        x:\\n        for(int i=0;i<v.size();i++){\\n            int k=*max_element(v[i].begin(),v[i].end());\\n            p.push_back(k);\\n            for(int j=0;j<v[i].size();j++)if(v[i][j]==k){v[i].erase(v[i].begin()+j);break;}\\n        }\\n        sum+=*max_element(p.begin(),p.end());\\n        p.clear();\\n        if(v[0].size()!=0)goto x;\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& v) {\\n        vector<int>p;\\n        int sum=0;\\n        x:\\n        for(int i=0;i<v.size();i++){\\n            int k=*max_element(v[i].begin(),v[i].end());\\n            p.push_back(k);\\n            for(int j=0;j<v[i].size();j++)if(v[i][j]==k){v[i].erase(v[i].begin()+j);break;}\\n        }\\n        sum+=*max_element(p.begin(),p.end());\\n        p.clear();\\n        if(v[0].size()!=0)goto x;\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3968984,
                "title": "my-solution-for-2679-sum-in-a-matrix",
                "content": "# Intuition\\nMy first thought is using numpy and hoping for the best)\\n\\n# Approach\\nSort rows for select maximum value for each iteration, find maximum value in each column to select largest value in each iteration and sum the result array.\\n\\n# Code\\n```\\nimport numpy as np\\n\\n\\nclass Solution:\\n    \\n    def matrixSum(self, nums: List[List[int]]) -> int:\\n        nums = np.array(nums)\\n        return np.sum(np.max(np.sort(nums, axis=1), axis=0))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport numpy as np\\n\\n\\nclass Solution:\\n    \\n    def matrixSum(self, nums: List[List[int]]) -> int:\\n        nums = np.array(nums)\\n        return np.sum(np.max(np.sort(nums, axis=1), axis=0))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3968059,
                "title": "python-simple-sorting-solution",
                "content": "Assume the matrix is nums = [[7,2,1],[6,4,2],[6,5,3],[3,2,1]]\\n\\n\\t7 2 1\\n\\t6 4 2 \\n\\t6 5 3\\n\\t3 2 1\\n\\t\\n\\t\\n Since we want the greatest value in each row in each operation, sorting will make our job easier.\\n \\n\\t If we sort each row in decreasing order, we get - \\n\\t \\n\\t 7 2 1\\n\\t 6 4 2 \\n\\t 6 5 3\\n\\t 3 2 1\\n\\t \\n\\t Now, Let\\'s take each operation and see what will be the greatest value in each row\\n\\t \\n\\t In Operation 1, we remove values 7,6,6 and 3 from each row respectively\\n\\t In Operation 2, we remove values 2,4,5 and 2 from each row respectively\\n\\t In Operation 3, we remove values 1,2,3 and 1 from each row respectively\\n\\t \\n\\t And So, score = max(7,6,6,3) + max(2,4,5,2) + max(1,2,3,1)\\n\\t  => 7 + 5 + 3 => 15\\n\\t  \\nDid you notice something?\\n\\nWhen we sorted the rows in decreasing order, then in each Operation \"i\", we were just removing values from column \"i - 1\"\\n\\nThat is, in Operation 1, we removed all the values from column 0\\nIn operation 2, we removed all the values from column 1\\nAnd In operation 3, we removed all the values from column 2\\n\\nSo basically, we just want the greatest value in each column and add that value to the score. And that\\'s it. There is no need to even remove anything. And that\\'s the whole idea of the below solution.\\n\\n\\n```\\ndef matrixSum(self, nums: List[List[int]]) -> int:\\n        # Score \\n        score = 0\\n        \\n        # Count of rows\\n        m = len(nums)\\n        \\n        # Count of columns\\n        n = len(nums[0])\\n        \\n        # Since we want the largest number in each row in each operation\\n        # We will sort each row in decreasing order\\n        for i in range(m): nums[i].sort(reverse=True)\\n            \\n        # Now that each row is sorted in decreasing order\\n        # It means that in one operation, the greatest values in each row are all aligned in same column\\n        # So we just need to go over all the values in each column and get the greatest out of them\\n        for j in range(n):\\n            \\n            # Greatest value\\n            greatestVal = 0\\n            \\n            for i in range(m):\\n                if nums[i][j] > greatestVal: \\n                    greatestVal = nums[i][j]\\n                    \\n            # Add the greatest value to the score\\n            score += greatestVal\\n            \\n        # Finally, return the score\\n        return score\\n```",
                "solutionTags": [
                    "Python",
                    "Sorting"
                ],
                "code": "```\\ndef matrixSum(self, nums: List[List[int]]) -> int:\\n        # Score \\n        score = 0\\n        \\n        # Count of rows\\n        m = len(nums)\\n        \\n        # Count of columns\\n        n = len(nums[0])\\n        \\n        # Since we want the largest number in each row in each operation\\n        # We will sort each row in decreasing order\\n        for i in range(m): nums[i].sort(reverse=True)\\n            \\n        # Now that each row is sorted in decreasing order\\n        # It means that in one operation, the greatest values in each row are all aligned in same column\\n        # So we just need to go over all the values in each column and get the greatest out of them\\n        for j in range(n):\\n            \\n            # Greatest value\\n            greatestVal = 0\\n            \\n            for i in range(m):\\n                if nums[i][j] > greatestVal: \\n                    greatestVal = nums[i][j]\\n                    \\n            # Add the greatest value to the score\\n            score += greatestVal\\n            \\n        # Finally, return the score\\n        return score\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3966970,
                "title": "its-for-u-begginer-python",
                "content": "# for begginers easy python solution\\n**less lines of code**\\n* using sorted list\\n* using list comprehensions easily get values from lists in grid\\n```\\nclass Solution(object):\\n    def matrixSum(self, nums):\\n        \"\"\"\\n        :type nums: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        for i in range(len(nums)):\\n            nums[i] = sorted(nums[i],reverse = True)\\n        li = [max([num[i] for num in nums]) for i in range(len(nums[0]))]\\n        sum1 = 0\\n        for num in li:\\n            sum1+=num\\n        return sum1\\n        \\n```\\n# please upvote\\n![image](https://assets.leetcode.com/users/images/74da17c0-1d76-426e-82c8-d577698e0012_1693134024.377868.jpeg)\\n",
                "solutionTags": [
                    "Matrix"
                ],
                "code": "```\\nclass Solution(object):\\n    def matrixSum(self, nums):\\n        \"\"\"\\n        :type nums: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        for i in range(len(nums)):\\n            nums[i] = sorted(nums[i],reverse = True)\\n        li = [max([num[i] for num in nums]) for i in range(len(nums[0]))]\\n        sum1 = 0\\n        for num in li:\\n            sum1+=num\\n        return sum1\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3963098,
                "title": "c-sorting-o-nlogn-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe code sorts each row in ascending order and then iterates through the columns, finding the maximum value in each column and accumulating these maximum values to calculate the total sum. This algorithm efficiently identifies and accumulates the maximum values across columns in a matrix.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Sort each row of the matrix in ascending order.\\n1. Iterate through columns, tracking the maximum value (maxi) encountered in each column.\\n1. Accumulate maxi for each column into the sum.\\n1. Return the calculated sum as the result.\\n# Complexity\\n- Time complexity: O(m * n * log n), where \\'m\\' is the number of rows and \\'n\\' is the number of columns in the matrix.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int maxi = 0, sum = 0;\\n        for(int i=0; i<nums.size(); i++){\\n            sort(nums[i].begin(), nums[i].end());\\n        }\\n        int j=0;\\n        while(j<nums[0].size()){\\n            maxi = 0;\\n            for(int i=0; i<nums.size(); i++){\\n                maxi = max(maxi, nums[i][j]);\\n            }\\n            sum += maxi;\\n            j++;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int maxi = 0, sum = 0;\\n        for(int i=0; i<nums.size(); i++){\\n            sort(nums[i].begin(), nums[i].end());\\n        }\\n        int j=0;\\n        while(j<nums[0].size()){\\n            maxi = 0;\\n            for(int i=0; i<nums.size(); i++){\\n                maxi = max(maxi, nums[i][j]);\\n            }\\n            sum += maxi;\\n            j++;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3960016,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n        for(int i=0;i<nums.length;i++){\\n            Arrays.sort(nums[i]);\\n        }\\n        int sum =0;\\n        for(int j=nums[0].length-1; j>= 0;j--){\\n            int max = Integer.MIN_VALUE;\\n            for(int i=0;i<nums.length;i++){\\n                int ans = nums[i][j];\\n                max = Math.max(max, ans);\\n            }\\n            sum += max;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n        for(int i=0;i<nums.length;i++){\\n            Arrays.sort(nums[i]);\\n        }\\n        int sum =0;\\n        for(int j=nums[0].length-1; j>= 0;j--){\\n            int max = Integer.MIN_VALUE;\\n            for(int i=0;i<nums.length;i++){\\n                int ans = nums[i][j];\\n                max = Math.max(max, ans);\\n            }\\n            sum += max;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3947646,
                "title": "c-solution-beats-100-00-sort-rows-and-scan-columns",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nint comp(const int * a, const int * b)\\n{\\n    return *a - *b;\\n}\\n\\nint matrixSum(int** nums, int numsSize, int* numsColSize){\\n\\n    int  score      = 0;\\n    int  rows       = numsSize;\\n    int  cols       = *numsColSize;\\n    int  max_val    = INT_MIN;\\n\\n    for (int i = 0; i < rows; i++)\\n    {\\n        /* Iteratve over all rows, sort the list in every row in descending order */\\n        qsort(nums[i], *numsColSize, sizeof(int), comp);\\n    }\\n\\n\\n    for (int i = 0; i < cols; i++)\\n    {\\n        /* Go column by column and find the max value \\n         * amongst all rows. Accumulate that to score */\\n        for (int j = 0; j < rows; j++)\\n        {\\n            max_val = (nums[j][i] > max_val) ? nums[j][i] : max_val;\\n        }\\n\\n        score  += max_val;\\n        max_val = INT_MIN;\\n    }\\n\\n    return score;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint comp(const int * a, const int * b)\\n{\\n    return *a - *b;\\n}\\n\\nint matrixSum(int** nums, int numsSize, int* numsColSize){\\n\\n    int  score      = 0;\\n    int  rows       = numsSize;\\n    int  cols       = *numsColSize;\\n    int  max_val    = INT_MIN;\\n\\n    for (int i = 0; i < rows; i++)\\n    {\\n        /* Iteratve over all rows, sort the list in every row in descending order */\\n        qsort(nums[i], *numsColSize, sizeof(int), comp);\\n    }\\n\\n\\n    for (int i = 0; i < cols; i++)\\n    {\\n        /* Go column by column and find the max value \\n         * amongst all rows. Accumulate that to score */\\n        for (int j = 0; j < rows; j++)\\n        {\\n            max_val = (nums[j][i] > max_val) ? nums[j][i] : max_val;\\n        }\\n\\n        score  += max_val;\\n        max_val = INT_MIN;\\n    }\\n\\n    return score;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3946646,
                "title": "sum-in-a-matrix-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def matrixSum(self, nums):\\n#         print(nums)\\n        for row in nums:\\n            row.sort(reverse=True)\\n            print(row)\\n        res = 0\\n        for i in range(len(nums[0])):\\n            curr = []\\n            for j in range(len(nums)):\\n                curr.append(nums[j][i])\\n                x = max(curr)\\n            res += x\\n        return res\\nobj = Solution()\\nobj.matrixSum([[7,2,1],[6,4,2],[6,5,3],[3,2,1]])\\n# obj.matrixSum([[1]])\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def matrixSum(self, nums):\\n#         print(nums)\\n        for row in nums:\\n            row.sort(reverse=True)\\n            print(row)\\n        res = 0\\n        for i in range(len(nums[0])):\\n            curr = []\\n            for j in range(len(nums)):\\n                curr.append(nums[j][i])\\n                x = max(curr)\\n            res += x\\n        return res\\nobj = Solution()\\nobj.matrixSum([[7,2,1],[6,4,2],[6,5,3],[3,2,1]])\\n# obj.matrixSum([[1]])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3941338,
                "title": "sol",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n        int score =0;\\n        int n=nums.length;\\n        int m=nums[0].length;\\n        for(int [] a:nums){\\n            Arrays.sort(a);\\n        }\\n        for(int i=0;i<m;i++)\\n        {\\n            int max=0;\\n            for(int j=0;j<n;j++){\\n                max=Math.max(max,nums[j][i]);\\n            }\\n            score+=max;\\n        }\\n        return score;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n        int score =0;\\n        int n=nums.length;\\n        int m=nums[0].length;\\n        for(int [] a:nums){\\n            Arrays.sort(a);\\n        }\\n        for(int i=0;i<m;i++)\\n        {\\n            int max=0;\\n            for(int j=0;j<n;j++){\\n                max=Math.max(max,nums[j][i]);\\n            }\\n            score+=max;\\n        }\\n        return score;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3939645,
                "title": "beats-99-40-simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n        int sum = 0;\\n        for(int i = 0 ; i < nums.length ; i++){\\n            Arrays.sort(nums[i]);\\n        }\\n        \\n        \\n        int k = nums[0].length-1;\\n        for(int j = 0 ; j < nums[0].length; j++){\\n            int s = 0;\\n            for(int i = 0 ; i < nums.length ; i++){\\n                s = Math.max(s,nums[i][k]);\\n            }\\n            sum+=s;\\n            k = k-1;\\n\\n        }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n        int sum = 0;\\n        for(int i = 0 ; i < nums.length ; i++){\\n            Arrays.sort(nums[i]);\\n        }\\n        \\n        \\n        int k = nums[0].length-1;\\n        for(int j = 0 ; j < nums[0].length; j++){\\n            int s = 0;\\n            for(int i = 0 ; i < nums.length ; i++){\\n                s = Math.max(s,nums[i][k]);\\n            }\\n            sum+=s;\\n            k = k-1;\\n\\n        }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3937786,
                "title": "simple-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. Sorting\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Sort all the rows\\n2. calculate the sum of max of each column\\n# Complexity\\n- Time complexity: O(N * N *logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def matrixSum(self, nums: List[List[int]]) -> int:\\n        for i in nums:\\n            i.sort()\\n        su=0\\n        for i in range(len(nums[0])):\\n            mx=0\\n            for j in range(len(nums)):\\n                mx=max(nums[j][i],mx)\\n            su+=mx\\n        return su\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def matrixSum(self, nums: List[List[int]]) -> int:\\n        for i in nums:\\n            i.sort()\\n        su=0\\n        for i in range(len(nums[0])):\\n            mx=0\\n            for j in range(len(nums)):\\n                mx=max(nums[j][i],mx)\\n            su+=mx\\n        return su\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3936312,
                "title": "easy-java-solution-sorting-beats-90",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int matrixSum(int[][] arr) {\\n        int n = arr.length; \\n        int m = arr[0].length;\\n\\n        int ans[][] = new int[n][m];\\n\\n        for(int i=0; i<n; i++){\\n            Arrays.sort(arr[i]);\\n            ans[i] = arr[i];\\n        }\\n\\n        int sum = 0;\\n\\n        for(int j=0; j<m; j++){\\n            int k = 0;\\n            for(int i=0; i<n; i++){\\n                k = Math.max(k,ans[i][j]);\\n            }\\n\\n            sum+=k;\\n        }\\n\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int matrixSum(int[][] arr) {\\n        int n = arr.length; \\n        int m = arr[0].length;\\n\\n        int ans[][] = new int[n][m];\\n\\n        for(int i=0; i<n; i++){\\n            Arrays.sort(arr[i]);\\n            ans[i] = arr[i];\\n        }\\n\\n        int sum = 0;\\n\\n        for(int j=0; j<m; j++){\\n            int k = 0;\\n            for(int i=0; i<n; i++){\\n                k = Math.max(k,ans[i][j]);\\n            }\\n\\n            sum+=k;\\n        }\\n\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3936169,
                "title": "c-solution-using-sorting-of-each-row",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int ans=0;\\n        int n=nums.size();\\n        int m=nums[0].size();\\n        for(int i=0;i<n;i++)\\n        {\\n            sort(nums[i].begin(),nums[i].end());\\n        }\\n        for(int i=0;i<m;i++)\\n        {\\n            int maxi=0;\\n            for(int j=0;j<n;j++)\\n            {\\n                maxi=max(maxi,nums[j][i]);\\n            }\\n            ans+=maxi;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int ans=0;\\n        int n=nums.size();\\n        int m=nums[0].size();\\n        for(int i=0;i<n;i++)\\n        {\\n            sort(nums[i].begin(),nums[i].end());\\n        }\\n        for(int i=0;i<m;i++)\\n        {\\n            int maxi=0;\\n            for(int j=0;j<n;j++)\\n            {\\n                maxi=max(maxi,nums[j][i]);\\n            }\\n            ans+=maxi;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3932370,
                "title": "easy-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int ans=0;\\n        int i,j,x;\\n      // coloumn size\\n        int m=nums.size();\\n      // row size\\n        int n=nums[0].size();\\n        // sorting row elements\\n        for(auto &i : nums)\\n        {\\n            sort(i.begin(),i.end());\\n        }\\n// traversing through the matrix and storing the largest element from each coloumn\\n        for(j=0;j<n;j++ )\\n        {\\n            x=0;\\n            for(int i=0;i<m;i++)\\n            {\\n            x= max(x,nums[i][j]);\\n            }\\n         // x is the largest element from the each column\\n            ans+=x;\\n        }\\n        return ans;\\n    } \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int ans=0;\\n        int i,j,x;\\n      // coloumn size\\n        int m=nums.size();\\n      // row size\\n        int n=nums[0].size();\\n        // sorting row elements\\n        for(auto &i : nums)\\n        {\\n            sort(i.begin(),i.end());\\n        }\\n// traversing through the matrix and storing the largest element from each coloumn\\n        for(j=0;j<n;j++ )\\n        {\\n            x=0;\\n            for(int i=0;i<m;i++)\\n            {\\n            x= max(x,nums[i][j]);\\n            }\\n         // x is the largest element from the each column\\n            ans+=x;\\n        }\\n        return ans;\\n    } \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3930117,
                "title": "c-easy-to-understand-priority-queue-sorting",
                "content": "# Intuition\\nTaking max from each row - can be done by sorting each row and taking the last element.\\n\\n# Approach\\nSorting each row and taking the last element, that every element is pushed in a max heap, so that at every iteration we can take the top element of the heap, and add to our score.\\n\\n\\n# Complexity\\n- Time complexity: $$O(n*m)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n*m)$$ - space of priority queue at every itration\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        \\n        \\n        int n = nums.size();\\n        int m = nums[0].size();\\n        int score = 0 ;\\n\\n        for(int i = 0 ; i<n ; i++){\\n            sort(nums[i].begin() , nums[i].end());\\n        }\\n        \\n            \\n            for(int i = m-1 ; i >=0 ; i--)\\n            {   \\n                priority_queue<int> pq;\\n            \\n                for(int j = 0 ; j<n ; j++){\\n                    cout<<nums[j][i]<<\" \";\\n                    pq.push(nums[j][i]);\\n                }\\n                cout<<endl;\\n            \\n                score = score+pq.top();\\n   \\n            }\\n\\n        return score;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sorting",
                    "Heap (Priority Queue)",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        \\n        \\n        int n = nums.size();\\n        int m = nums[0].size();\\n        int score = 0 ;\\n\\n        for(int i = 0 ; i<n ; i++){\\n            sort(nums[i].begin() , nums[i].end());\\n        }\\n        \\n            \\n            for(int i = m-1 ; i >=0 ; i--)\\n            {   \\n                priority_queue<int> pq;\\n            \\n                for(int j = 0 ; j<n ; j++){\\n                    cout<<nums[j][i]<<\" \";\\n                    pq.push(nums[j][i]);\\n                }\\n                cout<<endl;\\n            \\n                score = score+pq.top();\\n   \\n            }\\n\\n        return score;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3929690,
                "title": "2679-sum-in-a-matrix",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n        int ans=0;\\n        for(int []row:nums)\\n        {\\n            Arrays.sort(row);\\n        }\\n        for(int i=0;i<nums[0].length;i++)\\n        {\\n            int m=0;\\n            for(int j=0;j<nums.length;j++)\\n            {\\n                if(m<nums[j][i])\\n                    m=nums[j][i];\\n            }\\n            ans+=m;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n        int ans=0;\\n        for(int []row:nums)\\n        {\\n            Arrays.sort(row);\\n        }\\n        for(int i=0;i<nums[0].length;i++)\\n        {\\n            int m=0;\\n            for(int j=0;j<nums.length;j++)\\n            {\\n                if(m<nums[j][i])\\n                    m=nums[j][i];\\n            }\\n            ans+=m;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3925605,
                "title": "java-easy-solution-beats-99-50",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n        \\n       int finalscore = 0;\\n\\n       for(int i = 0; i<nums.length; i++){\\n          Arrays.sort(nums[i]);\\n\\n\\n       }\\n\\n       int minr = 0;\\n       int minc = 0;\\n       int maxr = nums.length;\\n       int maxc = nums[0].length;\\n\\n       for(int i = 0; i<nums[0].length; i++){\\n\\n        int max = 0;\\n\\n        for(int j = minr, k=minc; j<maxr; j++ ){\\n                  max = Math.max(max, nums[j][k]);\\n        }\\n       \\n        finalscore +=max;\\n        minc++;\\n        minr = 0;\\n       }\\n       \\n       return finalscore;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n        \\n       int finalscore = 0;\\n\\n       for(int i = 0; i<nums.length; i++){\\n          Arrays.sort(nums[i]);\\n\\n\\n       }\\n\\n       int minr = 0;\\n       int minc = 0;\\n       int maxr = nums.length;\\n       int maxc = nums[0].length;\\n\\n       for(int i = 0; i<nums[0].length; i++){\\n\\n        int max = 0;\\n\\n        for(int j = minr, k=minc; j<maxr; j++ ){\\n                  max = Math.max(max, nums[j][k]);\\n        }\\n       \\n        finalscore +=max;\\n        minc++;\\n        minr = 0;\\n       }\\n       \\n       return finalscore;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3911580,
                "title": "python-easiest-solution-sorting-the-rows-brets-84",
                "content": "\\n```\\nclass Solution:\\n    def matrixSum(self, nums: List[List[int]]) -> int:\\n        for x in nums:\\n            x.sort()\\n        l=len(nums[0])\\n        temp=0\\n        ans=0\\n        for x in range(l):\\n            for y in nums:\\n                temp=max(temp,y[x])\\n            ans+=temp\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def matrixSum(self, nums: List[List[int]]) -> int:\\n        for x in nums:\\n            x.sort()\\n        l=len(nums[0])\\n        temp=0\\n        ans=0\\n        for x in range(l):\\n            for y in nums:\\n                temp=max(temp,y[x])\\n            ans+=temp\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3904034,
                "title": "simple-traversal",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int sum=0;\\n        \\n        \\n        for(int i=0;i<nums.size();i++){\\n            sort(nums[i].begin(),nums[i].end());\\n            }\\n        for(int n=0;n<nums[0].size();n++){\\n            int m=INT_MIN;\\n            for(int i=0;i<nums.size();i++){    \\n                m=max(m,nums[i][n]);\\n            }\\n            sum=sum+m;\\n        \\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int sum=0;\\n        \\n        \\n        for(int i=0;i<nums.size();i++){\\n            sort(nums[i].begin(),nums[i].end());\\n            }\\n        for(int n=0;n<nums[0].size();n++){\\n            int m=INT_MIN;\\n            for(int i=0;i<nums.size();i++){    \\n                m=max(m,nums[i][n]);\\n            }\\n            sum=sum+m;\\n        \\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3902815,
                "title": "c-solution",
                "content": "# Intuition\\nSince we have to get the max from each row and then calculate the max from each column and add it the answer(score).\\n\\n# Approach\\nSteps are:\\n1.Therefor we are going to first sort the each row in descending order.\\n2.Then after that we are going to traverse the each column to calculate the max from that column.\\n3.Then we will add that maximum value to answer(score).\\n4.Repeat the above steps.\\n\\n# Complexity\\n- Time complexity:O(n^2)\\n- Since we are traversing in nested loop.\\n\\n- Space complexity:0(1)\\n- Since no extra space is needed.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int n = nums.size();\\n        int m = nums[0].size();\\n        for(auto &it : nums){\\n            sort(it.begin(), it.end(), greater<int>());\\n        }\\n\\n        int ans = 0;\\n        for(int j=0; j<m; j++){\\n            int val = INT_MIN;\\n            for(int i=0; i<n; i++){\\n                val = max(val, nums[i][j]);\\n            }\\n            ans += val;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int n = nums.size();\\n        int m = nums[0].size();\\n        for(auto &it : nums){\\n            sort(it.begin(), it.end(), greater<int>());\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3897773,
                "title": "c-too-easy-short",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& g) {\\n        long long int s=0;\\n        for(auto &i : g)\\n        sort(i.begin(),i.end());\\n        for(int i=0;i<g[0].size();i++)\\n          {\\n              int m=0;\\n              for(int j=0;j<g.size();j++)\\n              m=max(m,g[j][i]);\\n              s+=m;\\n          }\\n          return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& g) {\\n        long long int s=0;\\n        for(auto &i : g)\\n        sort(i.begin(),i.end());\\n        for(int i=0;i<g[0].size();i++)\\n          {\\n              int m=0;\\n              for(int j=0;j<g.size();j++)\\n              m=max(m,g[j][i]);\\n              s+=m;\\n          }\\n          return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3895251,
                "title": "good-question-tricky-but-v-easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        for(int i = 0; i<nums.size(); i++){\\n            sort(nums[i].begin(), nums[i].end());\\n            reverse(nums[i].begin(), nums[i].end());\\n            \\n        }\\n        int answer = 0;\\n        int maxI= INT_MIN;\\n        for(int j = 0; j<nums[0].size(); j++){\\n            maxI=INT_MIN;\\n            for(int k = 0; k<nums.size(); k++){\\n                maxI = max(maxI, nums[k][j]);\\n            }\\n            answer += maxI;\\n        }\\n\\n        return answer;\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        for(int i = 0; i<nums.size(); i++){\\n            sort(nums[i].begin(), nums[i].end());\\n            reverse(nums[i].begin(), nums[i].end());\\n            \\n        }\\n        int answer = 0;\\n        int maxI= INT_MIN;\\n        for(int j = 0; j<nums[0].size(); j++){\\n            maxI=INT_MIN;\\n            for(int k = 0; k<nums.size(); k++){\\n                maxI = max(maxI, nums[k][j]);\\n            }\\n            answer += maxI;\\n        }\\n\\n        return answer;\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3890673,
                "title": "simple-clean-c-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int r = nums.size();\\n        int c = nums[0].size();\\n        int ans = 0;\\n        int ptr = 0;\\n        int m = 0;\\n        for(int i=0; i<r; i++)\\n        {\\n            sort(nums[i].begin(), nums[i].end(), greater<int>());\\n        }\\n        while(ptr < c)\\n        {\\n            m = 0;\\n            for(int i=0; i<r; i++)\\n            {\\n                m = max(m, nums[i][ptr]);\\n            }\\n            ans += m;\\n            ptr++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int r = nums.size();\\n        int c = nums[0].size();\\n        int ans = 0;\\n        int ptr = 0;\\n        int m = 0;\\n        for(int i=0; i<r; i++)\\n        {\\n            sort(nums[i].begin(), nums[i].end(), greater<int>());\\n        }\\n        while(ptr < c)\\n        {\\n            m = 0;\\n            for(int i=0; i<r; i++)\\n            {\\n                m = max(m, nums[i][ptr]);\\n            }\\n            ans += m;\\n            ptr++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3884264,
                "title": "sum-in-a-matrix",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n        int sum = 0;\\n        int m = nums.length;\\n        int n = nums[0].length;\\n        System.out.println(m+\" \"+n);\\n        for(int i=0;i<n;i++)\\n        {int max1 = 0;\\n        for(int j=0;j<m;j++)\\n        {\\n            int max = 0;\\n            for(int k=0;k<n;k++)\\n            {\\n                max = Math.max(max,nums[j][k]);\\n            }\\n            for(int k=0;k<n;k++)\\n            {\\n                if(nums[j][k]==max)\\n                {nums[j][k]=0;\\n                break;}\\n            }\\n            max1=Math.max(max1,max);\\n        }\\n        sum = sum+max1;}\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n        int sum = 0;\\n        int m = nums.length;\\n        int n = nums[0].length;\\n        System.out.println(m+\" \"+n);\\n        for(int i=0;i<n;i++)\\n        {int max1 = 0;\\n        for(int j=0;j<m;j++)\\n        {\\n            int max = 0;\\n            for(int k=0;k<n;k++)\\n            {\\n                max = Math.max(max,nums[j][k]);\\n            }\\n            for(int k=0;k<n;k++)\\n            {\\n                if(nums[j][k]==max)\\n                {nums[j][k]=0;\\n                break;}\\n            }\\n            max1=Math.max(max1,max);\\n        }\\n        sum = sum+max1;}\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3871313,
                "title": "c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int n=nums.size();\\n        int m=nums[0].size();\\n        for (int i=0;i<n;i++)\\n        {\\n            sort(nums[i].begin(),nums[i].end());\\n        }\\n        int ans=0;\\n        for (int j=0;j<m;j++)\\n        {\\n            int maxi=0;\\n            for (int i=0;i<n;i++)\\n            {\\n              maxi=max(maxi,nums[i][j]);\\n            }\\n            ans+=maxi;\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int n=nums.size();\\n        int m=nums[0].size();\\n        for (int i=0;i<n;i++)\\n        {\\n            sort(nums[i].begin(),nums[i].end());\\n        }\\n        int ans=0;\\n        for (int j=0;j<m;j++)\\n        {\\n            int maxi=0;\\n            for (int i=0;i<n;i++)\\n            {\\n              maxi=max(maxi,nums[i][j]);\\n            }\\n            ans+=maxi;\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3858546,
                "title": "sort-solution-python",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def matrixSum(self, nums: List[List[int]]) -> int:\\n        for i in range(len(nums)):\\n            nums[i].sort(reverse=True)\\n        answer = 0\\n        for i in range(len(nums[0])):\\n            mx = 0\\n            for j in range(len(nums)):\\n                mx = max(mx, nums[j][i])\\n            answer += mx\\n        return answer\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def matrixSum(self, nums: List[List[int]]) -> int:\\n        for i in range(len(nums)):\\n            nums[i].sort(reverse=True)\\n        answer = 0\\n        for i in range(len(nums[0])):\\n            mx = 0\\n            for j in range(len(nums)):\\n                mx = max(mx, nums[j][i])\\n            answer += mx\\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3854876,
                "title": "sort",
                "content": "```\\nint matrixSum(vector<vector<int>>& n)\\n{\\n\\tfor(auto & n : n) sort(begin(n), end(n), greater{});\\n\\tint out{};\\n\\tfor(int j{}; j<size(n[0]); ++j)\\n\\t{\\n\\t\\tint M(INT_MIN);\\n\\t\\tfor(int i{}; i<size(n); ++i)\\n\\t\\t\\tM=max(M, n[i][j]);\\n\\t\\tout+=M;\\n\\t}\\n\\treturn out;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint matrixSum(vector<vector<int>>& n)\\n{\\n\\tfor(auto & n : n) sort(begin(n), end(n), greater{});\\n\\tint out{};\\n\\tfor(int j{}; j<size(n[0]); ++j)\\n\\t{\\n\\t\\tint M(INT_MIN);\\n\\t\\tfor(int i{}; i<size(n); ++i)\\n\\t\\t\\tM=max(M, n[i][j]);\\n\\t\\tout+=M;\\n\\t}\\n\\treturn out;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3852036,
                "title": "c-beats-98-14-simple",
                "content": "class Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {  \\n        for(auto &num:nums){\\n            sort(num.begin(),num.end());\\n        }\\n        int sum=0;\\n        for(int i=0;i<nums[0].size();i++){\\n            int max1=INT_MIN;\\n            for(int j=0;j<nums.size();j++){\\n                max1=max(max1,nums[j][i]);\\n            }\\n            sum+=max1;\\n        }\\n        return sum;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {  \\n        for(auto &num:nums){\\n            sort(num.begin(),num.end());\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3852009,
                "title": "c-priority-queue",
                "content": "class Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {  \\n        for(auto &num:nums){\\n            sort(num.begin(),num.end());\\n        }\\n        int sum=0;\\n        priority_queue<int> pq;\\n        for(int i=0;i<nums[0].size();i++){\\n            for(auto num:nums){\\n                pq.push(num[i]);\\n            }\\n            sum+=pq.top();\\n            cout<<pq.top()<<endl;\\n\\n            while(!pq.empty()) pq.pop();\\n        }\\n        return sum;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {  \\n        for(auto &num:nums){\\n            sort(num.begin(),num.end());\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3850720,
                "title": "python-sort-solution-beats-99",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition is that we want to first sort each row then loop through this to add the max value at each index.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Sort each row\\n2. Create score var\\n2. For every index in a row, find the max value of each row at that index\\n3. Add those max values to the score var\\n4. Return score\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def matrixSum(self, nums: List[List[int]]) -> int:\\n        for row in nums:\\n            row.sort()\\n        \\n        score = 0\\n        for i in range(len(nums[0])-1,-1,-1):\\n            maximum = -1\\n            for row in nums:\\n                maximum = max(row[i], maximum)\\n            \\n            score+=maximum\\n\\n        return score\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Sort"
                ],
                "code": "```\\nclass Solution:\\n    def matrixSum(self, nums: List[List[int]]) -> int:\\n        for row in nums:\\n            row.sort()\\n        \\n        score = 0\\n        for i in range(len(nums[0])-1,-1,-1):\\n            maximum = -1\\n            for row in nums:\\n                maximum = max(row[i], maximum)\\n            \\n            score+=maximum\\n\\n        return score\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3844004,
                "title": "python-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def matrixSum(self, nums: List[List[int]]) -> int:\\n        for row in nums:\\n            row.sort(reverse=True)\\n        ans=0\\n        for i in range(len(nums[0])):\\n            arr=[]\\n            for j in range(len(nums)):\\n                heapq.heappush(arr,-nums[j][i])\\n            heapq.heapify(arr)\\n            a=-heapq.heappop(arr)\\n            ans+=a\\n            \\n\\n\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def matrixSum(self, nums: List[List[int]]) -> int:\\n        for row in nums:\\n            row.sort(reverse=True)\\n        ans=0\\n        for i in range(len(nums[0])):\\n            arr=[]\\n            for j in range(len(nums)):\\n                heapq.heappush(arr,-nums[j][i])\\n            heapq.heapify(arr)\\n            a=-heapq.heappop(arr)\\n            ans+=a\\n            \\n\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3842937,
                "title": "easy-to-get-solution-using-sorting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n        int score=0;\\n        int n=nums.length;\\n        int m=nums[0].length;\\n        for(int[] a :nums) Arrays.sort(a);\\n        \\n        for(int i=0;i<m;i++){\\n            int max=0;\\n            for(int j=0;j<n;j++){\\n                max=Math.max(max,nums[j][i]);\\n            }\\n            score+=max;\\n        }\\n\\n        return score;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n        int score=0;\\n        int n=nums.length;\\n        int m=nums[0].length;\\n        for(int[] a :nums) Arrays.sort(a);\\n        \\n        for(int i=0;i<m;i++){\\n            int max=0;\\n            for(int j=0;j<n;j++){\\n                max=Math.max(max,nums[j][i]);\\n            }\\n            score+=max;\\n        }\\n\\n        return score;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3838325,
                "title": "simple-js",
                "content": "\\n```\\n\\nconst matrixSum = function (nums) {\\n  let sum = 0;\\n\\n  nums.forEach(arr => arr.sort((a, b) => b - a));\\n\\n  for (let i = 0; i < nums[0].length; i++) {\\n    const maxVals = [];\\n\\n    for (let j = 0; j < nums.length; j++) {\\n      maxVals.push(nums[j][i]);\\n    }\\n\\n    sum += Math.max(...maxVals);\\n  }\\n\\n  return sum;\\n};\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nconst matrixSum = function (nums) {\\n  let sum = 0;\\n\\n  nums.forEach(arr => arr.sort((a, b) => b - a));\\n\\n  for (let i = 0; i < nums[0].length; i++) {\\n    const maxVals = [];\\n\\n    for (let j = 0; j < nums.length; j++) {\\n      maxVals.push(nums[j][i]);\\n    }\\n\\n    sum += Math.max(...maxVals);\\n  }\\n\\n  return sum;\\n};\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3825028,
                "title": "intuitive-approach-that-beats-100-python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n-> Sort each subarray in reverse order\\n-> Create a for loop that loops until the maxlength of nums-subarray.\\n-> if i is out-of-bounds of num then skip or else normal logic to find maxelem\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: o(mlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution:\\n    def matrixSum(self, nums: List[List[int]]) -> int:\\n\\n        maxlen = 0\\n\\n        returnsum = 0\\n\\n        for num in nums:\\n            if len(num) > maxlen:\\n                maxlen = len(num)\\n            num.sort(reverse=True)\\n\\n        for i in range(maxlen):\\n\\n            maxelem = float(\\'-inf\\')\\n\\n            for num in nums:\\n                if i >= len(num):\\n                    continue\\n                elif num[i] > maxelem:\\n                    maxelem = num[i]\\n            \\n            returnsum +=maxelem\\n        \\n        return returnsum\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n\\nclass Solution:\\n    def matrixSum(self, nums: List[List[int]]) -> int:\\n\\n        maxlen = 0\\n\\n        returnsum = 0\\n\\n        for num in nums:\\n            if len(num) > maxlen:\\n                maxlen = len(num)\\n            num.sort(reverse=True)\\n\\n        for i in range(maxlen):\\n\\n            maxelem = float(\\'-inf\\')\\n\\n            for num in nums:\\n                if i >= len(num):\\n                    continue\\n                elif num[i] > maxelem:\\n                    maxelem = num[i]\\n            \\n            returnsum +=maxelem\\n        \\n        return returnsum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3820339,
                "title": "java-easy-beats-90-o-n-2",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n        for(int i[]: nums){\\n            Arrays.sort(i);\\n        }\\n        int ans=0;\\n        for(int i =0; i <nums[0].length; i++){\\n            int max=0;\\n            for(int j =0; j<nums.length; j++){\\n                max=Math.max(nums[j][i],max);\\n            }\\n            ans+=max;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n        for(int i[]: nums){\\n            Arrays.sort(i);\\n        }\\n        int ans=0;\\n        for(int i =0; i <nums[0].length; i++){\\n            int max=0;\\n            for(int j =0; j<nums.length; j++){\\n                max=Math.max(nums[j][i],max);\\n            }\\n            ans+=max;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3806394,
                "title": "column-sum-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int ans = 0;\\n        for(int i = 0; i < nums.size(); i++){\\n            sort(nums[i].begin(), nums[i].end(), greater<int> ());\\n        }\\n        for(int i = 0; i < nums[0].size(); i++){\\n            int maxi = INT_MIN;\\n            for(int j = 0; j < nums.size(); j++){\\n                maxi = max(maxi, nums[j][i]);\\n            }\\n            ans+= maxi;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int ans = 0;\\n        for(int i = 0; i < nums.size(); i++){\\n            sort(nums[i].begin(), nums[i].end(), greater<int> ());\\n        }\\n        for(int i = 0; i < nums[0].size(); i++){\\n            int maxi = INT_MIN;\\n            for(int j = 0; j < nums.size(); j++){\\n                maxi = max(maxi, nums[j][i]);\\n            }\\n            ans+= maxi;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3794858,
                "title": "intuitive-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n\\n# Complexity\\n- Time complexity:\\n<!-- O(mnlogn) for a m x n matrix -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1) space\\n\\n# Code\\n```\\nclass Solution:\\n    def matrixSum(self, nums: List[List[int]]) -> int:\\n        \\n        #Brute-Force\\n            #init score\\n            #while nums is not empty\\n                #init final list\\n                #for every row in nums\\n                    #extract max of row\\n                    #add max to score\\n        score = 0\\n        cols = len(nums[0])\\n\\n        for i in range(len(nums)):\\n            nums[i].sort(reverse=True)\\n     \\n        for j in range(cols):\\n            final = 0\\n            for k in nums:\\n                high = k[0]\\n                final = max(final, high)\\n                k.remove(high)\\n            \\n            score += final\\n\\n        return score\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def matrixSum(self, nums: List[List[int]]) -> int:\\n        \\n        #Brute-Force\\n            #init score\\n            #while nums is not empty\\n                #init final list\\n                #for every row in nums\\n                    #extract max of row\\n                    #add max to score\\n        score = 0\\n        cols = len(nums[0])\\n\\n        for i in range(len(nums)):\\n            nums[i].sort(reverse=True)\\n     \\n        for j in range(cols):\\n            final = 0\\n            for k in nums:\\n                high = k[0]\\n                final = max(final, high)\\n                k.remove(high)\\n            \\n            score += final\\n\\n        return score\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3791051,
                "title": "java-easy-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n        int row = nums.length;\\n        int col = nums[0].length;\\n        List<List<Integer>> l = new ArrayList<>();\\n        int count = 0;\\n        int max = Integer.MIN_VALUE;\\n        int maxIndexX = -1;\\n        int maxIndexY = -1;\\n        int iteration = 0;\\n        while (iteration < col) {\\n            List<Integer> l1 = new ArrayList<>();\\n            for (int i = 0; i < row; i++) {\\n\\n                for (int j = 0; j < col; j++) {\\n                    if (nums[i][j] > max) {\\n                        maxIndexX = i;\\n                        maxIndexY = j;\\n                        max = nums[i][j];\\n                    }\\n                }\\n                l1.add(max);\\n                nums[maxIndexX][maxIndexY] = Integer.MIN_VALUE;\\n                max = Integer.MIN_VALUE;\\n                maxIndexX = -1;\\n                maxIndexY = -1;\\n            }\\n\\n            l.add(l1);\\n            iteration++;\\n        }\\n\\n        for (List<Integer> l1 : l) {\\n            count += l1.stream().sorted(Collections.reverseOrder()).findFirst().get();\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n        int row = nums.length;\\n        int col = nums[0].length;\\n        List<List<Integer>> l = new ArrayList<>();\\n        int count = 0;\\n        int max = Integer.MIN_VALUE;\\n        int maxIndexX = -1;\\n        int maxIndexY = -1;\\n        int iteration = 0;\\n        while (iteration < col) {\\n            List<Integer> l1 = new ArrayList<>();\\n            for (int i = 0; i < row; i++) {\\n\\n                for (int j = 0; j < col; j++) {\\n                    if (nums[i][j] > max) {\\n                        maxIndexX = i;\\n                        maxIndexY = j;\\n                        max = nums[i][j];\\n                    }\\n                }\\n                l1.add(max);\\n                nums[maxIndexX][maxIndexY] = Integer.MIN_VALUE;\\n                max = Integer.MIN_VALUE;\\n                maxIndexX = -1;\\n                maxIndexY = -1;\\n            }\\n\\n            l.add(l1);\\n            iteration++;\\n        }\\n\\n        for (List<Integer> l1 : l) {\\n            count += l1.stream().sorted(Collections.reverseOrder()).findFirst().get();\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3784036,
                "title": "2-solutions-1-priority-queue-2-soring-o-1-space",
                "content": "# Priority Queue\\n- Time complexity: $$O(n^2logn)$$ \\n\\n- Space complexity: $$O(n^2)$$ \\n\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int n = nums[0].size();\\n        vector<priority_queue<int>> pq;\\n\\n        for(int i=0; i<nums.size(); i++) //....O(n)\\n        {\\n            priority_queue<int> temp;\\n            for(auto it : nums[i])  //.........O(n * n)\\n             temp.push(it);         //.........O(n * n * logn)\\n            pq.push_back(temp);\\n        }\\n\\n    int sum = 0;\\n        while(n--)                            //........O(n)\\n        {\\n            int maxi = INT_MIN;\\n            for(int i=0; i<nums.size(); i++) //........O(n * n)\\n            {\\n             int currMax = pq[i].top(); pq[i].pop(); //...O(n * n * logn)\\n             maxi = max(maxi,currMax);\\n            }\\n            sum += maxi;\\n        }\\n    return sum;\\n    }\\n};\\n```\\n# Sorting + Constant Space\\n- Time complexity: $$O(n^2logn)$$ \\n\\n- Space complexity: $$O(1)$$ \\n\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n     int sum = 0;\\n        for(int i=0; i<nums.size(); i++)     //.....O(n)\\n         sort(nums[i].begin(),nums[i].end()); //....O(n * nlogn)\\n\\n        for(int j=0; j<nums[0].size(); j++) //......O(n)\\n        {\\n            int maxi = INT_MIN;\\n            for(int i=0; i<nums.size(); i++) //......O(n * n)\\n            {\\n             maxi = max(maxi,nums[i][j]);\\n            }\\n            sum += maxi;\\n        }\\n     return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int n = nums[0].size();\\n        vector<priority_queue<int>> pq;\\n\\n        for(int i=0; i<nums.size(); i++) //....O(n)\\n        {\\n            priority_queue<int> temp;\\n            for(auto it : nums[i])  //.........O(n * n)\\n             temp.push(it);         //.........O(n * n * logn)\\n            pq.push_back(temp);\\n        }\\n\\n    int sum = 0;\\n        while(n--)                            //........O(n)\\n        {\\n            int maxi = INT_MIN;\\n            for(int i=0; i<nums.size(); i++) //........O(n * n)\\n            {\\n             int currMax = pq[i].top(); pq[i].pop(); //...O(n * n * logn)\\n             maxi = max(maxi,currMax);\\n            }\\n            sum += maxi;\\n        }\\n    return sum;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n     int sum = 0;\\n        for(int i=0; i<nums.size(); i++)     //.....O(n)\\n         sort(nums[i].begin(),nums[i].end()); //....O(n * nlogn)\\n\\n        for(int j=0; j<nums[0].size(); j++) //......O(n)\\n        {\\n            int maxi = INT_MIN;\\n            for(int i=0; i<nums.size(); i++) //......O(n * n)\\n            {\\n             maxi = max(maxi,nums[i][j]);\\n            }\\n            sum += maxi;\\n        }\\n     return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3777968,
                "title": "first-sort-each-row-and-then-solve",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n        int ans = 0;\\n         for(int[] a :nums)\\n        {\\n            Arrays.sort(a);\\n        }\\n        for(int i = 0; i<nums[0].length;i++){\\n            int x = 0;\\n            for(int j = 0 ; j < nums.length ;j++){\\n                x = Math.max(x,nums[j][i]);\\n            }\\n            ans = ans + x;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sorting",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n        int ans = 0;\\n         for(int[] a :nums)\\n        {\\n            Arrays.sort(a);\\n        }\\n        for(int i = 0; i<nums[0].length;i++){\\n            int x = 0;\\n            for(int j = 0 ; j < nums.length ;j++){\\n                x = Math.max(x,nums[j][i]);\\n            }\\n            ans = ans + x;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3777498,
                "title": "simple-iterative-beginner-friendly-beats-85",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n        int n=nums.length;\\n        int m=nums[0].length;\\n        int score=0;\\n        for(int[] a:nums){\\n            Arrays.sort(a);\\n        }\\n        int max;\\n        for(int i=0;i<m;i++){\\n            max=0;\\n            for(int j=0;j<n;j++){\\n                if(max<nums[j][i]){\\n                    max=nums[j][i];\\n                }\\n            }\\n            score+=max;\\n        }\\n        return score;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sort",
                    "Matrix",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n        int n=nums.length;\\n        int m=nums[0].length;\\n        int score=0;\\n        for(int[] a:nums){\\n            Arrays.sort(a);\\n        }\\n        int max;\\n        for(int i=0;i<m;i++){\\n            max=0;\\n            for(int j=0;j<n;j++){\\n                if(max<nums[j][i]){\\n                    max=nums[j][i];\\n                }\\n            }\\n            score+=max;\\n        }\\n        return score;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3773631,
                "title": "sort-rows-93-speed",
                "content": "![image.png](https://assets.leetcode.com/users/images/675be2ed-c21b-4d61-b091-59b16337d403_1689511656.978553.png)\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def matrixSum(self, nums: List[List[int]]) -> int:\\n        for i in range(len(nums)):\\n            nums[i].sort()\\n        return sum(max(col) for col in zip(*nums))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def matrixSum(self, nums: List[List[int]]) -> int:\\n        for i in range(len(nums)):\\n            nums[i].sort()\\n        return sum(max(col) for col in zip(*nums))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3764942,
                "title": "dart-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  int matrixSum(List<List<int>> nums) {\\n  for(List<int> sublist in nums) {\\n    sublist.sort((a,b) => b.compareTo(a));\\n  }\\n  List<List<int>> output = [];\\n  for(int i = 0; i < nums[0].length; i++) {\\n    List<int> firstNumbers = [];\\n    for(List<int> sublist in nums) {\\n      firstNumbers.add(sublist[i]);\\n    }\\n    output.add(firstNumbers);\\n  }\\n  List<int> maxNumbers = output.map((e) => e.reduce((value, element) => value > element ? value : element)).toList();\\n  int result = maxNumbers.reduce((value, element) => value + element);\\n  return result;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  int matrixSum(List<List<int>> nums) {\\n  for(List<int> sublist in nums) {\\n    sublist.sort((a,b) => b.compareTo(a));\\n  }\\n  List<List<int>> output = [];\\n  for(int i = 0; i < nums[0].length; i++) {\\n    List<int> firstNumbers = [];\\n    for(List<int> sublist in nums) {\\n      firstNumbers.add(sublist[i]);\\n    }\\n    output.add(firstNumbers);\\n  }\\n  List<int> maxNumbers = output.map((e) => e.reduce((value, element) => value > element ? value : element)).toList();\\n  int result = maxNumbers.reduce((value, element) => value + element);\\n  return result;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3734978,
                "title": "sum-in-a-matrix-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2logn)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        vector<priority_queue<int>> arr;\\n        priority_queue<int> pq;\\n        int i, j, sum=0;\\n        for(i=0 ; i<nums.size() ; i++)\\n        {\\n            for(j=0 ; j<nums[i].size() ; j++)\\n            {\\n                pq.push(nums[i][j]);\\n            }\\n            arr.push_back(pq);\\n            pq = priority_queue<int>();\\n        }\\n        while(!arr[0].empty())\\n        {\\n            for(i=0 ; i<arr.size() ; i++)\\n            {\\n                pq.push(arr[i].top());\\n                arr[i].pop();\\n            }\\n            sum += pq.top();\\n            pq = priority_queue<int>();\\n        }\\n        return sum;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/09e11844-d0db-4c82-89c4-38a3a4227feb_1688796804.6589239.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        vector<priority_queue<int>> arr;\\n        priority_queue<int> pq;\\n        int i, j, sum=0;\\n        for(i=0 ; i<nums.size() ; i++)\\n        {\\n            for(j=0 ; j<nums[i].size() ; j++)\\n            {\\n                pq.push(nums[i][j]);\\n            }\\n            arr.push_back(pq);\\n            pq = priority_queue<int>();\\n        }\\n        while(!arr[0].empty())\\n        {\\n            for(i=0 ; i<arr.size() ; i++)\\n            {\\n                pq.push(arr[i].top());\\n                arr[i].pop();\\n            }\\n            sum += pq.top();\\n            pq = priority_queue<int>();\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3724727,
                "title": "c-sort-and-traverse",
                "content": "```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        for(auto&i:nums)sort(begin(i),end(i),greater<>());\\n        int ans=0;\\n        for(int i=0;i<size(nums[0]);++i){\\n            int mx=0;\\n            for(auto&j:nums)mx=max(mx,j[i]);\\n            ans+=mx;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        for(auto&i:nums)sort(begin(i),end(i),greater<>());\\n        int ans=0;\\n        for(int i=0;i<size(nums[0]);++i){\\n            int mx=0;\\n            for(auto&j:nums)mx=max(mx,j[i]);\\n            ans+=mx;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3721064,
                "title": "arra",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n 1. Sort each row of nums\\n 2. take Jth element from each row of array in each iteration\\n\\n\\n# Complexity\\n- Time complexity: O(M*N)\\n\\n- Space complexity:O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int m = nums[0].size();\\n        int n = nums.size();\\n        int t = m;\\n        int ans = 0;\\n        for(int i=0;i<n;i++){\\n            sort(nums[i].begin(), nums[i].end());\\n        }\\n        for(int j=0;j<m;j++){\\n            int newMax = -1;\\n            for(int i=0;i<n;i++){\\n                newMax = max(newMax, nums[i][j]);\\n            }\\n            ans += newMax;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sorting",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int m = nums[0].size();\\n        int n = nums.size();\\n        int t = m;\\n        int ans = 0;\\n        for(int i=0;i<n;i++){\\n            sort(nums[i].begin(), nums[i].end());\\n        }\\n        for(int j=0;j<m;j++){\\n            int newMax = -1;\\n            for(int i=0;i<n;i++){\\n                newMax = max(newMax, nums[i][j]);\\n            }\\n            ans += newMax;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3714469,
                "title": "innovative-and-easiest-soln-using-arrays-sort",
                "content": "# Approach\\n- We sort the Arrays at each Index of ```nums```.\\n- We Dynamically Sort the ```nums``` using ```sortbyColumn``` function by decreasing value of ```i```, which ensures that the highest numbers of all removing row numbers occurs at ```nums[0][i]```.\\n\\n\\n# Code\\n```\\nclass Solution {\\n\\n    // Sorting of 2D Array by Column\\n    public static void sortbyColumn(int arr[][], int col){\\n      Arrays.sort(arr, (a, b) -> Integer.compare(b[col],a[col]));\\n    }\\n\\n    // Solution\\n    public int matrixSum(int[][] nums) {\\n        for(int i=0; i<nums.length; i++){\\n            Arrays.sort(nums[i]);\\n        }\\n        int finalScore=0;\\n        int i=nums[0].length-1;\\n        while(i>=0){\\n            sortbyColumn(nums,i);\\n            finalScore+=nums[0][i];\\n            i--;\\n        }\\n        return finalScore;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sorting",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```nums```\n```nums```\n```sortbyColumn```\n```i```\n```nums[0][i]```\n```\\nclass Solution {\\n\\n    // Sorting of 2D Array by Column\\n    public static void sortbyColumn(int arr[][], int col){\\n      Arrays.sort(arr, (a, b) -> Integer.compare(b[col],a[col]));\\n    }\\n\\n    // Solution\\n    public int matrixSum(int[][] nums) {\\n        for(int i=0; i<nums.length; i++){\\n            Arrays.sort(nums[i]);\\n        }\\n        int finalScore=0;\\n        int i=nums[0].length-1;\\n        while(i>=0){\\n            sortbyColumn(nums,i);\\n            finalScore+=nums[0][i];\\n            i--;\\n        }\\n        return finalScore;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3714227,
                "title": "basic-c-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n           int ans = 0;\\n\\n        for(auto &i: nums){\\n            sort(i.begin(),i.end());\\n        }\\n        for(int j = 0; j < nums[i].size(); j++){\\n            x = 0;\\n            for(int i = 0; i < nums.size(); i++){\\n                x = max(x,nums[i][j]);\\n            }\\n            ans += x;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n           int ans = 0;\\n\\n        for(auto &i: nums){\\n            sort(i.begin(),i.end());\\n        }\\n        for(int j = 0; j < nums[i].size(); j++){\\n            x = 0;\\n            for(int i = 0; i < nums.size(); i++){\\n                x = max(x,nums[i][j]);\\n            }\\n            ans += x;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3709635,
                "title": "sort-2d-array-find-largest-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        \\n        int m=nums.size();\\n        int n=nums[0].size();\\n        for(int i=0;i<m;i++) sort(nums[i].begin(),nums[i].end());\\n        int ans=0;\\n        for(int j=0;j<n;j++)\\n        {\\n            int maxi=INT_MIN;\\n            for(int i=0;i<m;i++)\\n            {\\n                maxi=max(maxi,nums[i][j]);\\n            }\\n            ans+=maxi;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        \\n        int m=nums.size();\\n        int n=nums[0].size();\\n        for(int i=0;i<m;i++) sort(nums[i].begin(),nums[i].end());\\n        int ans=0;\\n        for(int j=0;j<n;j++)\\n        {\\n            int maxi=INT_MIN;\\n            for(int i=0;i<m;i++)\\n            {\\n                maxi=max(maxi,nums[i][j]);\\n            }\\n            ans+=maxi;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3708522,
                "title": "python3-2-liner",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def matrixSum(self, grid: List[List[int]]) -> int:\\n        \\n        for i in range(len(grid)): grid[i].sort(reverse = True)\\n\\n        return sum(max(i)for i in [[grid[j][i] for j in range(len(grid))] for i in range(len(grid[0]))])\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def matrixSum(self, grid: List[List[int]]) -> int:\\n        \\n        for i in range(len(grid)): grid[i].sort(reverse = True)\\n\\n        return sum(max(i)for i in [[grid[j][i] for j in range(len(grid))] for i in range(len(grid[0]))])\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3703037,
                "title": "c-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(n^3)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int sum = 0;\\n        int maxAmongstAll = 0;\\n        for (int i = 0; i < nums[0].size(); i++) {\\n            maxAmongstAll = 0;\\n            for (int j = 0; j < nums.size(); j++) {\\n                vector<int> maxInRow{0, 0};\\n                for (int k = 0; k < nums[j].size(); k++) {\\n                    if (maxInRow[0] < nums[j][k]) {\\n                        maxInRow[0] = nums[j][k];\\n                        maxInRow[1] = k;\\n                    }\\n                }\\n                nums[j][maxInRow[1]] = 0;\\n                if (maxAmongstAll < maxInRow[0]) maxAmongstAll = maxInRow[0];\\n            }\\n            sum += maxAmongstAll;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int sum = 0;\\n        int maxAmongstAll = 0;\\n        for (int i = 0; i < nums[0].size(); i++) {\\n            maxAmongstAll = 0;\\n            for (int j = 0; j < nums.size(); j++) {\\n                vector<int> maxInRow{0, 0};\\n                for (int k = 0; k < nums[j].size(); k++) {\\n                    if (maxInRow[0] < nums[j][k]) {\\n                        maxInRow[0] = nums[j][k];\\n                        maxInRow[1] = k;\\n                    }\\n                }\\n                nums[j][maxInRow[1]] = 0;\\n                if (maxAmongstAll < maxInRow[0]) maxAmongstAll = maxInRow[0];\\n            }\\n            sum += maxAmongstAll;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3701690,
                "title": "99-faster-solution-java",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n        int score = 0;\\n        int max = Integer.MIN_VALUE;\\n\\n        for(int i = 0;i<nums.length;i++){\\n            Arrays.sort(nums[i]);\\n        }\\n\\n        for(int i = nums[0].length-1;i>=0;i--){\\n            max=0;\\n            for(int j = 0;j<nums.length;j++){\\n                max = Math.max(max,nums[j][i]);\\n            }\\n            score+=max;\\n        }\\n        return score;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n        int score = 0;\\n        int max = Integer.MIN_VALUE;\\n\\n        for(int i = 0;i<nums.length;i++){\\n            Arrays.sort(nums[i]);\\n        }\\n\\n        for(int i = nums[0].length-1;i>=0;i--){\\n            max=0;\\n            for(int j = 0;j<nums.length;j++){\\n                max = Math.max(max,nums[j][i]);\\n            }\\n            score+=max;\\n        }\\n        return score;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3699493,
                "title": "python-simple-python-solution-using-greedy",
                "content": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 785 ms, faster than 44.04% of Python3 online submissions for Sum in a Matrix.\\n# Memory Usage: 34.5 MB, less than 61.84% of Python3 online submissions for Sum in a Matrix.\\n\\n\\tclass Solution:\\n\\t\\tdef matrixSum(self, nums: List[List[int]]) -> int:\\n\\n\\t\\t\\tresult = 0\\n\\n\\t\\t\\tfor index in range(len(nums)):\\n\\n\\t\\t\\t\\tnums[index] = sorted(nums[index])[::-1]\\n\\n\\t\\t\\tfor col in range(len(nums[0])):\\n\\n\\t\\t\\t\\tcurrent_max = -1\\n\\n\\t\\t\\t\\tfor row in range(len(nums)):\\n\\n\\t\\t\\t\\t\\tcurrent_max = max(current_max, nums[row][col])\\n\\n\\t\\t\\t\\tresult = result + current_max\\n\\n\\t\\t\\treturn result\\n\\t\\t\\t\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Sorting",
                    "Matrix"
                ],
                "code": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 785 ms, faster than 44.04% of Python3 online submissions for Sum in a Matrix.\\n# Memory Usage: 34.5 MB, less than 61.84% of Python3 online submissions for Sum in a Matrix.\\n\\n\\tclass Solution:\\n\\t\\tdef matrixSum(self, nums: List[List[int]]) -> int:\\n\\n\\t\\t\\tresult = 0\\n\\n\\t\\t\\tfor index in range(len(nums)):\\n\\n\\t\\t\\t\\tnums[index] = sorted(nums[index])[::-1]\\n\\n\\t\\t\\tfor col in range(len(nums[0])):\\n\\n\\t\\t\\t\\tcurrent_max = -1\\n\\n\\t\\t\\t\\tfor row in range(len(nums)):\\n\\n\\t\\t\\t\\t\\tcurrent_max = max(current_max, nums[row][col])\\n\\n\\t\\t\\t\\tresult = result + current_max\\n\\n\\t\\t\\treturn result\\n\\t\\t\\t\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "codeTag": "Java"
            },
            {
                "id": 3699447,
                "title": "easy-explained-approach-for-o-n-m",
                "content": "# Intuition\\nTake array of priority_queues and for no of elements in a col take the top element of all rows and add the maximum of them in answer.\\nthis is repeated for col times.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N*M)\\n\\n- Space complexity:\\nO(N*M)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        vector<priority_queue<int>>arr(nums.size());\\n        for(int i=0;i<nums.size();i++){\\n            for(auto j:nums[i]){\\n                arr[i].push(j);\\n            }\\n        }\\n        int ans=0;\\n        for(int i=0;i<nums[0].size();i++){\\n            int val=0;\\n            for(int j=0;j<nums.size();j++){\\n                val=max(val,arr[j].top());\\n                arr[j].pop();\\n            }\\n            ans+=val;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        vector<priority_queue<int>>arr(nums.size());\\n        for(int i=0;i<nums.size();i++){\\n            for(auto j:nums[i]){\\n                arr[i].push(j);\\n            }\\n        }\\n        int ans=0;\\n        for(int i=0;i<nums[0].size();i++){\\n            int val=0;\\n            for(int j=0;j<nums.size();j++){\\n                val=max(val,arr[j].top());\\n                arr[j].pop();\\n            }\\n            ans+=val;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3694236,
                "title": "beginner-friendly-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) \\n    {\\n        int row=nums.size();\\n        int col=nums[0].size();\\n        int max=INT_MIN;\\n        int sum=0;\\n        for(int i = 0 ; i < row ; i++)\\n         {\\n            sort(nums[i].begin(),nums[i].end());\\n         }\\n        for(int i=0;i<col;i++)\\n        {\\n            int max=INT_MIN;\\n            int val=0;\\n            for(int j=0;j<row;j++)\\n            {\\n                val=nums[j][i];\\n                {\\n                    if(val>max)\\n                    {\\n                        max=val;\\n                    }\\n                }\\n            }\\n            sum+=max;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) \\n    {\\n        int row=nums.size();\\n        int col=nums[0].size();\\n        int max=INT_MIN;\\n        int sum=0;\\n        for(int i = 0 ; i < row ; i++)\\n         {\\n            sort(nums[i].begin(),nums[i].end());\\n         }\\n        for(int i=0;i<col;i++)\\n        {\\n            int max=INT_MIN;\\n            int val=0;\\n            for(int j=0;j<row;j++)\\n            {\\n                val=nums[j][i];\\n                {\\n                    if(val>max)\\n                    {\\n                        max=val;\\n                    }\\n                }\\n            }\\n            sum+=max;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3692989,
                "title": "sorting-approach-java-simple-solution-clean-code",
                "content": "# Complexity\\nLet `n = nums.length`\\n`m = nums[0].length`\\n- Time complexity: $O(n \\\\cdot m \\\\cdot log(m))$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(1)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```java\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n        int n = nums.length;\\n        int m = nums[0].length;\\n        for(int i = 0;i < n;i++){\\n            Arrays.sort(nums[i]);\\n        }\\n        int ans = 0;\\n        for(int j = 0;j < m;j++){\\n            int max = -1;\\n            for(int i = 0;i < n;i++){\\n                max = Math.max(max,nums[i][j]);\\n            }\\n            ans += max;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```java\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n        int n = nums.length;\\n        int m = nums[0].length;\\n        for(int i = 0;i < n;i++){\\n            Arrays.sort(nums[i]);\\n        }\\n        int ans = 0;\\n        for(int j = 0;j < m;j++){\\n            int max = -1;\\n            for(int i = 0;i < n;i++){\\n                max = Math.max(max,nums[i][j]);\\n            }\\n            ans += max;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3691916,
                "title": "java-simple-to-understand",
                "content": "```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n        for (int[] curr : nums) Arrays.sort(curr);\\n        int n = nums[0].length - 1, sum = 0;\\n        while (n >= 0) {\\n            int max = -1;\\n            for (int[] curr : nums) {\\n                max = Math.max(curr[n], max);\\n            }\\n            sum += max;\\n            n--;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n        for (int[] curr : nums) Arrays.sort(curr);\\n        int n = nums[0].length - 1, sum = 0;\\n        while (n >= 0) {\\n            int max = -1;\\n            for (int[] curr : nums) {\\n                max = Math.max(curr[n], max);\\n            }\\n            sum += max;\\n            n--;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3676623,
                "title": "priority-queue-step-wise-easy-to-understand",
                "content": "# Intuition\\nWe need to traverse through the sub_arrays in side the main array and find the maximum of those sub_arrays , then from the list of those maximums we want the maximum and store it .\\n\\nWe need to repeat the above iteration for len(sub_array.) The length of sub_arrays has to be equal.\\n\\n# Approach\\nThe first loop takes care of the fact that the process needs to run for the len(sub_array)\\nThe inner for loop is picking up the sub_array and finding out the maximum.\\n\\nNext I have used a Priority queue which will store the maximum(maximum) and by the use of get() function, I get the first value that needs to be added in the total sum.\\n\\n# Complexity\\nSpace = O(n)\\nTime = O(kn)\\n\\nPLEASE UPVOTE IF YOU LIKE THE SOLUTION!!\\n# Code\\n```\\nfrom queue import PriorityQueue\\nclass Solution:\\n    def matrixSum(self, nums: List[List[int]]) -> int:\\n        sm=0\\n        k=len(nums[0])\\n        while(k>0):\\n            pq=PriorityQueue()\\n            for i in nums:\\n                #pq=PriorityQueue()\\n                i.sort()\\n                val=i[len(i)-1]\\n                i[len(i)-1]=0\\n                pq.put(-1*val)\\n            sm+=(-1*pq.get())\\n            k-=1\\n        print(sm)\\n        return sm\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nfrom queue import PriorityQueue\\nclass Solution:\\n    def matrixSum(self, nums: List[List[int]]) -> int:\\n        sm=0\\n        k=len(nums[0])\\n        while(k>0):\\n            pq=PriorityQueue()\\n            for i in nums:\\n                #pq=PriorityQueue()\\n                i.sort()\\n                val=i[len(i)-1]\\n                i[len(i)-1]=0\\n                pq.put(-1*val)\\n            sm+=(-1*pq.get())\\n            k-=1\\n        print(sm)\\n        return sm\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3658363,
                "title": "c-solution-explain-with-comments",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int ans = 0;\\n\\n        // sorting every row in decending order\\n        // so that highest value will shift to left side\\n        // then we can easily eliminate highest value\\n\\n        for(auto &val : nums){\\n            sort(val.rbegin(),val.rend());\\n        }\\n\\n        // looping column wise (top to bottom) first to get the highest value and then row wise (left to right).\\n        // add it to ans\\n\\n        for(int i=0;i<nums[0].size();i++){\\n\\n            int toBeAdded = 0;\\n\\n            for(int j=0;j<nums.size();j++){\\n                toBeAdded = max(toBeAdded,nums[j][i]);\\n            }\\n\\n            ans += toBeAdded;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int ans = 0;\\n\\n        // sorting every row in decending order\\n        // so that highest value will shift to left side\\n        // then we can easily eliminate highest value\\n\\n        for(auto &val : nums){\\n            sort(val.rbegin(),val.rend());\\n        }\\n\\n        // looping column wise (top to bottom) first to get the highest value and then row wise (left to right).\\n        // add it to ans\\n\\n        for(int i=0;i<nums[0].size();i++){\\n\\n            int toBeAdded = 0;\\n\\n            for(int j=0;j<nums.size();j++){\\n                toBeAdded = max(toBeAdded,nums[j][i]);\\n            }\\n\\n            ans += toBeAdded;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3657775,
                "title": "using-priority-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(0);\\n        int n=nums.size();\\n        int m=nums[0].size();\\n        priority_queue<int>pq[n];\\n        for(int i=0;i<nums.size();i++){\\n            priority_queue<int>q;\\n            for(int j=0;j<nums[i].size();j++){\\n                q.push(nums[i][j]);\\n            }\\n            pq[i]=q;\\n        }\\n        int ans=0;\\n        for(int i=0;i<m;i++){\\n            int curr_max=0;\\n            for(int j=0;j<n;j++){\\n                curr_max=max(curr_max,pq[j].top());\\n                pq[j].pop();\\n            }\\n            cout<<curr_max<<endl;\\n            ans+=curr_max;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(0);\\n        int n=nums.size();\\n        int m=nums[0].size();\\n        priority_queue<int>pq[n];\\n        for(int i=0;i<nums.size();i++){\\n            priority_queue<int>q;\\n            for(int j=0;j<nums[i].size();j++){\\n                q.push(nums[i][j]);\\n            }\\n            pq[i]=q;\\n        }\\n        int ans=0;\\n        for(int i=0;i<m;i++){\\n            int curr_max=0;\\n            for(int j=0;j<n;j++){\\n                curr_max=max(curr_max,pq[j].top());\\n                pq[j].pop();\\n            }\\n            cout<<curr_max<<endl;\\n            ans+=curr_max;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3655498,
                "title": "easy-c-solution-simple-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int count=0;\\n        for(int i=0;i<nums.size();i++){\\n            sort(nums[i].begin(),nums[i].end());\\n            reverse(nums[i].begin(),nums[i].end());\\n        }\\n        for(int j=0;j<nums[0].size();j++){\\n            int ans=0;\\n            for(int i=0;i<nums.size();i++){\\n                ans=max(ans,nums[i][j]);\\n            }\\n            count+=ans;\\n        }\\n        return count;\\n    }\\n};\\n```\\nPLEASE UPVOTE \\u2B06\\uFE0F\\u2B06\\uFE0F IF YOU LIKE THE SOLUTION !!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int count=0;\\n        for(int i=0;i<nums.size();i++){\\n            sort(nums[i].begin(),nums[i].end());\\n            reverse(nums[i].begin(),nums[i].end());\\n        }\\n        for(int j=0;j<nums[0].size();j++){\\n            int ans=0;\\n            for(int i=0;i<nums.size();i++){\\n                ans=max(ans,nums[i][j]);\\n            }\\n            count+=ans;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3655461,
                "title": "very-easy-solution-beginner-friendly-c-sorting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\njust traversing the matrix and finding the max and adding to the answer after sorting each row of the matrix\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(m*n) + O(n*m*logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int row = 0;\\n\\n        int n = nums.size(); // columns\\n        int m = nums[0].size(); // rows\\n        // cout << n <<\" \"<< m << endl;\\n        int ans = 0;\\n\\n        for(int i=0;i<n;i++){\\n            sort(nums[i].begin(),nums[i].end());\\n        }\\n        \\n        while(row < m){\\n            int currmax = INT_MIN;\\n            for(int col=0;col<n;col++){\\n                currmax = max(currmax,nums[col][row]);\\n            }\\n            cout << currmax << endl;\\n            ans+=currmax;\\n            row++;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int row = 0;\\n\\n        int n = nums.size(); // columns\\n        int m = nums[0].size(); // rows\\n        // cout << n <<\" \"<< m << endl;\\n        int ans = 0;\\n\\n        for(int i=0;i<n;i++){\\n            sort(nums[i].begin(),nums[i].end());\\n        }\\n        \\n        while(row < m){\\n            int currmax = INT_MIN;\\n            for(int col=0;col<n;col++){\\n                currmax = max(currmax,nums[col][row]);\\n            }\\n            cout << currmax << endl;\\n            ans+=currmax;\\n            row++;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3653498,
                "title": "c-sorting-2-d-vector-best-and-simple-approach",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int m=nums.size();\\n        int n=nums[0].size();\\n        int score=0;\\n        for(int i=0;i<m;i++)\\n        {\\n            sort(nums[i].begin(),nums[i].end());\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            int maximum=INT_MIN;\\n            for(int j=0;j<m;j++)\\n            {\\n               if(nums[j][i]>maximum)\\n               {\\n                   maximum=nums[j][i];\\n               }\\n            }\\n            score+=maximum;\\n        }\\n      return score;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int m=nums.size();\\n        int n=nums[0].size();\\n        int score=0;\\n        for(int i=0;i<m;i++)\\n        {\\n            sort(nums[i].begin(),nums[i].end());\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            int maximum=INT_MIN;\\n            for(int j=0;j<m;j++)\\n            {\\n               if(nums[j][i]>maximum)\\n               {\\n                   maximum=nums[j][i];\\n               }\\n            }\\n            score+=maximum;\\n        }\\n      return score;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3647598,
                "title": "java-easy-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n        int count=0;\\n     for(int i=0;i<nums.length;i++)\\n     {\\n         Arrays.sort(nums[i]);\\n     } \\n     \\n     for(int i=0;i<nums[0].length;i++)\\n     {\\n         int max=0;\\n         for(int j=0;j<nums.length;j++)\\n         {\\n             max=Math.max(max,nums[j][i]);\\n         }\\n         count+=max;\\n     } \\n     return count; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n        int count=0;\\n     for(int i=0;i<nums.length;i++)\\n     {\\n         Arrays.sort(nums[i]);\\n     } \\n     \\n     for(int i=0;i<nums[0].length;i++)\\n     {\\n         int max=0;\\n         for(int j=0;j<nums.length;j++)\\n         {\\n             max=Math.max(max,nums[j][i]);\\n         }\\n         count+=max;\\n     } \\n     return count; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3646869,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n         for(int i=0;i<nums.length;i++) {\\n            Arrays.sort(nums[i]);\\n        }\\n        int sum=0;\\n        for(int i=0;i<nums[0].length;i++){\\n            int max=0;\\n            for(int j=0;j<nums.length;j++){\\n                if(nums[j][i]>max){\\n                    max=nums[j][i];\\n                }\\n            }\\n            sum+=max;\\n        }\\n        return sum;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n         for(int i=0;i<nums.length;i++) {\\n            Arrays.sort(nums[i]);\\n        }\\n        int sum=0;\\n        for(int i=0;i<nums[0].length;i++){\\n            int max=0;\\n            for(int j=0;j<nums.length;j++){\\n                if(nums[j][i]>max){\\n                    max=nums[j][i];\\n                }\\n            }\\n            sum+=max;\\n        }\\n        return sum;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3646868,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n         for(int i=0;i<nums.length;i++) {\\n            Arrays.sort(nums[i]);\\n        }\\n        int sum=0;\\n        for(int i=0;i<nums[0].length;i++){\\n            int max=0;\\n            for(int j=0;j<nums.length;j++){\\n                if(nums[j][i]>max){\\n                    max=nums[j][i];\\n                }\\n            }\\n            sum+=max;\\n        }\\n        return sum;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n         for(int i=0;i<nums.length;i++) {\\n            Arrays.sort(nums[i]);\\n        }\\n        int sum=0;\\n        for(int i=0;i<nums[0].length;i++){\\n            int max=0;\\n            for(int j=0;j<nums.length;j++){\\n                if(nums[j][i]>max){\\n                    max=nums[j][i];\\n                }\\n            }\\n            sum+=max;\\n        }\\n        return sum;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3642902,
                "title": "elegant-python-solution-that-beats-92-44",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nsort the row first, then select the highest num in each column and add it to the score.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity can be analyzed as follows:\\n\\n1. Sorting each row in the matrix: For each row, the `sort()` function is `O(n log n)`, where `n` is the number of elements in the row. If there are `m` rows in the matrix, the total time complexity for this part is `O(m * n log n)`.\\n2. The `zip(*nums)` operation: This operation transposes the matrix (turns rows into columns and vice versa), which is an `O(m * n)` operation, where `m` is the number of rows and `n` is the number of columns.\\n3. Calculating the maximum of each column and adding it to the score: For each column, the `max()` function is `O(m)`, where `m` is the number of rows. Since this is done for each of the n columns, the total time complexity for this part is `O(m * n)`.\\n\\nSo, the overall time complexity of this code is `O(m * n log n)` for the sorting part plus `O(m * n)` for the transposing and summing part. Therefore, the overall time complexity is `O(m * n log n + m * n)`. If `m` and `n` are roughly equal, this simplifies to `O(n^2 log n)`, where `n` is the number of elements in a row or column.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of this function is `O(m * n)`, because the `zip(*nums)` operation creates a new transposed copy of the matrix in memory. This assumes that the sorting is done in-place (which is true for Python\\'s built-in sort() function). If the matrix is very large, this could be a significant amount of space.\\n\\n# Code\\n```\\nclass Solution:\\n    def matrixSum(self, nums: List[List[int]]) -> int:\\n        score = 0\\n\\n        for row in nums:\\n            row.sort(reverse=True)\\n        \\n        for col in zip(*nums):\\n            score += max(col)\\n\\n        return score\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def matrixSum(self, nums: List[List[int]]) -> int:\\n        score = 0\\n\\n        for row in nums:\\n            row.sort(reverse=True)\\n        \\n        for col in zip(*nums):\\n            score += max(col)\\n\\n        return score\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3642045,
                "title": "sum-in-a-matrix",
                "content": "```\\nclass Solution:\\n    def matrixSum(self, nums: List[List[int]]) -> int:\\n        maxrow = []\\n        final_score = 0\\n        i = 0\\n        while i < len(nums[0]):\\n            maxrow.clear()\\n            for num in nums:\\n                num.sort(reverse = True)\\n                maxrow.append(num[i])\\n            final_score += max(maxrow)\\n            i += 1\\n        return final_score\\n```\\nAny doubt please ask",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def matrixSum(self, nums: List[List[int]]) -> int:\\n        maxrow = []\\n        final_score = 0\\n        i = 0\\n        while i < len(nums[0]):\\n            maxrow.clear()\\n            for num in nums:\\n                num.sort(reverse = True)\\n                maxrow.append(num[i])\\n            final_score += max(maxrow)\\n            i += 1\\n        return final_score\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3628724,
                "title": "max-heap-java-simple-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int matrixSum(int[][] nums) { \\n      int sum=0;\\n      for(int i=0;i<nums.length;i++){\\n        Arrays.sort(nums[i]);\\n      }\\n      for(int i=0;i<nums[0].length;i++){\\n          Queue<Integer> max=new PriorityQueue<>(Collections.reverseOrder());\\n          for(int j=0;j<nums.length;j++){\\n          max.add(nums[j][i]);\\n          }\\n          sum+=max.peek();\\n      }\\n    return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int matrixSum(int[][] nums) { \\n      int sum=0;\\n      for(int i=0;i<nums.length;i++){\\n        Arrays.sort(nums[i]);\\n      }\\n      for(int i=0;i<nums[0].length;i++){\\n          Queue<Integer> max=new PriorityQueue<>(Collections.reverseOrder());\\n          for(int j=0;j<nums.length;j++){\\n          max.add(nums[j][i]);\\n          }\\n          sum+=max.peek();\\n      }\\n    return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3610596,
                "title": "sort-then-add-to-score",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MatrixSum(int[][] nums) {\\n       var sum=0;\\n       var x=nums.Length;\\n       var y=nums[0].Length;\\n       for (var i=0;i<x;i++)\\n       Array.Sort(nums[i]);\\n        for(var i=0;i<y;i++)\\n        {\\n            var top=nums[0][i];\\n            for(var j=0;j<x;j++)\\n            {\\n                if(nums[j][i]>top)\\n                top=nums[j][i];\\n\\n            }\\n            sum+=top;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MatrixSum(int[][] nums) {\\n       var sum=0;\\n       var x=nums.Length;\\n       var y=nums[0].Length;\\n       for (var i=0;i<x;i++)\\n       Array.Sort(nums[i]);\\n        for(var i=0;i<y;i++)\\n        {\\n            var top=nums[0][i];\\n            for(var j=0;j<x;j++)\\n            {\\n                if(nums[j][i]>top)\\n                top=nums[j][i];\\n\\n            }\\n            sum+=top;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3608050,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n       int x,sum=0;\\n       for(int i=0;i<nums.size();i++){\\n           sort(nums[i].begin(),nums[i].end());\\n       }\\n       int n=nums.size();int m=nums[0].size();\\n       for(int i=0;i<m;i++){\\n           x=0;\\n           for(int j=0;j<n;j++){\\n             x=max(x,nums[j][i]);\\n           }\\n           sum+=x;\\n       }\\n        return sum;\\n          \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n       int x,sum=0;\\n       for(int i=0;i<nums.size();i++){\\n           sort(nums[i].begin(),nums[i].end());\\n       }\\n       int n=nums.size();int m=nums[0].size();\\n       for(int i=0;i<m;i++){\\n           x=0;\\n           for(int j=0;j<n;j++){\\n             x=max(x,nums[j][i]);\\n           }\\n           sum+=x;\\n       }\\n        return sum;\\n          \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3606648,
                "title": "java-sort-and-loop",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe need pick the max-value from the each row and add it up to our result; those value are not considerd further. So, if the 2D arrays is sorted, we just need to add up the max-value in each column.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. sort the 2D array\\n2. in a loop, we add up the max-value in the column. \\n        !!!Since we are comparing value in column, so the outer loop index will be the #of column, and we comparing them by the #of how many row\\n3. get the max value and add it to the result\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nrow = n; col=m\\nO(n*mlogm)[sort] + O(n*m)[for-loop] -> O(n*mlogm)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(log m) due to the recursive nature of the sorting algorithms used. \\n# Code\\n```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n        int result = 0;\\n\\n        for(int[] rows : nums){\\n            Arrays.sort(rows);\\n        }\\n\\n        for(int col=0; col<nums[0].length; ++col){\\n            int val = 0;\\n            for(int row=0; row<nums.length; ++row){\\n                int cur = nums[row][col];\\n                if(cur > val)\\n                    val = cur;\\n            }\\n            result += val;\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n        int result = 0;\\n\\n        for(int[] rows : nums){\\n            Arrays.sort(rows);\\n        }\\n\\n        for(int col=0; col<nums[0].length; ++col){\\n            int val = 0;\\n            for(int row=0; row<nums.length; ++row){\\n                int cur = nums[row][col];\\n                if(cur > val)\\n                    val = cur;\\n            }\\n            result += val;\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3604635,
                "title": "sum-in-a-matrix-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO (n*2logn)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int sum=0;\\n        for(int i=0;i<nums.size();i++){\\n            sort(nums[i].begin(),nums[i].end());\\n        }\\n          for(int j=0;j<nums[0].size();j++){\\n              int maxi=INT_MIN;\\n              for(int i=0;i<nums.size();i++){\\n                   if(maxi<nums[i][j]){\\n                       maxi=nums[i][j];\\n                   }\\n              }\\n              sum+=maxi;\\n          }\\n\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int sum=0;\\n        for(int i=0;i<nums.size();i++){\\n            sort(nums[i].begin(),nums[i].end());\\n        }\\n          for(int j=0;j<nums[0].size();j++){\\n              int maxi=INT_MIN;\\n              for(int i=0;i<nums.size();i++){\\n                   if(maxi<nums[i][j]){\\n                       maxi=nums[i][j];\\n                   }\\n              }\\n              sum+=maxi;\\n          }\\n\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3604561,
                "title": "sum-in-a-matrix",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def matrixSum(self, nums: List[List[int]]) -> int:\\n        sun=[]\\n        sun1=0\\n        x=len(nums[0])\\n        while x>=1:\\n            for i in nums:\\n                a=max(i)\\n                sun.append(a)\\n                nums[nums.index(i)].remove(a)\\n            sun1+=max(sun)\\n            sun.clear()\\n            x-=1\\n        return sun1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def matrixSum(self, nums: List[List[int]]) -> int:\\n        sun=[]\\n        sun1=0\\n        x=len(nums[0])\\n        while x>=1:\\n            for i in nums:\\n                a=max(i)\\n                sun.append(a)\\n                nums[nums.index(i)].remove(a)\\n            sun1+=max(sun)\\n            sun.clear()\\n            x-=1\\n        return sun1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3603629,
                "title": "java-sort-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n        int m = nums.length; int n = nums[0].length;\\n        for(int []row : nums ){\\n            Arrays.sort(row);\\n        }\\n        int []max = new int[n];\\n\\n        for(int i=0;i<m;i++){\\n            for(int j = 0;j<n;j++){\\n                max[j] = Math.max(max[j],nums[i][j]);\\n            }\\n        }\\n        int sum = 0;\\n        for(int e : max) sum+= e;\\n\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n        int m = nums.length; int n = nums[0].length;\\n        for(int []row : nums ){\\n            Arrays.sort(row);\\n        }\\n        int []max = new int[n];\\n\\n        for(int i=0;i<m;i++){\\n            for(int j = 0;j<n;j++){\\n                max[j] = Math.max(max[j],nums[i][j]);\\n            }\\n        }\\n        int sum = 0;\\n        for(int e : max) sum+= e;\\n\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3600012,
                "title": "one-line-solution",
                "content": "# Code\\n```\\nobject Solution {\\n  def matrixSum(nums: Array[Array[Int]]): Int = {\\n    nums.map(_.sorted).transpose.map(_.max).sum\\n  }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n  def matrixSum(nums: Array[Array[Int]]): Int = {\\n    nums.map(_.sorted).transpose.map(_.max).sum\\n  }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3599444,
                "title": "java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n   public int matrixSum(int[][] nums) { \\n        int sum=0;\\n        int n=nums[0].length,m=nums.length;\\n        for(int i=0;i<m;i++)\\n            Arrays.sort(nums[i]);\\n        for(int j=0;j<n;j++){\\n            int t=0;\\n            for(int i=0;i<m;i++)\\n                t=Math.max(t,nums[i][j]);\\n               sum+=t;\\n        }\\n        \\n        return sum;\\n}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n   public int matrixSum(int[][] nums) { \\n        int sum=0;\\n        int n=nums[0].length,m=nums.length;\\n        for(int i=0;i<m;i++)\\n            Arrays.sort(nums[i]);\\n        for(int j=0;j<n;j++){\\n            int t=0;\\n            for(int i=0;i<m;i++)\\n                t=Math.max(t,nums[i][j]);\\n               sum+=t;\\n        }\\n        \\n        return sum;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3598615,
                "title": "sum-in-a-matrix",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def matrixSum(self, nums):\\n        col=len(nums[0])\\n        row=len(nums)\\n        sum1=0\\n        for j in range(col):\\n            list1=[]\\n            for i in range(row):    \\n                if(len(nums[i])>0):\\n                    list1.append(max(nums[i]))\\n                nums[i].remove(max(nums[i]))\\n            if(len(list1)>0):\\n                print(list1)\\n                sum1+=max(list1)\\n        return sum1 \\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def matrixSum(self, nums):\\n        col=len(nums[0])\\n        row=len(nums)\\n        sum1=0\\n        for j in range(col):\\n            list1=[]\\n            for i in range(row):    \\n                if(len(nums[i])>0):\\n                    list1.append(max(nums[i]))\\n                nums[i].remove(max(nums[i]))\\n            if(len(list1)>0):\\n                print(list1)\\n                sum1+=max(list1)\\n        return sum1 \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3597767,
                "title": "kotlin-sorting-o-m-n-log-n",
                "content": "# Approach\\nSimply sort each row, then iterate down each column\\n\\n# Complexity\\n- Time complexity:\\nIf nums contains m rows of m items\\n$$O(m * n logn)$$ to sort each row, then $$O(m * n)$$ to iterate over each column to find the max. Therefore the limiting factor is the sort and overall complexity is \\n$$O(m * n logn)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    fun matrixSum(nums: Array<IntArray>): Int {\\n        var result = 0\\n\\n        nums.forEach { row ->\\n            row.sortDescending()\\n        }\\n\\n        for (i in 0 until nums[0].size) {\\n            var max = 0\\n\\n            for (j in 0 until nums.size) {\\n                max = maxOf(max, nums[j][i])    \\n            }\\n            result += max\\n        }\\n        \\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun matrixSum(nums: Array<IntArray>): Int {\\n        var result = 0\\n\\n        nums.forEach { row ->\\n            row.sortDescending()\\n        }\\n\\n        for (i in 0 until nums[0].size) {\\n            var max = 0\\n\\n            for (j in 0 until nums.size) {\\n                max = maxOf(max, nums[j][i])    \\n            }\\n            result += max\\n        }\\n        \\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3597377,
                "title": "using-vector-of-priority-queue",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsing Vector of priority queue\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n**0(NMlogM)**\\ntwo loops n*m and push operation takes log(size of heap)=0(M),\\nso total NM(logm)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n**0(NM)** \\n# Code\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int n=nums.size();\\n        int m=nums[0].size();\\n        vector<priority_queue<int>>vq(n);\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                vq[i].push(nums[i][j]);//pushing all row elements ,rowwise\\n            }\\n        }\\n        int score=0,total=0;\\n        for(int j=0;j<m;j++){\\n            score=-1;\\n            for(int i=0;i<n;i++){\\n                int t=vq[i].top(); //taking top element i.e., max elemnt of row\\n                vq[i].pop(); // remove that element\\n                score=max(score,t); //taking highest of all elements of row one by one\\n            }\\n            total+=score; //update total score\\n        }\\n        return total;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int n=nums.size();\\n        int m=nums[0].size();\\n        vector<priority_queue<int>>vq(n);\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                vq[i].push(nums[i][j]);//pushing all row elements ,rowwise\\n            }\\n        }\\n        int score=0,total=0;\\n        for(int j=0;j<m;j++){\\n            score=-1;\\n            for(int i=0;i<n;i++){\\n                int t=vq[i].top(); //taking top element i.e., max elemnt of row\\n                vq[i].pop(); // remove that element\\n                score=max(score,t); //taking highest of all elements of row one by one\\n            }\\n            total+=score; //update total score\\n        }\\n        return total;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3594745,
                "title": "simplest-solution-c-99",
                "content": "# Intuition & Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIn every iteration, we need to find the highest element among all the rows and add it to the score. In order to achieve that easily, we sort each rows in the matrix and in every iteration we take the highest among the ith element of each row.\\n\\n![Screenshot 2023-06-04 074039.png](https://assets.leetcode.com/users/images/ecc4ef67-44a3-4d34-b934-391ec919daf6_1685844859.9296994.png)\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N*NLogN) - as we sort N arrays\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1) - as we do not use any extra memory\\n\\n## Please upvote if you like the simple approach\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MatrixSum(int[][] nums) {\\n        for (int i = 0; i < nums.Length; i++)\\n        {\\n            Array.Sort(nums[i]);\\n        }\\n\\n        int score = 0;\\n        for (int j = 0; j < nums[0].Length; j++)\\n        {\\n            int max = nums[0][j];\\n            for (int i = 1; i < nums.Length; i++)\\n            {\\n                max = Math.Max(max, nums[i][j]);\\n            }\\n\\n            score += max;\\n        }\\n\\n        return score;\\n    }\\n}\\n```\\n## Please upvote if you like the simple approach\\n![Upvote please - steve.jpg](https://assets.leetcode.com/users/images/e338f844-9b25-4388-a447-044a1f6f6236_1685844958.3806489.jpeg)\\n",
                "solutionTags": [
                    "C#",
                    "Array",
                    "Sorting",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\npublic class Solution {\\n    public int MatrixSum(int[][] nums) {\\n        for (int i = 0; i < nums.Length; i++)\\n        {\\n            Array.Sort(nums[i]);\\n        }\\n\\n        int score = 0;\\n        for (int j = 0; j < nums[0].Length; j++)\\n        {\\n            int max = nums[0][j];\\n            for (int i = 1; i < nums.Length; i++)\\n            {\\n                max = Math.Max(max, nums[i][j]);\\n            }\\n\\n            score += max;\\n        }\\n\\n        return score;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3594594,
                "title": "just-sort-first-pointer-o-n-m",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def matrixSum(self, nums: List[List[int]]) -> int:\\n        res = 0\\n        m = len(nums)\\n        n = len(nums[0])\\n        j = n-1\\n        for i in range(m):\\n            nums[i].sort()\\n        \\n        for _ in range(n):\\n            mx = 0\\n            for i in range(m):\\n                \\n                mx = max(mx, nums[i][j])\\n            j -= 1\\n            res += mx\\n\\n\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def matrixSum(self, nums: List[List[int]]) -> int:\\n        res = 0\\n        m = len(nums)\\n        n = len(nums[0])\\n        j = n-1\\n        for i in range(m):\\n            nums[i].sort()\\n        \\n        for _ in range(n):\\n            mx = 0\\n            for i in range(m):\\n                \\n                mx = max(mx, nums[i][j])\\n            j -= 1\\n            res += mx\\n\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3594570,
                "title": "swift-one-liner",
                "content": "# Complexity\\n- Time complexity: $O(m\\\\cdot n)$\\n- Space complexity: $O(m\\\\cdot n)$\\n\\n## Code\\n```\\nclass Solution {\\n    func matrixSum(_ nums: [[Int]]) -> Int\\n    {\\n        nums[0].indices.reduce(into: (ns: nums.map{ $0.sorted(by: >) }, res: 0))\\n        {   data, j in \\n            data.res += data.ns[  data.ns.indices.max {i1, i2 in data.ns[i1][j] < data.ns[i2][j]}! ] [j]\\n        }.res\\n    }\\n}\\n```\\n## Terse Form\\n```\\n    func matrixSum(_ ns: [[Int]]) -> Int {\\n        ns[0].indices.reduce(into:(ns:ns.map{$0.sorted(by:>)},r:0)){d,j in d.r+=d.ns[d.ns.indices.max{d.ns[$0][j]<d.ns[$1][j]}!][j]}.r\\n    }\\n```",
                "solutionTags": [
                    "Swift",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    func matrixSum(_ nums: [[Int]]) -> Int\\n    {\\n        nums[0].indices.reduce(into: (ns: nums.map{ $0.sorted(by: >) }, res: 0))\\n        {   data, j in \\n            data.res += data.ns[  data.ns.indices.max {i1, i2 in data.ns[i1][j] < data.ns[i2][j]}! ] [j]\\n        }.res\\n    }\\n}\\n```\n```\\n    func matrixSum(_ ns: [[Int]]) -> Int {\\n        ns[0].indices.reduce(into:(ns:ns.map{$0.sorted(by:>)},r:0)){d,j in d.r+=d.ns[d.ns.indices.max{d.ns[$0][j]<d.ns[$1][j]}!][j]}.r\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3593460,
                "title": "easy-solution-in-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def matrixSum(self, nums: List[List[int]]) -> int:\\n\\n        temp =0\\n        maxnum = []\\n        while nums[0] != []:\\n            nums2 = []\\n            for j in range(0,len(nums)):\\n                nums2.append(max(nums[j]))\\n                nums[j].remove(max(nums[j]))\\n            maxnum.append(max(nums2))\\n        for i in maxnum:\\n            temp+=i\\n        return temp\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def matrixSum(self, nums: List[List[int]]) -> int:\\n\\n        temp =0\\n        maxnum = []\\n        while nums[0] != []:\\n            nums2 = []\\n            for j in range(0,len(nums)):\\n                nums2.append(max(nums[j]))\\n                nums[j].remove(max(nums[j]))\\n            maxnum.append(max(nums2))\\n        for i in maxnum:\\n            temp+=i\\n        return temp\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3593107,
                "title": "simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n^2logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int n=nums.size();\\n        int m=nums[0].size();\\n        int maxglob=INT_MIN;\\n        int score=0;\\n        for(int i=0;i<n;i++){\\n            sort(nums[i].begin(),nums[i].end());\\n        }\\n        for(int j=0;j<m;j++){\\n            int mxcol=INT_MIN;\\n            for(int i=0;i<n;i++){\\n                mxcol=max(mxcol,nums[i][j]);\\n            }\\n            score+=mxcol;\\n        }\\n        return score;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int n=nums.size();\\n        int m=nums[0].size();\\n        int maxglob=INT_MIN;\\n        int score=0;\\n        for(int i=0;i<n;i++){\\n            sort(nums[i].begin(),nums[i].end());\\n        }\\n        for(int j=0;j<m;j++){\\n            int mxcol=INT_MIN;\\n            for(int i=0;i<n;i++){\\n                mxcol=max(mxcol,nums[i][j]);\\n            }\\n            score+=mxcol;\\n        }\\n        return score;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1892461,
                "content": [
                    {
                        "username": "roboto7o32oo3",
                        "content": "This problem should be marked Easy....."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "how is your dp moving??"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "This problem is same as [2500. Delete Greatest Value in Each Row](https://leetcode.com/problems/delete-greatest-value-in-each-row/)"
                    },
                    {
                        "username": "abhijay_123",
                        "content": "Why sort ?\\nand why selecting the largest value in a column fails?"
                    },
                    {
                        "username": "vinnnu",
                        "content": "[@candy45](/candy45) thanks mate "
                    },
                    {
                        "username": "HarshitRaj_14",
                        "content": "[@arshikamishra](/arshikamishra) Because in every iteration we have to remove the maximum element from each row. \\nIt is not mandatory that the maximum element will always be at column number i so we sort every row in order to make sure that the maximum number is at ith column.\\nThe question has specifically asked us to - From each row in the matrix, select the largest number and remove it. So first sort it rowwise to get the largest element first.\\n \\nPlease upvote if you understood"
                    },
                    {
                        "username": "HarshitRaj_14",
                        "content": "Because in every iteration we have to remove the maximum element from each row. \\nIt is not mandatory that the maximum element will always be at column number i so we sort every row in order to make sure that the maximum number is at ith column.\\nThe question has specifically asked us to - From each row in the matrix, select the largest number and remove it. So first sort it rowwise to get the largest element first.\\n \\nPlease upvote if you understood"
                    },
                    {
                        "username": "arshikamishra",
                        "content": "[@candy45](/candy45) could you elaborate please"
                    },
                    {
                        "username": "candy45",
                        "content": "consider this case [[7,2,1],[6,1,4],[6,1,2],[3,2,1]] by taking max value in every column we will get answer as 13 but answer is 12"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "Can someone help me with my code?\\nWhy is not working ?\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        for(auto a:nums){\\n            sort(a.begin(),a.end());\\n        }\\n        int sum=0;\\n        for(int i=0;i<nums[0].size();i++){\\n            int maxi=0;\\n            for(int j=0;j<nums.size();j++){\\n                maxi=max(nums[j][i],maxi);\\n            }\\n            sum+=maxi;\\n        }\\n        return sum;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "avinash3300",
                        "content": "you want to write in for loop\\nfor(auto &a : nums){\\n            sort(a.begin(),a.end());\\n        }\\n"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "[@BadalArya](/BadalArya)  thanks bro \\n"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "[@Ankur_0152](/Ankur_0152)  Thanks bro\\n"
                    },
                    {
                        "username": "Ankur_0152",
                        "content": "either use \n        for(auto &a:nums)\n            sort(a.begin(),a.end());\nor \n       for(int i=0;i<nums.size();i++)\n           sort(nums[i].begin(),nums[i].end());\n        "
                    },
                    {
                        "username": "BadalArya",
                        "content": "for(auto &a : nums)\\n\\nYou need to use for each loop with address or it won\\'t sort the array"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "even i come up with the same sol, i don't understand sorting of rows req. did they ask in question ? "
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach :-)**\\n- Initialize the score to 0 and a variable called total to 0.\\n- While total is less than the total number of elements in the matrix:\\n- Create a priority queue to store the largest numbers from each row.\\n- For each row in the matrix, find the largest number that hasn\\'t been removed yet (i.e., its value is not -1), and add it to the priority queue.\\n- Remove the largest number from the priority queue and add it to the score.\\n- Mark the location of the removed number in the matrix by setting its value to -1.\\n- Increment the total variable to keep track of how many elements have been removed.\\n- Return the final score."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the Code Link :-)***\\nhttps://leetcode.com/problems/sum-in-a-matrix/solutions/3524127/easiest-solution-priorityqueue/"
                    },
                    {
                        "username": "Balwierz",
                        "content": "Identical to https://leetcode.com/problems/delete-greatest-value-in-each-row/"
                    },
                    {
                        "username": "rtanishka",
                        "content": "Why does this code pass only 116/1057 test cases \\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int score =0;\\n        priority_queue<int> pq;\\n        for(int j=0;j<nums[0].size();j++){\\n            for(int i=0;i<nums.size();i++){\\n                pq.push(nums[i][j]);\\n            }\\n            score += pq.top();\\n            while(!pq.empty()){\\n                pq.pop();\\n            }\\n        }\\n        return score;\\n    }\\n};"
                    },
                    {
                        "username": "Nazar2020",
                        "content": "Matrix row can be sorted asc or desc, it doesn\\'t matter"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "for me wheneve I try to iterate rows and column runtime error for no reason like even I used n = nums.size() and m = nums[0].size() still it says runtime but while 14 and 13 numbers it works what is wrong"
                    },
                    {
                        "username": "hacker363",
                        "content": "```class Solution:\n    def matrixSum(self, nums: List[List[int]]) -> int:\n        i = 0\n        ans = 0\n        while i<len(nums[0]):\n            l = sorted(nums, key=lambda x :x[i])[::-1]\n            ans+=l[0][i]\n            i+=1\n        return ans\n```\n\nCan anyone please tell me why my code only passes 116 testcases rather than all....\nPlease address the mistake I have made.\nif it finds helpful please upvote\n"
                    }
                ]
            },
            {
                "id": 1892785,
                "content": [
                    {
                        "username": "roboto7o32oo3",
                        "content": "This problem should be marked Easy....."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "how is your dp moving??"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "This problem is same as [2500. Delete Greatest Value in Each Row](https://leetcode.com/problems/delete-greatest-value-in-each-row/)"
                    },
                    {
                        "username": "abhijay_123",
                        "content": "Why sort ?\\nand why selecting the largest value in a column fails?"
                    },
                    {
                        "username": "vinnnu",
                        "content": "[@candy45](/candy45) thanks mate "
                    },
                    {
                        "username": "HarshitRaj_14",
                        "content": "[@arshikamishra](/arshikamishra) Because in every iteration we have to remove the maximum element from each row. \\nIt is not mandatory that the maximum element will always be at column number i so we sort every row in order to make sure that the maximum number is at ith column.\\nThe question has specifically asked us to - From each row in the matrix, select the largest number and remove it. So first sort it rowwise to get the largest element first.\\n \\nPlease upvote if you understood"
                    },
                    {
                        "username": "HarshitRaj_14",
                        "content": "Because in every iteration we have to remove the maximum element from each row. \\nIt is not mandatory that the maximum element will always be at column number i so we sort every row in order to make sure that the maximum number is at ith column.\\nThe question has specifically asked us to - From each row in the matrix, select the largest number and remove it. So first sort it rowwise to get the largest element first.\\n \\nPlease upvote if you understood"
                    },
                    {
                        "username": "arshikamishra",
                        "content": "[@candy45](/candy45) could you elaborate please"
                    },
                    {
                        "username": "candy45",
                        "content": "consider this case [[7,2,1],[6,1,4],[6,1,2],[3,2,1]] by taking max value in every column we will get answer as 13 but answer is 12"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "Can someone help me with my code?\\nWhy is not working ?\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        for(auto a:nums){\\n            sort(a.begin(),a.end());\\n        }\\n        int sum=0;\\n        for(int i=0;i<nums[0].size();i++){\\n            int maxi=0;\\n            for(int j=0;j<nums.size();j++){\\n                maxi=max(nums[j][i],maxi);\\n            }\\n            sum+=maxi;\\n        }\\n        return sum;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "avinash3300",
                        "content": "you want to write in for loop\\nfor(auto &a : nums){\\n            sort(a.begin(),a.end());\\n        }\\n"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "[@BadalArya](/BadalArya)  thanks bro \\n"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "[@Ankur_0152](/Ankur_0152)  Thanks bro\\n"
                    },
                    {
                        "username": "Ankur_0152",
                        "content": "either use \n        for(auto &a:nums)\n            sort(a.begin(),a.end());\nor \n       for(int i=0;i<nums.size();i++)\n           sort(nums[i].begin(),nums[i].end());\n        "
                    },
                    {
                        "username": "BadalArya",
                        "content": "for(auto &a : nums)\\n\\nYou need to use for each loop with address or it won\\'t sort the array"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "even i come up with the same sol, i don't understand sorting of rows req. did they ask in question ? "
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach :-)**\\n- Initialize the score to 0 and a variable called total to 0.\\n- While total is less than the total number of elements in the matrix:\\n- Create a priority queue to store the largest numbers from each row.\\n- For each row in the matrix, find the largest number that hasn\\'t been removed yet (i.e., its value is not -1), and add it to the priority queue.\\n- Remove the largest number from the priority queue and add it to the score.\\n- Mark the location of the removed number in the matrix by setting its value to -1.\\n- Increment the total variable to keep track of how many elements have been removed.\\n- Return the final score."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the Code Link :-)***\\nhttps://leetcode.com/problems/sum-in-a-matrix/solutions/3524127/easiest-solution-priorityqueue/"
                    },
                    {
                        "username": "Balwierz",
                        "content": "Identical to https://leetcode.com/problems/delete-greatest-value-in-each-row/"
                    },
                    {
                        "username": "rtanishka",
                        "content": "Why does this code pass only 116/1057 test cases \\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int score =0;\\n        priority_queue<int> pq;\\n        for(int j=0;j<nums[0].size();j++){\\n            for(int i=0;i<nums.size();i++){\\n                pq.push(nums[i][j]);\\n            }\\n            score += pq.top();\\n            while(!pq.empty()){\\n                pq.pop();\\n            }\\n        }\\n        return score;\\n    }\\n};"
                    },
                    {
                        "username": "Nazar2020",
                        "content": "Matrix row can be sorted asc or desc, it doesn\\'t matter"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "for me wheneve I try to iterate rows and column runtime error for no reason like even I used n = nums.size() and m = nums[0].size() still it says runtime but while 14 and 13 numbers it works what is wrong"
                    },
                    {
                        "username": "hacker363",
                        "content": "```class Solution:\n    def matrixSum(self, nums: List[List[int]]) -> int:\n        i = 0\n        ans = 0\n        while i<len(nums[0]):\n            l = sorted(nums, key=lambda x :x[i])[::-1]\n            ans+=l[0][i]\n            i+=1\n        return ans\n```\n\nCan anyone please tell me why my code only passes 116 testcases rather than all....\nPlease address the mistake I have made.\nif it finds helpful please upvote\n"
                    }
                ]
            },
            {
                "id": 1892799,
                "content": [
                    {
                        "username": "roboto7o32oo3",
                        "content": "This problem should be marked Easy....."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "how is your dp moving??"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "This problem is same as [2500. Delete Greatest Value in Each Row](https://leetcode.com/problems/delete-greatest-value-in-each-row/)"
                    },
                    {
                        "username": "abhijay_123",
                        "content": "Why sort ?\\nand why selecting the largest value in a column fails?"
                    },
                    {
                        "username": "vinnnu",
                        "content": "[@candy45](/candy45) thanks mate "
                    },
                    {
                        "username": "HarshitRaj_14",
                        "content": "[@arshikamishra](/arshikamishra) Because in every iteration we have to remove the maximum element from each row. \\nIt is not mandatory that the maximum element will always be at column number i so we sort every row in order to make sure that the maximum number is at ith column.\\nThe question has specifically asked us to - From each row in the matrix, select the largest number and remove it. So first sort it rowwise to get the largest element first.\\n \\nPlease upvote if you understood"
                    },
                    {
                        "username": "HarshitRaj_14",
                        "content": "Because in every iteration we have to remove the maximum element from each row. \\nIt is not mandatory that the maximum element will always be at column number i so we sort every row in order to make sure that the maximum number is at ith column.\\nThe question has specifically asked us to - From each row in the matrix, select the largest number and remove it. So first sort it rowwise to get the largest element first.\\n \\nPlease upvote if you understood"
                    },
                    {
                        "username": "arshikamishra",
                        "content": "[@candy45](/candy45) could you elaborate please"
                    },
                    {
                        "username": "candy45",
                        "content": "consider this case [[7,2,1],[6,1,4],[6,1,2],[3,2,1]] by taking max value in every column we will get answer as 13 but answer is 12"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "Can someone help me with my code?\\nWhy is not working ?\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        for(auto a:nums){\\n            sort(a.begin(),a.end());\\n        }\\n        int sum=0;\\n        for(int i=0;i<nums[0].size();i++){\\n            int maxi=0;\\n            for(int j=0;j<nums.size();j++){\\n                maxi=max(nums[j][i],maxi);\\n            }\\n            sum+=maxi;\\n        }\\n        return sum;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "avinash3300",
                        "content": "you want to write in for loop\\nfor(auto &a : nums){\\n            sort(a.begin(),a.end());\\n        }\\n"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "[@BadalArya](/BadalArya)  thanks bro \\n"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "[@Ankur_0152](/Ankur_0152)  Thanks bro\\n"
                    },
                    {
                        "username": "Ankur_0152",
                        "content": "either use \n        for(auto &a:nums)\n            sort(a.begin(),a.end());\nor \n       for(int i=0;i<nums.size();i++)\n           sort(nums[i].begin(),nums[i].end());\n        "
                    },
                    {
                        "username": "BadalArya",
                        "content": "for(auto &a : nums)\\n\\nYou need to use for each loop with address or it won\\'t sort the array"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "even i come up with the same sol, i don't understand sorting of rows req. did they ask in question ? "
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach :-)**\\n- Initialize the score to 0 and a variable called total to 0.\\n- While total is less than the total number of elements in the matrix:\\n- Create a priority queue to store the largest numbers from each row.\\n- For each row in the matrix, find the largest number that hasn\\'t been removed yet (i.e., its value is not -1), and add it to the priority queue.\\n- Remove the largest number from the priority queue and add it to the score.\\n- Mark the location of the removed number in the matrix by setting its value to -1.\\n- Increment the total variable to keep track of how many elements have been removed.\\n- Return the final score."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the Code Link :-)***\\nhttps://leetcode.com/problems/sum-in-a-matrix/solutions/3524127/easiest-solution-priorityqueue/"
                    },
                    {
                        "username": "Balwierz",
                        "content": "Identical to https://leetcode.com/problems/delete-greatest-value-in-each-row/"
                    },
                    {
                        "username": "rtanishka",
                        "content": "Why does this code pass only 116/1057 test cases \\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int score =0;\\n        priority_queue<int> pq;\\n        for(int j=0;j<nums[0].size();j++){\\n            for(int i=0;i<nums.size();i++){\\n                pq.push(nums[i][j]);\\n            }\\n            score += pq.top();\\n            while(!pq.empty()){\\n                pq.pop();\\n            }\\n        }\\n        return score;\\n    }\\n};"
                    },
                    {
                        "username": "Nazar2020",
                        "content": "Matrix row can be sorted asc or desc, it doesn\\'t matter"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "for me wheneve I try to iterate rows and column runtime error for no reason like even I used n = nums.size() and m = nums[0].size() still it says runtime but while 14 and 13 numbers it works what is wrong"
                    },
                    {
                        "username": "hacker363",
                        "content": "```class Solution:\n    def matrixSum(self, nums: List[List[int]]) -> int:\n        i = 0\n        ans = 0\n        while i<len(nums[0]):\n            l = sorted(nums, key=lambda x :x[i])[::-1]\n            ans+=l[0][i]\n            i+=1\n        return ans\n```\n\nCan anyone please tell me why my code only passes 116 testcases rather than all....\nPlease address the mistake I have made.\nif it finds helpful please upvote\n"
                    }
                ]
            },
            {
                "id": 1892459,
                "content": [
                    {
                        "username": "roboto7o32oo3",
                        "content": "This problem should be marked Easy....."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "how is your dp moving??"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "This problem is same as [2500. Delete Greatest Value in Each Row](https://leetcode.com/problems/delete-greatest-value-in-each-row/)"
                    },
                    {
                        "username": "abhijay_123",
                        "content": "Why sort ?\\nand why selecting the largest value in a column fails?"
                    },
                    {
                        "username": "vinnnu",
                        "content": "[@candy45](/candy45) thanks mate "
                    },
                    {
                        "username": "HarshitRaj_14",
                        "content": "[@arshikamishra](/arshikamishra) Because in every iteration we have to remove the maximum element from each row. \\nIt is not mandatory that the maximum element will always be at column number i so we sort every row in order to make sure that the maximum number is at ith column.\\nThe question has specifically asked us to - From each row in the matrix, select the largest number and remove it. So first sort it rowwise to get the largest element first.\\n \\nPlease upvote if you understood"
                    },
                    {
                        "username": "HarshitRaj_14",
                        "content": "Because in every iteration we have to remove the maximum element from each row. \\nIt is not mandatory that the maximum element will always be at column number i so we sort every row in order to make sure that the maximum number is at ith column.\\nThe question has specifically asked us to - From each row in the matrix, select the largest number and remove it. So first sort it rowwise to get the largest element first.\\n \\nPlease upvote if you understood"
                    },
                    {
                        "username": "arshikamishra",
                        "content": "[@candy45](/candy45) could you elaborate please"
                    },
                    {
                        "username": "candy45",
                        "content": "consider this case [[7,2,1],[6,1,4],[6,1,2],[3,2,1]] by taking max value in every column we will get answer as 13 but answer is 12"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "Can someone help me with my code?\\nWhy is not working ?\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        for(auto a:nums){\\n            sort(a.begin(),a.end());\\n        }\\n        int sum=0;\\n        for(int i=0;i<nums[0].size();i++){\\n            int maxi=0;\\n            for(int j=0;j<nums.size();j++){\\n                maxi=max(nums[j][i],maxi);\\n            }\\n            sum+=maxi;\\n        }\\n        return sum;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "avinash3300",
                        "content": "you want to write in for loop\\nfor(auto &a : nums){\\n            sort(a.begin(),a.end());\\n        }\\n"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "[@BadalArya](/BadalArya)  thanks bro \\n"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "[@Ankur_0152](/Ankur_0152)  Thanks bro\\n"
                    },
                    {
                        "username": "Ankur_0152",
                        "content": "either use \n        for(auto &a:nums)\n            sort(a.begin(),a.end());\nor \n       for(int i=0;i<nums.size();i++)\n           sort(nums[i].begin(),nums[i].end());\n        "
                    },
                    {
                        "username": "BadalArya",
                        "content": "for(auto &a : nums)\\n\\nYou need to use for each loop with address or it won\\'t sort the array"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "even i come up with the same sol, i don't understand sorting of rows req. did they ask in question ? "
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach :-)**\\n- Initialize the score to 0 and a variable called total to 0.\\n- While total is less than the total number of elements in the matrix:\\n- Create a priority queue to store the largest numbers from each row.\\n- For each row in the matrix, find the largest number that hasn\\'t been removed yet (i.e., its value is not -1), and add it to the priority queue.\\n- Remove the largest number from the priority queue and add it to the score.\\n- Mark the location of the removed number in the matrix by setting its value to -1.\\n- Increment the total variable to keep track of how many elements have been removed.\\n- Return the final score."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the Code Link :-)***\\nhttps://leetcode.com/problems/sum-in-a-matrix/solutions/3524127/easiest-solution-priorityqueue/"
                    },
                    {
                        "username": "Balwierz",
                        "content": "Identical to https://leetcode.com/problems/delete-greatest-value-in-each-row/"
                    },
                    {
                        "username": "rtanishka",
                        "content": "Why does this code pass only 116/1057 test cases \\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int score =0;\\n        priority_queue<int> pq;\\n        for(int j=0;j<nums[0].size();j++){\\n            for(int i=0;i<nums.size();i++){\\n                pq.push(nums[i][j]);\\n            }\\n            score += pq.top();\\n            while(!pq.empty()){\\n                pq.pop();\\n            }\\n        }\\n        return score;\\n    }\\n};"
                    },
                    {
                        "username": "Nazar2020",
                        "content": "Matrix row can be sorted asc or desc, it doesn\\'t matter"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "for me wheneve I try to iterate rows and column runtime error for no reason like even I used n = nums.size() and m = nums[0].size() still it says runtime but while 14 and 13 numbers it works what is wrong"
                    },
                    {
                        "username": "hacker363",
                        "content": "```class Solution:\n    def matrixSum(self, nums: List[List[int]]) -> int:\n        i = 0\n        ans = 0\n        while i<len(nums[0]):\n            l = sorted(nums, key=lambda x :x[i])[::-1]\n            ans+=l[0][i]\n            i+=1\n        return ans\n```\n\nCan anyone please tell me why my code only passes 116 testcases rather than all....\nPlease address the mistake I have made.\nif it finds helpful please upvote\n"
                    }
                ]
            },
            {
                "id": 1893910,
                "content": [
                    {
                        "username": "roboto7o32oo3",
                        "content": "This problem should be marked Easy....."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "how is your dp moving??"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "This problem is same as [2500. Delete Greatest Value in Each Row](https://leetcode.com/problems/delete-greatest-value-in-each-row/)"
                    },
                    {
                        "username": "abhijay_123",
                        "content": "Why sort ?\\nand why selecting the largest value in a column fails?"
                    },
                    {
                        "username": "vinnnu",
                        "content": "[@candy45](/candy45) thanks mate "
                    },
                    {
                        "username": "HarshitRaj_14",
                        "content": "[@arshikamishra](/arshikamishra) Because in every iteration we have to remove the maximum element from each row. \\nIt is not mandatory that the maximum element will always be at column number i so we sort every row in order to make sure that the maximum number is at ith column.\\nThe question has specifically asked us to - From each row in the matrix, select the largest number and remove it. So first sort it rowwise to get the largest element first.\\n \\nPlease upvote if you understood"
                    },
                    {
                        "username": "HarshitRaj_14",
                        "content": "Because in every iteration we have to remove the maximum element from each row. \\nIt is not mandatory that the maximum element will always be at column number i so we sort every row in order to make sure that the maximum number is at ith column.\\nThe question has specifically asked us to - From each row in the matrix, select the largest number and remove it. So first sort it rowwise to get the largest element first.\\n \\nPlease upvote if you understood"
                    },
                    {
                        "username": "arshikamishra",
                        "content": "[@candy45](/candy45) could you elaborate please"
                    },
                    {
                        "username": "candy45",
                        "content": "consider this case [[7,2,1],[6,1,4],[6,1,2],[3,2,1]] by taking max value in every column we will get answer as 13 but answer is 12"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "Can someone help me with my code?\\nWhy is not working ?\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        for(auto a:nums){\\n            sort(a.begin(),a.end());\\n        }\\n        int sum=0;\\n        for(int i=0;i<nums[0].size();i++){\\n            int maxi=0;\\n            for(int j=0;j<nums.size();j++){\\n                maxi=max(nums[j][i],maxi);\\n            }\\n            sum+=maxi;\\n        }\\n        return sum;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "avinash3300",
                        "content": "you want to write in for loop\\nfor(auto &a : nums){\\n            sort(a.begin(),a.end());\\n        }\\n"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "[@BadalArya](/BadalArya)  thanks bro \\n"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "[@Ankur_0152](/Ankur_0152)  Thanks bro\\n"
                    },
                    {
                        "username": "Ankur_0152",
                        "content": "either use \n        for(auto &a:nums)\n            sort(a.begin(),a.end());\nor \n       for(int i=0;i<nums.size();i++)\n           sort(nums[i].begin(),nums[i].end());\n        "
                    },
                    {
                        "username": "BadalArya",
                        "content": "for(auto &a : nums)\\n\\nYou need to use for each loop with address or it won\\'t sort the array"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "even i come up with the same sol, i don't understand sorting of rows req. did they ask in question ? "
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach :-)**\\n- Initialize the score to 0 and a variable called total to 0.\\n- While total is less than the total number of elements in the matrix:\\n- Create a priority queue to store the largest numbers from each row.\\n- For each row in the matrix, find the largest number that hasn\\'t been removed yet (i.e., its value is not -1), and add it to the priority queue.\\n- Remove the largest number from the priority queue and add it to the score.\\n- Mark the location of the removed number in the matrix by setting its value to -1.\\n- Increment the total variable to keep track of how many elements have been removed.\\n- Return the final score."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the Code Link :-)***\\nhttps://leetcode.com/problems/sum-in-a-matrix/solutions/3524127/easiest-solution-priorityqueue/"
                    },
                    {
                        "username": "Balwierz",
                        "content": "Identical to https://leetcode.com/problems/delete-greatest-value-in-each-row/"
                    },
                    {
                        "username": "rtanishka",
                        "content": "Why does this code pass only 116/1057 test cases \\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int score =0;\\n        priority_queue<int> pq;\\n        for(int j=0;j<nums[0].size();j++){\\n            for(int i=0;i<nums.size();i++){\\n                pq.push(nums[i][j]);\\n            }\\n            score += pq.top();\\n            while(!pq.empty()){\\n                pq.pop();\\n            }\\n        }\\n        return score;\\n    }\\n};"
                    },
                    {
                        "username": "Nazar2020",
                        "content": "Matrix row can be sorted asc or desc, it doesn\\'t matter"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "for me wheneve I try to iterate rows and column runtime error for no reason like even I used n = nums.size() and m = nums[0].size() still it says runtime but while 14 and 13 numbers it works what is wrong"
                    },
                    {
                        "username": "hacker363",
                        "content": "```class Solution:\n    def matrixSum(self, nums: List[List[int]]) -> int:\n        i = 0\n        ans = 0\n        while i<len(nums[0]):\n            l = sorted(nums, key=lambda x :x[i])[::-1]\n            ans+=l[0][i]\n            i+=1\n        return ans\n```\n\nCan anyone please tell me why my code only passes 116 testcases rather than all....\nPlease address the mistake I have made.\nif it finds helpful please upvote\n"
                    }
                ]
            },
            {
                "id": 1893821,
                "content": [
                    {
                        "username": "roboto7o32oo3",
                        "content": "This problem should be marked Easy....."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "how is your dp moving??"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "This problem is same as [2500. Delete Greatest Value in Each Row](https://leetcode.com/problems/delete-greatest-value-in-each-row/)"
                    },
                    {
                        "username": "abhijay_123",
                        "content": "Why sort ?\\nand why selecting the largest value in a column fails?"
                    },
                    {
                        "username": "vinnnu",
                        "content": "[@candy45](/candy45) thanks mate "
                    },
                    {
                        "username": "HarshitRaj_14",
                        "content": "[@arshikamishra](/arshikamishra) Because in every iteration we have to remove the maximum element from each row. \\nIt is not mandatory that the maximum element will always be at column number i so we sort every row in order to make sure that the maximum number is at ith column.\\nThe question has specifically asked us to - From each row in the matrix, select the largest number and remove it. So first sort it rowwise to get the largest element first.\\n \\nPlease upvote if you understood"
                    },
                    {
                        "username": "HarshitRaj_14",
                        "content": "Because in every iteration we have to remove the maximum element from each row. \\nIt is not mandatory that the maximum element will always be at column number i so we sort every row in order to make sure that the maximum number is at ith column.\\nThe question has specifically asked us to - From each row in the matrix, select the largest number and remove it. So first sort it rowwise to get the largest element first.\\n \\nPlease upvote if you understood"
                    },
                    {
                        "username": "arshikamishra",
                        "content": "[@candy45](/candy45) could you elaborate please"
                    },
                    {
                        "username": "candy45",
                        "content": "consider this case [[7,2,1],[6,1,4],[6,1,2],[3,2,1]] by taking max value in every column we will get answer as 13 but answer is 12"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "Can someone help me with my code?\\nWhy is not working ?\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        for(auto a:nums){\\n            sort(a.begin(),a.end());\\n        }\\n        int sum=0;\\n        for(int i=0;i<nums[0].size();i++){\\n            int maxi=0;\\n            for(int j=0;j<nums.size();j++){\\n                maxi=max(nums[j][i],maxi);\\n            }\\n            sum+=maxi;\\n        }\\n        return sum;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "avinash3300",
                        "content": "you want to write in for loop\\nfor(auto &a : nums){\\n            sort(a.begin(),a.end());\\n        }\\n"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "[@BadalArya](/BadalArya)  thanks bro \\n"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "[@Ankur_0152](/Ankur_0152)  Thanks bro\\n"
                    },
                    {
                        "username": "Ankur_0152",
                        "content": "either use \n        for(auto &a:nums)\n            sort(a.begin(),a.end());\nor \n       for(int i=0;i<nums.size();i++)\n           sort(nums[i].begin(),nums[i].end());\n        "
                    },
                    {
                        "username": "BadalArya",
                        "content": "for(auto &a : nums)\\n\\nYou need to use for each loop with address or it won\\'t sort the array"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "even i come up with the same sol, i don't understand sorting of rows req. did they ask in question ? "
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach :-)**\\n- Initialize the score to 0 and a variable called total to 0.\\n- While total is less than the total number of elements in the matrix:\\n- Create a priority queue to store the largest numbers from each row.\\n- For each row in the matrix, find the largest number that hasn\\'t been removed yet (i.e., its value is not -1), and add it to the priority queue.\\n- Remove the largest number from the priority queue and add it to the score.\\n- Mark the location of the removed number in the matrix by setting its value to -1.\\n- Increment the total variable to keep track of how many elements have been removed.\\n- Return the final score."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the Code Link :-)***\\nhttps://leetcode.com/problems/sum-in-a-matrix/solutions/3524127/easiest-solution-priorityqueue/"
                    },
                    {
                        "username": "Balwierz",
                        "content": "Identical to https://leetcode.com/problems/delete-greatest-value-in-each-row/"
                    },
                    {
                        "username": "rtanishka",
                        "content": "Why does this code pass only 116/1057 test cases \\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int score =0;\\n        priority_queue<int> pq;\\n        for(int j=0;j<nums[0].size();j++){\\n            for(int i=0;i<nums.size();i++){\\n                pq.push(nums[i][j]);\\n            }\\n            score += pq.top();\\n            while(!pq.empty()){\\n                pq.pop();\\n            }\\n        }\\n        return score;\\n    }\\n};"
                    },
                    {
                        "username": "Nazar2020",
                        "content": "Matrix row can be sorted asc or desc, it doesn\\'t matter"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "for me wheneve I try to iterate rows and column runtime error for no reason like even I used n = nums.size() and m = nums[0].size() still it says runtime but while 14 and 13 numbers it works what is wrong"
                    },
                    {
                        "username": "hacker363",
                        "content": "```class Solution:\n    def matrixSum(self, nums: List[List[int]]) -> int:\n        i = 0\n        ans = 0\n        while i<len(nums[0]):\n            l = sorted(nums, key=lambda x :x[i])[::-1]\n            ans+=l[0][i]\n            i+=1\n        return ans\n```\n\nCan anyone please tell me why my code only passes 116 testcases rather than all....\nPlease address the mistake I have made.\nif it finds helpful please upvote\n"
                    }
                ]
            },
            {
                "id": 2046752,
                "content": [
                    {
                        "username": "roboto7o32oo3",
                        "content": "This problem should be marked Easy....."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "how is your dp moving??"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "This problem is same as [2500. Delete Greatest Value in Each Row](https://leetcode.com/problems/delete-greatest-value-in-each-row/)"
                    },
                    {
                        "username": "abhijay_123",
                        "content": "Why sort ?\\nand why selecting the largest value in a column fails?"
                    },
                    {
                        "username": "vinnnu",
                        "content": "[@candy45](/candy45) thanks mate "
                    },
                    {
                        "username": "HarshitRaj_14",
                        "content": "[@arshikamishra](/arshikamishra) Because in every iteration we have to remove the maximum element from each row. \\nIt is not mandatory that the maximum element will always be at column number i so we sort every row in order to make sure that the maximum number is at ith column.\\nThe question has specifically asked us to - From each row in the matrix, select the largest number and remove it. So first sort it rowwise to get the largest element first.\\n \\nPlease upvote if you understood"
                    },
                    {
                        "username": "HarshitRaj_14",
                        "content": "Because in every iteration we have to remove the maximum element from each row. \\nIt is not mandatory that the maximum element will always be at column number i so we sort every row in order to make sure that the maximum number is at ith column.\\nThe question has specifically asked us to - From each row in the matrix, select the largest number and remove it. So first sort it rowwise to get the largest element first.\\n \\nPlease upvote if you understood"
                    },
                    {
                        "username": "arshikamishra",
                        "content": "[@candy45](/candy45) could you elaborate please"
                    },
                    {
                        "username": "candy45",
                        "content": "consider this case [[7,2,1],[6,1,4],[6,1,2],[3,2,1]] by taking max value in every column we will get answer as 13 but answer is 12"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "Can someone help me with my code?\\nWhy is not working ?\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        for(auto a:nums){\\n            sort(a.begin(),a.end());\\n        }\\n        int sum=0;\\n        for(int i=0;i<nums[0].size();i++){\\n            int maxi=0;\\n            for(int j=0;j<nums.size();j++){\\n                maxi=max(nums[j][i],maxi);\\n            }\\n            sum+=maxi;\\n        }\\n        return sum;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "avinash3300",
                        "content": "you want to write in for loop\\nfor(auto &a : nums){\\n            sort(a.begin(),a.end());\\n        }\\n"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "[@BadalArya](/BadalArya)  thanks bro \\n"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "[@Ankur_0152](/Ankur_0152)  Thanks bro\\n"
                    },
                    {
                        "username": "Ankur_0152",
                        "content": "either use \n        for(auto &a:nums)\n            sort(a.begin(),a.end());\nor \n       for(int i=0;i<nums.size();i++)\n           sort(nums[i].begin(),nums[i].end());\n        "
                    },
                    {
                        "username": "BadalArya",
                        "content": "for(auto &a : nums)\\n\\nYou need to use for each loop with address or it won\\'t sort the array"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "even i come up with the same sol, i don't understand sorting of rows req. did they ask in question ? "
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach :-)**\\n- Initialize the score to 0 and a variable called total to 0.\\n- While total is less than the total number of elements in the matrix:\\n- Create a priority queue to store the largest numbers from each row.\\n- For each row in the matrix, find the largest number that hasn\\'t been removed yet (i.e., its value is not -1), and add it to the priority queue.\\n- Remove the largest number from the priority queue and add it to the score.\\n- Mark the location of the removed number in the matrix by setting its value to -1.\\n- Increment the total variable to keep track of how many elements have been removed.\\n- Return the final score."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the Code Link :-)***\\nhttps://leetcode.com/problems/sum-in-a-matrix/solutions/3524127/easiest-solution-priorityqueue/"
                    },
                    {
                        "username": "Balwierz",
                        "content": "Identical to https://leetcode.com/problems/delete-greatest-value-in-each-row/"
                    },
                    {
                        "username": "rtanishka",
                        "content": "Why does this code pass only 116/1057 test cases \\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int score =0;\\n        priority_queue<int> pq;\\n        for(int j=0;j<nums[0].size();j++){\\n            for(int i=0;i<nums.size();i++){\\n                pq.push(nums[i][j]);\\n            }\\n            score += pq.top();\\n            while(!pq.empty()){\\n                pq.pop();\\n            }\\n        }\\n        return score;\\n    }\\n};"
                    },
                    {
                        "username": "Nazar2020",
                        "content": "Matrix row can be sorted asc or desc, it doesn\\'t matter"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "for me wheneve I try to iterate rows and column runtime error for no reason like even I used n = nums.size() and m = nums[0].size() still it says runtime but while 14 and 13 numbers it works what is wrong"
                    },
                    {
                        "username": "hacker363",
                        "content": "```class Solution:\n    def matrixSum(self, nums: List[List[int]]) -> int:\n        i = 0\n        ans = 0\n        while i<len(nums[0]):\n            l = sorted(nums, key=lambda x :x[i])[::-1]\n            ans+=l[0][i]\n            i+=1\n        return ans\n```\n\nCan anyone please tell me why my code only passes 116 testcases rather than all....\nPlease address the mistake I have made.\nif it finds helpful please upvote\n"
                    }
                ]
            },
            {
                "id": 2037216,
                "content": [
                    {
                        "username": "roboto7o32oo3",
                        "content": "This problem should be marked Easy....."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "how is your dp moving??"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "This problem is same as [2500. Delete Greatest Value in Each Row](https://leetcode.com/problems/delete-greatest-value-in-each-row/)"
                    },
                    {
                        "username": "abhijay_123",
                        "content": "Why sort ?\\nand why selecting the largest value in a column fails?"
                    },
                    {
                        "username": "vinnnu",
                        "content": "[@candy45](/candy45) thanks mate "
                    },
                    {
                        "username": "HarshitRaj_14",
                        "content": "[@arshikamishra](/arshikamishra) Because in every iteration we have to remove the maximum element from each row. \\nIt is not mandatory that the maximum element will always be at column number i so we sort every row in order to make sure that the maximum number is at ith column.\\nThe question has specifically asked us to - From each row in the matrix, select the largest number and remove it. So first sort it rowwise to get the largest element first.\\n \\nPlease upvote if you understood"
                    },
                    {
                        "username": "HarshitRaj_14",
                        "content": "Because in every iteration we have to remove the maximum element from each row. \\nIt is not mandatory that the maximum element will always be at column number i so we sort every row in order to make sure that the maximum number is at ith column.\\nThe question has specifically asked us to - From each row in the matrix, select the largest number and remove it. So first sort it rowwise to get the largest element first.\\n \\nPlease upvote if you understood"
                    },
                    {
                        "username": "arshikamishra",
                        "content": "[@candy45](/candy45) could you elaborate please"
                    },
                    {
                        "username": "candy45",
                        "content": "consider this case [[7,2,1],[6,1,4],[6,1,2],[3,2,1]] by taking max value in every column we will get answer as 13 but answer is 12"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "Can someone help me with my code?\\nWhy is not working ?\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        for(auto a:nums){\\n            sort(a.begin(),a.end());\\n        }\\n        int sum=0;\\n        for(int i=0;i<nums[0].size();i++){\\n            int maxi=0;\\n            for(int j=0;j<nums.size();j++){\\n                maxi=max(nums[j][i],maxi);\\n            }\\n            sum+=maxi;\\n        }\\n        return sum;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "avinash3300",
                        "content": "you want to write in for loop\\nfor(auto &a : nums){\\n            sort(a.begin(),a.end());\\n        }\\n"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "[@BadalArya](/BadalArya)  thanks bro \\n"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "[@Ankur_0152](/Ankur_0152)  Thanks bro\\n"
                    },
                    {
                        "username": "Ankur_0152",
                        "content": "either use \n        for(auto &a:nums)\n            sort(a.begin(),a.end());\nor \n       for(int i=0;i<nums.size();i++)\n           sort(nums[i].begin(),nums[i].end());\n        "
                    },
                    {
                        "username": "BadalArya",
                        "content": "for(auto &a : nums)\\n\\nYou need to use for each loop with address or it won\\'t sort the array"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "even i come up with the same sol, i don't understand sorting of rows req. did they ask in question ? "
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach :-)**\\n- Initialize the score to 0 and a variable called total to 0.\\n- While total is less than the total number of elements in the matrix:\\n- Create a priority queue to store the largest numbers from each row.\\n- For each row in the matrix, find the largest number that hasn\\'t been removed yet (i.e., its value is not -1), and add it to the priority queue.\\n- Remove the largest number from the priority queue and add it to the score.\\n- Mark the location of the removed number in the matrix by setting its value to -1.\\n- Increment the total variable to keep track of how many elements have been removed.\\n- Return the final score."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the Code Link :-)***\\nhttps://leetcode.com/problems/sum-in-a-matrix/solutions/3524127/easiest-solution-priorityqueue/"
                    },
                    {
                        "username": "Balwierz",
                        "content": "Identical to https://leetcode.com/problems/delete-greatest-value-in-each-row/"
                    },
                    {
                        "username": "rtanishka",
                        "content": "Why does this code pass only 116/1057 test cases \\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int score =0;\\n        priority_queue<int> pq;\\n        for(int j=0;j<nums[0].size();j++){\\n            for(int i=0;i<nums.size();i++){\\n                pq.push(nums[i][j]);\\n            }\\n            score += pq.top();\\n            while(!pq.empty()){\\n                pq.pop();\\n            }\\n        }\\n        return score;\\n    }\\n};"
                    },
                    {
                        "username": "Nazar2020",
                        "content": "Matrix row can be sorted asc or desc, it doesn\\'t matter"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "for me wheneve I try to iterate rows and column runtime error for no reason like even I used n = nums.size() and m = nums[0].size() still it says runtime but while 14 and 13 numbers it works what is wrong"
                    },
                    {
                        "username": "hacker363",
                        "content": "```class Solution:\n    def matrixSum(self, nums: List[List[int]]) -> int:\n        i = 0\n        ans = 0\n        while i<len(nums[0]):\n            l = sorted(nums, key=lambda x :x[i])[::-1]\n            ans+=l[0][i]\n            i+=1\n        return ans\n```\n\nCan anyone please tell me why my code only passes 116 testcases rather than all....\nPlease address the mistake I have made.\nif it finds helpful please upvote\n"
                    }
                ]
            },
            {
                "id": 1990741,
                "content": [
                    {
                        "username": "roboto7o32oo3",
                        "content": "This problem should be marked Easy....."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "how is your dp moving??"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "This problem is same as [2500. Delete Greatest Value in Each Row](https://leetcode.com/problems/delete-greatest-value-in-each-row/)"
                    },
                    {
                        "username": "abhijay_123",
                        "content": "Why sort ?\\nand why selecting the largest value in a column fails?"
                    },
                    {
                        "username": "vinnnu",
                        "content": "[@candy45](/candy45) thanks mate "
                    },
                    {
                        "username": "HarshitRaj_14",
                        "content": "[@arshikamishra](/arshikamishra) Because in every iteration we have to remove the maximum element from each row. \\nIt is not mandatory that the maximum element will always be at column number i so we sort every row in order to make sure that the maximum number is at ith column.\\nThe question has specifically asked us to - From each row in the matrix, select the largest number and remove it. So first sort it rowwise to get the largest element first.\\n \\nPlease upvote if you understood"
                    },
                    {
                        "username": "HarshitRaj_14",
                        "content": "Because in every iteration we have to remove the maximum element from each row. \\nIt is not mandatory that the maximum element will always be at column number i so we sort every row in order to make sure that the maximum number is at ith column.\\nThe question has specifically asked us to - From each row in the matrix, select the largest number and remove it. So first sort it rowwise to get the largest element first.\\n \\nPlease upvote if you understood"
                    },
                    {
                        "username": "arshikamishra",
                        "content": "[@candy45](/candy45) could you elaborate please"
                    },
                    {
                        "username": "candy45",
                        "content": "consider this case [[7,2,1],[6,1,4],[6,1,2],[3,2,1]] by taking max value in every column we will get answer as 13 but answer is 12"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "Can someone help me with my code?\\nWhy is not working ?\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        for(auto a:nums){\\n            sort(a.begin(),a.end());\\n        }\\n        int sum=0;\\n        for(int i=0;i<nums[0].size();i++){\\n            int maxi=0;\\n            for(int j=0;j<nums.size();j++){\\n                maxi=max(nums[j][i],maxi);\\n            }\\n            sum+=maxi;\\n        }\\n        return sum;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "avinash3300",
                        "content": "you want to write in for loop\\nfor(auto &a : nums){\\n            sort(a.begin(),a.end());\\n        }\\n"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "[@BadalArya](/BadalArya)  thanks bro \\n"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "[@Ankur_0152](/Ankur_0152)  Thanks bro\\n"
                    },
                    {
                        "username": "Ankur_0152",
                        "content": "either use \n        for(auto &a:nums)\n            sort(a.begin(),a.end());\nor \n       for(int i=0;i<nums.size();i++)\n           sort(nums[i].begin(),nums[i].end());\n        "
                    },
                    {
                        "username": "BadalArya",
                        "content": "for(auto &a : nums)\\n\\nYou need to use for each loop with address or it won\\'t sort the array"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "even i come up with the same sol, i don't understand sorting of rows req. did they ask in question ? "
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach :-)**\\n- Initialize the score to 0 and a variable called total to 0.\\n- While total is less than the total number of elements in the matrix:\\n- Create a priority queue to store the largest numbers from each row.\\n- For each row in the matrix, find the largest number that hasn\\'t been removed yet (i.e., its value is not -1), and add it to the priority queue.\\n- Remove the largest number from the priority queue and add it to the score.\\n- Mark the location of the removed number in the matrix by setting its value to -1.\\n- Increment the total variable to keep track of how many elements have been removed.\\n- Return the final score."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the Code Link :-)***\\nhttps://leetcode.com/problems/sum-in-a-matrix/solutions/3524127/easiest-solution-priorityqueue/"
                    },
                    {
                        "username": "Balwierz",
                        "content": "Identical to https://leetcode.com/problems/delete-greatest-value-in-each-row/"
                    },
                    {
                        "username": "rtanishka",
                        "content": "Why does this code pass only 116/1057 test cases \\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int score =0;\\n        priority_queue<int> pq;\\n        for(int j=0;j<nums[0].size();j++){\\n            for(int i=0;i<nums.size();i++){\\n                pq.push(nums[i][j]);\\n            }\\n            score += pq.top();\\n            while(!pq.empty()){\\n                pq.pop();\\n            }\\n        }\\n        return score;\\n    }\\n};"
                    },
                    {
                        "username": "Nazar2020",
                        "content": "Matrix row can be sorted asc or desc, it doesn\\'t matter"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "for me wheneve I try to iterate rows and column runtime error for no reason like even I used n = nums.size() and m = nums[0].size() still it says runtime but while 14 and 13 numbers it works what is wrong"
                    },
                    {
                        "username": "hacker363",
                        "content": "```class Solution:\n    def matrixSum(self, nums: List[List[int]]) -> int:\n        i = 0\n        ans = 0\n        while i<len(nums[0]):\n            l = sorted(nums, key=lambda x :x[i])[::-1]\n            ans+=l[0][i]\n            i+=1\n        return ans\n```\n\nCan anyone please tell me why my code only passes 116 testcases rather than all....\nPlease address the mistake I have made.\nif it finds helpful please upvote\n"
                    }
                ]
            },
            {
                "id": 1989259,
                "content": [
                    {
                        "username": "roboto7o32oo3",
                        "content": "This problem should be marked Easy....."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "how is your dp moving??"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "This problem is same as [2500. Delete Greatest Value in Each Row](https://leetcode.com/problems/delete-greatest-value-in-each-row/)"
                    },
                    {
                        "username": "abhijay_123",
                        "content": "Why sort ?\\nand why selecting the largest value in a column fails?"
                    },
                    {
                        "username": "vinnnu",
                        "content": "[@candy45](/candy45) thanks mate "
                    },
                    {
                        "username": "HarshitRaj_14",
                        "content": "[@arshikamishra](/arshikamishra) Because in every iteration we have to remove the maximum element from each row. \\nIt is not mandatory that the maximum element will always be at column number i so we sort every row in order to make sure that the maximum number is at ith column.\\nThe question has specifically asked us to - From each row in the matrix, select the largest number and remove it. So first sort it rowwise to get the largest element first.\\n \\nPlease upvote if you understood"
                    },
                    {
                        "username": "HarshitRaj_14",
                        "content": "Because in every iteration we have to remove the maximum element from each row. \\nIt is not mandatory that the maximum element will always be at column number i so we sort every row in order to make sure that the maximum number is at ith column.\\nThe question has specifically asked us to - From each row in the matrix, select the largest number and remove it. So first sort it rowwise to get the largest element first.\\n \\nPlease upvote if you understood"
                    },
                    {
                        "username": "arshikamishra",
                        "content": "[@candy45](/candy45) could you elaborate please"
                    },
                    {
                        "username": "candy45",
                        "content": "consider this case [[7,2,1],[6,1,4],[6,1,2],[3,2,1]] by taking max value in every column we will get answer as 13 but answer is 12"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "Can someone help me with my code?\\nWhy is not working ?\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        for(auto a:nums){\\n            sort(a.begin(),a.end());\\n        }\\n        int sum=0;\\n        for(int i=0;i<nums[0].size();i++){\\n            int maxi=0;\\n            for(int j=0;j<nums.size();j++){\\n                maxi=max(nums[j][i],maxi);\\n            }\\n            sum+=maxi;\\n        }\\n        return sum;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "avinash3300",
                        "content": "you want to write in for loop\\nfor(auto &a : nums){\\n            sort(a.begin(),a.end());\\n        }\\n"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "[@BadalArya](/BadalArya)  thanks bro \\n"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "[@Ankur_0152](/Ankur_0152)  Thanks bro\\n"
                    },
                    {
                        "username": "Ankur_0152",
                        "content": "either use \n        for(auto &a:nums)\n            sort(a.begin(),a.end());\nor \n       for(int i=0;i<nums.size();i++)\n           sort(nums[i].begin(),nums[i].end());\n        "
                    },
                    {
                        "username": "BadalArya",
                        "content": "for(auto &a : nums)\\n\\nYou need to use for each loop with address or it won\\'t sort the array"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "even i come up with the same sol, i don't understand sorting of rows req. did they ask in question ? "
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach :-)**\\n- Initialize the score to 0 and a variable called total to 0.\\n- While total is less than the total number of elements in the matrix:\\n- Create a priority queue to store the largest numbers from each row.\\n- For each row in the matrix, find the largest number that hasn\\'t been removed yet (i.e., its value is not -1), and add it to the priority queue.\\n- Remove the largest number from the priority queue and add it to the score.\\n- Mark the location of the removed number in the matrix by setting its value to -1.\\n- Increment the total variable to keep track of how many elements have been removed.\\n- Return the final score."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the Code Link :-)***\\nhttps://leetcode.com/problems/sum-in-a-matrix/solutions/3524127/easiest-solution-priorityqueue/"
                    },
                    {
                        "username": "Balwierz",
                        "content": "Identical to https://leetcode.com/problems/delete-greatest-value-in-each-row/"
                    },
                    {
                        "username": "rtanishka",
                        "content": "Why does this code pass only 116/1057 test cases \\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int score =0;\\n        priority_queue<int> pq;\\n        for(int j=0;j<nums[0].size();j++){\\n            for(int i=0;i<nums.size();i++){\\n                pq.push(nums[i][j]);\\n            }\\n            score += pq.top();\\n            while(!pq.empty()){\\n                pq.pop();\\n            }\\n        }\\n        return score;\\n    }\\n};"
                    },
                    {
                        "username": "Nazar2020",
                        "content": "Matrix row can be sorted asc or desc, it doesn\\'t matter"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "for me wheneve I try to iterate rows and column runtime error for no reason like even I used n = nums.size() and m = nums[0].size() still it says runtime but while 14 and 13 numbers it works what is wrong"
                    },
                    {
                        "username": "hacker363",
                        "content": "```class Solution:\n    def matrixSum(self, nums: List[List[int]]) -> int:\n        i = 0\n        ans = 0\n        while i<len(nums[0]):\n            l = sorted(nums, key=lambda x :x[i])[::-1]\n            ans+=l[0][i]\n            i+=1\n        return ans\n```\n\nCan anyone please tell me why my code only passes 116 testcases rather than all....\nPlease address the mistake I have made.\nif it finds helpful please upvote\n"
                    }
                ]
            },
            {
                "id": 1892461,
                "content": [
                    {
                        "username": "roboto7o32oo3",
                        "content": "This problem should be marked Easy....."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "how is your dp moving??"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "This problem is same as [2500. Delete Greatest Value in Each Row](https://leetcode.com/problems/delete-greatest-value-in-each-row/)"
                    },
                    {
                        "username": "abhijay_123",
                        "content": "Why sort ?\\nand why selecting the largest value in a column fails?"
                    },
                    {
                        "username": "vinnnu",
                        "content": "[@candy45](/candy45) thanks mate "
                    },
                    {
                        "username": "HarshitRaj_14",
                        "content": "[@arshikamishra](/arshikamishra) Because in every iteration we have to remove the maximum element from each row. \\nIt is not mandatory that the maximum element will always be at column number i so we sort every row in order to make sure that the maximum number is at ith column.\\nThe question has specifically asked us to - From each row in the matrix, select the largest number and remove it. So first sort it rowwise to get the largest element first.\\n \\nPlease upvote if you understood"
                    },
                    {
                        "username": "HarshitRaj_14",
                        "content": "Because in every iteration we have to remove the maximum element from each row. \\nIt is not mandatory that the maximum element will always be at column number i so we sort every row in order to make sure that the maximum number is at ith column.\\nThe question has specifically asked us to - From each row in the matrix, select the largest number and remove it. So first sort it rowwise to get the largest element first.\\n \\nPlease upvote if you understood"
                    },
                    {
                        "username": "arshikamishra",
                        "content": "[@candy45](/candy45) could you elaborate please"
                    },
                    {
                        "username": "candy45",
                        "content": "consider this case [[7,2,1],[6,1,4],[6,1,2],[3,2,1]] by taking max value in every column we will get answer as 13 but answer is 12"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "Can someone help me with my code?\\nWhy is not working ?\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        for(auto a:nums){\\n            sort(a.begin(),a.end());\\n        }\\n        int sum=0;\\n        for(int i=0;i<nums[0].size();i++){\\n            int maxi=0;\\n            for(int j=0;j<nums.size();j++){\\n                maxi=max(nums[j][i],maxi);\\n            }\\n            sum+=maxi;\\n        }\\n        return sum;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "avinash3300",
                        "content": "you want to write in for loop\\nfor(auto &a : nums){\\n            sort(a.begin(),a.end());\\n        }\\n"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "[@BadalArya](/BadalArya)  thanks bro \\n"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "[@Ankur_0152](/Ankur_0152)  Thanks bro\\n"
                    },
                    {
                        "username": "Ankur_0152",
                        "content": "either use \n        for(auto &a:nums)\n            sort(a.begin(),a.end());\nor \n       for(int i=0;i<nums.size();i++)\n           sort(nums[i].begin(),nums[i].end());\n        "
                    },
                    {
                        "username": "BadalArya",
                        "content": "for(auto &a : nums)\\n\\nYou need to use for each loop with address or it won\\'t sort the array"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "even i come up with the same sol, i don't understand sorting of rows req. did they ask in question ? "
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach :-)**\\n- Initialize the score to 0 and a variable called total to 0.\\n- While total is less than the total number of elements in the matrix:\\n- Create a priority queue to store the largest numbers from each row.\\n- For each row in the matrix, find the largest number that hasn\\'t been removed yet (i.e., its value is not -1), and add it to the priority queue.\\n- Remove the largest number from the priority queue and add it to the score.\\n- Mark the location of the removed number in the matrix by setting its value to -1.\\n- Increment the total variable to keep track of how many elements have been removed.\\n- Return the final score."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the Code Link :-)***\\nhttps://leetcode.com/problems/sum-in-a-matrix/solutions/3524127/easiest-solution-priorityqueue/"
                    },
                    {
                        "username": "Balwierz",
                        "content": "Identical to https://leetcode.com/problems/delete-greatest-value-in-each-row/"
                    },
                    {
                        "username": "rtanishka",
                        "content": "Why does this code pass only 116/1057 test cases \\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int score =0;\\n        priority_queue<int> pq;\\n        for(int j=0;j<nums[0].size();j++){\\n            for(int i=0;i<nums.size();i++){\\n                pq.push(nums[i][j]);\\n            }\\n            score += pq.top();\\n            while(!pq.empty()){\\n                pq.pop();\\n            }\\n        }\\n        return score;\\n    }\\n};"
                    },
                    {
                        "username": "Nazar2020",
                        "content": "Matrix row can be sorted asc or desc, it doesn\\'t matter"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "for me wheneve I try to iterate rows and column runtime error for no reason like even I used n = nums.size() and m = nums[0].size() still it says runtime but while 14 and 13 numbers it works what is wrong"
                    },
                    {
                        "username": "hacker363",
                        "content": "```class Solution:\n    def matrixSum(self, nums: List[List[int]]) -> int:\n        i = 0\n        ans = 0\n        while i<len(nums[0]):\n            l = sorted(nums, key=lambda x :x[i])[::-1]\n            ans+=l[0][i]\n            i+=1\n        return ans\n```\n\nCan anyone please tell me why my code only passes 116 testcases rather than all....\nPlease address the mistake I have made.\nif it finds helpful please upvote\n"
                    }
                ]
            },
            {
                "id": 1892785,
                "content": [
                    {
                        "username": "roboto7o32oo3",
                        "content": "This problem should be marked Easy....."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "how is your dp moving??"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "This problem is same as [2500. Delete Greatest Value in Each Row](https://leetcode.com/problems/delete-greatest-value-in-each-row/)"
                    },
                    {
                        "username": "abhijay_123",
                        "content": "Why sort ?\\nand why selecting the largest value in a column fails?"
                    },
                    {
                        "username": "vinnnu",
                        "content": "[@candy45](/candy45) thanks mate "
                    },
                    {
                        "username": "HarshitRaj_14",
                        "content": "[@arshikamishra](/arshikamishra) Because in every iteration we have to remove the maximum element from each row. \\nIt is not mandatory that the maximum element will always be at column number i so we sort every row in order to make sure that the maximum number is at ith column.\\nThe question has specifically asked us to - From each row in the matrix, select the largest number and remove it. So first sort it rowwise to get the largest element first.\\n \\nPlease upvote if you understood"
                    },
                    {
                        "username": "HarshitRaj_14",
                        "content": "Because in every iteration we have to remove the maximum element from each row. \\nIt is not mandatory that the maximum element will always be at column number i so we sort every row in order to make sure that the maximum number is at ith column.\\nThe question has specifically asked us to - From each row in the matrix, select the largest number and remove it. So first sort it rowwise to get the largest element first.\\n \\nPlease upvote if you understood"
                    },
                    {
                        "username": "arshikamishra",
                        "content": "[@candy45](/candy45) could you elaborate please"
                    },
                    {
                        "username": "candy45",
                        "content": "consider this case [[7,2,1],[6,1,4],[6,1,2],[3,2,1]] by taking max value in every column we will get answer as 13 but answer is 12"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "Can someone help me with my code?\\nWhy is not working ?\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        for(auto a:nums){\\n            sort(a.begin(),a.end());\\n        }\\n        int sum=0;\\n        for(int i=0;i<nums[0].size();i++){\\n            int maxi=0;\\n            for(int j=0;j<nums.size();j++){\\n                maxi=max(nums[j][i],maxi);\\n            }\\n            sum+=maxi;\\n        }\\n        return sum;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "avinash3300",
                        "content": "you want to write in for loop\\nfor(auto &a : nums){\\n            sort(a.begin(),a.end());\\n        }\\n"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "[@BadalArya](/BadalArya)  thanks bro \\n"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "[@Ankur_0152](/Ankur_0152)  Thanks bro\\n"
                    },
                    {
                        "username": "Ankur_0152",
                        "content": "either use \n        for(auto &a:nums)\n            sort(a.begin(),a.end());\nor \n       for(int i=0;i<nums.size();i++)\n           sort(nums[i].begin(),nums[i].end());\n        "
                    },
                    {
                        "username": "BadalArya",
                        "content": "for(auto &a : nums)\\n\\nYou need to use for each loop with address or it won\\'t sort the array"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "even i come up with the same sol, i don't understand sorting of rows req. did they ask in question ? "
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach :-)**\\n- Initialize the score to 0 and a variable called total to 0.\\n- While total is less than the total number of elements in the matrix:\\n- Create a priority queue to store the largest numbers from each row.\\n- For each row in the matrix, find the largest number that hasn\\'t been removed yet (i.e., its value is not -1), and add it to the priority queue.\\n- Remove the largest number from the priority queue and add it to the score.\\n- Mark the location of the removed number in the matrix by setting its value to -1.\\n- Increment the total variable to keep track of how many elements have been removed.\\n- Return the final score."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the Code Link :-)***\\nhttps://leetcode.com/problems/sum-in-a-matrix/solutions/3524127/easiest-solution-priorityqueue/"
                    },
                    {
                        "username": "Balwierz",
                        "content": "Identical to https://leetcode.com/problems/delete-greatest-value-in-each-row/"
                    },
                    {
                        "username": "rtanishka",
                        "content": "Why does this code pass only 116/1057 test cases \\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int score =0;\\n        priority_queue<int> pq;\\n        for(int j=0;j<nums[0].size();j++){\\n            for(int i=0;i<nums.size();i++){\\n                pq.push(nums[i][j]);\\n            }\\n            score += pq.top();\\n            while(!pq.empty()){\\n                pq.pop();\\n            }\\n        }\\n        return score;\\n    }\\n};"
                    },
                    {
                        "username": "Nazar2020",
                        "content": "Matrix row can be sorted asc or desc, it doesn\\'t matter"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "for me wheneve I try to iterate rows and column runtime error for no reason like even I used n = nums.size() and m = nums[0].size() still it says runtime but while 14 and 13 numbers it works what is wrong"
                    },
                    {
                        "username": "hacker363",
                        "content": "```class Solution:\n    def matrixSum(self, nums: List[List[int]]) -> int:\n        i = 0\n        ans = 0\n        while i<len(nums[0]):\n            l = sorted(nums, key=lambda x :x[i])[::-1]\n            ans+=l[0][i]\n            i+=1\n        return ans\n```\n\nCan anyone please tell me why my code only passes 116 testcases rather than all....\nPlease address the mistake I have made.\nif it finds helpful please upvote\n"
                    }
                ]
            },
            {
                "id": 1892799,
                "content": [
                    {
                        "username": "roboto7o32oo3",
                        "content": "This problem should be marked Easy....."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "how is your dp moving??"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "This problem is same as [2500. Delete Greatest Value in Each Row](https://leetcode.com/problems/delete-greatest-value-in-each-row/)"
                    },
                    {
                        "username": "abhijay_123",
                        "content": "Why sort ?\\nand why selecting the largest value in a column fails?"
                    },
                    {
                        "username": "vinnnu",
                        "content": "[@candy45](/candy45) thanks mate "
                    },
                    {
                        "username": "HarshitRaj_14",
                        "content": "[@arshikamishra](/arshikamishra) Because in every iteration we have to remove the maximum element from each row. \\nIt is not mandatory that the maximum element will always be at column number i so we sort every row in order to make sure that the maximum number is at ith column.\\nThe question has specifically asked us to - From each row in the matrix, select the largest number and remove it. So first sort it rowwise to get the largest element first.\\n \\nPlease upvote if you understood"
                    },
                    {
                        "username": "HarshitRaj_14",
                        "content": "Because in every iteration we have to remove the maximum element from each row. \\nIt is not mandatory that the maximum element will always be at column number i so we sort every row in order to make sure that the maximum number is at ith column.\\nThe question has specifically asked us to - From each row in the matrix, select the largest number and remove it. So first sort it rowwise to get the largest element first.\\n \\nPlease upvote if you understood"
                    },
                    {
                        "username": "arshikamishra",
                        "content": "[@candy45](/candy45) could you elaborate please"
                    },
                    {
                        "username": "candy45",
                        "content": "consider this case [[7,2,1],[6,1,4],[6,1,2],[3,2,1]] by taking max value in every column we will get answer as 13 but answer is 12"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "Can someone help me with my code?\\nWhy is not working ?\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        for(auto a:nums){\\n            sort(a.begin(),a.end());\\n        }\\n        int sum=0;\\n        for(int i=0;i<nums[0].size();i++){\\n            int maxi=0;\\n            for(int j=0;j<nums.size();j++){\\n                maxi=max(nums[j][i],maxi);\\n            }\\n            sum+=maxi;\\n        }\\n        return sum;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "avinash3300",
                        "content": "you want to write in for loop\\nfor(auto &a : nums){\\n            sort(a.begin(),a.end());\\n        }\\n"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "[@BadalArya](/BadalArya)  thanks bro \\n"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "[@Ankur_0152](/Ankur_0152)  Thanks bro\\n"
                    },
                    {
                        "username": "Ankur_0152",
                        "content": "either use \n        for(auto &a:nums)\n            sort(a.begin(),a.end());\nor \n       for(int i=0;i<nums.size();i++)\n           sort(nums[i].begin(),nums[i].end());\n        "
                    },
                    {
                        "username": "BadalArya",
                        "content": "for(auto &a : nums)\\n\\nYou need to use for each loop with address or it won\\'t sort the array"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "even i come up with the same sol, i don't understand sorting of rows req. did they ask in question ? "
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach :-)**\\n- Initialize the score to 0 and a variable called total to 0.\\n- While total is less than the total number of elements in the matrix:\\n- Create a priority queue to store the largest numbers from each row.\\n- For each row in the matrix, find the largest number that hasn\\'t been removed yet (i.e., its value is not -1), and add it to the priority queue.\\n- Remove the largest number from the priority queue and add it to the score.\\n- Mark the location of the removed number in the matrix by setting its value to -1.\\n- Increment the total variable to keep track of how many elements have been removed.\\n- Return the final score."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the Code Link :-)***\\nhttps://leetcode.com/problems/sum-in-a-matrix/solutions/3524127/easiest-solution-priorityqueue/"
                    },
                    {
                        "username": "Balwierz",
                        "content": "Identical to https://leetcode.com/problems/delete-greatest-value-in-each-row/"
                    },
                    {
                        "username": "rtanishka",
                        "content": "Why does this code pass only 116/1057 test cases \\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int score =0;\\n        priority_queue<int> pq;\\n        for(int j=0;j<nums[0].size();j++){\\n            for(int i=0;i<nums.size();i++){\\n                pq.push(nums[i][j]);\\n            }\\n            score += pq.top();\\n            while(!pq.empty()){\\n                pq.pop();\\n            }\\n        }\\n        return score;\\n    }\\n};"
                    },
                    {
                        "username": "Nazar2020",
                        "content": "Matrix row can be sorted asc or desc, it doesn\\'t matter"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "for me wheneve I try to iterate rows and column runtime error for no reason like even I used n = nums.size() and m = nums[0].size() still it says runtime but while 14 and 13 numbers it works what is wrong"
                    },
                    {
                        "username": "hacker363",
                        "content": "```class Solution:\n    def matrixSum(self, nums: List[List[int]]) -> int:\n        i = 0\n        ans = 0\n        while i<len(nums[0]):\n            l = sorted(nums, key=lambda x :x[i])[::-1]\n            ans+=l[0][i]\n            i+=1\n        return ans\n```\n\nCan anyone please tell me why my code only passes 116 testcases rather than all....\nPlease address the mistake I have made.\nif it finds helpful please upvote\n"
                    }
                ]
            },
            {
                "id": 1892459,
                "content": [
                    {
                        "username": "roboto7o32oo3",
                        "content": "This problem should be marked Easy....."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "how is your dp moving??"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "This problem is same as [2500. Delete Greatest Value in Each Row](https://leetcode.com/problems/delete-greatest-value-in-each-row/)"
                    },
                    {
                        "username": "abhijay_123",
                        "content": "Why sort ?\\nand why selecting the largest value in a column fails?"
                    },
                    {
                        "username": "vinnnu",
                        "content": "[@candy45](/candy45) thanks mate "
                    },
                    {
                        "username": "HarshitRaj_14",
                        "content": "[@arshikamishra](/arshikamishra) Because in every iteration we have to remove the maximum element from each row. \\nIt is not mandatory that the maximum element will always be at column number i so we sort every row in order to make sure that the maximum number is at ith column.\\nThe question has specifically asked us to - From each row in the matrix, select the largest number and remove it. So first sort it rowwise to get the largest element first.\\n \\nPlease upvote if you understood"
                    },
                    {
                        "username": "HarshitRaj_14",
                        "content": "Because in every iteration we have to remove the maximum element from each row. \\nIt is not mandatory that the maximum element will always be at column number i so we sort every row in order to make sure that the maximum number is at ith column.\\nThe question has specifically asked us to - From each row in the matrix, select the largest number and remove it. So first sort it rowwise to get the largest element first.\\n \\nPlease upvote if you understood"
                    },
                    {
                        "username": "arshikamishra",
                        "content": "[@candy45](/candy45) could you elaborate please"
                    },
                    {
                        "username": "candy45",
                        "content": "consider this case [[7,2,1],[6,1,4],[6,1,2],[3,2,1]] by taking max value in every column we will get answer as 13 but answer is 12"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "Can someone help me with my code?\\nWhy is not working ?\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        for(auto a:nums){\\n            sort(a.begin(),a.end());\\n        }\\n        int sum=0;\\n        for(int i=0;i<nums[0].size();i++){\\n            int maxi=0;\\n            for(int j=0;j<nums.size();j++){\\n                maxi=max(nums[j][i],maxi);\\n            }\\n            sum+=maxi;\\n        }\\n        return sum;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "avinash3300",
                        "content": "you want to write in for loop\\nfor(auto &a : nums){\\n            sort(a.begin(),a.end());\\n        }\\n"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "[@BadalArya](/BadalArya)  thanks bro \\n"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "[@Ankur_0152](/Ankur_0152)  Thanks bro\\n"
                    },
                    {
                        "username": "Ankur_0152",
                        "content": "either use \n        for(auto &a:nums)\n            sort(a.begin(),a.end());\nor \n       for(int i=0;i<nums.size();i++)\n           sort(nums[i].begin(),nums[i].end());\n        "
                    },
                    {
                        "username": "BadalArya",
                        "content": "for(auto &a : nums)\\n\\nYou need to use for each loop with address or it won\\'t sort the array"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "even i come up with the same sol, i don't understand sorting of rows req. did they ask in question ? "
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach :-)**\\n- Initialize the score to 0 and a variable called total to 0.\\n- While total is less than the total number of elements in the matrix:\\n- Create a priority queue to store the largest numbers from each row.\\n- For each row in the matrix, find the largest number that hasn\\'t been removed yet (i.e., its value is not -1), and add it to the priority queue.\\n- Remove the largest number from the priority queue and add it to the score.\\n- Mark the location of the removed number in the matrix by setting its value to -1.\\n- Increment the total variable to keep track of how many elements have been removed.\\n- Return the final score."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the Code Link :-)***\\nhttps://leetcode.com/problems/sum-in-a-matrix/solutions/3524127/easiest-solution-priorityqueue/"
                    },
                    {
                        "username": "Balwierz",
                        "content": "Identical to https://leetcode.com/problems/delete-greatest-value-in-each-row/"
                    },
                    {
                        "username": "rtanishka",
                        "content": "Why does this code pass only 116/1057 test cases \\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int score =0;\\n        priority_queue<int> pq;\\n        for(int j=0;j<nums[0].size();j++){\\n            for(int i=0;i<nums.size();i++){\\n                pq.push(nums[i][j]);\\n            }\\n            score += pq.top();\\n            while(!pq.empty()){\\n                pq.pop();\\n            }\\n        }\\n        return score;\\n    }\\n};"
                    },
                    {
                        "username": "Nazar2020",
                        "content": "Matrix row can be sorted asc or desc, it doesn\\'t matter"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "for me wheneve I try to iterate rows and column runtime error for no reason like even I used n = nums.size() and m = nums[0].size() still it says runtime but while 14 and 13 numbers it works what is wrong"
                    },
                    {
                        "username": "hacker363",
                        "content": "```class Solution:\n    def matrixSum(self, nums: List[List[int]]) -> int:\n        i = 0\n        ans = 0\n        while i<len(nums[0]):\n            l = sorted(nums, key=lambda x :x[i])[::-1]\n            ans+=l[0][i]\n            i+=1\n        return ans\n```\n\nCan anyone please tell me why my code only passes 116 testcases rather than all....\nPlease address the mistake I have made.\nif it finds helpful please upvote\n"
                    }
                ]
            },
            {
                "id": 1893910,
                "content": [
                    {
                        "username": "roboto7o32oo3",
                        "content": "This problem should be marked Easy....."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "how is your dp moving??"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "This problem is same as [2500. Delete Greatest Value in Each Row](https://leetcode.com/problems/delete-greatest-value-in-each-row/)"
                    },
                    {
                        "username": "abhijay_123",
                        "content": "Why sort ?\\nand why selecting the largest value in a column fails?"
                    },
                    {
                        "username": "vinnnu",
                        "content": "[@candy45](/candy45) thanks mate "
                    },
                    {
                        "username": "HarshitRaj_14",
                        "content": "[@arshikamishra](/arshikamishra) Because in every iteration we have to remove the maximum element from each row. \\nIt is not mandatory that the maximum element will always be at column number i so we sort every row in order to make sure that the maximum number is at ith column.\\nThe question has specifically asked us to - From each row in the matrix, select the largest number and remove it. So first sort it rowwise to get the largest element first.\\n \\nPlease upvote if you understood"
                    },
                    {
                        "username": "HarshitRaj_14",
                        "content": "Because in every iteration we have to remove the maximum element from each row. \\nIt is not mandatory that the maximum element will always be at column number i so we sort every row in order to make sure that the maximum number is at ith column.\\nThe question has specifically asked us to - From each row in the matrix, select the largest number and remove it. So first sort it rowwise to get the largest element first.\\n \\nPlease upvote if you understood"
                    },
                    {
                        "username": "arshikamishra",
                        "content": "[@candy45](/candy45) could you elaborate please"
                    },
                    {
                        "username": "candy45",
                        "content": "consider this case [[7,2,1],[6,1,4],[6,1,2],[3,2,1]] by taking max value in every column we will get answer as 13 but answer is 12"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "Can someone help me with my code?\\nWhy is not working ?\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        for(auto a:nums){\\n            sort(a.begin(),a.end());\\n        }\\n        int sum=0;\\n        for(int i=0;i<nums[0].size();i++){\\n            int maxi=0;\\n            for(int j=0;j<nums.size();j++){\\n                maxi=max(nums[j][i],maxi);\\n            }\\n            sum+=maxi;\\n        }\\n        return sum;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "avinash3300",
                        "content": "you want to write in for loop\\nfor(auto &a : nums){\\n            sort(a.begin(),a.end());\\n        }\\n"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "[@BadalArya](/BadalArya)  thanks bro \\n"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "[@Ankur_0152](/Ankur_0152)  Thanks bro\\n"
                    },
                    {
                        "username": "Ankur_0152",
                        "content": "either use \n        for(auto &a:nums)\n            sort(a.begin(),a.end());\nor \n       for(int i=0;i<nums.size();i++)\n           sort(nums[i].begin(),nums[i].end());\n        "
                    },
                    {
                        "username": "BadalArya",
                        "content": "for(auto &a : nums)\\n\\nYou need to use for each loop with address or it won\\'t sort the array"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "even i come up with the same sol, i don't understand sorting of rows req. did they ask in question ? "
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach :-)**\\n- Initialize the score to 0 and a variable called total to 0.\\n- While total is less than the total number of elements in the matrix:\\n- Create a priority queue to store the largest numbers from each row.\\n- For each row in the matrix, find the largest number that hasn\\'t been removed yet (i.e., its value is not -1), and add it to the priority queue.\\n- Remove the largest number from the priority queue and add it to the score.\\n- Mark the location of the removed number in the matrix by setting its value to -1.\\n- Increment the total variable to keep track of how many elements have been removed.\\n- Return the final score."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the Code Link :-)***\\nhttps://leetcode.com/problems/sum-in-a-matrix/solutions/3524127/easiest-solution-priorityqueue/"
                    },
                    {
                        "username": "Balwierz",
                        "content": "Identical to https://leetcode.com/problems/delete-greatest-value-in-each-row/"
                    },
                    {
                        "username": "rtanishka",
                        "content": "Why does this code pass only 116/1057 test cases \\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int score =0;\\n        priority_queue<int> pq;\\n        for(int j=0;j<nums[0].size();j++){\\n            for(int i=0;i<nums.size();i++){\\n                pq.push(nums[i][j]);\\n            }\\n            score += pq.top();\\n            while(!pq.empty()){\\n                pq.pop();\\n            }\\n        }\\n        return score;\\n    }\\n};"
                    },
                    {
                        "username": "Nazar2020",
                        "content": "Matrix row can be sorted asc or desc, it doesn\\'t matter"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "for me wheneve I try to iterate rows and column runtime error for no reason like even I used n = nums.size() and m = nums[0].size() still it says runtime but while 14 and 13 numbers it works what is wrong"
                    },
                    {
                        "username": "hacker363",
                        "content": "```class Solution:\n    def matrixSum(self, nums: List[List[int]]) -> int:\n        i = 0\n        ans = 0\n        while i<len(nums[0]):\n            l = sorted(nums, key=lambda x :x[i])[::-1]\n            ans+=l[0][i]\n            i+=1\n        return ans\n```\n\nCan anyone please tell me why my code only passes 116 testcases rather than all....\nPlease address the mistake I have made.\nif it finds helpful please upvote\n"
                    }
                ]
            },
            {
                "id": 1893821,
                "content": [
                    {
                        "username": "roboto7o32oo3",
                        "content": "This problem should be marked Easy....."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "how is your dp moving??"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "This problem is same as [2500. Delete Greatest Value in Each Row](https://leetcode.com/problems/delete-greatest-value-in-each-row/)"
                    },
                    {
                        "username": "abhijay_123",
                        "content": "Why sort ?\\nand why selecting the largest value in a column fails?"
                    },
                    {
                        "username": "vinnnu",
                        "content": "[@candy45](/candy45) thanks mate "
                    },
                    {
                        "username": "HarshitRaj_14",
                        "content": "[@arshikamishra](/arshikamishra) Because in every iteration we have to remove the maximum element from each row. \\nIt is not mandatory that the maximum element will always be at column number i so we sort every row in order to make sure that the maximum number is at ith column.\\nThe question has specifically asked us to - From each row in the matrix, select the largest number and remove it. So first sort it rowwise to get the largest element first.\\n \\nPlease upvote if you understood"
                    },
                    {
                        "username": "HarshitRaj_14",
                        "content": "Because in every iteration we have to remove the maximum element from each row. \\nIt is not mandatory that the maximum element will always be at column number i so we sort every row in order to make sure that the maximum number is at ith column.\\nThe question has specifically asked us to - From each row in the matrix, select the largest number and remove it. So first sort it rowwise to get the largest element first.\\n \\nPlease upvote if you understood"
                    },
                    {
                        "username": "arshikamishra",
                        "content": "[@candy45](/candy45) could you elaborate please"
                    },
                    {
                        "username": "candy45",
                        "content": "consider this case [[7,2,1],[6,1,4],[6,1,2],[3,2,1]] by taking max value in every column we will get answer as 13 but answer is 12"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "Can someone help me with my code?\\nWhy is not working ?\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        for(auto a:nums){\\n            sort(a.begin(),a.end());\\n        }\\n        int sum=0;\\n        for(int i=0;i<nums[0].size();i++){\\n            int maxi=0;\\n            for(int j=0;j<nums.size();j++){\\n                maxi=max(nums[j][i],maxi);\\n            }\\n            sum+=maxi;\\n        }\\n        return sum;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "avinash3300",
                        "content": "you want to write in for loop\\nfor(auto &a : nums){\\n            sort(a.begin(),a.end());\\n        }\\n"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "[@BadalArya](/BadalArya)  thanks bro \\n"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "[@Ankur_0152](/Ankur_0152)  Thanks bro\\n"
                    },
                    {
                        "username": "Ankur_0152",
                        "content": "either use \n        for(auto &a:nums)\n            sort(a.begin(),a.end());\nor \n       for(int i=0;i<nums.size();i++)\n           sort(nums[i].begin(),nums[i].end());\n        "
                    },
                    {
                        "username": "BadalArya",
                        "content": "for(auto &a : nums)\\n\\nYou need to use for each loop with address or it won\\'t sort the array"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "even i come up with the same sol, i don't understand sorting of rows req. did they ask in question ? "
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach :-)**\\n- Initialize the score to 0 and a variable called total to 0.\\n- While total is less than the total number of elements in the matrix:\\n- Create a priority queue to store the largest numbers from each row.\\n- For each row in the matrix, find the largest number that hasn\\'t been removed yet (i.e., its value is not -1), and add it to the priority queue.\\n- Remove the largest number from the priority queue and add it to the score.\\n- Mark the location of the removed number in the matrix by setting its value to -1.\\n- Increment the total variable to keep track of how many elements have been removed.\\n- Return the final score."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the Code Link :-)***\\nhttps://leetcode.com/problems/sum-in-a-matrix/solutions/3524127/easiest-solution-priorityqueue/"
                    },
                    {
                        "username": "Balwierz",
                        "content": "Identical to https://leetcode.com/problems/delete-greatest-value-in-each-row/"
                    },
                    {
                        "username": "rtanishka",
                        "content": "Why does this code pass only 116/1057 test cases \\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int score =0;\\n        priority_queue<int> pq;\\n        for(int j=0;j<nums[0].size();j++){\\n            for(int i=0;i<nums.size();i++){\\n                pq.push(nums[i][j]);\\n            }\\n            score += pq.top();\\n            while(!pq.empty()){\\n                pq.pop();\\n            }\\n        }\\n        return score;\\n    }\\n};"
                    },
                    {
                        "username": "Nazar2020",
                        "content": "Matrix row can be sorted asc or desc, it doesn\\'t matter"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "for me wheneve I try to iterate rows and column runtime error for no reason like even I used n = nums.size() and m = nums[0].size() still it says runtime but while 14 and 13 numbers it works what is wrong"
                    },
                    {
                        "username": "hacker363",
                        "content": "```class Solution:\n    def matrixSum(self, nums: List[List[int]]) -> int:\n        i = 0\n        ans = 0\n        while i<len(nums[0]):\n            l = sorted(nums, key=lambda x :x[i])[::-1]\n            ans+=l[0][i]\n            i+=1\n        return ans\n```\n\nCan anyone please tell me why my code only passes 116 testcases rather than all....\nPlease address the mistake I have made.\nif it finds helpful please upvote\n"
                    }
                ]
            },
            {
                "id": 2046752,
                "content": [
                    {
                        "username": "roboto7o32oo3",
                        "content": "This problem should be marked Easy....."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "how is your dp moving??"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "This problem is same as [2500. Delete Greatest Value in Each Row](https://leetcode.com/problems/delete-greatest-value-in-each-row/)"
                    },
                    {
                        "username": "abhijay_123",
                        "content": "Why sort ?\\nand why selecting the largest value in a column fails?"
                    },
                    {
                        "username": "vinnnu",
                        "content": "[@candy45](/candy45) thanks mate "
                    },
                    {
                        "username": "HarshitRaj_14",
                        "content": "[@arshikamishra](/arshikamishra) Because in every iteration we have to remove the maximum element from each row. \\nIt is not mandatory that the maximum element will always be at column number i so we sort every row in order to make sure that the maximum number is at ith column.\\nThe question has specifically asked us to - From each row in the matrix, select the largest number and remove it. So first sort it rowwise to get the largest element first.\\n \\nPlease upvote if you understood"
                    },
                    {
                        "username": "HarshitRaj_14",
                        "content": "Because in every iteration we have to remove the maximum element from each row. \\nIt is not mandatory that the maximum element will always be at column number i so we sort every row in order to make sure that the maximum number is at ith column.\\nThe question has specifically asked us to - From each row in the matrix, select the largest number and remove it. So first sort it rowwise to get the largest element first.\\n \\nPlease upvote if you understood"
                    },
                    {
                        "username": "arshikamishra",
                        "content": "[@candy45](/candy45) could you elaborate please"
                    },
                    {
                        "username": "candy45",
                        "content": "consider this case [[7,2,1],[6,1,4],[6,1,2],[3,2,1]] by taking max value in every column we will get answer as 13 but answer is 12"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "Can someone help me with my code?\\nWhy is not working ?\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        for(auto a:nums){\\n            sort(a.begin(),a.end());\\n        }\\n        int sum=0;\\n        for(int i=0;i<nums[0].size();i++){\\n            int maxi=0;\\n            for(int j=0;j<nums.size();j++){\\n                maxi=max(nums[j][i],maxi);\\n            }\\n            sum+=maxi;\\n        }\\n        return sum;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "avinash3300",
                        "content": "you want to write in for loop\\nfor(auto &a : nums){\\n            sort(a.begin(),a.end());\\n        }\\n"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "[@BadalArya](/BadalArya)  thanks bro \\n"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "[@Ankur_0152](/Ankur_0152)  Thanks bro\\n"
                    },
                    {
                        "username": "Ankur_0152",
                        "content": "either use \n        for(auto &a:nums)\n            sort(a.begin(),a.end());\nor \n       for(int i=0;i<nums.size();i++)\n           sort(nums[i].begin(),nums[i].end());\n        "
                    },
                    {
                        "username": "BadalArya",
                        "content": "for(auto &a : nums)\\n\\nYou need to use for each loop with address or it won\\'t sort the array"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "even i come up with the same sol, i don't understand sorting of rows req. did they ask in question ? "
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach :-)**\\n- Initialize the score to 0 and a variable called total to 0.\\n- While total is less than the total number of elements in the matrix:\\n- Create a priority queue to store the largest numbers from each row.\\n- For each row in the matrix, find the largest number that hasn\\'t been removed yet (i.e., its value is not -1), and add it to the priority queue.\\n- Remove the largest number from the priority queue and add it to the score.\\n- Mark the location of the removed number in the matrix by setting its value to -1.\\n- Increment the total variable to keep track of how many elements have been removed.\\n- Return the final score."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the Code Link :-)***\\nhttps://leetcode.com/problems/sum-in-a-matrix/solutions/3524127/easiest-solution-priorityqueue/"
                    },
                    {
                        "username": "Balwierz",
                        "content": "Identical to https://leetcode.com/problems/delete-greatest-value-in-each-row/"
                    },
                    {
                        "username": "rtanishka",
                        "content": "Why does this code pass only 116/1057 test cases \\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int score =0;\\n        priority_queue<int> pq;\\n        for(int j=0;j<nums[0].size();j++){\\n            for(int i=0;i<nums.size();i++){\\n                pq.push(nums[i][j]);\\n            }\\n            score += pq.top();\\n            while(!pq.empty()){\\n                pq.pop();\\n            }\\n        }\\n        return score;\\n    }\\n};"
                    },
                    {
                        "username": "Nazar2020",
                        "content": "Matrix row can be sorted asc or desc, it doesn\\'t matter"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "for me wheneve I try to iterate rows and column runtime error for no reason like even I used n = nums.size() and m = nums[0].size() still it says runtime but while 14 and 13 numbers it works what is wrong"
                    },
                    {
                        "username": "hacker363",
                        "content": "```class Solution:\n    def matrixSum(self, nums: List[List[int]]) -> int:\n        i = 0\n        ans = 0\n        while i<len(nums[0]):\n            l = sorted(nums, key=lambda x :x[i])[::-1]\n            ans+=l[0][i]\n            i+=1\n        return ans\n```\n\nCan anyone please tell me why my code only passes 116 testcases rather than all....\nPlease address the mistake I have made.\nif it finds helpful please upvote\n"
                    }
                ]
            },
            {
                "id": 2037216,
                "content": [
                    {
                        "username": "roboto7o32oo3",
                        "content": "This problem should be marked Easy....."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "how is your dp moving??"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "This problem is same as [2500. Delete Greatest Value in Each Row](https://leetcode.com/problems/delete-greatest-value-in-each-row/)"
                    },
                    {
                        "username": "abhijay_123",
                        "content": "Why sort ?\\nand why selecting the largest value in a column fails?"
                    },
                    {
                        "username": "vinnnu",
                        "content": "[@candy45](/candy45) thanks mate "
                    },
                    {
                        "username": "HarshitRaj_14",
                        "content": "[@arshikamishra](/arshikamishra) Because in every iteration we have to remove the maximum element from each row. \\nIt is not mandatory that the maximum element will always be at column number i so we sort every row in order to make sure that the maximum number is at ith column.\\nThe question has specifically asked us to - From each row in the matrix, select the largest number and remove it. So first sort it rowwise to get the largest element first.\\n \\nPlease upvote if you understood"
                    },
                    {
                        "username": "HarshitRaj_14",
                        "content": "Because in every iteration we have to remove the maximum element from each row. \\nIt is not mandatory that the maximum element will always be at column number i so we sort every row in order to make sure that the maximum number is at ith column.\\nThe question has specifically asked us to - From each row in the matrix, select the largest number and remove it. So first sort it rowwise to get the largest element first.\\n \\nPlease upvote if you understood"
                    },
                    {
                        "username": "arshikamishra",
                        "content": "[@candy45](/candy45) could you elaborate please"
                    },
                    {
                        "username": "candy45",
                        "content": "consider this case [[7,2,1],[6,1,4],[6,1,2],[3,2,1]] by taking max value in every column we will get answer as 13 but answer is 12"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "Can someone help me with my code?\\nWhy is not working ?\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        for(auto a:nums){\\n            sort(a.begin(),a.end());\\n        }\\n        int sum=0;\\n        for(int i=0;i<nums[0].size();i++){\\n            int maxi=0;\\n            for(int j=0;j<nums.size();j++){\\n                maxi=max(nums[j][i],maxi);\\n            }\\n            sum+=maxi;\\n        }\\n        return sum;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "avinash3300",
                        "content": "you want to write in for loop\\nfor(auto &a : nums){\\n            sort(a.begin(),a.end());\\n        }\\n"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "[@BadalArya](/BadalArya)  thanks bro \\n"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "[@Ankur_0152](/Ankur_0152)  Thanks bro\\n"
                    },
                    {
                        "username": "Ankur_0152",
                        "content": "either use \n        for(auto &a:nums)\n            sort(a.begin(),a.end());\nor \n       for(int i=0;i<nums.size();i++)\n           sort(nums[i].begin(),nums[i].end());\n        "
                    },
                    {
                        "username": "BadalArya",
                        "content": "for(auto &a : nums)\\n\\nYou need to use for each loop with address or it won\\'t sort the array"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "even i come up with the same sol, i don't understand sorting of rows req. did they ask in question ? "
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach :-)**\\n- Initialize the score to 0 and a variable called total to 0.\\n- While total is less than the total number of elements in the matrix:\\n- Create a priority queue to store the largest numbers from each row.\\n- For each row in the matrix, find the largest number that hasn\\'t been removed yet (i.e., its value is not -1), and add it to the priority queue.\\n- Remove the largest number from the priority queue and add it to the score.\\n- Mark the location of the removed number in the matrix by setting its value to -1.\\n- Increment the total variable to keep track of how many elements have been removed.\\n- Return the final score."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the Code Link :-)***\\nhttps://leetcode.com/problems/sum-in-a-matrix/solutions/3524127/easiest-solution-priorityqueue/"
                    },
                    {
                        "username": "Balwierz",
                        "content": "Identical to https://leetcode.com/problems/delete-greatest-value-in-each-row/"
                    },
                    {
                        "username": "rtanishka",
                        "content": "Why does this code pass only 116/1057 test cases \\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int score =0;\\n        priority_queue<int> pq;\\n        for(int j=0;j<nums[0].size();j++){\\n            for(int i=0;i<nums.size();i++){\\n                pq.push(nums[i][j]);\\n            }\\n            score += pq.top();\\n            while(!pq.empty()){\\n                pq.pop();\\n            }\\n        }\\n        return score;\\n    }\\n};"
                    },
                    {
                        "username": "Nazar2020",
                        "content": "Matrix row can be sorted asc or desc, it doesn\\'t matter"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "for me wheneve I try to iterate rows and column runtime error for no reason like even I used n = nums.size() and m = nums[0].size() still it says runtime but while 14 and 13 numbers it works what is wrong"
                    },
                    {
                        "username": "hacker363",
                        "content": "```class Solution:\n    def matrixSum(self, nums: List[List[int]]) -> int:\n        i = 0\n        ans = 0\n        while i<len(nums[0]):\n            l = sorted(nums, key=lambda x :x[i])[::-1]\n            ans+=l[0][i]\n            i+=1\n        return ans\n```\n\nCan anyone please tell me why my code only passes 116 testcases rather than all....\nPlease address the mistake I have made.\nif it finds helpful please upvote\n"
                    }
                ]
            },
            {
                "id": 1990741,
                "content": [
                    {
                        "username": "roboto7o32oo3",
                        "content": "This problem should be marked Easy....."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "how is your dp moving??"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "This problem is same as [2500. Delete Greatest Value in Each Row](https://leetcode.com/problems/delete-greatest-value-in-each-row/)"
                    },
                    {
                        "username": "abhijay_123",
                        "content": "Why sort ?\\nand why selecting the largest value in a column fails?"
                    },
                    {
                        "username": "vinnnu",
                        "content": "[@candy45](/candy45) thanks mate "
                    },
                    {
                        "username": "HarshitRaj_14",
                        "content": "[@arshikamishra](/arshikamishra) Because in every iteration we have to remove the maximum element from each row. \\nIt is not mandatory that the maximum element will always be at column number i so we sort every row in order to make sure that the maximum number is at ith column.\\nThe question has specifically asked us to - From each row in the matrix, select the largest number and remove it. So first sort it rowwise to get the largest element first.\\n \\nPlease upvote if you understood"
                    },
                    {
                        "username": "HarshitRaj_14",
                        "content": "Because in every iteration we have to remove the maximum element from each row. \\nIt is not mandatory that the maximum element will always be at column number i so we sort every row in order to make sure that the maximum number is at ith column.\\nThe question has specifically asked us to - From each row in the matrix, select the largest number and remove it. So first sort it rowwise to get the largest element first.\\n \\nPlease upvote if you understood"
                    },
                    {
                        "username": "arshikamishra",
                        "content": "[@candy45](/candy45) could you elaborate please"
                    },
                    {
                        "username": "candy45",
                        "content": "consider this case [[7,2,1],[6,1,4],[6,1,2],[3,2,1]] by taking max value in every column we will get answer as 13 but answer is 12"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "Can someone help me with my code?\\nWhy is not working ?\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        for(auto a:nums){\\n            sort(a.begin(),a.end());\\n        }\\n        int sum=0;\\n        for(int i=0;i<nums[0].size();i++){\\n            int maxi=0;\\n            for(int j=0;j<nums.size();j++){\\n                maxi=max(nums[j][i],maxi);\\n            }\\n            sum+=maxi;\\n        }\\n        return sum;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "avinash3300",
                        "content": "you want to write in for loop\\nfor(auto &a : nums){\\n            sort(a.begin(),a.end());\\n        }\\n"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "[@BadalArya](/BadalArya)  thanks bro \\n"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "[@Ankur_0152](/Ankur_0152)  Thanks bro\\n"
                    },
                    {
                        "username": "Ankur_0152",
                        "content": "either use \n        for(auto &a:nums)\n            sort(a.begin(),a.end());\nor \n       for(int i=0;i<nums.size();i++)\n           sort(nums[i].begin(),nums[i].end());\n        "
                    },
                    {
                        "username": "BadalArya",
                        "content": "for(auto &a : nums)\\n\\nYou need to use for each loop with address or it won\\'t sort the array"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "even i come up with the same sol, i don't understand sorting of rows req. did they ask in question ? "
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach :-)**\\n- Initialize the score to 0 and a variable called total to 0.\\n- While total is less than the total number of elements in the matrix:\\n- Create a priority queue to store the largest numbers from each row.\\n- For each row in the matrix, find the largest number that hasn\\'t been removed yet (i.e., its value is not -1), and add it to the priority queue.\\n- Remove the largest number from the priority queue and add it to the score.\\n- Mark the location of the removed number in the matrix by setting its value to -1.\\n- Increment the total variable to keep track of how many elements have been removed.\\n- Return the final score."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the Code Link :-)***\\nhttps://leetcode.com/problems/sum-in-a-matrix/solutions/3524127/easiest-solution-priorityqueue/"
                    },
                    {
                        "username": "Balwierz",
                        "content": "Identical to https://leetcode.com/problems/delete-greatest-value-in-each-row/"
                    },
                    {
                        "username": "rtanishka",
                        "content": "Why does this code pass only 116/1057 test cases \\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int score =0;\\n        priority_queue<int> pq;\\n        for(int j=0;j<nums[0].size();j++){\\n            for(int i=0;i<nums.size();i++){\\n                pq.push(nums[i][j]);\\n            }\\n            score += pq.top();\\n            while(!pq.empty()){\\n                pq.pop();\\n            }\\n        }\\n        return score;\\n    }\\n};"
                    },
                    {
                        "username": "Nazar2020",
                        "content": "Matrix row can be sorted asc or desc, it doesn\\'t matter"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "for me wheneve I try to iterate rows and column runtime error for no reason like even I used n = nums.size() and m = nums[0].size() still it says runtime but while 14 and 13 numbers it works what is wrong"
                    },
                    {
                        "username": "hacker363",
                        "content": "```class Solution:\n    def matrixSum(self, nums: List[List[int]]) -> int:\n        i = 0\n        ans = 0\n        while i<len(nums[0]):\n            l = sorted(nums, key=lambda x :x[i])[::-1]\n            ans+=l[0][i]\n            i+=1\n        return ans\n```\n\nCan anyone please tell me why my code only passes 116 testcases rather than all....\nPlease address the mistake I have made.\nif it finds helpful please upvote\n"
                    }
                ]
            },
            {
                "id": 1989259,
                "content": [
                    {
                        "username": "roboto7o32oo3",
                        "content": "This problem should be marked Easy....."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "how is your dp moving??"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "This problem is same as [2500. Delete Greatest Value in Each Row](https://leetcode.com/problems/delete-greatest-value-in-each-row/)"
                    },
                    {
                        "username": "abhijay_123",
                        "content": "Why sort ?\\nand why selecting the largest value in a column fails?"
                    },
                    {
                        "username": "vinnnu",
                        "content": "[@candy45](/candy45) thanks mate "
                    },
                    {
                        "username": "HarshitRaj_14",
                        "content": "[@arshikamishra](/arshikamishra) Because in every iteration we have to remove the maximum element from each row. \\nIt is not mandatory that the maximum element will always be at column number i so we sort every row in order to make sure that the maximum number is at ith column.\\nThe question has specifically asked us to - From each row in the matrix, select the largest number and remove it. So first sort it rowwise to get the largest element first.\\n \\nPlease upvote if you understood"
                    },
                    {
                        "username": "HarshitRaj_14",
                        "content": "Because in every iteration we have to remove the maximum element from each row. \\nIt is not mandatory that the maximum element will always be at column number i so we sort every row in order to make sure that the maximum number is at ith column.\\nThe question has specifically asked us to - From each row in the matrix, select the largest number and remove it. So first sort it rowwise to get the largest element first.\\n \\nPlease upvote if you understood"
                    },
                    {
                        "username": "arshikamishra",
                        "content": "[@candy45](/candy45) could you elaborate please"
                    },
                    {
                        "username": "candy45",
                        "content": "consider this case [[7,2,1],[6,1,4],[6,1,2],[3,2,1]] by taking max value in every column we will get answer as 13 but answer is 12"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "Can someone help me with my code?\\nWhy is not working ?\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        for(auto a:nums){\\n            sort(a.begin(),a.end());\\n        }\\n        int sum=0;\\n        for(int i=0;i<nums[0].size();i++){\\n            int maxi=0;\\n            for(int j=0;j<nums.size();j++){\\n                maxi=max(nums[j][i],maxi);\\n            }\\n            sum+=maxi;\\n        }\\n        return sum;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "avinash3300",
                        "content": "you want to write in for loop\\nfor(auto &a : nums){\\n            sort(a.begin(),a.end());\\n        }\\n"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "[@BadalArya](/BadalArya)  thanks bro \\n"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "[@Ankur_0152](/Ankur_0152)  Thanks bro\\n"
                    },
                    {
                        "username": "Ankur_0152",
                        "content": "either use \n        for(auto &a:nums)\n            sort(a.begin(),a.end());\nor \n       for(int i=0;i<nums.size();i++)\n           sort(nums[i].begin(),nums[i].end());\n        "
                    },
                    {
                        "username": "BadalArya",
                        "content": "for(auto &a : nums)\\n\\nYou need to use for each loop with address or it won\\'t sort the array"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "even i come up with the same sol, i don't understand sorting of rows req. did they ask in question ? "
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach :-)**\\n- Initialize the score to 0 and a variable called total to 0.\\n- While total is less than the total number of elements in the matrix:\\n- Create a priority queue to store the largest numbers from each row.\\n- For each row in the matrix, find the largest number that hasn\\'t been removed yet (i.e., its value is not -1), and add it to the priority queue.\\n- Remove the largest number from the priority queue and add it to the score.\\n- Mark the location of the removed number in the matrix by setting its value to -1.\\n- Increment the total variable to keep track of how many elements have been removed.\\n- Return the final score."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the Code Link :-)***\\nhttps://leetcode.com/problems/sum-in-a-matrix/solutions/3524127/easiest-solution-priorityqueue/"
                    },
                    {
                        "username": "Balwierz",
                        "content": "Identical to https://leetcode.com/problems/delete-greatest-value-in-each-row/"
                    },
                    {
                        "username": "rtanishka",
                        "content": "Why does this code pass only 116/1057 test cases \\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int score =0;\\n        priority_queue<int> pq;\\n        for(int j=0;j<nums[0].size();j++){\\n            for(int i=0;i<nums.size();i++){\\n                pq.push(nums[i][j]);\\n            }\\n            score += pq.top();\\n            while(!pq.empty()){\\n                pq.pop();\\n            }\\n        }\\n        return score;\\n    }\\n};"
                    },
                    {
                        "username": "Nazar2020",
                        "content": "Matrix row can be sorted asc or desc, it doesn\\'t matter"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "for me wheneve I try to iterate rows and column runtime error for no reason like even I used n = nums.size() and m = nums[0].size() still it says runtime but while 14 and 13 numbers it works what is wrong"
                    },
                    {
                        "username": "hacker363",
                        "content": "```class Solution:\n    def matrixSum(self, nums: List[List[int]]) -> int:\n        i = 0\n        ans = 0\n        while i<len(nums[0]):\n            l = sorted(nums, key=lambda x :x[i])[::-1]\n            ans+=l[0][i]\n            i+=1\n        return ans\n```\n\nCan anyone please tell me why my code only passes 116 testcases rather than all....\nPlease address the mistake I have made.\nif it finds helpful please upvote\n"
                    }
                ]
            }
        ]
    }
]