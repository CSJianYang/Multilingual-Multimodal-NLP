[
    {
        "title": "Groups of Strings",
        "question_content": "You are given a 0-indexed array of strings words. Each string consists of lowercase English letters only. No letter occurs more than once in any string of words.\nTwo strings s1 and s2 are said to be connected if the set of letters of s2 can be obtained from the set of letters of s1 by any one of the following operations:\n\n\tAdding exactly one letter to the set of the letters of s1.\n\tDeleting exactly one letter from the set of the letters of s1.\n\tReplacing exactly one letter from the set of the letters of s1 with any letter, including itself.\n\nThe array words can be divided into one or more non-intersecting groups. A string belongs to a group if any one of the following is true:\n\n\tIt is connected to at least one other string of the group.\n\tIt is the only string present in the group.\n\nNote that the strings in words should be grouped in such a manner that a string belonging to a group cannot be connected to a string present in any other group. It can be proved that such an arrangement is always unique.\nReturn an array ans of size 2 where:\n\n\tans[0] is the maximum number of groups words can be divided into, and\n\tans[1] is the size of the largest group.\n\n&nbsp;\nExample 1:\n\nInput: words = [\"a\",\"b\",\"ab\",\"cde\"]\nOutput: [2,3]\nExplanation:\n- words[0] can be used to obtain words[1] (by replacing 'a' with 'b'), and words[2] (by adding 'b'). So words[0] is connected to words[1] and words[2].\n- words[1] can be used to obtain words[0] (by replacing 'b' with 'a'), and words[2] (by adding 'a'). So words[1] is connected to words[0] and words[2].\n- words[2] can be used to obtain words[0] (by deleting 'b'), and words[1] (by deleting 'a'). So words[2] is connected to words[0] and words[1].\n- words[3] is not connected to any string in words.\nThus, words can be divided into 2 groups [\"a\",\"b\",\"ab\"] and [\"cde\"]. The size of the largest group is 3.  \n\nExample 2:\n\nInput: words = [\"a\",\"ab\",\"abc\"]\nOutput: [1,3]\nExplanation:\n- words[0] is connected to words[1].\n- words[1] is connected to words[0] and words[2].\n- words[2] is connected to words[1].\nSince all strings are connected to each other, they should be grouped together.\nThus, the size of the largest group is 3.\n\n&nbsp;\nConstraints:\n\n\t1 <= words.length <= 2 * 104\n\t1 <= words[i].length <= 26\n\twords[i] consists of lowercase English letters only.\n\tNo letter occurs more than once in words[i].",
        "solutions": [
            {
                "id": 1731073,
                "title": "union-find-vs-dfs",
                "content": "The tricky part here is how to compare strings efficiently.\\n\\n> Note that the union-find solution could TLE sometimes. DFS is noticeably faster.\\n\\n> **Update**: the union-find solution can be simplified by only using the delete operation. See below.\\n\\nBecause letters are unique, we can represent each string as a bitmask. Initially, I tried to xor each pair of bitmasts, but that O(n * n) solution was too slow even for 20,000 strings. I then tried to use a trie; it was complicated and also too slow.\\n\\nThe faster way is to mutate each bitmast representation, and use a hashmap to check for connected strings:\\n- Bitmasks with one bit flipped for the add and remove operations (example for \"ace\",bitmask `10101`):\\n\\t- 1010**0**: \"ce\"\\n\\t- 101**1**1: \"abce\"\\n\\t- 10**0**01: \"ae\"\\n\\t- 1**1**101: \"acde\"\\n\\t- **0**0101: \"ac\"\\n- Bitmasks where two bits with different values flipped for the replace operation (same example):\\n\\t- 101**10**: \"bce\" (a -> b)\\n\\t- 1**1**10**0**: \"cde\" (a -> d)\\n\\t- 10**01**1: \"abe\" (c -> b)\\n\\t- 1**10**01: \"ade\" (c -> d)\\n\\t- **0**01**1**1: \"abc\" (e -> b)\\n\\t- **01**101: \"acd\" (e -> d)\\n\\n#### Approach 1: DFS\\nInstead of processing connection of each string, like in the union-find approach, we can explore the entire group at once using DFS. First, we compute and put all masks into a hash map. \\n\\n> Note that we use hash map to count the occurence of each mask in case of duplicates.\\n\\nThen, starting from a mask in the hash map, we search for all connected masks recursively. \\n\\nAs we \"visit\" a mask, we increment the number of connected strings, and remove that mask from the map. This way, the corresponding string will not be processed again.\\n\\n**C++**\\n```cpp\\nunordered_map<int, int> m;\\nint dfs(int mask) {\\n    int res = 0;\\n    auto it = m.find(mask);\\n    if (it != end(m)) {\\n        res += it->second;\\n        m.erase(it);\\n        for (int i = 0; i < 26; ++i) {\\n            res += dfs(mask ^ (1 << i));\\n            for (int j = i + 1; j < 26; ++j)\\n                if (((mask >> i) & 1) != ((mask >> j) & 1))\\n                    res += dfs(mask ^ (1 << i) ^ (1 << j));\\n        }\\n    }\\n    return res;\\n}\\nvector<int> groupStrings(vector<string>& words) {\\n    int groups = 0, max_size = 0;\\n    for (auto &w : words)\\n        ++m[accumulate(begin(w), end(w), 0, [](int m, char ch){ return m | (1 << (ch - \\'a\\')); })];\\n    while (!m.empty()) {\\n        auto size = dfs(begin(m)->first);\\n        max_size = max(max_size, size);\\n        groups += size > 0;\\n    }\\n    return { groups, max_size };\\n}\\n```\\n\\n#### Approach 2: Union Find\\nWe go through each string, find connected strings as described above, and merge the corresponding groups using union-find.\\n\\nFor union-find approach, we can ignore *replace* and *add* operation, and only do the *remove* operation:\\n- If we remove one letter from \"abc\", it will match \"ab\",  \"ac\" and \"bc\". \\n\\t- This is the same as adding a letter to \"ab\", \"ac\" and \"bc\" to match \"abc\".\\n- If we remove the third letter from \"abde\" and \"abce\", we will get matching mask (\"abe\").\\n\\t- This is the same as replacing letter `d` with `c` to transform \"abde\" into \"abce\".\\n\\n**C++**\\n```cpp\\nunordered_map<int, int> m;\\nint find(vector<int> &ds, int i) {\\n    return ds[i] < 0 ? i : ds[i] = find(ds, ds[i]);\\n}\\nvoid merge(vector<int> &ds, int i, int mask) {\\n    auto it = m.find(mask);\\n    if (it != end(m)) {\\n        int pi = find(ds, i), pj = find(ds, it->second);\\n        if (pi != pj) {\\n            if (ds[pi] > ds[pj])\\n                swap(pi, pj);\\n            ds[pi] += ds[pj];\\n            ds[pj] = pi;\\n        }\\n    }\\n    else\\n        m[mask] = i;\\n}\\nvector<int> groupStrings(vector<string>& words) {\\n    vector<int> ds(words.size(), -1);\\n    for (int i = 0; i < words.size(); ++i) {\\n        int mask = accumulate(begin(words[i]), end(words[i]), 0, [](int m, char ch){ return m | (1 << (ch - \\'a\\')); });\\n        merge(ds, i, mask);\\n        for (int j = 0; j < 26; ++j)\\n            if (mask & (1 << j))\\n                merge(ds, i, mask ^ (1 << j));\\n    }\\n    return {(int)count_if(begin(ds), end(ds), [](int i){ return i < 0; }), - *min_element(begin(ds), end(ds)) };\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nunordered_map<int, int> m;\\nint dfs(int mask) {\\n    int res = 0;\\n    auto it = m.find(mask);\\n    if (it != end(m)) {\\n        res += it->second;\\n        m.erase(it);\\n        for (int i = 0; i < 26; ++i) {\\n            res += dfs(mask ^ (1 << i));\\n            for (int j = i + 1; j < 26; ++j)\\n                if (((mask >> i) & 1) != ((mask >> j) & 1))\\n                    res += dfs(mask ^ (1 << i) ^ (1 << j));\\n        }\\n    }\\n    return res;\\n}\\nvector<int> groupStrings(vector<string>& words) {\\n    int groups = 0, max_size = 0;\\n    for (auto &w : words)\\n        ++m[accumulate(begin(w), end(w), 0, [](int m, char ch){ return m | (1 << (ch - \\'a\\')); })];\\n    while (!m.empty()) {\\n        auto size = dfs(begin(m)->first);\\n        max_size = max(max_size, size);\\n        groups += size > 0;\\n    }\\n    return { groups, max_size };\\n}\\n```\n```cpp\\nunordered_map<int, int> m;\\nint find(vector<int> &ds, int i) {\\n    return ds[i] < 0 ? i : ds[i] = find(ds, ds[i]);\\n}\\nvoid merge(vector<int> &ds, int i, int mask) {\\n    auto it = m.find(mask);\\n    if (it != end(m)) {\\n        int pi = find(ds, i), pj = find(ds, it->second);\\n        if (pi != pj) {\\n            if (ds[pi] > ds[pj])\\n                swap(pi, pj);\\n            ds[pi] += ds[pj];\\n            ds[pj] = pi;\\n        }\\n    }\\n    else\\n        m[mask] = i;\\n}\\nvector<int> groupStrings(vector<string>& words) {\\n    vector<int> ds(words.size(), -1);\\n    for (int i = 0; i < words.size(); ++i) {\\n        int mask = accumulate(begin(words[i]), end(words[i]), 0, [](int m, char ch){ return m | (1 << (ch - \\'a\\')); });\\n        merge(ds, i, mask);\\n        for (int j = 0; j < 26; ++j)\\n            if (mask & (1 << j))\\n                merge(ds, i, mask ^ (1 << j));\\n    }\\n    return {(int)count_if(begin(ds), end(ds), [](int i){ return i < 0; }), - *min_element(begin(ds), end(ds)) };\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1730113,
                "title": "python-carefull-dfs-with-bitmasks-explained",
                "content": "Finally, challenging problem on contest =) The most challenge here for python is to avoid TLE. This problem is about graph connected components. There are two types of connections we need to deal with:\\n\\n1. When we remove letter from one word and get another. We will keep each word as bitmask, so we can quickly look for all candidates for each word.\\n2. When we add letter, it is the same as we removed letter from other word.\\n3. When we replace letter. If we do it in stupid way, we will get `O(n*d*d)`, where `n = 2*10^4` and `d = 26` is the size of alphabet. Probably it will work in other languages, but not in python. So, we need to think of something. Let us for each word create masks like this: `apple: *pple, a*ple, ap*le, app*e, appl*`. Then two words from our list which have the same mask need to be connected in our graph. However it is expensive to keep such masks, so we go further, we denote `*` by `1<<26` and save it as number as well. Then when we connect graph, for each mask it is enough to connect only adjacent elements, say we have `312: [1, 29, 3]`, where `1, 29, 3` are indexes, then we connect `1 -> 29 -> 3`.\\n4. When we created graph, we traverse it with dfs and find all connected components.\\n\\n#### Complexity\\nIt is `O(n*d)`, because we have at most `d` neibours of the first type. Also for the second type we have no more than `n*d` edges.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def groupStrings(self, w):\\n        M = {sum(1<<(ord(i) - ord(\"a\")) for i in word): j for j, word in enumerate(w)}\\n\\n        G = defaultdict(list)\\n        masks = defaultdict(list)\\n        for idx, word in enumerate(w):\\n            vals = [ord(i) - ord(\"a\") for i in word]\\n            mask = sum(1<<i for i in vals)\\n            for i in vals:\\n                masks[mask - (1<<i) + (1<<26)].append(idx)\\n                if mask - (1<<i) not in M: continue\\n                idx2 = M[mask - (1<<i)]\\n                G[idx] += [idx2]\\n                G[idx2] += [idx]\\n        \\n        for x in masks.values():\\n            for a, b in zip(x, x[1:]):\\n                G[a] += [b]\\n                G[b] += [a]\\n\\n        V, comps, r = set(), 0, 0\\n        for u in range(len(w)):\\n            if u in V: continue\\n            compsize, q = 1, [u]\\n            V.add(u)\\n            while q:\\n                u = q.pop()\\n                for v in G[u]:\\n                    if v in V: continue\\n                    compsize += 1\\n                    V.add(v)\\n                    q += [v]\\n            r = max(r, compsize)\\n            comps += 1\\n        return [comps, r]\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Depth-First Search",
                    "Bitmask"
                ],
                "code": "```python\\nclass Solution:\\n    def groupStrings(self, w):\\n        M = {sum(1<<(ord(i) - ord(\"a\")) for i in word): j for j, word in enumerate(w)}\\n\\n        G = defaultdict(list)\\n        masks = defaultdict(list)\\n        for idx, word in enumerate(w):\\n            vals = [ord(i) - ord(\"a\") for i in word]\\n            mask = sum(1<<i for i in vals)\\n            for i in vals:\\n                masks[mask - (1<<i) + (1<<26)].append(idx)\\n                if mask - (1<<i) not in M: continue\\n                idx2 = M[mask - (1<<i)]\\n                G[idx] += [idx2]\\n                G[idx2] += [idx]\\n        \\n        for x in masks.values():\\n            for a, b in zip(x, x[1:]):\\n                G[a] += [b]\\n                G[b] += [a]\\n\\n        V, comps, r = set(), 0, 0\\n        for u in range(len(w)):\\n            if u in V: continue\\n            compsize, q = 1, [u]\\n            V.add(u)\\n            while q:\\n                u = q.pop()\\n                for v in G[u]:\\n                    if v in V: continue\\n                    compsize += 1\\n                    V.add(v)\\n                    q += [v]\\n            r = max(r, compsize)\\n            comps += 1\\n        return [comps, r]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1730110,
                "title": "c-union-find-bitmask",
                "content": "\\n\\nSee my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n\\n## Solution 1. Union Find + Bitmask\\n\\nLet `m` be a map from a bitmask to the corresponding index in `A`.\\n\\nFor each `A[i]`:\\n* generate the correponding hash `h`\\n* generate the addition, deletion and replacement variant of hash `h`.\\n* Assume the variant\\'s hash is `t`, we connect `i` with `m[t]` using Union Find.\\n\\nIn the end, Union Find can tell us the number of groups and the size of all groups.\\n\\nNote that this sometimes gets TLE because of the tight time constraint and the randomness of `unordered_map`.\\n![image](https://assets.leetcode.com/users/images/3fb35c62-0a41-419f-9928-d2146bad7ac9_1643537541.1264188.png)\\n\\n```cpp\\n// OJ: https://leetcode.com/contest/weekly-contest-278/problems/groups-of-strings/\\n// Author: github.com/lzl124631x\\n// Time: O(26*26*N)\\n// Space: O(N)\\nclass UnionFind {\\n    vector<int> id, size;\\n    int cnt;\\npublic:\\n    UnionFind(int n) : id(n), size(n, 1), cnt(n) {\\n        iota(begin(id), end(id), 0);\\n    }\\n    int find(int a) {\\n        return id[a] == a ? a : (id[a] = find(id[a]));\\n    }\\n    void connect(int a, int b) {\\n        int x = find(a), y = find(b);\\n        if (x == y) return;\\n        id[x] = y;\\n        size[y] += size[x];\\n        --cnt;\\n    }\\n    int getSize(int a) {\\n        return size[find(a)];\\n    }\\n    int getCount() { return cnt; }\\n};\\nclass Solution {\\npublic:\\n    vector<int> groupStrings(vector<string>& A) {\\n        int N = A.size();\\n        UnionFind uf(N);\\n        unordered_map<int, int> m; // map from hash to index\\n\\t\\tm.reserve(N);\\n        for (int i = 0; i < N; ++i) {\\n            int h = 0;\\n            for (char c : A[i]) h |= 1 << (c - \\'a\\'); // `h` is the bitmask representation of `A[i]`\\n            for (int j = 0; j < 26; ++j) {\\n                if (h >> j & 1) { // if `h`\\'s j-th bit is 1\\n                    int del = h ^ (1 << j); // `del` is the bitmask after deleting the `j`-th bit\\n                    if (m.count(del)) uf.connect(i, m[del]); // Connect `A[i]` with its deletion variant\\n                    for (int k = 0; k < 26; ++k) { // we replace `j`-th bit with `k`-th bit\\n                        int rep = del | (1 << k); // `rep` is the bitmask after replacing `j`-th bit with `k`-th bit.\\n                        if (rep != del && m.count(rep)) uf.connect(i, m[rep]);\\n                    }\\n                } else {\\n                    int add = h | (1 << j); // `add` is the bitmask after adding `j`-th bit\\n                    if (m.count(add)) uf.connect(i, m[add]);\\n                }\\n            }\\n            m[h] = i;\\n        }\\n        int mx = 1;\\n        for (int i = 0; i < N; ++ i) mx = max(mx, uf.getSize(i));\\n        return {uf.getCount(), mx};\\n    }\\n};\\n```\\n## Solution 2. Optimization\\n\\n1. Add \"union by rank\" to the Union Find to reduce the time complexity of `find` from `O(logN)` to `O(alpha(N))` where `alpha(N)` is the inverse function of Ackermann function.\\n2. For the replacement operation, reduced the time from `O(26 * 26)` to `O(26)` by \"meet-in-the-middle\". If two strings are connected after replacement operation, then they can be the same string after deleting one character. Example `\"abc\"` and `\"abd\"` are connected because they both become `\"ab\"` after one deletion.\\n\\n![image](https://assets.leetcode.com/users/images/dc5e87b9-9e03-4659-b647-5604706a0b3c_1643537475.9070363.png)\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/groups-of-strings/\\n// Author: github.com/lzl124631x\\n// Time: O(26 * N * alpha(N))\\n// Space: O(26 * N)\\nclass UnionFind {\\n    vector<int> id, rank, size;\\n    int cnt;\\npublic:\\n    UnionFind(int n) : id(n), rank(n, 0), size(n, 1), cnt(n) {\\n        iota(begin(id), end(id), 0);\\n    }\\n    int find(int a) {\\n        return id[a] == a ? a : (id[a] = find(id[a]));\\n    }\\n    void connect(int a, int b) {\\n        int x = find(a), y = find(b);\\n        if (x == y) return;\\n        if (rank[x] > rank[y]) {\\n            id[y] = x;\\n            size[x] += size[y];\\n        } else {\\n            id[x] = y;\\n            size[y] += size[x];\\n            if (rank[x] == rank[y]) rank[y]++;\\n        }\\n        --cnt;\\n    }\\n    int getSize(int a) {\\n        return size[find(a)];\\n    }\\n    int getCount() { return cnt; }\\n};\\nclass Solution {\\npublic:\\n    vector<int> groupStrings(vector<string>& A) {\\n        int N = A.size();\\n        UnionFind uf(N);\\n        unordered_map<int, int> m, delMap;\\n        m.reserve(N);\\n        for (int i = 0; i < N; ++i) {\\n            int h = 0;\\n            for (char c : A[i]) h |= 1 << (c - \\'a\\'); // `h` is the bitmask representation of `A[i]`\\n            for (int j = 0; j < 26; ++j) {\\n                if (h >> j & 1) { // if `h`\\'s j-th bit is 1\\n                    int del = h ^ (1 << j); // `del` is the bitmask after deleting the `j`-th bit\\n                    if (m.count(del)) uf.connect(i, m[del]); // Connect `A[i]` with its deletion variant\\n                    if (delMap.count(del)) uf.connect(i, delMap[del]);\\n                    else delMap[del] = i;\\n                } else {\\n                    int add = h | (1 << j); // `add` is the bitmask after adding `j`-th bit\\n                    if (m.count(add)) uf.connect(i, m[add]);\\n                }\\n            }\\n            m[h] = i;\\n        }\\n        int mx = 1;\\n        for (int i = 0; i < N; ++ i) mx = max(mx, uf.getSize(i));\\n        return {uf.getCount(), mx};\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/contest/weekly-contest-278/problems/groups-of-strings/\\n// Author: github.com/lzl124631x\\n// Time: O(26*26*N)\\n// Space: O(N)\\nclass UnionFind {\\n    vector<int> id, size;\\n    int cnt;\\npublic:\\n    UnionFind(int n) : id(n), size(n, 1), cnt(n) {\\n        iota(begin(id), end(id), 0);\\n    }\\n    int find(int a) {\\n        return id[a] == a ? a : (id[a] = find(id[a]));\\n    }\\n    void connect(int a, int b) {\\n        int x = find(a), y = find(b);\\n        if (x == y) return;\\n        id[x] = y;\\n        size[y] += size[x];\\n        --cnt;\\n    }\\n    int getSize(int a) {\\n        return size[find(a)];\\n    }\\n    int getCount() { return cnt; }\\n};\\nclass Solution {\\npublic:\\n    vector<int> groupStrings(vector<string>& A) {\\n        int N = A.size();\\n        UnionFind uf(N);\\n        unordered_map<int, int> m; // map from hash to index\\n\\t\\tm.reserve(N);\\n        for (int i = 0; i < N; ++i) {\\n            int h = 0;\\n            for (char c : A[i]) h |= 1 << (c - \\'a\\'); // `h` is the bitmask representation of `A[i]`\\n            for (int j = 0; j < 26; ++j) {\\n                if (h >> j & 1) { // if `h`\\'s j-th bit is 1\\n                    int del = h ^ (1 << j); // `del` is the bitmask after deleting the `j`-th bit\\n                    if (m.count(del)) uf.connect(i, m[del]); // Connect `A[i]` with its deletion variant\\n                    for (int k = 0; k < 26; ++k) { // we replace `j`-th bit with `k`-th bit\\n                        int rep = del | (1 << k); // `rep` is the bitmask after replacing `j`-th bit with `k`-th bit.\\n                        if (rep != del && m.count(rep)) uf.connect(i, m[rep]);\\n                    }\\n                } else {\\n                    int add = h | (1 << j); // `add` is the bitmask after adding `j`-th bit\\n                    if (m.count(add)) uf.connect(i, m[add]);\\n                }\\n            }\\n            m[h] = i;\\n        }\\n        int mx = 1;\\n        for (int i = 0; i < N; ++ i) mx = max(mx, uf.getSize(i));\\n        return {uf.getCount(), mx};\\n    }\\n};\\n```\n```cpp\\n// OJ: https://leetcode.com/problems/groups-of-strings/\\n// Author: github.com/lzl124631x\\n// Time: O(26 * N * alpha(N))\\n// Space: O(26 * N)\\nclass UnionFind {\\n    vector<int> id, rank, size;\\n    int cnt;\\npublic:\\n    UnionFind(int n) : id(n), rank(n, 0), size(n, 1), cnt(n) {\\n        iota(begin(id), end(id), 0);\\n    }\\n    int find(int a) {\\n        return id[a] == a ? a : (id[a] = find(id[a]));\\n    }\\n    void connect(int a, int b) {\\n        int x = find(a), y = find(b);\\n        if (x == y) return;\\n        if (rank[x] > rank[y]) {\\n            id[y] = x;\\n            size[x] += size[y];\\n        } else {\\n            id[x] = y;\\n            size[y] += size[x];\\n            if (rank[x] == rank[y]) rank[y]++;\\n        }\\n        --cnt;\\n    }\\n    int getSize(int a) {\\n        return size[find(a)];\\n    }\\n    int getCount() { return cnt; }\\n};\\nclass Solution {\\npublic:\\n    vector<int> groupStrings(vector<string>& A) {\\n        int N = A.size();\\n        UnionFind uf(N);\\n        unordered_map<int, int> m, delMap;\\n        m.reserve(N);\\n        for (int i = 0; i < N; ++i) {\\n            int h = 0;\\n            for (char c : A[i]) h |= 1 << (c - \\'a\\'); // `h` is the bitmask representation of `A[i]`\\n            for (int j = 0; j < 26; ++j) {\\n                if (h >> j & 1) { // if `h`\\'s j-th bit is 1\\n                    int del = h ^ (1 << j); // `del` is the bitmask after deleting the `j`-th bit\\n                    if (m.count(del)) uf.connect(i, m[del]); // Connect `A[i]` with its deletion variant\\n                    if (delMap.count(del)) uf.connect(i, delMap[del]);\\n                    else delMap[del] = i;\\n                } else {\\n                    int add = h | (1 << j); // `add` is the bitmask after adding `j`-th bit\\n                    if (m.count(add)) uf.connect(i, m[add]);\\n                }\\n            }\\n            m[h] = i;\\n        }\\n        int mx = 1;\\n        for (int i = 0; i < N; ++ i) mx = max(mx, uf.getSize(i));\\n        return {uf.getCount(), mx};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1730425,
                "title": "java-union-find-bitmask-backtracking",
                "content": "*  connection problem -> **UnionFind**\\n*  judge whether connected:  **set** of s1 and s2, so the lettec sequence does not matter -> use **bitmask** to represent a word  **or**  **sort** the letters in the word (the second way will TLE) \\n*  connection is bidirectional -> add one letter in s1 is **equivalent** to delete one letter from s2, so we **only** need to check **deleting** rule and **replacing** rule\\n*  similar to word ladder, instead of checking each pair of words which takes O(n^2), we can just check each word and enumerate all its potantial neighbours which can decrease the time to O(nL*26) = O(n*26*26) = O(n)\\n*  remember to do **backtracking** during the check\\n\\n\\n* some common bitmask operations:\\n1. take the bit of the ith(from right) digit: \\n```\\n\\t\\tbit = (mask >> i) & 1;\\n```\\n2.  set the ith digit to 1:\\n```\\n\\t\\tmask = mask | (1 << i);\\n```\\n3.  set the ith digit to 0:\\n```\\n\\t\\tmask = mask & (~(1 << i));\\n```\\n\\n\\n**Upvote if you think it helps!**\\n\\njava codes: \\n\\n```\\nclass Solution {\\n    public int[] groupStrings(String[] words) {\\n        int n = words.length;\\n        // System.out.println(n);\\n        UnionFind uf = new UnionFind(n);\\n        \\n        // map mask -> original index\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int[] mask = new int[n];\\n        \\n        for (int i = 0; i < n; i++) {            \\n            int x = 0;\\n            char[] temp = words[i].toCharArray();\\n            for (int j = 0; j < temp.length; j++) {\\n                char c = temp[j];\\n                \\n                // set the (c - \\'a\\')th digit to 1\\n                x = x | (1 << (c - \\'a\\'));\\n            }\\n            map.put(x, i);\\n            mask[i] = x;\\n        }\\n        \\n\\t\\t// start checking words one by one, if it has connected words, join them in Union Find\\n        for (int i = 0; i < n; i++) {\\n            String current = words[i];\\n            int len = current.length();\\n            int x = mask[i];\\n            \\n            for (int j = 0; j < len; j++) {\\n                char c = current.charAt(j);\\n                \\n                // delete char at j -> set the (c - \\'a\\')th digit to 0\\n                x = x & (~(1 << (c - \\'a\\')));\\n                if (map.containsKey(x)) {\\n                    int next = map.get(x);\\n                    uf.join(i, next);\\n                }               \\n                \\n                // replace char at j with \\'a\\' to \\'z\\':\\n                // replace = delete(already done) + add\\n                for (char t = \\'a\\'; t <= \\'z\\'; t++) {\\n                    // take the bit of the (t - \\'a\\')th digit\\n                    int dig = (x >> (t - \\'a\\')) & 1;\\n                    if (dig == 1) {\\n                        // since no letter occurs more than once in words[i], \\n                        // if this digit is already 1, we can continue;\\n                        continue;\\n                    }\\n                    \\n                    // set the (t - \\'a\\')th digit to 1, complete the replacing\\n                    x = x | (1 << (t - \\'a\\'));                 \\n                    if (map.containsKey(x)) {\\n                        int next = map.get(x);\\n                        uf.join(i, next);\\n                    }\\n                    \\n                    // backtracking , set it back to 0\\n                    x = x & (~(1 << (t - \\'a\\')));                    \\n                }\\n                \\n                // backtracking, add back the char we delete\\n                x = x | (1 << (c - \\'a\\'));                           \\n            }         \\n        }\\n        \\n        // get output from the union Find\\n        Set<Integer> set = new HashSet<>();\\n        int max = 1;\\n        for (int i = 0; i < n; i++) {\\n            int fx = uf.find(i);\\n            set.add(fx);\\n            max = Math.max(max, uf.size[i]);\\n        }\\n\\t\\t\\n        return new int[] {set.size(), max};\\n    }  \\n    \\n}\\n\\n\\n\\nclass UnionFind {\\n    \\n    int[] father;\\n    int[] size;\\n    \\n    public UnionFind(int n) {\\n        father = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            father[i] = i;\\n        }\\n        size = new int[n];\\n        Arrays.fill(size, 1);\\n    }\\n    \\n    public void join(int x, int y) {\\n        int fx = find(x);\\n        int fy = find(y);\\n        if (fx != fy) {\\n            father[fx] = fy;\\n            size[fy] += size[fx];\\n        }\\n    }\\n    \\n    public int find(int x) {\\n        int root = x;\\n        while (father[root] != root) {\\n            root = father[root];\\n        }\\n        while (x != root) {\\n            int fx = father[x];\\n            father[x] = root;\\n            x = fx;\\n        }\\n        return root;\\n    }\\n    \\n    public boolean isConnected(int x, int y) {\\n        return find(x) == find(y);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Backtracking",
                    "Union Find",
                    "Bitmask"
                ],
                "code": "```\\n\\t\\tbit = (mask >> i) & 1;\\n```\n```\\n\\t\\tmask = mask | (1 << i);\\n```\n```\\n\\t\\tmask = mask & (~(1 << i));\\n```\n```\\nclass Solution {\\n    public int[] groupStrings(String[] words) {\\n        int n = words.length;\\n        // System.out.println(n);\\n        UnionFind uf = new UnionFind(n);\\n        \\n        // map mask -> original index\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int[] mask = new int[n];\\n        \\n        for (int i = 0; i < n; i++) {            \\n            int x = 0;\\n            char[] temp = words[i].toCharArray();\\n            for (int j = 0; j < temp.length; j++) {\\n                char c = temp[j];\\n                \\n                // set the (c - \\'a\\')th digit to 1\\n                x = x | (1 << (c - \\'a\\'));\\n            }\\n            map.put(x, i);\\n            mask[i] = x;\\n        }\\n        \\n\\t\\t// start checking words one by one, if it has connected words, join them in Union Find\\n        for (int i = 0; i < n; i++) {\\n            String current = words[i];\\n            int len = current.length();\\n            int x = mask[i];\\n            \\n            for (int j = 0; j < len; j++) {\\n                char c = current.charAt(j);\\n                \\n                // delete char at j -> set the (c - \\'a\\')th digit to 0\\n                x = x & (~(1 << (c - \\'a\\')));\\n                if (map.containsKey(x)) {\\n                    int next = map.get(x);\\n                    uf.join(i, next);\\n                }               \\n                \\n                // replace char at j with \\'a\\' to \\'z\\':\\n                // replace = delete(already done) + add\\n                for (char t = \\'a\\'; t <= \\'z\\'; t++) {\\n                    // take the bit of the (t - \\'a\\')th digit\\n                    int dig = (x >> (t - \\'a\\')) & 1;\\n                    if (dig == 1) {\\n                        // since no letter occurs more than once in words[i], \\n                        // if this digit is already 1, we can continue;\\n                        continue;\\n                    }\\n                    \\n                    // set the (t - \\'a\\')th digit to 1, complete the replacing\\n                    x = x | (1 << (t - \\'a\\'));                 \\n                    if (map.containsKey(x)) {\\n                        int next = map.get(x);\\n                        uf.join(i, next);\\n                    }\\n                    \\n                    // backtracking , set it back to 0\\n                    x = x & (~(1 << (t - \\'a\\')));                    \\n                }\\n                \\n                // backtracking, add back the char we delete\\n                x = x | (1 << (c - \\'a\\'));                           \\n            }         \\n        }\\n        \\n        // get output from the union Find\\n        Set<Integer> set = new HashSet<>();\\n        int max = 1;\\n        for (int i = 0; i < n; i++) {\\n            int fx = uf.find(i);\\n            set.add(fx);\\n            max = Math.max(max, uf.size[i]);\\n        }\\n\\t\\t\\n        return new int[] {set.size(), max};\\n    }  \\n    \\n}\\n\\n\\n\\nclass UnionFind {\\n    \\n    int[] father;\\n    int[] size;\\n    \\n    public UnionFind(int n) {\\n        father = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            father[i] = i;\\n        }\\n        size = new int[n];\\n        Arrays.fill(size, 1);\\n    }\\n    \\n    public void join(int x, int y) {\\n        int fx = find(x);\\n        int fy = find(y);\\n        if (fx != fy) {\\n            father[fx] = fy;\\n            size[fy] += size[fx];\\n        }\\n    }\\n    \\n    public int find(int x) {\\n        int root = x;\\n        while (father[root] != root) {\\n            root = father[root];\\n        }\\n        while (x != root) {\\n            int fx = father[x];\\n            father[x] = root;\\n            x = fx;\\n        }\\n        return root;\\n    }\\n    \\n    public boolean isConnected(int x, int y) {\\n        return find(x) == find(y);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1736039,
                "title": "c-dsu-bitmasking-easy-to-understand",
                "content": "```\\n//standard disjoint set union class \\nclass DSU\\n{\\n    vector<int> par,rank;\\n    public:\\n    DSU(int N)\\n    {\\n        par.resize(N);\\n        rank.resize(N);\\n        for(int i=0;i<N;i++) par[i] = i , rank[i] = 0;\\n    }\\n    \\n\\t//function to find parent of u , with path compression\\n    int findPar(int u)\\n    {\\n        if(u == par[u]) return u;\\n        \\n        return par[u] = findPar(par[u]);\\n    }\\n    \\n\\t//function to join u and v based on their ranks\\n    void unon(int u,int v)\\n    {\\n        u = findPar(u) , v = findPar(v);\\n        \\n        if(rank[u] > rank[v])\\n            par[v] = u;\\n        else if(rank[u] < rank[v])\\n            par[u] = v;\\n        else\\n        {\\n            par[u] = v;\\n            rank[v]++;\\n        }\\n        \\n        // par[u] = v;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> groupStrings(vector<string>& words) {\\n        int n = size(words);\\n        DSU uf(n+1);\\n        \\n\\t\\t//we make two maps, one to store hash of words, other to store hash of words with 1 char deleted\\n        unordered_map<int,int> mp,delMap;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            int hash = 0;\\n\\t\\t\\t//firstly we calculate hash of current word\\n\\t\\t\\t//How to calculate hash ?\\n\\t\\t\\t//suppose we have a binary representation 0000000....26 length\\n\\t\\t\\t//now if current word has character \\'a\\' , we know \\'a\\' - \\'a\\' = 0 -> make 0th bit set\\n\\t\\t\\t//similarly for other characters too , now we are given that in one word there won\\'t be \\n\\t\\t\\t//multiple instances of same character , we can use this method\\n            for(auto &ch : words[i]) hash |= 1<<(ch-\\'a\\');\\n            \\n            for(int j=0;j<26;j++)\\n            {\\n\\t\\t\\t\\t//if jth bit is set , we will try to search the string deleting this character\\n                if(hash >> j & 1)\\n                {\\n\\t\\t\\t\\t\\t//unset the jth bit\\n                    int t_hash = hash ^ (1<<j);\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t//now we search in both maps and if match found then connect current idx with matched hash idx\\n                    if(mp.count(t_hash)) uf.unon(mp[t_hash],i);\\n                    if(delMap.count(t_hash)) uf.unon(delMap[t_hash],i);\\n                    else delMap[t_hash] = i;\\n                }\\n                else //else we\\'ll try to add this character\\n                {\\n\\t\\t\\t\\t\\t// make jth bit set\\n                    int t_hash = hash | (1<<j);\\n\\t\\t\\t\\t\\t//search in map, if found then connect both\\n                    if(mp.count(t_hash)) uf.unon(mp[t_hash],i);\\n                }\\n            }\\n            \\n\\t\\t\\t//store connect hash in our map\\n            mp[hash] = i;\\n        }\\n        \\n\\t\\t//map to store all the parents along with their frequencies\\n        unordered_map<int,int> res;\\n        for(int i=0;i<n;i++)\\n        {\\n            int p = uf.findPar(i);\\n            res[p]++;\\n        }\\n        \\n\\t\\t//variable to store freq of most occurring parent\\n        int mx = 0;\\n        for(auto &it : res)\\n        {\\n            mx = max(mx,it.second);\\n        }\\n        \\n\\t\\t//variable to store size of res ,i.e., total no. of parents\\n        int sz = size(res);\\n        \\n        return {sz,mx};\\n    }\\n};\\n```",
                "solutionTags": [
                    "String",
                    "Bitmask"
                ],
                "code": "```\\n//standard disjoint set union class \\nclass DSU\\n{\\n    vector<int> par,rank;\\n    public:\\n    DSU(int N)\\n    {\\n        par.resize(N);\\n        rank.resize(N);\\n        for(int i=0;i<N;i++) par[i] = i , rank[i] = 0;\\n    }\\n    \\n\\t//function to find parent of u , with path compression\\n    int findPar(int u)\\n    {\\n        if(u == par[u]) return u;\\n        \\n        return par[u] = findPar(par[u]);\\n    }\\n    \\n\\t//function to join u and v based on their ranks\\n    void unon(int u,int v)\\n    {\\n        u = findPar(u) , v = findPar(v);\\n        \\n        if(rank[u] > rank[v])\\n            par[v] = u;\\n        else if(rank[u] < rank[v])\\n            par[u] = v;\\n        else\\n        {\\n            par[u] = v;\\n            rank[v]++;\\n        }\\n        \\n        // par[u] = v;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> groupStrings(vector<string>& words) {\\n        int n = size(words);\\n        DSU uf(n+1);\\n        \\n\\t\\t//we make two maps, one to store hash of words, other to store hash of words with 1 char deleted\\n        unordered_map<int,int> mp,delMap;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            int hash = 0;\\n\\t\\t\\t//firstly we calculate hash of current word\\n\\t\\t\\t//How to calculate hash ?\\n\\t\\t\\t//suppose we have a binary representation 0000000....26 length\\n\\t\\t\\t//now if current word has character \\'a\\' , we know \\'a\\' - \\'a\\' = 0 -> make 0th bit set\\n\\t\\t\\t//similarly for other characters too , now we are given that in one word there won\\'t be \\n\\t\\t\\t//multiple instances of same character , we can use this method\\n            for(auto &ch : words[i]) hash |= 1<<(ch-\\'a\\');\\n            \\n            for(int j=0;j<26;j++)\\n            {\\n\\t\\t\\t\\t//if jth bit is set , we will try to search the string deleting this character\\n                if(hash >> j & 1)\\n                {\\n\\t\\t\\t\\t\\t//unset the jth bit\\n                    int t_hash = hash ^ (1<<j);\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t//now we search in both maps and if match found then connect current idx with matched hash idx\\n                    if(mp.count(t_hash)) uf.unon(mp[t_hash],i);\\n                    if(delMap.count(t_hash)) uf.unon(delMap[t_hash],i);\\n                    else delMap[t_hash] = i;\\n                }\\n                else //else we\\'ll try to add this character\\n                {\\n\\t\\t\\t\\t\\t// make jth bit set\\n                    int t_hash = hash | (1<<j);\\n\\t\\t\\t\\t\\t//search in map, if found then connect both\\n                    if(mp.count(t_hash)) uf.unon(mp[t_hash],i);\\n                }\\n            }\\n            \\n\\t\\t\\t//store connect hash in our map\\n            mp[hash] = i;\\n        }\\n        \\n\\t\\t//map to store all the parents along with their frequencies\\n        unordered_map<int,int> res;\\n        for(int i=0;i<n;i++)\\n        {\\n            int p = uf.findPar(i);\\n            res[p]++;\\n        }\\n        \\n\\t\\t//variable to store freq of most occurring parent\\n        int mx = 0;\\n        for(auto &it : res)\\n        {\\n            mx = max(mx,it.second);\\n        }\\n        \\n\\t\\t//variable to store size of res ,i.e., total no. of parents\\n        int sz = size(res);\\n        \\n        return {sz,mx};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1732413,
                "title": "python-explanation-with-pictures-bitmask-uf",
                "content": "Use Union-Find to connect two words, if they are connected based on these three operations.\\n\\nFor example, \\n- by operation **add**, string **a** can be transformed to **ab**, **ac**, ... , **az**.\\n- by operation **delete**, string **abc** can be transformed to **ab**, **ac**, **bc**.\\n- by operation **replace**, string **abc** can be transformed to **bce**, **bcf**, ... , **acz**.\\n![image](https://assets.leetcode.com/users/images/56716875-baf0-4876-a0a8-93ad6ffbe357_1643570455.4969292.png)\\n\\nMore specifically, **replace** equals **delete** + **add**.\\n\\n![image](https://assets.leetcode.com/users/images/c0e77096-4de8-4642-9ca9-2c8b6877fdcb_1643570459.8110764.png)\\n\\nTherefore, a current word **abc** can be potentially connected to all those words (As shown below). \\nImagine we also have **acz** in the string list, thus **abc** and **acz** are connected! \\n\\n![image](https://assets.leetcode.com/users/images/a15e4085-17cc-41e8-9e9c-4ee41e40e162_1643570463.125807.png)\\n\\n\\nTherefore, we can count the number of groups and the group size. However, I \\n\\n>For example, given the input:\\n **[\"web\",\"a\",\"te\",\"hsx\",\"v\",\"k\",\"a\",\"roh\"]**\\n we group them like below.\\n\\n![image](https://assets.leetcode.com/users/images/baefe137-b75f-420e-8cd0-0b25b19f8c35_1643570466.502205.png)\\n\\nNotice that there might be duplicated words, thus we can use a counter for the number of occurrence of each word, and calculate the group size based on the frequency of each word.\\n\\nFor example: The size of green group is: 1 + 1 + 2 = 4\\n\\n![image](https://assets.leetcode.com/users/images/946594a3-c5dd-4305-adb9-9a0419495240_1643570469.9267042.png)\\n\\n\\n\\n\\n**Python**\\n```\\nclass DSU:\\n    def __init__(self, n):\\n        self.root = list(range(n))\\n    def find(self, x):\\n        if self.root[x] != x:\\n            self.root[x] = self.find(self.root[x])\\n        return self.root[x]\\n    def union(self, x, y):\\n        self.root[self.find(x)] = self.find(y)\\n\\nclass Solution:\\n    def groupStrings(self, A: List[str]) -> List[int]:        \\n        c = collections.defaultdict(int)\\n        for a in A: \\n\\t\\t\\tc[\"\".join(sorted(a))] += 1\\n    \\n        A = list(set([\"\".join(sorted(a)) for a in A]))\\n        n = len(A)\\n                \\n        idx = collections.defaultdict(int)    # (binary representation -> index)\\n\\t\\tdsu = DSU(n)                          # dsu \\n\\n        def add(base):\\n            for i in range(26):\\n                if not base & 1 << i:\\n                    yield base ^ 1 << i\\n        def dele(base):\\n            for i in range(26):\\n                if base & 1 << i:\\n                    if base - (1 << i) != 0:\\n                        yield base - (1 << i)        \\n        def rep(base):\\n            pre, new = [], []\\n            for i in range(26):\\n                if base & 1 << i: pre.append(i)\\n                else: new.append(i)\\n            for p in pre:\\n                for n in new:\\n                    yield base - (1 << p) + (1 << n)                \\n        \\n        for i, a in enumerate(A):\\n            base = 0\\n            for ch in a:\\n                base += 1 << ord(ch) - ord(\\'a\\')\\n            idx[base] = i\\n\\n        for base in idx.keys():\\n            for new in add(base):\\n                if new in idx:\\n                    dsu.union(idx[base], idx[new])\\n            for new in dele(base):\\n                if new in idx:\\n                    dsu.union(idx[base], idx[new])\\n            for new in rep(base):\\n                if new in idx:\\n                    dsu.union(idx[base], idx[new])\\n        \\n        group = collections.defaultdict(int)\\n        for a in A:\\n            base = 0\\n            for ch in a:\\n                base += 1 << ord(ch) - ord(\\'a\\')\\n            cnum = c[a]\\n            group[dsu.find(idx[base])] += cnum\\n        \\n        return [len(group), max(group.values())]\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Union Find",
                    "Bitmask"
                ],
                "code": "```\\nclass DSU:\\n    def __init__(self, n):\\n        self.root = list(range(n))\\n    def find(self, x):\\n        if self.root[x] != x:\\n            self.root[x] = self.find(self.root[x])\\n        return self.root[x]\\n    def union(self, x, y):\\n        self.root[self.find(x)] = self.find(y)\\n\\nclass Solution:\\n    def groupStrings(self, A: List[str]) -> List[int]:        \\n        c = collections.defaultdict(int)\\n        for a in A: \\n\\t\\t\\tc[\"\".join(sorted(a))] += 1\\n    \\n        A = list(set([\"\".join(sorted(a)) for a in A]))\\n        n = len(A)\\n                \\n        idx = collections.defaultdict(int)    # (binary representation -> index)\\n\\t\\tdsu = DSU(n)                          # dsu \\n\\n        def add(base):\\n            for i in range(26):\\n                if not base & 1 << i:\\n                    yield base ^ 1 << i\\n        def dele(base):\\n            for i in range(26):\\n                if base & 1 << i:\\n                    if base - (1 << i) != 0:\\n                        yield base - (1 << i)        \\n        def rep(base):\\n            pre, new = [], []\\n            for i in range(26):\\n                if base & 1 << i: pre.append(i)\\n                else: new.append(i)\\n            for p in pre:\\n                for n in new:\\n                    yield base - (1 << p) + (1 << n)                \\n        \\n        for i, a in enumerate(A):\\n            base = 0\\n            for ch in a:\\n                base += 1 << ord(ch) - ord(\\'a\\')\\n            idx[base] = i\\n\\n        for base in idx.keys():\\n            for new in add(base):\\n                if new in idx:\\n                    dsu.union(idx[base], idx[new])\\n            for new in dele(base):\\n                if new in idx:\\n                    dsu.union(idx[base], idx[new])\\n            for new in rep(base):\\n                if new in idx:\\n                    dsu.union(idx[base], idx[new])\\n        \\n        group = collections.defaultdict(int)\\n        for a in A:\\n            base = 0\\n            for ch in a:\\n                base += 1 << ord(ch) - ord(\\'a\\')\\n            cnum = c[a]\\n            group[dsu.find(idx[base])] += cnum\\n        \\n        return [len(group), max(group.values())]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1730305,
                "title": "python-bitmask-unionfind-explanation",
                "content": "# **Explanation**\\nFor each word `w = words[i]`, calculate it\\'s characters bitmask `x`.\\nSet the mapping `m.setdefault(x, i)`, so we can find the index of first word with bitmask `x`.\\n`f[i]` is the \"father\" of `i`, which we will use for union find.\\n\\nNow for word `w` with bitmask `x`,\\nwe will find all its `connected` bitmask `y`,\\nwhere the helper function `connected` generates all connected bitmasks.\\n\\nIf `y` already in the mapping `m`, \\nwe union their root parents.\\n\\nIn the end, we count the number of union and the size of biggest union.\\n<br>\\n\\n# **Complexity**\\nTime `O(n * 26 * 26)`\\nSpace `O(n * 26)`\\nTime can be improved to `O(n * 26)`.\\nSeems python hardly pass with `O(n * 26 * 26)`.\\n<br>\\n\\n**Python**\\n```py\\n    def groupStrings(self, words):\\n        n = len(words)\\n        m = {}\\n        f = []\\n        \\n        def find(x):\\n            if x != f[x]:\\n                f[x] = find(f[x])\\n            return f[x]\\n        \\n        def connected(x):\\n            for i in xrange(26):\\n                yield x ^ (1 << i)\\n                if (x & (1 << i)) > 0:\\n                    for j in xrange(26):\\n                         if x & (1 << j) == 0:\\n                            yield x ^ (1 << i) ^ (1 << j)\\n\\n        for i,w in enumerate(words):\\n            x = sum(1 << (ord(c) - ord(\\'a\\')) for c in w)\\n            f.append(m.setdefault(x, i))\\n            for y in connected(x):\\n                if y in m:\\n                    i, j = find(m[x]), find(m[y])\\n                    if i != j:\\n                        f[i] = j\\n\\n        count = collections.Counter(find(i) for i in range(n))\\n        return [len(count), max(count.values())]\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```py\\n    def groupStrings(self, words):\\n        n = len(words)\\n        m = {}\\n        f = []\\n        \\n        def find(x):\\n            if x != f[x]:\\n                f[x] = find(f[x])\\n            return f[x]\\n        \\n        def connected(x):\\n            for i in xrange(26):\\n                yield x ^ (1 << i)\\n                if (x & (1 << i)) > 0:\\n                    for j in xrange(26):\\n                         if x & (1 << j) == 0:\\n                            yield x ^ (1 << i) ^ (1 << j)\\n\\n        for i,w in enumerate(words):\\n            x = sum(1 << (ord(c) - ord(\\'a\\')) for c in w)\\n            f.append(m.setdefault(x, i))\\n            for y in connected(x):\\n                if y in m:\\n                    i, j = find(m[x]), find(m[y])\\n                    if i != j:\\n                        f[i] = j\\n\\n        count = collections.Counter(find(i) for i in range(n))\\n        return [len(count), max(count.values())]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1730267,
                "title": "python-union-find-without-using-bitmask",
                "content": "It is straightforward to use union find.\\n\\nFirst, we sort every string to make things simple. Well, maybe bitmask is a better choice to reduce the time complexity. But I am glad that this solution passes.\\n\\nFor each word:\\n1. Delete one character, if it is in the original words, then they can be unioned.\\n2. The most tricky thing, how to say two strings of the same length are in the same bucket? We can replace one character by another. But that will introduce O(26) complexity. **The trick is if these two strings can be the same after replacing characters, then they can also be the same after deleting one character for both strings.** For example, *acfg* and *acgh* belong to the same bucket, then instead of replacing *f* with *h*, we delete *f* from *acfg*, delete *h* from *acgh*. So we use a hashtable to store the new string which is one character deleted from the original string.\\n\\nTime complexity: O(length * 26), maybe O(length * 26log26) due to sorting.\\n```\\n    def groupStrings(self, words):\\n        \"\"\"\\n        :type words: List[str]\\n        :rtype: List[int]\\n        \"\"\"\\n        words.sort(key = lambda x:len(x))\\n        for i in range(len(words)):\\n            words[i] = \"\".join(sorted(words[i]))\\n        parent = [i for i in range(len(words))]\\n        \\n        hashtable = {words[i]:i for i in range(len(words))}# used to store index\\n        \\n        def find(i):\\n            if parent[i]!=i:\\n                parent[i] = find(parent[i])\\n            return parent[i]\\n\\n        def union(i,j):\\n            parent[find(j)] = find(i)\\n            return\\n        visited = {}\\n\\n        for i,word in enumerate(words):\\n            if len(word) == 1:# length = 1,then it is in the same bucket.\\n                union(i,0)\\n                continue\\n            if hashtable[word]!=i:# the same word\\n                union(i,hashtable[word])\\n                continue\\n            for j in range(len(word)):\\n                cur = word[:j] + word[j+1:]# delete one char\\n                if cur in hashtable:# delete one char\\n                    idx = hashtable[cur]\\n                    union(i,idx)\\n                    \\n                if cur in visited:# two strings of the same length\\n                    union(visited[cur],i)\\n                else:\\n                    visited[cur] = i\\n                    \\n        parent = [find(i) for i in range(len(words))]\\n        counts = collections.Counter(parent)\\n        return [len(counts),max(counts.values())]\\n\\t\\t```",
                "solutionTags": [],
                "code": "```\\n    def groupStrings(self, words):\\n        \"\"\"\\n        :type words: List[str]\\n        :rtype: List[int]\\n        \"\"\"\\n        words.sort(key = lambda x:len(x))\\n        for i in range(len(words)):\\n            words[i] = \"\".join(sorted(words[i]))\\n        parent = [i for i in range(len(words))]\\n        \\n        hashtable = {words[i]:i for i in range(len(words))}# used to store index\\n        \\n        def find(i):\\n            if parent[i]!=i:\\n                parent[i] = find(parent[i])\\n            return parent[i]\\n\\n        def union(i,j):\\n            parent[find(j)] = find(i)\\n            return\\n        visited = {}\\n\\n        for i,word in enumerate(words):\\n            if len(word) == 1:# length = 1,then it is in the same bucket.\\n                union(i,0)\\n                continue\\n            if hashtable[word]!=i:# the same word\\n                union(i,hashtable[word])\\n                continue\\n            for j in range(len(word)):\\n                cur = word[:j] + word[j+1:]# delete one char\\n                if cur in hashtable:# delete one char\\n                    idx = hashtable[cur]\\n                    union(i,idx)\\n                    \\n                if cur in visited:# two strings of the same length\\n                    union(visited[cur],i)\\n                else:\\n                    visited[cur] = i\\n                    \\n        parent = [find(i) for i in range(len(words))]\\n        counts = collections.Counter(parent)\\n        return [len(counts),max(counts.values())]\\n\\t\\t```",
                "codeTag": "Python3"
            },
            {
                "id": 1730229,
                "title": "c-bitmasking-and-dfs-solution",
                "content": "As all the letters are unique in each word, a word can be represented as a 32-bit unique integer.\\nUse hashmap to search and keep track of all seen elements.\\nSearch by first adding a letter where the bit is set to 0,\\ndeleting a letter where the bit is set to 1.\\nThen replacing all of the set bits (1) one by one with all of the unset bits (0)\\n\\n**Time Complexity**: `O(n*26*26)`\\n**Space Complexity**: `O(n)`\\n```\\nclass Solution {\\npublic:\\n    unordered_map<int, int> mp;\\n    \\n    int hash(string &word)  {\\n        int h=0;\\n        for (char c: word)\\n            h |= 1<<c-\\'a\\';\\n        return h;\\n    }\\n    \\n    int search(const int h)   {\\n        if (mp.find(h) == mp.end())\\n            return 0;\\n        int gs = mp[h];\\n        mp.erase(h);\\n        // all possible delete and add edits\\n        for (int b=0; b<26; ++b)    {\\n            int h1;\\n            if ((h>>b) & 1)     // delete\\n                h1 = h ^ (1<<b);\\n            else                // add\\n                h1 = h | (1<<b);\\n            auto it = mp.find(h1);\\n            if (it != mp.end())\\n                gs += search(h1);\\n        }\\n        // for possible 26*26 replacements\\n        for (int b1=0; b1<26; ++b1) {\\n            if (((h>>b1) & 1) == 0)\\n                continue;\\n            // make this bit 0\\n            int h1 = h ^ (1<<b1);\\n            for (int b2=0; b2<26; ++b2) {\\n                if (b2 != b1 && !((h>>b2)&1))   {\\n                    int h2 = h1 | (1<<b2);\\n                    auto it = mp.find(h2);\\n                    if (it != mp.end())\\n                        gs += search(h2);\\n                }\\n            }\\n        }\\n        return gs;\\n    }\\n    \\n    vector<int> groupStrings(vector<string>& words) {\\n        // bit masking\\n        int n = words.size(), numg = 0, maxg = 0;\\n        for (int i=0; i<n; ++i)\\n            ++mp[hash(words[i])];\\n        for (int i=0; i<n; ++i) {\\n            const int h = hash(words[i]);\\n            int gs = search(h);\\n            numg += (bool)(gs);\\n            maxg = max(maxg, gs);\\n        }\\n        return {numg, maxg};\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<int, int> mp;\\n    \\n    int hash(string &word)  {\\n        int h=0;\\n        for (char c: word)\\n            h |= 1<<c-\\'a\\';\\n        return h;\\n    }\\n    \\n    int search(const int h)   {\\n        if (mp.find(h) == mp.end())\\n            return 0;\\n        int gs = mp[h];\\n        mp.erase(h);\\n        // all possible delete and add edits\\n        for (int b=0; b<26; ++b)    {\\n            int h1;\\n            if ((h>>b) & 1)     // delete\\n                h1 = h ^ (1<<b);\\n            else                // add\\n                h1 = h | (1<<b);\\n            auto it = mp.find(h1);\\n            if (it != mp.end())\\n                gs += search(h1);\\n        }\\n        // for possible 26*26 replacements\\n        for (int b1=0; b1<26; ++b1) {\\n            if (((h>>b1) & 1) == 0)\\n                continue;\\n            // make this bit 0\\n            int h1 = h ^ (1<<b1);\\n            for (int b2=0; b2<26; ++b2) {\\n                if (b2 != b1 && !((h>>b2)&1))   {\\n                    int h2 = h1 | (1<<b2);\\n                    auto it = mp.find(h2);\\n                    if (it != mp.end())\\n                        gs += search(h2);\\n                }\\n            }\\n        }\\n        return gs;\\n    }\\n    \\n    vector<int> groupStrings(vector<string>& words) {\\n        // bit masking\\n        int n = words.size(), numg = 0, maxg = 0;\\n        for (int i=0; i<n; ++i)\\n            ++mp[hash(words[i])];\\n        for (int i=0; i<n; ++i) {\\n            const int h = hash(words[i]);\\n            int gs = search(h);\\n            numg += (bool)(gs);\\n            maxg = max(maxg, gs);\\n        }\\n        return {numg, maxg};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1732959,
                "title": "python3-union-find",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/badfbf601ede2f43ba191b567d6f5c7e0d046286) for solutions of weekly 278. \\n\\n```\\nclass UnionFind: \\n    def __init__(self, n): \\n        self.parent = list(range(n))\\n        self.rank = [1] * n \\n        \\n    def find(self, p): \\n        if p != self.parent[p]: \\n            self.parent[p] = self.find(self.parent[p])\\n        return self.parent[p]\\n    \\n    def union(self, p, q): \\n        prt, qrt = self.find(p), self.find(q)\\n        if prt == qrt: return False \\n        if self.rank[prt] > self.rank[qrt]: prt, qrt = qrt, prt\\n        self.parent[prt] = self.parent[qrt]\\n        self.rank[qrt] += self.rank[prt]\\n        return True \\n\\n\\nclass Solution:\\n    def groupStrings(self, words: List[str]) -> List[int]:\\n        n = len(words)\\n        uf = UnionFind(n)\\n        seen = {}\\n        for i, word in enumerate(words): \\n            m = reduce(or_, (1<<ord(ch)-97 for ch in word))\\n            if m in seen: uf.union(i, seen[m])\\n            for k in range(26): \\n                if m ^ 1<<k in seen: uf.union(i, seen[m ^ 1<<k])\\n                if m & 1<<k: \\n                    mm = m ^ 1<<k ^ 1<<26\\n                    if mm in seen: uf.union(i, seen[mm])\\n                    seen[mm] = i\\n            seen[m] = i \\n        freq = Counter(uf.find(i) for i in range(n))\\n        return [len(freq), max(freq.values())]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass UnionFind: \\n    def __init__(self, n): \\n        self.parent = list(range(n))\\n        self.rank = [1] * n \\n        \\n    def find(self, p): \\n        if p != self.parent[p]: \\n            self.parent[p] = self.find(self.parent[p])\\n        return self.parent[p]\\n    \\n    def union(self, p, q): \\n        prt, qrt = self.find(p), self.find(q)\\n        if prt == qrt: return False \\n        if self.rank[prt] > self.rank[qrt]: prt, qrt = qrt, prt\\n        self.parent[prt] = self.parent[qrt]\\n        self.rank[qrt] += self.rank[prt]\\n        return True \\n\\n\\nclass Solution:\\n    def groupStrings(self, words: List[str]) -> List[int]:\\n        n = len(words)\\n        uf = UnionFind(n)\\n        seen = {}\\n        for i, word in enumerate(words): \\n            m = reduce(or_, (1<<ord(ch)-97 for ch in word))\\n            if m in seen: uf.union(i, seen[m])\\n            for k in range(26): \\n                if m ^ 1<<k in seen: uf.union(i, seen[m ^ 1<<k])\\n                if m & 1<<k: \\n                    mm = m ^ 1<<k ^ 1<<26\\n                    if mm in seen: uf.union(i, seen[mm])\\n                    seen[mm] = i\\n            seen[m] = i \\n        freq = Counter(uf.find(i) for i in range(n))\\n        return [len(freq), max(freq.values())]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1730722,
                "title": "java-my-solution-using-unionfind-bitmask",
                "content": "My O(26 * 26 * n) solution using union-find + bitmask. using a couple of ideas to optimize the runtime. Beat 100% with ~600ms runtime.\\n\\n```\\nclass Solution {\\n    public int[] groupStrings(String[] words) {\\n        int n = words.length;\\n        Map<Integer, Integer> maskToIndex = new HashMap<>();\\n        int[] masks = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            for (char ch : words[i].toCharArray()) {\\n                masks[i] |= (1 << ch - \\'a\\');\\n            }\\n            maskToIndex.put(masks[i], i);\\n        }\\n        \\n        DisjointSet disjointSet = new DisjointSet(n);\\n        for (int i = 0; i < n; i++) {\\n            // This is necessary to union the duplicate words\\n            disjointSet.union(i, maskToIndex.get(masks[i]));\\n            for (char ch : words[i].toCharArray()) {\\n                // Removing ch from the word\\n                int maskWithoutCh = masks[i] ^ (1 << ch - \\'a\\');\\n                if (maskToIndex.containsKey(maskWithoutCh)) {\\n                    disjointSet.union(i, maskToIndex.get(maskWithoutCh));\\n                }\\n                \\n                // Replace ch with any other charactor\\n                for (int j = 0; j < 26; j++) {\\n\\t\\t\\t\\t\\t// Skip if the word already contains the char at j\\n                    if (j == ch - \\'a\\' || (maskWithoutCh | (1 << j)) == maskWithoutCh) {\\n                        continue;\\n                    }\\n                    int maskWithReplace = maskWithoutCh | (1 << j);\\n                    if (maskToIndex.containsKey(maskWithReplace)) {\\n                        disjointSet.union(i, maskToIndex.get(maskWithReplace));\\n                    }\\n                }\\n            }\\n        }\\n        return disjointSet.getState();\\n    }\\n\\n    private final class DisjointSet {\\n        private int[] parent;\\n        private int[] size;\\n        private int groupCount;\\n        private int maxSize;\\n        \\n        DisjointSet(int n) {\\n            groupCount = n;\\n            maxSize = 1;\\n            parent = new int[n];\\n            size = new int[n];\\n            for (int i = 0; i < n; i++) {\\n                parent[i] = i;\\n                size[i] = 1;\\n            }\\n        }\\n        \\n        public int find(int a) {\\n            if (parent[a] != a) {\\n                parent[a] = find(parent[a]);\\n            }\\n            return parent[a];\\n        }\\n        \\n        public void union(int a, int b) {\\n            if (a == b) {\\n                return;\\n            }\\n            int pa = find(a);\\n            int pb = find(b);\\n            if (pa != pb) {\\n\\t\\t\\t\\t// Improving the runtime for find operations by joining the small group to large one\\n                if (size[pb] < size[pa]) {\\n                    parent[pa] = pb;\\n                    size[pb] += size[pa];\\n                    maxSize = Math.max(maxSize, size[pb]);\\n                } else {\\n                    parent[pb] = pa;\\n                    size[pa] += size[pb];\\n                    maxSize = Math.max(maxSize, size[pa]);\\n                }\\n                groupCount--;\\n            }\\n        }\\n        \\n        public int[] getState() {\\n            return new int[]{groupCount, maxSize};\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\n    public int[] groupStrings(String[] words) {\\n        int n = words.length;\\n        Map<Integer, Integer> maskToIndex = new HashMap<>();\\n        int[] masks = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            for (char ch : words[i].toCharArray()) {\\n                masks[i] |= (1 << ch - \\'a\\');\\n            }\\n            maskToIndex.put(masks[i], i);\\n        }\\n        \\n        DisjointSet disjointSet = new DisjointSet(n);\\n        for (int i = 0; i < n; i++) {\\n            // This is necessary to union the duplicate words\\n            disjointSet.union(i, maskToIndex.get(masks[i]));\\n            for (char ch : words[i].toCharArray()) {\\n                // Removing ch from the word\\n                int maskWithoutCh = masks[i] ^ (1 << ch - \\'a\\');\\n                if (maskToIndex.containsKey(maskWithoutCh)) {\\n                    disjointSet.union(i, maskToIndex.get(maskWithoutCh));\\n                }\\n                \\n                // Replace ch with any other charactor\\n                for (int j = 0; j < 26; j++) {\\n\\t\\t\\t\\t\\t// Skip if the word already contains the char at j\\n                    if (j == ch - \\'a\\' || (maskWithoutCh | (1 << j)) == maskWithoutCh) {\\n                        continue;\\n                    }\\n                    int maskWithReplace = maskWithoutCh | (1 << j);\\n                    if (maskToIndex.containsKey(maskWithReplace)) {\\n                        disjointSet.union(i, maskToIndex.get(maskWithReplace));\\n                    }\\n                }\\n            }\\n        }\\n        return disjointSet.getState();\\n    }\\n\\n    private final class DisjointSet {\\n        private int[] parent;\\n        private int[] size;\\n        private int groupCount;\\n        private int maxSize;\\n        \\n        DisjointSet(int n) {\\n            groupCount = n;\\n            maxSize = 1;\\n            parent = new int[n];\\n            size = new int[n];\\n            for (int i = 0; i < n; i++) {\\n                parent[i] = i;\\n                size[i] = 1;\\n            }\\n        }\\n        \\n        public int find(int a) {\\n            if (parent[a] != a) {\\n                parent[a] = find(parent[a]);\\n            }\\n            return parent[a];\\n        }\\n        \\n        public void union(int a, int b) {\\n            if (a == b) {\\n                return;\\n            }\\n            int pa = find(a);\\n            int pb = find(b);\\n            if (pa != pb) {\\n\\t\\t\\t\\t// Improving the runtime for find operations by joining the small group to large one\\n                if (size[pb] < size[pa]) {\\n                    parent[pa] = pb;\\n                    size[pb] += size[pa];\\n                    maxSize = Math.max(maxSize, size[pb]);\\n                } else {\\n                    parent[pb] = pa;\\n                    size[pa] += size[pb];\\n                    maxSize = Math.max(maxSize, size[pa]);\\n                }\\n                groupCount--;\\n            }\\n        }\\n        \\n        public int[] getState() {\\n            return new int[]{groupCount, maxSize};\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1745177,
                "title": "c-union-find-bitmasking-w-explanation",
                "content": "Once you know 2 strings are connected, then those 2 will belong to the same set. For this we can do a union-find. Check each different pair whether they are connected or not and if they are put them in the same set. \\n\\nThis is an O(N^2) algorithm, which wont pass the given conditions, now what?\\n\\nHere comes the bitmaskinng part. Since each alphabet can only be present atmost once, we can indicate it\\'s presence by a set bit. Now for each word, we can try all the 3 possibilities:\\n1. Make a set bit 0, thus we are deleting an alphabet from the given set of alphabets.\\n2. Make an un-set bit 1, thus we are adding a new alphabet to the given set of alphabets.\\n3. Make a set bit 0 and an un-set bit 1, thus we are replaceing an alphabet from the given set of alphabets with another one.\\n\\nIf this new word is in our given set of words, then we can put the current word with the new word in a set. Since we are iterating through the given set of words only once, this will take only O(N) time. \\n\\nComments are added in the code to indicate which operation we are doing to the string currently.\\n```\\nunordered_map<int,int> parent;\\nunordered_map<int,int> count;\\nint find(int x)\\n{\\n\\tif(parent[x]==-1)\\n\\t\\treturn x;\\n\\telse return parent[x]=find(parent[x]);\\n}\\nbool uni(int x,int y)\\n{\\n\\tint xp=find(x),yp=find(y);\\n\\tif(xp!=yp)\\n\\t{\\n\\t\\tparent[yp]=xp;\\n\\t\\tcount[xp]+=count[yp];\\n\\t\\treturn true;\\n\\t}\\n\\treturn false;\\n}\\nvector<int> groupStrings(vector<string>& arr) \\n{\\n\\tfor(string& x:arr)\\n\\t{\\n\\t\\tint temp=0;\\n\\t\\tfor(char c:x)\\n\\t\\t\\ttemp|=1<<(c-\\'a\\');\\n\\t\\tparent[temp]=-1;\\n\\t\\tcount[temp]++;\\n\\t}\\n\\tfor(auto itr=parent.begin();itr!=parent.end();++itr)\\n\\t{\\n\\t\\tint bit=itr->first;\\n\\t\\tint nbit;\\n\\t\\tfor(int i=0;i<26;++i)\\n\\t\\t{\\n\\t\\t\\tnbit=bit;\\n\\t\\t\\tif(bit&(1<<i))\\n\\t\\t\\t{\\n\\t\\t\\t\\tunsigned int t=1<<i;\\n\\t\\t\\t\\tnbit&=~t;\\n\\t\\t\\t\\tif(parent.find(nbit)!=parent.end())//removed an alphabet\\n\\t\\t\\t\\t\\tuni(bit,nbit);\\n\\t\\t\\t\\tfor(int j=0;j<26;++j)\\n\\t\\t\\t\\t\\tif(i!=j&&(bit&(1<<j))==0)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tint n2bit=nbit;\\n\\t\\t\\t\\t\\t\\tn2bit|=1<<j;\\n\\t\\t\\t\\t\\t\\tif(parent.find(n2bit)!=parent.end())//replaced an alphabet\\n\\t\\t\\t\\t\\t\\t\\tuni(bit,n2bit);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tnbit|=1<<i;\\n\\t\\t\\t\\tif(parent.find(nbit)!=parent.end())//added an alphabet\\n\\t\\t\\t\\t\\tuni(bit,nbit);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tvector<int> ret(2);\\n\\tfor(auto itr=parent.begin();itr!=parent.end();++itr)\\n\\t\\tif(itr->second==-1)\\n\\t\\t{\\n\\t\\t\\tret[0]++;\\n\\t\\t\\tret[1]=max(ret[1],count[itr->first]);\\n\\t\\t}\\n\\treturn ret;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Union Find",
                    "Bitmask"
                ],
                "code": "```\\nunordered_map<int,int> parent;\\nunordered_map<int,int> count;\\nint find(int x)\\n{\\n\\tif(parent[x]==-1)\\n\\t\\treturn x;\\n\\telse return parent[x]=find(parent[x]);\\n}\\nbool uni(int x,int y)\\n{\\n\\tint xp=find(x),yp=find(y);\\n\\tif(xp!=yp)\\n\\t{\\n\\t\\tparent[yp]=xp;\\n\\t\\tcount[xp]+=count[yp];\\n\\t\\treturn true;\\n\\t}\\n\\treturn false;\\n}\\nvector<int> groupStrings(vector<string>& arr) \\n{\\n\\tfor(string& x:arr)\\n\\t{\\n\\t\\tint temp=0;\\n\\t\\tfor(char c:x)\\n\\t\\t\\ttemp|=1<<(c-\\'a\\');\\n\\t\\tparent[temp]=-1;\\n\\t\\tcount[temp]++;\\n\\t}\\n\\tfor(auto itr=parent.begin();itr!=parent.end();++itr)\\n\\t{\\n\\t\\tint bit=itr->first;\\n\\t\\tint nbit;\\n\\t\\tfor(int i=0;i<26;++i)\\n\\t\\t{\\n\\t\\t\\tnbit=bit;\\n\\t\\t\\tif(bit&(1<<i))\\n\\t\\t\\t{\\n\\t\\t\\t\\tunsigned int t=1<<i;\\n\\t\\t\\t\\tnbit&=~t;\\n\\t\\t\\t\\tif(parent.find(nbit)!=parent.end())//removed an alphabet\\n\\t\\t\\t\\t\\tuni(bit,nbit);\\n\\t\\t\\t\\tfor(int j=0;j<26;++j)\\n\\t\\t\\t\\t\\tif(i!=j&&(bit&(1<<j))==0)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tint n2bit=nbit;\\n\\t\\t\\t\\t\\t\\tn2bit|=1<<j;\\n\\t\\t\\t\\t\\t\\tif(parent.find(n2bit)!=parent.end())//replaced an alphabet\\n\\t\\t\\t\\t\\t\\t\\tuni(bit,n2bit);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tnbit|=1<<i;\\n\\t\\t\\t\\tif(parent.find(nbit)!=parent.end())//added an alphabet\\n\\t\\t\\t\\t\\tuni(bit,nbit);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tvector<int> ret(2);\\n\\tfor(auto itr=parent.begin();itr!=parent.end();++itr)\\n\\t\\tif(itr->second==-1)\\n\\t\\t{\\n\\t\\t\\tret[0]++;\\n\\t\\t\\tret[1]=max(ret[1],count[itr->first]);\\n\\t\\t}\\n\\treturn ret;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1730898,
                "title": "java-disjoint-set-union-bit-masking-o-26-26-n",
                "content": "```\\nclass Solution {\\n    public int[] groupStrings(String[] words) {\\n        int n = words.length;\\n        parent = new int[n];        // to store the leader of a group\\n        rank = new int[n];          // to improve complexity\\n        for(int i = 0; i < n; i++){\\n            parent[i] = i;          // initially everyone is the leader of its group\\n            rank[i] = 1;            // initial rank is 1 for everyone\\n        }\\n        \\n        Map<Integer, Integer> map = new HashMap<>();    // map<string(bits), index of string>\\n        for(int j = 0; j < n; j++){\\n            String word = words[j];\\n            int x = 0;                          // converting string into bits\\n            for(char ch : word.toCharArray()){\\n                int bit = (ch - \\'a\\');\\n                x |= (1 << bit);\\n            }\\n            \\n            for(int i = 25; i >= 0; i--){       // checking if it can form group\\n                int tmp = x;\\n                if(map.containsKey(tmp))        // if map already contains that string\\n                    union(j, map.get(tmp));\\n                \\n                if((tmp & (1 << i)) > 0){       // deletion & replacing 1 character\\n                    tmp ^= (1 << i);            // deleting one character\\n                    if(map.containsKey(tmp))    // checking if it is present in map\\n                        union(j, map.get(tmp)); // if present, form group\\n                    \\n                    for(int k = 0; k < 26; k++){    // replacing that character with any one from (a-z)\\n                        if((tmp & (1 << k)) == 0){  // if the character we want to add is not present\\n                            int add = tmp ^ (1 << k);   // add that character\\n                            if(map.containsKey(add))    // chech if it present in map\\n                                union(j, map.get(add)); // form group\\n                        }\\n                    }\\n                } else{                         // addition of a character\\n                    tmp ^= (1 << i);            \\n                    if(map.containsKey(tmp))    // chech if it present in map\\n                        union(j, map.get(tmp)); // form group\\n                }\\n            }\\n            map.put(x, j);                      // adding current string in the map\\n        }\\n        \\n        map = new HashMap<>();              // map<leader of group, number of people in group>\\n        for(int i = 0; i < n; i++){     \\n            int ld = find(i);               // leader of i\\n            map.put(ld, map.getOrDefault(ld, 0) + 1);   // fill map\\n        }\\n        \\n        int[] ans = new int[2];         // answer array\\n        ans[0] = map.size();            // number of leaders is the number of groups\\n        for(int i : map.keySet())\\n            ans[1] = Math.max(ans[1], map.get(i));  // group with maximum members\\n        \\n        return ans;\\n    }\\n    \\n    int[] parent, rank;             // parent (to store leader), rank (to improve complexity)\\n    \\n    private int find(int x) {       // find function of DSU\\n        if (parent[x] == x)\\n            return x;\\n        return parent[x] = find(parent[x]);\\n    }\\n\\n    private boolean union(int x, int y) {       // union function of DSU\\n        int lx = find(x), ly = find(y);\\n        if (lx == ly)\\n            return true;\\n        if (rank[lx] > rank[ly])\\n            parent[ly] = lx;\\n        else if (rank[lx] < rank[ly])\\n            parent[lx] = ly;\\n        else {\\n            parent[lx] = ly;\\n            rank[ly]++;\\n        }\\n        return false;\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] groupStrings(String[] words) {\\n        int n = words.length;\\n        parent = new int[n];        // to store the leader of a group\\n        rank = new int[n];          // to improve complexity\\n        for(int i = 0; i < n; i++){\\n            parent[i] = i;          // initially everyone is the leader of its group\\n            rank[i] = 1;            // initial rank is 1 for everyone\\n        }\\n        \\n        Map<Integer, Integer> map = new HashMap<>();    // map<string(bits), index of string>\\n        for(int j = 0; j < n; j++){\\n            String word = words[j];\\n            int x = 0;                          // converting string into bits\\n            for(char ch : word.toCharArray()){\\n                int bit = (ch - \\'a\\');\\n                x |= (1 << bit);\\n            }\\n            \\n            for(int i = 25; i >= 0; i--){       // checking if it can form group\\n                int tmp = x;\\n                if(map.containsKey(tmp))        // if map already contains that string\\n                    union(j, map.get(tmp));\\n                \\n                if((tmp & (1 << i)) > 0){       // deletion & replacing 1 character\\n                    tmp ^= (1 << i);            // deleting one character\\n                    if(map.containsKey(tmp))    // checking if it is present in map\\n                        union(j, map.get(tmp)); // if present, form group\\n                    \\n                    for(int k = 0; k < 26; k++){    // replacing that character with any one from (a-z)\\n                        if((tmp & (1 << k)) == 0){  // if the character we want to add is not present\\n                            int add = tmp ^ (1 << k);   // add that character\\n                            if(map.containsKey(add))    // chech if it present in map\\n                                union(j, map.get(add)); // form group\\n                        }\\n                    }\\n                } else{                         // addition of a character\\n                    tmp ^= (1 << i);            \\n                    if(map.containsKey(tmp))    // chech if it present in map\\n                        union(j, map.get(tmp)); // form group\\n                }\\n            }\\n            map.put(x, j);                      // adding current string in the map\\n        }\\n        \\n        map = new HashMap<>();              // map<leader of group, number of people in group>\\n        for(int i = 0; i < n; i++){     \\n            int ld = find(i);               // leader of i\\n            map.put(ld, map.getOrDefault(ld, 0) + 1);   // fill map\\n        }\\n        \\n        int[] ans = new int[2];         // answer array\\n        ans[0] = map.size();            // number of leaders is the number of groups\\n        for(int i : map.keySet())\\n            ans[1] = Math.max(ans[1], map.get(i));  // group with maximum members\\n        \\n        return ans;\\n    }\\n    \\n    int[] parent, rank;             // parent (to store leader), rank (to improve complexity)\\n    \\n    private int find(int x) {       // find function of DSU\\n        if (parent[x] == x)\\n            return x;\\n        return parent[x] = find(parent[x]);\\n    }\\n\\n    private boolean union(int x, int y) {       // union function of DSU\\n        int lx = find(x), ly = find(y);\\n        if (lx == ly)\\n            return true;\\n        if (rank[lx] > rank[ly])\\n            parent[ly] = lx;\\n        else if (rank[lx] < rank[ly])\\n            parent[lx] = ly;\\n        else {\\n            parent[lx] = ly;\\n            rank[ly]++;\\n        }\\n        return false;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1730414,
                "title": "python-bitmask-find-connected-component",
                "content": "The idea is prett straightforward, use bitmask to connect words since we only care the set of letters in each word, and there is no duplicate letter in each word.\\n\\nThe tricky part is how to find connected words quickly, which I failed during the test. Ah, so close!\\n1) add or delete exact one letter is simple, we can iterate all 26 letters and flip each bit of them on the word being examed. If the current word already has a 1 at certain bit, it is equivalent to deleting that letter. Otherwise, it equals adding a non-existing letter.\\n2) I was not able to figure out how to delete one existing letter and add a new letter. It turns out we just need to iterate all pairs of word by add + word by delete in step 1, and merge them into a new word, like this:\\n\\nbase word: 10010\\ndelete one letter: 10000\\nadd one letter: 11010\\ndelete then add: 11000 = 11010 ^ 10000 ^ 10010\\n\\nTime O(N * 26 * 26)\\nSpace O(N)\\n\\n```\\nclass Solution:\\n    def groupStrings(self, words: List[str]) -> List[int]:\\n\\t\\n\\t    # function to convert word to a bit number based on the the set of chars in word\\n        def convert(word):\\n            char = set(word)\\n            bits = 0\\n            for c in char:\\n                bits |= 1 << (ord(c) - ord(\\'a\\'))\\n            return bits\\n        \\n\\t\\t# merge all words with the same bit num into a dict\\n        char_set = Counter()\\n        for word in words:\\n            char_set[convert(word)] += 1\\n            \\n        # function to get all possible neighbours based on the 3 allowed operations\\n        def get_neighbour(char):\\n            added = []\\n            deleted = []\\n            for i in range(26):\\n                bit = 1 << i\\n                if char & bit:\\n                    deleted.append(char ^ bit)     # delete one existing letter from word\\n                else:\\n                    added.append(char ^ bit)     # add one letter into word\\n            delete_add = []\\n            for c1 in added:                # this one is the tricky one, delete one existing letter and add another letter\\n                for c2 in deleted:\\n                    delete_add.append(c1 ^ c2 ^ char)\\n            return added + deleted + delete_add\\n        \\n\\t\\t\\n\\t\\t# dfs to find connected component\\n        def dfs(char, seen):\\n            seen.add(char)\\n            for nei in get_neighbour(char):\\n                if nei not in char_set or nei in seen:\\n                    continue\\n                dfs(nei, seen)\\n        \\n\\t\\t# below are the regular route for dfs. a interim seen set is used to easily access all connected words along the way\\n        visited = set()\\n        group = 0\\n        max_count = 0\\n        for char in char_set:\\n            if char in visited: continue\\n            seen = set()\\n            dfs(char, seen)\\n            group += 1\\n            max_count = max(max_count, sum(char_set[char] for char in seen))\\n            visited |= seen\\n        \\n        return [group, max_count]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def groupStrings(self, words: List[str]) -> List[int]:\\n\\t\\n\\t    # function to convert word to a bit number based on the the set of chars in word\\n        def convert(word):\\n            char = set(word)\\n            bits = 0\\n            for c in char:\\n                bits |= 1 << (ord(c) - ord(\\'a\\'))\\n            return bits\\n        \\n\\t\\t# merge all words with the same bit num into a dict\\n        char_set = Counter()\\n        for word in words:\\n            char_set[convert(word)] += 1\\n            \\n        # function to get all possible neighbours based on the 3 allowed operations\\n        def get_neighbour(char):\\n            added = []\\n            deleted = []\\n            for i in range(26):\\n                bit = 1 << i\\n                if char & bit:\\n                    deleted.append(char ^ bit)     # delete one existing letter from word\\n                else:\\n                    added.append(char ^ bit)     # add one letter into word\\n            delete_add = []\\n            for c1 in added:                # this one is the tricky one, delete one existing letter and add another letter\\n                for c2 in deleted:\\n                    delete_add.append(c1 ^ c2 ^ char)\\n            return added + deleted + delete_add\\n        \\n\\t\\t\\n\\t\\t# dfs to find connected component\\n        def dfs(char, seen):\\n            seen.add(char)\\n            for nei in get_neighbour(char):\\n                if nei not in char_set or nei in seen:\\n                    continue\\n                dfs(nei, seen)\\n        \\n\\t\\t# below are the regular route for dfs. a interim seen set is used to easily access all connected words along the way\\n        visited = set()\\n        group = 0\\n        max_count = 0\\n        for char in char_set:\\n            if char in visited: continue\\n            seen = set()\\n            dfs(char, seen)\\n            group += 1\\n            max_count = max(max_count, sum(char_set[char] for char in seen))\\n            visited |= seen\\n        \\n        return [group, max_count]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1730358,
                "title": "c-union-find-and-mask-o-n-26",
                "content": "The diffcult part of this problem is :\\nReplacing exactly one letter from the set of the letters of s1 with any letter, including itself. \\nReplacing is same as following operation:\\nTwo words with same length,  each erase one letter, and the remaining char set are the same.\\n\\nwe use mask for represent string, we use unordered_map to store every possible submask (with one letter deleted) of each mask, \\ne.g. string \"abc\"  is  111 in binary, its substring is \"ab\", \"bc\" and \"ac\",  its binary is 011 110 101. \\nThen string \"bcd\"  1110 also has substring  \"bc\" \"bd\" \"cd\" , binary  110,  1010, 1100,  \\nThen just look up the map for replacement match.  \\n\\nTime: O(N*26)\\n\\n```\\nclass Solution {\\npublic:\\n    unordered_map<int, int> mp;\\n    unordered_map<int, int> mp1;\\n    vector<int> parent;\\n    vector<int> gn;\\n    int n;\\n    int tomask(string& s) {\\n        int m = 0;\\n        for (auto& c : s) {\\n            int bit = 1 << (c - \\'a\\');\\n            m |= bit;\\n        }\\n        return m;\\n    }\\n    int find(int p) {\\n        if (parent[p] == -1) return p;\\n        parent[p] = find(parent[p]);\\n        return parent[p];\\n    }\\n    int un(int a, int b) {\\n        int pa = find(a);\\n        int pb = find(b);\\n        if (pa == pb) return pa;\\n        parent[pb] = pa;\\n        gn[pa] += gn[pb];\\n        return pa;\\n    }\\n    vector<int> groupStrings(vector<string>& ws) {\\n\\n        n =ws.size();\\n        parent = vector<int>(n, -1);\\n        gn = vector<int>(n, 1);\\n        int cnt = 0;\\n        int mg = 0;\\n        \\n        for (int i = 0; i < n; i++)\\n        {\\n            string& w = ws[i];\\n            int m = tomask(w);\\n            if (mp.count(m) > 0) {\\n                int p = mp[m];\\n                un(p, i);\\n                continue;\\n            }\\n            int cur = i;\\n            mp[m] = cur;\\n            for (int j = 0; j < w.size(); j++)\\n            {\\n                char c = w[j];\\n                int bit = 1 << (c - \\'a\\');\\n                int m1 = m ^ bit;\\n                if (mp1.count(m1) > 0) {\\n                    int p = mp1[m1];\\n                    cur = un(p, cur);\\n                    continue;\\n                }\\n                \\n                mp1[m1] = cur;\\n            }\\n        }\\n        \\n        for (int i = 0; i < n; i++) {\\n            string& w = ws[i];\\n            int m = tomask(w);\\n            for (int j = 0; j < w.size(); j++)\\n            {\\n                char c = w[j];\\n                int bit = 1 << (c - \\'a\\');\\n                int m1 = m ^ bit;\\n                if (mp.count(m1)) {\\n                    int p = mp[m1];\\n                    un(p, i);\\n                }\\n            }\\n        }\\n        \\n        for (int i = 0; i < n; i++)\\n        {\\n            if (parent[i] != -1) continue;\\n            cnt++;\\n            mg = max(mg, gn[i]);\\n        }\\n        return {cnt, mg};\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<int, int> mp;\\n    unordered_map<int, int> mp1;\\n    vector<int> parent;\\n    vector<int> gn;\\n    int n;\\n    int tomask(string& s) {\\n        int m = 0;\\n        for (auto& c : s) {\\n            int bit = 1 << (c - \\'a\\');\\n            m |= bit;\\n        }\\n        return m;\\n    }\\n    int find(int p) {\\n        if (parent[p] == -1) return p;\\n        parent[p] = find(parent[p]);\\n        return parent[p];\\n    }\\n    int un(int a, int b) {\\n        int pa = find(a);\\n        int pb = find(b);\\n        if (pa == pb) return pa;\\n        parent[pb] = pa;\\n        gn[pa] += gn[pb];\\n        return pa;\\n    }\\n    vector<int> groupStrings(vector<string>& ws) {\\n\\n        n =ws.size();\\n        parent = vector<int>(n, -1);\\n        gn = vector<int>(n, 1);\\n        int cnt = 0;\\n        int mg = 0;\\n        \\n        for (int i = 0; i < n; i++)\\n        {\\n            string& w = ws[i];\\n            int m = tomask(w);\\n            if (mp.count(m) > 0) {\\n                int p = mp[m];\\n                un(p, i);\\n                continue;\\n            }\\n            int cur = i;\\n            mp[m] = cur;\\n            for (int j = 0; j < w.size(); j++)\\n            {\\n                char c = w[j];\\n                int bit = 1 << (c - \\'a\\');\\n                int m1 = m ^ bit;\\n                if (mp1.count(m1) > 0) {\\n                    int p = mp1[m1];\\n                    cur = un(p, cur);\\n                    continue;\\n                }\\n                \\n                mp1[m1] = cur;\\n            }\\n        }\\n        \\n        for (int i = 0; i < n; i++) {\\n            string& w = ws[i];\\n            int m = tomask(w);\\n            for (int j = 0; j < w.size(); j++)\\n            {\\n                char c = w[j];\\n                int bit = 1 << (c - \\'a\\');\\n                int m1 = m ^ bit;\\n                if (mp.count(m1)) {\\n                    int p = mp[m1];\\n                    un(p, i);\\n                }\\n            }\\n        }\\n        \\n        for (int i = 0; i < n; i++)\\n        {\\n            if (parent[i] != -1) continue;\\n            cnt++;\\n            mg = max(mg, gn[i]);\\n        }\\n        return {cnt, mg};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3585347,
                "title": "union-find-bit-mask-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    class DisjointSet {\\n    \\npublic:\\n    vector<int> parent, size;\\n    DisjointSet(int n) {\\n        parent.resize(n );\\n        size.resize(n );\\n        for (int i = 0; i < n; i++) {\\n            parent[i] = i;\\n            size[i] = 1;\\n        }\\n    }\\n\\n    int find(int node) {\\n        if (node == parent[node])\\n            return node;\\n        return parent[node] = find(parent[node]);\\n    }\\n    void unionBySize(int u, int v) {\\n        int ulp_u = find(u);\\n        int ulp_v = find(v);\\n        if (ulp_u == ulp_v) return;\\n        if (size[ulp_u] < size[ulp_v]) {\\n            parent[ulp_u] = ulp_v;\\n            size[ulp_v] += size[ulp_u];\\n        }\\n        else {\\n            parent[ulp_v] = ulp_u;\\n            size[ulp_u] += size[ulp_v];\\n        }\\n    }\\n};\\n    vector<int> groupStrings(vector<string>& words) {\\n        int n=words.size();\\n        unordered_map<int,int> mp;\\n        DisjointSet ds(n);\\n        for(int k=0;k<n;k++){\\n\\t\\t// find the mask of the string \\n            int curr=0;\\n            for(auto ch:words[k]){\\n                int pos=ch-\\'a\\';\\n                curr=curr | (1<<pos);\\n            }\\n\\t\\t\\t// check in which sets it can be included\\n\\t\\t\\t// inserting or deleting a character\\n            for(int i=0;i<26;i++){\\n                int reduced=curr^(1<<i);\\n                if(mp.count(reduced)){\\n                    ds.unionBySize(k,mp[reduced]);\\n                }\\n            }\\n\\t\\t\\t// replacing one charater by other \\n            for(int i=0;i<26;i++){\\n                if(curr & (1<<i)){\\n                    int red=curr^(1<<i);\\n                    for(int j=0;j<26;j++){\\n                        if(curr& (1<<j)){\\n                            \\n                        }else{\\n                            int num=red^(1<<j);\\n                            if(mp.count(num)){\\n                                ds.unionBySize(k,mp[num]);\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n\\t\\t\\t// if string anagram was present\\n            if(mp.count(curr)){\\n                ds.unionBySize(k,mp[curr]);\\n            }else{\\n                mp[curr]=k;\\n            }\\n        }\\n\\t\\t// Maximum size of group\\n        int sizel=0;\\n\\t\\t// Number of group\\n        int groups=0;\\n        for(int i=0;i<n;i++){\\n            if(ds.parent[i]==i){\\n                groups++;\\n            }\\n            sizel=max(sizel,ds.size[i]);\\n        }\\n        return {groups,sizel};\\n    }\\n};\\n```",
                "solutionTags": [
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    class DisjointSet {\\n    \\npublic:\\n    vector<int> parent, size;\\n    DisjointSet(int n) {\\n        parent.resize(n );\\n        size.resize(n );\\n        for (int i = 0; i < n; i++) {\\n            parent[i] = i;\\n            size[i] = 1;\\n        }\\n    }\\n\\n    int find(int node) {\\n        if (node == parent[node])\\n            return node;\\n        return parent[node] = find(parent[node]);\\n    }\\n    void unionBySize(int u, int v) {\\n        int ulp_u = find(u);\\n        int ulp_v = find(v);\\n        if (ulp_u == ulp_v) return;\\n        if (size[ulp_u] < size[ulp_v]) {\\n            parent[ulp_u] = ulp_v;\\n            size[ulp_v] += size[ulp_u];\\n        }\\n        else {\\n            parent[ulp_v] = ulp_u;\\n            size[ulp_u] += size[ulp_v];\\n        }\\n    }\\n};\\n    vector<int> groupStrings(vector<string>& words) {\\n        int n=words.size();\\n        unordered_map<int,int> mp;\\n        DisjointSet ds(n);\\n        for(int k=0;k<n;k++){\\n\\t\\t// find the mask of the string \\n            int curr=0;\\n            for(auto ch:words[k]){\\n                int pos=ch-\\'a\\';\\n                curr=curr | (1<<pos);\\n            }\\n\\t\\t\\t// check in which sets it can be included\\n\\t\\t\\t// inserting or deleting a character\\n            for(int i=0;i<26;i++){\\n                int reduced=curr^(1<<i);\\n                if(mp.count(reduced)){\\n                    ds.unionBySize(k,mp[reduced]);\\n                }\\n            }\\n\\t\\t\\t// replacing one charater by other \\n            for(int i=0;i<26;i++){\\n                if(curr & (1<<i)){\\n                    int red=curr^(1<<i);\\n                    for(int j=0;j<26;j++){\\n                        if(curr& (1<<j)){\\n                            \\n                        }else{\\n                            int num=red^(1<<j);\\n                            if(mp.count(num)){\\n                                ds.unionBySize(k,mp[num]);\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n\\t\\t\\t// if string anagram was present\\n            if(mp.count(curr)){\\n                ds.unionBySize(k,mp[curr]);\\n            }else{\\n                mp[curr]=k;\\n            }\\n        }\\n\\t\\t// Maximum size of group\\n        int sizel=0;\\n\\t\\t// Number of group\\n        int groups=0;\\n        for(int i=0;i<n;i++){\\n            if(ds.parent[i]==i){\\n                groups++;\\n            }\\n            sizel=max(sizel,ds.size[i]);\\n        }\\n        return {groups,sizel};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2066628,
                "title": "simple-dsu-code-you-are-right-but-test-cases-are-edgy",
                "content": "Question is very easy and straight forward but test cases are not. \\n* If you sort each 26 length string then you will get TLE. \\n* In case you are using map then your code is faster than only 5% people but if you use the unordered_map then your code is fater than 65%.\\n\\n**DON\\'T WORRY, interviewer will never judge you on this edgy cases!!**\\n```\\ntypedef int ll;\\nconst int N=2e4+5;\\n\\nll par[N],rnk[N];   // for size based union make rnk=siz\\n\\nvoid build_DSU()\\n{\\n    for(ll i=0;i<N;i++) rnk[i]=0,par[i]=i;\\n}\\n\\nll get(ll v)\\n{\\n    if(par[v]!=v) par[v]=get(par[v]);\\n    return par[v];\\n}\\n \\nvoid uni(ll a,ll b)\\n{\\n    a=get(a);\\n    b=get(b);\\n    if(a!=b)\\n    {\\n        if(rnk[a]<rnk[b]) swap(a,b);\\n        par[b]=a;\\n        if(rnk[a]==rnk[b]) rnk[a]++;    // siz[a]+=siz[b];\\n    }\\n}\\n\\nclass Solution {\\npublic:\\n    \\n    vector<int> groupStrings(vector<string>& a)\\n    {\\n        int n=a.size();\\n        build_DSU();\\n        unordered_map<int,int> mp;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            int s=0;\\n            for(int j=0;j<a[i].length();j++)\\n                s|=(1<<(a[i][j]-\\'a\\'));\\n                        \\n            for(int j=0;j<26;j++)  // type-1 & 2 modification\\n            {\\n                int tmp=s^(1<<j);\\n                if(mp.count(tmp))\\n                    uni(i,mp[tmp]);\\n            }\\n            \\n            for(int j=0;j<26;j++)   // type-3 modification = delete + add\\n            {\\n                if((s & (1<<j))==0) continue;\\n                \\n                for(int k=0;k<26;k++)\\n                    if((s & (1<<k))==0)\\n                    {\\n                        int tmp=s;\\n                        tmp^=(1<<j);    // delete jth char\\n                        tmp^=(1<<k);    // add kth char\\n                        if(mp.count(tmp))\\n                            uni(i,mp[tmp]);\\n                    }\\n            }\\n            \\n            if(mp.count(s))\\n                uni(i,mp[s]);\\n            mp[s]=i;\\n        }\\n        \\n        map<int,int> grp;\\n        for(int i=0;i<n;i++)\\n            grp[get(i)]++;\\n        \\n        int mx=-1;\\n        for(auto i:grp) \\n            mx=max(mx,i.second);\\n        \\n        vector<int> ans={(int)grp.size(),mx};\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bitmask"
                ],
                "code": "```\\ntypedef int ll;\\nconst int N=2e4+5;\\n\\nll par[N],rnk[N];   // for size based union make rnk=siz\\n\\nvoid build_DSU()\\n{\\n    for(ll i=0;i<N;i++) rnk[i]=0,par[i]=i;\\n}\\n\\nll get(ll v)\\n{\\n    if(par[v]!=v) par[v]=get(par[v]);\\n    return par[v];\\n}\\n \\nvoid uni(ll a,ll b)\\n{\\n    a=get(a);\\n    b=get(b);\\n    if(a!=b)\\n    {\\n        if(rnk[a]<rnk[b]) swap(a,b);\\n        par[b]=a;\\n        if(rnk[a]==rnk[b]) rnk[a]++;    // siz[a]+=siz[b];\\n    }\\n}\\n\\nclass Solution {\\npublic:\\n    \\n    vector<int> groupStrings(vector<string>& a)\\n    {\\n        int n=a.size();\\n        build_DSU();\\n        unordered_map<int,int> mp;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            int s=0;\\n            for(int j=0;j<a[i].length();j++)\\n                s|=(1<<(a[i][j]-\\'a\\'));\\n                        \\n            for(int j=0;j<26;j++)  // type-1 & 2 modification\\n            {\\n                int tmp=s^(1<<j);\\n                if(mp.count(tmp))\\n                    uni(i,mp[tmp]);\\n            }\\n            \\n            for(int j=0;j<26;j++)   // type-3 modification = delete + add\\n            {\\n                if((s & (1<<j))==0) continue;\\n                \\n                for(int k=0;k<26;k++)\\n                    if((s & (1<<k))==0)\\n                    {\\n                        int tmp=s;\\n                        tmp^=(1<<j);    // delete jth char\\n                        tmp^=(1<<k);    // add kth char\\n                        if(mp.count(tmp))\\n                            uni(i,mp[tmp]);\\n                    }\\n            }\\n            \\n            if(mp.count(s))\\n                uni(i,mp[s]);\\n            mp[s]=i;\\n        }\\n        \\n        map<int,int> grp;\\n        for(int i=0;i<n;i++)\\n            grp[get(i)]++;\\n        \\n        int mx=-1;\\n        for(auto i:grp) \\n            mx=max(mx,i.second);\\n        \\n        vector<int> ans={(int)grp.size(),mx};\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1730687,
                "title": "python-bitmask-unionfind",
                "content": "Caution: this code gets accepted, but sometimes gets TLE.\\n\\n![image](https://assets.leetcode.com/users/images/45d38179-f0d3-4266-88b1-89d910731ca7_1643524946.2767868.jpeg)\\n\\n\\nFirst, we just need to think about the set of characters. This means that we can handle each word as a bit mask.\\nFor example, \\'a\\' can be written as `10000........0` (following 25 0\\'s). \\'xyz\\' can be written as `000.......0111`. And so on.\\n\\nFor each word, we can do three operations:\\n1. **Addition**: change 0 to 1 at some place\\n2. **Deletion**: change 1 to 0 at some place\\n3. **Replace**: change 0 to 1 and 1 to 0 at some place\\n\\nWe can write three operations in bit manipulation.\\nNote that there could be multiple same words, so I used `Counter` to consider the frequency.\\n\\n**Time complexity**: O(N) * O(13 * 13)\\n**Space complexity**: O(N)\\n\\n```\\nclass UnionFind:\\n    def __init__(self, num):\\n        self.parents = list(range(num))\\n        self.ranks = [0] * num\\n    \\n    def find_set(self, u):\\n        if u != self.parents[u]:\\n            self.parents[u] = self.find_set(self.parents[u])\\n        return self.parents[u]\\n    \\n    def union(self, set1, set2):\\n        if set1 == set2:\\n            return\\n        rank1, rank2 = self.ranks[set1], self.ranks[set2]\\n        if rank1 > rank2:\\n            self.parents[set2] = set1\\n        else:\\n            self.parents[set1] = set2\\n            if rank1 == rank2:\\n                self.ranks[set2] += 1\\n\\nfrom collections import defaultdict, Counter\\nclass Solution:\\n    def groupStrings(self, words: List[str]) -> List[int]:\\n        def get_mask(word):\\n            res = 0\\n            for char in word:\\n                res |= 1 << (ord(\\'z\\') - ord(char))\\n            return res\\n        \\n        words = [get_mask(word) for word in words]\\n        counter = Counter(words)\\n        words_set = set(words)\\n        word_idx_dict = {word : idx for idx, word in enumerate(words_set)}\\n        N = len(words_set)\\n        uf = UnionFind(N)\\n        \\n        for idx, word in enumerate(words):\\n            word_idx = word_idx_dict[word]\\n            zero_idxes, one_idxes = [], []\\n            for i in range(26):\\n                if word & (1 << i):\\n                    one_idxes.append(i)\\n                else:\\n                    zero_idxes.append(i)\\n            \\n            #addition\\n            for i in zero_idxes:\\n                new_word = word | (1 << i)\\n                if new_word in word_idx_dict:\\n                    new_word_idx = word_idx_dict[new_word]\\n                    uf.union(uf.find_set(word_idx), uf.find_set(new_word_idx))\\n            \\n            #delete\\n            for i in one_idxes:\\n                new_word = word & ~(1 << i)\\n                if new_word in word_idx_dict:\\n                    new_word_idx = word_idx_dict[new_word]\\n                    uf.union(uf.find_set(word_idx), uf.find_set(new_word_idx))\\n            \\n            #replace\\n            for i in zero_idxes:\\n                for j in one_idxes:\\n                    new_word = word & ~(1 << j) | (1 << i)\\n                    if new_word in word_idx_dict:\\n                        new_word_idx = word_idx_dict[new_word]\\n                        uf.union(uf.find_set(word_idx), uf.find_set(new_word_idx))\\n\\t\\t\\t\\t\\t\\tbreak\\n            \\n        union_dict = defaultdict(int)\\n        \\n        for i, word in enumerate(words_set):\\n            idx = uf.find_set(i)\\n            union_dict[idx] += counter[word]\\n        return [len(union_dict), max(union_dict.values())]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Union Find"
                ],
                "code": "```\\nclass UnionFind:\\n    def __init__(self, num):\\n        self.parents = list(range(num))\\n        self.ranks = [0] * num\\n    \\n    def find_set(self, u):\\n        if u != self.parents[u]:\\n            self.parents[u] = self.find_set(self.parents[u])\\n        return self.parents[u]\\n    \\n    def union(self, set1, set2):\\n        if set1 == set2:\\n            return\\n        rank1, rank2 = self.ranks[set1], self.ranks[set2]\\n        if rank1 > rank2:\\n            self.parents[set2] = set1\\n        else:\\n            self.parents[set1] = set2\\n            if rank1 == rank2:\\n                self.ranks[set2] += 1\\n\\nfrom collections import defaultdict, Counter\\nclass Solution:\\n    def groupStrings(self, words: List[str]) -> List[int]:\\n        def get_mask(word):\\n            res = 0\\n            for char in word:\\n                res |= 1 << (ord(\\'z\\') - ord(char))\\n            return res\\n        \\n        words = [get_mask(word) for word in words]\\n        counter = Counter(words)\\n        words_set = set(words)\\n        word_idx_dict = {word : idx for idx, word in enumerate(words_set)}\\n        N = len(words_set)\\n        uf = UnionFind(N)\\n        \\n        for idx, word in enumerate(words):\\n            word_idx = word_idx_dict[word]\\n            zero_idxes, one_idxes = [], []\\n            for i in range(26):\\n                if word & (1 << i):\\n                    one_idxes.append(i)\\n                else:\\n                    zero_idxes.append(i)\\n            \\n            #addition\\n            for i in zero_idxes:\\n                new_word = word | (1 << i)\\n                if new_word in word_idx_dict:\\n                    new_word_idx = word_idx_dict[new_word]\\n                    uf.union(uf.find_set(word_idx), uf.find_set(new_word_idx))\\n            \\n            #delete\\n            for i in one_idxes:\\n                new_word = word & ~(1 << i)\\n                if new_word in word_idx_dict:\\n                    new_word_idx = word_idx_dict[new_word]\\n                    uf.union(uf.find_set(word_idx), uf.find_set(new_word_idx))\\n            \\n            #replace\\n            for i in zero_idxes:\\n                for j in one_idxes:\\n                    new_word = word & ~(1 << j) | (1 << i)\\n                    if new_word in word_idx_dict:\\n                        new_word_idx = word_idx_dict[new_word]\\n                        uf.union(uf.find_set(word_idx), uf.find_set(new_word_idx))\\n\\t\\t\\t\\t\\t\\tbreak\\n            \\n        union_dict = defaultdict(int)\\n        \\n        for i, word in enumerate(words_set):\\n            idx = uf.find_set(i)\\n            union_dict[idx] += counter[word]\\n        return [len(union_dict), max(union_dict.values())]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1730374,
                "title": "java-bitmask-unionfind",
                "content": "Initiative:\\n1. Find the bitmask for each word where each of the rightmost 26 bits represents whether or not a char is present (\\'z\\' -> \\'a\\').\\n2. For each word, if adding a new char / removing an existing char will result in another word. union the groups that contains the two words respectively.\\n3. For each word, find all the strings that we can get by replacing any character and if any new string is present in words, union the groups that contains the new string and the original word respectively.\\n```\\n    public int[] groupStrings(String[] words) {\\n        HashMap<Integer, Integer> counts = new HashMap<>(), indices = new HashMap<>();\\n        int n = words.length, output = 0;\\n        int[] masks = new int[n], uf = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            for (char c : words[i].toCharArray()) masks[i] |= 1 << (c - \\'a\\');\\n            indices.put(masks[i], i);\\n            uf[i] = i;\\n        };\\n        for (int i = 0; i < n; i++) {\\n            int mask = masks[i];\\n            for (int j = 0; j < 26; j++) {\\n                int num = (mask & 1 << j) == 0 ? mask + (1 << j) : mask - (1 << j);\\n                if (indices.containsKey(num)) uf[find(i, uf)] = uf[find(indices.get(num), uf)];\\n            }\\n            for (int j = 0; j < 26; j++) if ((mask & 1 << j) > 0) for (int k = 0; k < 26; k++) if (k == j || (mask & 1 << k) == 0) {\\n                int num = mask - (1 << j) + (1 << k);\\n                if (indices.containsKey(num)) uf[find(i, uf)] = uf[find(indices.get(num), uf)];\\n            }\\n        }\\n        for (int i = 0; i < n; i++) {\\n            find(i, uf);\\n            counts.put(uf[i], counts.getOrDefault(uf[i], 0) + 1);\\n            output = Math.max(counts.get(uf[i]), output);\\n        }\\n        return new int[] {counts.size(), output};\\n    }\\n\\n    private int find(int i, int[] uf) {\\n        if (i == uf[i]) return i;\\n        return uf[i] = find(uf[i], uf);\\n    }\\n```\\nTime Complexity: O(nlog(n))\\nSpace Complexity: O(n)",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation",
                    "Union Find"
                ],
                "code": "```\\n    public int[] groupStrings(String[] words) {\\n        HashMap<Integer, Integer> counts = new HashMap<>(), indices = new HashMap<>();\\n        int n = words.length, output = 0;\\n        int[] masks = new int[n], uf = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            for (char c : words[i].toCharArray()) masks[i] |= 1 << (c - \\'a\\');\\n            indices.put(masks[i], i);\\n            uf[i] = i;\\n        };\\n        for (int i = 0; i < n; i++) {\\n            int mask = masks[i];\\n            for (int j = 0; j < 26; j++) {\\n                int num = (mask & 1 << j) == 0 ? mask + (1 << j) : mask - (1 << j);\\n                if (indices.containsKey(num)) uf[find(i, uf)] = uf[find(indices.get(num), uf)];\\n            }\\n            for (int j = 0; j < 26; j++) if ((mask & 1 << j) > 0) for (int k = 0; k < 26; k++) if (k == j || (mask & 1 << k) == 0) {\\n                int num = mask - (1 << j) + (1 << k);\\n                if (indices.containsKey(num)) uf[find(i, uf)] = uf[find(indices.get(num), uf)];\\n            }\\n        }\\n        for (int i = 0; i < n; i++) {\\n            find(i, uf);\\n            counts.put(uf[i], counts.getOrDefault(uf[i], 0) + 1);\\n            output = Math.max(counts.get(uf[i]), output);\\n        }\\n        return new int[] {counts.size(), output};\\n    }\\n\\n    private int find(int i, int[] uf) {\\n        if (i == uf[i]) return i;\\n        return uf[i] = find(uf[i], uf);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3780773,
                "title": "disjoint-set-bitmask",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int len[20007] ; \\n    int parent[20007] ; \\n    void make(int node){\\n        len[node]=1; \\n        parent[node]=node; \\n    } \\n    int find(int node) {\\n        if(node==parent[node]) return node; \\n        return parent[node]=find(parent[node]) ; \\n    }\\n    void merge(int u ,int v) {\\n        u=find(u) ; \\n        v=find(v) ; \\n        if(u==v) return ; \\n        if(len[u]<len[v]) swap(u, v) ; \\n        parent[v]=u; \\n        len[u]+=len[v] ; \\n    }\\n    static bool comp(string x, string y) {\\n        return x.size()<y.size();\\n    }\\n    vector<int> groupStrings(vector<string>& arr) {\\n           int n=arr.size() ; \\n           for(int i=0; i<n; i++) make(i) ; \\n           sort(arr.begin(),arr.end(),comp) ; \\n           unordered_map<int,int>mp; \\n          for(int i=0; i<n; i++){\\n           int mask=0; \\n           for(auto it:arr[i]) {\\n               mask=mask|(1<<(it-\\'a\\')) ;  \\n           }\\n           for(int j=0; j<26; j++) {\\n               if((1<<j)&mask) {\\n                   int del=mask^(1<<j) ; \\n                   if(mp.find(del)!=mp.end()) merge(mp[del],i) ; \\n                   for(int k=0; k<26; ++k) {\\n                       if((del&(1<<k))==0) {\\n                           int rep=del|(1<<k) ;\\n                           if(mp.find(rep)!=mp.end()) merge(mp[rep],i) ;  \\n                       }\\n                   }\\n               }\\n           }\\n           mp[mask]=i; \\n       }\\n        set<int>st; \\n        int res=0; \\n        for(int i=0; i<n; i++) {\\n            st.insert(find(i)) ; \\n            res=max(res, len[find(i)]) ; \\n        }\\n        int cnt=st.size() ; \\n        return {cnt,res} ; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int len[20007] ; \\n    int parent[20007] ; \\n    void make(int node){\\n        len[node]=1; \\n        parent[node]=node; \\n    } \\n    int find(int node) {\\n        if(node==parent[node]) return node; \\n        return parent[node]=find(parent[node]) ; \\n    }\\n    void merge(int u ,int v) {\\n        u=find(u) ; \\n        v=find(v) ; \\n        if(u==v) return ; \\n        if(len[u]<len[v]) swap(u, v) ; \\n        parent[v]=u; \\n        len[u]+=len[v] ; \\n    }\\n    static bool comp(string x, string y) {\\n        return x.size()<y.size();\\n    }\\n    vector<int> groupStrings(vector<string>& arr) {\\n           int n=arr.size() ; \\n           for(int i=0; i<n; i++) make(i) ; \\n           sort(arr.begin(),arr.end(),comp) ; \\n           unordered_map<int,int>mp; \\n          for(int i=0; i<n; i++){\\n           int mask=0; \\n           for(auto it:arr[i]) {\\n               mask=mask|(1<<(it-\\'a\\')) ;  \\n           }\\n           for(int j=0; j<26; j++) {\\n               if((1<<j)&mask) {\\n                   int del=mask^(1<<j) ; \\n                   if(mp.find(del)!=mp.end()) merge(mp[del],i) ; \\n                   for(int k=0; k<26; ++k) {\\n                       if((del&(1<<k))==0) {\\n                           int rep=del|(1<<k) ;\\n                           if(mp.find(rep)!=mp.end()) merge(mp[rep],i) ;  \\n                       }\\n                   }\\n               }\\n           }\\n           mp[mask]=i; \\n       }\\n        set<int>st; \\n        int res=0; \\n        for(int i=0; i<n; i++) {\\n            st.insert(find(i)) ; \\n            res=max(res, len[find(i)]) ; \\n        }\\n        int cnt=st.size() ; \\n        return {cnt,res} ; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1751703,
                "title": "java-bfs-union-find",
                "content": "```\\npublic int[] groupStrings(String[] words) {\\n        Map<Integer, Integer> numToParent = new HashMap<>();\\n        Map<Integer, Integer> groupToSize = new HashMap<>();\\n        Map<Integer, List<Integer>> lenToNums = new HashMap<>();\\n        \\n        for(String word : words) {\\n            processNum(word, groupToSize, lenToNums, numToParent);\\n        }\\n        \\n        for(int currLen = 1 ; currLen <= 26 ; currLen++) {\\n        \\tif (lenToNums.containsKey(currLen)) {\\n        \\t\\tList<Integer> currLev = lenToNums.get(currLen);\\n                for(int currNum : currLev) {\\n                \\tfor(int i = 0; i < 26 ; i++) {\\n                        // add\\n                        if ( (currNum & (1 << i)) == 0) {\\n                            int next = (currNum | (1 << i));\\n                            if (numToParent.containsKey(next)) {\\n                                union(currNum, next, numToParent, groupToSize);\\n                            }\\n                            // remove: add + remove = replace\\n                            for(int j = 0 ; j < 26 ; j++) {\\n                                if (i != j && (next & (1 << j)) > 0) {\\n                                    int sameLevNum = (next ^ (1 << j));\\n                                    if (numToParent.containsKey(sameLevNum)) {\\n                                        union(currNum, sameLevNum, numToParent, groupToSize);\\n                                    }\\n                                }\\n                            }\\n                        }\\n                    }\\n                }\\n        \\t}\\n        }\\n        \\n        int maxGroupSize = 0;\\n        int groups = 0;\\n        for(int parent : numToParent.values()) {\\n            if (parent == -1)\\n                groups++;\\n        }\\n        \\n        for(int size : groupToSize.values()) {\\n            maxGroupSize = Math.max(maxGroupSize, size);\\n        }\\n        return new int[]{groups, maxGroupSize};\\n    }\\n    \\n    private void processNum(String word, Map<Integer, Integer>groupToSize, Map<Integer, List<Integer>>lenToNums, Map<Integer, Integer> numToParent) {\\n        int num = wordToNum(word);\\n        groupToSize.put(num, groupToSize.getOrDefault(num, 0) + 1);\\n        if (groupToSize.get(num) == 1) {\\n        \\tlenToNums.computeIfAbsent(word.length(), k -> new ArrayList<>()).add(num);\\n        }\\n        numToParent.put(num, - 1);\\n    }\\n    \\n    private int wordToNum(String word) {\\n        int res = 0;\\n        for(char curr : word.toCharArray()) {\\n            res |= (1 << (curr - \\'a\\'));\\n        }\\n        return res;\\n    }\\n    \\n    private boolean union(int key1, int key2, Map<Integer, Integer> numToParent, Map<Integer, Integer> groupToSize) {\\n        int par1 = find(key1, numToParent);\\n        int par2 = find(key2, numToParent);\\n        if (par1 == par2)\\n            return false;\\n        // parents[par2] = par1\\n        numToParent.put(par2, par1);\\n        groupToSize.put(par1, groupToSize.get(par1) + groupToSize.get(par2));\\n        return true;\\n    }\\n    \\n    private int find(int key1, Map<Integer, Integer> numToParent)  {\\n        if (numToParent.get(key1) == -1) {\\n            return key1;\\n        }\\n        \\n        numToParent.put( key1, find(numToParent.get(key1), numToParent) );\\n        return numToParent.get(key1);\\n    }\\n```",
                "solutionTags": [
                    "Breadth-First Search",
                    "Union Find"
                ],
                "code": "```\\npublic int[] groupStrings(String[] words) {\\n        Map<Integer, Integer> numToParent = new HashMap<>();\\n        Map<Integer, Integer> groupToSize = new HashMap<>();\\n        Map<Integer, List<Integer>> lenToNums = new HashMap<>();\\n        \\n        for(String word : words) {\\n            processNum(word, groupToSize, lenToNums, numToParent);\\n        }\\n        \\n        for(int currLen = 1 ; currLen <= 26 ; currLen++) {\\n        \\tif (lenToNums.containsKey(currLen)) {\\n        \\t\\tList<Integer> currLev = lenToNums.get(currLen);\\n                for(int currNum : currLev) {\\n                \\tfor(int i = 0; i < 26 ; i++) {\\n                        // add\\n                        if ( (currNum & (1 << i)) == 0) {\\n                            int next = (currNum | (1 << i));\\n                            if (numToParent.containsKey(next)) {\\n                                union(currNum, next, numToParent, groupToSize);\\n                            }\\n                            // remove: add + remove = replace\\n                            for(int j = 0 ; j < 26 ; j++) {\\n                                if (i != j && (next & (1 << j)) > 0) {\\n                                    int sameLevNum = (next ^ (1 << j));\\n                                    if (numToParent.containsKey(sameLevNum)) {\\n                                        union(currNum, sameLevNum, numToParent, groupToSize);\\n                                    }\\n                                }\\n                            }\\n                        }\\n                    }\\n                }\\n        \\t}\\n        }\\n        \\n        int maxGroupSize = 0;\\n        int groups = 0;\\n        for(int parent : numToParent.values()) {\\n            if (parent == -1)\\n                groups++;\\n        }\\n        \\n        for(int size : groupToSize.values()) {\\n            maxGroupSize = Math.max(maxGroupSize, size);\\n        }\\n        return new int[]{groups, maxGroupSize};\\n    }\\n    \\n    private void processNum(String word, Map<Integer, Integer>groupToSize, Map<Integer, List<Integer>>lenToNums, Map<Integer, Integer> numToParent) {\\n        int num = wordToNum(word);\\n        groupToSize.put(num, groupToSize.getOrDefault(num, 0) + 1);\\n        if (groupToSize.get(num) == 1) {\\n        \\tlenToNums.computeIfAbsent(word.length(), k -> new ArrayList<>()).add(num);\\n        }\\n        numToParent.put(num, - 1);\\n    }\\n    \\n    private int wordToNum(String word) {\\n        int res = 0;\\n        for(char curr : word.toCharArray()) {\\n            res |= (1 << (curr - \\'a\\'));\\n        }\\n        return res;\\n    }\\n    \\n    private boolean union(int key1, int key2, Map<Integer, Integer> numToParent, Map<Integer, Integer> groupToSize) {\\n        int par1 = find(key1, numToParent);\\n        int par2 = find(key2, numToParent);\\n        if (par1 == par2)\\n            return false;\\n        // parents[par2] = par1\\n        numToParent.put(par2, par1);\\n        groupToSize.put(par1, groupToSize.get(par1) + groupToSize.get(par2));\\n        return true;\\n    }\\n    \\n    private int find(int key1, Map<Integer, Integer> numToParent)  {\\n        if (numToParent.get(key1) == -1) {\\n            return key1;\\n        }\\n        \\n        numToParent.put( key1, find(numToParent.get(key1), numToParent) );\\n        return numToParent.get(key1);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1745014,
                "title": "java-dfs-bitmasking-intuitive-explanation",
                "content": "Whenever we have to compare strings, either we think of trie or bitmasking. We use trie when strings are coming again in the same order, here to do this we\\'d have to sort all strings, and that\\'ll cost us too much. So to store info of each string we are using bitmasking. \\n\\nNow, we\\'ll have to store our bitmasks somewhere, and we are choosing hashmap to make retrieval time constant, and also to store all occurences of a string (same string may appear several times).\\n\\n**Our operations ->**\\n1. Addition and Deletion\\n   If we look closely just by toggling each bit we could do both additon and deletion operation.\\n    \"abc\" -> 000111\\n\\tToggling 0th bit -> 000110 -> \"bc\"\\n\\tToggling 1st bit -> 000101 -> \"ac\"\\n\\tToggling 2nd bit -> 000011 -> \"ab\"\\n\\tToggling 3rd bit -> 001111 -> \"abcd\"\\n\\tToggling 4th bit -> 010111 -> \"abce\"\\n\\tToggling 5th bit -> 100111 -> \"abcf\"\\n  I\\'ve taken 6 bits as an example, in real it\\'ll happen with 26 bits.\\n  \\n2. Replacing the character\\n   As we can only replace existing characters with un-existing ones, so we would just replace set bits (i.e. 1) with un-set bits (i.e 0).\\n   \\n**Approach ->** Simple DFS\\nIterate over the hashmap, pick one bitmask (or string) and do both operations, if the result after each operation still exists in map, then call dfs again for this result, this way we\\'ll have all connected components!! And remember if our bitmask exists in hashmap, then delete it so that we don\\'t call our dfs again for this bitmask or for it\\'s connected components.\\nEach dfs call we make from the groupStrings() function corresponds to different groups, and each call will return it\\'s group\\'s size.\\n\\n```\\npublic int[] groupStrings(String[] words) {\\n        // time -> 26*26*O(N)  space -> 2*O(N)\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        for(String word: words){\\n            int bitmask = 0;\\n            for(char ch: word.toCharArray()){\\n                bitmask |= (1 << (ch - \\'a\\'));\\n            }\\n            map.put( bitmask, map.getOrDefault(bitmask, 0) + 1 );\\n        }\\n        \\n        List<Integer> keyset = new ArrayList<>();\\n        for(Integer key : map.keySet()){\\n            keyset.add(key);\\n        }\\n        \\n        int total_groups = 0, max_size = 0;\\n        \\n        for(Integer key: keyset){\\n            if(!map.containsKey(key)) continue;\\n            \\n            total_groups++;\\n            int size = dfs(key, map);\\n            max_size = Math.max(size, max_size);\\n        }\\n        \\n        return new int[]{total_groups, max_size};\\n    }\\n    \\n    private int dfs(Integer key, HashMap<Integer, Integer> map){\\n        \\n        if(!map.containsKey(key)){\\n            return 0;\\n        }\\n        \\n        int size = map.get(key);\\n        map.remove(key);\\n        // toggling the bits -> both addition and deletion operation\\n        for(int i = 0; i < 26; i++){\\n            size += dfs( (key ^ (1 << i)), map );\\n        }\\n        \\n        // doing the replacing operation -> replacing each set bit with every unset bit\\n        for(int i = 0; i < 26; i++){\\n            if( (key & (1 << i)) > 0 ){ // means ith bit is 1(set)\\n                \\n                for(int j = 0; j < 26; j++){\\n                    if( (key & (1 << j)) == 0 ){ // means jth bit is 0(not set)\\n                        \\n                        size += dfs( (key ^ (1 << i) ^ (1 << j)), map );\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return size;\\n    }\\n```\\n\\nJust read above explanation thoroughly and dry run this code, you\\'ll surely understand it!!\\nHope it helps someone!!\\n\\t",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Bitmask"
                ],
                "code": "```\\npublic int[] groupStrings(String[] words) {\\n        // time -> 26*26*O(N)  space -> 2*O(N)\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        for(String word: words){\\n            int bitmask = 0;\\n            for(char ch: word.toCharArray()){\\n                bitmask |= (1 << (ch - \\'a\\'));\\n            }\\n            map.put( bitmask, map.getOrDefault(bitmask, 0) + 1 );\\n        }\\n        \\n        List<Integer> keyset = new ArrayList<>();\\n        for(Integer key : map.keySet()){\\n            keyset.add(key);\\n        }\\n        \\n        int total_groups = 0, max_size = 0;\\n        \\n        for(Integer key: keyset){\\n            if(!map.containsKey(key)) continue;\\n            \\n            total_groups++;\\n            int size = dfs(key, map);\\n            max_size = Math.max(size, max_size);\\n        }\\n        \\n        return new int[]{total_groups, max_size};\\n    }\\n    \\n    private int dfs(Integer key, HashMap<Integer, Integer> map){\\n        \\n        if(!map.containsKey(key)){\\n            return 0;\\n        }\\n        \\n        int size = map.get(key);\\n        map.remove(key);\\n        // toggling the bits -> both addition and deletion operation\\n        for(int i = 0; i < 26; i++){\\n            size += dfs( (key ^ (1 << i)), map );\\n        }\\n        \\n        // doing the replacing operation -> replacing each set bit with every unset bit\\n        for(int i = 0; i < 26; i++){\\n            if( (key & (1 << i)) > 0 ){ // means ith bit is 1(set)\\n                \\n                for(int j = 0; j < 26; j++){\\n                    if( (key & (1 << j)) == 0 ){ // means jth bit is 0(not set)\\n                        \\n                        size += dfs( (key ^ (1 << i) ^ (1 << j)), map );\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return size;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1734590,
                "title": "simply-only-consider-delete-operation-dfs-and-union-find-100",
                "content": "We only need consider deletion operation. Adding one letter to a word is the same as deleting a letter in another word. For replacement, \"abcx\"  and \"abcz\", repalcing \"x\" with \"z\" in \"abcx\" is the same as deleting \"x\" and \"z\" from the two words, respectively.\\n\\n```\\nimport collections\\nclass Solution:\\n    def groupStrings(self, words: List[str]) -> List[int]:\\n        def get_digit(s):\\n            res = 0\\n            for c in s:\\n                res |= 1 << ord(c) - ord(\\'a\\')\\n            return res\\n        \\n        def dfs(i):\\n            if i in seen:\\n                return 0\\n            seen.add(i)\\n            return count[i] + sum(dfs(j) for j in graph[i])\\n\\n        count = Counter(get_digit(word) for word in words)\\n        graph = defaultdict(set)\\n        grp_cnt, max_size= 0, 0\\n        seen = set()\\n        \\n        for word in words:\\n            cur = get_digit(word)\\n            for i in range(26):\\n                if (cur >> i) & 1:\\n                    nei = cur & ~(1 << i)\\n                    graph[cur].add(nei)\\n                    graph[nei].add(cur)\\n         \\n        for i in count:\\n            if i not in seen:\\n                grp_cnt += 1\\n                size = dfs(i)\\n                max_size = max(max_size, size)\\n        return [grp_cnt, max_size]\\n```\\n\\nSame idea but using UnionFind approach.\\n```\\nfrom collections import Counter\\n\\nclass UnionFind:\\n    def __init__(self, n):\\n        self.par = [i for i in range(n)]\\n        self.rank = [0] * n\\n        \\n    def find(self, i):\\n        if self.par[i] != i:\\n            self.par[i] = self.find(self.par[i])\\n        return self.par[i]\\n    \\n    def union(self, i, j):\\n        pi, pj = self.find(i), self.find(j)\\n        if pi == pj:\\n            return False\\n        if self.rank[pi] < self.rank[pj]:\\n            self.par[pi] = pj\\n        elif self.rank[pi] > self.rank[pj]:\\n            self.par[pj] = pi\\n        else:\\n            self.par[pj] = pi\\n            self.rank[pi] += 1\\n        return True\\n    \\nclass Solution:\\n    def groupStrings(self, words: List[str]) -> List[int]:\\n        def get_digit(s):\\n            res = 0\\n            for c in s:\\n                res |= 1 << (ord(c) - ord(\\'a\\'))\\n            return res\\n        \\n        def group(word, i):\\n            if word in grp_id:\\n                uf.union(grp_id[word], i)\\n            else:\\n                grp_id[word] = i\\n            \\n        n, grp_id = len(words), {}\\n        uf = UnionFind(n)\\n        for i, word in enumerate(words):\\n            w = get_digit(word)\\n            group(w, i)\\n            for k in range(26):\\n                if w >> k & 1:\\n                    ww = w & ~(1 << k)\\n                    group(ww, i)\\n                    \\n        count = Counter(uf.find(i) for i in range(n))\\n        return [len(count), max(count.values())]\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Union Find"
                ],
                "code": "```\\nimport collections\\nclass Solution:\\n    def groupStrings(self, words: List[str]) -> List[int]:\\n        def get_digit(s):\\n            res = 0\\n            for c in s:\\n                res |= 1 << ord(c) - ord(\\'a\\')\\n            return res\\n        \\n        def dfs(i):\\n            if i in seen:\\n                return 0\\n            seen.add(i)\\n            return count[i] + sum(dfs(j) for j in graph[i])\\n\\n        count = Counter(get_digit(word) for word in words)\\n        graph = defaultdict(set)\\n        grp_cnt, max_size= 0, 0\\n        seen = set()\\n        \\n        for word in words:\\n            cur = get_digit(word)\\n            for i in range(26):\\n                if (cur >> i) & 1:\\n                    nei = cur & ~(1 << i)\\n                    graph[cur].add(nei)\\n                    graph[nei].add(cur)\\n         \\n        for i in count:\\n            if i not in seen:\\n                grp_cnt += 1\\n                size = dfs(i)\\n                max_size = max(max_size, size)\\n        return [grp_cnt, max_size]\\n```\n```\\nfrom collections import Counter\\n\\nclass UnionFind:\\n    def __init__(self, n):\\n        self.par = [i for i in range(n)]\\n        self.rank = [0] * n\\n        \\n    def find(self, i):\\n        if self.par[i] != i:\\n            self.par[i] = self.find(self.par[i])\\n        return self.par[i]\\n    \\n    def union(self, i, j):\\n        pi, pj = self.find(i), self.find(j)\\n        if pi == pj:\\n            return False\\n        if self.rank[pi] < self.rank[pj]:\\n            self.par[pi] = pj\\n        elif self.rank[pi] > self.rank[pj]:\\n            self.par[pj] = pi\\n        else:\\n            self.par[pj] = pi\\n            self.rank[pi] += 1\\n        return True\\n    \\nclass Solution:\\n    def groupStrings(self, words: List[str]) -> List[int]:\\n        def get_digit(s):\\n            res = 0\\n            for c in s:\\n                res |= 1 << (ord(c) - ord(\\'a\\'))\\n            return res\\n        \\n        def group(word, i):\\n            if word in grp_id:\\n                uf.union(grp_id[word], i)\\n            else:\\n                grp_id[word] = i\\n            \\n        n, grp_id = len(words), {}\\n        uf = UnionFind(n)\\n        for i, word in enumerate(words):\\n            w = get_digit(word)\\n            group(w, i)\\n            for k in range(26):\\n                if w >> k & 1:\\n                    ww = w & ~(1 << k)\\n                    group(ww, i)\\n                    \\n        count = Counter(uf.find(i) for i in range(n))\\n        return [len(count), max(count.values())]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1733905,
                "title": "java-solution-union-find-ds-bit-masking-hashmap-easy-understanding",
                "content": "```\\nclass Solution {\\n     class UnionFind{\\n        int []parent,size;\\n        int max=1,group;\\n        UnionFind(int n){\\n            parent=new int[n];\\n            size=new int[n];\\n            group=n;\\n            for (int i=0;i<n;i++){\\n                parent[i]=i;\\n                size[i]=1;\\n            }\\n        }\\n\\n\\n\\n        public int find(int n){\\n            if(parent[n]==n) return n;\\n            else return find(parent[n]);\\n        }\\n\\n        public void union(int a,int b){\\n\\n            int parenta=find(a);\\n            int parentb=find(b);\\n            if (parenta!=parentb){\\n                if (size[parentb]>size[parenta]){\\n                    size[parentb]+=size[parenta];\\n                    max=Math.max(size[parentb],max);\\n                    parent[parenta]=parentb;\\n                }\\n                else{\\n                    size[parenta]+=size[parentb];\\n                    max=Math.max(size[parenta],max);\\n                    parent[parentb]=parenta;\\n                }\\n                group--;\\n            }\\n\\n        }\\n\\n\\n\\n    }\\n\\n    int getMask(String word){\\n        int mask=0;\\n        for(int i=0;i<word.length();i++){\\n            mask|= 1<<(word.charAt(i)-\\'a\\');\\n        }\\n        return mask;\\n    }\\n\\n\\n    public int[] groupStrings(String[] words) {\\n\\n        UnionFind unionFind=new UnionFind(words.length);\\n        HashMap<Integer,Integer> map=new HashMap<>();\\n        for (int i=0;i<words.length;i++){\\n            int mask=getMask(words[i]);\\n            if (map.containsKey(mask))\\n            unionFind.union(i,map.get(mask));\\n            map.put(mask,i);\\n\\n        }\\n        for (Map.Entry<Integer,Integer> entry:map.entrySet()){\\n            int mask=entry.getKey();\\n            int index=entry.getValue();\\n\\n\\n            for (int i=0;i<26;i++){\\n                if ((mask & (1<<i))==0){\\n                    if (map.containsKey(mask|(1<<i)))\\n                    unionFind.union(index,map.get(mask|(1<<i)));\\n                }\\n            }\\n\\n\\n            for (int i=0;i<26;i++){\\n                if ((mask & (1<<i))>0){\\n                    if (map.containsKey(mask^(1<<i)))\\n                        unionFind.union(index,map.get(mask^(1<<i)));\\n                }\\n            }\\n\\n\\n            for (int i=0;i<26;i++){\\n                for (int j=i+1;j<26;j++){\\n\\n                    if (getBit(mask,i)!=getBit(mask,j)){\\n                        int t= mask^((1<<i) | (1<<j));\\n                        if (map.containsKey(t))\\n                            unionFind.union(index,map.get(t));\\n                    }\\n                }\\n            }\\n\\n        }\\n        return new int[]{unionFind.group,unionFind.max};\\n    }\\n\\n    int getBit(int mask,int pos){\\n        return (mask&(1<<pos))>0?1:0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n     class UnionFind{\\n        int []parent,size;\\n        int max=1,group;\\n        UnionFind(int n){\\n            parent=new int[n];\\n            size=new int[n];\\n            group=n;\\n            for (int i=0;i<n;i++){\\n                parent[i]=i;\\n                size[i]=1;\\n            }\\n        }\\n\\n\\n\\n        public int find(int n){\\n            if(parent[n]==n) return n;\\n            else return find(parent[n]);\\n        }\\n\\n        public void union(int a,int b){\\n\\n            int parenta=find(a);\\n            int parentb=find(b);\\n            if (parenta!=parentb){\\n                if (size[parentb]>size[parenta]){\\n                    size[parentb]+=size[parenta];\\n                    max=Math.max(size[parentb],max);\\n                    parent[parenta]=parentb;\\n                }\\n                else{\\n                    size[parenta]+=size[parentb];\\n                    max=Math.max(size[parenta],max);\\n                    parent[parentb]=parenta;\\n                }\\n                group--;\\n            }\\n\\n        }\\n\\n\\n\\n    }\\n\\n    int getMask(String word){\\n        int mask=0;\\n        for(int i=0;i<word.length();i++){\\n            mask|= 1<<(word.charAt(i)-\\'a\\');\\n        }\\n        return mask;\\n    }\\n\\n\\n    public int[] groupStrings(String[] words) {\\n\\n        UnionFind unionFind=new UnionFind(words.length);\\n        HashMap<Integer,Integer> map=new HashMap<>();\\n        for (int i=0;i<words.length;i++){\\n            int mask=getMask(words[i]);\\n            if (map.containsKey(mask))\\n            unionFind.union(i,map.get(mask));\\n            map.put(mask,i);\\n\\n        }\\n        for (Map.Entry<Integer,Integer> entry:map.entrySet()){\\n            int mask=entry.getKey();\\n            int index=entry.getValue();\\n\\n\\n            for (int i=0;i<26;i++){\\n                if ((mask & (1<<i))==0){\\n                    if (map.containsKey(mask|(1<<i)))\\n                    unionFind.union(index,map.get(mask|(1<<i)));\\n                }\\n            }\\n\\n\\n            for (int i=0;i<26;i++){\\n                if ((mask & (1<<i))>0){\\n                    if (map.containsKey(mask^(1<<i)))\\n                        unionFind.union(index,map.get(mask^(1<<i)));\\n                }\\n            }\\n\\n\\n            for (int i=0;i<26;i++){\\n                for (int j=i+1;j<26;j++){\\n\\n                    if (getBit(mask,i)!=getBit(mask,j)){\\n                        int t= mask^((1<<i) | (1<<j));\\n                        if (map.containsKey(t))\\n                            unionFind.union(index,map.get(t));\\n                    }\\n                }\\n            }\\n\\n        }\\n        return new int[]{unionFind.group,unionFind.max};\\n    }\\n\\n    int getBit(int mask,int pos){\\n        return (mask&(1<<pos))>0?1:0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1731355,
                "title": "go-union-find-bitmask-with-explanation",
                "content": "# Approach\\n\\nWe are only interested in sets of characters, so we can use bitmasks to\\nrepresent each word. The words are like nodes in the graph, and the bitmasks \\nare possible edges.\\n\\nUsing [DBabichev](https://leetcode.com/problems/groups-of-strings/discuss/1730113/Python-carefull-dfs-with-bitmasks-explained.)\\'s trick, the add / remove / replace action can be \\nperformed by adding a wildcard to the current mask (add), and replacing a\\nbit in the mask with a wildcard (replace/remove).\\n\\nE.g. the string \"abc\" results in sets `{a,b,c,*}`, `{a,b,*}`, `{a,b,*}`, `{b,c,*}`.\\n\"ba\" will be matched by `{a,b,*}`.\\n\"cdba\" will be matched by `{a,b,c,*}`.\\n\\nThe wildcard is represented by the bit `1 << 26`.\\n\\nSo we visit each word, calculate its wildcard masks and append the index to each\\nmasks\\' indices.\\n\\nTo combine linked words into groups, DSU can be used. It\\'s important to use path\\ncompression in this problem, as the largest set is 20000.\\n\\n# Solution\\n\\n```go\\nfunc groupStrings(words []string) []int {\\n\\tgetBits := func(w string) int {\\n\\t\\tvar res int\\n\\t\\tfor _, ch := range w {\\n\\t\\t\\tres |= 1 << int(ch-\\'a\\')\\n\\t\\t}\\n\\t\\treturn res\\n\\t}\\n\\n\\tn := len(words)\\n\\n\\t// DSU setup\\n\\tparent := make([]int, n)\\n\\tsize := make([]int, n)\\n\\tfor i := range words {\\n\\t\\tparent[i] = i\\n\\t\\tsize[i] = 1\\n\\t}\\n\\tvar find func(a int) int\\n\\tfind = func(a int) int {\\n\\t\\tif parent[a] == a {\\n\\t\\t\\treturn a\\n\\t\\t}\\n\\t\\tparent[a] = find(parent[a]) // path compression\\n\\t\\treturn parent[a]\\n\\t}\\n\\tunion := func(a, b int) {\\n\\t\\tra, rb := find(a), find(b)\\n\\t\\tif ra != rb {\\n\\t\\t\\tparent[rb] = ra\\n\\t\\t\\tsize[ra] += size[rb]\\n\\t\\t}\\n\\t}\\n\\n\\t// For each word, parse its bit-masks and add to a list of indices per mask\\n\\tmasks := make(map[int][]int, n)\\n\\tfor i, w := range words {\\n\\t\\tbits := getBits(w)\\n\\t\\tmasks[bits+1<<26] = append(masks[bits+1<<26], i) // add wildcard\\n\\t\\tfor b := 1; b < 1<<27; b <<= 1 {\\n\\t\\t\\tif bits&b > 0 {\\n\\t\\t\\t\\treplaced := (bits &^ b) | 1<<26\\n\\t\\t\\t\\tmasks[replaced] = append(masks[replaced], i) // replacement wildcard\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t// For each mask, union matched indices\\n\\tfor _, indices := range masks {\\n\\t\\tfor i := 0; i < len(indices)-1; i++ {\\n\\t\\t\\tunion(indices[i], indices[i+1])\\n\\t\\t}\\n\\t}\\n\\n\\t// Collect group sizes\\n\\tgroupSize := make(map[int]int)\\n\\tvar largestGroup int\\n\\tfor i := range words {\\n\\t\\tr := find(i)\\n\\t\\tgroupSize[r] = size[r]\\n\\t\\tif groupSize[r] > largestGroup {\\n\\t\\t\\tlargestGroup = groupSize[r]\\n\\t\\t}\\n\\t}\\n\\n\\tres := []int{len(groupSize), largestGroup}\\n\\treturn res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc groupStrings(words []string) []int {\\n\\tgetBits := func(w string) int {\\n\\t\\tvar res int\\n\\t\\tfor _, ch := range w {\\n\\t\\t\\tres |= 1 << int(ch-\\'a\\')\\n\\t\\t}\\n\\t\\treturn res\\n\\t}\\n\\n\\tn := len(words)\\n\\n\\t// DSU setup\\n\\tparent := make([]int, n)\\n\\tsize := make([]int, n)\\n\\tfor i := range words {\\n\\t\\tparent[i] = i\\n\\t\\tsize[i] = 1\\n\\t}\\n\\tvar find func(a int) int\\n\\tfind = func(a int) int {\\n\\t\\tif parent[a] == a {\\n\\t\\t\\treturn a\\n\\t\\t}\\n\\t\\tparent[a] = find(parent[a]) // path compression\\n\\t\\treturn parent[a]\\n\\t}\\n\\tunion := func(a, b int) {\\n\\t\\tra, rb := find(a), find(b)\\n\\t\\tif ra != rb {\\n\\t\\t\\tparent[rb] = ra\\n\\t\\t\\tsize[ra] += size[rb]\\n\\t\\t}\\n\\t}\\n\\n\\t// For each word, parse its bit-masks and add to a list of indices per mask\\n\\tmasks := make(map[int][]int, n)\\n\\tfor i, w := range words {\\n\\t\\tbits := getBits(w)\\n\\t\\tmasks[bits+1<<26] = append(masks[bits+1<<26], i) // add wildcard\\n\\t\\tfor b := 1; b < 1<<27; b <<= 1 {\\n\\t\\t\\tif bits&b > 0 {\\n\\t\\t\\t\\treplaced := (bits &^ b) | 1<<26\\n\\t\\t\\t\\tmasks[replaced] = append(masks[replaced], i) // replacement wildcard\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t// For each mask, union matched indices\\n\\tfor _, indices := range masks {\\n\\t\\tfor i := 0; i < len(indices)-1; i++ {\\n\\t\\t\\tunion(indices[i], indices[i+1])\\n\\t\\t}\\n\\t}\\n\\n\\t// Collect group sizes\\n\\tgroupSize := make(map[int]int)\\n\\tvar largestGroup int\\n\\tfor i := range words {\\n\\t\\tr := find(i)\\n\\t\\tgroupSize[r] = size[r]\\n\\t\\tif groupSize[r] > largestGroup {\\n\\t\\t\\tlargestGroup = groupSize[r]\\n\\t\\t}\\n\\t}\\n\\n\\tres := []int{len(groupSize), largestGroup}\\n\\treturn res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1730472,
                "title": "solution-for-c-union-find-and-bit-mask",
                "content": "sort with length first and skip bit mask task of words with same set of letters\\n```cpp\\nclass Solution\\n{\\n    vector<int> colors;\\n    int find_root_color(int n)\\n    {\\n        if (colors[n] != n)\\n        {\\n            return colors[n] = find_root_color(colors[n]);\\n        }\\n        return n;\\n    }\\n\\npublic:\\n    vector<int> groupStrings(vector<string> &words)\\n    {\\n        int w = words.size();\\n        for (int i = 0; i != w; ++i)\\n        {\\n            colors.push_back(i);\\n        }\\n        sort(words.begin(), words.end(), [](string &a, string &b)\\n             { return a.size() < b.size(); });\\n        unordered_map<int, int> mp;\\n        for (int i = 0; i != w; ++i)\\n        {\\n            auto &word = words[i];\\n            int int_word = 0;\\n            for (auto w : word)\\n            {\\n                int_word |= 1 << (w - \\'a\\');\\n            }\\n            if (mp.count(int_word))\\n            {\\n                colors[find_root_color(mp[int_word])] = colors[i];\\n                mp[int_word] = colors[i];\\n                continue;\\n            }\\n            else\\n            {\\n                mp[int_word] = colors[i];\\n            }\\n            for (int j = 0, w_w = word.size(); j != w_w; ++j)\\n            {\\n                int_word ^= (1 << (word[j] - \\'a\\'));\\n                if (!mp.count(int_word))\\n                {\\n                    mp[int_word] = colors[i];\\n                }\\n                else\\n                {\\n                    colors[find_root_color(mp[int_word])] = colors[i];\\n                    mp[int_word] = colors[i];\\n                }\\n                int_word |= (1 << (word[j] - \\'a\\'));\\n            }\\n        }\\n        vector<int> gp(w);\\n        vector<int> res = {0, 0};\\n        for (auto c : colors)\\n        {\\n            int find_color = find_root_color(c);\\n            ++gp[find_color];\\n            if (gp[find_color] > res[1])\\n            {\\n                res[1] = gp[find_color];\\n            }\\n            if (gp[find_color] == 1)\\n            {\\n                ++res[0];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nclass Solution\\n{\\n    vector<int> colors;\\n    int find_root_color(int n)\\n    {\\n        if (colors[n] != n)\\n        {\\n            return colors[n] = find_root_color(colors[n]);\\n        }\\n        return n;\\n    }\\n\\npublic:\\n    vector<int> groupStrings(vector<string> &words)\\n    {\\n        int w = words.size();\\n        for (int i = 0; i != w; ++i)\\n        {\\n            colors.push_back(i);\\n        }\\n        sort(words.begin(), words.end(), [](string &a, string &b)\\n             { return a.size() < b.size(); });\\n        unordered_map<int, int> mp;\\n        for (int i = 0; i != w; ++i)\\n        {\\n            auto &word = words[i];\\n            int int_word = 0;\\n            for (auto w : word)\\n            {\\n                int_word |= 1 << (w - \\'a\\');\\n            }\\n            if (mp.count(int_word))\\n            {\\n                colors[find_root_color(mp[int_word])] = colors[i];\\n                mp[int_word] = colors[i];\\n                continue;\\n            }\\n            else\\n            {\\n                mp[int_word] = colors[i];\\n            }\\n            for (int j = 0, w_w = word.size(); j != w_w; ++j)\\n            {\\n                int_word ^= (1 << (word[j] - \\'a\\'));\\n                if (!mp.count(int_word))\\n                {\\n                    mp[int_word] = colors[i];\\n                }\\n                else\\n                {\\n                    colors[find_root_color(mp[int_word])] = colors[i];\\n                    mp[int_word] = colors[i];\\n                }\\n                int_word |= (1 << (word[j] - \\'a\\'));\\n            }\\n        }\\n        vector<int> gp(w);\\n        vector<int> res = {0, 0};\\n        for (auto c : colors)\\n        {\\n            int find_color = find_root_color(c);\\n            ++gp[find_color];\\n            if (gp[find_color] > res[1])\\n            {\\n                res[1] = gp[find_color];\\n            }\\n            if (gp[find_color] == 1)\\n            {\\n                ++res[0];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1730413,
                "title": "java-bit-masking-and-dsu",
                "content": "Idea:\\n1. Use DSU to join. I also had to use ranks to pass the test.\\n2. Every chararacter appears only once --> we can represent the set of characters as integer with bit manipulation (character `a` as last bit, `b` as second last bit, etc.)\\n3. How to tell if it can be merged?\\n\\t* \\tIf there is only one bit difference, it means one character is missing. `xor & (xor - 1)) == 0`; that menas one bit is missing compared to others (i.e. one character is added or removed)\\n\\t* \\tHow do we find one character is *replaced*, use `and = a & b`, and compare it with `a` and `b`.\\n4. Some more optimizations:\\n\\t* Sort words by length, and if the length differs by 2 or more, we can skip the rest of it\\n\\t* Use ranks for DSU\\n\\t* No need to repeat long merge computations again if two different words have same set of unique letters. I used `seen` to track the words that have the same bit representations.\\n5. The rest is easy. Loop through the index, count the number of parents, track maximum length using hashmap.\\n\\n```\\nclass Solution {\\n    public int[] groupStrings(String[] words) {\\n        int n = words.length;\\n        Arrays.sort(words, Comparator.comparingInt(String::length));\\n        int[] parents = new int[n];\\n        int[] ranks = new int[n];\\n        for (int i = 0; i < n; i++) parents[i] = i;\\n        Arrays.fill(ranks, 1);\\n\\n        int[] masks = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            int val = 0;\\n            for (int j = 0; j < words[i].length(); j++) {\\n                val += (1 << (words[i].charAt(j) - \\'a\\'));\\n            }\\n            masks[i] = val;\\n        }\\n        Set<Integer> seen = new HashSet<>();\\n        for (int i = 0; i < n; i++) {\\n            if (seen.contains(masks[i])) continue;\\n            for (int j = i + 1; j < n; j++) {\\n                if (words[i].length() + 1 < words[j].length()) break;\\n                int p1 = find(parents, i), p2 = find(parents, j);\\n                if (p1 == p2) continue;\\n                int a = masks[i], b = masks[j];\\n                if (a == b) merge(parents, ranks, p1, p2);\\n                int xor = a ^ b;\\n                int and = a & b;\\n                int xor1 = a ^ and, xor2 = b ^ and;\\n                if ((xor & (xor - 1)) == 0 || ((xor1 & (xor1 - 1)) == 0 && (xor2 & (xor2 - 1)) == 0)) {\\n                    merge(parents, ranks, p1, p2);\\n                }\\n            }\\n            seen.add(masks[i]);\\n        }\\n\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int max = 1;\\n        for (int i = 0; i < n; i++) {\\n            int f = find(parents, i);\\n            int cnt = map.getOrDefault(f, 0) + 1;\\n            map.put(f, cnt);\\n            max = Math.max(max, cnt);\\n        }\\n\\n        return new int[]{map.size(), max};\\n    }\\n\\n    private int find(int[] parents, int i) {\\n        return parents[i] = parents[i] == i ? i: find(parents, parents[i]);\\n    }\\n\\n    private void merge(int[] parents, int[] ranks, int i, int j) {\\n        int p1 = find(parents, i), p2 = find(parents, j);\\n        if (p1 == p2) return;\\n        if (ranks[p1] > ranks[p2]) {\\n            parents[p1] = p2;\\n            parents[i] = p2;\\n            ranks[p2]++;\\n            return;\\n        }\\n        parents[p2] = p1;\\n        parents[j] = p1;\\n        ranks[p1]++;\\n    }\\n}\\n```\\nThis code barely passes, and is still quite slow. I would love to see other people\\'s solutions. :)",
                "solutionTags": [
                    "Java",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\n    public int[] groupStrings(String[] words) {\\n        int n = words.length;\\n        Arrays.sort(words, Comparator.comparingInt(String::length));\\n        int[] parents = new int[n];\\n        int[] ranks = new int[n];\\n        for (int i = 0; i < n; i++) parents[i] = i;\\n        Arrays.fill(ranks, 1);\\n\\n        int[] masks = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            int val = 0;\\n            for (int j = 0; j < words[i].length(); j++) {\\n                val += (1 << (words[i].charAt(j) - \\'a\\'));\\n            }\\n            masks[i] = val;\\n        }\\n        Set<Integer> seen = new HashSet<>();\\n        for (int i = 0; i < n; i++) {\\n            if (seen.contains(masks[i])) continue;\\n            for (int j = i + 1; j < n; j++) {\\n                if (words[i].length() + 1 < words[j].length()) break;\\n                int p1 = find(parents, i), p2 = find(parents, j);\\n                if (p1 == p2) continue;\\n                int a = masks[i], b = masks[j];\\n                if (a == b) merge(parents, ranks, p1, p2);\\n                int xor = a ^ b;\\n                int and = a & b;\\n                int xor1 = a ^ and, xor2 = b ^ and;\\n                if ((xor & (xor - 1)) == 0 || ((xor1 & (xor1 - 1)) == 0 && (xor2 & (xor2 - 1)) == 0)) {\\n                    merge(parents, ranks, p1, p2);\\n                }\\n            }\\n            seen.add(masks[i]);\\n        }\\n\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int max = 1;\\n        for (int i = 0; i < n; i++) {\\n            int f = find(parents, i);\\n            int cnt = map.getOrDefault(f, 0) + 1;\\n            map.put(f, cnt);\\n            max = Math.max(max, cnt);\\n        }\\n\\n        return new int[]{map.size(), max};\\n    }\\n\\n    private int find(int[] parents, int i) {\\n        return parents[i] = parents[i] == i ? i: find(parents, parents[i]);\\n    }\\n\\n    private void merge(int[] parents, int[] ranks, int i, int j) {\\n        int p1 = find(parents, i), p2 = find(parents, j);\\n        if (p1 == p2) return;\\n        if (ranks[p1] > ranks[p2]) {\\n            parents[p1] = p2;\\n            parents[i] = p2;\\n            ranks[p2]++;\\n            return;\\n        }\\n        parents[p2] = p1;\\n        parents[j] = p1;\\n        ranks[p1]++;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1730116,
                "title": "why-this-test-case-showing-8-3",
                "content": "if words==[\"ghnv\",\"uip\",\"tenv\",\"hvepx\",\"e\",\"ktc\",\"byjdt\",\"ulm\",\"cae\",\"ea\"]:\\n            return [8,3]",
                "solutionTags": [],
                "code": "if words==[\"ghnv\",\"uip\",\"tenv\",\"hvepx\",\"e\",\"ktc\",\"byjdt\",\"ulm\",\"cae\",\"ea\"]:\\n            return [8,3]",
                "codeTag": "Unknown"
            },
            {
                "id": 2522009,
                "title": "c-union-find-with-bithmask-easy-to-understand",
                "content": "```\\nclass Solution {\\n    class union_find {\\n        vector<int> rank;\\n        vector<int> parent;\\n        int N;\\n        public:\\n        union_find(int n):N(n) {\\n            for (int i = 0; i < n; i++) {\\n                parent.push_back(i);\\n                rank.push_back(1);\\n            }\\n        }\\n        bool isConnected(int i, int j) {\\n            return find(i) == find(j);\\n        }\\n        int find(int u) {\\n            while(u != parent[u]) {\\n                parent[u] = parent[parent[u]];\\n                u = parent[u];\\n            }\\n            return u;\\n        }\\n        void merge(int i, int j) {\\n            i = find(i); j = find(j);\\n            if (i == j) {\\n                return ;\\n            }\\n            if (rank[i] >= rank[j]) {\\n                parent[j] = i;\\n                rank[i]+= rank[j]; rank[j] = 0;\\n            } else if (rank[j] > rank[i]) {\\n                parent[i] = j;\\n                rank[j]+= rank[i]; rank[i] = 0;\\n            }\\n            N--;\\n           \\n        }\\n        int size() const { return N; }\\n        int largestRank() {\\n\\t\\t    return *max_element(rank.begin(), rank.end());\\n        }\\n    };\\n    int getMask(const std::string &s) {\\n        int mask = 0;\\n        for (char ch: s) {\\n            mask = mask ^ (1<<(ch-\\'a\\'));\\n        }\\n        return mask;\\n    }\\n    unordered_map<int, int> mask;    \\npublic:\\n    vector<int> groupStrings(vector<string>& words) {\\n        int n = words.size();\\n        mask.clear();\\n        union_find uf(n);\\n        for (int i = 0; i < n; i++) {\\n            int m = getMask(words[i]);\\n\\t\\t\\t/* Add and Delete operations */\\n            for (char ch=\\'a\\'; ch <= \\'z\\'; ch++) {\\n                int newMask = m ^ (1<<(ch-\\'a\\'));\\n                if (mask.find(newMask) != mask.end()) {\\n                    uf.merge(i, mask[newMask]);\\n                }\\n            }\\n            \\n\\t\\t\\t/* Replace operation */\\n            for (char ch=\\'a\\'; ch <= \\'z\\'; ch++) {\\n                if ((m & (1<<(ch-\\'a\\')))==0) continue; //If char does not exist in word\\n                for (char c=\\'a\\'; c<=\\'z\\';c++) {\\n                    if ((m & (1<<(c-\\'a\\')))==0) {\\n                        int newMask = m;\\n                        newMask = newMask ^ (1<<(ch-\\'a\\'));  // Delete exiting char\\n                        newMask = newMask ^ (1<<(c-\\'a\\'));   // Add char\\n                        if (mask.find(newMask) != mask.end()) {\\n                            uf.merge(i, mask[newMask]);\\n                        }\\n                    }\\n                }\\n            }\\n\\t\\t\\t\\n\\t\\t\\t/* Duplicate word */\\n            if(mask.find(m) != mask.end()){\\n                uf.merge(i, mask[m]);\\n            }\\n            \\n            mask[m] = i;\\n        }\\n        return {uf.size(), uf.largestRank()};\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    class union_find {\\n        vector<int> rank;\\n        vector<int> parent;\\n        int N;\\n        public:\\n        union_find(int n):N(n) {\\n            for (int i = 0; i < n; i++) {\\n                parent.push_back(i);\\n                rank.push_back(1);\\n            }\\n        }\\n        bool isConnected(int i, int j) {\\n            return find(i) == find(j);\\n        }\\n        int find(int u) {\\n            while(u != parent[u]) {\\n                parent[u] = parent[parent[u]];\\n                u = parent[u];\\n            }\\n            return u;\\n        }\\n        void merge(int i, int j) {\\n            i = find(i); j = find(j);\\n            if (i == j) {\\n                return ;\\n            }\\n            if (rank[i] >= rank[j]) {\\n                parent[j] = i;\\n                rank[i]+= rank[j]; rank[j] = 0;\\n            } else if (rank[j] > rank[i]) {\\n                parent[i] = j;\\n                rank[j]+= rank[i]; rank[i] = 0;\\n            }\\n            N--;\\n           \\n        }\\n        int size() const { return N; }\\n        int largestRank() {\\n\\t\\t    return *max_element(rank.begin(), rank.end());\\n        }\\n    };\\n    int getMask(const std::string &s) {\\n        int mask = 0;\\n        for (char ch: s) {\\n            mask = mask ^ (1<<(ch-\\'a\\'));\\n        }\\n        return mask;\\n    }\\n    unordered_map<int, int> mask;    \\npublic:\\n    vector<int> groupStrings(vector<string>& words) {\\n        int n = words.size();\\n        mask.clear();\\n        union_find uf(n);\\n        for (int i = 0; i < n; i++) {\\n            int m = getMask(words[i]);\\n\\t\\t\\t/* Add and Delete operations */\\n            for (char ch=\\'a\\'; ch <= \\'z\\'; ch++) {\\n                int newMask = m ^ (1<<(ch-\\'a\\'));\\n                if (mask.find(newMask) != mask.end()) {\\n                    uf.merge(i, mask[newMask]);\\n                }\\n            }\\n            \\n\\t\\t\\t/* Replace operation */\\n            for (char ch=\\'a\\'; ch <= \\'z\\'; ch++) {\\n                if ((m & (1<<(ch-\\'a\\')))==0) continue; //If char does not exist in word\\n                for (char c=\\'a\\'; c<=\\'z\\';c++) {\\n                    if ((m & (1<<(c-\\'a\\')))==0) {\\n                        int newMask = m;\\n                        newMask = newMask ^ (1<<(ch-\\'a\\'));  // Delete exiting char\\n                        newMask = newMask ^ (1<<(c-\\'a\\'));   // Add char\\n                        if (mask.find(newMask) != mask.end()) {\\n                            uf.merge(i, mask[newMask]);\\n                        }\\n                    }\\n                }\\n            }\\n\\t\\t\\t\\n\\t\\t\\t/* Duplicate word */\\n            if(mask.find(m) != mask.end()){\\n                uf.merge(i, mask[m]);\\n            }\\n            \\n            mask[m] = i;\\n        }\\n        return {uf.size(), uf.largestRank()};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2072875,
                "title": "c-dfs-w-bitmasks",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> groupStrings(vector<string>& words) {\\n        unordered_map<int, int> nums;\\n        for (const auto& w : words) {\\n            int x = accumulate(begin(w), end(w), 0,\\n                               [](int s, char c) { return s|(1<<(c-\\'a\\')); });\\n            nums[x]++;\\n        }\\n        int ngroups = 0, largest = 0;\\n        for (auto [x, count] : nums) {\\n            if (count) {\\n                ngroups++;\\n                largest = max(largest, dfs(x, nums));\\n            }\\n        }\\n        return {ngroups, largest};\\n    }\\nprivate:\\n    int dfs(int x, unordered_map<int, int>& nums) {\\n        int cur = 0;\\n        if (auto it = nums.find(x); it != end(nums) && it->second) {\\n            cur += it->second;\\n            it->second = 0;\\n            for (size_t m = 1; m < 1<<26; m <<= 1) {\\n                cur += dfs(x^m, nums);\\n                for (size_t m2 = 1; m2 < 1<<26; m2 <<= 1)\\n                    if (x&m && !(x&m2))\\n                        cur += dfs(x^m^m2, nums);\\n            }\\n        }\\n        return cur;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> groupStrings(vector<string>& words) {\\n        unordered_map<int, int> nums;\\n        for (const auto& w : words) {\\n            int x = accumulate(begin(w), end(w), 0,\\n                               [](int s, char c) { return s|(1<<(c-\\'a\\')); });\\n            nums[x]++;\\n        }\\n        int ngroups = 0, largest = 0;\\n        for (auto [x, count] : nums) {\\n            if (count) {\\n                ngroups++;\\n                largest = max(largest, dfs(x, nums));\\n            }\\n        }\\n        return {ngroups, largest};\\n    }\\nprivate:\\n    int dfs(int x, unordered_map<int, int>& nums) {\\n        int cur = 0;\\n        if (auto it = nums.find(x); it != end(nums) && it->second) {\\n            cur += it->second;\\n            it->second = 0;\\n            for (size_t m = 1; m < 1<<26; m <<= 1) {\\n                cur += dfs(x^m, nums);\\n                for (size_t m2 = 1; m2 < 1<<26; m2 <<= 1)\\n                    if (x&m && !(x&m2))\\n                        cur += dfs(x^m^m2, nums);\\n            }\\n        }\\n        return cur;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2000000,
                "title": "python3-o-26-n-no-tle-only-look-at-add-no-delete-and-replace",
                "content": "If you are using Python with O(26\\\\*26\\\\*n) solution, there is a good chance that you will get TLE.\\nWe use bit mask to represent each word. And for each word, we enumerate all possible changes for \"add-one-char\", \"delete-one-char\", and \"replace-one-char\". Totally 26\\\\*26 possibilites. But this is still too much and will very likely get TLE in Python.\\nWe will need to further optimize it by looking at only the 26 \"add-one-char\" changes. Don\\'t look at \"delete\" and \"replace\".\\nNo \"delete\" because if word1 can become word2 by deleting one char, then word2 can become word1 by adding one char.\\nNo \"replace\" because if word1 can become word2 by replacing one char, then there must exist an intermediate \"word3\", thus both word1 adding one char and word2 adding one char equals \"word3\".\\nWe introduce a \"links\" dictionary, that maps all the \"add-one-char\" words to its original word. For example, for \"ab\", we have {abc:ab, abd:ab, abe:ab, ...}.\\nWhen looking for \"replace-one-char\" for \"ac\", one of its 26 \"add-one-char\" words is \"abc\", and in the \"links\" dict we have \"abc->ab\", this way we know \"ac->ab\".\\n\\n```\\n    def groupStrings(self, words: List[str]) -> List[int]:\\n        uf=[i for i in range(len(words))]\\n        def find(x):\\n            if uf[x]!=x:\\n                uf[x]=find(uf[x])\\n            return uf[x]\\n        links = {}\\n        for i,w in enumerate(words):\\n            word = sum(1<<(ord(c)-ord(\\'a\\')) for c in w)\\n            for add_bit in range(26): # only add, no delete or replace\\n                word2 = word|(1<<add_bit) \\n                linked_idx = links.setdefault(word2,i)\\n                if find(i)!=find(linked_idx):\\n                    uf[find(i)]=find(linked_idx)\\n        counter = Counter(find(i) for i in range(len(words)))\\n        return [len(counter),max(counter.values())]\\n```",
                "solutionTags": [],
                "code": "```\\n    def groupStrings(self, words: List[str]) -> List[int]:\\n        uf=[i for i in range(len(words))]\\n        def find(x):\\n            if uf[x]!=x:\\n                uf[x]=find(uf[x])\\n            return uf[x]\\n        links = {}\\n        for i,w in enumerate(words):\\n            word = sum(1<<(ord(c)-ord(\\'a\\')) for c in w)\\n            for add_bit in range(26): # only add, no delete or replace\\n                word2 = word|(1<<add_bit) \\n                linked_idx = links.setdefault(word2,i)\\n                if find(i)!=find(linked_idx):\\n                    uf[find(i)]=find(linked_idx)\\n        counter = Counter(find(i) for i in range(len(words)))\\n        return [len(counter),max(counter.values())]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1772767,
                "title": "only-removing-is-needed-o-n-26-python",
                "content": "Suppose you have two words w1, w2 they belong to the same group iff removing one letter from each we can get same string (correspond to replacing). Or removing one character from just one string will match the second one. \\n\\nIn this way, you can loop through each word and by removing a letter generate new words. After that for each new word recall indexes of the words it can be generated from and add all these indexes to the same group using DSU linearly.\\n\\nRepresenting each word as a 32-bit number (aka bitmasking) helps us perform removal operations fast. \\n\\n```\\nfrom collections import defaultdict\\n\\nclass DSU:\\n    def __init__(self, size):\\n        self.pr = list(range(size))\\n        self.hs = [0] * size\\n        self.sz = [1] * size\\n\\n    def find(self, i):\\n        if self.pr[i] != i:\\n            self.pr[i] = self.find(self.pr[i])\\n        return self.pr[i]\\n\\n    def union(self, i, j):\\n        pi, pj = self.find(i), self.find(j)\\n        if pi == pj: return\\n        if self.hs[pi] < self.hs[pj]:\\n            pi, pj = pj, pi\\n        self.pr[pj] = pi\\n        self.hs[pi] += 1 if self.hs[pi] == self.hs[pj] else 0\\n        self.sz[pi] += self.sz[pj]\\n\\n\\nclass Solution:\\n    def groupStrings(self, words):\\n        w2num = lambda w: sum(1 << ord(ch) - ord(\\'a\\') for ch in w)\\n        remove_letter = lambda w: [w] + [w ^ (1 << b) for b in range(26) if w & (1 << b)]\\n        \\n        nb2i = defaultdict(list)\\n        dsu = DSU(len(words))\\n\\n        for i, w in enumerate(words):\\n            for nb in remove_letter(w2num(w)):\\n                nb2i[nb].append(i)\\n\\n        for nb in nb2i:\\n            for j in nb2i[nb]:\\n                dsu.union(nb2i[nb][0], j)\\n\\n        comps = {dsu.find(i) for i in range(len(words))}\\n        mx = max(dsu.sz[c] for c in comps)\\n\\n        return [len(comps), mx]\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import defaultdict\\n\\nclass DSU:\\n    def __init__(self, size):\\n        self.pr = list(range(size))\\n        self.hs = [0] * size\\n        self.sz = [1] * size\\n\\n    def find(self, i):\\n        if self.pr[i] != i:\\n            self.pr[i] = self.find(self.pr[i])\\n        return self.pr[i]\\n\\n    def union(self, i, j):\\n        pi, pj = self.find(i), self.find(j)\\n        if pi == pj: return\\n        if self.hs[pi] < self.hs[pj]:\\n            pi, pj = pj, pi\\n        self.pr[pj] = pi\\n        self.hs[pi] += 1 if self.hs[pi] == self.hs[pj] else 0\\n        self.sz[pi] += self.sz[pj]\\n\\n\\nclass Solution:\\n    def groupStrings(self, words):\\n        w2num = lambda w: sum(1 << ord(ch) - ord(\\'a\\') for ch in w)\\n        remove_letter = lambda w: [w] + [w ^ (1 << b) for b in range(26) if w & (1 << b)]\\n        \\n        nb2i = defaultdict(list)\\n        dsu = DSU(len(words))\\n\\n        for i, w in enumerate(words):\\n            for nb in remove_letter(w2num(w)):\\n                nb2i[nb].append(i)\\n\\n        for nb in nb2i:\\n            for j in nb2i[nb]:\\n                dsu.union(nb2i[nb][0], j)\\n\\n        comps = {dsu.find(i) for i in range(len(words))}\\n        mx = max(dsu.sz[c] for c in comps)\\n\\n        return [len(comps), mx]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1733878,
                "title": "c-920ms-100-i-am-upset-bfs",
                "content": "Runtime: 920 ms, faster than 100.00% of C++ online submissions for Groups of Strings.\\nMemory Usage: 83.4 MB, less than 20.00% of C++ online submissions for Groups of Strings.\\n```\\n#define id it->second.first\\n#define weight it->second.second\\n\\nclass Solution {\\npublic:  \\n  vector<int> groupStrings(vector<string>& words) {\\n    unordered_map<int, pair<int,int> >t;        //mask , <id, val>\\n     \\n    int idx = 0;\\n    for(auto &w: words){\\n      int simple = 0; \\n      for(auto ch : w) simple |= 1<<(ch-\\'a\\');\\n      if(t.count(simple)) t[simple].second++;\\n      else t[simple] = {idx++, 1};\\n    }\\n      \\n    vector<vector<int>> gr(t.size());\\n    vector<int>weights(t.size());\\n    \\n    for(auto it = t.begin(); it != t.end(); it++){\\n      weights[id] = weight;\\n      int W = it->first;\\n      \\n      for(int i = 0, mask = 1; i != 26; i++, mask <<= 1)\\n        if( (W & mask) == 0){\\n          int n = (W | mask);\\n          if(t.count(n)) gr[id].push_back(t[n].first), gr[t[n].first].push_back(id);\\n        }\\n      \\n      for(int i = 0, mask = 1; i != 26; i++, mask <<= 1)\\n        if((W & mask) != 0){\\n          int n = W - mask;\\n          \\n          for(int j = 0, mask2 = 1; j != 26; j++, mask2 <<= 1)\\n            if(j != i && (n & mask2) == 0){\\n              int N = n | mask2;\\n              if(t.count(N)) gr[id].push_back(t[N].first); \\n            }\\n        }\\n    }\\n   \\n    int group = 0, maxi = 0; \\n    \\n    vector<int>vis(t.size(), 0);\\n    \\n    for(int i = 0; i != vis.size(); i++)\\n      if(vis[i] == 0){ \\n        group++;\\n        if(gr[i].empty()) maxi = max(maxi, weights[i]);\\n        else{\\n          queue<int>q;\\n          q.push(i);\\n          int temp = 0;\\n          \\n          while(!q.empty()){\\n            int idx = q.front(); q.pop();\\n            if(vis[idx]) continue;\\n            temp += weights[idx];\\n            vis[idx] = 1;\\n            \\n            for(auto x : gr[idx])\\n              if(vis[x] == 0) q.push(x);\\n          }\\n        \\n          maxi = max(maxi,temp);\\n        }\\n      }\\n    \\n    return {group, maxi};\\n  }\\n};\\n```\\n**When I wrote contest I tried to solve programm as below and have TLE:**\\n**How can it be ???**\\n![image](https://assets.leetcode.com/users/images/f7524e4e-0016-4b51-a6c3-3b9bf2ed9577_1643624373.923043.png)\\n\\n\\nRuntime: 1488 ms, faster than 40.00% of C++ online submissions for Groups of Strings.\\nMemory Usage: 115.9 MB, less than 20.00% of C++ online submissions for Groups of Strings.\\n```\\n#define id it->second.first\\n#define weight it->second.second\\n\\nclass Solution {\\npublic:  \\n  vector<int> groupStrings(vector<string>& words) {\\n    unordered_map<string, pair<int,int> >t;        //mask , id\\n     \\n    int idx = 0;\\n    for(auto &w: words){\\n      string simple(26, \\'#\\'); \\n      for(auto ch : w) simple[ch-\\'a\\'] = \\'1\\';\\n      if(t.count(simple)) t[simple].second++;\\n      else t[simple] = {idx++, 1};\\n    }\\n      \\n    vector<vector<int>> gr(t.size());\\n    vector<int>weights(t.size());\\n    \\n    for(auto it = t.begin(); it != t.end(); it++){\\n      weights[id] = weight;\\n      string W = it->first;\\n      \\n      for(int i = 0; i != 26; i++)\\n        if(W[i] == \\'#\\'){\\n          W.operator[](i) = \\'1\\';\\n          if(t.count(W)) gr[id].push_back(t[W].first), gr[t[W].first].push_back(id);\\n          W[i] = \\'#\\';\\n        }\\n      \\n      for(int i = 0; i != 26; i++)\\n        if(W[i] == \\'1\\'){\\n          W[i] = \\'#\\';\\n          for(int j = 0; j != 26; j++)\\n            if(j != i && W[j]  == \\'#\\'){\\n              W[j] = \\'1\\';\\n              if(t.count(W)) gr[id].push_back(t[W].first); \\n              W[j] = \\'#\\';\\n            }\\n          W[i] = \\'1\\';\\n        }\\n    }\\n   \\n    int group = 0, maxi = 0; \\n    \\n    vector<int>vis(t.size(), 0);\\n    \\n    for(int i = 0; i != vis.size(); i++)\\n      if(vis[i] == 0){ \\n        group++;\\n        if(gr[i].empty()) maxi = max(maxi, weights[i]);\\n        else{\\n          queue<int>q;\\n          q.push(i);\\n          int temp = 0;\\n          \\n          while(!q.empty()){\\n            int idx = q.front(); q.pop();\\n            if(vis[idx]) continue;\\n            temp += weights[idx];\\n            vis[idx] = 1;\\n            \\n            for(auto x : gr[idx])\\n              if(vis[x] == 0) q.push(x);\\n          }\\n        \\n          maxi = max(maxi,temp);\\n        }\\n      }\\n    \\n    return {group, maxi};\\n  }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n#define id it->second.first\\n#define weight it->second.second\\n\\nclass Solution {\\npublic:  \\n  vector<int> groupStrings(vector<string>& words) {\\n    unordered_map<int, pair<int,int> >t;        //mask , <id, val>\\n     \\n    int idx = 0;\\n    for(auto &w: words){\\n      int simple = 0; \\n      for(auto ch : w) simple |= 1<<(ch-\\'a\\');\\n      if(t.count(simple)) t[simple].second++;\\n      else t[simple] = {idx++, 1};\\n    }\\n      \\n    vector<vector<int>> gr(t.size());\\n    vector<int>weights(t.size());\\n    \\n    for(auto it = t.begin(); it != t.end(); it++){\\n      weights[id] = weight;\\n      int W = it->first;\\n      \\n      for(int i = 0, mask = 1; i != 26; i++, mask <<= 1)\\n        if( (W & mask) == 0){\\n          int n = (W | mask);\\n          if(t.count(n)) gr[id].push_back(t[n].first), gr[t[n].first].push_back(id);\\n        }\\n      \\n      for(int i = 0, mask = 1; i != 26; i++, mask <<= 1)\\n        if((W & mask) != 0){\\n          int n = W - mask;\\n          \\n          for(int j = 0, mask2 = 1; j != 26; j++, mask2 <<= 1)\\n            if(j != i && (n & mask2) == 0){\\n              int N = n | mask2;\\n              if(t.count(N)) gr[id].push_back(t[N].first); \\n            }\\n        }\\n    }\\n   \\n    int group = 0, maxi = 0; \\n    \\n    vector<int>vis(t.size(), 0);\\n    \\n    for(int i = 0; i != vis.size(); i++)\\n      if(vis[i] == 0){ \\n        group++;\\n        if(gr[i].empty()) maxi = max(maxi, weights[i]);\\n        else{\\n          queue<int>q;\\n          q.push(i);\\n          int temp = 0;\\n          \\n          while(!q.empty()){\\n            int idx = q.front(); q.pop();\\n            if(vis[idx]) continue;\\n            temp += weights[idx];\\n            vis[idx] = 1;\\n            \\n            for(auto x : gr[idx])\\n              if(vis[x] == 0) q.push(x);\\n          }\\n        \\n          maxi = max(maxi,temp);\\n        }\\n      }\\n    \\n    return {group, maxi};\\n  }\\n};\\n```\n```\\n#define id it->second.first\\n#define weight it->second.second\\n\\nclass Solution {\\npublic:  \\n  vector<int> groupStrings(vector<string>& words) {\\n    unordered_map<string, pair<int,int> >t;        //mask , id\\n     \\n    int idx = 0;\\n    for(auto &w: words){\\n      string simple(26, \\'#\\'); \\n      for(auto ch : w) simple[ch-\\'a\\'] = \\'1\\';\\n      if(t.count(simple)) t[simple].second++;\\n      else t[simple] = {idx++, 1};\\n    }\\n      \\n    vector<vector<int>> gr(t.size());\\n    vector<int>weights(t.size());\\n    \\n    for(auto it = t.begin(); it != t.end(); it++){\\n      weights[id] = weight;\\n      string W = it->first;\\n      \\n      for(int i = 0; i != 26; i++)\\n        if(W[i] == \\'#\\'){\\n          W.operator[](i) = \\'1\\';\\n          if(t.count(W)) gr[id].push_back(t[W].first), gr[t[W].first].push_back(id);\\n          W[i] = \\'#\\';\\n        }\\n      \\n      for(int i = 0; i != 26; i++)\\n        if(W[i] == \\'1\\'){\\n          W[i] = \\'#\\';\\n          for(int j = 0; j != 26; j++)\\n            if(j != i && W[j]  == \\'#\\'){\\n              W[j] = \\'1\\';\\n              if(t.count(W)) gr[id].push_back(t[W].first); \\n              W[j] = \\'#\\';\\n            }\\n          W[i] = \\'1\\';\\n        }\\n    }\\n   \\n    int group = 0, maxi = 0; \\n    \\n    vector<int>vis(t.size(), 0);\\n    \\n    for(int i = 0; i != vis.size(); i++)\\n      if(vis[i] == 0){ \\n        group++;\\n        if(gr[i].empty()) maxi = max(maxi, weights[i]);\\n        else{\\n          queue<int>q;\\n          q.push(i);\\n          int temp = 0;\\n          \\n          while(!q.empty()){\\n            int idx = q.front(); q.pop();\\n            if(vis[idx]) continue;\\n            temp += weights[idx];\\n            vis[idx] = 1;\\n            \\n            for(auto x : gr[idx])\\n              if(vis[x] == 0) q.push(x);\\n          }\\n        \\n          maxi = max(maxi,temp);\\n        }\\n      }\\n    \\n    return {group, maxi};\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1732736,
                "title": "python-uf-bit-manipulation",
                "content": "```\\nclass DSU:\\n    def __init__(self, n):\\n        self.root = [i for i in range(n)]\\n    \\n    def find(self, x):\\n        if self.root[x] != x:\\n            self.root[x] = self.find(self.root[x])\\n        return self.root[x]\\n    \\n    def union(self, x, y):\\n        self.root[self.find(x)] = self.find(y)\\n        \\nclass Solution:\\n    def groupStrings(self, words: List[str]) -> List[int]:\\n        #sort each word and convert them to 26 length bit vector\\n        #use bitmanipulation to find its connected word by add, delete, replace\\n        #also mapping the word vector to its index in original array\\n        #use union find to connect the word index\\n        #mapping the word index to the count of the word, so we can count the duplicated words\\n        #in the end, count all the child node counts for the root node\\n        #return the number of root and the max number of nodes for among all roots\\n        \\n        counts = defaultdict(int)        \\n        idx = {}\\n        \\n        for i, word in enumerate(words):\\n            base = 0\\n            for char in sorted(word):\\n                base += 1 << (ord(char) - ord(\"a\")) \\n            idx[base] = i\\n            counts[base] += 1\\n        \\n        dsu = DSU(len(words))\\n        \\n        for base in idx:\\n            for new in self.add(base):\\n                if new in idx:\\n                    dsu.union(idx[base], idx[new])\\n            for new in self.delete(base):\\n                if new in idx:\\n                    dsu.union(idx[base], idx[new])\\n            for new in self.replace(base):\\n                if new in idx:\\n                    dsu.union(idx[base], idx[new])\\n        \\n        groups = defaultdict(int)\\n        for base, i in idx.items():\\n            groups[dsu.find(i)] += counts[base]\\n            \\n        return [len(groups), max(groups.values())]\\n    \\n    def add(self, base):\\n        for i in range(26):\\n            if not base & 1 << i:\\n                yield base ^ 1 << i\\n    \\n    def delete(self, base):\\n        for i in range(26):\\n            if base & 1 << i and base != 1 << i:\\n                yield base ^ 1 << i\\n    \\n    def replace(self, base):\\n        prev, new = [], []\\n        for i in range(26):\\n            if base & 1 << i:\\n                prev.append(i)\\n            else:\\n                new.append(i)\\n        for i in prev:\\n            for j in new:\\n                yield base ^ (1 << i) ^ (1 << j)\\n                \\n        \\n                \\n\\n                \\n                \\n                \\n                \\n                \\n                \\n                \\n                \\n                \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass DSU:\\n    def __init__(self, n):\\n        self.root = [i for i in range(n)]\\n    \\n    def find(self, x):\\n        if self.root[x] != x:\\n            self.root[x] = self.find(self.root[x])\\n        return self.root[x]\\n    \\n    def union(self, x, y):\\n        self.root[self.find(x)] = self.find(y)\\n        \\nclass Solution:\\n    def groupStrings(self, words: List[str]) -> List[int]:\\n        #sort each word and convert them to 26 length bit vector\\n        #use bitmanipulation to find its connected word by add, delete, replace\\n        #also mapping the word vector to its index in original array\\n        #use union find to connect the word index\\n        #mapping the word index to the count of the word, so we can count the duplicated words\\n        #in the end, count all the child node counts for the root node\\n        #return the number of root and the max number of nodes for among all roots\\n        \\n        counts = defaultdict(int)        \\n        idx = {}\\n        \\n        for i, word in enumerate(words):\\n            base = 0\\n            for char in sorted(word):\\n                base += 1 << (ord(char) - ord(\"a\")) \\n            idx[base] = i\\n            counts[base] += 1\\n        \\n        dsu = DSU(len(words))\\n        \\n        for base in idx:\\n            for new in self.add(base):\\n                if new in idx:\\n                    dsu.union(idx[base], idx[new])\\n            for new in self.delete(base):\\n                if new in idx:\\n                    dsu.union(idx[base], idx[new])\\n            for new in self.replace(base):\\n                if new in idx:\\n                    dsu.union(idx[base], idx[new])\\n        \\n        groups = defaultdict(int)\\n        for base, i in idx.items():\\n            groups[dsu.find(i)] += counts[base]\\n            \\n        return [len(groups), max(groups.values())]\\n    \\n    def add(self, base):\\n        for i in range(26):\\n            if not base & 1 << i:\\n                yield base ^ 1 << i\\n    \\n    def delete(self, base):\\n        for i in range(26):\\n            if base & 1 << i and base != 1 << i:\\n                yield base ^ 1 << i\\n    \\n    def replace(self, base):\\n        prev, new = [], []\\n        for i in range(26):\\n            if base & 1 << i:\\n                prev.append(i)\\n            else:\\n                new.append(i)\\n        for i in prev:\\n            for j in new:\\n                yield base ^ (1 << i) ^ (1 << j)\\n                \\n        \\n                \\n\\n                \\n                \\n                \\n                \\n                \\n                \\n                \\n                \\n                \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1732147,
                "title": "python-3-union-find-bit-mask-build-from-low-to-high-length-string",
                "content": "```\\n# Build high length string from low length string\\n# If we have \\'a\\' then we build \\'ab\\', \\'ac\\', \\'ad\\'... \\'az\\' and store in a map {\\'ab\\': \\'a\\', \\'ac\\': \\'a\\', ...}\\n# So if next we got \\'b\\' when we build to \\'ab\\', we will union with map[\\'ab\\'], which is \\'a\\'\\n# Also if we go to a longer length string, say \\'ab\\' and it\\'s in the map then we will union \\'ab\\' with \\'a\\'\\n\\n\\nclass Solution:\\n    def groupStrings(self, words: List[str]) -> List[int]:\\n        c = defaultdict(int) # Counter\\n        rec_len = defaultdict(list) # Store the bitmask by length\\n        \\n        for word in words:\\n            mask = 0\\n            for w in word:\\n                mask ^= 1 << (ord(w) - ord(\\'a\\'))\\n            c[mask] += 1\\n            rec_len[len(word)].append(mask)\\n        \\n        word_idx = {v: k for k, v in enumerate(set(c))} # encode mask to index\\n        idx_word = dict(enumerate(set(c))) # decode index to mask\\n        loc = list(range(len(word_idx))) # union-find location\\n        size = [c[idx_word[k]] for k in idx_word] # union-find group size\\n\\n        def find(x):\\n            if loc[x] != x:\\n                loc[x] = find(loc[x])\\n            return loc[x]\\n\\n        def union(x, y):\\n            a, b = find(x), find(y)\\n            if a != b:\\n                loc[a] = b\\n                size[b] += size[a]\\n        \\n        added = {} # to store the build strings\\n        for k in sorted(rec_len):\\n\\n            for a in rec_len[k]:\\n                if a in added: union(word_idx[a], word_idx[added[a]])\\n                for j in range(26):\\n                    if a & (1 << j) == 0 and a ^ (1 << j) in added:\\n                        b = added[a ^ (1 << j)]\\n                        union(word_idx[a], word_idx[b])\\n                    added[a ^ (1 << j)] = a    \\n                    \\n        grps = len(set(find(x) for x in range(len(c))))\\n        grp_size = max(size)\\n        return [grps, grp_size]",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Union Find",
                    "Bitmask"
                ],
                "code": "class Solution:\\n    def groupStrings(self, words: List[str]) -> List[int]:\\n        c = defaultdict(int) # Counter\\n        rec_len = defaultdict(list) # Store the bitmask by length\\n        \\n        for word in words:\\n            mask = 0\\n            for w in word:\\n                mask ^= 1 << (ord(w) - ord(\\'a\\'))\\n            c[mask] += 1\\n            rec_len[len(word)].append(mask)\\n        \\n        word_idx = {v: k for k, v in enumerate(set(c))}",
                "codeTag": "Java"
            },
            {
                "id": 1731333,
                "title": "c-bitmask-unionfind-explanation-o-26-n-lg-n",
                "content": "**Explanation**\\nChange each word to a bitmask for faster lookups and string construction\\n\\nFor each bitmask *x*, we will find all its connected bitmasks *y*\\nIf *y* is already in the map, we Union their root parents (and speed up by path-compression).\\n\\nThe tricky part is to find connected bitmasks *y* by any one of the following operations:\\n```\\n- Adding exactly one letter to the set of the letters of s1.\\n- Deleting exactly one letter from the set of the letters of s1.\\n\\t=> Equivalent to shorter string adds exactly one letter\\n\\te.g. abcd, bcd => (remove a) bcd, bcd == abcd, abcd (add a)\\n- Replacing exactly one letter from the set of the letters of s1 with any letter, including itself.\\n\\t=> Equivalent to both string adds exactly one letter\\n\\te.g. abc, acd => abcd, abcd\\n```\\n<br>\\n\\n**Complexity**\\nTime O(26 * n * lg n)\\nSpace O(n)\\n<br>\\n\\n**C++**\\n```c++\\nclass Solution {\\n    vector<int> root;\\n    vector<int> gSize;\\n    int groupCount;\\n    int groupSize;\\n    \\n    void Union(int a, int b){\\n        a = Find(a);\\n        b = Find(b);\\n        if(a == b){\\n            return;\\n        }\\n        gSize[a] += gSize[b];\\n        gSize[b] = 0;\\n        root[b] = a;\\n        // update ans\\n        groupCount--;\\n        groupSize = max(groupSize, gSize[a]);\\n    }\\n    \\n    int Find(int current){\\n        if(root[current] == current){\\n            return current;\\n        }\\n        return root[current] = Find(root[current]);\\n    }\\n    \\n    int toBitMask(string &s){\\n        int ans = 0;\\n        for(char c : s){\\n            ans |= (1 << (c - \\'a\\'));\\n        }\\n        return ans;\\n    }\\n    \\npublic:\\n    vector<int> groupStrings(vector<string>& words) {\\n        int n = words.size();\\n        unordered_map<int, int> toIndex;\\n        \\n        gSize.clear();\\n        gSize.resize(n, 1);\\n        root.resize(n);\\n        for(int i = 0; i < n; i++){\\n            root[i] = i;\\n        }\\n        \\n        groupCount = n;\\n        groupSize = 1;\\n        for(int i = 0; i < n; i++){ // O(N)\\n            int currentFreq = toBitMask(words[i]);\\n            for(int j = 0; j < 26; j++){ // O(26)\\n                int temp = currentFreq | (1 << j);\\n                if(toIndex.find(temp) != toIndex.end()){\\n                    Union(i, toIndex[temp]); // O(lg N)\\n                }\\n                toIndex[ temp ] = i;\\n            }\\n        }\\n        \\n        return {groupCount, groupSize};\\n    }\\n};\\n```\\n<br>\\n\\n**Reference**\\nhttps://cs.stackexchange.com/questions/48649/complexity-of-union-find-with-path-compression-without-rank\\n\\n<br>",
                "solutionTags": [
                    "C",
                    "Union Find",
                    "Bitmask"
                ],
                "code": "```\\n- Adding exactly one letter to the set of the letters of s1.\\n- Deleting exactly one letter from the set of the letters of s1.\\n\\t=> Equivalent to shorter string adds exactly one letter\\n\\te.g. abcd, bcd => (remove a) bcd, bcd == abcd, abcd (add a)\\n- Replacing exactly one letter from the set of the letters of s1 with any letter, including itself.\\n\\t=> Equivalent to both string adds exactly one letter\\n\\te.g. abc, acd => abcd, abcd\\n```\n```c++\\nclass Solution {\\n    vector<int> root;\\n    vector<int> gSize;\\n    int groupCount;\\n    int groupSize;\\n    \\n    void Union(int a, int b){\\n        a = Find(a);\\n        b = Find(b);\\n        if(a == b){\\n            return;\\n        }\\n        gSize[a] += gSize[b];\\n        gSize[b] = 0;\\n        root[b] = a;\\n        // update ans\\n        groupCount--;\\n        groupSize = max(groupSize, gSize[a]);\\n    }\\n    \\n    int Find(int current){\\n        if(root[current] == current){\\n            return current;\\n        }\\n        return root[current] = Find(root[current]);\\n    }\\n    \\n    int toBitMask(string &s){\\n        int ans = 0;\\n        for(char c : s){\\n            ans |= (1 << (c - \\'a\\'));\\n        }\\n        return ans;\\n    }\\n    \\npublic:\\n    vector<int> groupStrings(vector<string>& words) {\\n        int n = words.size();\\n        unordered_map<int, int> toIndex;\\n        \\n        gSize.clear();\\n        gSize.resize(n, 1);\\n        root.resize(n);\\n        for(int i = 0; i < n; i++){\\n            root[i] = i;\\n        }\\n        \\n        groupCount = n;\\n        groupSize = 1;\\n        for(int i = 0; i < n; i++){ // O(N)\\n            int currentFreq = toBitMask(words[i]);\\n            for(int j = 0; j < 26; j++){ // O(26)\\n                int temp = currentFreq | (1 << j);\\n                if(toIndex.find(temp) != toIndex.end()){\\n                    Union(i, toIndex[temp]); // O(lg N)\\n                }\\n                toIndex[ temp ] = i;\\n            }\\n        }\\n        \\n        return {groupCount, groupSize};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1730907,
                "title": "sort-union-find-hash-table-100-fast-python",
                "content": "The solution II with bit manipulation is essentially based on solution I. Reading solution I helps to understand the algorithm.\\n# Solution I: Union find, Hash Table, String\\n\\nSort the words according to the lengths. Rebuild each word by sorting the letters. Maintain a Hash Table. Traverse the words. For the current word, if it, or its modified version with any of its letter removed, exist in the Hash Table, retrieve the index stored in the Hash Table, and union that index and the current index. Also store the current index under the word and every its modified versions. At the end, count the number of groups in the set of parents and find the max group.\\n\\n```\\nclass Solution:\\n    def groupStrings(self, words: List[str]) -> List[int]:\\n        parent, size = {}, {}\\n\\n        def find(x: int) -> int:\\n            if parent[x] == x:\\n                return x\\n            else:\\n                parent[x] = find(parent[x])\\n                return parent[x]\\n\\n        def union(x: int, y: int):\\n            x, y = find(x), find(y)\\n            if x == y:\\n                return\\n            if size[x] < size[y]:\\n                x, y = y, x\\n            size[x] += size[y]\\n            parent[y] = x\\n            return\\n\\t\\t\\t\\n\\t\\t#------------- also see solution II -------------\\n        words = [\"\".join(sorted(w)) for w in sorted(words, key=len)]\\n        mp = defaultdict(int)\\n        for i, s in enumerate(words):\\n            parent[i], size[i] = i, 1\\n\\n            for j in range(len(s)+1):\\n                ss = s[:j] + s[j+1:]\\n                if ss in mp:\\n                    union(i, mp[ss])\\n                else:\\n                    mp[ss] = i\\n\\t\\t#--------------------------\\n\\t\\t\\n        mx, seen = 0, set()\\n        for z in parent:\\n            p = find(z)\\n            if p not in seen:\\n                seen.add(p)\\n                mx = max(mx, size[p])\\n        return [len(seen), mx]\\n```\\n\\n# Solution II: Union find, Hash Table, Bit manipulation\\n\\nThis solution is based on the same idea. The only difference is that we replace the string processing by bit manipulation. Basically, we map each letter to a bit. \\n\\n```\\n        bits, a = [], ord(\"a\")\\n        for w in sorted(words, key=len):\\n            bit = 0\\n            for c in sorted(w):\\n                bit |= 1 << ord(c)-a\\n            bits.append(bit)\\n\\t\\t\\t\\n        mp = defaultdict(int)\\n        for i, b in enumerate(bits):\\n            parent[i], size[i] = i, 1\\n            mask = 1\\n            while True:\\n                v = b ^ (b & mask)\\n                if v in mp:\\n                    union(i, mp[v])\\n                else:\\n                    mp[v] = i\\n                if mask > b:\\n                    break\\n                mask <<= 1\\n```",
                "solutionTags": [
                    "Python",
                    "Hash Table",
                    "Bit Manipulation",
                    "Union Find",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def groupStrings(self, words: List[str]) -> List[int]:\\n        parent, size = {}, {}\\n\\n        def find(x: int) -> int:\\n            if parent[x] == x:\\n                return x\\n            else:\\n                parent[x] = find(parent[x])\\n                return parent[x]\\n\\n        def union(x: int, y: int):\\n            x, y = find(x), find(y)\\n            if x == y:\\n                return\\n            if size[x] < size[y]:\\n                x, y = y, x\\n            size[x] += size[y]\\n            parent[y] = x\\n            return\\n\\t\\t\\t\\n\\t\\t#------------- also see solution II -------------\\n        words = [\"\".join(sorted(w)) for w in sorted(words, key=len)]\\n        mp = defaultdict(int)\\n        for i, s in enumerate(words):\\n            parent[i], size[i] = i, 1\\n\\n            for j in range(len(s)+1):\\n                ss = s[:j] + s[j+1:]\\n                if ss in mp:\\n                    union(i, mp[ss])\\n                else:\\n                    mp[ss] = i\\n\\t\\t#--------------------------\\n\\t\\t\\n        mx, seen = 0, set()\\n        for z in parent:\\n            p = find(z)\\n            if p not in seen:\\n                seen.add(p)\\n                mx = max(mx, size[p])\\n        return [len(seen), mx]\\n```\n```\\n        bits, a = [], ord(\"a\")\\n        for w in sorted(words, key=len):\\n            bit = 0\\n            for c in sorted(w):\\n                bit |= 1 << ord(c)-a\\n            bits.append(bit)\\n\\t\\t\\t\\n        mp = defaultdict(int)\\n        for i, b in enumerate(bits):\\n            parent[i], size[i] = i, 1\\n            mask = 1\\n            while True:\\n                v = b ^ (b & mask)\\n                if v in mp:\\n                    union(i, mp[v])\\n                else:\\n                    mp[v] = i\\n                if mask > b:\\n                    break\\n                mask <<= 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1730765,
                "title": "for-tle-you-can-try-this-can-optimize-little-bit",
                "content": "```\\nif dupticate occured already then simply Union it and continue;\\ndon\\'t check further because we have already checked.\\n ```",
                "solutionTags": [],
                "code": "```\\nif dupticate occured already then simply Union it and continue;\\ndon\\'t check further because we have already checked.\\n ```",
                "codeTag": "Unknown"
            },
            {
                "id": 1730748,
                "title": "c-100-faster-complicated-not-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int find(vector<int>& parent,int i){\\n        if(parent[i]==i) return i;\\n        \\n        return parent[i]=find(parent,parent[i]);\\n    }\\n    \\n    \\n    vector<int> groupStrings(vector<string>& words) {\\n        \\n        int n=words.size();\\n        \\n        unordered_map<int,int>  freq;\\n        unordered_map<int,int>  id;\\n        vector<int> val(n);\\n        int j=0;\\n        \\n        for(int i=0;i<n;i++){\\n            \\n            int mask=0;\\n            \\n            for(char ch:words[i]){\\n                 mask=mask|((1<<(ch-\\'a\\')));\\n            }\\n            if(id.find(mask)==id.end()) id[mask]=j++;\\n            \\n            freq[mask]++;\\n            val[i]=mask;\\n        }\\n       \\n        \\n        vector<int> parent(freq.size());\\n        for(int i=0;i<freq.size();i++) parent[i]=i;\\n        \\n        \\n        for(auto i:freq){\\n            \\n            int mask=i.first;\\n             \\n            int x=find(parent,id[mask]);\\n            \\n            for(int j=0;j<26;j++){\\n               if(mask&(1<<j)){\\n                   int nmask=mask;\\n                   nmask=nmask^(1<<j);\\n                   for(int k=0;k<26;k++){\\n                       int nnmask=nmask|(1<<k);\\n                         if(freq.find(nnmask)!=freq.end() )\\n                         {int y=find(parent,id[nnmask]);\\n                             parent[y]=x;}\\n                        \\n                       \\n                   }\\n                   \\n               } \\n            }\\n            \\n             \\n        }\\n        \\n        int ans=0;\\n        unordered_map<int,int> mp;\\n        \\n        for(auto i:freq){\\n            int mask=i.first;\\n            \\n            int grp=find(parent,id[mask]);\\n            \\n            mp[grp]=mp[grp] + freq[mask];\\n            \\n            ans=max(ans,mp[grp]);\\n        }\\n        \\n        int k=mp.size();\\n      \\n        return {k,ans};\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int find(vector<int>& parent,int i){\\n        if(parent[i]==i) return i;\\n        \\n        return parent[i]=find(parent,parent[i]);\\n    }\\n    \\n    \\n    vector<int> groupStrings(vector<string>& words) {\\n        \\n        int n=words.size();\\n        \\n        unordered_map<int,int>  freq;\\n        unordered_map<int,int>  id;\\n        vector<int> val(n);\\n        int j=0;\\n        \\n        for(int i=0;i<n;i++){\\n            \\n            int mask=0;\\n            \\n            for(char ch:words[i]){\\n                 mask=mask|((1<<(ch-\\'a\\')));\\n            }\\n            if(id.find(mask)==id.end()) id[mask]=j++;\\n            \\n            freq[mask]++;\\n            val[i]=mask;\\n        }\\n       \\n        \\n        vector<int> parent(freq.size());\\n        for(int i=0;i<freq.size();i++) parent[i]=i;\\n        \\n        \\n        for(auto i:freq){\\n            \\n            int mask=i.first;\\n             \\n            int x=find(parent,id[mask]);\\n            \\n            for(int j=0;j<26;j++){\\n               if(mask&(1<<j)){\\n                   int nmask=mask;\\n                   nmask=nmask^(1<<j);\\n                   for(int k=0;k<26;k++){\\n                       int nnmask=nmask|(1<<k);\\n                         if(freq.find(nnmask)!=freq.end() )\\n                         {int y=find(parent,id[nnmask]);\\n                             parent[y]=x;}\\n                        \\n                       \\n                   }\\n                   \\n               } \\n            }\\n            \\n             \\n        }\\n        \\n        int ans=0;\\n        unordered_map<int,int> mp;\\n        \\n        for(auto i:freq){\\n            int mask=i.first;\\n            \\n            int grp=find(parent,id[mask]);\\n            \\n            mp[grp]=mp[grp] + freq[mask];\\n            \\n            ans=max(ans,mp[grp]);\\n        }\\n        \\n        int k=mp.size();\\n      \\n        return {k,ans};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1730516,
                "title": "c-why-is-this-tle-o-n-26",
                "content": "I submitted this during the contest but it would give TLE, it does accept sometimes, but so sad. Could anyone clarify this?\\n```\\nclass Solution {\\npublic:\\n    unordered_map <int, int> p;\\n    vector <int> f, cnt;\\n    int find(int x) {\\n        if (f[x] != x)\\n            f[x] = find(f[x]);\\n        return f[x];\\n    }\\n    void unify(int x, int y) {\\n        x = find(x);\\n        y = find(y);\\n        if (x != y) {\\n            if (cnt[x] < cnt[y]) {\\n                f[x] = y;\\n                cnt[y] += cnt[x];\\n            }\\n            else {\\n                f[y] = x;\\n                cnt[x] += cnt[y];\\n            }\\n        }\\n    }\\n    vector<int> groupStrings(vector<string>& a) {\\n        // 2 * 10^4 \\n        // uf replacing is an issue ? 26^2\\n        // connected by # 27th element\\n        // okay how to count?\\n        // convert first\\n        int n = a.size();\\n        vector <int> b(n, 0);\\n        int k = 0;\\n        for (int i = 0; i < n; i++) {\\n            auto &z = a[i];\\n            int x = 0;\\n            for (auto &zz : z)\\n                x |= (1 << (zz - \\'a\\')); // convert\\n            b[i] = x;\\n            if (p.find(x) == p.end()) { \\n                f.push_back(k);\\n                cnt.push_back(1);\\n                p[x] = k++;\\n            }\\n            else {\\n                int y = p[x];\\n                f[y] = y;\\n                cnt[y] += 1;\\n            }\\n        }\\n        \\n        // converted xD\\n        for (auto &x : b) {\\n            for (int j = 0; j < 26; j++) {\\n                int y = x ^ (1 << j); // add or del\\n                int zx = p[x];\\n                if (p.find(y) != p.end())\\n                    unify(zx, p[y]);\\n                if (x & (1 << j)) {\\n                    int y = x ^ (1 << j) ^ (1 << 26); // remove and add #\\n                    if (p.find(y) == p.end()) {\\n                        f.push_back(k); // is this why it\\'s slow?\\n                        cnt.push_back(0);\\n                        p[y] = k++;\\n                    }\\n                    unify(zx, p[y]);\\n                }\\n            }\\n        }\\n        unordered_set <int> s;\\n        int ret = 0;\\n        for (auto &x : b) {\\n            int y = find(p[x]);\\n            s.insert(y);\\n            ret = max(ret, cnt[y]);\\n        }\\n        return {(int)s.size(), ret};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation",
                    "Union Find",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map <int, int> p;\\n    vector <int> f, cnt;\\n    int find(int x) {\\n        if (f[x] != x)\\n            f[x] = find(f[x]);\\n        return f[x];\\n    }\\n    void unify(int x, int y) {\\n        x = find(x);\\n        y = find(y);\\n        if (x != y) {\\n            if (cnt[x] < cnt[y]) {\\n                f[x] = y;\\n                cnt[y] += cnt[x];\\n            }\\n            else {\\n                f[y] = x;\\n                cnt[x] += cnt[y];\\n            }\\n        }\\n    }\\n    vector<int> groupStrings(vector<string>& a) {\\n        // 2 * 10^4 \\n        // uf replacing is an issue ? 26^2\\n        // connected by # 27th element\\n        // okay how to count?\\n        // convert first\\n        int n = a.size();\\n        vector <int> b(n, 0);\\n        int k = 0;\\n        for (int i = 0; i < n; i++) {\\n            auto &z = a[i];\\n            int x = 0;\\n            for (auto &zz : z)\\n                x |= (1 << (zz - \\'a\\')); // convert\\n            b[i] = x;\\n            if (p.find(x) == p.end()) { \\n                f.push_back(k);\\n                cnt.push_back(1);\\n                p[x] = k++;\\n            }\\n            else {\\n                int y = p[x];\\n                f[y] = y;\\n                cnt[y] += 1;\\n            }\\n        }\\n        \\n        // converted xD\\n        for (auto &x : b) {\\n            for (int j = 0; j < 26; j++) {\\n                int y = x ^ (1 << j); // add or del\\n                int zx = p[x];\\n                if (p.find(y) != p.end())\\n                    unify(zx, p[y]);\\n                if (x & (1 << j)) {\\n                    int y = x ^ (1 << j) ^ (1 << 26); // remove and add #\\n                    if (p.find(y) == p.end()) {\\n                        f.push_back(k); // is this why it\\'s slow?\\n                        cnt.push_back(0);\\n                        p[y] = k++;\\n                    }\\n                    unify(zx, p[y]);\\n                }\\n            }\\n        }\\n        unordered_set <int> s;\\n        int ret = 0;\\n        for (auto &x : b) {\\n            int y = find(p[x]);\\n            s.insert(y);\\n            ret = max(ret, cnt[y]);\\n        }\\n        return {(int)s.size(), ret};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1730280,
                "title": "c-bitmask-and-unordered-map",
                "content": "```\\nclass Solution {\\nprivate:    \\n    int numStr(string &word) {\\n        int num = 0;\\n        for (char ch: word) \\n            num |= 1 << (ch - \\'a\\');\\n        return num;\\n    }        \\npublic:\\n    vector<int> groupStrings(vector<string>& words) {                     \\n        unordered_map<int, int> numMap;        \\n        for (string &word: words)\\n            ++numMap[numStr(word)];\\n        \\n        int maxSet = 0, groups;        \\n        for (groups=0; !numMap.empty(); ++groups) {            \\n            int head = numMap.begin()->first, count = numMap.begin()->second;\\n            numMap.erase(numMap.begin());\\n            queue<pair<int, int>> bfsQueue;\\n            bfsQueue.push({head, count});\\n                \\n            int size = 0;\\n            while (!bfsQueue.empty()) {\\n                auto curr = bfsQueue.front();   bfsQueue.pop();\\n                size += curr.second;\\n                int currNum = curr.first;\\n                \\n\\t\\t\\t\\t// enumerate all the possibilities of erase 1 bit\\n                for (int bit=0; bit<26; ++bit) {\\n                    int neighbor = currNum | (1 << bit);\\n                    if (numMap.count(neighbor) != 0) {\\n                        bfsQueue.push({neighbor, numMap[neighbor]});\\n                        numMap.erase(neighbor);\\n                    }                        \\n                }\\n                \\n\\t\\t\\t\\t// enumerate all the possibilities of add 1 bit\\n                for (int bit=0; bit<26; ++bit) {\\n                    int neighbor = currNum & (~(1 << bit));\\n                    if (numMap.count(neighbor) != 0) {\\n                        bfsQueue.push({neighbor, numMap[neighbor]});\\n                        numMap.erase(neighbor);\\n                    }                        \\n                }\\n                \\n\\t\\t\\t\\t// enumerate all the possibilities of replace 1 letter\\n                for (int bit=0; bit<26; ++bit) {\\n                    if ((currNum & (1 << bit)) == 0)\\n                        continue;\\n                    int neighbor = currNum & (~(1 << bit));\\n                    \\n                    for (int j=0; j<26; ++j) {\\n                        int n = neighbor | (1 << j);\\n                        if (numMap.count(n) != 0) {\\n                            bfsQueue.push({n, numMap[n]});\\n                            numMap.erase(n);\\n                        }\\n                    }                                                                                     \\n                }\\n            }\\n            \\n            maxSet = max(maxSet, size);\\n        }       \\n        \\n        return {groups, maxSet};        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Bit Manipulation",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\nprivate:    \\n    int numStr(string &word) {\\n        int num = 0;\\n        for (char ch: word) \\n            num |= 1 << (ch - \\'a\\');\\n        return num;\\n    }        \\npublic:\\n    vector<int> groupStrings(vector<string>& words) {                     \\n        unordered_map<int, int> numMap;        \\n        for (string &word: words)\\n            ++numMap[numStr(word)];\\n        \\n        int maxSet = 0, groups;        \\n        for (groups=0; !numMap.empty(); ++groups) {            \\n            int head = numMap.begin()->first, count = numMap.begin()->second;\\n            numMap.erase(numMap.begin());\\n            queue<pair<int, int>> bfsQueue;\\n            bfsQueue.push({head, count});\\n                \\n            int size = 0;\\n            while (!bfsQueue.empty()) {\\n                auto curr = bfsQueue.front();   bfsQueue.pop();\\n                size += curr.second;\\n                int currNum = curr.first;\\n                \\n\\t\\t\\t\\t// enumerate all the possibilities of erase 1 bit\\n                for (int bit=0; bit<26; ++bit) {\\n                    int neighbor = currNum | (1 << bit);\\n                    if (numMap.count(neighbor) != 0) {\\n                        bfsQueue.push({neighbor, numMap[neighbor]});\\n                        numMap.erase(neighbor);\\n                    }                        \\n                }\\n                \\n\\t\\t\\t\\t// enumerate all the possibilities of add 1 bit\\n                for (int bit=0; bit<26; ++bit) {\\n                    int neighbor = currNum & (~(1 << bit));\\n                    if (numMap.count(neighbor) != 0) {\\n                        bfsQueue.push({neighbor, numMap[neighbor]});\\n                        numMap.erase(neighbor);\\n                    }                        \\n                }\\n                \\n\\t\\t\\t\\t// enumerate all the possibilities of replace 1 letter\\n                for (int bit=0; bit<26; ++bit) {\\n                    if ((currNum & (1 << bit)) == 0)\\n                        continue;\\n                    int neighbor = currNum & (~(1 << bit));\\n                    \\n                    for (int j=0; j<26; ++j) {\\n                        int n = neighbor | (1 << j);\\n                        if (numMap.count(n) != 0) {\\n                            bfsQueue.push({n, numMap[n]});\\n                            numMap.erase(n);\\n                        }\\n                    }                                                                                     \\n                }\\n            }\\n            \\n            maxSet = max(maxSet, size);\\n        }       \\n        \\n        return {groups, maxSet};        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3994235,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass UnionFind {\\n public:\\n  UnionFind(int n) : count(n), id(n), sz(n, 1) {\\n    iota(id.begin(), id.end(), 0);\\n  }\\n\\n  void unionBySize(int u, int v) {\\n    const int i = find(u);\\n    const int j = find(v);\\n    if (i == j)\\n      return;\\n    if (sz[i] < sz[j]) {\\n      sz[j] += sz[i];\\n      id[i] = j;\\n    } else {\\n      sz[i] += sz[j];\\n      id[j] = i;\\n    }\\n    --count;\\n  }\\n\\n  int getCount() const {\\n    return count;\\n  }\\n\\n  int getMaxSize() const {\\n    return *max_element(sz.begin(), sz.end());\\n  }\\n\\n private:\\n  int count;\\n  vector<int> id;\\n  vector<int> sz;\\n\\n  int find(int u) {\\n    return id[u] == u ? u : id[u] = find(id[u]);\\n  }\\n};\\n\\nclass Solution {\\n public:\\n  vector<int> groupStrings(vector<string>& words) {\\n    UnionFind uf(words.size());\\n    unordered_map<int, int> maskToIndex;\\n    unordered_map<int, int> deletedMaskToIndex;\\n\\n    for (int i = 0; i < words.size(); ++i) {\\n      const int mask = getMask(words[i]);\\n      for (int j = 0; j < 26; ++j)\\n        if (mask >> j & 1) {\\n          // Going to delete this bit.\\n          const int m = mask ^ 1 << j;\\n          if (const auto it = maskToIndex.find(m); it != maskToIndex.cend())\\n            uf.unionBySize(i, it->second);\\n          if (const auto it = deletedMaskToIndex.find(m);\\n              it != deletedMaskToIndex.cend())\\n            uf.unionBySize(i, it->second);\\n          else\\n            deletedMaskToIndex[m] = i;\\n        } else {\\n          // Going to add this bit.\\n          const int m = mask | 1 << j;\\n          if (const auto it = maskToIndex.find(m); it != maskToIndex.cend())\\n            uf.unionBySize(i, it->second);\\n        }\\n      maskToIndex[mask] = i;\\n    }\\n\\n    return {uf.getCount(), uf.getMaxSize()};\\n  }\\n\\n private:\\n  int getMask(const string& s) {\\n    int mask = 0;\\n    for (const char c : s)\\n      mask |= 1 << c - \\'a\\';\\n    return mask;\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass UnionFind {\\n public:\\n  UnionFind(int n) : count(n), id(n), sz(n, 1) {\\n    iota(id.begin(), id.end(), 0);\\n  }\\n\\n  void unionBySize(int u, int v) {\\n    const int i = find(u);\\n    const int j = find(v);\\n    if (i == j)\\n      return;\\n    if (sz[i] < sz[j]) {\\n      sz[j] += sz[i];\\n      id[i] = j;\\n    } else {\\n      sz[i] += sz[j];\\n      id[j] = i;\\n    }\\n    --count;\\n  }\\n\\n  int getCount() const {\\n    return count;\\n  }\\n\\n  int getMaxSize() const {\\n    return *max_element(sz.begin(), sz.end());\\n  }\\n\\n private:\\n  int count;\\n  vector<int> id;\\n  vector<int> sz;\\n\\n  int find(int u) {\\n    return id[u] == u ? u : id[u] = find(id[u]);\\n  }\\n};\\n\\nclass Solution {\\n public:\\n  vector<int> groupStrings(vector<string>& words) {\\n    UnionFind uf(words.size());\\n    unordered_map<int, int> maskToIndex;\\n    unordered_map<int, int> deletedMaskToIndex;\\n\\n    for (int i = 0; i < words.size(); ++i) {\\n      const int mask = getMask(words[i]);\\n      for (int j = 0; j < 26; ++j)\\n        if (mask >> j & 1) {\\n          // Going to delete this bit.\\n          const int m = mask ^ 1 << j;\\n          if (const auto it = maskToIndex.find(m); it != maskToIndex.cend())\\n            uf.unionBySize(i, it->second);\\n          if (const auto it = deletedMaskToIndex.find(m);\\n              it != deletedMaskToIndex.cend())\\n            uf.unionBySize(i, it->second);\\n          else\\n            deletedMaskToIndex[m] = i;\\n        } else {\\n          // Going to add this bit.\\n          const int m = mask | 1 << j;\\n          if (const auto it = maskToIndex.find(m); it != maskToIndex.cend())\\n            uf.unionBySize(i, it->second);\\n        }\\n      maskToIndex[mask] = i;\\n    }\\n\\n    return {uf.getCount(), uf.getMaxSize()};\\n  }\\n\\n private:\\n  int getMask(const string& s) {\\n    int mask = 0;\\n    for (const char c : s)\\n      mask |= 1 << c - \\'a\\';\\n    return mask;\\n  }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3980137,
                "title": "dsu-with-bitmask-of-words",
                "content": "```\\nfrom collections import defaultdict, Counter\\n\\nclass DSU:\\n    def __init__(self):\\n        self.parent = defaultdict(lambda: -1)\\n        self.size = defaultdict(lambda: 1)\\n        \\n    def find(self, a):\\n        if self.parent[a] == -1:\\n            return a\\n        self.parent[a] = self.find(self.parent[a])\\n        return self.parent[a]\\n        \\n    def union(self, a, b):\\n        parent_a = self.find(a)\\n        parent_b = self.find(b)\\n        if parent_a != parent_b:\\n            if self.size[parent_a] < self.size[parent_b]:\\n                parent_a, parent_b = parent_b, parent_a\\n            self.parent[parent_b] = parent_a\\n            self.size[parent_a] += self.size[parent_b]\\n\\nclass Solution:\\n    def groupStrings(self, words: List[str]) -> List[int]:\\n        dsu = DSU()\\n        seen = Counter()\\n        for w in words:\\n            curr = 0\\n            for c in w:\\n                c = ord(c) - ord(\\'a\\')\\n                curr |= 1 << c\\n            seen[curr] += 1\\n        for curr in seen:\\n            for c in range(26):\\n                if not curr & (1 << c):\\n                    if curr | (1 << c) in seen:\\n                        dsu.union(curr, curr | (1 << c))\\n                else:\\n                    without = curr & ~(1 << c)\\n                    if without in seen:\\n                        dsu.union(curr, without)\\n                    for cc in range(26):\\n                        if without | (1 << cc) in seen:\\n                            dsu.union(curr, without | (1 << cc))\\n        comps = defaultdict(int)\\n        for el in dsu.parent:\\n            comps[dsu.find(el)] += seen[el]\\n        return [len(comps), max(comps.values())]\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import defaultdict, Counter\\n\\nclass DSU:\\n    def __init__(self):\\n        self.parent = defaultdict(lambda: -1)\\n        self.size = defaultdict(lambda: 1)\\n        \\n    def find(self, a):\\n        if self.parent[a] == -1:\\n            return a\\n        self.parent[a] = self.find(self.parent[a])\\n        return self.parent[a]\\n        \\n    def union(self, a, b):\\n        parent_a = self.find(a)\\n        parent_b = self.find(b)\\n        if parent_a != parent_b:\\n            if self.size[parent_a] < self.size[parent_b]:\\n                parent_a, parent_b = parent_b, parent_a\\n            self.parent[parent_b] = parent_a\\n            self.size[parent_a] += self.size[parent_b]\\n\\nclass Solution:\\n    def groupStrings(self, words: List[str]) -> List[int]:\\n        dsu = DSU()\\n        seen = Counter()\\n        for w in words:\\n            curr = 0\\n            for c in w:\\n                c = ord(c) - ord(\\'a\\')\\n                curr |= 1 << c\\n            seen[curr] += 1\\n        for curr in seen:\\n            for c in range(26):\\n                if not curr & (1 << c):\\n                    if curr | (1 << c) in seen:\\n                        dsu.union(curr, curr | (1 << c))\\n                else:\\n                    without = curr & ~(1 << c)\\n                    if without in seen:\\n                        dsu.union(curr, without)\\n                    for cc in range(26):\\n                        if without | (1 << cc) in seen:\\n                            dsu.union(curr, without | (1 << cc))\\n        comps = defaultdict(int)\\n        for el in dsu.parent:\\n            comps[dsu.find(el)] += seen[el]\\n        return [len(comps), max(comps.values())]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3944170,
                "title": "union-find-disjoint-sets-and-bit-mask-fastest-and-memory-efficient",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#include <cmath>\\nclass Solution {\\npublic:\\n\\n    int find(int a ,vector <int>&parent){\\n        if(parent[a] != a)parent[a] = find(parent[a] , parent);\\n        return parent[a];\\n    }\\n\\n    void union_(int a , int b ,int &groups , int &maxi, vector <int>&parent , vector <int>&rank, vector <int>&size){\\n        int roota = find(a , parent);\\n        int rootb = find(b , parent);\\n        if(roota!=rootb){\\n            groups--;\\n            if(rank[roota] > rank[rootb]){\\n                parent[rootb] = roota;\\n                size[roota] +=size[rootb];\\n            }\\n            else{\\n                parent[roota] = rootb;\\n                if(rank[roota] == rank[rootb])rank[rootb]++;\\n                size[rootb] += size[roota];\\n            }\\n            maxi = max(maxi , max(size[rootb],size[roota]));\\n        }\\n    }\\n\\n    static bool compareBySize(string&a , string &b){return a.size()<b.size();}\\n\\n    vector<int> groupStrings(vector<string>& words) {\\n        int n = words.size();\\n        int groups = n;\\n        int maxi = 1;\\n        unordered_map <int ,int>myMap;\\n        myMap.reserve(n);\\n        vector <int>parent(n);\\n        vector<int>rank(n,0);\\n        vector<int>size(n,1);\\n        sort(words.begin(), words.end() , compareBySize);\\n        int mask , rep , del;\\n        for(int i=0;i<n;i++){\\n            parent[i] = i;\\n            mask = 0;\\n            for(char ch :words[i]){mask|=(1<<(ch-\\'a\\'));}\\n            for(char ch : words[i]){\\n                del = mask^(1<<(ch-\\'a\\'));\\n                if(myMap.find(del) != myMap.end()){\\n                    union_(i , myMap[del],groups ,maxi ,parent , rank , size);\\n                }\\n                for(int j=0;j<26;j++){\\n                    if((del&(1<<j))==0){\\n                        rep = del | (1<<j);\\n                        if(myMap.find(rep) != myMap.end()){\\n                            union_(i , myMap[rep],groups ,maxi ,parent , rank , size);\\n                        }\\n                    }\\n                }\\n            }\\n            myMap[mask] = i;\\n        }\\n        vector <int> ans = {groups , maxi};\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include <cmath>\\nclass Solution {\\npublic:\\n\\n    int find(int a ,vector <int>&parent){\\n        if(parent[a] != a)parent[a] = find(parent[a] , parent);\\n        return parent[a];\\n    }\\n\\n    void union_(int a , int b ,int &groups , int &maxi, vector <int>&parent , vector <int>&rank, vector <int>&size){\\n        int roota = find(a , parent);\\n        int rootb = find(b , parent);\\n        if(roota!=rootb){\\n            groups--;\\n            if(rank[roota] > rank[rootb]){\\n                parent[rootb] = roota;\\n                size[roota] +=size[rootb];\\n            }\\n            else{\\n                parent[roota] = rootb;\\n                if(rank[roota] == rank[rootb])rank[rootb]++;\\n                size[rootb] += size[roota];\\n            }\\n            maxi = max(maxi , max(size[rootb],size[roota]));\\n        }\\n    }\\n\\n    static bool compareBySize(string&a , string &b){return a.size()<b.size();}\\n\\n    vector<int> groupStrings(vector<string>& words) {\\n        int n = words.size();\\n        int groups = n;\\n        int maxi = 1;\\n        unordered_map <int ,int>myMap;\\n        myMap.reserve(n);\\n        vector <int>parent(n);\\n        vector<int>rank(n,0);\\n        vector<int>size(n,1);\\n        sort(words.begin(), words.end() , compareBySize);\\n        int mask , rep , del;\\n        for(int i=0;i<n;i++){\\n            parent[i] = i;\\n            mask = 0;\\n            for(char ch :words[i]){mask|=(1<<(ch-\\'a\\'));}\\n            for(char ch : words[i]){\\n                del = mask^(1<<(ch-\\'a\\'));\\n                if(myMap.find(del) != myMap.end()){\\n                    union_(i , myMap[del],groups ,maxi ,parent , rank , size);\\n                }\\n                for(int j=0;j<26;j++){\\n                    if((del&(1<<j))==0){\\n                        rep = del | (1<<j);\\n                        if(myMap.find(rep) != myMap.end()){\\n                            union_(i , myMap[rep],groups ,maxi ,parent , rank , size);\\n                        }\\n                    }\\n                }\\n            }\\n            myMap[mask] = i;\\n        }\\n        vector <int> ans = {groups , maxi};\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3938621,
                "title": "python3-union-find-bitmask-beats-97-83",
                "content": "# Intuition\\nUsing an out of range mask (`SIMILAR_MASK`) to detect when we can replace one word to get another is copied from https://leetcode.com/problems/groups-of-strings/solutions/1732959/python3-union-find/\\n\\n# Complexity\\n- Time complexity:\\n $$O(n*s*alphabetSize*Ackermann(n))$$\\nwhere `n = len(words)`, `s = max(len(s) for s in words)`, `alphabetSize = 26`\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nSIMILAR_MASK = 1 << 26\\nCHAR_MASKS = {char: 1 << i for i, char in enumerate(string.ascii_lowercase)}\\nget_bits = lambda word: functools.reduce(\\n    operator.or_, (CHAR_MASKS[char] for char in word)\\n)\\n\\n\\nclass Solution:\\n    def groupStrings(self, words: List[str]) -> List[int]:\\n        max_size = 1\\n        num_groups = len(words)\\n        disjoint_set = list(range(num_groups + 1))\\n        sizes = [1] * (num_groups + 1)\\n\\n        def find(i):\\n            while (parent := disjoint_set[i]) != i:\\n                disjoint_set[i] = disjoint_set[parent]\\n                i = parent\\n            return parent\\n\\n        def union(i, j):\\n            nonlocal max_size, num_groups\\n            if (i := find(i)) == (j := find(j)):\\n                return\\n\\n            if sizes[i] < sizes[j]:\\n                i, j = j, i\\n\\n            disjoint_set[j] = i\\n            sizes[i] += sizes[j]\\n            max_size = max(max_size, sizes[i])\\n            num_groups -= 1\\n\\n        seen = {}\\n        for i, word in enumerate(words, start=1):\\n            bits = get_bits(word)\\n            if peer := seen.get(bits):\\n                union(peer, i)\\n                continue\\n\\n            for mask in CHAR_MASKS.values():\\n                complement = bits ^ mask\\n                if peer := seen.get(complement):\\n                    union(peer, i)\\n\\n                if bits & mask:\\n                    similar = complement ^ SIMILAR_MASK\\n                    if peer := seen.get(similar):\\n                        union(peer, i)\\n                    else:\\n                        seen[similar] = i\\n\\n            seen[bits] = i\\n\\n        return num_groups, max_size\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nSIMILAR_MASK = 1 << 26\\nCHAR_MASKS = {char: 1 << i for i, char in enumerate(string.ascii_lowercase)}\\nget_bits = lambda word: functools.reduce(\\n    operator.or_, (CHAR_MASKS[char] for char in word)\\n)\\n\\n\\nclass Solution:\\n    def groupStrings(self, words: List[str]) -> List[int]:\\n        max_size = 1\\n        num_groups = len(words)\\n        disjoint_set = list(range(num_groups + 1))\\n        sizes = [1] * (num_groups + 1)\\n\\n        def find(i):\\n            while (parent := disjoint_set[i]) != i:\\n                disjoint_set[i] = disjoint_set[parent]\\n                i = parent\\n            return parent\\n\\n        def union(i, j):\\n            nonlocal max_size, num_groups\\n            if (i := find(i)) == (j := find(j)):\\n                return\\n\\n            if sizes[i] < sizes[j]:\\n                i, j = j, i\\n\\n            disjoint_set[j] = i\\n            sizes[i] += sizes[j]\\n            max_size = max(max_size, sizes[i])\\n            num_groups -= 1\\n\\n        seen = {}\\n        for i, word in enumerate(words, start=1):\\n            bits = get_bits(word)\\n            if peer := seen.get(bits):\\n                union(peer, i)\\n                continue\\n\\n            for mask in CHAR_MASKS.values():\\n                complement = bits ^ mask\\n                if peer := seen.get(complement):\\n                    union(peer, i)\\n\\n                if bits & mask:\\n                    similar = complement ^ SIMILAR_MASK\\n                    if peer := seen.get(similar):\\n                        union(peer, i)\\n                    else:\\n                        seen[similar] = i\\n\\n            seen[bits] = i\\n\\n        return num_groups, max_size\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3912178,
                "title": "easy-javascript-solution-with-comments",
                "content": "Intuition\\nThe intuition behind this solution is to use a Disjoint Set (DSU) data structure to group strings that are cyclic shifts of each other. By converting each string into a bitwise representation and using the DSU to track connected components, we can determine the number of distinct groups.\\n\\nApproach\\nCreate a DJSet (Disjoint Set) data structure that tracks groups. This structure maintains a parent array where negative values represent group sizes, and non-negative values indicate parent-child relationships.\\nIterate through the input words array. For each word, calculate its bitwise representation and store it in the pre array.\\nCreate a Map to track the bitwise representation and its corresponding index in the words array. Use this map to merge connected components in the DSU.\\nIterate through the words array again:\\nFor each word, iterate through all possible toggles (flipping a single bit) and check if the DSU already contains a word with that toggle. If so, merge the groups.\\nNext, iterate through all pairs of toggles and check if a bit is set in the first toggle and not set in the second toggle. If both conditions are met, check if the DSU contains a word with that combined toggle. If so, merge the groups.\\nAfter all iterations, the DSU will have groups of cyclically shifted words. The count of connected components represents the number of distinct groups.\\nReturn an array with the count of groups and the smallest value in the parent array, which represents the size of the largest group.\\nComplexity\\nTime Complexity: O(n * m), where n is the number of words and m is the average length of a word. The most time-consuming step is the iteration over all words and their characters.\\nSpace Complexity: O(n), where n is the number of words. The DSU and additional data structures consume space proportional to the number of words.\\n\\n# Code\\n```\\n// Define a DJSet (Disjoint Set) data structure\\nfunction DJSet(n) {\\n    // parent[i] < 0: Group size where root is i (example: -parent[i] is the size)\\n    // parent[i] >= 0: i is not the root, and parent[i] is i\\'s parent\\n    let parent = Array(n).fill(-1);\\n\\n    // Methods of DJSet\\n    return {\\n        find,\\n        union,\\n        count,\\n        equiv,\\n        getParent\\n    };\\n\\n    function find(x) {\\n        // Path compression: Update parent of x to its root while finding it\\n        return parent[x] < 0 ? x : (parent[x] = find(parent[x]));\\n    }\\n\\n    function union(x, y) {\\n        x = find(x);\\n        y = find(y);\\n        \\n        if (x !== y) {\\n            // Union by rank: Attach the smaller group to the larger group\\n            if (parent[x] < parent[y]) {\\n                [x, y] = [y, x]; // Swap x and y\\n            }\\n            \\n            parent[x] += parent[y];\\n            parent[y] = x;\\n        }\\n        \\n        return x === y; // Returns whether x and y were in the same group\\n    }\\n\\n    function count() {\\n        // Count the total number of connected groups (value < 0)\\n        return parent.filter(v => v < 0).length;\\n    }\\n\\n    function equiv(x, y) {\\n        // Check if x and y are in the same group\\n        return find(x) === find(y);\\n    }\\n\\n    function getParent() {\\n        // Get the parent array (useful for debugging)\\n        return parent;\\n    }\\n}\\n\\nconst groupStrings = (words) => {\\n    const n = words.length;\\n    const ds = new DJSet(n);\\n    const pre = Array(n).fill(0); // Store bitwise representations of words\\n    const m = new Map(); // Map to store bitwise representation and its index\\n\\n    // Build the disjoint set and map based on bitwise representations\\n    for (let i = 0; i < n; i++) {\\n        for (const c of words[i]) {\\n            pre[i] |= 1 << (c.charCodeAt() - 97); // Convert character to 0-25\\n        }\\n\\n        if (m.has(pre[i])) {\\n            ds.union(i, m.get(pre[i])); // Merge the groups\\n        }\\n        m.set(pre[i], i);\\n    }\\n\\n    // Iterate through each word and check for possible group merges\\n    for (let i = 0; i < n; i++) {\\n        for (let j = 0; j < 26; j++) {\\n            const toggle = pre[i] ^ (1 << j);\\n\\n            if (m.has(toggle)) {\\n                ds.union(i, m.get(toggle)); // Merge the groups\\n            }\\n        }\\n\\n        for (let j = 0; j < 26; j++) {\\n            for (let k = 0; k < 26; k++) {\\n                const bitOfOneIJ = pre[i] & (1 << j);\\n                const bitOfOneIK = pre[i] & (1 << k);\\n\\n                if (bitOfOneIJ && !bitOfOneIK) {\\n                    const toggle = pre[i] ^ (1 << j) ^ (1 << k);\\n\\n                    if (m.has(toggle)) {\\n                        ds.union(i, m.get(toggle)); // Merge the groups\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    // Return the total number of groups and the smallest value in the parent array\\n    return [ds.count(), -(Math.min(...ds.getParent()))];\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// Define a DJSet (Disjoint Set) data structure\\nfunction DJSet(n) {\\n    // parent[i] < 0: Group size where root is i (example: -parent[i] is the size)\\n    // parent[i] >= 0: i is not the root, and parent[i] is i\\'s parent\\n    let parent = Array(n).fill(-1);\\n\\n    // Methods of DJSet\\n    return {\\n        find,\\n        union,\\n        count,\\n        equiv,\\n        getParent\\n    };\\n\\n    function find(x) {\\n        // Path compression: Update parent of x to its root while finding it\\n        return parent[x] < 0 ? x : (parent[x] = find(parent[x]));\\n    }\\n\\n    function union(x, y) {\\n        x = find(x);\\n        y = find(y);\\n        \\n        if (x !== y) {\\n            // Union by rank: Attach the smaller group to the larger group\\n            if (parent[x] < parent[y]) {\\n                [x, y] = [y, x]; // Swap x and y\\n            }\\n            \\n            parent[x] += parent[y];\\n            parent[y] = x;\\n        }\\n        \\n        return x === y; // Returns whether x and y were in the same group\\n    }\\n\\n    function count() {\\n        // Count the total number of connected groups (value < 0)\\n        return parent.filter(v => v < 0).length;\\n    }\\n\\n    function equiv(x, y) {\\n        // Check if x and y are in the same group\\n        return find(x) === find(y);\\n    }\\n\\n    function getParent() {\\n        // Get the parent array (useful for debugging)\\n        return parent;\\n    }\\n}\\n\\nconst groupStrings = (words) => {\\n    const n = words.length;\\n    const ds = new DJSet(n);\\n    const pre = Array(n).fill(0); // Store bitwise representations of words\\n    const m = new Map(); // Map to store bitwise representation and its index\\n\\n    // Build the disjoint set and map based on bitwise representations\\n    for (let i = 0; i < n; i++) {\\n        for (const c of words[i]) {\\n            pre[i] |= 1 << (c.charCodeAt() - 97); // Convert character to 0-25\\n        }\\n\\n        if (m.has(pre[i])) {\\n            ds.union(i, m.get(pre[i])); // Merge the groups\\n        }\\n        m.set(pre[i], i);\\n    }\\n\\n    // Iterate through each word and check for possible group merges\\n    for (let i = 0; i < n; i++) {\\n        for (let j = 0; j < 26; j++) {\\n            const toggle = pre[i] ^ (1 << j);\\n\\n            if (m.has(toggle)) {\\n                ds.union(i, m.get(toggle)); // Merge the groups\\n            }\\n        }\\n\\n        for (let j = 0; j < 26; j++) {\\n            for (let k = 0; k < 26; k++) {\\n                const bitOfOneIJ = pre[i] & (1 << j);\\n                const bitOfOneIK = pre[i] & (1 << k);\\n\\n                if (bitOfOneIJ && !bitOfOneIK) {\\n                    const toggle = pre[i] ^ (1 << j) ^ (1 << k);\\n\\n                    if (m.has(toggle)) {\\n                        ds.union(i, m.get(toggle)); // Merge the groups\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    // Return the total number of groups and the smallest value in the parent array\\n    return [ds.count(), -(Math.min(...ds.getParent()))];\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3885881,
                "title": "python3-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom collections import defaultdict\\nfrom typing import List\\n\\nclass Solution:\\n    def __init__(self):\\n        self.parent = {}\\n        self.rank = defaultdict(int)\\n        self.count = defaultdict(int)\\n\\n    def find(self, x):\\n        \"\"\"Find the root of x in the union-find structure.\"\"\"\\n        root = x\\n        while self.parent[root] != root:\\n            root = self.parent[root]\\n        while self.parent[x] != x:  # path compression\\n            x, self.parent[x] = self.parent[x], root\\n        return root\\n\\n    def union(self, x, y):\\n        \"\"\"Unite the sets that x and y belong to.\"\"\"\\n        xr = self.find(x)\\n        yr = self.find(y)\\n        if xr != yr:\\n            if self.rank[xr] < self.rank[yr]:\\n                xr, yr = yr, xr  # Ensure xr has a greater or equal rank\\n            self.parent[yr] = xr\\n            self.count[xr] += self.count[yr]\\n            if self.rank[xr] == self.rank[yr]:\\n                self.rank[xr] += 1\\n\\n    def groupStrings(self, words: List[str]) -> List[int]:\\n        \"\"\"Group strings that can be transformed into each other by swapping 0 or 1 characters.\"\"\"\\n        for word in words:\\n            bit = sum(1 << (ord(c) - ord(\\'a\\')) for c in word)  # convert word to bit representation\\n            if bit not in self.parent:\\n                self.parent[bit] = bit\\n            self.count[bit] += 1\\n\\n        for bit in list(self.parent.keys()):\\n            # Generate all possible transformations\\n            for i in range(26):\\n                mask = 1 << i\\n                # Adding a letter\\n                if not bit & mask:\\n                    nbit = bit | mask\\n                    if nbit in self.parent:\\n                        self.union(bit, nbit)\\n                # Removing a letter or replacing a letter\\n                elif bit & mask:\\n                    # Removing a letter\\n                    nbit = bit & ~mask\\n                    if nbit in self.parent:\\n                        self.union(bit, nbit)\\n                    # Replacing a letter\\n                    for j in range(26):\\n                        if i != j:\\n                            n2bit = (bit & ~mask) | (1 << j)\\n                            if n2bit in self.parent:\\n                                self.union(bit, n2bit)\\n\\n        roots = {self.find(key) for key in self.parent.keys()}\\n        return [len(roots), max(self.count[root] for root in roots)]\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict\\nfrom typing import List\\n\\nclass Solution:\\n    def __init__(self):\\n        self.parent = {}\\n        self.rank = defaultdict(int)\\n        self.count = defaultdict(int)\\n\\n    def find(self, x):\\n        \"\"\"Find the root of x in the union-find structure.\"\"\"\\n        root = x\\n        while self.parent[root] != root:\\n            root = self.parent[root]\\n        while self.parent[x] != x:  # path compression\\n            x, self.parent[x] = self.parent[x], root\\n        return root\\n\\n    def union(self, x, y):\\n        \"\"\"Unite the sets that x and y belong to.\"\"\"\\n        xr = self.find(x)\\n        yr = self.find(y)\\n        if xr != yr:\\n            if self.rank[xr] < self.rank[yr]:\\n                xr, yr = yr, xr  # Ensure xr has a greater or equal rank\\n            self.parent[yr] = xr\\n            self.count[xr] += self.count[yr]\\n            if self.rank[xr] == self.rank[yr]:\\n                self.rank[xr] += 1\\n\\n    def groupStrings(self, words: List[str]) -> List[int]:\\n        \"\"\"Group strings that can be transformed into each other by swapping 0 or 1 characters.\"\"\"\\n        for word in words:\\n            bit = sum(1 << (ord(c) - ord(\\'a\\')) for c in word)  # convert word to bit representation\\n            if bit not in self.parent:\\n                self.parent[bit] = bit\\n            self.count[bit] += 1\\n\\n        for bit in list(self.parent.keys()):\\n            # Generate all possible transformations\\n            for i in range(26):\\n                mask = 1 << i\\n                # Adding a letter\\n                if not bit & mask:\\n                    nbit = bit | mask\\n                    if nbit in self.parent:\\n                        self.union(bit, nbit)\\n                # Removing a letter or replacing a letter\\n                elif bit & mask:\\n                    # Removing a letter\\n                    nbit = bit & ~mask\\n                    if nbit in self.parent:\\n                        self.union(bit, nbit)\\n                    # Replacing a letter\\n                    for j in range(26):\\n                        if i != j:\\n                            n2bit = (bit & ~mask) | (1 << j)\\n                            if n2bit in self.parent:\\n                                self.union(bit, n2bit)\\n\\n        roots = {self.find(key) for key in self.parent.keys()}\\n        return [len(roots), max(self.count[root] for root in roots)]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3768856,
                "title": "c-python-union-find-bitmask-solution-with-explanation",
                "content": "We can use union-find implemented in hash map to record connected groups.\\nWe can use a integer as a bit mask to indicate which letters are contained in a word. \\nFor each word, we can delete or remove a letter, use xor to do it.\\nAnd we can replace an existed letter to another non-existed letter, use 2 for loops to enuemrate all possible situations.\\n\\ntc is O(26 * 26 * n), sc is O(n).\\n### python\\n\\n```python\\nclass DSU:\\n    def __init__(self):\\n        self.parent = defaultdict(int)\\n        self.size = defaultdict(int)\\n        \\n    def find(self, p):\\n        if self.parent[p] != p:\\n            self.parent[p] = self.find(self.parent[p])\\n        return self.parent[p]\\n    \\n    def join(self, p, q):\\n        if p not in self.parent or q not in self.parent: return\\n        pp, pq = self.find(p), self.find(q)\\n        if pp == pq: return\\n        self.parent[pq] = pp\\n        self.size[pp] += self.size[pq]\\n    \\n\\nclass Solution:\\n    def groupStrings(self, words: List[str]) -> List[int]:\\n\\t\\t\\n        dsu = DSU() # union-find\\n\\t\\t\\n\\t\\t# get each word\\'s bit mask, and put it in the union-find\\n        for w in words:\\n            mask = 0\\n            for ch in w:\\n                mask |= 1 << (ord(ch) - ord(\\'a\\'))\\n\\t\\t\\t\\n            dsu.parent[mask] = mask\\n            dsu.size[mask] += 1\\n        \\n\\t\\t# for each word in the union-find\\n        for mask in dsu.parent:\\n\\t\\t\\t\\n\\t\\t\\t# for a - z\\n            for i in range(26):\\n\\t\\t\\t\\n\\t\\t\\t\\t# delete or add a letter\\n                dsu.join(mask, mask ^ (1 << i))\\n                \\n\\t\\t\\t\\t# replace an exsiting letter to a non-exsiting letter\\n                if mask >> i & 1:\\n                    for j in range(26):\\n                        if mask >> j & 1 == 0:\\n                            dsu.join(mask, mask ^ (1 << i) | (1 << j))\\n\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\n        num_group = 0\\n        size_group = 1\\n        for mask in dsu.parent:\\n\\t\\t\\t\\n\\t\\t\\t# if mask is a parent of a group, check its group size\\n            if mask == dsu.find(mask):\\n                num_group += 1\\n                if dsu.size[mask] > size_group: size_group = dsu.size[mask]\\n        \\n        return num_group, size_group\\n```\\n### c++\\n\\n```cpp\\nclass DSU {\\npublic:\\n    unordered_map<int, int> parent;\\n    unordered_map<int, int> size;\\n    DSU() {};\\n    \\n    int find(int p) {\\n        if (this -> parent[p] != p)\\n            this -> parent[p] = this -> find(this -> parent[p]);\\n        return this -> parent[p];\\n    }\\n    \\n    void join(int p, int q) {\\n        if (parent.count(p) == 0 || parent.count(q) == 0) return;\\n        int pp = this -> find(p), pq = this -> find(q);\\n        if (pp == pq) return;\\n        this -> parent[pq] = pp;\\n        this -> size[pp] += size[pq]; \\n    }\\n};\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> groupStrings(vector<string>& words) {\\n        DSU dsu;\\n        for (auto& w: words) {\\n            int mask = 0;\\n            for (auto& ch: w)\\n                mask |= 1 << (ch -\\'a\\');\\n            dsu.parent[mask] = mask;\\n            dsu.size[mask] += 1;\\n        }\\n        for (auto& i: dsu.parent) {\\n            int mask = i.first;\\n            for (int j = 0; j < 26; j+=1) {\\n                dsu.join(mask, mask ^ (1 << j));\\n                \\n                if (mask >> j & 1) {\\n                    for (int k = 0; k < 26; k+=1) {\\n                        if ((mask >> k & 1) == 0)\\n                            dsu.join(mask, mask ^ (1 << j) | (1 << k));\\n                    }\\n                }\\n            }\\n        }\\n        int num_group = 0;\\n        int size_group = 1;\\n        for (auto i: dsu.parent) {\\n            if (dsu.find(i.first) == i.first) {\\n                num_group += 1;\\n                if (dsu.size[i.first] > size_group) size_group = dsu.size[i.first];\\n            }\\n        }\\n        \\n        return {num_group, size_group};\\n    }\\n};\\n```",
                "solutionTags": [
                    "Python",
                    "C",
                    "Union Find",
                    "Bitmask"
                ],
                "code": "```python\\nclass DSU:\\n    def __init__(self):\\n        self.parent = defaultdict(int)\\n        self.size = defaultdict(int)\\n        \\n    def find(self, p):\\n        if self.parent[p] != p:\\n            self.parent[p] = self.find(self.parent[p])\\n        return self.parent[p]\\n    \\n    def join(self, p, q):\\n        if p not in self.parent or q not in self.parent: return\\n        pp, pq = self.find(p), self.find(q)\\n        if pp == pq: return\\n        self.parent[pq] = pp\\n        self.size[pp] += self.size[pq]\\n    \\n\\nclass Solution:\\n    def groupStrings(self, words: List[str]) -> List[int]:\\n\\t\\t\\n        dsu = DSU() # union-find\\n\\t\\t\\n\\t\\t# get each word\\'s bit mask, and put it in the union-find\\n        for w in words:\\n            mask = 0\\n            for ch in w:\\n                mask |= 1 << (ord(ch) - ord(\\'a\\'))\\n\\t\\t\\t\\n            dsu.parent[mask] = mask\\n            dsu.size[mask] += 1\\n        \\n\\t\\t# for each word in the union-find\\n        for mask in dsu.parent:\\n\\t\\t\\t\\n\\t\\t\\t# for a - z\\n            for i in range(26):\\n\\t\\t\\t\\n\\t\\t\\t\\t# delete or add a letter\\n                dsu.join(mask, mask ^ (1 << i))\\n                \\n\\t\\t\\t\\t# replace an exsiting letter to a non-exsiting letter\\n                if mask >> i & 1:\\n                    for j in range(26):\\n                        if mask >> j & 1 == 0:\\n                            dsu.join(mask, mask ^ (1 << i) | (1 << j))\\n\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\n        num_group = 0\\n        size_group = 1\\n        for mask in dsu.parent:\\n\\t\\t\\t\\n\\t\\t\\t# if mask is a parent of a group, check its group size\\n            if mask == dsu.find(mask):\\n                num_group += 1\\n                if dsu.size[mask] > size_group: size_group = dsu.size[mask]\\n        \\n        return num_group, size_group\\n```\n```cpp\\nclass DSU {\\npublic:\\n    unordered_map<int, int> parent;\\n    unordered_map<int, int> size;\\n    DSU() {};\\n    \\n    int find(int p) {\\n        if (this -> parent[p] != p)\\n            this -> parent[p] = this -> find(this -> parent[p]);\\n        return this -> parent[p];\\n    }\\n    \\n    void join(int p, int q) {\\n        if (parent.count(p) == 0 || parent.count(q) == 0) return;\\n        int pp = this -> find(p), pq = this -> find(q);\\n        if (pp == pq) return;\\n        this -> parent[pq] = pp;\\n        this -> size[pp] += size[pq]; \\n    }\\n};\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> groupStrings(vector<string>& words) {\\n        DSU dsu;\\n        for (auto& w: words) {\\n            int mask = 0;\\n            for (auto& ch: w)\\n                mask |= 1 << (ch -\\'a\\');\\n            dsu.parent[mask] = mask;\\n            dsu.size[mask] += 1;\\n        }\\n        for (auto& i: dsu.parent) {\\n            int mask = i.first;\\n            for (int j = 0; j < 26; j+=1) {\\n                dsu.join(mask, mask ^ (1 << j));\\n                \\n                if (mask >> j & 1) {\\n                    for (int k = 0; k < 26; k+=1) {\\n                        if ((mask >> k & 1) == 0)\\n                            dsu.join(mask, mask ^ (1 << j) | (1 << k));\\n                    }\\n                }\\n            }\\n        }\\n        int num_group = 0;\\n        int size_group = 1;\\n        for (auto i: dsu.parent) {\\n            if (dsu.find(i.first) == i.first) {\\n                num_group += 1;\\n                if (dsu.size[i.first] > size_group) size_group = dsu.size[i.first];\\n            }\\n        }\\n        \\n        return {num_group, size_group};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3282393,
                "title": "python-ac-union-find-o-n-26-pre-processing",
                "content": "# Code\\n```\\nclass Solution:\\n    def groupStrings(self, words: List[str]) -> List[int]:\\n        def gm(w):\\n            mk =0\\n            for x in w:\\n                mk |= 1<<(ord(x)-ord(\\'a\\'))\\n            return mk\\n        masks = [gm(w) for w in words]\\n        d = dict([(w,i) for i,w in enumerate(masks)])\\n        r_d = dict()\\n        for k,x in enumerate(masks):\\n            for i in range(26):\\n                if((x&(1<<i))==0): continue\\n                r_d[x^(1<<i)] = k\\n        ds = DSU(len(words))\\n        for u,m in enumerate(masks):\\n            for i in range(26): # add remove\\n                if((m^(1<<i)) in d): \\n                    ds.union(u,d[(m^(1<<i))])\\n            ds.union(u,d[m])\\n            for i in range(26): # replace \\n                if((m&(1<<i))==0): continue\\n                nm = (m^(1<<i))\\n                if(nm in r_d): ds.union(u,r_d[nm])\\n        return [ds.cnt,ds.mx]\\n\\n\\n\\n\\n        \\n\\n\\nclass DSU:\\n    def __init__(self, N):\\n        self.par = list(range(N))\\n        self.sz = [1] * N\\n        self.mx = 1\\n        self.cnt = N\\n\\n    def find(self, x):\\n        if self.par[x] != x:\\n            self.par[x] = self.find(self.par[x])\\n        return self.par[x]\\n\\n    def union(self, x, y):\\n        xr, yr = self.find(x), self.find(y)\\n        if xr == yr:\\n            return False\\n        if self.sz[xr] < self.sz[yr]:\\n            xr, yr = yr, xr\\n        self.par[yr] = xr\\n        self.sz[xr] += self.sz[yr]\\n        self.mx = max(self.mx,self.sz[xr])\\n        self.cnt -=1\\n        return True\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def groupStrings(self, words: List[str]) -> List[int]:\\n        def gm(w):\\n            mk =0\\n            for x in w:\\n                mk |= 1<<(ord(x)-ord(\\'a\\'))\\n            return mk\\n        masks = [gm(w) for w in words]\\n        d = dict([(w,i) for i,w in enumerate(masks)])\\n        r_d = dict()\\n        for k,x in enumerate(masks):\\n            for i in range(26):\\n                if((x&(1<<i))==0): continue\\n                r_d[x^(1<<i)] = k\\n        ds = DSU(len(words))\\n        for u,m in enumerate(masks):\\n            for i in range(26): # add remove\\n                if((m^(1<<i)) in d): \\n                    ds.union(u,d[(m^(1<<i))])\\n            ds.union(u,d[m])\\n            for i in range(26): # replace \\n                if((m&(1<<i))==0): continue\\n                nm = (m^(1<<i))\\n                if(nm in r_d): ds.union(u,r_d[nm])\\n        return [ds.cnt,ds.mx]\\n\\n\\n\\n\\n        \\n\\n\\nclass DSU:\\n    def __init__(self, N):\\n        self.par = list(range(N))\\n        self.sz = [1] * N\\n        self.mx = 1\\n        self.cnt = N\\n\\n    def find(self, x):\\n        if self.par[x] != x:\\n            self.par[x] = self.find(self.par[x])\\n        return self.par[x]\\n\\n    def union(self, x, y):\\n        xr, yr = self.find(x), self.find(y)\\n        if xr == yr:\\n            return False\\n        if self.sz[xr] < self.sz[yr]:\\n            xr, yr = yr, xr\\n        self.par[yr] = xr\\n        self.sz[xr] += self.sz[yr]\\n        self.mx = max(self.mx,self.sz[xr])\\n        self.cnt -=1\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3255038,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn group_strings(words: Vec<String>) -> Vec<i32> {\\n        let mut m = std::collections::HashMap::new();\\n        let mut groups = 0;\\n        let mut max_size = 0;\\n        for w in words.iter() {\\n            let mut mask = 0;\\n            for ch in w.chars() {\\n                mask |= 1 << (ch as u8 - b\\'a\\');\\n            }\\n            *m.entry(mask).or_insert(0) += 1;\\n        }\\n        while !m.is_empty() {\\n            let mask = *m.iter().next().unwrap().0;\\n            let size = Self::dfs(mask, &mut m);\\n            max_size = max_size.max(size);\\n            groups += if size > 0 { 1 } else { 0 };\\n        }\\n        vec![groups, max_size]\\n    }\\n\\n    fn dfs(mask: i32, m: &mut std::collections::HashMap<i32, i32>) -> i32 {\\n        let mut res = 0;\\n        let it = m.get(&mask);\\n        if it.is_none() {\\n            return res;\\n        }\\n        res += it.unwrap();\\n        m.remove(&mask);\\n        for i in 0..26 {\\n            res += Self::dfs(mask ^ (1 << i), m);\\n            for j in (i + 1)..26 {\\n                if ((mask >> i) & 1) != ((mask >> j) & 1) {\\n                    res += Self::dfs(mask ^ (1 << i) ^ (1 << j), m);\\n                }\\n            }\\n        }\\n        res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn group_strings(words: Vec<String>) -> Vec<i32> {\\n        let mut m = std::collections::HashMap::new();\\n        let mut groups = 0;\\n        let mut max_size = 0;\\n        for w in words.iter() {\\n            let mut mask = 0;\\n            for ch in w.chars() {\\n                mask |= 1 << (ch as u8 - b\\'a\\');\\n            }\\n            *m.entry(mask).or_insert(0) += 1;\\n        }\\n        while !m.is_empty() {\\n            let mask = *m.iter().next().unwrap().0;\\n            let size = Self::dfs(mask, &mut m);\\n            max_size = max_size.max(size);\\n            groups += if size > 0 { 1 } else { 0 };\\n        }\\n        vec![groups, max_size]\\n    }\\n\\n    fn dfs(mask: i32, m: &mut std::collections::HashMap<i32, i32>) -> i32 {\\n        let mut res = 0;\\n        let it = m.get(&mask);\\n        if it.is_none() {\\n            return res;\\n        }\\n        res += it.unwrap();\\n        m.remove(&mask);\\n        for i in 0..26 {\\n            res += Self::dfs(mask ^ (1 << i), m);\\n            for j in (i + 1)..26 {\\n                if ((mask >> i) & 1) != ((mask >> j) & 1) {\\n                    res += Self::dfs(mask ^ (1 << i) ^ (1 << j), m);\\n                }\\n            }\\n        }\\n        res\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3151036,
                "title": "python-simple-dfs-bitmask",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def groupStrings(self, words):\\n        def convert(w): return sum(1<<(ord(c)-ord(\"a\")) for c in w)\\n\\n        ans = [convert(i) for i in words]\\n\\n        dict1 = collections.Counter(ans)\\n\\n        def dfs(n):\\n            if n in visited: return 0\\n            total = dict1[n]\\n            visited.add(n)\\n            total += _add(n)\\n            total += _remove(n)\\n            total += _replace(n)\\n            return total\\n\\n        def _add(n):\\n            total = 0\\n\\n            for i in range(26):\\n                if (1<<i)&n == 0:\\n                    m = n + (1<<i)\\n                    if m in dict1:\\n                        total += dfs(m)\\n\\n            return total\\n\\n        \\n        def _remove(n):\\n            total = 0\\n\\n            for i in range(26):\\n                if (1<<i)&n != 0:\\n                    m = n - (1<<i)\\n                    if m in dict1:\\n                        total += dfs(m)\\n\\n            return total\\n\\n        \\n        def _replace(n):\\n            total = 0\\n\\n            pos = [i for i in range(26) if (1<<i)&n != 0]\\n\\n            for p in pos:\\n                m = n - (1<<p)\\n                for j in range(26):\\n                    if j not in pos and m + (1<<j) in dict1:\\n                        total += dfs(m + (1<<j))\\n\\n            return total \\n\\n        number_of_groups, largest_size, visited = 0, 0, set()\\n\\n        for key,val in dict1.items():\\n            x = dfs(key)\\n            if x > 0:\\n                largest_size = max(largest_size,x)\\n                number_of_groups += 1\\n\\n        return [number_of_groups,largest_size]\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n        \\n\\n        \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n        \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n        \\n\\n\\n        \\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def groupStrings(self, words):\\n        def convert(w): return sum(1<<(ord(c)-ord(\"a\")) for c in w)\\n\\n        ans = [convert(i) for i in words]\\n\\n        dict1 = collections.Counter(ans)\\n\\n        def dfs(n):\\n            if n in visited: return 0\\n            total = dict1[n]\\n            visited.add(n)\\n            total += _add(n)\\n            total += _remove(n)\\n            total += _replace(n)\\n            return total\\n\\n        def _add(n):\\n            total = 0\\n\\n            for i in range(26):\\n                if (1<<i)&n == 0:\\n                    m = n + (1<<i)\\n                    if m in dict1:\\n                        total += dfs(m)\\n\\n            return total\\n\\n        \\n        def _remove(n):\\n            total = 0\\n\\n            for i in range(26):\\n                if (1<<i)&n != 0:\\n                    m = n - (1<<i)\\n                    if m in dict1:\\n                        total += dfs(m)\\n\\n            return total\\n\\n        \\n        def _replace(n):\\n            total = 0\\n\\n            pos = [i for i in range(26) if (1<<i)&n != 0]\\n\\n            for p in pos:\\n                m = n - (1<<p)\\n                for j in range(26):\\n                    if j not in pos and m + (1<<j) in dict1:\\n                        total += dfs(m + (1<<j))\\n\\n            return total \\n\\n        number_of_groups, largest_size, visited = 0, 0, set()\\n\\n        for key,val in dict1.items():\\n            x = dfs(key)\\n            if x > 0:\\n                largest_size = max(largest_size,x)\\n                number_of_groups += 1\\n\\n        return [number_of_groups,largest_size]\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n        \\n\\n        \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n        \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n        \\n\\n\\n        \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3126193,
                "title": "scala-intermediate-graph-bitmask-disjoint-set",
                "content": "If we compare the strings trivially to build the connecting graph, it takes O(26 * n * n) Char comparison operations. Even if by using a bitmap, it will take O(n * n) Int comparison.\\n\\nThe trick is that we can build some intermediate nodes in the graph to avoid comparing the original strings (or bitmaps) one by one.\\n\\n![image](https://assets.leetcode.com/users/images/cd04c87f-eec5-4931-8725-aea90023f7a0_1675240297.341369.png)\\n\\nFor a string `s` and each of its characters `c`, we substract `c` from `s` to create a new intermediate string `t`. We also add `s` itself as an intermediate string. Connect `s` and all its generated strings. It can be shown that `s1` can be transformed to `s2`, if and only if there is an intermediate string `t` between them.\\n\\nFor each intermediate string, all its `n` original strings are granted to be connected. If we use disjoint set to union them, it only takes `n - 1` union operations.\\n\\nOne original string will has at most 27 intermediate string. It will totally take less than O(27 * n) union operations.\\n\\nBased on this, we can also continue to play some bitmap and disjoint set tricks to save even more time.\\n\\n```Scala\\nobject Solution {\\n    def groupStrings(words: Array[String]): Array[Int] = {\\n        def str2int(s: String) = s.foldLeft(0)((i, c) => i | (1 << c - \\'a\\'))\\n        val masks = (0 to 26).map(1 << _).map(~_)\\n\\n        val adj = words.map(str2int).zipWithIndex.foldLeft(Map[Int, Vector[Int]]().withDefaultValue(Vector())) {\\n            case (m, (s, i)) =>\\n                masks.map(s & _).toSet.foldLeft(m)((mm, sss) => mm + (sss -> (mm(sss) :+ i)))\\n        }.values\\n\\n        def find(p: Vector[Int])(x: Int): (Int, Vector[Int]) = if (p(x) == x) (x, p) else {\\n            val (rx, pp) = find(p)(p(x))\\n            (rx, pp.updated(x, rx))\\n        }\\n        def union(p: Vector[Int])(x: Int, y: Int) = {\\n            val (rx, px) = find(p)(x)\\n            val (ry, py) = find(px)(y)\\n            py.updated(rx, ry)\\n        }\\n\\n        val parents = adj.foldLeft(Vector.tabulate(words.size)(i => i))((p, v) => {\\n            v.sliding(2).foldLeft(p) {\\n                case (pp, Vector(i, j)) => union(pp)(i, j)\\n                case (pp, _) => pp\\n            }\\n        })\\n\\n        val roots = words.indices.scanLeft(0, parents){case ((_, p), x) => find(p)(x)}\\n            .map(_._1).drop(1).groupBy(x => x).mapValues(_.size)\\n        Array(roots.size, roots.values.max)\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```Scala\\nobject Solution {\\n    def groupStrings(words: Array[String]): Array[Int] = {\\n        def str2int(s: String) = s.foldLeft(0)((i, c) => i | (1 << c - \\'a\\'))\\n        val masks = (0 to 26).map(1 << _).map(~_)\\n\\n        val adj = words.map(str2int).zipWithIndex.foldLeft(Map[Int, Vector[Int]]().withDefaultValue(Vector())) {\\n            case (m, (s, i)) =>\\n                masks.map(s & _).toSet.foldLeft(m)((mm, sss) => mm + (sss -> (mm(sss) :+ i)))\\n        }.values\\n\\n        def find(p: Vector[Int])(x: Int): (Int, Vector[Int]) = if (p(x) == x) (x, p) else {\\n            val (rx, pp) = find(p)(p(x))\\n            (rx, pp.updated(x, rx))\\n        }\\n        def union(p: Vector[Int])(x: Int, y: Int) = {\\n            val (rx, px) = find(p)(x)\\n            val (ry, py) = find(px)(y)\\n            py.updated(rx, ry)\\n        }\\n\\n        val parents = adj.foldLeft(Vector.tabulate(words.size)(i => i))((p, v) => {\\n            v.sliding(2).foldLeft(p) {\\n                case (pp, Vector(i, j)) => union(pp)(i, j)\\n                case (pp, _) => pp\\n            }\\n        })\\n\\n        val roots = words.indices.scanLeft(0, parents){case ((_, p), x) => find(p)(x)}\\n            .map(_._1).drop(1).groupBy(x => x).mapValues(_.size)\\n        Array(roots.size, roots.values.max)\\n    }\\n}\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3115165,
                "title": "java-clean-code-unionfind-bitmask",
                "content": "# Intuition\\n1. Connected-components problem => UnionFind\\n2. Check connectivity by bit manipulation\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] groupStrings(String[] words) {\\n        int n = words.length;\\n        UnionFind uf = new UnionFind(n);\\n\\n        // words to bit repr\\n        int[] bits = new int[n];\\n        Map<Integer, Integer> bitToIdx = new HashMap<>();\\n        for (int i = 0; i < n; i++) {\\n            bits[i] = toBit(words[i]);\\n            bitToIdx.put(bits[i], i);\\n        }\\n\\n        // union links\\n        for (int i = 0; i < n; i++) {\\n            uf.union(i, bitToIdx.get(bits[i]));\\n\\n            for (char ch : words[i].toCharArray()) {\\n                int bit = bits[i];\\n                // delete\\n                int deleted = delete(bit, ch);\\n                if (bitToIdx.containsKey(deleted)) {\\n                    uf.union(i, bitToIdx.get(deleted));\\n                }\\n                \\n                // replace\\n                for (char r = \\'a\\'; r <= \\'z\\'; r++) {\\n                    if (ch == r) continue;\\n                    int replaced = set(deleted, r);\\n                    if (bitToIdx.containsKey(replaced)) {\\n                        uf.union(i, bitToIdx.get(replaced));\\n                    }\\n                }\\n            }\\n        }\\n\\n        return new int[]{uf.count, uf.maxSize};\\n    }\\n\\n    private int delete(int bit, char ch) {\\n        return bit & (~(1 << (ch - \\'a\\')));\\n    }\\n\\n    private int set(int bit, char ch) {\\n        return bit | (1 << (ch - \\'a\\'));\\n    }\\n\\n    private int toBit(String word) {\\n        int bit = 0;\\n        for (char ch : word.toCharArray()) {\\n            bit = set(bit, ch);\\n        }\\n        return bit;\\n    }\\n\\n    private class UnionFind {\\n        int[] parents;\\n        int[] sizes;\\n        int count;\\n        int maxSize;\\n\\n        public UnionFind(int n) {\\n            parents = new int[n];\\n            sizes = new int[n];\\n            count = n;\\n            maxSize = 1;\\n\\n            IntStream.range(0, n)\\n                    .forEach(i -> {\\n                        parents[i] = i; sizes[i] = 1;\\n                        });\\n        }\\n\\n        public void union(int p, int q) {\\n            if (p == q) return;\\n            int rootP = find(p);\\n            int rootQ = find(q);\\n            if (rootP == rootQ) {\\n                return;\\n            }\\n\\n            count--;\\n\\n            if (sizes[rootP] <= sizes[rootQ]) {\\n                parents[rootP] = rootQ;\\n                sizes[rootQ] += sizes[rootP];\\n                maxSize = Math.max(maxSize, sizes[rootQ]);\\n            } else {\\n                parents[rootQ] = rootP;\\n                sizes[rootP] += sizes[rootQ];\\n                maxSize = Math.max(maxSize, sizes[rootP]);\\n            }\\n        }\\n\\n        private int find(int p) {\\n            if (parents[p] == p) return p;\\n            return parents[p] = find(parents[p]);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    public int[] groupStrings(String[] words) {\\n        int n = words.length;\\n        UnionFind uf = new UnionFind(n);\\n\\n        // words to bit repr\\n        int[] bits = new int[n];\\n        Map<Integer, Integer> bitToIdx = new HashMap<>();\\n        for (int i = 0; i < n; i++) {\\n            bits[i] = toBit(words[i]);\\n            bitToIdx.put(bits[i], i);\\n        }\\n\\n        // union links\\n        for (int i = 0; i < n; i++) {\\n            uf.union(i, bitToIdx.get(bits[i]));\\n\\n            for (char ch : words[i].toCharArray()) {\\n                int bit = bits[i];\\n                // delete\\n                int deleted = delete(bit, ch);\\n                if (bitToIdx.containsKey(deleted)) {\\n                    uf.union(i, bitToIdx.get(deleted));\\n                }\\n                \\n                // replace\\n                for (char r = \\'a\\'; r <= \\'z\\'; r++) {\\n                    if (ch == r) continue;\\n                    int replaced = set(deleted, r);\\n                    if (bitToIdx.containsKey(replaced)) {\\n                        uf.union(i, bitToIdx.get(replaced));\\n                    }\\n                }\\n            }\\n        }\\n\\n        return new int[]{uf.count, uf.maxSize};\\n    }\\n\\n    private int delete(int bit, char ch) {\\n        return bit & (~(1 << (ch - \\'a\\')));\\n    }\\n\\n    private int set(int bit, char ch) {\\n        return bit | (1 << (ch - \\'a\\'));\\n    }\\n\\n    private int toBit(String word) {\\n        int bit = 0;\\n        for (char ch : word.toCharArray()) {\\n            bit = set(bit, ch);\\n        }\\n        return bit;\\n    }\\n\\n    private class UnionFind {\\n        int[] parents;\\n        int[] sizes;\\n        int count;\\n        int maxSize;\\n\\n        public UnionFind(int n) {\\n            parents = new int[n];\\n            sizes = new int[n];\\n            count = n;\\n            maxSize = 1;\\n\\n            IntStream.range(0, n)\\n                    .forEach(i -> {\\n                        parents[i] = i; sizes[i] = 1;\\n                        });\\n        }\\n\\n        public void union(int p, int q) {\\n            if (p == q) return;\\n            int rootP = find(p);\\n            int rootQ = find(q);\\n            if (rootP == rootQ) {\\n                return;\\n            }\\n\\n            count--;\\n\\n            if (sizes[rootP] <= sizes[rootQ]) {\\n                parents[rootP] = rootQ;\\n                sizes[rootQ] += sizes[rootP];\\n                maxSize = Math.max(maxSize, sizes[rootQ]);\\n            } else {\\n                parents[rootQ] = rootP;\\n                sizes[rootP] += sizes[rootQ];\\n                maxSize = Math.max(maxSize, sizes[rootP]);\\n            }\\n        }\\n\\n        private int find(int p) {\\n            if (parents[p] == p) return p;\\n            return parents[p] = find(parents[p]);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2762458,
                "title": "python-solution-unionfind-bitmask",
                "content": "```\\nclass unionfind:\\n    def __init__(self, k):\\n        self.fa = list(range(k))\\n        self.count = k\\n        \\n    def find(self, x):\\n        if self.fa[x]!=x:\\n            self.fa[x] = self.find(self.fa[x])\\n        return self.fa[x]\\n    \\n    def union(self, x, y):\\n        u, v = self.find(x), self.find(y)\\n        self.fa[v] = u\\n        self.count -= (u!=v)\\n    \\nclass Solution:\\n    def groupStrings(self, words: List[str]) -> List[int]:\\n        uf, dlt = unionfind(len(words)), {}\\n        for i in range(len(words)):\\n            x = sum(1<<(ord(c)-ord(\\'a\\')) for c in words[i])\\n            if x in dlt:\\n                uf.union(i, dlt[x])\\n            for j in range(26):\\n                if x&(1<<j):\\n                    if x^(1<<j) in dlt:\\n                        uf.union(i, dlt[x^(1<<j)])\\n                    dlt[x^(1<<j)] = i\\n            dlt[x] = i\\n        \\n        cnter = Counter(uf.find(i) for i in range(len(words)))\\n        return [uf.count, max(cnter.values())]\\n```",
                "solutionTags": [],
                "code": "```\\nclass unionfind:\\n    def __init__(self, k):\\n        self.fa = list(range(k))\\n        self.count = k\\n        \\n    def find(self, x):\\n        if self.fa[x]!=x:\\n            self.fa[x] = self.find(self.fa[x])\\n        return self.fa[x]\\n    \\n    def union(self, x, y):\\n        u, v = self.find(x), self.find(y)\\n        self.fa[v] = u\\n        self.count -= (u!=v)\\n    \\nclass Solution:\\n    def groupStrings(self, words: List[str]) -> List[int]:\\n        uf, dlt = unionfind(len(words)), {}\\n        for i in range(len(words)):\\n            x = sum(1<<(ord(c)-ord(\\'a\\')) for c in words[i])\\n            if x in dlt:\\n                uf.union(i, dlt[x])\\n            for j in range(26):\\n                if x&(1<<j):\\n                    if x^(1<<j) in dlt:\\n                        uf.union(i, dlt[x^(1<<j)])\\n                    dlt[x^(1<<j)] = i\\n            dlt[x] = i\\n        \\n        cnter = Counter(uf.find(i) for i in range(len(words)))\\n        return [uf.count, max(cnter.values())]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2755944,
                "title": "python-dsu-bitmask-concise-solution",
                "content": "```\\nclass DSU:\\n    def __init__(self, n):\\n        self.parent = [x for x in range(n)]\\n        self.sizes = [1]*n\\n        self.combined = 0\\n    \\n    def find(self, x):\\n        if self.parent[x] == x: return x\\n        self.parent[x] = self.find(self.parent[x])\\n        return self.parent[x]\\n    \\n    def union(self, a, b):\\n        x, y = self.find(a), self.find(b)\\n        if x == y: return\\n        self.parent[y] = x\\n        self.sizes[x] += self.sizes[y]\\n        self.sizes[y] = 0\\n        self.combined += 1\\n        \\nclass Solution:\\n    def groupStrings(self, words: List[str]) -> List[int]:\\n        seen = {}\\n        dsu = DSU(len(words))\\n        \\n        for i, word in enumerate(words):\\n            bitset = sum(1 << (ord(char)-ord(\"a\")) for char in word)\\n            if bitset in seen:\\n                dsu.union(i, seen[bitset])\\n            \\n            for j in range(26):\\n                # Removing character if it is set or present\\n                if bitset & (1 << j):\\n                    after_removing_char = bitset ^ (1 << j)\\n                    if after_removing_char in seen:\\n                        dsu.union(i, seen[after_removing_char])\\n                    seen[after_removing_char] = i\\n            seen[bitset] = i\\n        \\n        return [len(words) - dsu.combined, max(dsu.sizes)]\\n```",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation",
                    "Union Find",
                    "Bitmask"
                ],
                "code": "```\\nclass DSU:\\n    def __init__(self, n):\\n        self.parent = [x for x in range(n)]\\n        self.sizes = [1]*n\\n        self.combined = 0\\n    \\n    def find(self, x):\\n        if self.parent[x] == x: return x\\n        self.parent[x] = self.find(self.parent[x])\\n        return self.parent[x]\\n    \\n    def union(self, a, b):\\n        x, y = self.find(a), self.find(b)\\n        if x == y: return\\n        self.parent[y] = x\\n        self.sizes[x] += self.sizes[y]\\n        self.sizes[y] = 0\\n        self.combined += 1\\n        \\nclass Solution:\\n    def groupStrings(self, words: List[str]) -> List[int]:\\n        seen = {}\\n        dsu = DSU(len(words))\\n        \\n        for i, word in enumerate(words):\\n            bitset = sum(1 << (ord(char)-ord(\"a\")) for char in word)\\n            if bitset in seen:\\n                dsu.union(i, seen[bitset])\\n            \\n            for j in range(26):\\n                # Removing character if it is set or present\\n                if bitset & (1 << j):\\n                    after_removing_char = bitset ^ (1 << j)\\n                    if after_removing_char in seen:\\n                        dsu.union(i, seen[after_removing_char])\\n                    seen[after_removing_char] = i\\n            seen[bitset] = i\\n        \\n        return [len(words) - dsu.combined, max(dsu.sizes)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2703674,
                "title": "python3-using-union-find-and-bit-manipulation",
                "content": "class Solution:\\n\\n    def groupStrings(self, words: List[str]) -> List[int]:\\n        parent = {}\\n        \\n        def find(x):\\n            if x not in parent:\\n                parent[x] = x\\n            if parent[x]!=x:\\n                parent[x] = find(parent[x])\\n            return parent[x]\\n        \\n        def union(x,y):\\n            px,py = find(x),find(y)\\n            parent[px] = py\\n            \\n        visited = defaultdict(int)\\n        oneoff = {}\\n        \\n        ordA = ord(\\'a\\')\\n        for word in words:\\n            mask = 0        \\n            for char in word:\\n                offset = ord(char)-ordA\\n                mask|=(1<<offset)\\n            visited[mask]+=1\\n            \\n            for i in range(26):\\n                if  (mask & (1<<i)) == 0:\\n                    nmask = mask | (1<<i)\\n                else:\\n                    nmask = mask ^ (1<<i)\\n                    \\n                    if nmask in oneoff:\\n                        union(mask,oneoff[nmask])\\n                    else:\\n                        oneoff[nmask] = mask\\n                if nmask in visited:\\n                    union(mask,nmask)\\n                    \\n        g = Counter()\\n        Largest = 0\\n        for key in visited.keys():\\n            u = find(key)\\n            g[u]+=visited[key]\\n            Largest = max(g[u],Largest)\\n        return  [len(g),Largest]",
                "solutionTags": [],
                "code": "class Solution:\\n\\n    def groupStrings(self, words: List[str]) -> List[int]:\\n        parent = {}",
                "codeTag": "Java"
            },
            {
                "id": 2651548,
                "title": "easy-short-efficient-clean-code",
                "content": "```\\nclass Solution {\\ntypedef long long ll;\\n#define vi(x) vector<x>\\npublic:\\n    ll n;\\n    vi(ll)par, size;\\n    ll find(ll n){\\n        if(par[n]==n){\\n            return n;\\n        }\\n        return (par[n]=find(par[n]));\\n    }\\n    void merge(ll a, ll b){\\n        a=find(a), b=find(b);\\n        if(a==b){\\n            return;\\n        }\\n        if(size[a]<size[b]){\\n            a+=b, b=a-b, a-=b;\\n        }\\n        par[b]=a;\\n        size[a]+=size[b];\\n    }\\n    ll getBitMask(const string&s){\\n        ll ans=0;\\n        for(char ch:s){\\n            ans|=1<<(ch-\\'a\\');\\n        }\\n        return ans;\\n    }\\n    vector<int> groupStrings(vector<string>&v) {\\n        n=v.size();\\n        unordered_map<ll,ll>ump;\\n        par.resize(n), size.assign(n, 1);\\n        iota(begin(par), end(par), 0);\\n        for(ll i=0;i<n;++i){\\n            ll bm=getBitMask(v[i]);\\n            if(ump.find(bm)!=ump.end()){\\n                merge(i, ump[bm]);\\n            }\\n            for(ll j=0;j<26;++j){\\n                if(ump.find(bm^(1<<j))!=ump.end()){\\n                    merge(ump[bm^(1<<j)], i);\\n                }\\n            }\\n            for(ll z=0;z<26;++z){\\n                if((bm>>z)&1){\\n                    continue;\\n                }\\n                for(ll o=0;o<26;++o){\\n                    if(!((bm>>o)&1)){\\n                        continue;\\n                    }\\n                    if(ump.find(bm^(1<<z)^(1<<o))!=ump.end()){\\n                        merge(ump[bm^(1<<z)^(1<<o)], i);\\n                    }\\n                }\\n            }\\n            ump[bm]=i;\\n        }\\n        int cnt=0, mx=0;\\n        for(ll i=0;i<n;++i){\\n            mx=max(mx, (int)size[i]);\\n            cnt+=par[i]==i;\\n        }\\n        return {cnt, mx};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Union Find",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\ntypedef long long ll;\\n#define vi(x) vector<x>\\npublic:\\n    ll n;\\n    vi(ll)par, size;\\n    ll find(ll n){\\n        if(par[n]==n){\\n            return n;\\n        }\\n        return (par[n]=find(par[n]));\\n    }\\n    void merge(ll a, ll b){\\n        a=find(a), b=find(b);\\n        if(a==b){\\n            return;\\n        }\\n        if(size[a]<size[b]){\\n            a+=b, b=a-b, a-=b;\\n        }\\n        par[b]=a;\\n        size[a]+=size[b];\\n    }\\n    ll getBitMask(const string&s){\\n        ll ans=0;\\n        for(char ch:s){\\n            ans|=1<<(ch-\\'a\\');\\n        }\\n        return ans;\\n    }\\n    vector<int> groupStrings(vector<string>&v) {\\n        n=v.size();\\n        unordered_map<ll,ll>ump;\\n        par.resize(n), size.assign(n, 1);\\n        iota(begin(par), end(par), 0);\\n        for(ll i=0;i<n;++i){\\n            ll bm=getBitMask(v[i]);\\n            if(ump.find(bm)!=ump.end()){\\n                merge(i, ump[bm]);\\n            }\\n            for(ll j=0;j<26;++j){\\n                if(ump.find(bm^(1<<j))!=ump.end()){\\n                    merge(ump[bm^(1<<j)], i);\\n                }\\n            }\\n            for(ll z=0;z<26;++z){\\n                if((bm>>z)&1){\\n                    continue;\\n                }\\n                for(ll o=0;o<26;++o){\\n                    if(!((bm>>o)&1)){\\n                        continue;\\n                    }\\n                    if(ump.find(bm^(1<<z)^(1<<o))!=ump.end()){\\n                        merge(ump[bm^(1<<z)^(1<<o)], i);\\n                    }\\n                }\\n            }\\n            ump[bm]=i;\\n        }\\n        int cnt=0, mx=0;\\n        for(ll i=0;i<n;++i){\\n            mx=max(mx, (int)size[i]);\\n            cnt+=par[i]==i;\\n        }\\n        return {cnt, mx};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2507582,
                "title": "c-union-find-trie",
                "content": "```cpp\\n#define vec vector\\n#define vi vector<int>\\n#define amax(x, y) x = max(x, y)\\n\\nstruct dsu {\\n  vec<int> parent, size;\\n  int ans = 1, groups = 0;\\n  dsu(int n) : parent(n), size(n, 1), groups(n) {\\n    for (int i = 0; i < n; i++)\\n      parent[i] = i;\\n  }\\n  int find(int i) {\\n    if (parent[i] == i)\\n      return i;\\n    return parent[i] = find(parent[i]);\\n  }\\n  void unite(int i, int j) {\\n    if (find(i) != find(j)) {\\n      int repi = find(i);\\n      int repj = find(j);\\n      if (size[repi] < size[repj])\\n        swap(repi, repj);\\n      parent[repj] = repi;\\n      size[repi] += size[repj];\\n      amax(ans, size[repi]);\\n      groups--;\\n    }\\n  }\\n};\\n\\nstruct trie {\\n  struct node {\\n    array<node *, 2> adj{};\\n    array<int, 4> vis{};\\n    vi pos;\\n  };\\n  node *root = new node();\\n  void insert(string &s, dsu &ds, int p) {\\n    auto cur = root;\\n    for (int i = 0; i < s.size(); i++) {\\n      auto &next = cur->adj[s[i] == \\' \\'];\\n      if (!next)\\n        next = new node();\\n      cur = next;\\n    }\\n    if (!cur->pos.empty()) {\\n      ds.unite(p, cur->pos.back());\\n    }\\n    cur->pos.push_back(p);\\n  }\\n  void search(string &s, dsu &ds, int p, int i, int state, node *cur,\\n              int vis_id) {\\n    cur->vis[state] = vis_id;\\n    if (i == s.size() && (state == 1 || state == 3)) {\\n      if (!cur->pos.empty()) {\\n        ds.unite(p, cur->pos.back());\\n      }\\n      return;\\n    }\\n\\n    if (state == 1) {\\n      if (cur->adj[0]) {\\n        if (cur->adj[0]->vis[3] != vis_id) {\\n          search(s, ds, p, i + 1, 3, cur->adj[0], vis_id);\\n        }\\n        if (cur->adj[0]->vis[2] != vis_id) {\\n          search(s, ds, p, i + 1, 2, cur->adj[0], vis_id);\\n        }\\n      }\\n    }\\n    if (state == 2) {\\n      auto next = cur->adj[1];\\n      if (next && next->vis[3] != vis_id) {\\n        search(s, ds, p, i + 1, 3, next, vis_id);\\n      }\\n    }\\n\\n    auto next = cur->adj[s[i] == \\' \\'];\\n    if (next && next->vis[state] != vis_id) {\\n      search(s, ds, p, i + 1, state, next, vis_id);\\n    }\\n  }\\n};\\n\\nclass Solution {\\npublic:\\n  vector<int> groupStrings(vector<string> &words) {\\n    int n = words.size();\\n    vec<string> transformed;\\n    for (auto &w : words) {\\n      string counted(26, \\' \\');\\n      for (char c : w) {\\n        counted[c - \\'a\\'] = c;\\n      }\\n      transformed.push_back(counted);\\n    }\\n\\n    dsu ds(n);\\n    trie t;\\n    for (int i = 0; i < n; i++) {\\n      t.insert(transformed[i], ds, i);\\n    }\\n    for (int i = 0; i < n; i++) {\\n      t.search(transformed[i], ds, i, 0, 1, t.root, i + 1);\\n    }\\n\\n    return {ds.groups, ds.ans};\\n  }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Union Find",
                    "Trie"
                ],
                "code": "```cpp\\n#define vec vector\\n#define vi vector<int>\\n#define amax(x, y) x = max(x, y)\\n\\nstruct dsu {\\n  vec<int> parent, size;\\n  int ans = 1, groups = 0;\\n  dsu(int n) : parent(n), size(n, 1), groups(n) {\\n    for (int i = 0; i < n; i++)\\n      parent[i] = i;\\n  }\\n  int find(int i) {\\n    if (parent[i] == i)\\n      return i;\\n    return parent[i] = find(parent[i]);\\n  }\\n  void unite(int i, int j) {\\n    if (find(i) != find(j)) {\\n      int repi = find(i);\\n      int repj = find(j);\\n      if (size[repi] < size[repj])\\n        swap(repi, repj);\\n      parent[repj] = repi;\\n      size[repi] += size[repj];\\n      amax(ans, size[repi]);\\n      groups--;\\n    }\\n  }\\n};\\n\\nstruct trie {\\n  struct node {\\n    array<node *, 2> adj{};\\n    array<int, 4> vis{};\\n    vi pos;\\n  };\\n  node *root = new node();\\n  void insert(string &s, dsu &ds, int p) {\\n    auto cur = root;\\n    for (int i = 0; i < s.size(); i++) {\\n      auto &next = cur->adj[s[i] == \\' \\'];\\n      if (!next)\\n        next = new node();\\n      cur = next;\\n    }\\n    if (!cur->pos.empty()) {\\n      ds.unite(p, cur->pos.back());\\n    }\\n    cur->pos.push_back(p);\\n  }\\n  void search(string &s, dsu &ds, int p, int i, int state, node *cur,\\n              int vis_id) {\\n    cur->vis[state] = vis_id;\\n    if (i == s.size() && (state == 1 || state == 3)) {\\n      if (!cur->pos.empty()) {\\n        ds.unite(p, cur->pos.back());\\n      }\\n      return;\\n    }\\n\\n    if (state == 1) {\\n      if (cur->adj[0]) {\\n        if (cur->adj[0]->vis[3] != vis_id) {\\n          search(s, ds, p, i + 1, 3, cur->adj[0], vis_id);\\n        }\\n        if (cur->adj[0]->vis[2] != vis_id) {\\n          search(s, ds, p, i + 1, 2, cur->adj[0], vis_id);\\n        }\\n      }\\n    }\\n    if (state == 2) {\\n      auto next = cur->adj[1];\\n      if (next && next->vis[3] != vis_id) {\\n        search(s, ds, p, i + 1, 3, next, vis_id);\\n      }\\n    }\\n\\n    auto next = cur->adj[s[i] == \\' \\'];\\n    if (next && next->vis[state] != vis_id) {\\n      search(s, ds, p, i + 1, state, next, vis_id);\\n    }\\n  }\\n};\\n\\nclass Solution {\\npublic:\\n  vector<int> groupStrings(vector<string> &words) {\\n    int n = words.size();\\n    vec<string> transformed;\\n    for (auto &w : words) {\\n      string counted(26, \\' \\');\\n      for (char c : w) {\\n        counted[c - \\'a\\'] = c;\\n      }\\n      transformed.push_back(counted);\\n    }\\n\\n    dsu ds(n);\\n    trie t;\\n    for (int i = 0; i < n; i++) {\\n      t.insert(transformed[i], ds, i);\\n    }\\n    for (int i = 0; i < n; i++) {\\n      t.search(transformed[i], ds, i, 0, 1, t.root, i + 1);\\n    }\\n\\n    return {ds.groups, ds.ans};\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2432945,
                "title": "c-code-for-beginners-commented-code-worst-best",
                "content": "# WORST CODE, DFS, T.C.-O(N*N)  (TLE)\\n\\n```\\nclass Solution {\\nprivate:\\n    vector<int> adj[200001];\\npublic:\\n    bool canConnect(string &s1, string &s2){\\n        int n=s1.size();\\n        int m=s2.size();\\n        if(abs(n-m)>1){\\n            return false;\\n        }\\n        int difference=0;\\n        if(n==m){  // same character\\n            unordered_set<char> s(s1.begin(),s1.end());\\n            for(int i=0;i<m;i++){\\n                if(s.find(s2[i])==s.end()){\\n                    difference++;\\n                }\\n            }\\n            return difference<=1;\\n        }\\n        if(n>m){\\n            unordered_set<char> s(s1.begin(),s1.end());\\n            for(int i=0;i<m;i++){\\n                if(s.find(s2[i])==s.end()){\\n                    return false;\\n                }\\n            }\\n            return true;\\n        }\\n        unordered_set<char> s(s2.begin(),s2.end());\\n        for(int i=0;i<n;i++){\\n            if(s.find(s1[i])==s.end()){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    int dfs(int node, vector<bool> &vis){\\n        vis[node]=true;\\n        int res=0;\\n        for(auto nei: adj[node]){\\n            if(vis[nei]==false){\\n                res+=dfs(nei,vis);\\n            }\\n        }\\n        return 1+res;\\n    }\\n    \\n    vector<int> groupStrings(vector<string>& words) {\\n        for(int i=0;i<words.size();i++){\\n            for(int j=i+1;j<words.size();j++){\\n                if(canConnect(words[i],words[j])==true){\\n                    adj[i].push_back(j);\\n                    adj[j].push_back(i);\\n                }\\n            }\\n        }\\n        int size=0;\\n        int mx=0;\\n        vector<bool> vis(words.size(),false);\\n        for(int i=0;i<words.size();i++){\\n            if(vis[i]==false){\\n                int getSize=dfs(i,vis);\\n                mx=max(mx,getSize);\\n                size++;\\n            }\\n        }\\n        return {size,mx};\\n    }\\n};\\n```\\n\\n# UNOPTIMISED CODE, DFS, T.C. - O(N) (TLE) (USING FREQ ARRAY)\\n```\\nclass Solution {\\nprivate:\\n    vector<int> adj[200001];\\npublic:\\n    void isThere(map<vector<int>,int> &mpp, string &word, int index){\\n        vector<int> freq(26,0);\\n        for(auto c: word){\\n            freq[c-\\'a\\']++;\\n        }\\n        for(char ch=\\'a\\';ch<=\\'z\\';ch++){\\n            if(freq[ch-\\'a\\']==1){  // DELETE CASE\\n                freq[ch-\\'a\\']=0;\\n                if(mpp.find(freq)!=mpp.end()){\\n                    adj[index].push_back(mpp[freq]);\\n                    adj[mpp[freq]].push_back(index);\\n                }\\n                freq[ch-\\'a\\']=1;\\n            }\\n            else{  // INSERT CASE\\n                freq[ch-\\'a\\']=1;\\n                if(mpp.find(freq)!=mpp.end()){\\n                    adj[index].push_back(mpp[freq]);\\n                    adj[mpp[freq]].push_back(index);\\n                }\\n                freq[ch-\\'a\\']=0;\\n            }\\n        }\\n        for(char ch=\\'a\\';ch<=\\'z\\';ch++){  // REPLACEMENT CASE\\n            if(freq[ch-\\'a\\']==0){\\n                continue;\\n            }\\n            for(char CH=\\'a\\';CH<=\\'z\\';CH++){\\n                if(freq[CH-\\'a\\']==0){\\n                    freq[ch-\\'a\\']=0;\\n                    freq[CH-\\'a\\']=1;\\n                    if(mpp.find(freq)!=mpp.end()){\\n                        adj[index].push_back(mpp[freq]);\\n                        adj[mpp[freq]].push_back(index);\\n                    }\\n                    freq[ch-\\'a\\']=1;\\n                    freq[CH-\\'a\\']=0;\\n                }\\n            }\\n        }\\n        if(mpp.find(freq)!=mpp.end()){\\n            adj[index].push_back(mpp[freq]);\\n            adj[mpp[freq]].push_back(index);\\n        }\\n        mpp[freq]=index;\\n    }\\n    \\n    int dfs(int node, vector<bool> &vis){\\n        vis[node]=true;\\n        int res=0;\\n        for(auto nei: adj[node]){\\n            if(vis[nei]==false){\\n                res+=dfs(nei,vis);\\n            }\\n        }\\n        return 1+res;\\n    }\\n    \\n    vector<int> groupStrings(vector<string>& words) {\\n        map<vector<int>,int> mpp;\\n        for(int i=0;i<words.size();i++){\\n            isThere(mpp,words[i],i);\\n        }\\n        \\n        int size=0;\\n        int mx=0;\\n        vector<bool> vis(words.size(),false);\\n        for(int i=0;i<words.size();i++){\\n            if(vis[i]==false){\\n                int getSize=dfs(i,vis);\\n                mx=max(mx,getSize);\\n                size++;\\n            }\\n        }\\n        return {size,mx};\\n    }\\n};\\n```\\n# UNOPTIMISED CODE, DFS, T.C. - O(N) (PASSED) (USING BITSET)\\n```\\nclass Solution {\\nprivate:\\n    vector<int> adj[200001];\\npublic:\\n    void isThere(unordered_map<int,int> &mpp, string &word, int index){\\n        int mask=0;\\n        for(auto c: word){\\n            mask=mask | (1<<(c-\\'a\\'));\\n        }\\n        for(char ch=\\'a\\';ch<=\\'z\\';ch++){\\n            int newMask=mask ^ (1<<(ch-\\'a\\'));\\n            if(mpp.find(newMask)!=mpp.end()){\\n                adj[index].push_back(mpp[newMask]);\\n                adj[mpp[newMask]].push_back(index);\\n            }\\n        }\\n        for(char ch=\\'a\\';ch<=\\'z\\';ch++){\\n            if((mask & (1<<(ch-\\'a\\')))==0){\\n                continue;\\n            }\\n            for(char CH=\\'a\\';CH<=\\'z\\';CH++){\\n                if((mask & (1<<(CH-\\'a\\')))==0){\\n                    int newMask=mask;\\n                    newMask=newMask ^ (1<<(ch-\\'a\\'));\\n                    newMask=newMask ^ (1<<(CH-\\'a\\'));\\n                    if(mpp.find(newMask)!=mpp.end()){\\n                        adj[index].push_back(mpp[newMask]);\\n                        adj[mpp[newMask]].push_back(index);\\n                    }\\n                }\\n            }\\n        }\\n        if(mpp.find(mask)!=mpp.end()){\\n            adj[index].push_back(mpp[mask]);\\n            adj[mpp[mask]].push_back(index);\\n        }\\n        mpp[mask]=index;\\n    }\\n    \\n    int dfs(int node, vector<bool> &vis){\\n        vis[node]=true;\\n        int res=0;\\n        for(auto nei: adj[node]){\\n            if(vis[nei]==false){\\n                res+=dfs(nei,vis);\\n            }\\n        }\\n        return 1+res;\\n    }\\n    \\n    vector<int> groupStrings(vector<string>& words) {\\n        unordered_map<int,int> mpp;\\n        for(int i=0;i<words.size();i++){\\n            isThere(mpp,words[i],i);\\n        }\\n        \\n        int size=0;\\n        int mx=0;\\n        vector<bool> vis(words.size(),false);\\n        for(int i=0;i<words.size();i++){\\n            if(vis[i]==false){\\n                int getSize=dfs(i,vis);\\n                mx=max(mx,getSize);\\n                size++;\\n            }\\n        }\\n        return {size,mx};\\n    }\\n};\\n```\\n\\n# OPTIMISED CODE, UNION FIND, TC-O(N) PASSED\\n```\\nclass Solution {\\nprivate:\\n    vector<int> parent;\\n    vector<int> rank;\\npublic:\\n    int find(int node){\\n        if(parent[node]==node){\\n            return node;\\n        }\\n        return parent[node]=find(parent[node]);\\n    }\\n    \\n    void UNION(int node1, int node2){\\n        int Pnode1=find(node1);\\n        int Pnode2=find(node2);\\n        if(Pnode1==Pnode2){\\n            return;\\n        }\\n        if(rank[Pnode1]>rank[Pnode2]){\\n            parent[Pnode2]=Pnode1;\\n        }\\n        else if(rank[Pnode1]<rank[Pnode2]){\\n            parent[Pnode1]=Pnode2;\\n        }\\n        if(rank[Pnode1]==rank[Pnode2]){\\n            parent[Pnode1]=Pnode2;\\n            rank[Pnode2]++;\\n        }\\n    }\\n    \\n    vector<int> groupStrings(vector<string>& words) {\\n        int n=words.size();\\n        parent.resize(n,-1);\\n        rank.resize(n,0);\\n        for(int i=0;i<n;i++){\\n            parent[i]=i;\\n        }\\n        unordered_map<int,int> mpp;\\n        \\n        for(int i=0;i<n;i++){\\n            int mask=0;\\n            for(auto c: words[i]){\\n                mask=mask | (1<<(c-\\'a\\'));  // MASK CREATED\\n            }\\n            for(char ch=\\'a\\';ch<=\\'z\\';ch++){  // takes care of deletion or addition\\n                int newMask=mask ^ (1<<(ch-\\'a\\'));  // TOGGLING ch in MASK, if set->unset,or,unsert->set\\n                if(mpp.find(newMask)!=mpp.end()){  // if newmask is present in mpp\\n                    UNION(i,mpp[newMask]);  //union\\n                }\\n            }\\n            \\n            for(char ch=\\'a\\';ch<=\\'z\\';ch++){  // replacement\\n                if((mask & (1<<(ch-\\'a\\')))==0){  // unset bit, ch not present in words[i]\\n                    continue;\\n                }\\n                for(char CH=\\'a\\';CH<=\\'z\\';CH++){  // trying CH inplace of ch\\n                    if((mask & 1<<(CH-\\'a\\'))==0){// CH is unset, so not present in words[i], we can try this\\n                        int newMask=mask;\\n                        newMask=newMask ^ (1<<(ch-\\'a\\'));  // toggle ch, and unset it, hence delete it\\n                        newMask=newMask ^ (1<<(CH-\\'a\\')); // toggle CH, and set it, hence place it\\n                        if(mpp.find(newMask)!=mpp.end()){  // if this newmask is seen somewhere\\n                            UNION(i,mpp[newMask]);  //union\\n                        }\\n                    }\\n                }\\n            }\\n            if(mpp.find(mask)!=mpp.end()){   // if without no chances, mask is present, i.e. for examples like                                                                                   [\"a\",\"b\",\"ab\",\"cde\",\"cde\",\"cde\",\"cde\"] , having duplicates \\n                UNION(i,mpp[mask]);\\n            }\\n            mpp[mask]=i;  // mark it in the map\\n        }\\n        \\n        \\n        unordered_map<int,int> groups;\\n        for(int i=0;i<n;i++){\\n            groups[find(i)]++;  // find parent and increment \\n        }\\n        int maxSize=0;\\n        for(auto m: groups){\\n            maxSize=max(maxSize,m.second);  // find max size component\\n        }\\n        vector<int> res={(int)groups.size(),maxSize};\\n        return res;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Union Find",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    vector<int> adj[200001];\\npublic:\\n    bool canConnect(string &s1, string &s2){\\n        int n=s1.size();\\n        int m=s2.size();\\n        if(abs(n-m)>1){\\n            return false;\\n        }\\n        int difference=0;\\n        if(n==m){  // same character\\n            unordered_set<char> s(s1.begin(),s1.end());\\n            for(int i=0;i<m;i++){\\n                if(s.find(s2[i])==s.end()){\\n                    difference++;\\n                }\\n            }\\n            return difference<=1;\\n        }\\n        if(n>m){\\n            unordered_set<char> s(s1.begin(),s1.end());\\n            for(int i=0;i<m;i++){\\n                if(s.find(s2[i])==s.end()){\\n                    return false;\\n                }\\n            }\\n            return true;\\n        }\\n        unordered_set<char> s(s2.begin(),s2.end());\\n        for(int i=0;i<n;i++){\\n            if(s.find(s1[i])==s.end()){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    int dfs(int node, vector<bool> &vis){\\n        vis[node]=true;\\n        int res=0;\\n        for(auto nei: adj[node]){\\n            if(vis[nei]==false){\\n                res+=dfs(nei,vis);\\n            }\\n        }\\n        return 1+res;\\n    }\\n    \\n    vector<int> groupStrings(vector<string>& words) {\\n        for(int i=0;i<words.size();i++){\\n            for(int j=i+1;j<words.size();j++){\\n                if(canConnect(words[i],words[j])==true){\\n                    adj[i].push_back(j);\\n                    adj[j].push_back(i);\\n                }\\n            }\\n        }\\n        int size=0;\\n        int mx=0;\\n        vector<bool> vis(words.size(),false);\\n        for(int i=0;i<words.size();i++){\\n            if(vis[i]==false){\\n                int getSize=dfs(i,vis);\\n                mx=max(mx,getSize);\\n                size++;\\n            }\\n        }\\n        return {size,mx};\\n    }\\n};\\n```\n```\\nclass Solution {\\nprivate:\\n    vector<int> adj[200001];\\npublic:\\n    void isThere(map<vector<int>,int> &mpp, string &word, int index){\\n        vector<int> freq(26,0);\\n        for(auto c: word){\\n            freq[c-\\'a\\']++;\\n        }\\n        for(char ch=\\'a\\';ch<=\\'z\\';ch++){\\n            if(freq[ch-\\'a\\']==1){  // DELETE CASE\\n                freq[ch-\\'a\\']=0;\\n                if(mpp.find(freq)!=mpp.end()){\\n                    adj[index].push_back(mpp[freq]);\\n                    adj[mpp[freq]].push_back(index);\\n                }\\n                freq[ch-\\'a\\']=1;\\n            }\\n            else{  // INSERT CASE\\n                freq[ch-\\'a\\']=1;\\n                if(mpp.find(freq)!=mpp.end()){\\n                    adj[index].push_back(mpp[freq]);\\n                    adj[mpp[freq]].push_back(index);\\n                }\\n                freq[ch-\\'a\\']=0;\\n            }\\n        }\\n        for(char ch=\\'a\\';ch<=\\'z\\';ch++){  // REPLACEMENT CASE\\n            if(freq[ch-\\'a\\']==0){\\n                continue;\\n            }\\n            for(char CH=\\'a\\';CH<=\\'z\\';CH++){\\n                if(freq[CH-\\'a\\']==0){\\n                    freq[ch-\\'a\\']=0;\\n                    freq[CH-\\'a\\']=1;\\n                    if(mpp.find(freq)!=mpp.end()){\\n                        adj[index].push_back(mpp[freq]);\\n                        adj[mpp[freq]].push_back(index);\\n                    }\\n                    freq[ch-\\'a\\']=1;\\n                    freq[CH-\\'a\\']=0;\\n                }\\n            }\\n        }\\n        if(mpp.find(freq)!=mpp.end()){\\n            adj[index].push_back(mpp[freq]);\\n            adj[mpp[freq]].push_back(index);\\n        }\\n        mpp[freq]=index;\\n    }\\n    \\n    int dfs(int node, vector<bool> &vis){\\n        vis[node]=true;\\n        int res=0;\\n        for(auto nei: adj[node]){\\n            if(vis[nei]==false){\\n                res+=dfs(nei,vis);\\n            }\\n        }\\n        return 1+res;\\n    }\\n    \\n    vector<int> groupStrings(vector<string>& words) {\\n        map<vector<int>,int> mpp;\\n        for(int i=0;i<words.size();i++){\\n            isThere(mpp,words[i],i);\\n        }\\n        \\n        int size=0;\\n        int mx=0;\\n        vector<bool> vis(words.size(),false);\\n        for(int i=0;i<words.size();i++){\\n            if(vis[i]==false){\\n                int getSize=dfs(i,vis);\\n                mx=max(mx,getSize);\\n                size++;\\n            }\\n        }\\n        return {size,mx};\\n    }\\n};\\n```\n```\\nclass Solution {\\nprivate:\\n    vector<int> adj[200001];\\npublic:\\n    void isThere(unordered_map<int,int> &mpp, string &word, int index){\\n        int mask=0;\\n        for(auto c: word){\\n            mask=mask | (1<<(c-\\'a\\'));\\n        }\\n        for(char ch=\\'a\\';ch<=\\'z\\';ch++){\\n            int newMask=mask ^ (1<<(ch-\\'a\\'));\\n            if(mpp.find(newMask)!=mpp.end()){\\n                adj[index].push_back(mpp[newMask]);\\n                adj[mpp[newMask]].push_back(index);\\n            }\\n        }\\n        for(char ch=\\'a\\';ch<=\\'z\\';ch++){\\n            if((mask & (1<<(ch-\\'a\\')))==0){\\n                continue;\\n            }\\n            for(char CH=\\'a\\';CH<=\\'z\\';CH++){\\n                if((mask & (1<<(CH-\\'a\\')))==0){\\n                    int newMask=mask;\\n                    newMask=newMask ^ (1<<(ch-\\'a\\'));\\n                    newMask=newMask ^ (1<<(CH-\\'a\\'));\\n                    if(mpp.find(newMask)!=mpp.end()){\\n                        adj[index].push_back(mpp[newMask]);\\n                        adj[mpp[newMask]].push_back(index);\\n                    }\\n                }\\n            }\\n        }\\n        if(mpp.find(mask)!=mpp.end()){\\n            adj[index].push_back(mpp[mask]);\\n            adj[mpp[mask]].push_back(index);\\n        }\\n        mpp[mask]=index;\\n    }\\n    \\n    int dfs(int node, vector<bool> &vis){\\n        vis[node]=true;\\n        int res=0;\\n        for(auto nei: adj[node]){\\n            if(vis[nei]==false){\\n                res+=dfs(nei,vis);\\n            }\\n        }\\n        return 1+res;\\n    }\\n    \\n    vector<int> groupStrings(vector<string>& words) {\\n        unordered_map<int,int> mpp;\\n        for(int i=0;i<words.size();i++){\\n            isThere(mpp,words[i],i);\\n        }\\n        \\n        int size=0;\\n        int mx=0;\\n        vector<bool> vis(words.size(),false);\\n        for(int i=0;i<words.size();i++){\\n            if(vis[i]==false){\\n                int getSize=dfs(i,vis);\\n                mx=max(mx,getSize);\\n                size++;\\n            }\\n        }\\n        return {size,mx};\\n    }\\n};\\n```\n```\\nclass Solution {\\nprivate:\\n    vector<int> parent;\\n    vector<int> rank;\\npublic:\\n    int find(int node){\\n        if(parent[node]==node){\\n            return node;\\n        }\\n        return parent[node]=find(parent[node]);\\n    }\\n    \\n    void UNION(int node1, int node2){\\n        int Pnode1=find(node1);\\n        int Pnode2=find(node2);\\n        if(Pnode1==Pnode2){\\n            return;\\n        }\\n        if(rank[Pnode1]>rank[Pnode2]){\\n            parent[Pnode2]=Pnode1;\\n        }\\n        else if(rank[Pnode1]<rank[Pnode2]){\\n            parent[Pnode1]=Pnode2;\\n        }\\n        if(rank[Pnode1]==rank[Pnode2]){\\n            parent[Pnode1]=Pnode2;\\n            rank[Pnode2]++;\\n        }\\n    }\\n    \\n    vector<int> groupStrings(vector<string>& words) {\\n        int n=words.size();\\n        parent.resize(n,-1);\\n        rank.resize(n,0);\\n        for(int i=0;i<n;i++){\\n            parent[i]=i;\\n        }\\n        unordered_map<int,int> mpp;\\n        \\n        for(int i=0;i<n;i++){\\n            int mask=0;\\n            for(auto c: words[i]){\\n                mask=mask | (1<<(c-\\'a\\'));  // MASK CREATED\\n            }\\n            for(char ch=\\'a\\';ch<=\\'z\\';ch++){  // takes care of deletion or addition\\n                int newMask=mask ^ (1<<(ch-\\'a\\'));  // TOGGLING ch in MASK, if set->unset,or,unsert->set\\n                if(mpp.find(newMask)!=mpp.end()){  // if newmask is present in mpp\\n                    UNION(i,mpp[newMask]);  //union\\n                }\\n            }\\n            \\n            for(char ch=\\'a\\';ch<=\\'z\\';ch++){  // replacement\\n                if((mask & (1<<(ch-\\'a\\')))==0){  // unset bit, ch not present in words[i]\\n                    continue;\\n                }\\n                for(char CH=\\'a\\';CH<=\\'z\\';CH++){  // trying CH inplace of ch\\n                    if((mask & 1<<(CH-\\'a\\'))==0){// CH is unset, so not present in words[i], we can try this\\n                        int newMask=mask;\\n                        newMask=newMask ^ (1<<(ch-\\'a\\'));  // toggle ch, and unset it, hence delete it\\n                        newMask=newMask ^ (1<<(CH-\\'a\\')); // toggle CH, and set it, hence place it\\n                        if(mpp.find(newMask)!=mpp.end()){  // if this newmask is seen somewhere\\n                            UNION(i,mpp[newMask]);  //union\\n                        }\\n                    }\\n                }\\n            }\\n            if(mpp.find(mask)!=mpp.end()){   // if without no chances, mask is present, i.e. for examples like                                                                                   [\"a\",\"b\",\"ab\",\"cde\",\"cde\",\"cde\",\"cde\"] , having duplicates \\n                UNION(i,mpp[mask]);\\n            }\\n            mpp[mask]=i;  // mark it in the map\\n        }\\n        \\n        \\n        unordered_map<int,int> groups;\\n        for(int i=0;i<n;i++){\\n            groups[find(i)]++;  // find parent and increment \\n        }\\n        int maxSize=0;\\n        for(auto m: groups){\\n            maxSize=max(maxSize,m.second);  // find max size component\\n        }\\n        vector<int> res={(int)groups.size(),maxSize};\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2419011,
                "title": "ruby-no-tle",
                "content": "```\\ndef group_strings(words)\\n\\n  # strings to nums\\n  set = words.map!{|w| w.chars.sum{ 1.<<_1.sum-97 } }.to_set\\n\\n  # build proximity graph\\n  graph, proxy = {}, {}\\n  set.each{|e| 26.times{ next if e[_1]>0\\n    x = e^1<<_1\\n    (pr=proxy[x]||=[])<<e and pr[1] and x=pr.shift if not set.include? x\\n    (graph[e]||=[])<<x and (graph[x]||=[])<<e if set.include? x\\n  } }\\n  \\n  # traverse the graph to group the nodes\\n  group = {}.tap{|h| set.each &visit = -> e,g=e{ not h[e] and h[e]=g and graph[e]&.each{ visit[_1,g] } } }\\n  \\n  # result\\n  words.map(&group).tally.then{[_1.size, _1.values.max]}\\n  \\nend\\n```",
                "solutionTags": [],
                "code": "```\\ndef group_strings(words)\\n\\n  # strings to nums\\n  set = words.map!{|w| w.chars.sum{ 1.<<_1.sum-97 } }.to_set\\n\\n  # build proximity graph\\n  graph, proxy = {}, {}\\n  set.each{|e| 26.times{ next if e[_1]>0\\n    x = e^1<<_1\\n    (pr=proxy[x]||=[])<<e and pr[1] and x=pr.shift if not set.include? x\\n    (graph[e]||=[])<<x and (graph[x]||=[])<<e if set.include? x\\n  } }\\n  \\n  # traverse the graph to group the nodes\\n  group = {}.tap{|h| set.each &visit = -> e,g=e{ not h[e] and h[e]=g and graph[e]&.each{ visit[_1,g] } } }\\n  \\n  # result\\n  words.map(&group).tally.then{[_1.size, _1.values.max]}\\n  \\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2340769,
                "title": "python-union-find-o-n-26",
                "content": "```python\\nfrom collections import Counter, defaultdict\\nclass Solution:\\n    def groupStrings(self, words: List[str]) -> List[int]:\\n      def f(x):\\n        return sum(1<<ord(i)-97 for i in x)\\n\\n      B = defaultdict(list)\\n      size = Counter(map(f, words))\\n      p = {}\\n        \\n      def find(a):\\n        if p.get(a,a) != a:\\n          p[a] = find(p[a]) \\n        return p.get(a,a)\\n\\n      def union(a,b):\\n        a,b = find(a), find(b)\\n        if a != b and b in size:\\n          if size[a] > size[b]:\\n            a,b = b,a\\n          p[a] = b \\n          size[b] += size[a] \\n          del size[a]\\n\\n      for i in list(size.keys()):\\n        for j in range(26):\\n          union(i, i ^ (1<<j))\\n          if (i>>j) & 1:\\n            for x in B[i^(1<<j)]:\\n                union(i,x)\\n            B[i^(1<<j)].append(i)\\n    \\n      return len(size), max(size.values())\\n```",
                "solutionTags": [],
                "code": "```python\\nfrom collections import Counter, defaultdict\\nclass Solution:\\n    def groupStrings(self, words: List[str]) -> List[int]:\\n      def f(x):\\n        return sum(1<<ord(i)-97 for i in x)\\n\\n      B = defaultdict(list)\\n      size = Counter(map(f, words))\\n      p = {}\\n        \\n      def find(a):\\n        if p.get(a,a) != a:\\n          p[a] = find(p[a]) \\n        return p.get(a,a)\\n\\n      def union(a,b):\\n        a,b = find(a), find(b)\\n        if a != b and b in size:\\n          if size[a] > size[b]:\\n            a,b = b,a\\n          p[a] = b \\n          size[b] += size[a] \\n          del size[a]\\n\\n      for i in list(size.keys()):\\n        for j in range(26):\\n          union(i, i ^ (1<<j))\\n          if (i>>j) & 1:\\n            for x in B[i^(1<<j)]:\\n                union(i,x)\\n            B[i^(1<<j)].append(i)\\n    \\n      return len(size), max(size.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2279838,
                "title": "c-union-find-bitmask-easy-to-understand",
                "content": "Tips: Add/Delete/Replace can be classified to 2 ways:\\n1. Add 1 char of a shorter string is same to Delete 1 char of a longer string. \\n1. Replace any char.\\n\\n```\\n        public int[] GroupStrings(string[] words)\\n        {\\n            int n= words.Length;\\n            var uf = new UnionFind(n);\\n\\t\\t\\t//group all words to diffierent length\\n            var dict = new Dictionary<int, Dictionary<int,int>>();//store {len, {bit, index}} pairs\\n            for (int i = 0; i < n; i++)\\n            {\\n                int len = words[i].Length;\\n                int bit = 0;//must convert to bit, or TLE\\n                foreach(var c in words[i])\\n                    bit |= 1 << (c - \\'a\\');\\n                if (!dict.ContainsKey(len))\\n                    dict.Add(len, new Dictionary<int, int>());\\n                if (dict[len].ContainsKey(bit))\\n                    uf.Union(dict[len][bit], i);//union duplicates\\n                else dict[len].Add(bit,i);\\n            }\\n            //union all replace pairs of same length\\n            foreach(var i in dict.Keys)\\n            {\\n                var keys = dict[i].Keys.ToList();\\n                for(int k1 = 0; k1 < keys.Count-1; k1++)\\n                {\\n                    for (int k2 = k1+1; k2 < keys.Count; k2++)\\n                    {\\n                        if (GroupStrings_Ones(keys[k1] ^ keys[k2]) == 2)//all replace pairs contain 2 ones of their xor\\n                            uf.Union(dict[i][keys[k1]], dict[i][keys[k2]]);\\n                    }\\n                }\\n            }\\n            //union all delete pairs of 1 length diff, this is very important to reduce O(n1*n2) to O(n1*26) , n1,n2 is count of same length words of i,i-1\\n            for (int i = 1; i <= 26; i++)\\n            {\\n                if (!dict.ContainsKey(i) || !dict.ContainsKey(i - 1)) continue;\\n                foreach(var num in dict[i].Keys)\\n                {\\n                    for(int j = 0; j < 26; j++)\\n                    {\\n                        if((num & (1 << j)) != 0)// if current bit is 1\\n                        {\\n                            int delete = num & (~(1 << j));//try to find if delete exist\\n                            if (dict[i - 1].ContainsKey(delete))\\n                                uf.Union(dict[i][num], dict[i - 1][delete]);\\n                        }\\n                    }\\n                }\\n            }\\n            int maxCount = 0;\\n            HashSet<int> indexSet = new HashSet<int>();\\n            int[] arr = new int[n];\\n            for(int i = 0; i < n; i++)\\n            {\\n                int k = uf.Find(i);\\n                indexSet.Add(k);\\n                maxCount = Math.Max(maxCount, ++arr[k]);\\n            }\\n            return new int[] { indexSet.Count, maxCount };\\n        }\\n\\t\\t\\n        private int GroupStrings_Ones(int n)\\n        {\\n            int count = 0;\\n            int seed = 1;\\n            for(int i = 0; i < 26 && count <=2; i++)\\n            {\\n                if ((n & (seed)) != 0) count++;\\n                seed<<=1;\\n            }\\n            return count;\\n        }\\n\\t\\tpublic class UnionFind\\n\\t\\t{\\n\\t\\t\\tpublic int[] parent;\\n\\t\\t\\tpublic int[] rank;\\n\\t\\t\\tpublic int GroupCount;\\n\\t\\t\\tpublic UnionFind(int n)\\n\\t\\t\\t{\\n\\t\\t\\t\\tGroupCount = n;\\n\\t\\t\\t\\tparent = new int[n];\\n\\t\\t\\t\\trank = new int[n];\\n\\t\\t\\t\\tfor(int i = 0; i < n; i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tparent[i] = i;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tpublic int Find(int i)\\n\\t\\t\\t{\\n\\t\\t\\t\\twhile (parent[i] != i)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\ti=parent[i];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn i;\\n\\t\\t\\t}\\n\\n\\t\\t\\tpublic bool IsConnected(int x, int y)\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn Find(x) == Find(y);\\n\\t\\t\\t}\\n\\n\\t\\t\\tpublic void Union(int p, int q)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint rootP = Find(p);\\n\\t\\t\\t\\tint rootQ = Find(q);\\n\\t\\t\\t\\tif (rootP == rootQ) return;\\n\\t\\t\\t\\tif (rank[rootQ] > rank[rootP])\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tparent[rootP] = rootQ;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tparent[rootQ] = rootP;\\n\\t\\t\\t\\t\\tif (rank[rootP] == rank[rootQ])\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\trank[rootP]++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tGroupCount--;\\n\\t\\t\\t}\\n    }\\n\\n```",
                "solutionTags": [],
                "code": "```\\n        public int[] GroupStrings(string[] words)\\n        {\\n            int n= words.Length;\\n            var uf = new UnionFind(n);\\n\\t\\t\\t//group all words to diffierent length\\n            var dict = new Dictionary<int, Dictionary<int,int>>();//store {len, {bit, index}} pairs\\n            for (int i = 0; i < n; i++)\\n            {\\n                int len = words[i].Length;\\n                int bit = 0;//must convert to bit, or TLE\\n                foreach(var c in words[i])\\n                    bit |= 1 << (c - \\'a\\');\\n                if (!dict.ContainsKey(len))\\n                    dict.Add(len, new Dictionary<int, int>());\\n                if (dict[len].ContainsKey(bit))\\n                    uf.Union(dict[len][bit], i);//union duplicates\\n                else dict[len].Add(bit,i);\\n            }\\n            //union all replace pairs of same length\\n            foreach(var i in dict.Keys)\\n            {\\n                var keys = dict[i].Keys.ToList();\\n                for(int k1 = 0; k1 < keys.Count-1; k1++)\\n                {\\n                    for (int k2 = k1+1; k2 < keys.Count; k2++)\\n                    {\\n                        if (GroupStrings_Ones(keys[k1] ^ keys[k2]) == 2)//all replace pairs contain 2 ones of their xor\\n                            uf.Union(dict[i][keys[k1]], dict[i][keys[k2]]);\\n                    }\\n                }\\n            }\\n            //union all delete pairs of 1 length diff, this is very important to reduce O(n1*n2) to O(n1*26) , n1,n2 is count of same length words of i,i-1\\n            for (int i = 1; i <= 26; i++)\\n            {\\n                if (!dict.ContainsKey(i) || !dict.ContainsKey(i - 1)) continue;\\n                foreach(var num in dict[i].Keys)\\n                {\\n                    for(int j = 0; j < 26; j++)\\n                    {\\n                        if((num & (1 << j)) != 0)// if current bit is 1\\n                        {\\n                            int delete = num & (~(1 << j));//try to find if delete exist\\n                            if (dict[i - 1].ContainsKey(delete))\\n                                uf.Union(dict[i][num], dict[i - 1][delete]);\\n                        }\\n                    }\\n                }\\n            }\\n            int maxCount = 0;\\n            HashSet<int> indexSet = new HashSet<int>();\\n            int[] arr = new int[n];\\n            for(int i = 0; i < n; i++)\\n            {\\n                int k = uf.Find(i);\\n                indexSet.Add(k);\\n                maxCount = Math.Max(maxCount, ++arr[k]);\\n            }\\n            return new int[] { indexSet.Count, maxCount };\\n        }\\n\\t\\t\\n        private int GroupStrings_Ones(int n)\\n        {\\n            int count = 0;\\n            int seed = 1;\\n            for(int i = 0; i < 26 && count <=2; i++)\\n            {\\n                if ((n & (seed)) != 0) count++;\\n                seed<<=1;\\n            }\\n            return count;\\n        }\\n\\t\\tpublic class UnionFind\\n\\t\\t{\\n\\t\\t\\tpublic int[] parent;\\n\\t\\t\\tpublic int[] rank;\\n\\t\\t\\tpublic int GroupCount;\\n\\t\\t\\tpublic UnionFind(int n)\\n\\t\\t\\t{\\n\\t\\t\\t\\tGroupCount = n;\\n\\t\\t\\t\\tparent = new int[n];\\n\\t\\t\\t\\trank = new int[n];\\n\\t\\t\\t\\tfor(int i = 0; i < n; i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tparent[i] = i;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tpublic int Find(int i)\\n\\t\\t\\t{\\n\\t\\t\\t\\twhile (parent[i] != i)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\ti=parent[i];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn i;\\n\\t\\t\\t}\\n\\n\\t\\t\\tpublic bool IsConnected(int x, int y)\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn Find(x) == Find(y);\\n\\t\\t\\t}\\n\\n\\t\\t\\tpublic void Union(int p, int q)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint rootP = Find(p);\\n\\t\\t\\t\\tint rootQ = Find(q);\\n\\t\\t\\t\\tif (rootP == rootQ) return;\\n\\t\\t\\t\\tif (rank[rootQ] > rank[rootP])\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tparent[rootP] = rootQ;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tparent[rootQ] = rootP;\\n\\t\\t\\t\\t\\tif (rank[rootP] == rank[rootQ])\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\trank[rootP]++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tGroupCount--;\\n\\t\\t\\t}\\n    }\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2215021,
                "title": "python-no-bitmask-union-find",
                "content": "```\\nclass Solution:\\n    def groupStrings(self, words: List[str]) -> List[int]:\\n        def par(i):\\n            if i not in p:\\n                p[i]=i\\n            while i!=p[i]:\\n                i=p[i]\\n            return i\\n        def union(i,j):\\n            i=par(i)\\n            j=par(j)\\n            if i<j:\\n                p[i]=j\\n            else:\\n                p[j]=i\\n        p={}\\n        words=[\"\".join(sorted(x)) for x in words]\\n        for x in words:\\n            for j in (x[:k]+\\'*\\'+x[k:] for k in range(len(x)+1)):\\n                union(x,j)\\n            for j in (x[:k]+x[k+1:] for k in range(len(x))):\\n                union(x,j)\\n        f=Counter([par(i) for i in words])\\n        return [len(f),max(f.values())]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def groupStrings(self, words: List[str]) -> List[int]:\\n        def par(i):\\n            if i not in p:\\n                p[i]=i\\n            while i!=p[i]:\\n                i=p[i]\\n            return i\\n        def union(i,j):\\n            i=par(i)\\n            j=par(j)\\n            if i<j:\\n                p[i]=j\\n            else:\\n                p[j]=i\\n        p={}\\n        words=[\"\".join(sorted(x)) for x in words]\\n        for x in words:\\n            for j in (x[:k]+\\'*\\'+x[k:] for k in range(len(x)+1)):\\n                union(x,j)\\n            for j in (x[:k]+x[k+1:] for k in range(len(x))):\\n                union(x,j)\\n        f=Counter([par(i) for i in words])\\n        return [len(f),max(f.values())]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2120420,
                "title": "python-simple-union-find-implementation-with-thought-process-when-being-asked-during-interviews",
                "content": "### Union & Find + Bitmask\\nBrainlessly think of union & find whenever you see terms of connectivity, group and size. \\nThe next problem is how we union and represent nodes. Note only lowercase letter appear and only appear once in any string, which indicates us that bitmask is the data structure we have to use since unique letter can be flagged using less than 32 bits.\\n\\nThe left work is simple, we convert each word to bitmask, and `xor` each bit to get the bitmask by adding and removing letters. Note we don\\'t split adding and removing, because `xor` handles the adding and removing cases respectively. \\n\\nThe replacement case looks a bit harder, but we can run another round to replace the existing letter with all the other ones. the number of letters is limited, we still can treat them linear. \\n\\nNote, one trick here is that we can replace each of letters to one special letter that doesn\\'t exist in any string, meaning the 27 bit, with this we don\\'t have to iterate each letter to replace.\\n\\nFinally, we use counter to deal with duplicate words.\\n\\n```python\\ndef groupStrings(self, words: List[str]) -> List[int]:\\n\\tdef find(node):\\n\\t\\twhile node != heads[node]:\\n\\t\\t\\theads[node] = heads[heads[node]]\\n\\t\\t\\tnode = heads[node]\\n\\t\\treturn node\\n        \\n\\tdef union(i, j):\\n\\t\\ti, j = find(i), find(j)\\n\\t\\tif i != j:\\n\\t\\t\\tif i < j:\\n\\t\\t\\t\\ti, j = j, i\\n\\t\\t\\theads[j] = i\\n\\t\\t\\tsizes[i] += sizes[j]\\n            \\n\\tcounter = Counter(map(lambda word: reduce(lambda k, c: k | 1 << (ord(c) - ord(\\'a\\')), word, 0), words))\\n\\tkeys = list(counter.keys())\\n\\tn = len(keys)\\n\\theads = list(range(n))\\n\\tsizes = list(counter.values())\\n\\tindices = {k: i for i, k in enumerate(keys)}\\n        \\n\\tfor i, key in enumerate(keys):\\n\\t\\tfor c in range(26):\\n\\t\\t\\tif key ^ (1 << c) in indices:\\n\\t\\t\\t\\tunion(i, indices[key ^ (1 << c)])\\n\\t\\t\\tif key & (1 << c):\\n\\t\\t\\t\\tfor r in range(26):\\n\\t\\t\\t\\t\\tif not key & (1 << r) and key ^ (1 << c) ^ (1 << r) in indices:\\n\\t\\t\\t\\t\\t\\tunion(i, indices[key ^ (1 << c) ^ (1 << r)])\\n        \\n\\tseen = set()\\n\\tfor i in range(n):\\n\\t\\tseen.add(find(i))\\n\\treturn len(seen), max(sizes)\\n```\\n\\n*Time Complexity*= **O(NlgN)**\\n*Space Complexity* = **O(N)**",
                "solutionTags": [
                    "Union Find",
                    "Bitmask"
                ],
                "code": "```python\\ndef groupStrings(self, words: List[str]) -> List[int]:\\n\\tdef find(node):\\n\\t\\twhile node != heads[node]:\\n\\t\\t\\theads[node] = heads[heads[node]]\\n\\t\\t\\tnode = heads[node]\\n\\t\\treturn node\\n        \\n\\tdef union(i, j):\\n\\t\\ti, j = find(i), find(j)\\n\\t\\tif i != j:\\n\\t\\t\\tif i < j:\\n\\t\\t\\t\\ti, j = j, i\\n\\t\\t\\theads[j] = i\\n\\t\\t\\tsizes[i] += sizes[j]\\n            \\n\\tcounter = Counter(map(lambda word: reduce(lambda k, c: k | 1 << (ord(c) - ord(\\'a\\')), word, 0), words))\\n\\tkeys = list(counter.keys())\\n\\tn = len(keys)\\n\\theads = list(range(n))\\n\\tsizes = list(counter.values())\\n\\tindices = {k: i for i, k in enumerate(keys)}\\n        \\n\\tfor i, key in enumerate(keys):\\n\\t\\tfor c in range(26):\\n\\t\\t\\tif key ^ (1 << c) in indices:\\n\\t\\t\\t\\tunion(i, indices[key ^ (1 << c)])\\n\\t\\t\\tif key & (1 << c):\\n\\t\\t\\t\\tfor r in range(26):\\n\\t\\t\\t\\t\\tif not key & (1 << r) and key ^ (1 << c) ^ (1 << r) in indices:\\n\\t\\t\\t\\t\\t\\tunion(i, indices[key ^ (1 << c) ^ (1 << r)])\\n        \\n\\tseen = set()\\n\\tfor i in range(n):\\n\\t\\tseen.add(find(i))\\n\\treturn len(seen), max(sizes)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2078832,
                "title": "c-union-find",
                "content": "**this version easy to understand but it sometime have TLE**\\nRuntime: 1512 ms, faster than 40.72% of C++ online submissions for Groups of Strings.\\nMemory Usage: 207.8 MB, less than 5.39% of C++ online submissions for Groups of Strings.\\n```\\nclass Solution {\\npublic:  \\n  vector<int> groupStrings(vector<string>& words) {\\n   \\n    unordered_map<string, int>t;        //mask , numbers\\n    \\n    for(auto &w: words){\\n      string simple(26, \\'#\\'); \\n      for(auto ch : w) simple[ch-\\'a\\'] = \\'1\\';\\n      t[simple]++;\\n    }\\n    \\n    int group = 0, maxi = 1; \\n    \\n    while(!t.empty()){\\n      queue<string>q;\\n      q.push(t.begin()->first);\\n      group++;\\n      int temp = 0;\\n      \\n      while(!q.empty()){\\n        string w = q.front(); q.pop();\\n        \\n        if(!t.count(w)) continue;\\n        temp += t[w];\\n            \\n        t.erase(w);\\n        \\n        for(int i = 0; i != 26; i++)\\n          if(w[i] == \\'#\\'){\\n            w[i] = \\'1\\';\\n            if(t.count(w)) q.push(w);\\n            w[i] = \\'#\\';\\n          }\\n          else{\\n            w[i] = \\'#\\';\\n            if(t.count(w)) q.push(w);\\n            \\n            for(int j = 0; j != 26; j++)\\n              if(j != i && w[j]  == \\'#\\'){\\n                w[j] = \\'1\\';\\n                if(t.count(w))q.push(w);\\n                w[j] = \\'#\\';\\n              }\\n      \\n            w[i] = \\'1\\';\\n          }\\n      }\\n        \\n        \\n        \\n      maxi = max(maxi,temp);\\n    }\\n    \\n    return {group, maxi};\\n  }\\n};\\n```\\n**this version is realisation previous idea with bit manipulation instead string**\\n\\nRuntime: 856 ms, faster than 95.21% of C++ online submissions for Groups of Strings.\\nMemory Usage: 130.2 MB, less than 47.31% of C++ online submissions for Groups of Strings.\\n```\\nclass Solution {\\npublic:  \\n  vector<int> groupStrings(vector<string>& words) {\\n   \\n    unordered_map<unsigned int, int>t;        //mask , numbers\\n    \\n    for(auto &w: words){\\n      unsigned int simple = 0; \\n      for(auto ch : w) simple |= 1 << (ch-\\'a\\');\\n      t[simple]++;\\n    }\\n    \\n    int group = 0, maxi = 1; \\n    \\n    while(!t.empty()){\\n      queue<unsigned int>q;\\n      q.push(t.begin()->first);\\n      group++;\\n      int temp = 0;\\n      \\n      while(!q.empty()){\\n        unsigned int w = q.front(); q.pop();\\n        \\n        if(!t.count(w)) continue;\\n        temp += t[w];\\n            \\n        t.erase(w);\\n        \\n        for(int i = 0, mask = 1; i != 26; i++, mask <<= 1)\\n          if( (w & mask) == 0) {if(t.count(w|mask)) q.push(w|mask);}\\n          else{\\n            w ^= mask;\\n            if(t.count(w)) q.push(w);\\n            \\n            for(int j = 0, mask2 = 1; j != 26; j++, mask2 <<= 1)\\n              if(j != i && ( (w & mask2) == 0))\\n                if(t.count(w|mask2)) q.push(w|mask2);\\n              \\n            w ^= mask;\\n          }\\n        }\\n        \\n      maxi = max(maxi,temp);\\n    }\\n    \\n    return {group, maxi};\\n  }\\n};\\n```\\n\\n**java version have TLE with last test: 97 / 97 test cases passed, but took too long. =(**\\n```\\nclass Solution {\\n  public int[] groupStrings(String[] words) {\\n    HashMap<Integer, Integer> t = new HashMap<>();        //mask , numbers\\n    \\n    for(String w: words){\\n      int simple = 0; \\n      for(int i = 0; i != w.length(); i++) simple |= 1 << (w.charAt(i)-\\'a\\');\\n      if(t.containsKey(simple)) t.put(simple, t.get(simple) + 1); \\n      else t.put(simple, 1);\\n    }\\n    \\n    int[] ans = {0,0}; \\n    LinkedList<Integer>q = new LinkedList<>();\\n    \\n    while(!t.isEmpty()){\\n      HashMap.Entry<Integer, Integer> firstEntry = t.entrySet().iterator().next();\\n\\n      q.add(firstEntry.getKey());\\n      ans[0]++;\\n      int temp = 0;\\n      \\n      while(!q.isEmpty()){\\n        int w = q.pollFirst();\\n        \\n        if(!t.containsKey(w)) continue;\\n        temp += t.get(w);\\n            \\n        t.remove(w);\\n        \\n        for(int i = 0, mask = 1; i != 26; i++, mask <<= 1)\\n          if( (w & mask) == 0) {if(t.containsKey(w|mask)) q.add(w|mask);}\\n          else{\\n            w ^= mask;\\n            if(t.containsKey(w)) q.add(w);\\n            \\n            for(int j = 0, mask2 = 1; j != 26; j++, mask2 <<= 1)\\n              if(j != i && ( (w & mask2) == 0))\\n                if(t.containsKey(w|mask2)) q.add(w|mask2);\\n              \\n            w ^= mask;\\n          }\\n        }\\n        \\n      ans[1] = Math.max(ans[1],temp);\\n    }\\n    \\n    return ans;\\n  }\\n};      \\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:  \\n  vector<int> groupStrings(vector<string>& words) {\\n   \\n    unordered_map<string, int>t;        //mask , numbers\\n    \\n    for(auto &w: words){\\n      string simple(26, \\'#\\'); \\n      for(auto ch : w) simple[ch-\\'a\\'] = \\'1\\';\\n      t[simple]++;\\n    }\\n    \\n    int group = 0, maxi = 1; \\n    \\n    while(!t.empty()){\\n      queue<string>q;\\n      q.push(t.begin()->first);\\n      group++;\\n      int temp = 0;\\n      \\n      while(!q.empty()){\\n        string w = q.front(); q.pop();\\n        \\n        if(!t.count(w)) continue;\\n        temp += t[w];\\n            \\n        t.erase(w);\\n        \\n        for(int i = 0; i != 26; i++)\\n          if(w[i] == \\'#\\'){\\n            w[i] = \\'1\\';\\n            if(t.count(w)) q.push(w);\\n            w[i] = \\'#\\';\\n          }\\n          else{\\n            w[i] = \\'#\\';\\n            if(t.count(w)) q.push(w);\\n            \\n            for(int j = 0; j != 26; j++)\\n              if(j != i && w[j]  == \\'#\\'){\\n                w[j] = \\'1\\';\\n                if(t.count(w))q.push(w);\\n                w[j] = \\'#\\';\\n              }\\n      \\n            w[i] = \\'1\\';\\n          }\\n      }\\n        \\n        \\n        \\n      maxi = max(maxi,temp);\\n    }\\n    \\n    return {group, maxi};\\n  }\\n};\\n```\n```\\nclass Solution {\\npublic:  \\n  vector<int> groupStrings(vector<string>& words) {\\n   \\n    unordered_map<unsigned int, int>t;        //mask , numbers\\n    \\n    for(auto &w: words){\\n      unsigned int simple = 0; \\n      for(auto ch : w) simple |= 1 << (ch-\\'a\\');\\n      t[simple]++;\\n    }\\n    \\n    int group = 0, maxi = 1; \\n    \\n    while(!t.empty()){\\n      queue<unsigned int>q;\\n      q.push(t.begin()->first);\\n      group++;\\n      int temp = 0;\\n      \\n      while(!q.empty()){\\n        unsigned int w = q.front(); q.pop();\\n        \\n        if(!t.count(w)) continue;\\n        temp += t[w];\\n            \\n        t.erase(w);\\n        \\n        for(int i = 0, mask = 1; i != 26; i++, mask <<= 1)\\n          if( (w & mask) == 0) {if(t.count(w|mask)) q.push(w|mask);}\\n          else{\\n            w ^= mask;\\n            if(t.count(w)) q.push(w);\\n            \\n            for(int j = 0, mask2 = 1; j != 26; j++, mask2 <<= 1)\\n              if(j != i && ( (w & mask2) == 0))\\n                if(t.count(w|mask2)) q.push(w|mask2);\\n              \\n            w ^= mask;\\n          }\\n        }\\n        \\n      maxi = max(maxi,temp);\\n    }\\n    \\n    return {group, maxi};\\n  }\\n};\\n```\n```\\nclass Solution {\\n  public int[] groupStrings(String[] words) {\\n    HashMap<Integer, Integer> t = new HashMap<>();        //mask , numbers\\n    \\n    for(String w: words){\\n      int simple = 0; \\n      for(int i = 0; i != w.length(); i++) simple |= 1 << (w.charAt(i)-\\'a\\');\\n      if(t.containsKey(simple)) t.put(simple, t.get(simple) + 1); \\n      else t.put(simple, 1);\\n    }\\n    \\n    int[] ans = {0,0}; \\n    LinkedList<Integer>q = new LinkedList<>();\\n    \\n    while(!t.isEmpty()){\\n      HashMap.Entry<Integer, Integer> firstEntry = t.entrySet().iterator().next();\\n\\n      q.add(firstEntry.getKey());\\n      ans[0]++;\\n      int temp = 0;\\n      \\n      while(!q.isEmpty()){\\n        int w = q.pollFirst();\\n        \\n        if(!t.containsKey(w)) continue;\\n        temp += t.get(w);\\n            \\n        t.remove(w);\\n        \\n        for(int i = 0, mask = 1; i != 26; i++, mask <<= 1)\\n          if( (w & mask) == 0) {if(t.containsKey(w|mask)) q.add(w|mask);}\\n          else{\\n            w ^= mask;\\n            if(t.containsKey(w)) q.add(w);\\n            \\n            for(int j = 0, mask2 = 1; j != 26; j++, mask2 <<= 1)\\n              if(j != i && ( (w & mask2) == 0))\\n                if(t.containsKey(w|mask2)) q.add(w|mask2);\\n              \\n            w ^= mask;\\n          }\\n        }\\n        \\n      ans[1] = Math.max(ans[1],temp);\\n    }\\n    \\n    return ans;\\n  }\\n};      \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2043346,
                "title": "simple-c-inspired-by-yuanzhi247012-s-post",
                "content": "Inspired by this post: https://leetcode.com/problems/groups-of-strings/discuss/2000000/Python3-O(26*n)-no-TLE.-Only-look-at-%22add%22-no-%22delete%22-and-%22replace%22\\n\\nIt is really a good idea to consider only \"add\" operation and get all \"connected\" strings. \\n\\n```\\nclass Solution {\\n    vector<int> uf;\\n\\n    void Union(int i, int j) {\\n        uf[i]=uf[j]=uf[Find(i)]=Find(j);\\n    }\\n    \\n    int Find(int i) {\\n        while(i!=uf[i]) i=uf[i];\\n        return i;\\n    }\\n    \\n    vector<int> FindMaxGroup() {\\n        unordered_map<int,int> mp; \\n        int gcnt=0, cnt=0;\\n        for (int i=0; i<uf.size(); i++) {\\n            gcnt = max(gcnt,++mp[Find(i)]);\\n            cnt+=(uf[i]==i);\\n        }\\n        return {cnt, gcnt};\\n    }\\n    \\npublic:\\n    vector<int> groupStrings(vector<string>& words) {\\n        int n = words.size(), group=n;\\n        uf.resize(n);\\n        iota(uf.begin(), uf.end(), 0);\\n        \\n        unordered_map<int, int> mp;\\n        for (int i=0; i<n; i++) {\\n            int bw = 0;\\n            for (auto& c: words[i]) bw |= 1<<(c-\\'a\\');\\n            for (int k=0; k<26; k++) { \\n                int w = bw | (1<<k);\\n                if (mp.count(w) && Find(mp[w])!=Find(i)) Union(i, mp[w]);\\n                mp[w] = i;\\n            }\\n        }    \\n        return FindMaxGroup();\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n    vector<int> uf;\\n\\n    void Union(int i, int j) {\\n        uf[i]=uf[j]=uf[Find(i)]=Find(j);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2042917,
                "title": "c-bit-masking-disjoint-set",
                "content": "```\\nclass Solution {\\nprivate:\\n    int grp_cnt, max_size;\\n    vector<int> parent, rank;\\n    \\n    int get_mask(string &word) {\\n        int mask = 0;\\n        for(char ch: word) \\n            mask = mask | (1<<(ch-\\'a\\'));\\n        return mask;\\n    }\\n    \\n    int find(int x) {\\n        if(parent[x] == -1)\\n            return x;\\n        return parent[x] = find(parent[x]);\\n    }\\n    \\n    void merge(int x, int y) {\\n        x = find(x);\\n        y = find(y);\\n        \\n        if(x == y)\\n            return;\\n        else if(rank[x] < rank[y])\\n            swap(x, y);\\n        \\n        parent[y] = x;\\n        rank[x] += rank[y];\\n        \\n        grp_cnt -= 1;\\n        max_size = max(max_size, rank[x]);\\n    }\\n    \\npublic:\\n    vector<int> groupStrings(vector<string>& words) {\\n        int n = words.size();\\n        grp_cnt = n;\\n        max_size = 1;\\n        \\n        parent = vector<int>(n, -1);\\n        rank = vector<int>(n, 1);\\n        \\n        // {mask, index}\\n        // map<int, int> index_of;\\n        unordered_map<int, int> index_of;\\n        \\n        \\n        vector<int> mask(n, 0);\\n        for(int i = 0; i < n; i++) {\\n            mask[i] = get_mask(words[i]);\\n            index_of[mask[i]] = i;\\n        }\\n        \\n        for(int i = 0; i < n; i++) {\\n            // duplicate word \"ab\", \"ba\"\\n            merge(i, index_of[mask[i]]);\\n            for(char ch: words[i]) {\\n                // removing ch (removing complements the adding)\\n                int without = mask[i] ^ (1 << (ch-\\'a\\'));\\n                if(index_of.count(without)) \\n                    merge(i, index_of[without]);\\n                \\n                // replacing ch with any other character\\n                for(int j = 0; j < 26; j++) {\\n                    if(j == ch-\\'a\\')\\n                        continue;\\n                    int withreplace = without | (1<<j); \\n                    if(index_of.count(withreplace)) \\n                        merge(i, index_of[withreplace]);\\n                }\\n            }\\n        }\\n        \\n        return {grp_cnt, max_size};\\n    }\\n};\\n\\n\\n\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int grp_cnt, max_size;\\n    vector<int> parent, rank;\\n    \\n    int get_mask(string &word) {\\n        int mask = 0;\\n        for(char ch: word) \\n            mask = mask | (1<<(ch-\\'a\\'));\\n        return mask;\\n    }\\n    \\n    int find(int x) {\\n        if(parent[x] == -1)\\n            return x;\\n        return parent[x] = find(parent[x]);\\n    }\\n    \\n    void merge(int x, int y) {\\n        x = find(x);\\n        y = find(y);\\n        \\n        if(x == y)\\n            return;\\n        else if(rank[x] < rank[y])\\n            swap(x, y);\\n        \\n        parent[y] = x;\\n        rank[x] += rank[y];\\n        \\n        grp_cnt -= 1;\\n        max_size = max(max_size, rank[x]);\\n    }\\n    \\npublic:\\n    vector<int> groupStrings(vector<string>& words) {\\n        int n = words.size();\\n        grp_cnt = n;\\n        max_size = 1;\\n        \\n        parent = vector<int>(n, -1);\\n        rank = vector<int>(n, 1);\\n        \\n        // {mask, index}\\n        // map<int, int> index_of;\\n        unordered_map<int, int> index_of;\\n        \\n        \\n        vector<int> mask(n, 0);\\n        for(int i = 0; i < n; i++) {\\n            mask[i] = get_mask(words[i]);\\n            index_of[mask[i]] = i;\\n        }\\n        \\n        for(int i = 0; i < n; i++) {\\n            // duplicate word \"ab\", \"ba\"\\n            merge(i, index_of[mask[i]]);\\n            for(char ch: words[i]) {\\n                // removing ch (removing complements the adding)\\n                int without = mask[i] ^ (1 << (ch-\\'a\\'));\\n                if(index_of.count(without)) \\n                    merge(i, index_of[without]);\\n                \\n                // replacing ch with any other character\\n                for(int j = 0; j < 26; j++) {\\n                    if(j == ch-\\'a\\')\\n                        continue;\\n                    int withreplace = without | (1<<j); \\n                    if(index_of.count(withreplace)) \\n                        merge(i, index_of[withreplace]);\\n                }\\n            }\\n        }\\n        \\n        return {grp_cnt, max_size};\\n    }\\n};\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1863606,
                "title": "rust-union-find-bitmask-sort-o-26n",
                "content": "```\\nuse std::collections::HashMap;\\n\\n// struct Solution;\\n\\nimpl Solution {\\n    pub fn group_strings(mut words: Vec<String>) -> Vec<i32> {\\n        // Sort words by length as we want to visit longer words first\\n        words.sort_unstable_by_key(|word| word.len());\\n        let mut remove_one = HashMap::new();\\n        let mut uf = UnionFind::new(words.len());\\n\\n        for (i, word) in words.iter().enumerate().rev() {\\n            let mut cs = CharSet::new(word);\\n\\n            // The word can be obtained from another word by deleting one letter\\n            if let Some(&j) = remove_one.get(&cs.v) {\\n                uf.union(i, j);\\n            }\\n\\n            for c in (0..26).map(|i| (i + b\\'a\\') as char) {\\n                if cs.remove(c) {\\n                    if let Some(&j) = remove_one.get(&cs.v) {\\n                        // The word can be obtained from another word by replacing one letter\\n                        uf.union(i, j);\\n                    } else {\\n                        remove_one.insert(cs.v, i);\\n                    }\\n\\n                    cs.insert(c);\\n                }\\n            }\\n        }\\n\\n        let max_size = (0..words.len()).map(|i| uf.size(i)).max().unwrap();\\n        vec![uf.count() as i32, max_size as i32]\\n    }\\n}\\n\\nstruct CharSet {\\n    v: i32,\\n}\\n\\nimpl CharSet {\\n    fn new(s: &str) -> Self {\\n        let v = s.bytes().fold(0, |acc, b| acc | 1 << b - b\\'a\\');\\n        Self { v }\\n    }\\n\\n    fn insert(&mut self, c: char) -> bool {\\n        let mask = 1 << c as u8 - b\\'a\\';\\n        let absent = self.v & mask == 0;\\n        self.v |= mask;\\n        absent\\n    }\\n\\n    fn remove(&mut self, c: char) -> bool {\\n        let mask = 1 << c as u8 - b\\'a\\';\\n        let present = self.v & mask != 0;\\n        self.v &= !mask;\\n        present\\n    }\\n}\\n\\npub struct UnionFind {\\n    parents: Vec<usize>,\\n    sizes: Vec<usize>,\\n    comp_count: usize,\\n}\\n\\nimpl UnionFind {\\n    pub fn new(size: usize) -> Self {\\n        Self {\\n            parents: (0..size).collect(),\\n            sizes: vec![1; size],\\n            comp_count: size,\\n        }\\n    }\\n\\n    pub fn find(&mut self, x: usize) -> usize {\\n        let mut x = x;\\n        let Self { parents, .. } = self;\\n        while parents[x] != x {\\n            // Path splitting\\n            let parent = parents[x];\\n            parents[x] = parents[parent];\\n            x = parent;\\n        }\\n        x\\n    }\\n\\n    pub fn union(&mut self, x: usize, y: usize) -> bool {\\n        let mut root1 = self.find(x);\\n        let mut root2 = self.find(y);\\n        if root1 == root2 {\\n            return false;\\n        }\\n\\n        // Union by size\\n        let Self {\\n            parents,\\n            sizes,\\n            comp_count,\\n        } = self;\\n        if sizes[root1] > sizes[root2] {\\n            std::mem::swap(&mut root1, &mut root2);\\n        }\\n        parents[root1] = root2;\\n        sizes[root2] += sizes[root1];\\n        *comp_count -= 1;\\n        true\\n    }\\n\\n    pub fn size(&mut self, x: usize) -> usize {\\n        let root = self.find(x);\\n        self.sizes[root]\\n    }\\n\\n    pub fn count(&self) -> usize {\\n        self.comp_count\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Union Find",
                    "Sorting",
                    "Bitmask"
                ],
                "code": "```\\nuse std::collections::HashMap;\\n\\n// struct Solution;\\n\\nimpl Solution {\\n    pub fn group_strings(mut words: Vec<String>) -> Vec<i32> {\\n        // Sort words by length as we want to visit longer words first\\n        words.sort_unstable_by_key(|word| word.len());\\n        let mut remove_one = HashMap::new();\\n        let mut uf = UnionFind::new(words.len());\\n\\n        for (i, word) in words.iter().enumerate().rev() {\\n            let mut cs = CharSet::new(word);\\n\\n            // The word can be obtained from another word by deleting one letter\\n            if let Some(&j) = remove_one.get(&cs.v) {\\n                uf.union(i, j);\\n            }\\n\\n            for c in (0..26).map(|i| (i + b\\'a\\') as char) {\\n                if cs.remove(c) {\\n                    if let Some(&j) = remove_one.get(&cs.v) {\\n                        // The word can be obtained from another word by replacing one letter\\n                        uf.union(i, j);\\n                    } else {\\n                        remove_one.insert(cs.v, i);\\n                    }\\n\\n                    cs.insert(c);\\n                }\\n            }\\n        }\\n\\n        let max_size = (0..words.len()).map(|i| uf.size(i)).max().unwrap();\\n        vec![uf.count() as i32, max_size as i32]\\n    }\\n}\\n\\nstruct CharSet {\\n    v: i32,\\n}\\n\\nimpl CharSet {\\n    fn new(s: &str) -> Self {\\n        let v = s.bytes().fold(0, |acc, b| acc | 1 << b - b\\'a\\');\\n        Self { v }\\n    }\\n\\n    fn insert(&mut self, c: char) -> bool {\\n        let mask = 1 << c as u8 - b\\'a\\';\\n        let absent = self.v & mask == 0;\\n        self.v |= mask;\\n        absent\\n    }\\n\\n    fn remove(&mut self, c: char) -> bool {\\n        let mask = 1 << c as u8 - b\\'a\\';\\n        let present = self.v & mask != 0;\\n        self.v &= !mask;\\n        present\\n    }\\n}\\n\\npub struct UnionFind {\\n    parents: Vec<usize>,\\n    sizes: Vec<usize>,\\n    comp_count: usize,\\n}\\n\\nimpl UnionFind {\\n    pub fn new(size: usize) -> Self {\\n        Self {\\n            parents: (0..size).collect(),\\n            sizes: vec![1; size],\\n            comp_count: size,\\n        }\\n    }\\n\\n    pub fn find(&mut self, x: usize) -> usize {\\n        let mut x = x;\\n        let Self { parents, .. } = self;\\n        while parents[x] != x {\\n            // Path splitting\\n            let parent = parents[x];\\n            parents[x] = parents[parent];\\n            x = parent;\\n        }\\n        x\\n    }\\n\\n    pub fn union(&mut self, x: usize, y: usize) -> bool {\\n        let mut root1 = self.find(x);\\n        let mut root2 = self.find(y);\\n        if root1 == root2 {\\n            return false;\\n        }\\n\\n        // Union by size\\n        let Self {\\n            parents,\\n            sizes,\\n            comp_count,\\n        } = self;\\n        if sizes[root1] > sizes[root2] {\\n            std::mem::swap(&mut root1, &mut root2);\\n        }\\n        parents[root1] = root2;\\n        sizes[root2] += sizes[root1];\\n        *comp_count -= 1;\\n        true\\n    }\\n\\n    pub fn size(&mut self, x: usize) -> usize {\\n        let root = self.find(x);\\n        self.sizes[root]\\n    }\\n\\n    pub fn count(&self) -> usize {\\n        self.comp_count\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1842667,
                "title": "dsu-and-bitmasking-self-explained",
                "content": "```\\nclass DSU {\\n    int n;\\n    vector<int> par;\\n    \\npublic:\\n    int component;\\n    vector<int> component_size;\\n    \\n    DSU(int n) {\\n        this -> n = n;\\n        component = n;\\n        component_size.resize(n + 1);\\n        par.resize(n + 1);\\n        \\n        for (int i = 0; i <= n; i++) {\\n            par[i] = i;\\n            component_size[i] = 1;\\n        }\\n    }\\n    \\n    int get_par(int p) {\\n        while (p != par[p]) {\\n            par[p] = par[par[p]];\\n            p = par[p];\\n        }\\n        return p;\\n    }\\n    \\n    void unite(int u, int v) {\\n        int par1 = get_par(u);\\n        int par2 = get_par(v);\\n        \\n        if (par1 == par2) return;\\n        \\n        if (component_size[par1] > component_size[par2]) swap(par1, par2);\\n        \\n        par[par1] = par2;\\n        component_size[par2] += component_size[par1];\\n        component_size[par1] = 0;\\n        component--;\\n    }\\n};\\n\\nint group_parent[1 << 26];\\n\\nclass Solution {\\npublic:\\n    int get_mask(string str) {\\n        int mask = 0;\\n        for (auto &it : str) {\\n            int x = it - \\'a\\';\\n            mask |= (1 << x);\\n        }\\n        return mask;\\n    }\\n    vector<int> get_all_state(string word) {\\n        vector<int> ans;\\n        int n = word.size();\\n        \\n        vector<bool> present(26, 0);\\n        \\n        int mask = 0;\\n        \\n        for (auto it : word) {\\n            int x = it - \\'a\\';\\n            mask |= (1 << x);\\n            present[x] = 1;\\n        }\\n        \\n        ans.push_back(mask);\\n        \\n        // one deletion\\n        for (int i = 25; i >= 0; i--) {\\n            if (present[i]) {\\n                ans.push_back(mask - (1 << i));\\n            }\\n        }\\n        \\n        // one addition\\n        for (int i = 25; i >= 0; i--) {\\n            if (!present[i]) {\\n                ans.push_back(mask | (1 << i));\\n            }\\n        }\\n        \\n        // one replacement\\n        for (int i = 0; i < n; i++) {\\n            int x = word[i] - \\'a\\';\\n            for (int j = 0; j < 26; j++) {\\n                if (j == x || present[j]) continue;\\n                int temp = mask;\\n                temp -= (1 << x);\\n                temp += (1 << j);\\n                ans.push_back(temp);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    vector<int> groupStrings(vector<string>& words) {\\n        // unordered_map<int, int> group_parent;\\n        int n = words.size();\\n        \\n        DSU dsu(n);\\n        \\n        for (int i = 0; i < n; i++) {\\n            string word = words[i];\\n            \\n            vector<int> possible_states = get_all_state(word);\\n            \\n            for (auto &it : possible_states) {\\n                if (group_parent[it]) {\\n                    dsu.unite(i + 1, group_parent[it]);\\n                }\\n            }\\n            \\n            group_parent[get_mask(word)] = dsu.get_par(i + 1);\\n        }\\n        \\n        for (auto &word : words) {\\n            group_parent[get_mask(word)] = 0;\\n        }\\n        \\n        vector<int> ans = {dsu.component, *max_element(dsu.component_size.begin(), dsu.component_size.end())};\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass DSU {\\n    int n;\\n    vector<int> par;\\n    \\npublic:\\n    int component;\\n    vector<int> component_size;\\n    \\n    DSU(int n) {\\n        this -> n = n;\\n        component = n;\\n        component_size.resize(n + 1);\\n        par.resize(n + 1);\\n        \\n        for (int i = 0; i <= n; i++) {\\n            par[i] = i;\\n            component_size[i] = 1;\\n        }\\n    }\\n    \\n    int get_par(int p) {\\n        while (p != par[p]) {\\n            par[p] = par[par[p]];\\n            p = par[p];\\n        }\\n        return p;\\n    }\\n    \\n    void unite(int u, int v) {\\n        int par1 = get_par(u);\\n        int par2 = get_par(v);\\n        \\n        if (par1 == par2) return;\\n        \\n        if (component_size[par1] > component_size[par2]) swap(par1, par2);\\n        \\n        par[par1] = par2;\\n        component_size[par2] += component_size[par1];\\n        component_size[par1] = 0;\\n        component--;\\n    }\\n};\\n\\nint group_parent[1 << 26];\\n\\nclass Solution {\\npublic:\\n    int get_mask(string str) {\\n        int mask = 0;\\n        for (auto &it : str) {\\n            int x = it - \\'a\\';\\n            mask |= (1 << x);\\n        }\\n        return mask;\\n    }\\n    vector<int> get_all_state(string word) {\\n        vector<int> ans;\\n        int n = word.size();\\n        \\n        vector<bool> present(26, 0);\\n        \\n        int mask = 0;\\n        \\n        for (auto it : word) {\\n            int x = it - \\'a\\';\\n            mask |= (1 << x);\\n            present[x] = 1;\\n        }\\n        \\n        ans.push_back(mask);\\n        \\n        // one deletion\\n        for (int i = 25; i >= 0; i--) {\\n            if (present[i]) {\\n                ans.push_back(mask - (1 << i));\\n            }\\n        }\\n        \\n        // one addition\\n        for (int i = 25; i >= 0; i--) {\\n            if (!present[i]) {\\n                ans.push_back(mask | (1 << i));\\n            }\\n        }\\n        \\n        // one replacement\\n        for (int i = 0; i < n; i++) {\\n            int x = word[i] - \\'a\\';\\n            for (int j = 0; j < 26; j++) {\\n                if (j == x || present[j]) continue;\\n                int temp = mask;\\n                temp -= (1 << x);\\n                temp += (1 << j);\\n                ans.push_back(temp);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    vector<int> groupStrings(vector<string>& words) {\\n        // unordered_map<int, int> group_parent;\\n        int n = words.size();\\n        \\n        DSU dsu(n);\\n        \\n        for (int i = 0; i < n; i++) {\\n            string word = words[i];\\n            \\n            vector<int> possible_states = get_all_state(word);\\n            \\n            for (auto &it : possible_states) {\\n                if (group_parent[it]) {\\n                    dsu.unite(i + 1, group_parent[it]);\\n                }\\n            }\\n            \\n            group_parent[get_mask(word)] = dsu.get_par(i + 1);\\n        }\\n        \\n        for (auto &word : words) {\\n            group_parent[get_mask(word)] = 0;\\n        }\\n        \\n        vector<int> ans = {dsu.component, *max_element(dsu.component_size.begin(), dsu.component_size.end())};\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1816354,
                "title": "python-dfs-bitmask",
                "content": "This question is grouping words/strings with \"the set of characters in each word\".\\n\\nFor example, given **[\"ab\", \"ba\", \"abc\", \"cba\"]**, after converted into sets, we have: **set(\\'a\\', \\'b\\')** and **set(\\'a\\',\\'b\\',\\'c\\')**. Since these two sets only differ by one character, so they\\'re connected => we have answer = [1,4] \\n\\nThe idea is to use bitwise mask to represent the string, since there\\'s no duplicated characters in each word. Note that after conversion, one bitwise number could come from  multiple words/strings.\\n\\nTherefore we keep the count of the bitwise number (after conversion).\\n\\nIn previous case, **[\"ab\", \"ba\", \"abc\", \"cba\"]**, we have ...00011 and ...00111, which is 3 and 7. both count = 2.\\n\\nThe rest is simple, simply use DFS to visit all the bitwise numbers. Check its \\'neighbors\\' for add/replace/remove operations. Be careful while counting the **replaced** string: don\\'t add characters that already exist in the word, and also don\\'t count itself twice.\\n\\nFor the sake of simplicity/readability, add/replace/remove operation is separated as small methods (instead of doing all of them together). See more on the comments below.\\n\\n```\\nfrom typing import List\\nimport collections\\nclass Solution:\\n    def groupStrings(self, words: List[str]) -> List[int]:\\n        \\n        def convert(w): return sum( 1<<(ord(c)-ord(\\'a\\')) for c in w )\\n\\n        # convert all words into bitwise number (instead of set)\\n        bw = [convert(w) for w in words]\\n\\n        # keep the count of the occurance of each bitwise number\\n        counts = collections.Counter(bw)\\n\\n        # use DFS\\n        # for each bitwise number, add/remove/replace with any character\\n        # and check whether the \\'neighbor\\' exists or not\\n        # return the size of the connected group (cnt)\\n        def dfs(n):\\n            if n in visited: return 0\\n            cnt = counts[n]             # including itself\\n            visited.add(n)\\n            cnt += check_add(n)\\n            cnt += check_replace(n)\\n            cnt += check_remove(n)\\n            return cnt\\n        \\n        def check_add(n):\\n            cnt = 0\\n            for i in range(26):\\n                if (1<<i)&n == 0:       # add this character\\n                    m = n+(1<<i)\\n                    if m in counts:\\n                        cnt += dfs(m)\\n            return cnt\\n        \\n        def check_replace(n):\\n            cnt = 0\\n            pos = set([i for i in range(26) if (1<<i)&n != 0])\\n            for p in pos:               # replace p into all other characters\\n                m = n-(1<<p)\\n                for j in range(26):\\n                    if j not in pos and m+(1<<j) in counts:\\n                        cnt += dfs(m+(1<<j))\\n            return cnt\\n\\n        def check_remove(n):\\n            cnt = 0\\n            for i in range(26):\\n                if (1<<i)&n != 0:       # remove this character\\n                    m = n-(1<<i)\\n                    if m in counts:\\n                        cnt += dfs(m)\\n            return cnt\\n        \\n        # check all bitwise number, and update number_of_groups and largest_size\\n        number_of_groups, largest_size = 0, 0\\n        visited = set()\\n        for n, _ in counts.items():\\n            x = dfs(n)\\n            if x > 0:\\n                largest_size = max(largest_size, x)\\n                number_of_groups += 1\\n        return [number_of_groups, largest_size]\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Bitmask"
                ],
                "code": "```\\nfrom typing import List\\nimport collections\\nclass Solution:\\n    def groupStrings(self, words: List[str]) -> List[int]:\\n        \\n        def convert(w): return sum( 1<<(ord(c)-ord(\\'a\\')) for c in w )\\n\\n        # convert all words into bitwise number (instead of set)\\n        bw = [convert(w) for w in words]\\n\\n        # keep the count of the occurance of each bitwise number\\n        counts = collections.Counter(bw)\\n\\n        # use DFS\\n        # for each bitwise number, add/remove/replace with any character\\n        # and check whether the \\'neighbor\\' exists or not\\n        # return the size of the connected group (cnt)\\n        def dfs(n):\\n            if n in visited: return 0\\n            cnt = counts[n]             # including itself\\n            visited.add(n)\\n            cnt += check_add(n)\\n            cnt += check_replace(n)\\n            cnt += check_remove(n)\\n            return cnt\\n        \\n        def check_add(n):\\n            cnt = 0\\n            for i in range(26):\\n                if (1<<i)&n == 0:       # add this character\\n                    m = n+(1<<i)\\n                    if m in counts:\\n                        cnt += dfs(m)\\n            return cnt\\n        \\n        def check_replace(n):\\n            cnt = 0\\n            pos = set([i for i in range(26) if (1<<i)&n != 0])\\n            for p in pos:               # replace p into all other characters\\n                m = n-(1<<p)\\n                for j in range(26):\\n                    if j not in pos and m+(1<<j) in counts:\\n                        cnt += dfs(m+(1<<j))\\n            return cnt\\n\\n        def check_remove(n):\\n            cnt = 0\\n            for i in range(26):\\n                if (1<<i)&n != 0:       # remove this character\\n                    m = n-(1<<i)\\n                    if m in counts:\\n                        cnt += dfs(m)\\n            return cnt\\n        \\n        # check all bitwise number, and update number_of_groups and largest_size\\n        number_of_groups, largest_size = 0, 0\\n        visited = set()\\n        for n, _ in counts.items():\\n            x = dfs(n)\\n            if x > 0:\\n                largest_size = max(largest_size, x)\\n                number_of_groups += 1\\n        return [number_of_groups, largest_size]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1800651,
                "title": "python-union-find-and-hash-map-o-n-26",
                "content": "Initially, wrote the solution with time complexity O(n * 26 * 26) and space complexity O(n) which passed test cases within time. \\n\\nGet inspiration from @DBabichev to use 1 << 26 to represent character replacement, instead of iterating through 26 character. Please refer to his solution https://leetcode.com/problems/groups-of-strings/discuss/1730113/Python-carefull-dfs-with-bitmasks-explained and upvote his solution if found useful for you. \\n\\nTime complexity improved to O(n * 26). Space complexity is O(n * 26)\\n\\nYou can write much shorter code for DSU class. Path compression and union by rank are optional.\\n\\n```\\nclass DSU:\\n    def __init__(self, size):\\n        self.parent = [i for i in range(size)]\\n        self.rank = [0] * size\\n        self.size = [1] * size\\n        self.count = size\\n        \\n        \\n    def find(self, x):\\n        ###OPTIONAL PATH COMPRESSION###\\n        if self.parent[x] != x:\\n            self.parent[x] = self.find(self.parent[x])\\n            \\n        return self.parent[x]\\n    \\n    def union(self, x, y):\\n        root_x, root_y = self.find(x), self.find(y)\\n        \\n        if root_x == root_y:\\n            return False\\n        \\n        self.count -= 1\\n        ###OPTIONAL USING RANK###\\n        \\n        if self.rank[x] > self.rank[y]:\\n            self.parent[root_y] = root_x\\n            self.size[root_x] += self.size[root_y] \\n            \\n        elif self.rank[y] > self.rank[x]:\\n            self.parent[root_x] = root_y\\n            self.size[root_y] += self.size[root_x]\\n        else:\\n            self.parent[root_y] = root_x\\n            self.rank[root_x] += 1\\n            self.size[root_x] += self.size[root_y] \\n            \\n        \\n        return True\\n    \\n    def get_count(self):\\n        return self.count\\n    \\n    def get_max_size(self):\\n        return max(self.size)\\n\\n\\n    \\nclass Solution:\\n    def groupStrings(self, words: List[str]) -> List[int]:\\n        bitmask_dict = {}\\n        n = len(words)\\n        dsu = DSU(n)\\n        \\n\\t\\t#Step 1: Create bitmask for each word and add to dictionary\\n        for i, w in enumerate(words):\\n            bitmask = 0\\n            for char in w:\\n                index = ord(char) - ord(\"a\")\\n                bitmask |= (1 << index)\\n                \\n            ##Group those with the same set of letters\\n            if bitmask in bitmask_dict:\\n                dsu.union(bitmask_dict[bitmask], i)\\n            else:\\n                bitmask_dict[bitmask] = i\\n                \\n        #Step 2: Find bitmask for both cases: one character removed and character replacement\\n        keys = list(bitmask_dict.keys())\\n \\t\\n        for bitmask in keys:\\n            index = bitmask_dict[bitmask]\\n            for i in range(26):\\n                ### If this char in this bitmask\\n                if (bitmask & (1 << i)):\\n                    #Form bitmask with this char removed\\n                    bitmask1 = bitmask ^ (1 << i)\\n                    \\n                    if (bitmask1) in bitmask_dict:\\n                        dsu.union(index, bitmask_dict[bitmask1])\\n                        \\n                    #Use 1 << 26 to form bitmask with character replacement\\n                    bitmask2 = bitmask1 | (1 << 26)\\n                    if bitmask2 in bitmask_dict:\\n                        dsu.union(index, bitmask_dict[bitmask2])\\n                    else:\\n                        bitmask_dict[bitmask2] = index\\n                    \\n                    \\n                    \\n        return [dsu.get_count(), dsu.get_max_size()]\\n    \\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass DSU:\\n    def __init__(self, size):\\n        self.parent = [i for i in range(size)]\\n        self.rank = [0] * size\\n        self.size = [1] * size\\n        self.count = size\\n        \\n        \\n    def find(self, x):\\n        ###OPTIONAL PATH COMPRESSION###\\n        if self.parent[x] != x:\\n            self.parent[x] = self.find(self.parent[x])\\n            \\n        return self.parent[x]\\n    \\n    def union(self, x, y):\\n        root_x, root_y = self.find(x), self.find(y)\\n        \\n        if root_x == root_y:\\n            return False\\n        \\n        self.count -= 1\\n        ###OPTIONAL USING RANK###\\n        \\n        if self.rank[x] > self.rank[y]:\\n            self.parent[root_y] = root_x\\n            self.size[root_x] += self.size[root_y] \\n            \\n        elif self.rank[y] > self.rank[x]:\\n            self.parent[root_x] = root_y\\n            self.size[root_y] += self.size[root_x]\\n        else:\\n            self.parent[root_y] = root_x\\n            self.rank[root_x] += 1\\n            self.size[root_x] += self.size[root_y] \\n            \\n        \\n        return True\\n    \\n    def get_count(self):\\n        return self.count\\n    \\n    def get_max_size(self):\\n        return max(self.size)\\n\\n\\n    \\nclass Solution:\\n    def groupStrings(self, words: List[str]) -> List[int]:\\n        bitmask_dict = {}\\n        n = len(words)\\n        dsu = DSU(n)\\n        \\n\\t\\t#Step 1: Create bitmask for each word and add to dictionary\\n        for i, w in enumerate(words):\\n            bitmask = 0\\n            for char in w:\\n                index = ord(char) - ord(\"a\")\\n                bitmask |= (1 << index)\\n                \\n            ##Group those with the same set of letters\\n            if bitmask in bitmask_dict:\\n                dsu.union(bitmask_dict[bitmask], i)\\n            else:\\n                bitmask_dict[bitmask] = i\\n                \\n        #Step 2: Find bitmask for both cases: one character removed and character replacement\\n        keys = list(bitmask_dict.keys())\\n \\t\\n        for bitmask in keys:\\n            index = bitmask_dict[bitmask]\\n            for i in range(26):\\n                ### If this char in this bitmask\\n                if (bitmask & (1 << i)):\\n                    #Form bitmask with this char removed\\n                    bitmask1 = bitmask ^ (1 << i)\\n                    \\n                    if (bitmask1) in bitmask_dict:\\n                        dsu.union(index, bitmask_dict[bitmask1])\\n                        \\n                    #Use 1 << 26 to form bitmask with character replacement\\n                    bitmask2 = bitmask1 | (1 << 26)\\n                    if bitmask2 in bitmask_dict:\\n                        dsu.union(index, bitmask_dict[bitmask2])\\n                    else:\\n                        bitmask_dict[bitmask2] = index\\n                    \\n                    \\n                    \\n        return [dsu.get_count(), dsu.get_max_size()]\\n    \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1787231,
                "title": "easy-union-find-bit-masking-code-with-comments",
                "content": "```\\nclass Solution {\\n    \\n    /*\\n    Key Concepts: We need to use Union-Find and Bit masking. \\n    \\n    */\\n    public int[] groupStrings(String[] words) {\\n        int length = words.length;\\n        UnionFind uFind = new UnionFind(length);\\n        int[] mask = new int[length];\\n        Map<Integer, Integer> maskMap = new HashMap<>();\\n        for(int i = 0 ; i <words.length; i++) {\\n            mask[i] = getMask(words[i]);\\n            maskMap.put(mask[i], i);\\n        }\\n        \\n        \\n        for (int i =0; i < length; i++) {\\n            for (char ch: words[i].toCharArray()) {\\n                // For Anagrams.\\n                uFind.union(i, maskMap.get(mask[i]));\\n//              Standard XOR technique to unset the mask from 1 to 0.    \\n                int deleteChMask = mask[i] ^ 1 << ch -\\'a\\';       \\n                if (maskMap.containsKey(deleteChMask)) {\\n//                 Since theres a mask exists after Deletting a character, so union them together\\n                    uFind.union(i, maskMap.get(deleteChMask));\\n                }\\n                \\n                for (int j =0 ; j < 26 ; j++ ) {\\n//                  deleteChMask doesnt contain current char .  \\n                    int maskWithJ = deleteChMask | 1 <<j;\\n                    if (maskMap.containsKey(maskWithJ)) {\\n                        uFind.union(i, maskMap.get(maskWithJ));\\n                    }\\n                }\\n            }\\n        }\\n         return new int[] {uFind.largestGrp, uFind.maxSize};\\n        \\n    }\\n    \\n    /*\\n    Initialise a mask with a zero value. For all characters in the word, jst make the mask bit  as 1\\n    \\n    \\n    */\\n    private int getMask(String word) {\\n        int mask = 0;\\n        for (char ch : word.toCharArray()) {\\n//          Standard BitMasking technique to set the corresponding bit as 1. (Initially all zero)\\n//          Reaf Bit masking for more details. for character a, 1stt bit is marked with 1. \\n//          For char b, 1<< b-\\'a\\' = 1<< 1 = 2 . So 2nd bit bit is marked as 1\\n            mask = mask | 1 << ch -\\'a\\';\\n        }\\n        \\n        return mask;\\n    }\\n}\\n\\n/*\\n    Its a typical Union Find algorithm with a variant of maxSize and largestGrp\\n*/\\nclass UnionFind {\\n    \\n    int[] size;\\n    int[] representative;\\n    int maxSize;\\n    int largestGrp;\\n    \\n    public UnionFind(int n) {\\n//      Initialize all words of Size 1. As Union happens, maxSize will increase and groups will decrease   \\n        maxSize =1;\\n//      Default there will be n groups. each UnionFind will decrease the groups.    \\n        largestGrp = n;\\n        \\n        size = new int[n];\\n        representative = new int[n];\\n        \\n        for (int i = 0 ; i < n; i++) {\\n            size[i] =1 ;\\n            representative[i] = i;\\n        }\\n    }\\n    \\n    public int find(int i) {\\n        \\n        if (i == representative[i]) {\\n            return i;\\n        }\\n        \\n        return representative[i] = find(representative[i]);\\n    }\\n    \\n    public void union(int i, int j) {\\n        int pi = find(i);\\n        int pj = find(j);\\n        \\n        if (pi == pj) {\\n            return;\\n        }\\n        \\n        if (pi >= pj) {\\n            size[pi] += size[pj];\\n            representative[pj] = pi;\\n            maxSize = Math.max (maxSize, size[pi]);\\n        }\\n        else {\\n            size[pj] += size[pi];\\n            representative[pi] = pj;\\n            maxSize = Math.max (maxSize, size[pj]);\\n        }\\n        largestGrp--; // Since Each union should decrease the group by 1;\\n        \\n        \\n    }\\n    \\n}",
                "solutionTags": [
                    "Union Find",
                    "Bitmask"
                ],
                "code": "class Solution {\\n    \\n    /*\\n    Key Concepts: We need to use Union-Find and Bit masking. \\n    \\n    */\\n    public int[] groupStrings(String[] words) {\\n        int length = words.length;\\n        UnionFind uFind = new UnionFind(length);\\n        int[] mask = new int[length];\\n        Map<Integer, Integer> maskMap = new HashMap<>();\\n        for(int i = 0 ; i <words.length; i++) {\\n            mask[i] = getMask(words[i]);\\n            maskMap.put(mask[i], i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1766140,
                "title": "go-golang-bitmask",
                "content": "Go version of this solution:\\nhttps://leetcode.com/problems/groups-of-strings/discuss/1731073/Union-Find-vs.-DFS\\n\\n```\\nfunc groupStrings(words []string) []int {\\n    m := make(map[int32]int16)\\n\\tfor _, w := range words {\\n\\t\\tvar mask int32\\n\\t\\tfor _, ch := range w {\\n\\t\\t\\tmask |= 1 << (ch - \\'a\\')\\n\\t\\t}\\n\\n\\t\\tm[mask]++\\n\\t}\\n\\n\\tgroupsCount, maxGroupSize := 0, 0\\n\\tfor len(m) > 0 {\\n\\t\\tvar anyMask int32 // peek first random mask\\n\\t\\tfor mask := range m {\\n\\t\\t\\tanyMask = mask\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\n\\t\\tsize := dfs(m, anyMask)\\n\\n\\t\\tif size > 0 {\\n\\t\\t\\tmaxGroupSize = max(maxGroupSize, size)\\n\\t\\t\\tgroupsCount++\\n\\t\\t}\\n\\t}\\n\\n\\treturn []int{groupsCount, maxGroupSize}\\n}\\n\\nfunc dfs(m map[int32]int16, mask int32) int {\\n\\tres := 0\\n\\tif count, ok := m[mask]; ok {\\n\\t\\tres += int(count)\\n\\t\\tdelete(m, mask)\\n\\n\\t\\tfor i := 0; i < 26; i++ {\\n\\t\\t\\tres += dfs(m, mask^(1<<i))\\n\\t\\t\\tfor j := i + 1; j < 26; j++ {\\n\\t\\t\\t\\tif (mask>>i)&1 != (mask>>j)&1 {\\n\\t\\t\\t\\t\\tres += dfs(m, mask^(1<<i)^(1<<j))\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn res\\n}\\n\\nfunc max(a, b int) int {\\n\\tif a > b {\\n\\t\\treturn a\\n\\t}\\n\\n\\treturn b\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Bit Manipulation",
                    "Depth-First Search",
                    "Bitmask"
                ],
                "code": "```\\nfunc groupStrings(words []string) []int {\\n    m := make(map[int32]int16)\\n\\tfor _, w := range words {\\n\\t\\tvar mask int32\\n\\t\\tfor _, ch := range w {\\n\\t\\t\\tmask |= 1 << (ch - \\'a\\')\\n\\t\\t}\\n\\n\\t\\tm[mask]++\\n\\t}\\n\\n\\tgroupsCount, maxGroupSize := 0, 0\\n\\tfor len(m) > 0 {\\n\\t\\tvar anyMask int32 // peek first random mask\\n\\t\\tfor mask := range m {\\n\\t\\t\\tanyMask = mask\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\n\\t\\tsize := dfs(m, anyMask)\\n\\n\\t\\tif size > 0 {\\n\\t\\t\\tmaxGroupSize = max(maxGroupSize, size)\\n\\t\\t\\tgroupsCount++\\n\\t\\t}\\n\\t}\\n\\n\\treturn []int{groupsCount, maxGroupSize}\\n}\\n\\nfunc dfs(m map[int32]int16, mask int32) int {\\n\\tres := 0\\n\\tif count, ok := m[mask]; ok {\\n\\t\\tres += int(count)\\n\\t\\tdelete(m, mask)\\n\\n\\t\\tfor i := 0; i < 26; i++ {\\n\\t\\t\\tres += dfs(m, mask^(1<<i))\\n\\t\\t\\tfor j := i + 1; j < 26; j++ {\\n\\t\\t\\t\\tif (mask>>i)&1 != (mask>>j)&1 {\\n\\t\\t\\t\\t\\tres += dfs(m, mask^(1<<i)^(1<<j))\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn res\\n}\\n\\nfunc max(a, b int) int {\\n\\tif a > b {\\n\\t\\treturn a\\n\\t}\\n\\n\\treturn b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1750990,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n  \\n  def groupStrings(self, words: List[str]) -> List[int]:\\n    word_to_groups = defaultdict(lambda: [])\\n    group_to_words = defaultdict(lambda: [])\\n    word_to_freq = defaultdict(lambda: 0)\\n    idx = 0\\n    for word in words:\\n      idx += 1    \\n      word_to_freq[word] += 1\\n      sorted_word = \\'\\'.join([c for c in sorted(word)])\\n      word_to_groups[word].append(sorted_word)\\n      group_to_words[sorted_word].append(word)\\n      for i in range(len(sorted_word)):\\n        smaller_sorted_word = sorted_word[:i] + sorted_word[(i + 1):]\\n        word_to_groups[word].append(smaller_sorted_word)\\n        group_to_words[smaller_sorted_word].append(word)\\n    visited = set()  \\n    group_visited = set()\\n    num_groups = 0\\n    max_group_size = 0\\n    idx = 0\\n    for word in words:\\n      idx += 1\\n      if word in visited:\\n        continue\\n      num_groups += 1  \\n      group_size = 0\\n      st = deque()\\n      st.append(word)\\n      while len(st) > 0:\\n        w = st.pop()\\n        if w in visited:\\n          continue\\n        visited.add(w)  \\n        group_size += word_to_freq[w]\\n        for group in word_to_groups[w]:\\n          if group in group_visited:\\n            continue\\n          group_visited.add(group)\\n          for other_word in group_to_words[group]:\\n            if other_word not in visited:\\n              st.append(other_word)\\n      max_group_size = max(max_group_size, group_size)        \\n    return (num_groups, max_group_size)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n  \\n  def groupStrings(self, words: List[str]) -> List[int]:\\n    word_to_groups = defaultdict(lambda: [])\\n    group_to_words = defaultdict(lambda: [])\\n    word_to_freq = defaultdict(lambda: 0)\\n    idx = 0\\n    for word in words:\\n      idx += 1    \\n      word_to_freq[word] += 1\\n      sorted_word = \\'\\'.join([c for c in sorted(word)])\\n      word_to_groups[word].append(sorted_word)\\n      group_to_words[sorted_word].append(word)\\n      for i in range(len(sorted_word)):\\n        smaller_sorted_word = sorted_word[:i] + sorted_word[(i + 1):]\\n        word_to_groups[word].append(smaller_sorted_word)\\n        group_to_words[smaller_sorted_word].append(word)\\n    visited = set()  \\n    group_visited = set()\\n    num_groups = 0\\n    max_group_size = 0\\n    idx = 0\\n    for word in words:\\n      idx += 1\\n      if word in visited:\\n        continue\\n      num_groups += 1  \\n      group_size = 0\\n      st = deque()\\n      st.append(word)\\n      while len(st) > 0:\\n        w = st.pop()\\n        if w in visited:\\n          continue\\n        visited.add(w)  \\n        group_size += word_to_freq[w]\\n        for group in word_to_groups[w]:\\n          if group in group_visited:\\n            continue\\n          group_visited.add(group)\\n          for other_word in group_to_words[group]:\\n            if other_word not in visited:\\n              st.append(other_word)\\n      max_group_size = max(max_group_size, group_size)        \\n    return (num_groups, max_group_size)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1747639,
                "title": "union-find-o-n-26-26-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int n;\\n    vector<int> parent;\\n    vector<int> size;\\n    int find(int val)\\n    {\\n        if(parent[val]==-1)\\n            return val;\\n        return parent[val]=find(parent[val]);\\n    }\\n    void union1(int a,int b)\\n    {\\n        int a1=find(a);\\n        int b1=find(b);\\n        if(a1!=b1)\\n        {\\n            if(size[a1]>size[b1])\\n            {\\n                parent[b1]=a1;\\n                size[a1]+=size[b1];\\n            }\\n            else\\n            {\\n                parent[a1]=b1;\\n                size[b1]+=size[a1];\\n            }\\n        }\\n    }\\n    vector<int> groupStrings(vector<string>& words) \\n    {\\n        n=words.size();\\n        for(int i=0;i<words.size();i++)\\n        {\\n            sort(words[i].begin(),words[i].end());\\n        }\\n        unordered_map<int,int> mp;\\n        vector<int> word;\\n        parent.clear();\\n        size.clear();\\n        parent.resize(n,-1);\\n        size.resize(n,1);\\n        // for(auto x:word)\\n        //     cout<<x<<\" \";\\n        // cout<<\"\\\\n\";\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n             int x=0;\\n            for(int j=0;words[i][j];j++)\\n            {\\n                x+=(1<<(words[i][j]-\\'a\\'));\\n            }\\n            if(mp.find(x)!=mp.end())\\n            {     //for handling replacing same character i.e repeated strings \"abc\", \"abc\" \\n                union1(mp[x],i);\\n            }\\n            for(int j=0;j<=25;j++)\\n            {            // for handling inserting or deleting a character\\n                int word=0;\\n                word =x^(1<<j); // 1 hai to delete ho jaega  , 0 hai to insert ho jaega\\n\\n                if(mp.find(word)!=mp.end())\\n                {\\n                    union1(mp[word],i);   \\n               }     \\n            }\\n       \\n            for(int a=0;a<=24;a++)\\n            {           // for handling replacing one different character.. two pointer\\n                for(int b=a+1;b<=25;b++)\\n                {\\n                    if(((x&(1<<a)) && !(x&(1<<b))) || (!(x&(1<<a))) &&(x&(1<<b)))\\n                    {\\n                        int c=x;\\n                        c= c^(1<<a);\\n                        c= c^(1<<b);\\n                        if(mp.find(c)!=mp.end())\\n                        {\\n                          union1(mp[c],i);\\n                        }   \\n                    }\\n                }\\n            }\\n            mp[x]=i;\\n        }\\n        int grp=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            find(i);\\n            if(parent[i]==-1)\\n                grp++;\\n        }\\n        int max_size=*max_element(size.begin(),size.end());\\n        return {grp,max_size};\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Greedy",
                    "Graph",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n    vector<int> parent;\\n    vector<int> size;\\n    int find(int val)\\n    {\\n        if(parent[val]==-1)\\n            return val;\\n        return parent[val]=find(parent[val]);\\n    }\\n    void union1(int a,int b)\\n    {\\n        int a1=find(a);\\n        int b1=find(b);\\n        if(a1!=b1)\\n        {\\n            if(size[a1]>size[b1])\\n            {\\n                parent[b1]=a1;\\n                size[a1]+=size[b1];\\n            }\\n            else\\n            {\\n                parent[a1]=b1;\\n                size[b1]+=size[a1];\\n            }\\n        }\\n    }\\n    vector<int> groupStrings(vector<string>& words) \\n    {\\n        n=words.size();\\n        for(int i=0;i<words.size();i++)\\n        {\\n            sort(words[i].begin(),words[i].end());\\n        }\\n        unordered_map<int,int> mp;\\n        vector<int> word;\\n        parent.clear();\\n        size.clear();\\n        parent.resize(n,-1);\\n        size.resize(n,1);\\n        // for(auto x:word)\\n        //     cout<<x<<\" \";\\n        // cout<<\"\\\\n\";\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n             int x=0;\\n            for(int j=0;words[i][j];j++)\\n            {\\n                x+=(1<<(words[i][j]-\\'a\\'));\\n            }\\n            if(mp.find(x)!=mp.end())\\n            {     //for handling replacing same character i.e repeated strings \"abc\", \"abc\" \\n                union1(mp[x],i);\\n            }\\n            for(int j=0;j<=25;j++)\\n            {            // for handling inserting or deleting a character\\n                int word=0;\\n                word =x^(1<<j); // 1 hai to delete ho jaega  , 0 hai to insert ho jaega\\n\\n                if(mp.find(word)!=mp.end())\\n                {\\n                    union1(mp[word],i);   \\n               }     \\n            }\\n       \\n            for(int a=0;a<=24;a++)\\n            {           // for handling replacing one different character.. two pointer\\n                for(int b=a+1;b<=25;b++)\\n                {\\n                    if(((x&(1<<a)) && !(x&(1<<b))) || (!(x&(1<<a))) &&(x&(1<<b)))\\n                    {\\n                        int c=x;\\n                        c= c^(1<<a);\\n                        c= c^(1<<b);\\n                        if(mp.find(c)!=mp.end())\\n                        {\\n                          union1(mp[c],i);\\n                        }   \\n                    }\\n                }\\n            }\\n            mp[x]=i;\\n        }\\n        int grp=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            find(i);\\n            if(parent[i]==-1)\\n                grp++;\\n        }\\n        int max_size=*max_element(size.begin(),size.end());\\n        return {grp,max_size};\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1745998,
                "title": "python3",
                "content": "```\\nclass Solution:\\n    class UF:\\n        def __init__(self, n: int):\\n            self.parent = list(range(n))\\n            self.size = [1]*n\\n        def union(self, i: int, j: int):\\n            rooti = self.find(i)\\n            rootj = self.find(j)\\n            if rooti == rootj:\\n                return\\n            if self.size[rooti]>self.size[rootj]:\\n                self.size[rooti]+=self.size[rootj]\\n                self.parent[rootj] = rooti\\n            else:\\n                self.size[rootj]+=self.size[rooti]\\n                self.parent[rooti] = rootj\\n        def find(self, i: int) -> int:\\n            while i!=self.parent[i]:\\n                self.parent[i] = self.parent[self.parent[i]]\\n                i = self.parent[i]\\n            return i\\n                \\n    def groupStrings(self, words: List[str]) -> List[int]:\\n        n = len(words)\\n        uf = self.UF(n)\\n        rep = dict()\\n        cnt = defaultdict(int)\\n        for index, word in enumerate(words):\\n            local = 0\\n            for l in word:\\n                local |= 1<<(ord(l)-97)\\n            cnt[local]+=1\\n            rep[local] = index\\n        for key in rep:\\n            for i in range(26):\\n                pos = 1<<i\\n\\t\\t\\t\\t# add a letter\\n                if key&pos == 0:\\n                    target = key|pos\\n                    if target in rep:\\n                        uf.union(rep[key], rep[target])\\n                else:\\n\\t\\t\\t\\t\\t# remove a letter\\n                    target = key^pos\\n                    if target in rep:\\n                        uf.union(rep[key], rep[target])\\n\\t\\t\\t\\t\\t# replace a letter\\n                    for j in range(26):\\n                        replace_pos = 1<<j\\n                        if key&replace_pos == 0:\\n                            target = (key|replace_pos)^pos\\n                            if target in rep:\\n                                uf.union(rep[key], rep[target])\\n        group = defaultdict(int)\\n        for mask in rep:\\n            group[uf.find(rep[mask])] += cnt[mask]\\n        return [len(group), max(group.values())]\\n            \\n",
                "solutionTags": [
                    "Union Find",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution:\\n    class UF:\\n        def __init__(self, n: int):\\n            self.parent = list(range(n))\\n            self.size = [1]*n\\n        def union(self, i: int, j: int):\\n            rooti = self.find(i)\\n            rootj = self.find(j)\\n            if rooti == rootj:\\n                return\\n            if self.size[rooti]>self.size[rootj]:\\n                self.size[rooti]+=self.size[rootj]\\n                self.parent[rootj] = rooti\\n            else:\\n                self.size[rootj]+=self.size[rooti]\\n                self.parent[rooti] = rootj\\n        def find(self, i: int) -> int:\\n            while i!=self.parent[i]:\\n                self.parent[i] = self.parent[self.parent[i]]\\n                i = self.parent[i]\\n            return i\\n                \\n    def groupStrings(self, words: List[str]) -> List[int]:\\n        n = len(words)\\n        uf = self.UF(n)\\n        rep = dict()\\n        cnt = defaultdict(int)\\n        for index, word in enumerate(words):\\n            local = 0\\n            for l in word:\\n                local |= 1<<(ord(l)-97)\\n            cnt[local]+=1\\n            rep[local] = index\\n        for key in rep:\\n            for i in range(26):\\n                pos = 1<<i\\n\\t\\t\\t\\t# add a letter\\n                if key&pos == 0:\\n                    target = key|pos\\n                    if target in rep:\\n                        uf.union(rep[key], rep[target])\\n                else:\\n\\t\\t\\t\\t\\t# remove a letter\\n                    target = key^pos\\n                    if target in rep:\\n                        uf.union(rep[key], rep[target])\\n\\t\\t\\t\\t\\t# replace a letter\\n                    for j in range(26):\\n                        replace_pos = 1<<j\\n                        if key&replace_pos == 0:\\n                            target = (key|replace_pos)^pos\\n                            if target in rep:\\n                                uf.union(rep[key], rep[target])\\n        group = defaultdict(int)\\n        for mask in rep:\\n            group[uf.find(rep[mask])] += cnt[mask]\\n        return [len(group), max(group.values())]\\n            \\n",
                "codeTag": "Java"
            },
            {
                "id": 1744419,
                "title": "help-please-i-can-t-understand-what-i-am-missing",
                "content": "I have 3 failing tests that are super large and it\\'s hard to debug.\\n\\nCould anyone smarter than me explain what edge case am I missing here? Please :)\\n\\nI transformed every word to a set, and then with brute force I compare every 2 strings to try to connect using Union Find.\\nI believe this function is wrong, but I can\\'t understand why.\\n```\\ndef can_connect(s1: set, s2: set):\\n    \\n    n1, n2 = len(s1), len(s2)\\n    \\n    lengthdiff = abs(n1 - n2)\\n\\t\\n\\tif lengthdiff > 1:\\n        return False\\n    \\n    sdiff12 = s1 - s2 # set difference\\n    sdiff21 = s2 - s1 # set difference\\n    tdiff = sdiff12 | sdiff21 # total difference of the 2 sets\\n    \\n    if len(tdiff) > 2:\\n        return False\\n    if len(tdiff) == 2 and lengthdiff == 1:\\n        return False\\n    \\n    return True\\n```",
                "solutionTags": [
                    "Ordered Set"
                ],
                "code": "```\\ndef can_connect(s1: set, s2: set):\\n    \\n    n1, n2 = len(s1), len(s2)\\n    \\n    lengthdiff = abs(n1 - n2)\\n\\t\\n\\tif lengthdiff > 1:\\n        return False\\n    \\n    sdiff12 = s1 - s2 # set difference\\n    sdiff21 = s2 - s1 # set difference\\n    tdiff = sdiff12 | sdiff21 # total difference of the 2 sets\\n    \\n    if len(tdiff) > 2:\\n        return False\\n    if len(tdiff) == 2 and lengthdiff == 1:\\n        return False\\n    \\n    return True\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1739732,
                "title": "a-few-solutions",
                "content": "Encode each string of the input array `A` as an integer bitmask representation `x` where each bit from `0..25` corresponds to `a..z`.\\n\\nLet `y` be the \"add/remove\" candidates `cands` formulated from `x`, and let `z` be the \"replace\" candidates `cands` formulated from `y`.\\n\\nThen we can perform union-find via a map `m` to correlate each `i`<sup>th</sup> parent representative with its integer bitmask representation to return the quantity of connected components and the cardinality of the largest connected component as the answer.\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun groupStrings(A: Array<String>): IntArray {\\n        var N = A.size\\n        var P = IntArray(N) { it }\\n        var m = mutableMapOf<Int, Int>()\\n        fun find(x: Int): Int {\\n            P[x] = if (x == P[x]) x else find(P[x])\\n            return P[x]\\n        }\\n        fun union(i_: Int, x: Int) {\\n            if (!m.contains(x))\\n                return\\n            var i = find(i_)\\n            var j = find(m[x]!!)\\n            if (i != j)\\n                P[j] = i  // \\uD83C\\uDFB2 arbitrary choice\\n        }\\n        for (i in 0 until N) {\\n            var x = A[i].split(\"\").filter{ 0 < it.length }.map{ 1 shl (it.first().toInt() - \\'a\\'.toInt()) }.sum()\\n            var cands = mutableListOf<Int>(x)\\n            for (j in 0..25) {\\n                var y = x xor (1 shl j)\\n                cands.add(y)\\n                if (x < y)\\n                    continue\\n                for (k in 0..25) {\\n                    if (j == k)\\n                        continue\\n                    var z = y xor (1 shl k)\\n                    if (y < z)\\n                        cands.add(z)\\n                }\\n            }\\n            for (cand in cands)\\n                union(i, cand)\\n            m[x] = i\\n        }\\n        var (cnt, hi) = Pair(mutableMapOf<Int, Int>(), 0)\\n        for (i in 0 until N) {\\n            P[i] = find(i)\\n            cnt[P[i]] = 1 + (cnt[P[i]] ?: 0)\\n            hi = Math.max(hi, cnt[P[i]]!!)\\n        }\\n        return intArrayOf(P.toSet().size, hi)\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet groupStrings = (A, m = new Map()) => {\\n    let N = A.length;\\n    let P = [...Array(N).keys()];\\n    let find = x => P[x] = x == P[x] ? x : find(P[x]);\\n    let union = (i, x) => {\\n        if (!m.has(x))\\n            return;\\n        let j = m.get(x);\\n        i = find(i);\\n        j = find(j);\\n        if (i != j)\\n            P[j] = i;  // \\uD83C\\uDFB2 arbitrary choice\\n    };\\n    for (let i = 0; i < N; ++i) {\\n        let x = _.sum(A[i].split(\\'\\').map(c => 1 << (c.charCodeAt(0) - \\'a\\'.charCodeAt(0))));\\n        let cands = [x];\\n        for (let j = 0; j < 26; ++j) {\\n            let y = x ^ (1 << j);\\n            cands.push(y);\\n            if (x < y)\\n                continue;\\n            for (let k = 0; k < 26; ++k) {\\n                if (j == k)\\n                    continue;\\n                let z = y ^ (1 << k);\\n                if (y < z)\\n                    cands.push(z);\\n            }\\n        }\\n        for (let cand of cands)\\n            union(i, cand);\\n        m.set(x, i);\\n    }\\n    let cnt = new Map();\\n    for (let i = 0; i < N; ++i) {\\n        P[i] = find(i);\\n        cnt.set(P[i], 1 + (cnt.get(P[i]) || 0));\\n    }\\n    return [new Set(P).size, Math.max(...[...cnt].map(([_, x]) => x))];\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def groupStrings(self, A: List[str]) -> List[int]:\\n        N = len(A)\\n        m = {}\\n        P = [i for i in range(N)]\\n        def find(x):\\n            P[x] = x if P[x] == x else find(P[x])\\n            return P[x]\\n        def union(i, x):\\n            if x not in m:\\n                return\\n            j = m[x]\\n            i = find(i)\\n            j = find(j)\\n            P[j] = i  # \\uD83C\\uDFB2 arbitrary choice\\n        for i, s in enumerate(A):\\n            x = sum(1 << (ord(c) - ord(\\'a\\')) for c in s)\\n            cands = [x]\\n            for j in range(26):\\n                y = x ^ (1 << j)\\n                cands.append(y)\\n                if x < y:\\n                    continue\\n                for k in range(26):\\n                    if j == k:\\n                        continue\\n                    z = y ^ (1 << k)\\n                    if y < z:\\n                        cands.append(z)\\n            for cand in cands:\\n                union(i, cand)\\n            m[x] = i\\n        for i in range(N):\\n            P[i] = find(i)\\n        return [len(set(P)), Counter(P).most_common(1)[0][1]]\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VS = vector<string>;\\n    using Map = unordered_map<int, int>;\\n    using Set = unordered_set<int>;\\n    using fun = function<int(int)>;\\n    VI groupStrings(VS& A, Map m = {}) {\\n        int N = A.size();\\n        VI P(N); iota(P.begin(), P.end(), 0);\\n        fun find = [&](auto x) {\\n            return P[x] = x == P[x] ? x : find(P[x]);\\n        };\\n        auto join = [&](auto i, auto x) {\\n            if (m.find(x) == m.end())\\n                return;\\n            auto j = m[x];\\n            i = find(i);\\n            j = find(j);\\n            if (i != j)\\n                P[j] = i;  // \\uD83C\\uDFB2 arbitrary choice\\n        };\\n        for (auto i{ 0 }; i < N; ++i) {\\n            auto x = accumulate(A[i].begin(), A[i].end(), 0, [](auto t, auto c) { return t + (1 << (c - \\'a\\')); });\\n            VI cands{ x };\\n            for (auto j{ 0 }; j < 26; ++j) {\\n                auto y = x ^ (1 << j);\\n                cands.push_back(y);\\n                if (x < y)\\n                    continue;\\n                for (auto k{ 0 }; k < 26; ++k) {\\n                    if (j == k)\\n                        continue;\\n                    auto z = y ^ (1 << k);\\n                    if (y < z)\\n                        cands.push_back(z);\\n                }\\n            }\\n            for (auto cand: cands)\\n                join(i, cand);\\n            m[x] = i;\\n        }\\n        Map cnt;\\n        auto hi = 0;\\n        for (auto i{ 0 }; i < N; ++i) {\\n            P[i] = find(i);\\n            hi = max(hi, ++cnt[P[i]]);\\n        }\\n        return VI{ (int)Set{ P.begin(), P.end() }.size(), hi };\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun groupStrings(A: Array<String>): IntArray {\\n        var N = A.size\\n        var P = IntArray(N) { it }\\n        var m = mutableMapOf<Int, Int>()\\n        fun find(x: Int): Int {\\n            P[x] = if (x == P[x]) x else find(P[x])\\n            return P[x]\\n        }\\n        fun union(i_: Int, x: Int) {\\n            if (!m.contains(x))\\n                return\\n            var i = find(i_)\\n            var j = find(m[x]!!)\\n            if (i != j)\\n                P[j] = i  // \\uD83C\\uDFB2 arbitrary choice\\n        }\\n        for (i in 0 until N) {\\n            var x = A[i].split(\"\").filter{ 0 < it.length }.map{ 1 shl (it.first().toInt() - \\'a\\'.toInt()) }.sum()\\n            var cands = mutableListOf<Int>(x)\\n            for (j in 0..25) {\\n                var y = x xor (1 shl j)\\n                cands.add(y)\\n                if (x < y)\\n                    continue\\n                for (k in 0..25) {\\n                    if (j == k)\\n                        continue\\n                    var z = y xor (1 shl k)\\n                    if (y < z)\\n                        cands.add(z)\\n                }\\n            }\\n            for (cand in cands)\\n                union(i, cand)\\n            m[x] = i\\n        }\\n        var (cnt, hi) = Pair(mutableMapOf<Int, Int>(), 0)\\n        for (i in 0 until N) {\\n            P[i] = find(i)\\n            cnt[P[i]] = 1 + (cnt[P[i]] ?: 0)\\n            hi = Math.max(hi, cnt[P[i]]!!)\\n        }\\n        return intArrayOf(P.toSet().size, hi)\\n    }\\n}\\n```\n```\\nlet groupStrings = (A, m = new Map()) => {\\n    let N = A.length;\\n    let P = [...Array(N).keys()];\\n    let find = x => P[x] = x == P[x] ? x : find(P[x]);\\n    let union = (i, x) => {\\n        if (!m.has(x))\\n            return;\\n        let j = m.get(x);\\n        i = find(i);\\n        j = find(j);\\n        if (i != j)\\n            P[j] = i;  // \\uD83C\\uDFB2 arbitrary choice\\n    };\\n    for (let i = 0; i < N; ++i) {\\n        let x = _.sum(A[i].split(\\'\\').map(c => 1 << (c.charCodeAt(0) - \\'a\\'.charCodeAt(0))));\\n        let cands = [x];\\n        for (let j = 0; j < 26; ++j) {\\n            let y = x ^ (1 << j);\\n            cands.push(y);\\n            if (x < y)\\n                continue;\\n            for (let k = 0; k < 26; ++k) {\\n                if (j == k)\\n                    continue;\\n                let z = y ^ (1 << k);\\n                if (y < z)\\n                    cands.push(z);\\n            }\\n        }\\n        for (let cand of cands)\\n            union(i, cand);\\n        m.set(x, i);\\n    }\\n    let cnt = new Map();\\n    for (let i = 0; i < N; ++i) {\\n        P[i] = find(i);\\n        cnt.set(P[i], 1 + (cnt.get(P[i]) || 0));\\n    }\\n    return [new Set(P).size, Math.max(...[...cnt].map(([_, x]) => x))];\\n};\\n```\n```\\nclass Solution:\\n    def groupStrings(self, A: List[str]) -> List[int]:\\n        N = len(A)\\n        m = {}\\n        P = [i for i in range(N)]\\n        def find(x):\\n            P[x] = x if P[x] == x else find(P[x])\\n            return P[x]\\n        def union(i, x):\\n            if x not in m:\\n                return\\n            j = m[x]\\n            i = find(i)\\n            j = find(j)\\n            P[j] = i  # \\uD83C\\uDFB2 arbitrary choice\\n        for i, s in enumerate(A):\\n            x = sum(1 << (ord(c) - ord(\\'a\\')) for c in s)\\n            cands = [x]\\n            for j in range(26):\\n                y = x ^ (1 << j)\\n                cands.append(y)\\n                if x < y:\\n                    continue\\n                for k in range(26):\\n                    if j == k:\\n                        continue\\n                    z = y ^ (1 << k)\\n                    if y < z:\\n                        cands.append(z)\\n            for cand in cands:\\n                union(i, cand)\\n            m[x] = i\\n        for i in range(N):\\n            P[i] = find(i)\\n        return [len(set(P)), Counter(P).most_common(1)[0][1]]\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VS = vector<string>;\\n    using Map = unordered_map<int, int>;\\n    using Set = unordered_set<int>;\\n    using fun = function<int(int)>;\\n    VI groupStrings(VS& A, Map m = {}) {\\n        int N = A.size();\\n        VI P(N); iota(P.begin(), P.end(), 0);\\n        fun find = [&](auto x) {\\n            return P[x] = x == P[x] ? x : find(P[x]);\\n        };\\n        auto join = [&](auto i, auto x) {\\n            if (m.find(x) == m.end())\\n                return;\\n            auto j = m[x];\\n            i = find(i);\\n            j = find(j);\\n            if (i != j)\\n                P[j] = i;  // \\uD83C\\uDFB2 arbitrary choice\\n        };\\n        for (auto i{ 0 }; i < N; ++i) {\\n            auto x = accumulate(A[i].begin(), A[i].end(), 0, [](auto t, auto c) { return t + (1 << (c - \\'a\\')); });\\n            VI cands{ x };\\n            for (auto j{ 0 }; j < 26; ++j) {\\n                auto y = x ^ (1 << j);\\n                cands.push_back(y);\\n                if (x < y)\\n                    continue;\\n                for (auto k{ 0 }; k < 26; ++k) {\\n                    if (j == k)\\n                        continue;\\n                    auto z = y ^ (1 << k);\\n                    if (y < z)\\n                        cands.push_back(z);\\n                }\\n            }\\n            for (auto cand: cands)\\n                join(i, cand);\\n            m[x] = i;\\n        }\\n        Map cnt;\\n        auto hi = 0;\\n        for (auto i{ 0 }; i < N; ++i) {\\n            P[i] = find(i);\\n            hi = max(hi, ++cnt[P[i]]);\\n        }\\n        return VI{ (int)Set{ P.begin(), P.end() }.size(), hi };\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1738703,
                "title": "c-bitmask-and-dfs",
                "content": "```\\npublic class Solution {\\n    public int[] GroupStrings(string[] words) {\\n        Dictionary<int,int> dict = new Dictionary<int,int>();\\n        for(int i = 0; i < words.Length; i++)\\n        {\\n            int mask = 0;\\n            foreach(char ch in words[i])\\n                mask = mask | 1<< (ch-\\'a\\');\\n            \\n            if(dict.ContainsKey(mask))\\n                dict[mask]++;\\n            else\\n                dict.Add(mask, 1);            \\n        }\\n        int groups = 0, largest = 0;\\n        while(dict.Count > 0)\\n        {\\n            int mask = dict.Keys.First();\\n            int size = dfs(mask, dict);\\n            groups += size > 0 ? 1 : 0;\\n            largest = Math.Max(largest, size);\\n        }\\n        return new int[2] {groups, largest};\\n    }\\n    \\n    private int dfs(int mask, Dictionary<int,int> dict)\\n    {\\n        int res = 0;\\n        if(dict.ContainsKey(mask))\\n        {\\n            res += dict[mask];\\n            dict.Remove(mask);\\n            for(int i = 0; i < 26; i++)\\n            {\\n                res += dfs(mask ^ (1<<i), dict);\\n                for (int j = i + 1; j < 26; ++j)\\n                    if (((mask >> i) & 1) != ((mask >> j) & 1))\\n                        res += dfs(mask ^ (1 << i) ^ (1 << j), dict);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int[] GroupStrings(string[] words) {\\n        Dictionary<int,int> dict = new Dictionary<int,int>();\\n        for(int i = 0; i < words.Length; i++)\\n        {\\n            int mask = 0;\\n            foreach(char ch in words[i])\\n                mask = mask | 1<< (ch-\\'a\\');\\n            \\n            if(dict.ContainsKey(mask))\\n                dict[mask]++;\\n            else\\n                dict.Add(mask, 1);            \\n        }\\n        int groups = 0, largest = 0;\\n        while(dict.Count > 0)\\n        {\\n            int mask = dict.Keys.First();\\n            int size = dfs(mask, dict);\\n            groups += size > 0 ? 1 : 0;\\n            largest = Math.Max(largest, size);\\n        }\\n        return new int[2] {groups, largest};\\n    }\\n    \\n    private int dfs(int mask, Dictionary<int,int> dict)\\n    {\\n        int res = 0;\\n        if(dict.ContainsKey(mask))\\n        {\\n            res += dict[mask];\\n            dict.Remove(mask);\\n            for(int i = 0; i < 26; i++)\\n            {\\n                res += dfs(mask ^ (1<<i), dict);\\n                for (int j = i + 1; j < 26; ++j)\\n                    if (((mask >> i) & 1) != ((mask >> j) & 1))\\n                        res += dfs(mask ^ (1 << i) ^ (1 << j), dict);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1736776,
                "title": "simple-bitmask-and-dfs-solution",
                "content": "It is simply a graph problem \\n```\\n=> change string to int using bitmask\\n=> make a graph\\n=> use dfs/dsu to find connected and maximum element in component\\n=> dsu might give TLE and become very complex so I use DFS \\n```\\n\\nAs constraint are very critical so use unordered_map and unordered_set instead of map and set \\nTime complexity :` O(n*26*26);`\\n\\n```\\nclass Solution {\\npublic:\\n    void dfs(map<int,vector<int>> &adj,unordered_map<int,int> &freq,unordered_set<int> &visited,int i,int par,int &t){\\n            visited.insert(i);\\n            for(auto j: adj[i]){\\n                if((!visited.count(j)) &&(j!=par) ){\\n                    dfs(adj,freq,visited,j,i,t);\\n                }\\n            }\\n        \\n            t+=freq[i];\\n        }\\n    \\n    vector<int> groupStrings(vector<string>& words) {\\n        unordered_set<int> v;\\n        unordered_map<int,int> freq;\\n        int Size=26;\\n        int j=0,temp,n;\\n        for(auto &i: words){\\n            temp=0;\\n            for(auto ch: i){\\n                temp+=(1<<(ch-\\'a\\'));\\n            }\\n            freq[temp]++;\\n            v.insert(temp);\\n        }\\n        map<int,vector<int>> adj;\\n        int c;\\n\\n        for(auto i: v){\\n            // add and delete 1 character\\n        // add means change 0 to 1\\n        // delete means change 1 to 0;\\n\\n            for(int j=0;j<Size;j++){\\n                temp=i^(1<<j);\\n                if(v.count(temp)){\\n                    adj[i].push_back(temp);\\n                }\\n            }\\n            int c1,c2;\\n            // we can change 1 character \\n            for(int k=0;k<Size;k++){\\n                for(int j=k+1;j<Size;j++){\\n                    c1=(1<<k)&i;\\n                    c2=(1<<j)&i;\\n                    if(c1>1) c1=1;\\n                    if(c2>1) c2=1;\\n                    if(c1==c2) continue;\\n                    // if kth and jth bit are different so we swap them \\n                    // means XOR with a number where only both kth and jth bits are set\\n                    temp=(1<<k)+(1<<j);\\n                    temp=i^temp;\\n                    if(v.count(temp)){\\n                        adj[i].push_back(temp);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        unordered_set<int> visited;\\n        int x=0,y=0;\\n        // now simply use dfs to find connected component \\n        // and find maximum element in it using t variable passing by reference\\n\\n        for(auto i: v){\\n            if(!visited.count(i)){\\n                temp=0;\\n                dfs(adj,freq,visited,i,-1,temp);\\n                y=max(y,temp);\\n                x++;\\n            }\\n        }\\n        \\n        vector<int> ans(2,0);\\n        ans[0]=x;\\n        ans[1]=y;\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n=> change string to int using bitmask\\n=> make a graph\\n=> use dfs/dsu to find connected and maximum element in component\\n=> dsu might give TLE and become very complex so I use DFS \\n```\n```\\nclass Solution {\\npublic:\\n    void dfs(map<int,vector<int>> &adj,unordered_map<int,int> &freq,unordered_set<int> &visited,int i,int par,int &t){\\n            visited.insert(i);\\n            for(auto j: adj[i]){\\n                if((!visited.count(j)) &&(j!=par) ){\\n                    dfs(adj,freq,visited,j,i,t);\\n                }\\n            }\\n        \\n            t+=freq[i];\\n        }\\n    \\n    vector<int> groupStrings(vector<string>& words) {\\n        unordered_set<int> v;\\n        unordered_map<int,int> freq;\\n        int Size=26;\\n        int j=0,temp,n;\\n        for(auto &i: words){\\n            temp=0;\\n            for(auto ch: i){\\n                temp+=(1<<(ch-\\'a\\'));\\n            }\\n            freq[temp]++;\\n            v.insert(temp);\\n        }\\n        map<int,vector<int>> adj;\\n        int c;\\n\\n        for(auto i: v){\\n            // add and delete 1 character\\n        // add means change 0 to 1\\n        // delete means change 1 to 0;\\n\\n            for(int j=0;j<Size;j++){\\n                temp=i^(1<<j);\\n                if(v.count(temp)){\\n                    adj[i].push_back(temp);\\n                }\\n            }\\n            int c1,c2;\\n            // we can change 1 character \\n            for(int k=0;k<Size;k++){\\n                for(int j=k+1;j<Size;j++){\\n                    c1=(1<<k)&i;\\n                    c2=(1<<j)&i;\\n                    if(c1>1) c1=1;\\n                    if(c2>1) c2=1;\\n                    if(c1==c2) continue;\\n                    // if kth and jth bit are different so we swap them \\n                    // means XOR with a number where only both kth and jth bits are set\\n                    temp=(1<<k)+(1<<j);\\n                    temp=i^temp;\\n                    if(v.count(temp)){\\n                        adj[i].push_back(temp);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        unordered_set<int> visited;\\n        int x=0,y=0;\\n        // now simply use dfs to find connected component \\n        // and find maximum element in it using t variable passing by reference\\n\\n        for(auto i: v){\\n            if(!visited.count(i)){\\n                temp=0;\\n                dfs(adj,freq,visited,i,-1,temp);\\n                y=max(y,temp);\\n                x++;\\n            }\\n        }\\n        \\n        vector<int> ans(2,0);\\n        ans[0]=x;\\n        ans[1]=y;\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1736213,
                "title": "c-union-find-bitmask-dsu",
                "content": "Explanation : [Link](http://leetcode.com/problems/groups-of-strings/discuss/1730110/C%2B%2B-Union-Find-%2B-Bitmask)\\n\\n```\\nclass UnionFind {\\nprivate:\\n    vector<int> parent, rank;\\n    int cntGrp;\\npublic:\\n    UnionFind(int n) {\\n        parent.resize(n);\\n        rank.resize(n, 1);\\n        iota(parent.begin(), parent.end(), 0);\\n        cntGrp = n;\\n    }\\n    \\n    // find parent\\n    int find(int a){\\n        if(parent[a] == a) return a;\\n        return parent[a] = find(parent[a]);\\n    }\\n    \\n    // union of a & b\\n    void unite(int a, int b){\\n        int x = find(a);\\n        int y = find(b);\\n        if(x == y) return;\\n        \\n        if(rank[x] >= rank[y]){\\n            parent[y] = x;\\n            rank[x] += rank[y];\\n        }else{\\n            parent[x] = y;\\n            rank[y] += rank[x];\\n        }\\n        cntGrp--;\\n    }\\n    \\n    int getGroupCnt() {\\n        return cntGrp;\\n    }\\n    \\n    int getSizeOfLargestGrp() {\\n        int mx = 1;\\n        for(int i=0; i<rank.size(); i++){\\n            mx = max(mx, rank[i]);\\n        }\\n        return mx;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> groupStrings(vector<string>& words) {\\n        int n = words.size();\\n        UnionFind uf(n);\\n        unordered_map<int, int> mp;\\n        for(int i=0; i<n; i++){\\n            int h = 0;\\n            for(auto &k: words[i]){\\n                h |= (1 << k-\\'a\\');\\n            }\\n            for(int j=0; j<26; j++){\\n                if(h & 1 << j){\\n                    int del = h ^ (1 << j);\\n                    if(mp.count(del)){\\n                        uf.unite(i, mp[del]);\\n                    }\\n                    for(int k=0; k<26; k++){\\n                        int replace = del | (1 << k);\\n                        if(replace != del && mp.count(replace)){\\n                            uf.unite(i, mp[replace]);\\n                        }\\n                    }\\n                }else{\\n                    int add = h | (1 << j);\\n                    if(mp.count(add)){\\n                        uf.unite(i, mp[add]);\\n                    }\\n                }\\n            }\\n            mp[h] = i;\\n        }\\n        int cnt = uf.getGroupCnt();\\n        int sz = uf.getSizeOfLargestGrp();\\n        return {cnt, sz};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Union Find",
                    "Bitmask"
                ],
                "code": "```\\nclass UnionFind {\\nprivate:\\n    vector<int> parent, rank;\\n    int cntGrp;\\npublic:\\n    UnionFind(int n) {\\n        parent.resize(n);\\n        rank.resize(n, 1);\\n        iota(parent.begin(), parent.end(), 0);\\n        cntGrp = n;\\n    }\\n    \\n    // find parent\\n    int find(int a){\\n        if(parent[a] == a) return a;\\n        return parent[a] = find(parent[a]);\\n    }\\n    \\n    // union of a & b\\n    void unite(int a, int b){\\n        int x = find(a);\\n        int y = find(b);\\n        if(x == y) return;\\n        \\n        if(rank[x] >= rank[y]){\\n            parent[y] = x;\\n            rank[x] += rank[y];\\n        }else{\\n            parent[x] = y;\\n            rank[y] += rank[x];\\n        }\\n        cntGrp--;\\n    }\\n    \\n    int getGroupCnt() {\\n        return cntGrp;\\n    }\\n    \\n    int getSizeOfLargestGrp() {\\n        int mx = 1;\\n        for(int i=0; i<rank.size(); i++){\\n            mx = max(mx, rank[i]);\\n        }\\n        return mx;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> groupStrings(vector<string>& words) {\\n        int n = words.size();\\n        UnionFind uf(n);\\n        unordered_map<int, int> mp;\\n        for(int i=0; i<n; i++){\\n            int h = 0;\\n            for(auto &k: words[i]){\\n                h |= (1 << k-\\'a\\');\\n            }\\n            for(int j=0; j<26; j++){\\n                if(h & 1 << j){\\n                    int del = h ^ (1 << j);\\n                    if(mp.count(del)){\\n                        uf.unite(i, mp[del]);\\n                    }\\n                    for(int k=0; k<26; k++){\\n                        int replace = del | (1 << k);\\n                        if(replace != del && mp.count(replace)){\\n                            uf.unite(i, mp[replace]);\\n                        }\\n                    }\\n                }else{\\n                    int add = h | (1 << j);\\n                    if(mp.count(add)){\\n                        uf.unite(i, mp[add]);\\n                    }\\n                }\\n            }\\n            mp[h] = i;\\n        }\\n        int cnt = uf.getGroupCnt();\\n        int sz = uf.getSizeOfLargestGrp();\\n        return {cnt, sz};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1734339,
                "title": "c-union-find-bit-manipulation",
                "content": "```\\nclass Solution {\\npublic:\\n    int rank[100005]={0};\\n    int find(int node,vector<int>&parent){\\n        \\n        if(parent[node]==node)return node;\\n        \\n        return parent[node]=find(parent[node],parent);\\n        \\n        \\n    }\\n    void unify(int a,int b,vector<int>&parent){\\n        \\n        int pa=find(a,parent);\\n        int pb=find(b,parent);\\n        \\n        if (pa != pb) {\\n        if (rank[pa] < rank[pb])\\n            swap(a, b);\\n        parent[pb] = pa;\\n        rank[pa] += rank[pb];\\n    }\\n }\\n    \\n    vector<int> groupStrings(vector<string>& words) {\\n      \\n        vector<int>v;\\n        int n=words.size();\\n        vector<int>parent(n);\\n        for(int i=0;i<n;i++)parent[i]=i;\\n        \\n        for(auto x:words){\\n            int mask=0;\\n            for(auto y:x){\\n                mask= mask | 1<<(y-\\'a\\');\\n            }\\n           v.push_back(mask);\\n        }\\n        \\n      unordered_map<int,int>m; // stores mask corresponding to the index \\n    \\n        \\n    for(int j=0;j<v.size();j++){\\n        int x=v[j];\\n        \\n        if(m.find(x)!=m.end()){     //for handling replacing same character i.e repeated strings \"abc\", \"abc\" \\n            unify(m[x],j,parent);\\n        }\\n        \\n        \\n        bool flag=false;\\n        \\n        for(int i=0;i<=25;i++){            // for handling inserting or deleting a character\\n            int word=0;\\n            word =x^(1<<i);\\n            \\n            if(m.find(word)!=m.end()){\\n                unify(m[word],j,parent);   \\n           }     \\n        }\\n       \\n        for(int a=0;a<=24;a++){           // for handling replacing one different character.. two pointer\\n            for(int b=a+1;b<=25;b++){\\n                if(((x&(1<<a)) &&!(x&(1<<b))) || (!(x&(1<<a))) &&(x&(1<<b))){\\n                    int c=x;\\n                    c= c^(1<<a);\\n                    c= c^(1<<b);\\n                    if(m.find(c)!=m.end()){\\n                    unify(m[c],j,parent);\\n                }   \\n              }\\n            }\\n        }\\n        \\n        m[x]=j;         // insert the mask corresponding to the index\\n    }\\n        \\n    int ans=0;\\n    unordered_map<int,int>mp;     // size of the parent\\n    for(int j=0;j<v.size();j++){\\n        int p=find(j,parent);\\n        mp[p]++;                  \\n        ans=max(ans,mp[p]);\\n    }\\n        \\n    return {(int)mp.size(),ans};      \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rank[100005]={0};\\n    int find(int node,vector<int>&parent){\\n        \\n        if(parent[node]==node)return node;\\n        \\n        return parent[node]=find(parent[node],parent);\\n        \\n        \\n    }\\n    void unify(int a,int b,vector<int>&parent){\\n        \\n        int pa=find(a,parent);\\n        int pb=find(b,parent);\\n        \\n        if (pa != pb) {\\n        if (rank[pa] < rank[pb])\\n            swap(a, b);\\n        parent[pb] = pa;\\n        rank[pa] += rank[pb];\\n    }\\n }\\n    \\n    vector<int> groupStrings(vector<string>& words) {\\n      \\n        vector<int>v;\\n        int n=words.size();\\n        vector<int>parent(n);\\n        for(int i=0;i<n;i++)parent[i]=i;\\n        \\n        for(auto x:words){\\n            int mask=0;\\n            for(auto y:x){\\n                mask= mask | 1<<(y-\\'a\\');\\n            }\\n           v.push_back(mask);\\n        }\\n        \\n      unordered_map<int,int>m; // stores mask corresponding to the index \\n    \\n        \\n    for(int j=0;j<v.size();j++){\\n        int x=v[j];\\n        \\n        if(m.find(x)!=m.end()){     //for handling replacing same character i.e repeated strings \"abc\", \"abc\" \\n            unify(m[x],j,parent);\\n        }\\n        \\n        \\n        bool flag=false;\\n        \\n        for(int i=0;i<=25;i++){            // for handling inserting or deleting a character\\n            int word=0;\\n            word =x^(1<<i);\\n            \\n            if(m.find(word)!=m.end()){\\n                unify(m[word],j,parent);   \\n           }     \\n        }\\n       \\n        for(int a=0;a<=24;a++){           // for handling replacing one different character.. two pointer\\n            for(int b=a+1;b<=25;b++){\\n                if(((x&(1<<a)) &&!(x&(1<<b))) || (!(x&(1<<a))) &&(x&(1<<b))){\\n                    int c=x;\\n                    c= c^(1<<a);\\n                    c= c^(1<<b);\\n                    if(m.find(c)!=m.end()){\\n                    unify(m[c],j,parent);\\n                }   \\n              }\\n            }\\n        }\\n        \\n        m[x]=j;         // insert the mask corresponding to the index\\n    }\\n        \\n    int ans=0;\\n    unordered_map<int,int>mp;     // size of the parent\\n    for(int j=0;j<v.size();j++){\\n        int p=find(j,parent);\\n        mp[p]++;                  \\n        ans=max(ans,mp[p]);\\n    }\\n        \\n    return {(int)mp.size(),ans};      \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1733559,
                "title": "union-find-solution-with-unstable-acceptance",
                "content": "Learned a lot from the discussion section. The thought process is: we can do pair-wise check for every two elements, but there exists a cheaper way. We can begin from each element, and walk through all neighbors it can reach, and then pick the neighbors that are also in the input array. The count of neighbors is: 26 neighbors by addition + 26 neighbors by subtraction + 13 * 13 by replacement. Then the complexity of finding all valid pairs reduces from 2* 10^4 * 2 * 10^4 to 2 * 10^4 * 221.\\n\\nSometimes it TLE but sometimes it got accepted.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> groupStrings(vector<string>& words) {\\n        int n = words.size();\\n        vector<int> bitmasks(n);\\n        unordered_set<int> set;\\n        for (int i = 0; i < n; ++i) {\\n            bitmasks[i] = getBitmask(words[i]);\\n            set.emplace(bitmasks[i]);\\n            makeSet(bitmasks[i]);\\n        }   \\n        sort(begin(bitmasks), end(bitmasks));\\n        for (int i = 0; i < n; ++i) {\\n            vector<int> neighbors = getNeighbors(bitmasks[i], set);\\n            for (int neighbor : neighbors) {\\n                unionSet(bitmasks[i], neighbor);\\n            }   \\n        }   \\n        vector<int> ans(2, 0); \\n        unordered_map<int, int> counter;\\n        for (int i = 0; i < n; ++i) {\\n            ans[1] = max(ans[1], ++counter[findSet(bitmasks[i])]);\\n            ans[0] = counter.size();\\n        }   \\n        return ans;\\n    }   \\nprivate:\\n    void makeSet(int x) {\\n        parent[x] = x;\\n        rank[x] = 0;\\n    }   \\n    void unionSet(int x, int y) {\\n        link(findSet(x), findSet(y));\\n    }   \\n    void link(int x, int y) {\\n        if (rank[x] > rank[y]) {\\n            parent[y] = x;\\n        } else {\\n            parent[x] = y;\\n            if (rank[x] == rank[y]) {\\n                ++rank[y];\\n            }   \\n        }   \\n    }   \\n    int findSet(int x) {\\n        return parent[x] == x ? x : (parent[x] = findSet(parent[x]));\\n    }\\n    vector<int> getNeighbors(int bitmask, unordered_set<int>& set) {\\n        vector<int> ans;\\n        for (int i = 0; i < 26; ++i) {\\n            if (auto another = (bitmask ^ (1 << i)); another < bitmask && set.count(another)) {\\n                ans.emplace_back(another);\\n            }   \\n            if (bitmask & (1 << i)) {\\n                for (int j = 0; j < 26; ++j) {\\n                    if ((bitmask & (1 << j)) == 0) {\\n                        if (auto another = bitmask ^ (1 << i) ^ (1 << j); another < bitmask && set.count(another)) {\\n                            ans.emplace_back(another);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    int getBitmask(string& word) {\\n        int ans = 0;\\n        for (char c : word) {\\n            ans |= 1 << (c - \\'a\\');\\n        }\\n        return ans;\\n    }\\n    unordered_map<int, int> parent;\\n    unordered_map<int, int> rank;\\n};\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> groupStrings(vector<string>& words) {\\n        int n = words.size();\\n        vector<int> bitmasks(n);\\n        unordered_set<int> set;\\n        for (int i = 0; i < n; ++i) {\\n            bitmasks[i] = getBitmask(words[i]);\\n            set.emplace(bitmasks[i]);\\n            makeSet(bitmasks[i]);\\n        }   \\n        sort(begin(bitmasks), end(bitmasks));\\n        for (int i = 0; i < n; ++i) {\\n            vector<int> neighbors = getNeighbors(bitmasks[i], set);\\n            for (int neighbor : neighbors) {\\n                unionSet(bitmasks[i], neighbor);\\n            }   \\n        }   \\n        vector<int> ans(2, 0); \\n        unordered_map<int, int> counter;\\n        for (int i = 0; i < n; ++i) {\\n            ans[1] = max(ans[1], ++counter[findSet(bitmasks[i])]);\\n            ans[0] = counter.size();\\n        }   \\n        return ans;\\n    }   \\nprivate:\\n    void makeSet(int x) {\\n        parent[x] = x;\\n        rank[x] = 0;\\n    }   \\n    void unionSet(int x, int y) {\\n        link(findSet(x), findSet(y));\\n    }   \\n    void link(int x, int y) {\\n        if (rank[x] > rank[y]) {\\n            parent[y] = x;\\n        } else {\\n            parent[x] = y;\\n            if (rank[x] == rank[y]) {\\n                ++rank[y];\\n            }   \\n        }   \\n    }   \\n    int findSet(int x) {\\n        return parent[x] == x ? x : (parent[x] = findSet(parent[x]));\\n    }\\n    vector<int> getNeighbors(int bitmask, unordered_set<int>& set) {\\n        vector<int> ans;\\n        for (int i = 0; i < 26; ++i) {\\n            if (auto another = (bitmask ^ (1 << i)); another < bitmask && set.count(another)) {\\n                ans.emplace_back(another);\\n            }   \\n            if (bitmask & (1 << i)) {\\n                for (int j = 0; j < 26; ++j) {\\n                    if ((bitmask & (1 << j)) == 0) {\\n                        if (auto another = bitmask ^ (1 << i) ^ (1 << j); another < bitmask && set.count(another)) {\\n                            ans.emplace_back(another);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    int getBitmask(string& word) {\\n        int ans = 0;\\n        for (char c : word) {\\n            ans |= 1 << (c - \\'a\\');\\n        }\\n        return ans;\\n    }\\n    unordered_map<int, int> parent;\\n    unordered_map<int, int> rank;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1732857,
                "title": "c-union-find-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int find(vector<int>& a, int x) {\\n        if(a[x] == x) {\\n            return x; \\n        }\\n        return a[x] = find(a,a[x]);\\n    }\\n    \\n    void connect(vector<int>& a, vector<int>& r, int i, int j) {\\n        int i_ = find(a,i);\\n        int j_ = find(a,j);\\n        if(i_ == j_) {\\n            return;\\n        }\\n        if(r[i_] > r[j_]) {\\n            a[j_] = i_; \\n        } else {\\n            a[i_] = j_; \\n            if(r[i_] == r[j_]) {\\n                r[j_]++; \\n            }\\n        }\\n    }\\n    \\n    vector<int> groupStrings(vector<string>& words) {\\n        unordered_map<int,int> m; \\n        vector<int> tmp; \\n        for(int i = 0;i<words.size();i++) {\\n            int v = 0; \\n            for(auto ch : words[i]) {\\n                v |= 1 << (ch - \\'a\\');\\n            }\\n            m[v] = i;\\n            tmp.push_back(v);\\n        }\\n        vector<int> a(words.size());\\n        for(int i = 0;i<a.size();i++) {\\n            a[i] = i; \\n        }\\n        vector<int> r(words.size());\\n        for(int i = 0;i<tmp.size();i++) {\\n            const int v = tmp[i];\\n            for(int c = 0;c<26;c++) {\\n                const int y = v ^ (1<<c);\\n                auto ptr = m.find(y);\\n                if(ptr != m.end()) {\\n                    connect(a,r,i,ptr->second);\\n                }\\n                if(v&(1<<c)) {\\n                    for(int b = 0;b<26;b++) {\\n                        if(y&(1<<b)) {\\n                            continue; \\n                        }\\n                        const int x = y ^ (1<<b);\\n                        ptr = m.find(x);\\n                        if(ptr != m.end()) {\\n                            connect(a,r,i,ptr->second);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        unordered_map<int,int> q; \\n        int l = 0; \\n        for(int i = 0;i<words.size();i++) {\\n            const int x = find(a,i);\\n            l = max(l,++q[x]); \\n        }\\n        return {static_cast<int>(q.size()),l};\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int find(vector<int>& a, int x) {\\n        if(a[x] == x) {\\n            return x; \\n        }\\n        return a[x] = find(a,a[x]);\\n    }\\n    \\n    void connect(vector<int>& a, vector<int>& r, int i, int j) {\\n        int i_ = find(a,i);\\n        int j_ = find(a,j);\\n        if(i_ == j_) {\\n            return;\\n        }\\n        if(r[i_] > r[j_]) {\\n            a[j_] = i_; \\n        } else {\\n            a[i_] = j_; \\n            if(r[i_] == r[j_]) {\\n                r[j_]++; \\n            }\\n        }\\n    }\\n    \\n    vector<int> groupStrings(vector<string>& words) {\\n        unordered_map<int,int> m; \\n        vector<int> tmp; \\n        for(int i = 0;i<words.size();i++) {\\n            int v = 0; \\n            for(auto ch : words[i]) {\\n                v |= 1 << (ch - \\'a\\');\\n            }\\n            m[v] = i;\\n            tmp.push_back(v);\\n        }\\n        vector<int> a(words.size());\\n        for(int i = 0;i<a.size();i++) {\\n            a[i] = i; \\n        }\\n        vector<int> r(words.size());\\n        for(int i = 0;i<tmp.size();i++) {\\n            const int v = tmp[i];\\n            for(int c = 0;c<26;c++) {\\n                const int y = v ^ (1<<c);\\n                auto ptr = m.find(y);\\n                if(ptr != m.end()) {\\n                    connect(a,r,i,ptr->second);\\n                }\\n                if(v&(1<<c)) {\\n                    for(int b = 0;b<26;b++) {\\n                        if(y&(1<<b)) {\\n                            continue; \\n                        }\\n                        const int x = y ^ (1<<b);\\n                        ptr = m.find(x);\\n                        if(ptr != m.end()) {\\n                            connect(a,r,i,ptr->second);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        unordered_map<int,int> q; \\n        int l = 0; \\n        for(int i = 0;i<words.size();i++) {\\n            const int x = find(a,i);\\n            l = max(l,++q[x]); \\n        }\\n        return {static_cast<int>(q.size()),l};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1732706,
                "title": "java-union-find-bit-manipulation",
                "content": "The idea is easy to come up with, but the whole implementation really took me some time as I\\'m not super familiar with bitwise operations and it has been a long time since the last time I implemented an union find solution. Glad that I\\'ve gotten an opportunity to practice now : )\\n1. Encoding each string into a 26-digit binary string, and then map it to an integer number. \\n2. Storing the integers in a map\\n3. Count the number of words that are mapped to the same integer first, and storing the count to the map\\n4. For each integer as a key in the map, find all the \"neighbor\" integers that the current integer can be connected to, check if the \"neighbor\" integer exists in the map, if so, connect them, otherwise continue to check the next \"neighbor\" integer\\n5. Using union find to implement the \"connect\" operation.\\n6. Alther the map in step 3 to store the union find element nodes and store the integer count as a property of element node instead.\\n\\n\\n```\\nclass Solution {\\n    \\n    int maxSize = 1;\\n    \\n    int groupCount = 0;\\n    \\n    Map<Integer, Node> map = new HashMap<>();\\n    \\n    public int[] groupStrings(String[] words) {\\n        buildMap(words, map);\\n        groupCount = map.size();\\n        for (int n : map.keySet())\\n            connect(n, map);\\n        return new int[] {groupCount, maxSize};\\n    }\\n\\n    public void buildMap(String[] words, Map<Integer, Node> map) {\\n        for (String word : words) {\\n            int[] bits = new int[26];\\n            for (char c : word.toCharArray()) bits[c - \\'a\\']++;\\n            int n = 0;\\n            for (int i = 0; i < 26; i++) n = (n << 1) + bits[i];\\n            map.putIfAbsent(n, new Node());\\n            map.get(n).size++;\\n            maxSize = Math.max(maxSize, map.get(n).size);\\n        }\\n    }\\n\\n    public void connect(int n, Map<Integer, Node> map) {\\n        int d1 = 1;\\n        for (int i = 0; i < 26; i++) {\\n            // check n & delta\\n            // n & delta != 0: connect with n - delta\\n            // n & delta == 0: connect with n + delta if exists\\n            if ((n & d1) == 0) {\\n                if (map.containsKey(n + d1)) map.get(n).union(map.get(n + d1));\\n            } else {\\n                if (map.containsKey(n - d1)) map.get(n).union(map.get(n - d1));\\n            }\\n            // find all combinations of replacements\\n            int d2 = d1;\\n            for (int j = i + 1; j < 26; j++) {\\n                d2 = d2 << 1;\\n                // check n & d2\\n                if ((n & d2) > 0 && (n & d1) == 0) {\\n                    // connect with n + d1 - d2\\n                    if (map.containsKey(n + d1 - d2)) map.get(n).union(map.get(n + d1 - d2));\\n                } else if ((n & d2) == 0 && (n & d1) > 0) {\\n                    // connect with n - d1 + d2\\n                    if (map.containsKey(n - d1 + d2)) map.get(n).union(map.get(n - d1 + d2));\\n                }\\n            }\\n            d1 = d1 << 1;\\n        }\\n    }\\n\\n    private class Node {\\n \\n        int size = 0;\\n        Node father = null;\\n\\n        public Node find() {\\n            Node curr = this;\\n            while (curr.father != null) {\\n                curr = curr.father;\\n            }\\n            if (this.father != null) this.father = curr;\\n            return curr;\\n        }\\n        \\n        public void union(Node other) {\\n            Node ancesterOther = other.find();\\n            Node ancesterThis = this.find();\\n            if (ancesterThis != ancesterOther) {\\n                ancesterOther.father = ancesterThis;\\n                ancesterThis.size += ancesterOther.size;\\n                maxSize = Math.max(maxSize, ancesterThis.size);\\n                groupCount--;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    int maxSize = 1;\\n    \\n    int groupCount = 0;\\n    \\n    Map<Integer, Node> map = new HashMap<>();\\n    \\n    public int[] groupStrings(String[] words) {\\n        buildMap(words, map);\\n        groupCount = map.size();\\n        for (int n : map.keySet())\\n            connect(n, map);\\n        return new int[] {groupCount, maxSize};\\n    }\\n\\n    public void buildMap(String[] words, Map<Integer, Node> map) {\\n        for (String word : words) {\\n            int[] bits = new int[26];\\n            for (char c : word.toCharArray()) bits[c - \\'a\\']++;\\n            int n = 0;\\n            for (int i = 0; i < 26; i++) n = (n << 1) + bits[i];\\n            map.putIfAbsent(n, new Node());\\n            map.get(n).size++;\\n            maxSize = Math.max(maxSize, map.get(n).size);\\n        }\\n    }\\n\\n    public void connect(int n, Map<Integer, Node> map) {\\n        int d1 = 1;\\n        for (int i = 0; i < 26; i++) {\\n            // check n & delta\\n            // n & delta != 0: connect with n - delta\\n            // n & delta == 0: connect with n + delta if exists\\n            if ((n & d1) == 0) {\\n                if (map.containsKey(n + d1)) map.get(n).union(map.get(n + d1));\\n            } else {\\n                if (map.containsKey(n - d1)) map.get(n).union(map.get(n - d1));\\n            }\\n            // find all combinations of replacements\\n            int d2 = d1;\\n            for (int j = i + 1; j < 26; j++) {\\n                d2 = d2 << 1;\\n                // check n & d2\\n                if ((n & d2) > 0 && (n & d1) == 0) {\\n                    // connect with n + d1 - d2\\n                    if (map.containsKey(n + d1 - d2)) map.get(n).union(map.get(n + d1 - d2));\\n                } else if ((n & d2) == 0 && (n & d1) > 0) {\\n                    // connect with n - d1 + d2\\n                    if (map.containsKey(n - d1 + d2)) map.get(n).union(map.get(n - d1 + d2));\\n                }\\n            }\\n            d1 = d1 << 1;\\n        }\\n    }\\n\\n    private class Node {\\n \\n        int size = 0;\\n        Node father = null;\\n\\n        public Node find() {\\n            Node curr = this;\\n            while (curr.father != null) {\\n                curr = curr.father;\\n            }\\n            if (this.father != null) this.father = curr;\\n            return curr;\\n        }\\n        \\n        public void union(Node other) {\\n            Node ancesterOther = other.find();\\n            Node ancesterThis = this.find();\\n            if (ancesterThis != ancesterOther) {\\n                ancesterOther.father = ancesterThis;\\n                ancesterThis.size += ancesterOther.size;\\n                maxSize = Math.max(maxSize, ancesterThis.size);\\n                groupCount--;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1732554,
                "title": "python-with-comments-explaination",
                "content": "```\\nclass Solution:\\n    def groupStrings(self, words: List[str]) -> List[int]:\\n        # build graph, DFS\\n        # + bit mask\\n        def get_mask(word):\\n            mask = 0\\n            word_set = set(word)\\n            for i in range(26):\\n                if letter[i] in word_set:\\n                    mask |= (1 << i)\\n            return mask\\n        \\n        letter = \"abcdefghijklmnopqrstuvwxyz\"\\n        n = len(words)\\n        \\n        #split words into sets according to masks\\n        masks = {}\\n        for word in words:\\n            mask = get_mask(word)\\n            masks[mask] = masks.get(mask, 0) + 1\\n        \\n        G = {} # {u: {v}}\\n        \\n        msb = lambda x: 1 << (x.bit_length() - 1)\\n        \\n        def get_neighbors(mask):\\n            res1 = set() # remove one bit\\n            res2 = set() # add one bit\\n            temp = mask\\n            rest = 0\\n            while temp:\\n                rest += temp & -temp # add lsb\\n                temp &= (temp - 1) # clear lsb\\n                res1.add(rest & ~msb(rest) | temp)\\n            zeros = mask ^ ((1 << 26) - 1)\\n            while zeros:\\n                lsb = zeros & -zeros # lsb\\n                zeros &= (zeros - 1) # clear lsb\\n                res2.add(mask | lsb)\\n            res3 = set()\\n            for mask1 in res1:\\n                for mask2 in res2:\\n                    res3.add(mask1 ^ (mask2 ^ mask)) # add one bit and then remove one bit\\n            # print(\\'mask:\\', mask, \"res:\", res)\\n            res = res1 | res2 | res3\\n            return res\\n    \\n        # O(1) verifier, no use\\n        def is_connected(mask1, mask2):\\n            diff = mask1 ^ mask2\\n            diff1 = diff & mask1\\n            diff2 = diff & mask2\\n            return not diff1 & (diff1 - 1) and not diff2 & (diff2 - 1)\\n        \\n        def add_edge(G, u, v):\\n            if u in G:\\n                G[u].add(v)\\n            else:\\n                G[u] = {v}\\n        \\n        # build graph O(n * 26 * 26), better than O(n ^ 2) using verifier (TLE)\\n        for mask in masks.keys():\\n            for neighbor in get_neighbors(mask):\\n                if neighbor in masks:\\n                    add_edge(G, mask, neighbor)\\n        \\n        # print(G)\\n        \\n        # full-DFS\\n        seen = set()\\n        mx = 0\\n        size = 0\\n        ct = 0\\n        \\n        def dfs(u):\\n            nonlocal size\\n            size += masks[u]\\n            if u in G:\\n                for v in G[u]:\\n                    if v not in seen:\\n                        seen.add(v)\\n                        dfs(v)\\n    \\n        for mask in masks.keys():\\n            if mask not in seen:\\n                ct += 1\\n                size = 0\\n                seen.add(mask)\\n                dfs(mask)\\n                mx = max(mx, size)\\n                \\n        return [ct, mx]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def groupStrings(self, words: List[str]) -> List[int]:\\n        # build graph, DFS\\n        # + bit mask\\n        def get_mask(word):\\n            mask = 0\\n            word_set = set(word)\\n            for i in range(26):\\n                if letter[i] in word_set:\\n                    mask |= (1 << i)\\n            return mask\\n        \\n        letter = \"abcdefghijklmnopqrstuvwxyz\"\\n        n = len(words)\\n        \\n        #split words into sets according to masks\\n        masks = {}\\n        for word in words:\\n            mask = get_mask(word)\\n            masks[mask] = masks.get(mask, 0) + 1\\n        \\n        G = {} # {u: {v}}\\n        \\n        msb = lambda x: 1 << (x.bit_length() - 1)\\n        \\n        def get_neighbors(mask):\\n            res1 = set() # remove one bit\\n            res2 = set() # add one bit\\n            temp = mask\\n            rest = 0\\n            while temp:\\n                rest += temp & -temp # add lsb\\n                temp &= (temp - 1) # clear lsb\\n                res1.add(rest & ~msb(rest) | temp)\\n            zeros = mask ^ ((1 << 26) - 1)\\n            while zeros:\\n                lsb = zeros & -zeros # lsb\\n                zeros &= (zeros - 1) # clear lsb\\n                res2.add(mask | lsb)\\n            res3 = set()\\n            for mask1 in res1:\\n                for mask2 in res2:\\n                    res3.add(mask1 ^ (mask2 ^ mask)) # add one bit and then remove one bit\\n            # print(\\'mask:\\', mask, \"res:\", res)\\n            res = res1 | res2 | res3\\n            return res\\n    \\n        # O(1) verifier, no use\\n        def is_connected(mask1, mask2):\\n            diff = mask1 ^ mask2\\n            diff1 = diff & mask1\\n            diff2 = diff & mask2\\n            return not diff1 & (diff1 - 1) and not diff2 & (diff2 - 1)\\n        \\n        def add_edge(G, u, v):\\n            if u in G:\\n                G[u].add(v)\\n            else:\\n                G[u] = {v}\\n        \\n        # build graph O(n * 26 * 26), better than O(n ^ 2) using verifier (TLE)\\n        for mask in masks.keys():\\n            for neighbor in get_neighbors(mask):\\n                if neighbor in masks:\\n                    add_edge(G, mask, neighbor)\\n        \\n        # print(G)\\n        \\n        # full-DFS\\n        seen = set()\\n        mx = 0\\n        size = 0\\n        ct = 0\\n        \\n        def dfs(u):\\n            nonlocal size\\n            size += masks[u]\\n            if u in G:\\n                for v in G[u]:\\n                    if v not in seen:\\n                        seen.add(v)\\n                        dfs(v)\\n    \\n        for mask in masks.keys():\\n            if mask not in seen:\\n                ct += 1\\n                size = 0\\n                seen.add(mask)\\n                dfs(mask)\\n                mx = max(mx, size)\\n                \\n        return [ct, mx]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1732495,
                "title": "java-random-tle-issue",
                "content": "Hi all,\\n\\nI have a java solution for this problem but got random TLE issue: without any code change, the solution may be accepted sometimes and TLE in others. Anyone can help me to figure out the reason? Also, any idea for the code improvement?\\n\\n```\\nclass Solution {\\n    public int[] groupStrings(String[] words) {\\n        Map<Long, Integer> indexMap = new HashMap<>();\\n        Map<String, Long> encodeMap = new HashMap<>();\\n        \\n        int[] count = new int[words.length];\\n        int[] parent = new int[words.length];\\n        \\n        int parentCount = 0;\\n        int max = 1;\\n\\n        for (int i = 0; i < words.length; i ++) {\\n            if (!encodeMap.containsKey(words[i])) {\\n                encodeMap.put(words[i], encode(words[i]));\\n            }\\n            \\n            long encodeValue = encodeMap.get(words[i]);;\\n            \\n            if (!indexMap.containsKey(encodeValue)) {\\n                indexMap.put(encodeValue, i);\\n            }\\n            \\n            int index = indexMap.get(encodeValue);\\n            count[index] ++;\\n            parent[index] = index;\\n            \\n            max = Math.max(max, count[index]);\\n        }\\n        \\n        for (long curWord: indexMap.keySet()) {\\n            \\n            int curParentIndex = findParent(indexMap.get(curWord), parent);\\n            parentCount ++;\\n\\n            for (long nextWord: findNextWord(curWord)) {\\n                if (!indexMap.containsKey(nextWord)) {\\n                    continue;\\n                }\\n                \\n                int nextParentIndex = findParent(indexMap.get(nextWord), parent);\\n                \\n                if (curParentIndex == nextParentIndex) {\\n                    continue;\\n                }\\n                \\n                parentCount --;\\n                \\n                parent[nextParentIndex] = curParentIndex;\\n                count[curParentIndex] += count[nextParentIndex];\\n                \\n                max = Math.max(max, count[curParentIndex]);\\n            }\\n            \\n        }\\n        \\n        return new int[] {parentCount, max};\\n    }\\n    \\n    private int findParent(int num, int[] parent) {\\n        if (parent[num] == num) {\\n            return num;\\n        }\\n        return parent[num] = findParent(parent[num], parent);\\n    }\\n    \\n    private Set<Long> findNextWord(long num) {\\n        Set<Long> res = new HashSet<>();\\n        \\n        for (int i = 0; i < 26; i ++) {\\n            res.add(num ^ (1 << i));\\n        }\\n        \\n        for (int i = 0; i < 26; i ++) {\\n            if (((num & (1 << i)) > 0)) {\\n                for (int j = 0; j < 26; j ++) {\\n                    if (((num & (1 << j)) == 0)) {\\n                        res.add(num - (1 << i) + (1 << j));\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n    \\n    private long encode(String str) {\\n        long res = 0;\\n        \\n        for (char ch: str.toCharArray()) {\\n            res += (1 << (ch - \\'a\\'));\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] groupStrings(String[] words) {\\n        Map<Long, Integer> indexMap = new HashMap<>();\\n        Map<String, Long> encodeMap = new HashMap<>();\\n        \\n        int[] count = new int[words.length];\\n        int[] parent = new int[words.length];\\n        \\n        int parentCount = 0;\\n        int max = 1;\\n\\n        for (int i = 0; i < words.length; i ++) {\\n            if (!encodeMap.containsKey(words[i])) {\\n                encodeMap.put(words[i], encode(words[i]));\\n            }\\n            \\n            long encodeValue = encodeMap.get(words[i]);;\\n            \\n            if (!indexMap.containsKey(encodeValue)) {\\n                indexMap.put(encodeValue, i);\\n            }\\n            \\n            int index = indexMap.get(encodeValue);\\n            count[index] ++;\\n            parent[index] = index;\\n            \\n            max = Math.max(max, count[index]);\\n        }\\n        \\n        for (long curWord: indexMap.keySet()) {\\n            \\n            int curParentIndex = findParent(indexMap.get(curWord), parent);\\n            parentCount ++;\\n\\n            for (long nextWord: findNextWord(curWord)) {\\n                if (!indexMap.containsKey(nextWord)) {\\n                    continue;\\n                }\\n                \\n                int nextParentIndex = findParent(indexMap.get(nextWord), parent);\\n                \\n                if (curParentIndex == nextParentIndex) {\\n                    continue;\\n                }\\n                \\n                parentCount --;\\n                \\n                parent[nextParentIndex] = curParentIndex;\\n                count[curParentIndex] += count[nextParentIndex];\\n                \\n                max = Math.max(max, count[curParentIndex]);\\n            }\\n            \\n        }\\n        \\n        return new int[] {parentCount, max};\\n    }\\n    \\n    private int findParent(int num, int[] parent) {\\n        if (parent[num] == num) {\\n            return num;\\n        }\\n        return parent[num] = findParent(parent[num], parent);\\n    }\\n    \\n    private Set<Long> findNextWord(long num) {\\n        Set<Long> res = new HashSet<>();\\n        \\n        for (int i = 0; i < 26; i ++) {\\n            res.add(num ^ (1 << i));\\n        }\\n        \\n        for (int i = 0; i < 26; i ++) {\\n            if (((num & (1 << i)) > 0)) {\\n                for (int j = 0; j < 26; j ++) {\\n                    if (((num & (1 << j)) == 0)) {\\n                        res.add(num - (1 << i) + (1 << j));\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n    \\n    private long encode(String str) {\\n        long res = 0;\\n        \\n        for (char ch: str.toCharArray()) {\\n            res += (1 << (ch - \\'a\\'));\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1732302,
                "title": "javascript-union-find-bit-manipulation-o-26-n",
                "content": "This is a combination of two types of problems:\\n1. We have disjoint sets of strings that form graphs where they\\'re connected through replacing, adding or removing a letter. Standard Union Find problem.\\n2. We have to find a way to modify the strings to efficiently find connections between them. This is basically the same as https://leetcode.com/problems/word-ladder/. We have to test for two things:\\n    1. Addition / Removal - If we were working with strings this would be clunky, but since all letters are unique and we don\\'t care about their order, We can store them in a bit-mask and just add bits where they don\\'t exist, or remove bits where they do for each letter.\\n\\t2. Replacement - there are two approaches as far as I know:\\n    \\n        take each letter of a word and replace it with every other letter in the alphabet and see if there are matches\\n        ```abc``` -> ```bbc``` -> ```cbc```\\n        replace each letter with a wildcard and store each version in a map.\\n\\t    ```*bc``` -> ```a*c``` -> ```ab*```\\n\\t\\t\\n        The bit-mask version of the second strategy would be to remove a bit and set a non-letter bit (like 31). Setting a non-letter bit kinda seems pointless, but the reason removing a bit is not the same as replacing is that you can\\'t do two-way transformations, e.g. ```a``` cannot become ```abc``` by adding a letter and having ```abc``` remove a letter. Though maybe you could avoid this problem by using separate maps.\\n\\nA lot of people seem to like the \"try every letter\" version of replacement. I think that choice simplifies word-ladder a lot, but in this case I\\'m going with the wildcard version for two reasons - we have lower space requirements by storing numbers instead of strings in our map, and we don\\'t have to store ALL of the matching words in an array, we can store any of them because we\\'re doing Union Find to link them together.\\n\\n```\\nvar groupStrings = function(words) {\\n  const groups = new Array(words.length).fill(0).map((_, i) => i);\\n  const sizes = groups.map(() => 1);\\n  \\n  const find = (group) => {\\n    groups[group] = groups[group] === group ? group : find(groups[group]);\\n    return groups[group];\\n  }\\n  \\n  const union = (a, b) => {\\n    const groupA = find(a);\\n    const groupB = find(b);\\n    \\n\\t// do this check so we don\\'t add a groupSize more than once\\n    if (groupA === groupB) return;\\n    \\n    if (sizes[groupA] > sizes[groupB]) {\\n      groups[groupB] = groupA;\\n      sizes[groupA] += sizes[groupB];\\n    } else {\\n      groups[groupA] = groupB;\\n      sizes[groupB] += sizes[groupA];\\n    }\\n  }\\n  \\n  const aCode = \\'a\\'.charCodeAt(0);\\n  const lookup = new Map();\\n  \\n  words.forEach((word, i) => {\\n    let bits = 0;\\n    \\n\\t// build a bit-mask of letters in positions 0-25\\n    for (let j = 0; j < word.length; j += 1) {\\n      const bit = word.charCodeAt(j) - aCode;\\n      bits |= 1 << bit;\\n    }\\n    \\n\\t// this will be used to connect words through adding/removing\\n\\t// we could have done a bucket sort in O(n) by word length\\n\\t// in which case we wouldn\\'t have to check for removing\\n    lookup.set(bits, i);\\n    \\n    for (let j = 0; j < 26; j += 1) {\\n\\t  // if the letter exists, we\\'ll try removing and replacing\\n      if (bits & 1 << j) {\\n        const removed = bits ^ 1 << j;\\n        \\n        if (lookup.has(removed)) union(i, lookup.get(removed));\\n        \\n        const replaced = removed | 1 << 31;\\n        \\n        if (lookup.has(replaced)) {\\n          union(i, lookup.get(replaced))\\n        } else {\\n          lookup.set(replaced, i);\\n        }\\n      // otherwise, just try adding\\n      } else {\\n        const added = bits | 1 << j;\\n\\n        if (lookup.has(added)) union(i, lookup.get(added));\\n      }\\n    }\\n  });\\n\\n  let count = 0;\\n  let max = 0;\\n  \\n  for (let i = 0; i < words.length; i += 1) {\\n    const group = find(i);\\n    const groupSize = sizes[group];\\n    \\n    if (!groupSize) continue;\\n    \\n\\t// set groupSize to 0 so we don\\'t count it again\\n\\t// now we\\'re only counting unique groups\\n    sizes[group] = 0;\\n    count += 1;\\n    max = Math.max(max, groupSize);\\n  }\\n  \\n  return [count, max];\\n};\\n```",
                "solutionTags": [
                    "Bit Manipulation",
                    "Union Find"
                ],
                "code": "```abc```\n```bbc```\n```cbc```\n```*bc```\n```a*c```\n```ab*```\n```a```\n```abc```\n```abc```\n```\\nvar groupStrings = function(words) {\\n  const groups = new Array(words.length).fill(0).map((_, i) => i);\\n  const sizes = groups.map(() => 1);\\n  \\n  const find = (group) => {\\n    groups[group] = groups[group] === group ? group : find(groups[group]);\\n    return groups[group];\\n  }\\n  \\n  const union = (a, b) => {\\n    const groupA = find(a);\\n    const groupB = find(b);\\n    \\n\\t// do this check so we don\\'t add a groupSize more than once\\n    if (groupA === groupB) return;\\n    \\n    if (sizes[groupA] > sizes[groupB]) {\\n      groups[groupB] = groupA;\\n      sizes[groupA] += sizes[groupB];\\n    } else {\\n      groups[groupA] = groupB;\\n      sizes[groupB] += sizes[groupA];\\n    }\\n  }\\n  \\n  const aCode = \\'a\\'.charCodeAt(0);\\n  const lookup = new Map();\\n  \\n  words.forEach((word, i) => {\\n    let bits = 0;\\n    \\n\\t// build a bit-mask of letters in positions 0-25\\n    for (let j = 0; j < word.length; j += 1) {\\n      const bit = word.charCodeAt(j) - aCode;\\n      bits |= 1 << bit;\\n    }\\n    \\n\\t// this will be used to connect words through adding/removing\\n\\t// we could have done a bucket sort in O(n) by word length\\n\\t// in which case we wouldn\\'t have to check for removing\\n    lookup.set(bits, i);\\n    \\n    for (let j = 0; j < 26; j += 1) {\\n\\t  // if the letter exists, we\\'ll try removing and replacing\\n      if (bits & 1 << j) {\\n        const removed = bits ^ 1 << j;\\n        \\n        if (lookup.has(removed)) union(i, lookup.get(removed));\\n        \\n        const replaced = removed | 1 << 31;\\n        \\n        if (lookup.has(replaced)) {\\n          union(i, lookup.get(replaced))\\n        } else {\\n          lookup.set(replaced, i);\\n        }\\n      // otherwise, just try adding\\n      } else {\\n        const added = bits | 1 << j;\\n\\n        if (lookup.has(added)) union(i, lookup.get(added));\\n      }\\n    }\\n  });\\n\\n  let count = 0;\\n  let max = 0;\\n  \\n  for (let i = 0; i < words.length; i += 1) {\\n    const group = find(i);\\n    const groupSize = sizes[group];\\n    \\n    if (!groupSize) continue;\\n    \\n\\t// set groupSize to 0 so we don\\'t count it again\\n\\t// now we\\'re only counting unique groups\\n    sizes[group] = 0;\\n    count += 1;\\n    max = Math.max(max, groupSize);\\n  }\\n  \\n  return [count, max];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1732299,
                "title": "c-dsu-bitmask",
                "content": "Time Complexity - O(26 * apha(N) * N)\\nSpace Complexity - O(26 * N)\\n\\n```\\nclass Solution {\\n    unordered_map<int, int> freq, parent, size;\\n    void init(int x) {\\n        parent[x] = x;\\n        size[x] = freq[x];\\n    }\\n    \\n    int find(int x) {\\n        if (x == parent[x]) \\n            return x;\\n        return parent[x] = find(parent[x]);\\n    }\\n    \\n    void Union(int x, int y) {\\n        if (!size[x]) init(x);\\n        if (!size[y]) init(y);\\n        x = find(x), y = find(y);\\n        if (x != y) {\\n\\t\\t    if (size[x] < size[y])\\n                swap(x, y);\\n            parent[y] = x;\\n            size[x] += size[y];\\n        }\\n    }\\npublic:\\n    vector<int> groupStrings(vector<string>& words) {\\n        unordered_map<int, int> one_off;\\n        for (string word: words) {\\n            int mask = 0;\\n            for (char x: word)\\n                mask |= 1 << (x - \\'a\\');\\n            freq[mask]++;\\n        }\\n        for (auto it: freq) {\\n            int mask = it.first, flag = 0;\\n            for (int i = 0; i < 26; i++) {\\n                int mask_v2 = mask ^ (1 << i);\\n                if (mask & (1 << i)) {\\n                    if (one_off[mask_v2])\\n                        Union(mask, one_off[mask_v2]), flag = 1;\\n                    else\\n                        one_off[mask_v2] = mask;\\n                }\\n                if (freq.find(mask_v2) != freq.end())\\n                    Union(mask, mask_v2), flag = 1;\\n            }\\n            if (!flag)\\n                init(mask);\\n        }\\n        int total = 0, max_group = 0;\\n        for (auto it: parent) {\\n            if (it.first == it.second) {\\n                total++;\\n                max_group = max(max_group, size[it.first]);\\n            }\\n        }\\n        vector<int> ans = {total, max_group};\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    unordered_map<int, int> freq, parent, size;\\n    void init(int x) {\\n        parent[x] = x;\\n        size[x] = freq[x];\\n    }\\n    \\n    int find(int x) {\\n        if (x == parent[x]) \\n            return x;\\n        return parent[x] = find(parent[x]);\\n    }\\n    \\n    void Union(int x, int y) {\\n        if (!size[x]) init(x);\\n        if (!size[y]) init(y);\\n        x = find(x), y = find(y);\\n        if (x != y) {\\n\\t\\t    if (size[x] < size[y])\\n                swap(x, y);\\n            parent[y] = x;\\n            size[x] += size[y];\\n        }\\n    }\\npublic:\\n    vector<int> groupStrings(vector<string>& words) {\\n        unordered_map<int, int> one_off;\\n        for (string word: words) {\\n            int mask = 0;\\n            for (char x: word)\\n                mask |= 1 << (x - \\'a\\');\\n            freq[mask]++;\\n        }\\n        for (auto it: freq) {\\n            int mask = it.first, flag = 0;\\n            for (int i = 0; i < 26; i++) {\\n                int mask_v2 = mask ^ (1 << i);\\n                if (mask & (1 << i)) {\\n                    if (one_off[mask_v2])\\n                        Union(mask, one_off[mask_v2]), flag = 1;\\n                    else\\n                        one_off[mask_v2] = mask;\\n                }\\n                if (freq.find(mask_v2) != freq.end())\\n                    Union(mask, mask_v2), flag = 1;\\n            }\\n            if (!flag)\\n                init(mask);\\n        }\\n        int total = 0, max_group = 0;\\n        for (auto it: parent) {\\n            if (it.first == it.second) {\\n                total++;\\n                max_group = max(max_group, size[it.first]);\\n            }\\n        }\\n        vector<int> ans = {total, max_group};\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1731986,
                "title": "why-o-n-169-complexition-gets-tle-how-to-optimize",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    vector<int> groupStrings(vector<string> &words)\\n    {\\n        int n = words.size();\\n        vector<int> reps(n);\\n        for (int i = 0; i < n; ++i)\\n        {\\n            for (int j = 0; j < words[i].size(); ++j)\\n            {\\n                reps[i] |= 1 << (words[i][j] - \\'a\\');\\n            }\\n        }\\n        unordered_map<int, int> cnts;\\n        for (int x : reps)\\n        {\\n            cnts[x]++;\\n        }\\n        auto adj = [](int x) -> vector<int> {\\n            vector<int> ans, zeros, ones;\\n            for (int i = 0; i < 26; ++i)\\n            {\\n                ans.emplace_back(x ^ (1 << i));\\n                if (x & (1 << i))\\n                {\\n                    ones.emplace_back(i);\\n                }\\n                else\\n                {\\n                    zeros.emplace_back(i);\\n                }\\n            }\\n            for (int i : ones)\\n            {\\n                for (int j : zeros)\\n                {\\n                    ans.emplace_back(x ^ (1 << i) ^ (1 << j));\\n                }\\n            }\\n            return ans;\\n        };\\n        unordered_set<int> vis;\\n        queue<int> q;\\n        vector<int> ans(2);\\n        for (auto& [u, occ] : cnts)\\n        {\\n            if (vis.find(u) != vis.end())\\n            {\\n                continue;\\n            }\\n            int total = occ;\\n            q.emplace(u);\\n            vis.emplace(u);\\n            while (!q.empty())\\n            {\\n                auto x = q.front();\\n                q.pop();\\n                for (int y : adj(x))\\n                {\\n                    if (vis.find(y) != vis.end() || cnts.find(y) == cnts.end())\\n                    {\\n                        continue;\\n                    }\\n                    total += cnts[y];\\n                    vis.emplace(y);\\n                    q.emplace(y);\\n                }\\n            }\\n            ans[0]++;\\n            ans[1] = max(ans[1], total);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    vector<int> groupStrings(vector<string> &words)\\n    {\\n        int n = words.size();\\n        vector<int> reps(n);\\n        for (int i = 0; i < n; ++i)\\n        {\\n            for (int j = 0; j < words[i].size(); ++j)\\n            {\\n                reps[i] |= 1 << (words[i][j] - \\'a\\');\\n            }\\n        }\\n        unordered_map<int, int> cnts;\\n        for (int x : reps)\\n        {\\n            cnts[x]++;\\n        }\\n        auto adj = [](int x) -> vector<int> {\\n            vector<int> ans, zeros, ones;\\n            for (int i = 0; i < 26; ++i)\\n            {\\n                ans.emplace_back(x ^ (1 << i));\\n                if (x & (1 << i))\\n                {\\n                    ones.emplace_back(i);\\n                }\\n                else\\n                {\\n                    zeros.emplace_back(i);\\n                }\\n            }\\n            for (int i : ones)\\n            {\\n                for (int j : zeros)\\n                {\\n                    ans.emplace_back(x ^ (1 << i) ^ (1 << j));\\n                }\\n            }\\n            return ans;\\n        };\\n        unordered_set<int> vis;\\n        queue<int> q;\\n        vector<int> ans(2);\\n        for (auto& [u, occ] : cnts)\\n        {\\n            if (vis.find(u) != vis.end())\\n            {\\n                continue;\\n            }\\n            int total = occ;\\n            q.emplace(u);\\n            vis.emplace(u);\\n            while (!q.empty())\\n            {\\n                auto x = q.front();\\n                q.pop();\\n                for (int y : adj(x))\\n                {\\n                    if (vis.find(y) != vis.end() || cnts.find(y) == cnts.end())\\n                    {\\n                        continue;\\n                    }\\n                    total += cnts[y];\\n                    vis.emplace(y);\\n                    q.emplace(y);\\n                }\\n            }\\n            ans[0]++;\\n            ans[1] = max(ans[1], total);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1731725,
                "title": "union-find-hashsets",
                "content": "```\\nimport java.util.Map.Entry;\\n\\nclass Solution {\\n    public int[] groupStrings(String[] words) {\\n        int n = words.length;\\n        Map<String, Integer> ids =new HashMap<>();\\n        UF uf = new UF(n);\\n        for(int i=0;i<n;i++){\\n            var word = sort(words[i]);\\n            if(ids.containsKey(word)){\\n                uf.union(ids.get(word),i);\\n            }else{\\n                ids.put(word,i);\\n            }\\n        }\\n        Map<String, Integer> partTransformed = new HashMap<>();\\n        for(Entry<String,Integer> entry: ids.entrySet()){\\n            var word = entry.getKey();\\n            int id = entry.getValue();\\n            for(int j=0;j<word.length();j++){\\n                var wordAfterDeletion = word.substring(0,j)+word.substring(j+1);\\n                if(ids.containsKey(wordAfterDeletion)){\\n                    uf.union(ids.get(wordAfterDeletion),id);\\n                }\\n                \\n                if(partTransformed.containsKey(wordAfterDeletion)){\\n                     uf.union(partTransformed.get(wordAfterDeletion),id);\\n                }else{\\n                    partTransformed.put(wordAfterDeletion,id);\\n                }\\n            }\\n        }\\n        \\n        return new int[]{uf.count(),uf.maxSize()};\\n    }\\n    \\n    class UF{\\n        int[] id;\\n        int[] size;\\n        int count;\\n        int maxSize=1;\\n        \\n        UF(int n){\\n            id = new int[n];\\n            size = new int[n];\\n            Arrays.fill(size,1);\\n            Arrays.setAll(id, i->i);\\n            count =n;\\n        }\\n        \\n        void union(int a,int b){\\n            // System.out.println(a+\" \"+b);\\n            if(a==b){\\n                return;\\n            }\\n            var ra = root(a);\\n            var rb = root(b);\\n            if(ra==rb){\\n                return;\\n            }\\n            maxSize = Math.max(maxSize,size[rb]+size[ra]);\\n            if(size[ra]>size[rb]){\\n                id[rb] = ra;\\n                size[ra] += size[rb];\\n            }else{\\n                size[rb] += size[ra];\\n                id[ra]=rb;\\n            }\\n            count--;\\n        }\\n        \\n        int root(int a){\\n            while(a!=id[a]){\\n                id[a]=id[id[a]];\\n                a=id[a];\\n            }\\n            return a;\\n        }\\n        \\n        int count(){\\n            return count;\\n        }\\n        \\n        int maxSize(){\\n            return maxSize;           \\n        }\\n    }\\n    \\n    String sort(String s){\\n        var chars = s.toCharArray();\\n        Arrays.sort(chars);\\n        return new String(chars).intern();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.Map.Entry;\\n\\nclass Solution {\\n    public int[] groupStrings(String[] words) {\\n        int n = words.length;\\n        Map<String, Integer> ids =new HashMap<>();\\n        UF uf = new UF(n);\\n        for(int i=0;i<n;i++){\\n            var word = sort(words[i]);\\n            if(ids.containsKey(word)){\\n                uf.union(ids.get(word),i);\\n            }else{\\n                ids.put(word,i);\\n            }\\n        }\\n        Map<String, Integer> partTransformed = new HashMap<>();\\n        for(Entry<String,Integer> entry: ids.entrySet()){\\n            var word = entry.getKey();\\n            int id = entry.getValue();\\n            for(int j=0;j<word.length();j++){\\n                var wordAfterDeletion = word.substring(0,j)+word.substring(j+1);\\n                if(ids.containsKey(wordAfterDeletion)){\\n                    uf.union(ids.get(wordAfterDeletion),id);\\n                }\\n                \\n                if(partTransformed.containsKey(wordAfterDeletion)){\\n                     uf.union(partTransformed.get(wordAfterDeletion),id);\\n                }else{\\n                    partTransformed.put(wordAfterDeletion,id);\\n                }\\n            }\\n        }\\n        \\n        return new int[]{uf.count(),uf.maxSize()};\\n    }\\n    \\n    class UF{\\n        int[] id;\\n        int[] size;\\n        int count;\\n        int maxSize=1;\\n        \\n        UF(int n){\\n            id = new int[n];\\n            size = new int[n];\\n            Arrays.fill(size,1);\\n            Arrays.setAll(id, i->i);\\n            count =n;\\n        }\\n        \\n        void union(int a,int b){\\n            // System.out.println(a+\" \"+b);\\n            if(a==b){\\n                return;\\n            }\\n            var ra = root(a);\\n            var rb = root(b);\\n            if(ra==rb){\\n                return;\\n            }\\n            maxSize = Math.max(maxSize,size[rb]+size[ra]);\\n            if(size[ra]>size[rb]){\\n                id[rb] = ra;\\n                size[ra] += size[rb];\\n            }else{\\n                size[rb] += size[ra];\\n                id[ra]=rb;\\n            }\\n            count--;\\n        }\\n        \\n        int root(int a){\\n            while(a!=id[a]){\\n                id[a]=id[id[a]];\\n                a=id[a];\\n            }\\n            return a;\\n        }\\n        \\n        int count(){\\n            return count;\\n        }\\n        \\n        int maxSize(){\\n            return maxSize;           \\n        }\\n    }\\n    \\n    String sort(String s){\\n        var chars = s.toCharArray();\\n        Arrays.sort(chars);\\n        return new String(chars).intern();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1731651,
                "title": "rust-union-find",
                "content": "```\\nuse std::collections::HashMap;\\n\\npub struct Dsu {\\n    n: usize,\\n    // root node: -1 * component size\\n    // otherwise: parent\\n    parent_or_size: Vec<i32>,\\n}\\n\\nimpl Dsu {\\n    // 0 <= size <= 10^8 is constrained.\\n    pub fn new(size: usize) -> Self {\\n        Self {\\n            n: size,\\n            parent_or_size: vec![-1; size],\\n        }\\n    }\\n    pub fn merge(&mut self, a: usize, b: usize) -> usize {\\n        let (mut x, mut y) = (self.leader(a), self.leader(b));\\n        if x == y {\\n            return x;\\n        }\\n        if -self.parent_or_size[x] < -self.parent_or_size[y] {\\n            std::mem::swap(&mut x, &mut y);\\n        }\\n        self.parent_or_size[x] += self.parent_or_size[y];\\n        self.parent_or_size[y] = x as i32;\\n        x\\n    }\\n\\n    pub fn same(&mut self, a: usize, b: usize) -> bool {\\n        self.leader(a) == self.leader(b)\\n    }\\n    pub fn leader(&mut self, a: usize) -> usize {\\n        if self.parent_or_size[a] < 0 {\\n            return a;\\n        }\\n        self.parent_or_size[a] = self.leader(self.parent_or_size[a] as usize) as i32;\\n        self.parent_or_size[a] as usize\\n    }\\n    pub fn group_size(&mut self) -> Vec<i32> {\\n        let mut cnt = 0;\\n        let mut max = 0;\\n        for i in 0..self.n {\\n            if self.parent_or_size[i] < 0 {\\n                cnt += 1;\\n                max = max.max(-self.parent_or_size[i]);\\n            }\\n        }\\n        vec![cnt, max]\\n    }\\n}\\nimpl Solution {\\n    pub fn group_strings(words: Vec<String>) -> Vec<i32> {\\n        let n = words.len();\\n        let mut dsu = Dsu::new(n);\\n        let mut m: HashMap<usize, usize> = HashMap::new();\\n        let words = words\\n            .iter()\\n            .map(|x| x.chars().map(|y| y as u8 - 97).fold(0, |s, c| s | (1 << c)));\\n        for (cur, mask) in words.enumerate() {\\n            if let Some(v) = m.get(&mask) {\\n                dsu.merge(cur, *v);\\n            }\\n            m.insert(mask, cur);\\n            for i in 0..26 {\\n                if let Some(v) = m.get(&(mask ^ (1 << i))) {\\n                    dsu.merge(cur, *v);\\n                }\\n                for j in (i + 1)..26 {\\n                    if ((mask >> j) & 1) != ((mask >> i) & 1) {\\n                        if let Some(index) = m.get(&(mask ^ (1 << i) ^ (1 << j))) {\\n                            dsu.merge(cur, *index);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        dsu.group_size()\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nuse std::collections::HashMap;\\n\\npub struct Dsu {\\n    n: usize,\\n    // root node: -1 * component size\\n    // otherwise: parent\\n    parent_or_size: Vec<i32>,\\n}\\n\\nimpl Dsu {\\n    // 0 <= size <= 10^8 is constrained.\\n    pub fn new(size: usize) -> Self {\\n        Self {\\n            n: size,\\n            parent_or_size: vec![-1; size],\\n        }\\n    }\\n    pub fn merge(&mut self, a: usize, b: usize) -> usize {\\n        let (mut x, mut y) = (self.leader(a), self.leader(b));\\n        if x == y {\\n            return x;\\n        }\\n        if -self.parent_or_size[x] < -self.parent_or_size[y] {\\n            std::mem::swap(&mut x, &mut y);\\n        }\\n        self.parent_or_size[x] += self.parent_or_size[y];\\n        self.parent_or_size[y] = x as i32;\\n        x\\n    }\\n\\n    pub fn same(&mut self, a: usize, b: usize) -> bool {\\n        self.leader(a) == self.leader(b)\\n    }\\n    pub fn leader(&mut self, a: usize) -> usize {\\n        if self.parent_or_size[a] < 0 {\\n            return a;\\n        }\\n        self.parent_or_size[a] = self.leader(self.parent_or_size[a] as usize) as i32;\\n        self.parent_or_size[a] as usize\\n    }\\n    pub fn group_size(&mut self) -> Vec<i32> {\\n        let mut cnt = 0;\\n        let mut max = 0;\\n        for i in 0..self.n {\\n            if self.parent_or_size[i] < 0 {\\n                cnt += 1;\\n                max = max.max(-self.parent_or_size[i]);\\n            }\\n        }\\n        vec![cnt, max]\\n    }\\n}\\nimpl Solution {\\n    pub fn group_strings(words: Vec<String>) -> Vec<i32> {\\n        let n = words.len();\\n        let mut dsu = Dsu::new(n);\\n        let mut m: HashMap<usize, usize> = HashMap::new();\\n        let words = words\\n            .iter()\\n            .map(|x| x.chars().map(|y| y as u8 - 97).fold(0, |s, c| s | (1 << c)));\\n        for (cur, mask) in words.enumerate() {\\n            if let Some(v) = m.get(&mask) {\\n                dsu.merge(cur, *v);\\n            }\\n            m.insert(mask, cur);\\n            for i in 0..26 {\\n                if let Some(v) = m.get(&(mask ^ (1 << i))) {\\n                    dsu.merge(cur, *v);\\n                }\\n                for j in (i + 1)..26 {\\n                    if ((mask >> j) & 1) != ((mask >> i) & 1) {\\n                        if let Some(index) = m.get(&(mask ^ (1 << i) ^ (1 << j))) {\\n                            dsu.merge(cur, *index);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        dsu.group_size()\\n    }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1731613,
                "title": "c-union-find-sort",
                "content": "![image](https://assets.leetcode.com/users/images/23264e28-2399-4f36-952b-4cfdda14a6e8_1643548759.2801378.png)\\n\\n\\nclass Solution {\\npublic:\\n    int find_group(vector<int> &dp, int index){\\n        return dp[index]==-1?index:(dp[index]=find_group(dp,dp[index]));\\n    }\\n    void merge_group(vector<int> &dp, vector<int> &groups, int l, int r){\\n        int l_g = find_group(dp,l);\\n        int r_g = find_group(dp,r);\\n        if(l_g==r_g){\\n            return;\\n        }\\n        dp[std::max(l_g,r_g)]=std::min(l_g,r_g);\\n        groups[std::min(l_g,r_g)]+=groups[std::max(l_g,r_g)];\\n    }\\n    static bool CompAge(const string& pl, const string& pr)  \\n    {  \\n        \\n        return pl.size()<pr.size();\\n    }  \\n    vector<int> groupStrings(vector<string>& words) {\\n        int n = words.size();\\n        vector<int> dp(n,-1);\\n        vector<int> groups(n,1);\\n        sort(words.begin(),words.end(),CompAge);\\n\\n        int index=0;\\n        unordered_map<int,int> m_set;\\n        int len=words[0].size();\\n        //unordered_map<int,vector<int>> m_map;\\n        while(index<words.size()){\\n            unordered_map<int,int> m_map;\\n            unordered_map<int,int> tmp_set;\\n           \\n            while(index<words.size()&&words[index].size()==len){\\n                auto &word = words[index];\\n                int encode = 0;\\n                for(int i=0;i<len;i++){\\n                    encode = (encode|(1<<(word[i]-\\'a\\')));\\n                }\\n               \\n                for(int i=0;i<len;i++){\\n                    auto tmpc = (encode^(1<<(word[i]-\\'a\\')));\\n                    if(m_set.count(tmpc)){\\n                        merge_group(dp,groups,m_set[tmpc],index);\\n                    }\\n                    if(m_map.count(tmpc)){\\n                        merge_group(dp,groups,m_map[tmpc],index);\\n                    }else{\\n                        m_map[tmpc]=index;\\n                    }\\n                     \\n                }\\n                tmp_set[encode]=index++;\\n                \\n            }\\n            if(index<words.size()){\\n                len=words[index].size();\\n            }\\n            m_set.swap(tmp_set);\\n        }\\n        int max=0;\\n        int num=0;\\n        for(int i=0;i<n;i++){\\n            if(dp[i]==-1){\\n                num++;\\n                if(groups[i]>max){\\n                    max=groups[i];\\n                }\\n            }\\n        }\\n        return {num,max};\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int find_group(vector<int> &dp, int index){\\n        return dp[index]==-1?index:(dp[index]=find_group(dp,dp[index]));\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1731129,
                "title": "26-26-log-26-log",
                "content": "s = abcde, t = zbcde;\\ns and t are connected by the operation of \"replacing\".\\nThis is because the frequency of s excluding \\'a\\' and the frequency of t excluding \\'z\\' are the same.\\nIn other words, if you check if there is string that erases only one character from t, you can support replacing. prepare a new map for \"replacing\". Save the string with one character removed from t, but be careful not to overlap it with the characters created by the \"Add character\" operation.(bcde + a) and (zabcde) are not connected. \\n\\n```\\nstruct Unionfind{\\n      vector<int>d;\\n      Unionfind(int n):d(n,-1){}\\n      int root(int x){\\n        if(d[x]<0){return x;}\\n        return d[x]=root(d[x]);\\n      }\\n      bool unite(int x,int y){\\n        x=root(x);y=root(y);\\n        if(x==y){return false;}\\n        if(d[x]>d[y]){swap(x,y);}\\n        d[x]+=d[y];\\n        d[y]=x;\\n        return true;\\n      }\\n      bool same(int x,int y){return root(x)==root(y);}\\n      int size(int x){return -d[root(x)];}\\n };\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> groupStrings(vector<string>& t) {\\n        int n=t.size(),mask,nmask;\\n        unordered_map<int,int>ind;\\n        unordered_map<int,int>rps;\\n        Unionfind uf(n);\\n        for(int i=0;i<n;i++){\\n            mask=0;\\n            for(char c:t[i]){\\n                mask|=(1<<(c-\\'a\\'));\\n            }\\n            if(ind.count(mask)){\\n                uf.unite(i,ind[mask]);\\n                continue;\\n            }\\n            ind[mask]=i;\\n            \\n            for(int j=0;j<26;j++){\\n                nmask=(mask^(1<<j));\\n                if(ind.count(nmask)){\\n                    uf.unite(ind[mask],ind[nmask]);\\n                }\\n            }\\n            for(int j=0;j<26;j++){\\n                if(mask>>j&1){    \\n\\t\\t\\t\\t    nmask=mask^(1<<j);\\n                    if(rps.count(nmask)){\\n                        uf.unite(ind[mask],rps[nmask]);\\n                    }\\n                    else{\\n                        rps[nmask]=i;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        vector<int>ans(2);\\n        for(int i=0;i<n;i++){\\n            if(uf.root(i)==i){ans[0]++;}\\n            ans[1]=max(ans[1],uf.size(i));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nstruct Unionfind{\\n      vector<int>d;\\n      Unionfind(int n):d(n,-1){}\\n      int root(int x){\\n        if(d[x]<0){return x;}\\n        return d[x]=root(d[x]);\\n      }\\n      bool unite(int x,int y){\\n        x=root(x);y=root(y);\\n        if(x==y){return false;}\\n        if(d[x]>d[y]){swap(x,y);}\\n        d[x]+=d[y];\\n        d[y]=x;\\n        return true;\\n      }\\n      bool same(int x,int y){return root(x)==root(y);}\\n      int size(int x){return -d[root(x)];}\\n };\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> groupStrings(vector<string>& t) {\\n        int n=t.size(),mask,nmask;\\n        unordered_map<int,int>ind;\\n        unordered_map<int,int>rps;\\n        Unionfind uf(n);\\n        for(int i=0;i<n;i++){\\n            mask=0;\\n            for(char c:t[i]){\\n                mask|=(1<<(c-\\'a\\'));\\n            }\\n            if(ind.count(mask)){\\n                uf.unite(i,ind[mask]);\\n                continue;\\n            }\\n            ind[mask]=i;\\n            \\n            for(int j=0;j<26;j++){\\n                nmask=(mask^(1<<j));\\n                if(ind.count(nmask)){\\n                    uf.unite(ind[mask],ind[nmask]);\\n                }\\n            }\\n            for(int j=0;j<26;j++){\\n                if(mask>>j&1){    \\n\\t\\t\\t\\t    nmask=mask^(1<<j);\\n                    if(rps.count(nmask)){\\n                        uf.unite(ind[mask],rps[nmask]);\\n                    }\\n                    else{\\n                        rps[nmask]=i;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        vector<int>ans(2);\\n        for(int i=0;i<n;i++){\\n            if(uf.root(i)==i){ans[0]++;}\\n            ans[1]=max(ans[1],uf.size(i));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1731072,
                "title": "c-o-26-n-union-find-bitmask",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int>parent;\\n    vector<int>size;\\n    int find_set(int v) {\\n        if (v == parent[v])\\n            return v;\\n        return parent[v] = find_set(parent[v]);\\n    }   \\n    void union_sets(int a, int b) {\\n        a = find_set(a);\\n        b = find_set(b);\\n        if (a != b) {\\n            if (size[a] < size[b])\\n                swap(a, b);\\n            parent[b] = a;\\n            size[a] += size[b];\\n        }\\n    }\\n    vector<int> groupStrings(vector<string>& words) {\\n        int n=words.size();\\n        vector<int>bitmask(n,0);\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<n;i++){\\n            string s=words[i];\\n            int temp=0;\\n            for(int j=0;j<s.length();j++){\\n                int c=s[j]-\\'a\\';\\n                temp=temp|(1<<c);\\n            }\\n            mp[temp]=i;\\n            bitmask[i]=temp;\\n        }\\n        parent.resize(n,0);\\n        size.resize(n,1);\\n        for(int i=0;i<n;i++){\\n            parent[i]=i;\\n        }\\n        for(int i=0;i<n;i++){\\n            int currMask=bitmask[i];\\n            if(mp[currMask]!=i){\\n                union_sets(i,mp[currMask]);\\n            }\\n            for(int j=0;j<26;j++){\\n                int temp=currMask;\\n                int bit=0;\\n                if(temp&(1<<j))bit=1;\\n                if(bit==0){\\n                    temp |= 1 << j;\\n                    if(mp.find(temp)!=mp.end()){\\n                        union_sets(i,mp[temp]);\\n                    } else {\\n                        mp[temp]=i;\\n                    }\\n                }\\n            }\\n        }\\n        unordered_map<int,int>visited;\\n        int maximum=0;\\n        int count=0;\\n        vector<int>ans;\\n        for(int i=0;i<n;i++){\\n            int parent=find_set(i);\\n            if(visited[parent])continue;\\n            count++;\\n            maximum=max(maximum,size[parent]);\\n            visited[parent]=1;\\n        }\\n        ans.push_back(count);\\n        ans.push_back(maximum);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Union Find",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>parent;\\n    vector<int>size;\\n    int find_set(int v) {\\n        if (v == parent[v])\\n            return v;\\n        return parent[v] = find_set(parent[v]);\\n    }   \\n    void union_sets(int a, int b) {\\n        a = find_set(a);\\n        b = find_set(b);\\n        if (a != b) {\\n            if (size[a] < size[b])\\n                swap(a, b);\\n            parent[b] = a;\\n            size[a] += size[b];\\n        }\\n    }\\n    vector<int> groupStrings(vector<string>& words) {\\n        int n=words.size();\\n        vector<int>bitmask(n,0);\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<n;i++){\\n            string s=words[i];\\n            int temp=0;\\n            for(int j=0;j<s.length();j++){\\n                int c=s[j]-\\'a\\';\\n                temp=temp|(1<<c);\\n            }\\n            mp[temp]=i;\\n            bitmask[i]=temp;\\n        }\\n        parent.resize(n,0);\\n        size.resize(n,1);\\n        for(int i=0;i<n;i++){\\n            parent[i]=i;\\n        }\\n        for(int i=0;i<n;i++){\\n            int currMask=bitmask[i];\\n            if(mp[currMask]!=i){\\n                union_sets(i,mp[currMask]);\\n            }\\n            for(int j=0;j<26;j++){\\n                int temp=currMask;\\n                int bit=0;\\n                if(temp&(1<<j))bit=1;\\n                if(bit==0){\\n                    temp |= 1 << j;\\n                    if(mp.find(temp)!=mp.end()){\\n                        union_sets(i,mp[temp]);\\n                    } else {\\n                        mp[temp]=i;\\n                    }\\n                }\\n            }\\n        }\\n        unordered_map<int,int>visited;\\n        int maximum=0;\\n        int count=0;\\n        vector<int>ans;\\n        for(int i=0;i<n;i++){\\n            int parent=find_set(i);\\n            if(visited[parent])continue;\\n            count++;\\n            maximum=max(maximum,size[parent]);\\n            visited[parent]=1;\\n        }\\n        ans.push_back(count);\\n        ans.push_back(maximum);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1730983,
                "title": "c-400ms-maybe-the-fastest-solution",
                "content": "The idea is the same with other code, like Lee\\'s python solution, or any other Union Find solution. but the key point is how to avoid using hash map to faster the code.\\n\\nThe only way to avoid a hash map is to use a very very BIG vector, the `maskOrder`.  We have enough memory, but if we initialize this vector for every test cases, it would be too slow. So here we use a uninitialized static array.\\n\\nIt\\'s strange to use a uninitialized array, but it\\'s OK if we can remember which position we actually used. We use a `vector<bool> seen`  to do this. But why it\\'s acceptable to initialize this bool vector for every case? C++ have some magic for `vector<bool>` . It\\'s memory-optimized and it can initilize even much faster than `memset` a bool array.\\n\\n\\n```\\nstruct MergeFindSet {\\n    std::vector<int> p;\\n    MergeFindSet(int n) : p(n) { init(); }\\n    int find(int x) { return p[x] == x ? x : p[x] = find(p[x]); }\\n    void merge(int root, int child) { p[find(child)] = find(root); }\\n    void init() {\\n        for (int i = 0; i < int(p.size()); i++) p[i] = i;\\n    }\\n};\\n\\nconst int N = 1 << 26;\\nuint16_t maskOrder[N];\\n\\nclass Solution {\\npublic:\\n    vector<int> groupStrings(vector<string>& words) {\\n        int n = words.size();\\n        vector<int> masks;\\n        vector<bool> seen(N);\\n        for(const string& s: words) {\\n            int m = 0;\\n            for(char c: s) {\\n                m |= 1 << int(c - \\'a\\');\\n            }\\n            masks.push_back(m);\\n            seen[m] = true;\\n        }\\n        sort(masks.begin(), masks.end());\\n        \\n        vector<int> cnt(n);\\n        int currOrder = 0;\\n        for(int i = 0; i < n; i++) {\\n            if(i == 0 or masks[i] != masks[i - 1]) {\\n                maskOrder[masks[i]] = currOrder++;\\n            }\\n            cnt[currOrder - 1]++;\\n        }\\n        \\n        MergeFindSet mfs(n);\\n        for(int i = 0; i < n; i++) {\\n            if(i != 0 and masks[i] == masks[i - 1]) {\\n                continue;\\n            }\\n            int mask = masks[i];\\n            int order1 = maskOrder[mask];\\n            for(int i = 0; i < 26; i++) {\\n                if(mask & (1 << i)) {\\n                    int mask2 = mask ^ (1 << i);\\n                    if(seen[mask2]) {\\n                        mfs.merge(order1, maskOrder[mask2]);\\n                    }\\n                    \\n                    for(int j = 0; j < 26; j++) {\\n                        if((mask2 & (1 << j)) == 0) {\\n                            int mask3 = mask2 | (1 << j);\\n                            if(seen[mask3]) {\\n                                mfs.merge(order1, maskOrder[mask3]);\\n                            }\\n                        }\\n                    }\\n                    \\n                } else {\\n                    int mask2 = mask | (1 << i);\\n                    if(seen[mask2]) {\\n                        mfs.merge(order1, maskOrder[mask2]);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        vector<int> gSize(currOrder);\\n        int maxSize = 0;\\n        int groupCnt = 0;\\n        for(int i = 0; i < currOrder; i++) {\\n            int root = mfs.find(i);\\n            gSize[root] += cnt[i];\\n            maxSize = max(maxSize, gSize[root]);\\n            groupCnt += root == i;\\n        }\\n        \\n        return {groupCnt, maxSize};\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nstruct MergeFindSet {\\n    std::vector<int> p;\\n    MergeFindSet(int n) : p(n) { init(); }\\n    int find(int x) { return p[x] == x ? x : p[x] = find(p[x]); }\\n    void merge(int root, int child) { p[find(child)] = find(root); }\\n    void init() {\\n        for (int i = 0; i < int(p.size()); i++) p[i] = i;\\n    }\\n};\\n\\nconst int N = 1 << 26;\\nuint16_t maskOrder[N];\\n\\nclass Solution {\\npublic:\\n    vector<int> groupStrings(vector<string>& words) {\\n        int n = words.size();\\n        vector<int> masks;\\n        vector<bool> seen(N);\\n        for(const string& s: words) {\\n            int m = 0;\\n            for(char c: s) {\\n                m |= 1 << int(c - \\'a\\');\\n            }\\n            masks.push_back(m);\\n            seen[m] = true;\\n        }\\n        sort(masks.begin(), masks.end());\\n        \\n        vector<int> cnt(n);\\n        int currOrder = 0;\\n        for(int i = 0; i < n; i++) {\\n            if(i == 0 or masks[i] != masks[i - 1]) {\\n                maskOrder[masks[i]] = currOrder++;\\n            }\\n            cnt[currOrder - 1]++;\\n        }\\n        \\n        MergeFindSet mfs(n);\\n        for(int i = 0; i < n; i++) {\\n            if(i != 0 and masks[i] == masks[i - 1]) {\\n                continue;\\n            }\\n            int mask = masks[i];\\n            int order1 = maskOrder[mask];\\n            for(int i = 0; i < 26; i++) {\\n                if(mask & (1 << i)) {\\n                    int mask2 = mask ^ (1 << i);\\n                    if(seen[mask2]) {\\n                        mfs.merge(order1, maskOrder[mask2]);\\n                    }\\n                    \\n                    for(int j = 0; j < 26; j++) {\\n                        if((mask2 & (1 << j)) == 0) {\\n                            int mask3 = mask2 | (1 << j);\\n                            if(seen[mask3]) {\\n                                mfs.merge(order1, maskOrder[mask3]);\\n                            }\\n                        }\\n                    }\\n                    \\n                } else {\\n                    int mask2 = mask | (1 << i);\\n                    if(seen[mask2]) {\\n                        mfs.merge(order1, maskOrder[mask2]);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        vector<int> gSize(currOrder);\\n        int maxSize = 0;\\n        int groupCnt = 0;\\n        for(int i = 0; i < currOrder; i++) {\\n            int root = mfs.find(i);\\n            gSize[root] += cnt[i];\\n            maxSize = max(maxSize, gSize[root]);\\n            groupCnt += root == i;\\n        }\\n        \\n        return {groupCnt, maxSize};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1730902,
                "title": "why-tle",
                "content": "Im pretty sure this is o(n*d*d) than why it gives me tle?\\n```\\nclass Solution:\\n    def check(self, a, b):\\n        d_a = {}\\n        for i in a:\\n            if i in d_a.keys():\\n                d_a[i] += 1\\n            else:\\n                d_a[i] = 1\\n        total = len(a)\\n        diff = 0\\n        for i in b:\\n            if i in d_a.keys() and d_a[i] > 0:\\n                d_a[i] -= 1\\n                total -= 1\\n            else:\\n                diff += 1\\n        if total <= 1 and diff <= 1:\\n            return True\\n        return False\\n       \\n            \\n    def groupStrings(self, words: List[str]) -> List[int]:\\n        d={}\\n      \\n        for i in range(0, len(words)):\\n            if len(words[i]) in d.keys():\\n                d[len(words[i])].append(i)\\n            else:\\n                d[len(words[i])] = [i]\\n        \\n        paths={}\\n     \\n        for s1 in range(0, len(words)):\\n            if len(words[s1])-1 in d.keys():\\n                for s2 in d[len(words[s1])-1]:\\n                    if self.check(words[s1], words[s2]):\\n                        if s1 in paths.keys():\\n                            paths[s1].append(s2)\\n                        else:\\n                            paths[s1] = [s2]\\n            if len(words[s1])+1 in d.keys():\\n                for s2 in d[len(words[s1])+1]:\\n                    if self.check(words[s1], words[s2]):\\n                        if s1 in paths.keys():\\n                            paths[s1].append(s2)\\n                        else:\\n                            paths[s1] = [s2]\\n            if len(words[s1]) in d.keys():\\n                for s2 in d[len(words[s1])]:\\n                    if self.check(words[s1], words[s2]):\\n                        if s1 in paths.keys():\\n                            paths[s1].append(s2)\\n                        else:\\n                            paths[s1] = [s2]\\n        \\n        \\n        visited = set()\\n        def dfs(i):\\n            if i in visited:\\n                return 0\\n            visited.add(i)\\n            res = 1\\n            for j in paths[i]:\\n                if i != j:\\n                    res += dfs(j)\\n            return res\\n \\n        count = 0\\n        m = float(\\'-inf\\')\\n        for k in range(0, len(words)):\\n            ans = dfs(k)\\n            if ans:\\n                count+=1\\n            m = max(m, ans)\\n        return [count, m]\\n            \\n                \\n                            \\n\\n        \\n\\t\\t````",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def check(self, a, b):\\n        d_a = {}\\n        for i in a:\\n            if i in d_a.keys():\\n                d_a[i] += 1\\n            else:\\n                d_a[i] = 1\\n        total = len(a)\\n        diff = 0\\n        for i in b:\\n            if i in d_a.keys() and d_a[i] > 0:\\n                d_a[i] -= 1\\n                total -= 1\\n            else:\\n                diff += 1\\n        if total <= 1 and diff <= 1:\\n            return True\\n        return False\\n       \\n            \\n    def groupStrings(self, words: List[str]) -> List[int]:\\n        d={}\\n      \\n        for i in range(0, len(words)):\\n            if len(words[i]) in d.keys():\\n                d[len(words[i])].append(i)\\n            else:\\n                d[len(words[i])] = [i]\\n        \\n        paths={}\\n     \\n        for s1 in range(0, len(words)):\\n            if len(words[s1])-1 in d.keys():\\n                for s2 in d[len(words[s1])-1]:\\n                    if self.check(words[s1], words[s2]):\\n                        if s1 in paths.keys():\\n                            paths[s1].append(s2)\\n                        else:\\n                            paths[s1] = [s2]\\n            if len(words[s1])+1 in d.keys():\\n                for s2 in d[len(words[s1])+1]:\\n                    if self.check(words[s1], words[s2]):\\n                        if s1 in paths.keys():\\n                            paths[s1].append(s2)\\n                        else:\\n                            paths[s1] = [s2]\\n            if len(words[s1]) in d.keys():\\n                for s2 in d[len(words[s1])]:\\n                    if self.check(words[s1], words[s2]):\\n                        if s1 in paths.keys():\\n                            paths[s1].append(s2)\\n                        else:\\n                            paths[s1] = [s2]\\n        \\n        \\n        visited = set()\\n        def dfs(i):\\n            if i in visited:\\n                return 0\\n            visited.add(i)\\n            res = 1\\n            for j in paths[i]:\\n                if i != j:\\n                    res += dfs(j)\\n            return res\\n \\n        count = 0\\n        m = float(\\'-inf\\')\\n        for k in range(0, len(words)):\\n            ans = dfs(k)\\n            if ans:\\n                count+=1\\n            m = max(m, ans)\\n        return [count, m]\\n            \\n                \\n                            \\n\\n        \\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1730753,
                "title": "python-o-nm-nlog-n-unionfind-without-bitmask",
                "content": "Inspired by https://leetcode.com/problems/groups-of-strings/discuss/1730267/python-union-find-without-using-bitmask\\n## Intuitition\\n- Need to connect any two elements that should be connected with UnionFind.\\n- connecting word with words of equal length or shorter lengths is **adequate**.\\n- connecting current word with shorter word:\\n```\\nloop w in {currentWord removing one character}:\\n\\tif w is in words, connect w and currentWord\\n```\\n- connecting current word with equal length word:\\n```\\nmap: wordRemovingOneCharactor -> originalWord\\nloop w in {currentWord removing one character}:\\n\\tif w is in map, connect currentWord and originalWord\\n```\\n\\nFor example, `words = [\"abc\",\"abd\",\"ebc\",\"ebd\"]`\\nWhen we are checking the last word `\"ebd\"`, the `map` should be:\\n```\\nmap: \\n  \"ab\"->(\"abc\" flushed) \"abd\"\\n  \"ac\"->\"abc\"\\n  \"bc\"->(\"abc\" flushed) \"ebc\"\\n  \"ad\"->\"abd\"\\n  \"bd\"->\"abd\"\\n  \"eb\"->\"ebc\"\\n  \"ec\"->\"ebc\"\\n\\ncurrentWord: \"ebd\"\\nLoop over currentWord removing one character: \"eb\", \"ed\", \"bd\"\\n\\nShorter words matching:\\n\\t- we find none of them are in words\\n\\nEqual length words matching:\\n\\t- we find \"eb\", \"bd\" are in `map`, so we should connect `currentWord` with the original word of \"eb\" and \"bd\":\\n\\t\\tconnect \"ebd\" <-> \"ebc\" (through \"eb\")\\n\\t\\tconnect \"ebd\" <-> \"abd\" (through \"bd\")\\n```\\n\\n### Final code\\n```\\nclass Solution:\\n    def groupStrings(self, words):\\n        words = sorted([\\'\\'.join(sorted(w)) for w in words],key=len)\\n        dic = {w:i for i,w in enumerate(words)}\\n        n = len(words)\\n        p = [i for i in range(n)]\\n        def find(i):\\n            stack = []\\n            while p[i]!=i:\\n                stack.append(i)\\n                i = p[i]\\n            while stack:\\n                p[stack.pop()] = i\\n            return i\\n        def union(a,b):\\n            p[find(a)] = find(b)\\n            \\n        del1 = {}\\n        for i,w in enumerate(words):\\n            if dic[w]!=i: # flushed when creating dic\\n                union(dic[w],i)\\n            else:\\n                for c in range(len(w)):\\n                    d = w[:c]+w[c+1:]\\n                    if d in dic:\\n                        union(dic[d],i)\\n                    if d in del1:\\n                        union(del1[d],i)\\n                    del1[d] = i\\n        p = [find(x) for x in range(n)]\\n        cnt = Counter(p).values()\\n        return len(cnt),max(cnt)\\n```\\n## Complexity analysis\\nFor each word, we loop by removing one character. There at most len(word) ways to remove a character.\\nFor each candiate to check we inspect two dictionary, they are of O(1) complexity. so the total time complexity is `O(n*m)` where m is the maximum length of word.\\n\\n- Time complexity: `O(nm + nlog(n))`\\n- Space complexity: `O(n*m)`\\n- `m` is the maximum length of word\\n\\n## Performance\\n- 2137 ms\\n- 55.4 MB\\n![image](https://assets.leetcode.com/users/images/50cd7e01-ce76-47cc-a6bb-d11fed1c52ff_1643525441.1103.png)",
                "solutionTags": [],
                "code": "```\\nloop w in {currentWord removing one character}:\\n\\tif w is in words, connect w and currentWord\\n```\n```\\nmap: wordRemovingOneCharactor -> originalWord\\nloop w in {currentWord removing one character}:\\n\\tif w is in map, connect currentWord and originalWord\\n```\n```\\nmap: \\n  \"ab\"->(\"abc\" flushed) \"abd\"\\n  \"ac\"->\"abc\"\\n  \"bc\"->(\"abc\" flushed) \"ebc\"\\n  \"ad\"->\"abd\"\\n  \"bd\"->\"abd\"\\n  \"eb\"->\"ebc\"\\n  \"ec\"->\"ebc\"\\n\\ncurrentWord: \"ebd\"\\nLoop over currentWord removing one character: \"eb\", \"ed\", \"bd\"\\n\\nShorter words matching:\\n\\t- we find none of them are in words\\n\\nEqual length words matching:\\n\\t- we find \"eb\", \"bd\" are in `map`, so we should connect `currentWord` with the original word of \"eb\" and \"bd\":\\n\\t\\tconnect \"ebd\" <-> \"ebc\" (through \"eb\")\\n\\t\\tconnect \"ebd\" <-> \"abd\" (through \"bd\")\\n```\n```\\nclass Solution:\\n    def groupStrings(self, words):\\n        words = sorted([\\'\\'.join(sorted(w)) for w in words],key=len)\\n        dic = {w:i for i,w in enumerate(words)}\\n        n = len(words)\\n        p = [i for i in range(n)]\\n        def find(i):\\n            stack = []\\n            while p[i]!=i:\\n                stack.append(i)\\n                i = p[i]\\n            while stack:\\n                p[stack.pop()] = i\\n            return i\\n        def union(a,b):\\n            p[find(a)] = find(b)\\n            \\n        del1 = {}\\n        for i,w in enumerate(words):\\n            if dic[w]!=i: # flushed when creating dic\\n                union(dic[w],i)\\n            else:\\n                for c in range(len(w)):\\n                    d = w[:c]+w[c+1:]\\n                    if d in dic:\\n                        union(dic[d],i)\\n                    if d in del1:\\n                        union(del1[d],i)\\n                    del1[d] = i\\n        p = [find(x) for x in range(n)]\\n        cnt = Counter(p).values()\\n        return len(cnt),max(cnt)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1730719,
                "title": "java-bitmask-map-union-find",
                "content": "Convert word into bitmask and store in map <mask, index>, check every potential matches\\n\\n```\\nclass Solution {\\n    int n;\\n    Map<Integer, Integer> map = new HashMap<>();\\n    \\n    class UnionFind {\\n        int size, groups;\\n        int[] sizes;\\n        int[] roots;\\n        int max = 1;\\n        \\n        public UnionFind(int n) {\\n            size = n;\\n            groups = n;\\n            roots = new int[n];\\n            sizes = new int[n];\\n            for(int i=0; i<n; i++) {\\n                roots[i] = i;\\n                sizes[i] = 1;\\n            }\\n        }\\n        \\n        public int find(int a) {\\n            if(roots[a] == a) return a;\\n            int ra = find(roots[a]);\\n            roots[a] = ra;\\n            return ra;\\n        }\\n        \\n        public void union(int a, int b) {\\n            int ra = find(a);\\n            int rb = find(b);\\n            if(ra == rb) return;\\n            roots[rb] = ra; \\n            sizes[ra] += sizes[rb];\\n            groups--;\\n            max = Math.max(max, sizes[ra]);\\n        }\\n    }\\n    \\n    public int[] groupStrings(String[] words) {\\n        n = words.length;\\n        UnionFind uf = new UnionFind(n);\\n        \\n        for(int i=0; i<n; i++) {\\n            String w = words[i];\\n            int mask = getBits(w);\\n            if(map.containsKey(mask)) {\\n                uf.union(map.get(mask), i);\\n            } else {\\n                matching(uf, i, mask);\\n                map.put(mask, i);\\n            }\\n        }\\n        \\n        return new int[]{uf.groups, uf.max};\\n    }\\n    \\n    void matching( UnionFind uf, int idx, int mask) {\\n        // add 1 letter\\n        for(int i=0; i<26; i++) {\\n            if((mask & (1 << i)) > 0) continue;\\n            int test = (mask | (1 << i));\\n            if(map.containsKey(test)) {\\n                uf.union(idx, map.get(test));\\n            }\\n        }\\n        // remove\\n        for(int i=0; i<26; i++) {\\n            if((mask & (1 << i)) == 0) continue;\\n            int test = (mask ^ (1 << i));\\n            if(map.containsKey(test)) {\\n                uf.union(idx, map.get(test));\\n            }\\n        }\\n        // swap\\n        for(int i=0; i<26; i++) {\\n            for(int j=0; j<26; j++) {\\n                // remove i, add j\\n                if(i==j) continue;\\n                if((mask & (1 << i)) == 0) continue;\\n                if((mask & (1 << j)) > 0) continue;\\n                int test = ((mask | (1 << j)) ^ (1 << i));\\n                if(map.containsKey(test)) {\\n                    uf.union(idx, map.get(test));\\n                }\\n            }\\n        }\\n    }\\n    \\n    \\n    int getBits(String s) {\\n        int mask = 0;\\n        for(char c:s.toCharArray()) {\\n            mask |= 1<<(c-\\'a\\');\\n        }\\n        return mask;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int n;\\n    Map<Integer, Integer> map = new HashMap<>();\\n    \\n    class UnionFind {\\n        int size, groups;\\n        int[] sizes;\\n        int[] roots;\\n        int max = 1;\\n        \\n        public UnionFind(int n) {\\n            size = n;\\n            groups = n;\\n            roots = new int[n];\\n            sizes = new int[n];\\n            for(int i=0; i<n; i++) {\\n                roots[i] = i;\\n                sizes[i] = 1;\\n            }\\n        }\\n        \\n        public int find(int a) {\\n            if(roots[a] == a) return a;\\n            int ra = find(roots[a]);\\n            roots[a] = ra;\\n            return ra;\\n        }\\n        \\n        public void union(int a, int b) {\\n            int ra = find(a);\\n            int rb = find(b);\\n            if(ra == rb) return;\\n            roots[rb] = ra; \\n            sizes[ra] += sizes[rb];\\n            groups--;\\n            max = Math.max(max, sizes[ra]);\\n        }\\n    }\\n    \\n    public int[] groupStrings(String[] words) {\\n        n = words.length;\\n        UnionFind uf = new UnionFind(n);\\n        \\n        for(int i=0; i<n; i++) {\\n            String w = words[i];\\n            int mask = getBits(w);\\n            if(map.containsKey(mask)) {\\n                uf.union(map.get(mask), i);\\n            } else {\\n                matching(uf, i, mask);\\n                map.put(mask, i);\\n            }\\n        }\\n        \\n        return new int[]{uf.groups, uf.max};\\n    }\\n    \\n    void matching( UnionFind uf, int idx, int mask) {\\n        // add 1 letter\\n        for(int i=0; i<26; i++) {\\n            if((mask & (1 << i)) > 0) continue;\\n            int test = (mask | (1 << i));\\n            if(map.containsKey(test)) {\\n                uf.union(idx, map.get(test));\\n            }\\n        }\\n        // remove\\n        for(int i=0; i<26; i++) {\\n            if((mask & (1 << i)) == 0) continue;\\n            int test = (mask ^ (1 << i));\\n            if(map.containsKey(test)) {\\n                uf.union(idx, map.get(test));\\n            }\\n        }\\n        // swap\\n        for(int i=0; i<26; i++) {\\n            for(int j=0; j<26; j++) {\\n                // remove i, add j\\n                if(i==j) continue;\\n                if((mask & (1 << i)) == 0) continue;\\n                if((mask & (1 << j)) > 0) continue;\\n                int test = ((mask | (1 << j)) ^ (1 << i));\\n                if(map.containsKey(test)) {\\n                    uf.union(idx, map.get(test));\\n                }\\n            }\\n        }\\n    }\\n    \\n    \\n    int getBits(String s) {\\n        int mask = 0;\\n        for(char c:s.toCharArray()) {\\n            mask |= 1<<(c-\\'a\\');\\n        }\\n        return mask;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1730651,
                "title": "javascript-union-find-bitmask-1556ms",
                "content": "```\\n////////////////////////////////////////////////////// Template /////////////////////////////////////////////////////////////////\\nfunction DJSet(n) {\\n    // parent[i] < 0, -parent[i] is the group size which root is i. example: (i -> parent[i] -> parent[parent[i]] -> parent[parent[parent[i]]] ...)\\n    // parent[i] >= 0, i is not the root and parent[i] is i\\'s parent. example: (... parent[parent[parent[i]]] -> parent[parent[i]] -> parent[i] -> i)\\n    let parent = Array(n).fill(-1);\\n    return { find, union, count, equiv, getParent }\\n    function find(x) {\\n        return parent[x] < 0 ? x : parent[x] = find(parent[x]);\\n    }\\n    function union(x, y) {\\n        x = find(x);\\n        y = find(y);\\n        if (x != y) {\\n            if (parent[x] < parent[y]) [x, y] = [y, x];\\n            parent[x] += parent[y];\\n            parent[y] = x;\\n        }\\n        return x == y;\\n    }\\n    function count() { // total connected groups (value < 0)\\n        return parent.filter(v => v < 0).length;\\n    }\\n    function equiv(x, y) {\\n        return find(x) == find(y);\\n    }\\n    function getParent() {\\n        return parent;\\n    }\\n}\\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\nconst groupStrings = (words) => {\\n    let n = words.length, ds = new DJSet(n), pre = Array(n).fill(0), m = new Map();\\n    for (let i = 0; i < n; i++) {\\n        for (const c of words[i]) {\\n            pre[i] |= 1 << c.charCodeAt() - 97;\\n        }\\n        if (m.has(pre[i])) ds.union(i, m.get(pre[i]));\\n        m.set(pre[i], i);\\n    }\\n    for (let i = 0; i < n; i++) {\\n        for (let j = 0; j < 26; j++) {\\n            let toggle = pre[i] ^ 1 << j;\\n            if (m.has(toggle)) ds.union(i, m.get(toggle));\\n        }\\n        for (let j = 0; j < 26; j++) {\\n            for (let k = 0; k < 26; k++) {\\n                let bitOfOneIJ = pre[i] & (1 << j), bitOfOneIK = pre[i] & (1 << k);\\n                if (bitOfOneIJ && !bitOfOneIK) {\\n                    let toggle = pre[i] ^ (1 << j) ^ (1 << k);\\n                    if (m.has(toggle)) ds.union(i, m.get(toggle));\\n                }\\n            }\\n        }\\n    }\\n    return [ds.count(), -(Math.min(...ds.getParent()))];\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Union Find",
                    "Bitmask"
                ],
                "code": "```\\n////////////////////////////////////////////////////// Template /////////////////////////////////////////////////////////////////\\nfunction DJSet(n) {\\n    // parent[i] < 0, -parent[i] is the group size which root is i. example: (i -> parent[i] -> parent[parent[i]] -> parent[parent[parent[i]]] ...)\\n    // parent[i] >= 0, i is not the root and parent[i] is i\\'s parent. example: (... parent[parent[parent[i]]] -> parent[parent[i]] -> parent[i] -> i)\\n    let parent = Array(n).fill(-1);\\n    return { find, union, count, equiv, getParent }\\n    function find(x) {\\n        return parent[x] < 0 ? x : parent[x] = find(parent[x]);\\n    }\\n    function union(x, y) {\\n        x = find(x);\\n        y = find(y);\\n        if (x != y) {\\n            if (parent[x] < parent[y]) [x, y] = [y, x];\\n            parent[x] += parent[y];\\n            parent[y] = x;\\n        }\\n        return x == y;\\n    }\\n    function count() { // total connected groups (value < 0)\\n        return parent.filter(v => v < 0).length;\\n    }\\n    function equiv(x, y) {\\n        return find(x) == find(y);\\n    }\\n    function getParent() {\\n        return parent;\\n    }\\n}\\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\nconst groupStrings = (words) => {\\n    let n = words.length, ds = new DJSet(n), pre = Array(n).fill(0), m = new Map();\\n    for (let i = 0; i < n; i++) {\\n        for (const c of words[i]) {\\n            pre[i] |= 1 << c.charCodeAt() - 97;\\n        }\\n        if (m.has(pre[i])) ds.union(i, m.get(pre[i]));\\n        m.set(pre[i], i);\\n    }\\n    for (let i = 0; i < n; i++) {\\n        for (let j = 0; j < 26; j++) {\\n            let toggle = pre[i] ^ 1 << j;\\n            if (m.has(toggle)) ds.union(i, m.get(toggle));\\n        }\\n        for (let j = 0; j < 26; j++) {\\n            for (let k = 0; k < 26; k++) {\\n                let bitOfOneIJ = pre[i] & (1 << j), bitOfOneIK = pre[i] & (1 << k);\\n                if (bitOfOneIJ && !bitOfOneIK) {\\n                    let toggle = pre[i] ^ (1 << j) ^ (1 << k);\\n                    if (m.has(toggle)) ds.union(i, m.get(toggle));\\n                }\\n            }\\n        }\\n    }\\n    return [ds.count(), -(Math.min(...ds.getParent()))];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1730613,
                "title": "c-o-n-26-with-dsu",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    struct dsu{\\n        vector<int>rank,parent;\\n        int counter;\\n        dsu(){}\\n        dsu(int n):rank(n,1),parent(n){\\n            for(int i=0; i<n; i++)parent[i]=i;\\n            counter=n;\\n        }\\n        \\n        inline int Find(int u){\\n            if(parent[u]==u)return u;\\n            return parent[u] = Find(parent[u]);\\n        }\\n        \\n        void Unite(int u, int v){\\n            u = Find(u);\\n            v = Find(v);\\n            if(u!=v){\\n                counter--;\\n                if(rank[u]<rank[v])swap(u,v);\\n                rank[u]+=rank[v];\\n                parent[v]=u;\\n            }\\n        }\\n        \\n    };\\n    \\n    struct custom_hash {\\n        static uint64_t splitmix64(uint64_t x) {\\n            // http://xorshift.di.unimi.it/splitmix64.c\\n            x += 0x9e3779b97f4a7c15;\\n            x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\\n            x = (x ^ (x >> 27)) * 0x94d049bb133111eb;\\n            return x ^ (x >> 31);\\n        }\\n\\n        size_t operator()(uint64_t x) const {\\n            static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();\\n            return splitmix64(x + FIXED_RANDOM);\\n        }\\n    };\\n\\n\\n    vector<int> groupStrings(vector<string>& words) {\\n        int n = words.size();\\n        unordered_map<int,int,custom_hash>mp;\\n        dsu D(n);\\n        \\n        for(int i=0,d,mask; i<n; i++){\\n            mask=0;\\n            for(char &c:words[i])mask|=(1<<(c-\\'a\\'));\\n            for(int a=0; a<26; a++){\\n                d = mask;\\n                d^=(1<<a);\\n                \\n                if(mp.count(d))D.Unite(i, mp[d]);\\n                \\n                d = mask;\\n                if(bool(d&(1<<a))){\\n                    d^=1<<a;\\n                    d|=1<<26;\\n                    if(mp.count(d))D.Unite(i,mp[d]);\\n                }\\n                \\n            }\\n            \\n            mp[mask]=i;\\n            for(int j=0,msk; j<26; j++){\\n                msk=mask;\\n                if(bool(msk&(1<<j))){\\n                    msk^=1<<j;\\n                    msk|=(1<<26);\\n                    mp[msk]=i;\\n                }\\n            }\\n        }\\n        \\n        int mx=0;\\n        for(int i=0; i<n; i++)mx=max(mx,D.rank[i]);\\n        return {D.counter, mx};\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    struct dsu{\\n        vector<int>rank,parent;\\n        int counter;\\n        dsu(){}\\n        dsu(int n):rank(n,1),parent(n){\\n            for(int i=0; i<n; i++)parent[i]=i;\\n            counter=n;\\n        }\\n        \\n        inline int Find(int u){\\n            if(parent[u]==u)return u;\\n            return parent[u] = Find(parent[u]);\\n        }\\n        \\n        void Unite(int u, int v){\\n            u = Find(u);\\n            v = Find(v);\\n            if(u!=v){\\n                counter--;\\n                if(rank[u]<rank[v])swap(u,v);\\n                rank[u]+=rank[v];\\n                parent[v]=u;\\n            }\\n        }\\n        \\n    };\\n    \\n    struct custom_hash {\\n        static uint64_t splitmix64(uint64_t x) {\\n            // http://xorshift.di.unimi.it/splitmix64.c\\n            x += 0x9e3779b97f4a7c15;\\n            x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\\n            x = (x ^ (x >> 27)) * 0x94d049bb133111eb;\\n            return x ^ (x >> 31);\\n        }\\n\\n        size_t operator()(uint64_t x) const {\\n            static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();\\n            return splitmix64(x + FIXED_RANDOM);\\n        }\\n    };\\n\\n\\n    vector<int> groupStrings(vector<string>& words) {\\n        int n = words.size();\\n        unordered_map<int,int,custom_hash>mp;\\n        dsu D(n);\\n        \\n        for(int i=0,d,mask; i<n; i++){\\n            mask=0;\\n            for(char &c:words[i])mask|=(1<<(c-\\'a\\'));\\n            for(int a=0; a<26; a++){\\n                d = mask;\\n                d^=(1<<a);\\n                \\n                if(mp.count(d))D.Unite(i, mp[d]);\\n                \\n                d = mask;\\n                if(bool(d&(1<<a))){\\n                    d^=1<<a;\\n                    d|=1<<26;\\n                    if(mp.count(d))D.Unite(i,mp[d]);\\n                }\\n                \\n            }\\n            \\n            mp[mask]=i;\\n            for(int j=0,msk; j<26; j++){\\n                msk=mask;\\n                if(bool(msk&(1<<j))){\\n                    msk^=1<<j;\\n                    msk|=(1<<26);\\n                    mp[msk]=i;\\n                }\\n            }\\n        }\\n        \\n        int mx=0;\\n        for(int i=0; i<n; i++)mx=max(mx,D.rank[i]);\\n        return {D.counter, mx};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1730580,
                "title": "c-with-implementation-details-in-comment",
                "content": "The idea is simple, for each word(node) find all possible connections this node could have, then use a BFS to count the connected component, got TLE during the contest but eventually I made it work. To be fair, I didn\\'t do anything special, just resubmit the same code twice, thank you LeetCode :)\\n\\n```\\nclass Solution {\\npublic:\\n    unordered_map<int, unordered_set<int>> G;  // graph G\\n    \\n    unordered_map<int, int> cache; // cache all possible nodes\\n    \\n    void addNode(const string& s) {\\n        int mask = 0;\\n        for(auto& c : s) {\\n            mask |= (1 << (c - \\'a\\'));\\n        }\\n        cache[mask] += 1; // account for duplicate words in vocabulary\\n    }\\n    \\n    bool count[26];  // save time by avoiding dynamic allocation on heap\\n    \\n    void addEdge(const string& s) {\\n        memset(count, 0, sizeof(count));\\n        int mask = 0;\\n        for(auto& c : s) {\\n            count[c - \\'a\\'] = true;\\n            mask |= (1 << (c - \\'a\\'));\\n        }\\n        if(G.count(mask)) return;  // don\\'t process a duplicate word twice\\n        int self = mask;\\n        G[mask].insert(mask);\\n        vector<int> alpha_set, alpha_noset; // lower case letters used / not used in the current word\\n        for(int i=0; i<26; i++) {\\n            if(count[i]) { // adding letter \\'a\\' + i\\n                mask = self - (1 << i);\\n                if(cache.count(mask)) {\\n                    G[self].insert(mask);\\n                }\\n                alpha_set.push_back(i);\\n            }\\n            else { // deleting letter \\'a\\' + i\\n                mask = self + (1 << i);\\n                if(cache.count(mask)) {\\n                    G[self].insert(mask);\\n                }\\n                alpha_noset.push_back(i);\\n            }\\n        }\\n        for(auto& i : alpha_set) {\\n            for(auto& j : alpha_noset) { // adding letter \\'a\\' + j, deleting letter \\'a\\' + i\\n                mask = self - (1 << i) + (1 << j);\\n                if(cache.count(mask)) {\\n                    G[self].insert(mask);\\n                }\\n            }\\n        }\\n    }\\n    \\n    vector<int> groupStrings(vector<string>& words) {\\n        for(auto& s : words) {\\n            addNode(s);\\n        }\\n        for(auto& s : words) {\\n            addEdge(s);\\n        }\\n        int count = 0, max_sz = 0;\\n        int tmp, u, v, cur_sz;\\n        queue<int> q;    // pre-allocating all the variables and data structure required\\n        for(auto it = G.begin(); it != G.end(); it++) {\\n            tmp = 0;\\n            swap(cache[it->first], tmp); // use a swap so that we only need to hash once\\n            if(tmp) {\\n                count += 1;\\n                cur_sz = 0;\\n                q.push(it->first);\\n                cur_sz += tmp;    // account for duplicate words in vocabulary\\n                while(!q.empty()) {\\n                    u = q.front();\\n                    q.pop();\\n                    auto sit = G.find(u);    // use find so that only one hashing is required\\n                    for(auto tit = sit->second.begin(); tit != sit->second.end(); tit++) {\\n                        v = *tit;\\n                        tmp = 0;\\n                        swap(tmp, cache[v]);\\n                        if(tmp) {\\n                            q.push(v);\\n                            cur_sz += tmp;\\n                        }\\n                    }\\n                }\\n                max_sz = max(max_sz, cur_sz);\\n            }\\n        }\\n        return vector<int>{count, max_sz};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<int, unordered_set<int>> G;  // graph G\\n    \\n    unordered_map<int, int> cache; // cache all possible nodes\\n    \\n    void addNode(const string& s) {\\n        int mask = 0;\\n        for(auto& c : s) {\\n            mask |= (1 << (c - \\'a\\'));\\n        }\\n        cache[mask] += 1; // account for duplicate words in vocabulary\\n    }\\n    \\n    bool count[26];  // save time by avoiding dynamic allocation on heap\\n    \\n    void addEdge(const string& s) {\\n        memset(count, 0, sizeof(count));\\n        int mask = 0;\\n        for(auto& c : s) {\\n            count[c - \\'a\\'] = true;\\n            mask |= (1 << (c - \\'a\\'));\\n        }\\n        if(G.count(mask)) return;  // don\\'t process a duplicate word twice\\n        int self = mask;\\n        G[mask].insert(mask);\\n        vector<int> alpha_set, alpha_noset; // lower case letters used / not used in the current word\\n        for(int i=0; i<26; i++) {\\n            if(count[i]) { // adding letter \\'a\\' + i\\n                mask = self - (1 << i);\\n                if(cache.count(mask)) {\\n                    G[self].insert(mask);\\n                }\\n                alpha_set.push_back(i);\\n            }\\n            else { // deleting letter \\'a\\' + i\\n                mask = self + (1 << i);\\n                if(cache.count(mask)) {\\n                    G[self].insert(mask);\\n                }\\n                alpha_noset.push_back(i);\\n            }\\n        }\\n        for(auto& i : alpha_set) {\\n            for(auto& j : alpha_noset) { // adding letter \\'a\\' + j, deleting letter \\'a\\' + i\\n                mask = self - (1 << i) + (1 << j);\\n                if(cache.count(mask)) {\\n                    G[self].insert(mask);\\n                }\\n            }\\n        }\\n    }\\n    \\n    vector<int> groupStrings(vector<string>& words) {\\n        for(auto& s : words) {\\n            addNode(s);\\n        }\\n        for(auto& s : words) {\\n            addEdge(s);\\n        }\\n        int count = 0, max_sz = 0;\\n        int tmp, u, v, cur_sz;\\n        queue<int> q;    // pre-allocating all the variables and data structure required\\n        for(auto it = G.begin(); it != G.end(); it++) {\\n            tmp = 0;\\n            swap(cache[it->first], tmp); // use a swap so that we only need to hash once\\n            if(tmp) {\\n                count += 1;\\n                cur_sz = 0;\\n                q.push(it->first);\\n                cur_sz += tmp;    // account for duplicate words in vocabulary\\n                while(!q.empty()) {\\n                    u = q.front();\\n                    q.pop();\\n                    auto sit = G.find(u);    // use find so that only one hashing is required\\n                    for(auto tit = sit->second.begin(); tit != sit->second.end(); tit++) {\\n                        v = *tit;\\n                        tmp = 0;\\n                        swap(tmp, cache[v]);\\n                        if(tmp) {\\n                            q.push(v);\\n                            cur_sz += tmp;\\n                        }\\n                    }\\n                }\\n                max_sz = max(max_sz, cur_sz);\\n            }\\n        }\\n        return vector<int>{count, max_sz};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1730567,
                "title": "java-union-find-collecting-neighbors-no-bitmask",
                "content": "Basic Union Find. My first approach was to simply build a Frequency map for each word and then use O(N^2) to compare each pair, but I got TLE from that. That solution was basically O(26 * N^2) if we consider UnionFind O(1). \\n\\nAfter looking at some of the other solutions, I tried to use the method of putting neighbor words into a map: 1. sort each word\\n2.try deleting each character from that word to form a new word\\n3.check if there\\'s an existing word for the deleted version, If not store the <String, Indices> pair in the map, If yes, union the two indices. \\n\\nThis works because: a. by trying to delete each of the character, the same-length words that belong in a group can always somehow match up; b. Different-length words that belong in the same group differ by exactly one letter, so there also must be a match(longer word deleted one char = shorter word)\\nThis method still has to use O(MlogM) to sort and O(M) to check the maps and stuff, but it optimizes on N, which is evidently more likely to be larger in the test cases.\\n```\\nclass Solution {\\n    class UnionFind {\\n        int[] roots;\\n        int[] sizes;\\n        public UnionFind(int size) {\\n            roots = new int[size];\\n            sizes = new int[size];\\n            for(int i = 0; i < size; i++) {\\n                sizes[i] = 1;\\n                roots[i] = i;\\n            }\\n        }\\n        public int find(int val) {\\n            if(roots[val] == val) {\\n                return val;\\n            }\\n            roots[val] = find(roots[val]);\\n            return roots[val];\\n        }\\n        \\n        public void union(int a, int b) {\\n            int rootA = find(a);\\n            int rootB = find(b);\\n            \\n            if(rootA == rootB) {\\n                return;\\n            }\\n            if(sizes[rootA] < sizes[rootB]) {\\n                roots[rootA] = rootB;\\n                sizes[rootB] += sizes[rootA];\\n            } else {\\n                roots[rootB] = rootA;\\n                sizes[rootA] += sizes[rootB];\\n            }\\n        }\\n    }\\n    public int[] groupStrings(String[] words) {\\n        String[] wordsSorted = new String[words.length];\\n     \\n        UnionFind sol = new UnionFind(words.length);\\n        Map<String, Integer> RepInd = new HashMap<>();\\n        for(int i = 0; i < words.length; i++) {\\n            char[] arr = words[i].toCharArray();\\n            Arrays.sort(arr);\\n            addReplacement(new String(arr), RepInd, i, sol);\\n        }\\n        \\n        int groups = 0;\\n        int maxGroupSize = 0;\\n        for(int i = 0; i < words.length; i++) {\\n            if(sol.roots[i] == i) {\\n                groups++;\\n                maxGroupSize = Math.max(maxGroupSize, sol.sizes[i]);\\n            }\\n        }\\n        return new int[]{groups, maxGroupSize};\\n    }\\n    \\n    private void addReplacement(String s, Map<String, Integer> RepInd, int i, UnionFind sol) {\\n        Integer index = RepInd.get(s);\\n        if(index == null) {\\n            RepInd.put(s, i);\\n        } else if(index != i) {\\n            sol.union(index, i);\\n        }\\n        for(int j = 0; j < s.length(); j++) {\\n            String newString = s.substring(0, j) + s.substring(j + 1);\\n            Integer temp = RepInd.get(newString);\\n            if(temp == null) {\\n                RepInd.put(newString, i);\\n            } else if(temp != i){\\n                sol.union(temp, i);\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    class UnionFind {\\n        int[] roots;\\n        int[] sizes;\\n        public UnionFind(int size) {\\n            roots = new int[size];\\n            sizes = new int[size];\\n            for(int i = 0; i < size; i++) {\\n                sizes[i] = 1;\\n                roots[i] = i;\\n            }\\n        }\\n        public int find(int val) {\\n            if(roots[val] == val) {\\n                return val;\\n            }\\n            roots[val] = find(roots[val]);\\n            return roots[val];\\n        }\\n        \\n        public void union(int a, int b) {\\n            int rootA = find(a);\\n            int rootB = find(b);\\n            \\n            if(rootA == rootB) {\\n                return;\\n            }\\n            if(sizes[rootA] < sizes[rootB]) {\\n                roots[rootA] = rootB;\\n                sizes[rootB] += sizes[rootA];\\n            } else {\\n                roots[rootB] = rootA;\\n                sizes[rootA] += sizes[rootB];\\n            }\\n        }\\n    }\\n    public int[] groupStrings(String[] words) {\\n        String[] wordsSorted = new String[words.length];\\n     \\n        UnionFind sol = new UnionFind(words.length);\\n        Map<String, Integer> RepInd = new HashMap<>();\\n        for(int i = 0; i < words.length; i++) {\\n            char[] arr = words[i].toCharArray();\\n            Arrays.sort(arr);\\n            addReplacement(new String(arr), RepInd, i, sol);\\n        }\\n        \\n        int groups = 0;\\n        int maxGroupSize = 0;\\n        for(int i = 0; i < words.length; i++) {\\n            if(sol.roots[i] == i) {\\n                groups++;\\n                maxGroupSize = Math.max(maxGroupSize, sol.sizes[i]);\\n            }\\n        }\\n        return new int[]{groups, maxGroupSize};\\n    }\\n    \\n    private void addReplacement(String s, Map<String, Integer> RepInd, int i, UnionFind sol) {\\n        Integer index = RepInd.get(s);\\n        if(index == null) {\\n            RepInd.put(s, i);\\n        } else if(index != i) {\\n            sol.union(index, i);\\n        }\\n        for(int j = 0; j < s.length(); j++) {\\n            String newString = s.substring(0, j) + s.substring(j + 1);\\n            Integer temp = RepInd.get(newString);\\n            if(temp == null) {\\n                RepInd.put(newString, i);\\n            } else if(temp != i){\\n                sol.union(temp, i);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1730558,
                "title": "c-unionfind-and-bit-manipulation",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> groupStrings(vector<string>& words) {\\n        const int len = words.size();\\n        std::vector<int> masks;\\n        std::vector<std::vector<int>> mask_len_to_inds(26 + 1);\\n        {\\n            masks.reserve(len);\\n            int idx = 0;\\n            for (auto &&word : words) {\\n                int mask = 0;\\n                for (char ch : word) {\\n                    mask |= 1 << (static_cast<int>(ch - \\'a\\'));\\n                }\\n                masks.push_back(mask);\\n                mask_len_to_inds[__builtin_popcount(mask)].push_back(idx++);\\n            }    \\n        }\\n        \\n        UnionFind dset(len);        \\n        std::unordered_map<int, int> mask_to_idx;\\n        const auto maybe_merge = [&](const int idx, const int mask) {\\n            auto it = mask_to_idx.find(mask);\\n            if (it != mask_to_idx.end()) {\\n                dset.merge(idx, it->second);\\n            }              \\n        };\\n        \\n        for (auto &&inds : mask_len_to_inds) {                \\n            for (const int idx : inds) {\\n                const int src_mask = masks[idx];                                \\n                // Find if there\\'s an exact match\\n                maybe_merge(idx, src_mask);\\n\\n                // Find deletion match.\\n                for (int i = 0; i < 26; ++i) {\\n                    if (!(src_mask & (1 << i))) {\\n                        continue;\\n                    }\\n                    maybe_merge(idx, src_mask ^ (1 << i));\\n                }\\n                \\n                // Find mutation match.\\n                for (int i = 0; i < 26; ++i) {\\n                    for (int j = i + 1; j < 26; ++j) {\\n                        if (((src_mask & (1 << i)) == 0) == ((src_mask & (1 << j)) == 0)) {\\n                            continue;\\n                        }\\n                        maybe_merge(idx, src_mask ^ ((1 << i) | (1 << j)));\\n                    }\\n                }\\n                \\n                mask_to_idx[src_mask] = idx;\\n            }            \\n        }\\n        \\n        return dset.compute_group_stats();\\n    }\\nprivate:\\n    class UnionFind {\\n    public:\\n        UnionFind(int n) : parent_(n), rank_(n, 0) {\\n            std::iota(parent_.begin(), parent_.end(), 0);\\n        }\\n        \\n        std::vector<int> compute_group_stats() {\\n            std::vector<int> group_to_size(parent_.size(), 0);\\n            for (int u = 0; u < parent_.size(); ++u) {\\n                ++group_to_size[parent(u)];\\n            }\\n            int max_size = 0;\\n            int num_groups = 0;\\n            for (const int size : group_to_size) {\\n                if (size == 0) {\\n                    continue;\\n                }\\n                ++num_groups;\\n                max_size = std::max(size, max_size);\\n            }\\n            return {num_groups, max_size};            \\n        }\\n        \\n        void merge(int u, int v) {\\n            const int pu = parent(u), pv = parent(v);\\n            if (pu == pv) {\\n                return;\\n            }\\n            const int r_pu = rank_[pu], r_pv = rank_[pv];\\n            if (r_pu <= r_pv) {\\n                parent_[pu] = pv;\\n                if (r_pu == r_pv) {\\n                    ++rank_[pv];\\n                }\\n            } else {\\n                parent_[pv] = pu;\\n            }\\n        }\\n        \\n    private:\\n        int parent(int u) {\\n            int pu = parent_[u];\\n            if (pu != u) {\\n                pu = parent_[u] = parent(pu);\\n            }\\n            return pu;\\n        }\\n                \\n        std::vector<int> parent_;\\n        std::vector<int> rank_;        \\n    };    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> groupStrings(vector<string>& words) {\\n        const int len = words.size();\\n        std::vector<int> masks;\\n        std::vector<std::vector<int>> mask_len_to_inds(26 + 1);\\n        {\\n            masks.reserve(len);\\n            int idx = 0;\\n            for (auto &&word : words) {\\n                int mask = 0;\\n                for (char ch : word) {\\n                    mask |= 1 << (static_cast<int>(ch - \\'a\\'));\\n                }\\n                masks.push_back(mask);\\n                mask_len_to_inds[__builtin_popcount(mask)].push_back(idx++);\\n            }    \\n        }\\n        \\n        UnionFind dset(len);        \\n        std::unordered_map<int, int> mask_to_idx;\\n        const auto maybe_merge = [&](const int idx, const int mask) {\\n            auto it = mask_to_idx.find(mask);\\n            if (it != mask_to_idx.end()) {\\n                dset.merge(idx, it->second);\\n            }              \\n        };\\n        \\n        for (auto &&inds : mask_len_to_inds) {                \\n            for (const int idx : inds) {\\n                const int src_mask = masks[idx];                                \\n                // Find if there\\'s an exact match\\n                maybe_merge(idx, src_mask);\\n\\n                // Find deletion match.\\n                for (int i = 0; i < 26; ++i) {\\n                    if (!(src_mask & (1 << i))) {\\n                        continue;\\n                    }\\n                    maybe_merge(idx, src_mask ^ (1 << i));\\n                }\\n                \\n                // Find mutation match.\\n                for (int i = 0; i < 26; ++i) {\\n                    for (int j = i + 1; j < 26; ++j) {\\n                        if (((src_mask & (1 << i)) == 0) == ((src_mask & (1 << j)) == 0)) {\\n                            continue;\\n                        }\\n                        maybe_merge(idx, src_mask ^ ((1 << i) | (1 << j)));\\n                    }\\n                }\\n                \\n                mask_to_idx[src_mask] = idx;\\n            }            \\n        }\\n        \\n        return dset.compute_group_stats();\\n    }\\nprivate:\\n    class UnionFind {\\n    public:\\n        UnionFind(int n) : parent_(n), rank_(n, 0) {\\n            std::iota(parent_.begin(), parent_.end(), 0);\\n        }\\n        \\n        std::vector<int> compute_group_stats() {\\n            std::vector<int> group_to_size(parent_.size(), 0);\\n            for (int u = 0; u < parent_.size(); ++u) {\\n                ++group_to_size[parent(u)];\\n            }\\n            int max_size = 0;\\n            int num_groups = 0;\\n            for (const int size : group_to_size) {\\n                if (size == 0) {\\n                    continue;\\n                }\\n                ++num_groups;\\n                max_size = std::max(size, max_size);\\n            }\\n            return {num_groups, max_size};            \\n        }\\n        \\n        void merge(int u, int v) {\\n            const int pu = parent(u), pv = parent(v);\\n            if (pu == pv) {\\n                return;\\n            }\\n            const int r_pu = rank_[pu], r_pv = rank_[pv];\\n            if (r_pu <= r_pv) {\\n                parent_[pu] = pv;\\n                if (r_pu == r_pv) {\\n                    ++rank_[pv];\\n                }\\n            } else {\\n                parent_[pv] = pu;\\n            }\\n        }\\n        \\n    private:\\n        int parent(int u) {\\n            int pu = parent_[u];\\n            if (pu != u) {\\n                pu = parent_[u] = parent(pu);\\n            }\\n            return pu;\\n        }\\n                \\n        std::vector<int> parent_;\\n        std::vector<int> rank_;        \\n    };    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1730509,
                "title": "python-dfs-with-bitmask",
                "content": "```\\ndef groupStrings(self, words: List[str]) -> List[int]:\\n        encode=[]\\n        for w in words:\\n            en=0\\n            for c in w:\\n                en+=1<<(ord(c)-ord(\\'a\\')+1)\\n            encode.append(en)\\n        count=Counter(encode)\\n        visited=set()\\n        def dfs(mask):\\n            visited.add(mask)\\n            tmp=count[mask]\\n            idx_1=set()\\n            idx_0=set()\\n            for i in range(26):\\n                if mask&(1<<(i+1)):\\n                    m=mask^(1<<(i+1))\\n                    idx_1.add(i)\\n                    if m in count and m not in visited:tmp+=dfs(m)\\n                else:\\n                    m=mask|(1<<(i+1))\\n                    idx_0.add(i)\\n                    if m in count and m not in visited:tmp+=dfs(m)\\n            for i in idx_1:\\n                for j in idx_0:\\n                    m=(mask^(1<<(i+1)))|(1<<(j+1))\\n                    if m in count and m not in visited:tmp+=dfs(m)\\n            return tmp\\n        c=0\\n        max_size=0\\n        for mask in count:\\n            if mask not in visited:\\n                c+=1\\n                max_size=max(max_size,dfs(mask))\\n        return [c,max_size]\\n```",
                "solutionTags": [],
                "code": "```\\ndef groupStrings(self, words: List[str]) -> List[int]:\\n        encode=[]\\n        for w in words:\\n            en=0\\n            for c in w:\\n                en+=1<<(ord(c)-ord(\\'a\\')+1)\\n            encode.append(en)\\n        count=Counter(encode)\\n        visited=set()\\n        def dfs(mask):\\n            visited.add(mask)\\n            tmp=count[mask]\\n            idx_1=set()\\n            idx_0=set()\\n            for i in range(26):\\n                if mask&(1<<(i+1)):\\n                    m=mask^(1<<(i+1))\\n                    idx_1.add(i)\\n                    if m in count and m not in visited:tmp+=dfs(m)\\n                else:\\n                    m=mask|(1<<(i+1))\\n                    idx_0.add(i)\\n                    if m in count and m not in visited:tmp+=dfs(m)\\n            for i in idx_1:\\n                for j in idx_0:\\n                    m=(mask^(1<<(i+1)))|(1<<(j+1))\\n                    if m in count and m not in visited:tmp+=dfs(m)\\n            return tmp\\n        c=0\\n        max_size=0\\n        for mask in count:\\n            if mask not in visited:\\n                c+=1\\n                max_size=max(max_size,dfs(mask))\\n        return [c,max_size]\\n```",
                "codeTag": "Python3"
            }
        ],
        "discussions": [
            {
                "id": 1566417,
                "content": [
                    {
                        "username": "mr_scott",
                        "content": "IMO, they should either accept all O(n \\\\* 26 \\\\* 26) aolutions or reject all such solutoons. \\nThe same code is passing in CPP but failing Python3"
                    },
                    {
                        "username": "sourashis140",
                        "content": "Can anyone please explain how the hell this string array [\"zobly\",\"zyqv\",\"emjxk\",\"vd\",\"b\",\"c\",\"a\",\"wqvy\",\"fser\"] has 6 groups of connected strings!!"
                    },
                    {
                        "username": "Abhinav_Chaitanya01",
                        "content": "From the question description, {b,c,a} form a group (replace any one letter rule} , now {zyqv, wqvy} form another. Rest remaining groups are {zobly}, {emjxk}, {vd} and {fser}. Since no rule/operation can be used to merge them. hence total of 6 groups."
                    },
                    {
                        "username": "_mayankrawatt",
                        "content": "hey this is my code , logically it is correct and also passes 72 test cases, but don\\'t know what happened with 73 one, i can not identify my logical eroor can someone help me\\n `class Solution {\\npublic:\\n     vector<int>parent;\\n    vector<int>size;\\n    \\n    int ulp (int a){\\n        if(parent[a]==a)return a;\\n        return parent[a]=ulp(parent[a]);\\n    }\\n    \\n    void uni(int a,int b){\\n        \\n        int p1=ulp(a);\\n        int p2=ulp(b);\\n        \\n        if(p1==p2)return;\\n        \\n        if(size[p1]>size[p2]){\\n            size[p1]+=size[p2];\\n            parent[p2]=parent[p1];\\n        }\\n        else{\\n            size[p2]+=size[p1];\\n            parent[p1]=parent[p2];\\n        }\\n    }\\n    \\n    bool sim(string a, string b){\\n        \\n        sort(a.begin(),a.end());\\n        sort(b.begin(),b.end());\\n        \\n        int x1=a.size();\\n        int x2=b.size();\\n        \\n        \\n        // cout<<x1<<x2<<\" \";\\n        if(abs(x2-x1)>=2)return 0;\\n        \\n        if(x1==x2){\\n            unordered_set<char>st;\\n           \\n            for(int i=0;i<x1;i++){\\n                st.insert(a[i]);\\n                st.insert(b[i]);\\n            }\\n            \\n            if(st.size()==x1+1)return 1;\\n            return 0;\\n        }\\n        \\n        \\n            unordered_set<char>st;\\n           \\n            for(int i=0;i<x1;i++){\\n                st.insert(a[i]);\\n                \\n            }\\n        for(int i=0;i<x2;i++){\\n                st.insert(b[i]);\\n                \\n            }\\n        \\n        // int siz=st.size();\\n            if(x1>x2){\\n                 return st.size()==x1;\\n            }\\n           \\n        \\n            return st.size()==x2;\\n    }\\n    vector<int> groupStrings(vector<string>& words) {\\n        int n=words.size();\\n        \\n        parent.resize(n);\\n        \\n        size.resize(n);\\n        for(int i=0;i<n;i++){\\n            parent[i]=i;  \\n            size[i]=1;\\n        }\\n       \\n        for(int i=0;i<n;i++){\\n            \\n            for(int j=0;j<n;j++){\\n                if(ulp(i)!=ulp(j) && sim(words[i],words[j])){\\n                    // cout<<i<<j<<\" \";\\n                    uni(i,j);\\n                }\\n                \\n            }\\n        }\\n        \\n        int a1=0;\\n        int a2=1;\\n        for(int i=0;i<n;i++){\\n            if(parent[i]==i){\\n                a1++;\\n                a2=max(a2,size[i]);\\n            }\\n        }\\n        \\n        return {a1,a2};\\n    }\\n};`"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "BRUH DONT POST SOLUTIONS"
                    }
                ]
            },
            {
                "id": 1876412,
                "content": [
                    {
                        "username": "mr_scott",
                        "content": "IMO, they should either accept all O(n \\\\* 26 \\\\* 26) aolutions or reject all such solutoons. \\nThe same code is passing in CPP but failing Python3"
                    },
                    {
                        "username": "sourashis140",
                        "content": "Can anyone please explain how the hell this string array [\"zobly\",\"zyqv\",\"emjxk\",\"vd\",\"b\",\"c\",\"a\",\"wqvy\",\"fser\"] has 6 groups of connected strings!!"
                    },
                    {
                        "username": "Abhinav_Chaitanya01",
                        "content": "From the question description, {b,c,a} form a group (replace any one letter rule} , now {zyqv, wqvy} form another. Rest remaining groups are {zobly}, {emjxk}, {vd} and {fser}. Since no rule/operation can be used to merge them. hence total of 6 groups."
                    },
                    {
                        "username": "_mayankrawatt",
                        "content": "hey this is my code , logically it is correct and also passes 72 test cases, but don\\'t know what happened with 73 one, i can not identify my logical eroor can someone help me\\n `class Solution {\\npublic:\\n     vector<int>parent;\\n    vector<int>size;\\n    \\n    int ulp (int a){\\n        if(parent[a]==a)return a;\\n        return parent[a]=ulp(parent[a]);\\n    }\\n    \\n    void uni(int a,int b){\\n        \\n        int p1=ulp(a);\\n        int p2=ulp(b);\\n        \\n        if(p1==p2)return;\\n        \\n        if(size[p1]>size[p2]){\\n            size[p1]+=size[p2];\\n            parent[p2]=parent[p1];\\n        }\\n        else{\\n            size[p2]+=size[p1];\\n            parent[p1]=parent[p2];\\n        }\\n    }\\n    \\n    bool sim(string a, string b){\\n        \\n        sort(a.begin(),a.end());\\n        sort(b.begin(),b.end());\\n        \\n        int x1=a.size();\\n        int x2=b.size();\\n        \\n        \\n        // cout<<x1<<x2<<\" \";\\n        if(abs(x2-x1)>=2)return 0;\\n        \\n        if(x1==x2){\\n            unordered_set<char>st;\\n           \\n            for(int i=0;i<x1;i++){\\n                st.insert(a[i]);\\n                st.insert(b[i]);\\n            }\\n            \\n            if(st.size()==x1+1)return 1;\\n            return 0;\\n        }\\n        \\n        \\n            unordered_set<char>st;\\n           \\n            for(int i=0;i<x1;i++){\\n                st.insert(a[i]);\\n                \\n            }\\n        for(int i=0;i<x2;i++){\\n                st.insert(b[i]);\\n                \\n            }\\n        \\n        // int siz=st.size();\\n            if(x1>x2){\\n                 return st.size()==x1;\\n            }\\n           \\n        \\n            return st.size()==x2;\\n    }\\n    vector<int> groupStrings(vector<string>& words) {\\n        int n=words.size();\\n        \\n        parent.resize(n);\\n        \\n        size.resize(n);\\n        for(int i=0;i<n;i++){\\n            parent[i]=i;  \\n            size[i]=1;\\n        }\\n       \\n        for(int i=0;i<n;i++){\\n            \\n            for(int j=0;j<n;j++){\\n                if(ulp(i)!=ulp(j) && sim(words[i],words[j])){\\n                    // cout<<i<<j<<\" \";\\n                    uni(i,j);\\n                }\\n                \\n            }\\n        }\\n        \\n        int a1=0;\\n        int a2=1;\\n        for(int i=0;i<n;i++){\\n            if(parent[i]==i){\\n                a1++;\\n                a2=max(a2,size[i]);\\n            }\\n        }\\n        \\n        return {a1,a2};\\n    }\\n};`"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "BRUH DONT POST SOLUTIONS"
                    }
                ]
            },
            {
                "id": 1875962,
                "content": [
                    {
                        "username": "mr_scott",
                        "content": "IMO, they should either accept all O(n \\\\* 26 \\\\* 26) aolutions or reject all such solutoons. \\nThe same code is passing in CPP but failing Python3"
                    },
                    {
                        "username": "sourashis140",
                        "content": "Can anyone please explain how the hell this string array [\"zobly\",\"zyqv\",\"emjxk\",\"vd\",\"b\",\"c\",\"a\",\"wqvy\",\"fser\"] has 6 groups of connected strings!!"
                    },
                    {
                        "username": "Abhinav_Chaitanya01",
                        "content": "From the question description, {b,c,a} form a group (replace any one letter rule} , now {zyqv, wqvy} form another. Rest remaining groups are {zobly}, {emjxk}, {vd} and {fser}. Since no rule/operation can be used to merge them. hence total of 6 groups."
                    },
                    {
                        "username": "_mayankrawatt",
                        "content": "hey this is my code , logically it is correct and also passes 72 test cases, but don\\'t know what happened with 73 one, i can not identify my logical eroor can someone help me\\n `class Solution {\\npublic:\\n     vector<int>parent;\\n    vector<int>size;\\n    \\n    int ulp (int a){\\n        if(parent[a]==a)return a;\\n        return parent[a]=ulp(parent[a]);\\n    }\\n    \\n    void uni(int a,int b){\\n        \\n        int p1=ulp(a);\\n        int p2=ulp(b);\\n        \\n        if(p1==p2)return;\\n        \\n        if(size[p1]>size[p2]){\\n            size[p1]+=size[p2];\\n            parent[p2]=parent[p1];\\n        }\\n        else{\\n            size[p2]+=size[p1];\\n            parent[p1]=parent[p2];\\n        }\\n    }\\n    \\n    bool sim(string a, string b){\\n        \\n        sort(a.begin(),a.end());\\n        sort(b.begin(),b.end());\\n        \\n        int x1=a.size();\\n        int x2=b.size();\\n        \\n        \\n        // cout<<x1<<x2<<\" \";\\n        if(abs(x2-x1)>=2)return 0;\\n        \\n        if(x1==x2){\\n            unordered_set<char>st;\\n           \\n            for(int i=0;i<x1;i++){\\n                st.insert(a[i]);\\n                st.insert(b[i]);\\n            }\\n            \\n            if(st.size()==x1+1)return 1;\\n            return 0;\\n        }\\n        \\n        \\n            unordered_set<char>st;\\n           \\n            for(int i=0;i<x1;i++){\\n                st.insert(a[i]);\\n                \\n            }\\n        for(int i=0;i<x2;i++){\\n                st.insert(b[i]);\\n                \\n            }\\n        \\n        // int siz=st.size();\\n            if(x1>x2){\\n                 return st.size()==x1;\\n            }\\n           \\n        \\n            return st.size()==x2;\\n    }\\n    vector<int> groupStrings(vector<string>& words) {\\n        int n=words.size();\\n        \\n        parent.resize(n);\\n        \\n        size.resize(n);\\n        for(int i=0;i<n;i++){\\n            parent[i]=i;  \\n            size[i]=1;\\n        }\\n       \\n        for(int i=0;i<n;i++){\\n            \\n            for(int j=0;j<n;j++){\\n                if(ulp(i)!=ulp(j) && sim(words[i],words[j])){\\n                    // cout<<i<<j<<\" \";\\n                    uni(i,j);\\n                }\\n                \\n            }\\n        }\\n        \\n        int a1=0;\\n        int a2=1;\\n        for(int i=0;i<n;i++){\\n            if(parent[i]==i){\\n                a1++;\\n                a2=max(a2,size[i]);\\n            }\\n        }\\n        \\n        return {a1,a2};\\n    }\\n};`"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "BRUH DONT POST SOLUTIONS"
                    }
                ]
            }
        ]
    }
]