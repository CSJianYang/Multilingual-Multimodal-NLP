[
    {
        "title": "Number of Subarrays With GCD Equal to K",
        "question_content": "Given an integer array nums and an integer k, return the number of subarrays of nums where the greatest common divisor of the subarray's elements is k.\nA subarray is a contiguous non-empty sequence of elements within an array.\nThe greatest common divisor of an array is the largest integer that evenly divides all the array elements.\n&nbsp;\nExample 1:\n\nInput: nums = [9,3,1,2,6,3], k = 3\nOutput: 4\nExplanation: The subarrays of nums where 3 is the greatest common divisor of all the subarray's elements are:\n- [9,3,1,2,6,3]\n- [9,3,1,2,6,3]\n- [9,3,1,2,6,3]\n- [9,3,1,2,6,3]\n\nExample 2:\n\nInput: nums = [4], k = 7\nOutput: 0\nExplanation: There are no subarrays of nums where 7 is the greatest common divisor of all the subarray's elements.\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 1000\n\t1 <= nums[i], k <= 109",
        "solutions": [
            {
                "id": 2734442,
                "title": "brute-force-vs-count-gcds",
                "content": "It feels like this problem can be solved using a sliding window or something, but it\\'s not the case.\\n\\nLooking at the constraints helps. As a follow-up, there is the Count GCDs solution below, which exploits the fact that the number of distinct GCDs is limited by log(m) - where m is the maximum value in `nums`. \\n\\n#### Brute-Force O(n ^ 2)\\n**C++**\\n```cpp\\nint subarrayGCD(vector<int>& nums, int k) {\\n    int res = 0;\\n    for (int i = 0; i < nums.size(); ++i)\\n        for (int j = i; j < nums.size() && nums[j] % k == 0; ++j) {\\n            nums[i] = gcd(nums[i], nums[j]);\\n            res += nums[i] == k;\\n        }\\n    return res;\\n}\\n```\\n#### Count GCDs O(n log m)\\nFor an element `num[i]`, we count GCDs produced by subarrays:\\n- `nums[i - 1]`\\n- `nums[i - 2], nums[i - 1]`\\n- `nums[i - 3], nums[i - 2], nums[i - 1]`\\n- ...and so on.\\n\\nThe number of distinct GCDs would not exceed log(m), where m is the maximum value in the array.\\n\\n> Note that those disticnt GCDs should share a factor `k`, and come from subarrays ending at some position.\\n> To produce a different GCD, `gcd(n[i], gcd(n[i - 2], n[i - 1])` should be bigger than `gcd(n[i - 2], n[i - 1])`.\\n> Therefore `n[i - 1] < n[i]`, and `n[i - 1]  * f == n[i]`.\\n> The best we can do is something like `[2, 4, 8, 16, 32, ...]`, and the number of unique GCDs will therefore be log m.\\n\\n**C++**\\n```cpp\\nint subarrayGCD(vector<int>& nums, int k) {\\n    int res = 0;\\n    unordered_map<int, int> gcds;\\n    for (int i = 0; i < nums.size(); ++i) {\\n        unordered_map<int, int> gcds1;\\n        if (nums[i] % k == 0) {\\n            ++gcds[nums[i]];\\n            for (auto [prev_gcd, cnt] : gcds)\\n                gcds1[gcd(prev_gcd, nums[i])] += cnt;\\n        }\\n        res += gcds1[k];\\n        swap(gcds, gcds1);\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint subarrayGCD(vector<int>& nums, int k) {\\n    int res = 0;\\n    for (int i = 0; i < nums.size(); ++i)\\n        for (int j = i; j < nums.size() && nums[j] % k == 0; ++j) {\\n            nums[i] = gcd(nums[i], nums[j]);\\n            res += nums[i] == k;\\n        }\\n    return res;\\n}\\n```\n```cpp\\nint subarrayGCD(vector<int>& nums, int k) {\\n    int res = 0;\\n    unordered_map<int, int> gcds;\\n    for (int i = 0; i < nums.size(); ++i) {\\n        unordered_map<int, int> gcds1;\\n        if (nums[i] % k == 0) {\\n            ++gcds[nums[i]];\\n            for (auto [prev_gcd, cnt] : gcds)\\n                gcds1[gcd(prev_gcd, nums[i])] += cnt;\\n        }\\n        res += gcds1[k];\\n        swap(gcds, gcds1);\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2734158,
                "title": "c-simple-code-with-dry-run",
                "content": "1.gcd of (0, n) is n.\\n\\n```\\n    int subarrayGCD(vector<int>& nums, int k) {\\n\\t\\tint cnt = 0;\\n        for (int i = 0; i < size(nums); i++)\\n        {\\n            int currGcd = 0;\\n            for (int j = i; j < size(nums); j++)\\n            {\\n                currGcd = gcd(currGcd, nums[j]);\\n                if (currGcd == k) cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n```\\nDry Run for nums : `[9,3,1,2,6,3]`, `K = 3`\\n```\\ni : 9 j: 9 currGcd: 9 cnt:0\\ni : 9 j: 3 currGcd: 3 cnt:1 *\\ni : 9 j: 1 currGcd: 1 cnt:1\\ni : 9 j: 2 currGcd: 1 cnt:1\\ni : 9 j: 6 currGcd: 1 cnt:1\\ni : 9 j: 3 currGcd: 1 cnt:1\\n\\ni : 3 j: 3 currGcd: 3 cnt:2 *\\ni : 3 j: 1 currGcd: 1 cnt:2\\ni : 3 j: 2 currGcd: 1 cnt:2\\ni : 3 j: 6 currGcd: 1 cnt:2\\ni : 3 j: 3 currGcd: 1 cnt:2\\n\\ni : 1 j: 1 currGcd: 1 cnt:2\\ni : 1 j: 2 currGcd: 1 cnt:2\\ni : 1 j: 6 currGcd: 1 cnt:2\\ni : 1 j: 3 currGcd: 1 cnt:2\\n\\ni : 2 j: 2 currGcd: 2 cnt:2\\ni : 2 j: 6 currGcd: 2 cnt:2\\ni : 2 j: 3 currGcd: 1 cnt:2\\n\\ni : 6 j: 6 currGcd: 6 cnt:2\\ni : 6 j: 3 currGcd: 3 cnt:3 *\\n\\ni : 3 j: 3 currGcd: 3 cnt:4 *\\n```\\n\\n\\n**Optimisation**:  after updating count : `if(currGcd < k || (currGcd % k) != 0) break;`  [@parameterNextNaive](https://leetcode.com/parameterNextNaive/)\\n\\n`[9,3,1,2,6,3]`, `K = 3`\\n\\n```\\ni : 9 j: 9 currGcd: 9 cnt:0\\ni : 9 j: 3 currGcd: 3 cnt:1 *\\ni : 9 j: 1 currGcd: 1 cnt:1\\n\\ni : 3 j: 3 currGcd: 3 cnt:2 *\\ni : 3 j: 1 currGcd: 1 cnt:2\\n\\ni : 1 j: 1 currGcd: 1 cnt:2\\n\\ni : 2 j: 2 currGcd: 2 cnt:2\\n\\ni : 6 j: 6 currGcd: 6 cnt:2\\ni : 6 j: 3 currGcd: 3 cnt:3 *\\n\\ni : 3 j: 3 currGcd: 3 cnt:4 *\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n    int subarrayGCD(vector<int>& nums, int k) {\\n\\t\\tint cnt = 0;\\n        for (int i = 0; i < size(nums); i++)\\n        {\\n            int currGcd = 0;\\n            for (int j = i; j < size(nums); j++)\\n            {\\n                currGcd = gcd(currGcd, nums[j]);\\n                if (currGcd == k) cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n```\n```\\ni : 9 j: 9 currGcd: 9 cnt:0\\ni : 9 j: 3 currGcd: 3 cnt:1 *\\ni : 9 j: 1 currGcd: 1 cnt:1\\ni : 9 j: 2 currGcd: 1 cnt:1\\ni : 9 j: 6 currGcd: 1 cnt:1\\ni : 9 j: 3 currGcd: 1 cnt:1\\n\\ni : 3 j: 3 currGcd: 3 cnt:2 *\\ni : 3 j: 1 currGcd: 1 cnt:2\\ni : 3 j: 2 currGcd: 1 cnt:2\\ni : 3 j: 6 currGcd: 1 cnt:2\\ni : 3 j: 3 currGcd: 1 cnt:2\\n\\ni : 1 j: 1 currGcd: 1 cnt:2\\ni : 1 j: 2 currGcd: 1 cnt:2\\ni : 1 j: 6 currGcd: 1 cnt:2\\ni : 1 j: 3 currGcd: 1 cnt:2\\n\\ni : 2 j: 2 currGcd: 2 cnt:2\\ni : 2 j: 6 currGcd: 2 cnt:2\\ni : 2 j: 3 currGcd: 1 cnt:2\\n\\ni : 6 j: 6 currGcd: 6 cnt:2\\ni : 6 j: 3 currGcd: 3 cnt:3 *\\n\\ni : 3 j: 3 currGcd: 3 cnt:4 *\\n```\n```\\ni : 9 j: 9 currGcd: 9 cnt:0\\ni : 9 j: 3 currGcd: 3 cnt:1 *\\ni : 9 j: 1 currGcd: 1 cnt:1\\n\\ni : 3 j: 3 currGcd: 3 cnt:2 *\\ni : 3 j: 1 currGcd: 1 cnt:2\\n\\ni : 1 j: 1 currGcd: 1 cnt:2\\n\\ni : 2 j: 2 currGcd: 2 cnt:2\\n\\ni : 6 j: 6 currGcd: 6 cnt:2\\ni : 6 j: 3 currGcd: 3 cnt:3 *\\n\\ni : 3 j: 3 currGcd: 3 cnt:4 *\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2734123,
                "title": "o-n-log-max-nums-with-explanation-similar-question",
                "content": "**O(N*N)**\\n* Iterate over all subarrays and check if the gcd equlas k.\\n\\n\\n```\\nclass Solution {\\n    public int subarrayGCD(int[] nums, int k) {\\n        int cnt = 0;\\n        for(int i=0;i<nums.length;i++){\\n            int gcd = nums[i];\\n            for(int j=i;j<nums.length;j++){\\n                gcd = getGCD(gcd,nums[j]);\\n                if(gcd == k) cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n    public static int getGCD(int a, int b){\\n        while(b!=0){\\n            int temp = b;\\n            b = a%b;\\n            a = temp;\\n        }\\n        return a;\\n    }\\n}\\n```\\n\\n**O(N*log(max(nums)))**\\n\\nObserve that the number of distinct gcd\\'s in the contiguous subsequence of the given sequence a[] is going to be small. We can precompute for each distinct gcd its count and then store it in a map. There can be atmost log(max(nums)) distinct gcds in a subarray.\\n\\n* How to get the count of each gcd ? \\n* Assume that we know the count of each gcd till a[i - 1]. A gcd of a subarray ending at a[i] will either be of the form gcd(a[i], <some subarray ending at a[i - 1]>) or will be a[i] itself.\\n*  Since we already know the count of each distinct gcd ending at a[i - 1], we can simply take the gcd of all those with a[i] and increment the count of the resulting gcd (in the map that stores the count of subarrays ending at a[i]).\\n*  We will need 2 maps, one to store the count of each gcd till a[i - 1], and one to calculate the count till a[i]. \\n*  Finally we will need another map to store the final counts of each gcd. This map will be updated with the entries of the second map at the end of each iteration.\\n \\n\\n\\n```\\nclass Solution {\\n    public int subarrayGCD(int[] arr, int k) {\\n        int cnt = 0;\\n        Map<Integer,Integer> gcdEndingAtPrev = new HashMap<>(); //Stores all gcds ending at arr[i-1] with their frequncies\\n        if(arr[0] == k) cnt++; \\n        gcdEndingAtPrev.put(arr[0],1);\\n        for(int i=1;i<arr.length;i++){\\n            HashMap<Integer,Integer> nf = new HashMap<>(); //Stores all gcds ending at arr[i]. This will become map for arr[i-1] on the next step\\n            int cur = arr[i]; \\n            gcdEndingAtPrev.put(cur,gcdEndingAtPrev.getOrDefault(cur,0)+1); //Important step. look below for explaination\\n            for(int key: gcdEndingAtPrev.keySet()){ //Iterate all prevoius gcds\\n                int cur_gcd = getGcd(key,cur);  //Calculate gcd ending arr[i]\\n                int f = gcdEndingAtPrev.get(key);  //Freq of new gcd is same as freq of previous gcd. If can\\'t visualize this try a dry run with a sample array\\n                if(cur_gcd == k) cnt = cnt+f;\\n                nf.put(cur_gcd,nf.getOrDefault(cur_gcd,0)+f);\\n            }\\n            gcdEndingAtPrev = nf;\\n        }\\n        return cnt;\\n    }\\n    private static int getGcd(int a, int b){\\n        if(a%b == 0) return b;\\n        return getGcd(b,a%b);\\n    }\\n}\\n```\\n\\n**Important Step**\\n1.  We increment the frequency of <code>arr[i]</code> in the map storing gcds ending at <code>arr[i-1]</code> because arr[i..i] is a valid subarray and shall be counted if its equal to k.\\n\\n\\n\\n\\n**Similar questions**\\n\\n1. [CodeChef Maximum of GCDs](https://www.codechef.com/problems/KSIZEGCD) [editorial of this question has full proof]     [Editorial](https://discuss.codechef.com/t/ksizegcd-editorial/104879)\\n2. [Codeforces 475D](https://codeforces.com/problemset/problem/475/D)\\n3. [GCDSUBARR](https://www.codechef.com/CDFT2023/problems/GCDSUBARR)\\n4. [Coprime Segment](https://codeforces.com/edu/course/2/lesson/9/2/practice/contest/307093/problem/G)\\n4. [Codeforces 1549D](https://codeforces.com/contest/1549/problem/D) (indirect application)(observation)\\n\\nPlease give a upvote if you like this solution",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int subarrayGCD(int[] nums, int k) {\\n        int cnt = 0;\\n        for(int i=0;i<nums.length;i++){\\n            int gcd = nums[i];\\n            for(int j=i;j<nums.length;j++){\\n                gcd = getGCD(gcd,nums[j]);\\n                if(gcd == k) cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n    public static int getGCD(int a, int b){\\n        while(b!=0){\\n            int temp = b;\\n            b = a%b;\\n            a = temp;\\n        }\\n        return a;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int subarrayGCD(int[] arr, int k) {\\n        int cnt = 0;\\n        Map<Integer,Integer> gcdEndingAtPrev = new HashMap<>(); //Stores all gcds ending at arr[i-1] with their frequncies\\n        if(arr[0] == k) cnt++; \\n        gcdEndingAtPrev.put(arr[0],1);\\n        for(int i=1;i<arr.length;i++){\\n            HashMap<Integer,Integer> nf = new HashMap<>(); //Stores all gcds ending at arr[i]. This will become map for arr[i-1] on the next step\\n            int cur = arr[i]; \\n            gcdEndingAtPrev.put(cur,gcdEndingAtPrev.getOrDefault(cur,0)+1); //Important step. look below for explaination\\n            for(int key: gcdEndingAtPrev.keySet()){ //Iterate all prevoius gcds\\n                int cur_gcd = getGcd(key,cur);  //Calculate gcd ending arr[i]\\n                int f = gcdEndingAtPrev.get(key);  //Freq of new gcd is same as freq of previous gcd. If can\\'t visualize this try a dry run with a sample array\\n                if(cur_gcd == k) cnt = cnt+f;\\n                nf.put(cur_gcd,nf.getOrDefault(cur_gcd,0)+f);\\n            }\\n            gcdEndingAtPrev = nf;\\n        }\\n        return cnt;\\n    }\\n    private static int getGcd(int a, int b){\\n        if(a%b == 0) return b;\\n        return getGcd(b,a%b);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2734230,
                "title": "python-solution-with-comments-easy-understanding",
                "content": "```\\nclass Solution:\\n    def subarrayGCD(self, nums: List[int], k: int) -> int:\\n        \\n        # iterative function for finding gcd\\n        def gcd(a, b):\\n            while a and b:\\n                a, b = b, a % b\\n            return a or b\\n\\t\\t\\t# Time complexity - O(log(min(a, b)) = O(log n)\\n\\n        \\n        cnt = 0\\n        n = len(nums)\\n        \\n        for i in range(n):\\n            tmp_gcd = 0 # gcd of zero with any number is equal to the number itself\\n            \\n            for j in range(i,n):\\n                tmp_gcd = gcd(tmp_gcd, nums[j])\\n                \\n                \\n\\n                if tmp_gcd == k:\\n                    cnt += 1\\n                elif tmp_gcd < k: # gcd cannot get bigger\\n                    break\\n        \\n        return cnt\\n        \\n        # n = nums.length\\n        # m = max(nums[i])\\n\\n        # O( n^2 * log(m) ) - Time\\n        # O(1) - Space\\n  \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def subarrayGCD(self, nums: List[int], k: int) -> int:\\n        \\n        # iterative function for finding gcd\\n        def gcd(a, b):\\n            while a and b:\\n                a, b = b, a % b\\n            return a or b\\n\\t\\t\\t# Time complexity - O(log(min(a, b)) = O(log n)\\n\\n        \\n        cnt = 0\\n        n = len(nums)\\n        \\n        for i in range(n):\\n            tmp_gcd = 0 # gcd of zero with any number is equal to the number itself\\n            \\n            for j in range(i,n):\\n                tmp_gcd = gcd(tmp_gcd, nums[j])\\n                \\n                \\n\\n                if tmp_gcd == k:\\n                    cnt += 1\\n                elif tmp_gcd < k: # gcd cannot get bigger\\n                    break\\n        \\n        return cnt\\n        \\n        # n = nums.length\\n        # m = max(nums[i])\\n\\n        # O( n^2 * log(m) ) - Time\\n        # O(1) - Space\\n  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2734313,
                "title": "java-100-fastest-o-n2log-n-tc-o-1-sc-easy-brute-force",
                "content": "```\\nclass Solution {\\n    private int gcd(int a, int b) {\\n        if (b == 0)\\n            return a;\\n        return gcd(b, a % b);\\n    }\\n\\n    public int subarrayGCD(int[] nums, int k) {\\n        int ans = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            int currGcd = nums[i];\\n            if(currGcd == k) // if element is equal to k, increment answer\\n                ans++;\\n            for (int j = i + 1; j < nums.length; j++) {\\n                if(nums[j] < k) // if nums[j] < k gcd can never be equal to k for this subarray\\n                    break;\\n                currGcd = gcd(nums[j], currGcd);\\n                if (currGcd == k)\\n                    ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private int gcd(int a, int b) {\\n        if (b == 0)\\n            return a;\\n        return gcd(b, a % b);\\n    }\\n\\n    public int subarrayGCD(int[] nums, int k) {\\n        int ans = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            int currGcd = nums[i];\\n            if(currGcd == k) // if element is equal to k, increment answer\\n                ans++;\\n            for (int j = i + 1; j < nums.length; j++) {\\n                if(nums[j] < k) // if nums[j] < k gcd can never be equal to k for this subarray\\n                    break;\\n                currGcd = gcd(nums[j], currGcd);\\n                if (currGcd == k)\\n                    ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2734153,
                "title": "python-rust-c-fastest-0-ms-brute-force-with-detailed-comments",
                "content": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\nThis solution employs a sliding window approach to scan for subarrays. Time complexity is quadratic: **O(n\\\\*n)**. Space complexity is constant: **O(1)**. \\n\\n| Language | Runtime | Memory |\\n|---|---|---|\\n| [**Python**](https://leetcode.com/contest/weekly-contest-316/submissions/detail/828360641/) | **179 ms (100.00%)** | **14.0 MB  (100.00%)** |\\n| [**Rust**](https://leetcode.com/submissions/detail/828388585/) | **0 ms (100.00%)** | **2.1 MB (100.00%)** |\\n| [**C++**](https://leetcode.com/submissions/detail/828390990/) | **7 ms (100.00%)** | **8.9 MB  (100.00%)** |\\n\\n<iframe src=\"https://leetcode.com/playground/W9L9smgF/shared\" frameBorder=\"0\" width=\"800\" height=\"500\"></iframe>",
                "solutionTags": [
                    "Python",
                    "C",
                    "Rust"
                ],
                "code": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\nThis solution employs a sliding window approach to scan for subarrays. Time complexity is quadratic: **O(n\\\\*n)**. Space complexity is constant: **O(1)**. \\n\\n| Language | Runtime | Memory |\\n|---|---|---|\\n| [**Python**](https://leetcode.com/contest/weekly-contest-316/submissions/detail/828360641/) | **179 ms (100.00%)** | **14.0 MB  (100.00%)** |\\n| [**Rust**](https://leetcode.com/submissions/detail/828388585/) | **0 ms (100.00%)** | **2.1 MB (100.00%)** |\\n| [**C++**](https://leetcode.com/submissions/detail/828390990/) | **7 ms (100.00%)** | **8.9 MB  (100.00%)** |\\n\\n<iframe src=\"https://leetcode.com/playground/W9L9smgF/shared\" frameBorder=\"0\" width=\"800\" height=\"500\"></iframe>",
                "codeTag": "Unknown"
            },
            {
                "id": 2734301,
                "title": "c-python-java-easy-brute-force-solution",
                "content": "The gcd of an n elements is the gcd of nth element and gcd of n - 1 elements \\n\\nwe will use this idea to find the gcd of all subarrays \\n\\nwhenever we get a subarray with k as gcd increment counter\\n#### C++ solution with comments\\n```c++\\n\\nclass Solution\\n{\\npublic:\\n    int gcd(int a, int b)\\n    {\\n        if (b == 0)\\n            return a;\\n        return gcd(b, a % b);\\n    }\\n    int subarrayGCD(vector<int> &nums, int k)\\n    {\\n        int count = 0, i = 0, curr_gcd;\\n\\t\\t// consider every element as a starting point \\n        for (int i = 0; i < nums.size(); i++)\\n        {\\n\\t\\t\\t// since gcd of nums[i] is nums[i] itself we initialize curr_gcd with 0 \\n            curr_gcd = 0;\\n\\t\\t\\t// from the given point try all the subarrays \\n            for (int j = i; j < nums.size(); j++)\\n            {\\n\\t\\t\\t\\t// keep updating the curr_gcd\\n                curr_gcd = gcd(curr_gcd, nums[j]);\\n\\t\\t\\t\\t// if equal to k increment\\n                count += (curr_gcd == k);\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\\n`Time complexity :- O(n2)`\\n\\n#### Python \\n\\n```python\\nclass Solution:\\n    def gcd(self, a, b):\\n        if b == 0:\\n            return a\\n        return self.gcd(b , a % b)\\n    def subarrayGCD(self, nums: List[int], k: int) -> int:\\n        count = 0\\n        for i in range(len(nums)):\\n            present_gcd = 0\\n            for j in range(i , len(nums)):\\n                present_gcd = gcd(present_gcd, nums[j])\\n                if present_gcd == k:\\n                    count += 1\\n                    \\n        return count\\n```\\n\\n\\n#### Java\\n```Java\\nclass Solution {\\n    private int gcd(int a , int b){\\n        if(b == 0) return a;\\n        return gcd(b , a % b);\\n    }\\n    public int subarrayGCD(int[] nums, int k) {\\n        int count = 0;\\n        for(int i = 0 ; i < nums.length; i++){\\n            int current_gcd = 0;\\n            for(int j = i; j < nums.length ;j++){\\n                current_gcd = gcd(current_gcd , nums[j]);\\n                if(current_gcd == k) count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```c++\\n\\nclass Solution\\n{\\npublic:\\n    int gcd(int a, int b)\\n    {\\n        if (b == 0)\\n            return a;\\n        return gcd(b, a % b);\\n    }\\n    int subarrayGCD(vector<int> &nums, int k)\\n    {\\n        int count = 0, i = 0, curr_gcd;\\n\\t\\t// consider every element as a starting point \\n        for (int i = 0; i < nums.size(); i++)\\n        {\\n\\t\\t\\t// since gcd of nums[i] is nums[i] itself we initialize curr_gcd with 0 \\n            curr_gcd = 0;\\n\\t\\t\\t// from the given point try all the subarrays \\n            for (int j = i; j < nums.size(); j++)\\n            {\\n\\t\\t\\t\\t// keep updating the curr_gcd\\n                curr_gcd = gcd(curr_gcd, nums[j]);\\n\\t\\t\\t\\t// if equal to k increment\\n                count += (curr_gcd == k);\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def gcd(self, a, b):\\n        if b == 0:\\n            return a\\n        return self.gcd(b , a % b)\\n    def subarrayGCD(self, nums: List[int], k: int) -> int:\\n        count = 0\\n        for i in range(len(nums)):\\n            present_gcd = 0\\n            for j in range(i , len(nums)):\\n                present_gcd = gcd(present_gcd, nums[j])\\n                if present_gcd == k:\\n                    count += 1\\n                    \\n        return count\\n```\n```Java\\nclass Solution {\\n    private int gcd(int a , int b){\\n        if(b == 0) return a;\\n        return gcd(b , a % b);\\n    }\\n    public int subarrayGCD(int[] nums, int k) {\\n        int count = 0;\\n        for(int i = 0 ; i < nums.length; i++){\\n            int current_gcd = 0;\\n            for(int j = i; j < nums.length ;j++){\\n                current_gcd = gcd(current_gcd , nums[j]);\\n                if(current_gcd == k) count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2736792,
                "title": "python-3-8-lines-w-example-t-m-155-ms-14-9-mb",
                "content": "```\\nclass Solution:\\n    def subarrayGCD(self, nums: List[int], k: int) -> int:\\n                                        \\n        ans = 0                             #   Ex: nums = [9,3,1,3]\\n                                            #\\n        for i, num in enumerate(nums):      #   num  next   G   ans\\n            G = num                         #   \\u2013\\u2013\\u2013  \\u2013\\u2013\\u2013\\u2013  \\u2013\\u2013\\u2013  \\u2013\\u2013\\u2013 \\n                                            #    9     9    9    0\\n            for next in nums[i:]:           #    9     3    3    1\\n                                            #    9     1    1    1\\n                G = gcd(G,next)             #    3     3    3    2\\n                ans+= (G == k)              #    3     1    1    2\\n                if G < k: break             #    1     1    1    2\\n                                            #    3     3    3    3  <-- answer\\n        return ans\\n```\\n[https://leetcode.com/submissions/detail/828790730/](http://)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def subarrayGCD(self, nums: List[int], k: int) -> int:\\n                                        \\n        ans = 0                             #   Ex: nums = [9,3,1,3]\\n                                            #\\n        for i, num in enumerate(nums):      #   num  next   G   ans\\n            G = num                         #   \\u2013\\u2013\\u2013  \\u2013\\u2013\\u2013\\u2013  \\u2013\\u2013\\u2013  \\u2013\\u2013\\u2013 \\n                                            #    9     9    9    0\\n            for next in nums[i:]:           #    9     3    3    1\\n                                            #    9     1    1    1\\n                G = gcd(G,next)             #    3     3    3    2\\n                ans+= (G == k)              #    3     1    1    2\\n                if G < k: break             #    1     1    1    2\\n                                            #    3     3    3    3  <-- answer\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2736533,
                "title": "my-clean-java-solution",
                "content": "### **Please Upvote** :D\\n```\\nclass Solution {\\n    public int subarrayGCD(int[] nums, int k) {\\n        int n = nums.length;\\n        int ans = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            int currGCD = nums[i];\\n\\n            for (int j = i; j < n; j++) {\\n                currGCD = gcd(currGCD, nums[j]);\\n                ans += (currGCD == k) ? 1 : 0;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n\\n    public int gcd(int a, int b) {\\n        return (b == 0) ? a : gcd(b, a % b);\\n    }\\n}\\n\\n// TC: O(n ^ 2)\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int subarrayGCD(int[] nums, int k) {\\n        int n = nums.length;\\n        int ans = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            int currGCD = nums[i];\\n\\n            for (int j = i; j < n; j++) {\\n                currGCD = gcd(currGCD, nums[j]);\\n                ans += (currGCD == k) ? 1 : 0;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n\\n    public int gcd(int a, int b) {\\n        return (b == 0) ? a : gcd(b, a % b);\\n    }\\n}\\n\\n// TC: O(n ^ 2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2739522,
                "title": "segment-tree-binary-search-o-n-log-2-n-time-complexity",
                "content": "For each subarray starting from index `i`, we want to know the first index `idx1` where `gcd(nums[i: idx1])` is equal to k (both inclusive).\\nAnd if such an idx1 exists, we\\'re going to find the closest index `idx2`, where `gcd(nums[i: idx2])` is **less than** k.\\nEvery subarray in between `nums[i: idx1]` and `nums[i: idx2-1]` has the GCD equals to k, so we can just add `idx2 - idx1` to result.\\n\\nWith the **associative** property of GCD, we can build a **segment tree** to speed up the calculation of ranged GCD operation.\\n\\n```\\nfunc subarrayGCD(nums []int, k int) int {\\n    n := len(nums)\\n    \\n    tree := initSegmentTree(n)\\n    for i := 0 ; i < n ; i++ {\\n        tree.Update(i, nums[i])\\n    }\\n    \\n    res := 0\\n    \\n    for i := 0 ; i < n ; i++ {\\n        idx1 := sort.Search(n-i, func(x int) bool {\\n            return tree.GcdRange(i, i+x) <= k\\n        })\\n        \\n        if idx1 < n - i && tree.GcdRange(i, i + idx1) == k {\\n            idx2 := sort.Search(n-i, func(x int) bool {\\n                return tree.GcdRange(i, i+x) < k\\n            })\\n            \\n            res += idx2 - idx1\\n        }\\n    }\\n    \\n    return res\\n}\\n\\nfunc gcd(a, b int) int {\\n    if b == 0 {\\n        return a\\n    }\\n    \\n    return gcd(b, a % b)\\n}\\n\\ntype SegmentTree struct {\\n    size  int\\n    nums  []int\\n}\\n\\nfunc initSegmentTree(size int) *SegmentTree {\\n    return &SegmentTree{\\n        size:  size,\\n        nums:  make([]int, size*2),\\n    }\\n}\\n\\nfunc (this *SegmentTree) Update(idx int, val int) {\\n    idx += this.size\\n    this.nums[idx] = val\\n    for i := idx; i > 1; i >>= 1 {\\n        this.nums[i>>1] = gcd(this.nums[i], this.nums[i^1])\\n    }\\n}\\n\\nfunc (this *SegmentTree) GcdRange(l, r int) int {\\n    res := -1\\n    l += this.size\\n    r += this.size\\n\\n    for l <= r {\\n        if l&1 > 0 {\\n            if res == -1 {\\n                res = this.nums[l]\\n            } else {\\n                res = gcd(res, this.nums[l])\\n            }\\n            l++\\n        }\\n        if r&1 == 0 {\\n            if res == -1 {\\n                res = this.nums[r]\\n            } else {\\n                res = gcd(res, this.nums[r])\\n            }\\n            r--\\n        }\\n        l >>= 1\\n        r >>= 1\\n    }\\n    return res\\n}\\n```\\n\\n**Time Complexity**\\nWe have to iterate through the array once, and we\\'re doing binary search on range operation of a segment tree. The time complexity is going to be O(N * log(N) * log(N))\\n\\n**Space Complexity**\\nSegment tree need 2 * N space, so the memory complexity is O(N)",
                "solutionTags": [
                    "Go",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\nfunc subarrayGCD(nums []int, k int) int {\\n    n := len(nums)\\n    \\n    tree := initSegmentTree(n)\\n    for i := 0 ; i < n ; i++ {\\n        tree.Update(i, nums[i])\\n    }\\n    \\n    res := 0\\n    \\n    for i := 0 ; i < n ; i++ {\\n        idx1 := sort.Search(n-i, func(x int) bool {\\n            return tree.GcdRange(i, i+x) <= k\\n        })\\n        \\n        if idx1 < n - i && tree.GcdRange(i, i + idx1) == k {\\n            idx2 := sort.Search(n-i, func(x int) bool {\\n                return tree.GcdRange(i, i+x) < k\\n            })\\n            \\n            res += idx2 - idx1\\n        }\\n    }\\n    \\n    return res\\n}\\n\\nfunc gcd(a, b int) int {\\n    if b == 0 {\\n        return a\\n    }\\n    \\n    return gcd(b, a % b)\\n}\\n\\ntype SegmentTree struct {\\n    size  int\\n    nums  []int\\n}\\n\\nfunc initSegmentTree(size int) *SegmentTree {\\n    return &SegmentTree{\\n        size:  size,\\n        nums:  make([]int, size*2),\\n    }\\n}\\n\\nfunc (this *SegmentTree) Update(idx int, val int) {\\n    idx += this.size\\n    this.nums[idx] = val\\n    for i := idx; i > 1; i >>= 1 {\\n        this.nums[i>>1] = gcd(this.nums[i], this.nums[i^1])\\n    }\\n}\\n\\nfunc (this *SegmentTree) GcdRange(l, r int) int {\\n    res := -1\\n    l += this.size\\n    r += this.size\\n\\n    for l <= r {\\n        if l&1 > 0 {\\n            if res == -1 {\\n                res = this.nums[l]\\n            } else {\\n                res = gcd(res, this.nums[l])\\n            }\\n            l++\\n        }\\n        if r&1 == 0 {\\n            if res == -1 {\\n                res = this.nums[r]\\n            } else {\\n                res = gcd(res, this.nums[r])\\n            }\\n            r--\\n        }\\n        l >>= 1\\n        r >>= 1\\n    }\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2734346,
                "title": "c-easy-to-understand-bruteforce-sliding-window",
                "content": "**Brute Force**\\n```\\npublic:\\n    int subarrayGCD(vector<int>& nums, int k) {\\n        int ans = 0; \\n        for(int i = 0; i < nums.size(); i++)\\n        {\\n            int curr = 0;\\n            for(int j = i; j < nums.size(); j++)\\n            {\\n                curr = __gcd(curr , nums[j]);\\n                if(curr == k)\\n                {\\n                    ans++;\\n                }\\n            }\\n          \\n        }\\n        return\\xA0ans;\\n\\xA0\\xA0\\xA0\\xA0}\\n};\\n```\\n**Sliding Window**\\n```\\nclass Solution {\\npublic:\\n    int subarrayGCD(vector<int>& nums, int k) {\\n        int ans = 0;\\n        int i = 0 , j = 0;\\n        int div = nums[0];\\n\\n        while(j < nums.size())\\n        {\\n            div = __gcd(nums[j] , nums[j++]);\\n                if(div == k)ans++;\\n            while(j < nums.size() && div >= k)\\n            {\\n                div = __gcd(div , nums[j++]);\\n                if(div == k)ans++;\\n            }\\n            i++;\\n            j=i;\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\npublic:\\n    int subarrayGCD(vector<int>& nums, int k) {\\n        int ans = 0; \\n        for(int i = 0; i < nums.size(); i++)\\n        {\\n            int curr = 0;\\n            for(int j = i; j < nums.size(); j++)\\n            {\\n                curr = __gcd(curr , nums[j]);\\n                if(curr == k)\\n                {\\n                    ans++;\\n                }\\n            }\\n          \\n        }\\n        return\\xA0ans;\\n\\xA0\\xA0\\xA0\\xA0}\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int subarrayGCD(vector<int>& nums, int k) {\\n        int ans = 0;\\n        int i = 0 , j = 0;\\n        int div = nums[0];\\n\\n        while(j < nums.size())\\n        {\\n            div = __gcd(nums[j] , nums[j++]);\\n                if(div == k)ans++;\\n            while(j < nums.size() && div >= k)\\n            {\\n                div = __gcd(div , nums[j++]);\\n                if(div == k)ans++;\\n            }\\n            i++;\\n            j=i;\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2734224,
                "title": "python3-brute-force-early-stopping-clean-concise",
                "content": "**Implementation**\\nWe use a nested for-loop to record the starting index `i` and ending index `j` for the subarray. Each time, when the GCD of subarray is smaller than `k`, we exit the inner for-loop.\\n\\n**Complexity**\\nTime Complexity: `O(N^2logM)`, where `M <= 1e9` (worse case for GCD)\\nSpace Complexity: `O(1)`\\n \\n **Solution**\\n```\\nclass Solution:\\n    def subarrayGCD(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        ans = 0\\n        for i in range(n):\\n            temp = nums[i]\\n            for j in range(i, n):\\n                temp = math.gcd(temp, nums[j])\\n                if temp == k:\\n                    ans += 1\\n                elif temp < k:\\n                    break\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def subarrayGCD(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        ans = 0\\n        for i in range(n):\\n            temp = nums[i]\\n            for j in range(i, n):\\n                temp = math.gcd(temp, nums[j])\\n                if temp == k:\\n                    ans += 1\\n                elif temp < k:\\n                    break\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2734209,
                "title": "c-simple-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int subarrayGCD(vector<int>& nums, int k) {\\n           int cnt = 0;\\n        \\n           int n = nums.size();\\n        \\n        for(int i=0; i<n; i++){\\n            int c  = 0;\\n\\n            for(int j=i; j<n; j++)\\n            {\\n                c = __gcd(c, nums[j]);\\n\\n                if(c == k){\\n                    cnt++;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```\\n**Please upvote if it was helpful for you, thank you!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subarrayGCD(vector<int>& nums, int k) {\\n           int cnt = 0;\\n        \\n           int n = nums.size();\\n        \\n        for(int i=0; i<n; i++){\\n            int c  = 0;\\n\\n            for(int j=i; j<n; j++)\\n            {\\n                c = __gcd(c, nums[j]);\\n\\n                if(c == k){\\n                    cnt++;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2734163,
                "title": "c-brute-force-time-complexity-o-n-n-log-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int subarrayGCD(vector<int>& nums, int k) {\\n        int ans=0;\\n\\t\\t// check for all size 1 subarray\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==k) ans++;\\n        }\\n\\t\\t// check for greater then 1 size subarray\\n        for(int i=0;i<nums.size();i++){\\n            bool flg = false;\\n            int gcd = nums[i];\\n            for(int j=i+1;j<nums.size();j++){\\n                if(nums[j]%k!=0) break;\\n                gcd = __gcd(gcd,nums[j]);\\n                if(gcd==k) flg = true;\\n                if(flg) ans+=1;\\n                // cout<<nums[i]<<\" \";\\n            }\\n            // cout<<\"\\\\n\";\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subarrayGCD(vector<int>& nums, int k) {\\n        int ans=0;\\n\\t\\t// check for all size 1 subarray\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==k) ans++;\\n        }\\n\\t\\t// check for greater then 1 size subarray\\n        for(int i=0;i<nums.size();i++){\\n            bool flg = false;\\n            int gcd = nums[i];\\n            for(int j=i+1;j<nums.size();j++){\\n                if(nums[j]%k!=0) break;\\n                gcd = __gcd(gcd,nums[j]);\\n                if(gcd==k) flg = true;\\n                if(flg) ans+=1;\\n                // cout<<nums[i]<<\" \";\\n            }\\n            // cout<<\"\\\\n\";\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3415884,
                "title": "95-faster-brute-force-c-easy-to-understnad",
                "content": "````\\nclass Solution {\\npublic:\\n    int subarrayGCD(vector<int>& nums, int k) {\\n        int ans = 0,i,j,n=nums.size(),g = 0;\\n        for(i = 0; i < n; i++){\\n            g = nums[i];\\n            for(j = i; j < n; j++){\\n                g = __gcd(g,nums[j]);//take gcd all number from i...to...j\\n                if(g==k)ans++;//if gcd == k than increment ans by one\\n                else if(g<k)break;//if gcd < k than break subarray\\'s loop because we cann\\'t find a subarray which gcd == k\\n            }\\n        }\\n        return ans;//return no of possible answers\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "````\\nclass Solution {\\npublic:\\n    int subarrayGCD(vector<int>& nums, int k) {\\n        int ans = 0,i,j,n=nums.size(),g = 0;\\n        for(i = 0; i < n; i++){\\n            g = nums[i];\\n            for(j = i; j < n; j++){\\n                g = __gcd(g,nums[j]);//take gcd all number from i...to...j\\n                if(g==k)ans++;//if gcd == k than increment ans by one\\n                else if(g<k)break;//if gcd < k than break subarray\\'s loop because we cann\\'t find a subarray which gcd == k\\n            }\\n        }\\n        return ans;//return no of possible answers\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2736992,
                "title": "easy-best-solution-in-c-bruteforce",
                "content": "# Complexity\\n- Time complexity:\\nO(logm * n^2)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n**Please Upvote if u liked my Solution**\\uD83D\\uDE42\\n```\\nclass Solution {\\npublic:\\n    int subarrayGCD(vector<int>& nums, int k) {\\n        int size=nums.size(),count=0;\\n        for(int i=0;i<size;i++){\\n            int GCD=nums[i];\\n            for(int j=i;j<size;j++){\\n                GCD=__gcd(GCD,nums[j]);\\n                if(GCD==k)\\n                    count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subarrayGCD(vector<int>& nums, int k) {\\n        int size=nums.size(),count=0;\\n        for(int i=0;i<size;i++){\\n            int GCD=nums[i];\\n            for(int j=i;j<size;j++){\\n                GCD=__gcd(GCD,nums[j]);\\n                if(GCD==k)\\n                    count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2735365,
                "title": "javascript-brute-force-clean-solution",
                "content": "**Solution: Brute Force**\\n\\nTo get the GCD of an array of elements, keep the running GCD starting from `arr[0]`.\\n  For each `arr[i]`, `gcd = getGCD(gcd, arr[i])`.\\n\\nTake each `nums[i]` as the start of a subarray.\\n  Keep the running GCD from index `i`.\\n  Go through each index `j` as the end of the subarray.\\n\\nTime Complexity: `O(n^2 * log(n))` 123ms\\nSpace Complexity: `O(1)` 41.6MB\\n```\\nvar subarrayGCD = function(nums, k) {\\n  let n = nums.length, ans = 0;\\n  for (let i = 0; i < n; i++) {\\n    let gcd = nums[i];\\n    for (let j = i; j < n; j++) {\\n      gcd = getGCD(gcd, nums[j]);\\n      if (gcd === k) ans++;\\n    }\\n  }\\n  return ans;  \\n};\\n\\nfunction getGCD(a, b) {\\n  if (b === 0) return a;\\n  return getGCD(b, a % b);\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar subarrayGCD = function(nums, k) {\\n  let n = nums.length, ans = 0;\\n  for (let i = 0; i < n; i++) {\\n    let gcd = nums[i];\\n    for (let j = i; j < n; j++) {\\n      gcd = getGCD(gcd, nums[j]);\\n      if (gcd === k) ans++;\\n    }\\n  }\\n  return ans;  \\n};\\n\\nfunction getGCD(a, b) {\\n  if (b === 0) return a;\\n  return getGCD(b, a % b);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2734444,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    int subarrayGCD(vector<int>& nums, int k) \\n    {   \\n        int n=nums.size(), ans=0, gcd=0;\\n        for(int i=0; i<n; i++)\\n        {\\n            gcd = nums[i];\\n            for(int j=i; j<n; j++)\\n            {\\n                if(nums[j]%k!=0) break;\\n                gcd = __gcd(gcd, nums[j]);\\n                if(gcd==k) ans++;\\n            }\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int subarrayGCD(vector<int>& nums, int k) \\n    {   \\n        int n=nums.size(), ans=0, gcd=0;\\n        for(int i=0; i<n; i++)\\n        {\\n            gcd = nums[i];\\n            for(int j=i; j<n; j++)\\n            {\\n                if(nums[j]%k!=0) break;\\n                gcd = __gcd(gcd, nums[j]);\\n                if(gcd==k) ans++;\\n            }\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2734417,
                "title": "python-brute-force-solution-clean-concise",
                "content": "```\\nclass Solution:\\n    def subarrayGCD(self, nums: List[int], t: int) -> int:\\n        ans=0\\n        for i, el in enumerate(nums): #iterate through all elements\\n            g=0 #gcd of 0 and a is a\\n            for j in nums[i:]:\\n                g=gcd(g, j) #update gcd\\n                if g==t:\\n                    ans+=1 #increment count if target found\\n                if g<t:\\n                    break #it is impossible to get the target, because gcd of two number is atmost the smaller one\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def subarrayGCD(self, nums: List[int], t: int) -> int:\\n        ans=0\\n        for i, el in enumerate(nums): #iterate through all elements\\n            g=0 #gcd of 0 and a is a\\n            for j in nums[i:]:\\n                g=gcd(g, j) #update gcd\\n                if g==t:\\n                    ans+=1 #increment count if target found\\n                if g<t:\\n                    break #it is impossible to get the target, because gcd of two number is atmost the smaller one\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2734196,
                "title": "easiest-solution-of-c-for-beginner",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    For every index i, keep iterating forward and compute the GCD \\n    from index i to j and check if it\\u2019s equal to k.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N^2log(max(nums[])) )  \\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int subarrayGCD(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        int ans=0;\\n        for (int i = 0; i < n; i++) {\\n            int curr_gcd = 0;\\n            for (int j = i; j < n; j++) {\\n                curr_gcd = __gcd(curr_gcd, nums[j]);\\n                ans += (curr_gcd == k);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subarrayGCD(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        int ans=0;\\n        for (int i = 0; i < n; i++) {\\n            int curr_gcd = 0;\\n            for (int j = i; j < n; j++) {\\n                curr_gcd = __gcd(curr_gcd, nums[j]);\\n                ans += (curr_gcd == k);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2734112,
                "title": "simple-clean-code",
                "content": "```\\nclass Solution {\\ntypedef int ll;\\n#define vi(x) vector<x>\\npublic:\\n    vi(ll)st; // Segment Tree\\n    ll n; // num of nodes/items\\n    ll findGcd(ll ss, ll se, ll qs, ll qe, ll si){\\n        if (ss > qe || se < qs){\\n            return 0;\\n        }\\n        if (qs <= ss && qe >= se){\\n            return st[si];\\n        }\\n        ll m = ss + ((se - ss)>>1);\\n        return __gcd(findGcd(ss, m, qs, qe, si * 2 + 1), findGcd(m + 1, se, qs, qe, si * 2 + 2));\\n    }\\n\\n    ll constructST(const vi(ll)&v, ll ss, ll se, ll si){\\n        if (ss == se) {\\n            return (st[si] = v[ss]);\\n        }\\n        ll m = ss + ((se - ss)>>1);\\n        return (st[si] = __gcd(constructST(v, ss, m, si * 2 + 1), constructST(v, m + 1, se, si * 2 + 2)));\\n    }\\n\\n    int subarrayGCD(vector<int>&v, int k) {\\n        n=v.size();\\n        ll height = ceil(log2(n));\\n        st.resize(2 * (1LL<<height) - 1);\\n        constructST(v, 0, n - 1, 0);\\n        ll ans=0;\\n        for(ll i=0;i<n;++i){\\n            for(ll j=i;j<n;++j){\\n                ans+=findGcd(0, n - 1, i, j, 0)==k;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\ntypedef int ll;\\n#define vi(x) vector<x>\\npublic:\\n    vi(ll)st; // Segment Tree\\n    ll n; // num of nodes/items\\n    ll findGcd(ll ss, ll se, ll qs, ll qe, ll si){\\n        if (ss > qe || se < qs){\\n            return 0;\\n        }\\n        if (qs <= ss && qe >= se){\\n            return st[si];\\n        }\\n        ll m = ss + ((se - ss)>>1);\\n        return __gcd(findGcd(ss, m, qs, qe, si * 2 + 1), findGcd(m + 1, se, qs, qe, si * 2 + 2));\\n    }\\n\\n    ll constructST(const vi(ll)&v, ll ss, ll se, ll si){\\n        if (ss == se) {\\n            return (st[si] = v[ss]);\\n        }\\n        ll m = ss + ((se - ss)>>1);\\n        return (st[si] = __gcd(constructST(v, ss, m, si * 2 + 1), constructST(v, m + 1, se, si * 2 + 2)));\\n    }\\n\\n    int subarrayGCD(vector<int>&v, int k) {\\n        n=v.size();\\n        ll height = ceil(log2(n));\\n        st.resize(2 * (1LL<<height) - 1);\\n        constructST(v, 0, n - 1, 0);\\n        ll ans=0;\\n        for(ll i=0;i<n;++i){\\n            for(ll j=i;j<n;++j){\\n                ans+=findGcd(0, n - 1, i, j, 0)==k;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2734095,
                "title": "python-bruct-force",
                "content": "\\tclass Solution:\\n\\t\\tdef subarrayGCD(self, nums: List[int], k: int) -> int:\\n\\t\\t\\tres = 0\\n\\t\\t\\tfor i in range(len(nums)):\\n\\t\\t\\t\\tif nums[i] % k == 0:\\n\\t\\t\\t\\t\\tfor j in range(i + 1, len(nums) + 1):\\n\\t\\t\\t\\t\\t\\tif math.gcd(*nums[i:j]) == k:\\n\\t\\t\\t\\t\\t\\t\\tres += 1\\n\\t\\t\\treturn res",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef subarrayGCD(self, nums: List[int], k: int) -> int:\\n\\t\\t\\tres = 0\\n\\t\\t\\tfor i in range(len(nums)):\\n\\t\\t\\t\\tif nums[i] % k == 0:\\n\\t\\t\\t\\t\\tfor j in range(i + 1, len(nums) + 1):\\n\\t\\t\\t\\t\\t\\tif math.gcd(*nums[i:j]) == k:\\n\\t\\t\\t\\t\\t\\t\\tres += 1\\n\\t\\t\\treturn res",
                "codeTag": "Java"
            },
            {
                "id": 3922558,
                "title": "easy-c-and-javascript-solution",
                "content": "# Approach\\nJust check how many subarrays have a GCD equal to a specific value k in a list of numbers. It does this by checking each element with the ones that come after it and counting the valid cases\\n\\n# Complexity\\n- Time complexity: O(n^2 * log(max(nums)))\\n\\n- Space complexity: O(1)\\n\\n# Code\\n# C++\\n```\\nclass Solution {\\npublic:\\n    int GCD(int A, int B) {\\n        if(B==0) return A;\\n        return GCD(B, A%B);\\n    }\\n    int subarrayGCD(vector<int>& nums, int k) {\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==k) ans++;\\n            int gcd=nums[i];\\n            for(int j=i+1;j<nums.size();j++){\\n                int res=GCD(gcd,nums[j]);\\n                if(res==k) ans++;\\n                gcd=res;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n---\\n\\n# JavaScript\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar subarrayGCD = function(nums, k) {\\n    const GCD=( A, B)=>{\\n        if(B==0) return A;\\n        return GCD(B, A%B);\\n    }\\n   \\n    let ans=0;\\n    for(let i=0;i<nums.length;i++){\\n        if(nums[i]==k) ans++;\\n        let gcd=nums[i];\\n        for(let j=i+1;j<nums.length;j++){\\n            let res=GCD(gcd,nums[j]);\\n            if(res==k) ans++;\\n            gcd=res;\\n        }\\n    }\\n    return ans;\\n   \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "JavaScript",
                    "Array",
                    "Math",
                    "Number Theory"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int GCD(int A, int B) {\\n        if(B==0) return A;\\n        return GCD(B, A%B);\\n    }\\n    int subarrayGCD(vector<int>& nums, int k) {\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==k) ans++;\\n            int gcd=nums[i];\\n            for(int j=i+1;j<nums.size();j++){\\n                int res=GCD(gcd,nums[j]);\\n                if(res==k) ans++;\\n                gcd=res;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar subarrayGCD = function(nums, k) {\\n    const GCD=( A, B)=>{\\n        if(B==0) return A;\\n        return GCD(B, A%B);\\n    }\\n   \\n    let ans=0;\\n    for(let i=0;i<nums.length;i++){\\n        if(nums[i]==k) ans++;\\n        let gcd=nums[i];\\n        for(let j=i+1;j<nums.length;j++){\\n            let res=GCD(gcd,nums[j]);\\n            if(res==k) ans++;\\n            gcd=res;\\n        }\\n    }\\n    return ans;\\n   \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3693483,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int subarrayGCD(vector<int>& nums, int k) {\\n        int count = 0;\\n        for(int i=0; i<nums.size();i++){\\n            int ans = 0;\\n            for(int j=i; j<nums.size();j++){\\n                ans = __gcd(ans,nums[j]);\\n\\n                if(ans == k){\\n                    count ++;\\n                }\\n            }\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Number Theory"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subarrayGCD(vector<int>& nums, int k) {\\n        int count = 0;\\n        for(int i=0; i<nums.size();i++){\\n            int ans = 0;\\n            for(int j=i; j<nums.size();j++){\\n                ans = __gcd(ans,nums[j]);\\n\\n                if(ans == k){\\n                    count ++;\\n                }\\n            }\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2933868,
                "title": "count-gcds-best-time-complexity-clearest-explanation",
                "content": "# Motivation\\nThis post is inspired by @votrubac and @Java_Programmer_CF, both of whom had posted solutions with a time complexity of $O(n\\\\log_2(max(nums)))$. This post covers the same approach but in a bit more detail considering that it took me a while to understand it also. Note that this is most likely beyond the scope of your typical interview; however, I find this solution interesting for one\\'s intellectual curiousity.\\n\\n**Prerequisite:** I am assuming that you are familiar with finding the GCD using Euclid\\'s algorithm and have gotten an AC with the brute-force approach.\\n\\n\\n# Approach\\nIf you are trying to pattern-match, then this approach is similar to the fundamental idea of DP. \\n\\nIn the brute-force solution, you simply iterate through every subarray, but this is costly. Ideally, we would like to cut-down any redundant work in the worst-case. The basic idea of the solution is to have a hashmap that stores the GCD of every subarray that ends at the index the index $$i-1$$ with its corresponding frequency. Since we are taking the frequencies of these GCDs, we are no longer taking $$O(n^{2})$$ to iterate through the subarrays, but rather we can get the relevant information that we need in $$O(n\\\\log_{2}(max(nums)))$$, since there are at most $$\\\\log_{2}(max(nums))$$ distinct GCDs at any given point, which is $<< n$ for sufficiently large $n$ (where $<<$ denotes \"much less than\").\\n\\n*Note:* if the use of collections.defaultdict(int) confuses you, it is simply a basic hashmap that initializes keys to 0. This way we don\\'t have to check if a key $x$ is in the hashmap or not.\\n\\nIn the code below we replace prevH with H as when we go to index $i+1$, we want to refer to the GCDs of the subarrays that end at index $i$ and no longer at index $i-1$.\\n# Code\\n```\\nclass Solution:\\n    def subarrayGCD(self, nums: List[int], k: int) -> int:\\n        \\n        # Basic GCD code.\\n        def GCD(a, b):\\n            if a < b: return GCD(b, a)\\n            if b == 0: return a \\n            if a % b == 0: return b \\n            return GCD(b, a % b)\\n\\n        # Treating nums[0] separately.\\n        res, prevH = 0, collections.defaultdict(int)\\n        if nums[0] == k: res += 1\\n        prevH[nums[0]] += 1\\n\\n        for i in range(1, len(nums)):\\n            # The gcd of nums[i] is nums[i], so we add this gcd into\\n            # prevH just to account for the edge-case where nums[i] == k\\n            H = collections.defaultdict(int)\\n            prevH[nums[i]] += 1\\n\\n            # The use of dict(prevH) is just a Python workaround\\n            # (feel free to ignore).\\n            for prev_gcd, freq in dict(prevH).items():\\n                # If we considered this subarray, what would be the gcd of the subarray?\\n                gcd = GCD(prev_gcd, nums[i])\\n\\n                if gcd == k:\\n                    # There are \\'freq\\' number of subarrays that correspond to this gcd.\\n                    res += freq\\n                H[gcd] += freq\\n            prevH = H \\n        return res\\n```\\n\\nFeel free to post below if anything confuses you :)",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def subarrayGCD(self, nums: List[int], k: int) -> int:\\n        \\n        # Basic GCD code.\\n        def GCD(a, b):\\n            if a < b: return GCD(b, a)\\n            if b == 0: return a \\n            if a % b == 0: return b \\n            return GCD(b, a % b)\\n\\n        # Treating nums[0] separately.\\n        res, prevH = 0, collections.defaultdict(int)\\n        if nums[0] == k: res += 1\\n        prevH[nums[0]] += 1\\n\\n        for i in range(1, len(nums)):\\n            # The gcd of nums[i] is nums[i], so we add this gcd into\\n            # prevH just to account for the edge-case where nums[i] == k\\n            H = collections.defaultdict(int)\\n            prevH[nums[i]] += 1\\n\\n            # The use of dict(prevH) is just a Python workaround\\n            # (feel free to ignore).\\n            for prev_gcd, freq in dict(prevH).items():\\n                # If we considered this subarray, what would be the gcd of the subarray?\\n                gcd = GCD(prev_gcd, nums[i])\\n\\n                if gcd == k:\\n                    # There are \\'freq\\' number of subarrays that correspond to this gcd.\\n                    res += freq\\n                H[gcd] += freq\\n            prevH = H \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2819517,
                "title": "c-o-n-n-log-n-easy-explanation",
                "content": "Here is the sister problem of this question which you can try after this problem.\\n[Number of Subarrays With LCM Equal to K](https://leetcode.com/problems/number-of-subarrays-with-lcm-equal-to-k/)\\n\\n```\\nclass Solution {\\npublic:\\n    int subarrayGCD(vector<int>& nums, int k) {\\n        \\n        int ans=0; // no. of subarrays\\n        int n=nums.size();  //size of the given vector\\n\\t\\t\\n\\t\\t// 2 loops to iterate over the vector\\n        for(int i=0; i<n; i++){ \\n\\t\\t\\tint gcd=nums[i];\\n\\t\\t\\tfor(int j=i; j<n; j++ ){\\n\\t\\t\\t\\t//using inbuilt fn. to find gcd\\n\\t\\t\\t\\tgcd = __gcd(gcd, nums[j]);\\n\\n\\t\\t\\t\\tif(gcd==k)   //comparison with k\\n\\t\\t\\t\\t\\tans++;     //store the subaaray count\\n\\t\\t\\t\\tif(gcd<k){    //if gcd is less than k we don\\'t have to check coz the number less than \\'k\\' would remain the minimum\\n\\t\\t\\t\\t\\t break;   // so break\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n        return ans;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subarrayGCD(vector<int>& nums, int k) {\\n        \\n        int ans=0; // no. of subarrays\\n        int n=nums.size();  //size of the given vector\\n\\t\\t\\n\\t\\t// 2 loops to iterate over the vector\\n        for(int i=0; i<n; i++){ \\n\\t\\t\\tint gcd=nums[i];\\n\\t\\t\\tfor(int j=i; j<n; j++ ){\\n\\t\\t\\t\\t//using inbuilt fn. to find gcd\\n\\t\\t\\t\\tgcd = __gcd(gcd, nums[j]);\\n\\n\\t\\t\\t\\tif(gcd==k)   //comparison with k\\n\\t\\t\\t\\t\\tans++;     //store the subaaray count\\n\\t\\t\\t\\tif(gcd<k){    //if gcd is less than k we don\\'t have to check coz the number less than \\'k\\' would remain the minimum\\n\\t\\t\\t\\t\\t break;   // so break\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n        return ans;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2812875,
                "title": "python-solution-time-o-nlog-max-o-n",
                "content": "This is a python solution of method 2 in [THIS SOLUTION](https://leetcode.com/problems/number-of-subarrays-with-gcd-equal-to-k/discuss/2734442/Brute-Force-vs.-Count-GCDs).\\n\\n```\\ndef subarrayGCD(self, nums: List[int], k: int) -> int:\\n\\tpre, ans = defaultdict(int), 0\\n\\tfor n in nums:\\n\\t\\tcur = defaultdict(int)\\n\\t\\tif n%k==0:\\n\\t\\t\\tpre[n] += 1\\n\\t\\t\\tfor x in pre:\\n\\t\\t\\t\\tcur[gcd(x, n)] += pre[x]\\n\\t\\tans += cur[k]\\n\\t\\tpre = cur\\n\\treturn ans\\n```\\n\\nWhy the time is O(N)?\\n```\\nThe number of distinct GCDs in nums would not exceed log(max(nums)).\\nThe max possible elements is 10^9, so the max size of \\'pre\\' will be log(10^9) = 30\\nSo the 2nd nested for loop will cost O(1) time.\\nAs a result, it will cost O(n) time in total.\\n```",
                "solutionTags": [],
                "code": "```\\ndef subarrayGCD(self, nums: List[int], k: int) -> int:\\n\\tpre, ans = defaultdict(int), 0\\n\\tfor n in nums:\\n\\t\\tcur = defaultdict(int)\\n\\t\\tif n%k==0:\\n\\t\\t\\tpre[n] += 1\\n\\t\\t\\tfor x in pre:\\n\\t\\t\\t\\tcur[gcd(x, n)] += pre[x]\\n\\t\\tans += cur[k]\\n\\t\\tpre = cur\\n\\treturn ans\\n```\n```\\nThe number of distinct GCDs in nums would not exceed log(max(nums)).\\nThe max possible elements is 10^9, so the max size of \\'pre\\' will be log(10^9) = 30\\nSo the 2nd nested for loop will cost O(1) time.\\nAs a result, it will cost O(n) time in total.\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2810531,
                "title": "python-brute-force-with-early-return",
                "content": "https://leetcode.com/submissions/detail/842601081/\\n\\n```\\nRuntime: 752 ms, faster than 65.33% of Python online submissions for Number of Subarrays With GCD Equal to K.\\nMemory Usage: 13.5 MB, less than 50.67% of Python online submissions for Number of Subarrays With GCD Equal to K.\\n```\\n```\\nclass Solution(object):\\n    def subarrayGCD(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        d = {}\\n        def getGCD(x, y):\\n            if x>y: x,y=y,x\\n            ## search in the dictionary first\\n            if (x,y) in d: \\n                return d[(x,y)]\\n            ## if not in the dictionary, calculate the GCD\\n            while(y):\\n                x, y = y, x%y\\n            d[(x,y)] = abs(x)\\n            return abs(x)\\n        \\n        l, result = len(nums), 0\\n        for i in range(l-1):\\n            if nums[i]==k: result += 1\\n            has_gcd = False ## whether existing a pair of nums with gcd==k in this trajectory\\n            for j in range(i, l-1):\\n                if nums[j]%k!=0: break\\n                gcd = getGCD(nums[j], nums[j+1])\\n                if gcd<k:\\n                    break\\n                elif gcd==k:\\n                    has_gcd = True\\n                    result += 1\\n                elif has_gcd:\\n                    result += 1\\n                elif i<j:\\n                    for h in range(i, j):\\n                        if getGCD(nums[h], nums[j+1])==k:\\n                            has_gcd = True\\n                            result += 1\\n                            break\\n                ## early return\\n                if j==l-2 and has_gcd==False:\\n                    return result\\n        if nums[-1]==k: result += 1 ## edge\\n        return result\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nRuntime: 752 ms, faster than 65.33% of Python online submissions for Number of Subarrays With GCD Equal to K.\\nMemory Usage: 13.5 MB, less than 50.67% of Python online submissions for Number of Subarrays With GCD Equal to K.\\n```\n```\\nclass Solution(object):\\n    def subarrayGCD(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        d = {}\\n        def getGCD(x, y):\\n            if x>y: x,y=y,x\\n            ## search in the dictionary first\\n            if (x,y) in d: \\n                return d[(x,y)]\\n            ## if not in the dictionary, calculate the GCD\\n            while(y):\\n                x, y = y, x%y\\n            d[(x,y)] = abs(x)\\n            return abs(x)\\n        \\n        l, result = len(nums), 0\\n        for i in range(l-1):\\n            if nums[i]==k: result += 1\\n            has_gcd = False ## whether existing a pair of nums with gcd==k in this trajectory\\n            for j in range(i, l-1):\\n                if nums[j]%k!=0: break\\n                gcd = getGCD(nums[j], nums[j+1])\\n                if gcd<k:\\n                    break\\n                elif gcd==k:\\n                    has_gcd = True\\n                    result += 1\\n                elif has_gcd:\\n                    result += 1\\n                elif i<j:\\n                    for h in range(i, j):\\n                        if getGCD(nums[h], nums[j+1])==k:\\n                            has_gcd = True\\n                            result += 1\\n                            break\\n                ## early return\\n                if j==l-2 and has_gcd==False:\\n                    return result\\n        if nums[-1]==k: result += 1 ## edge\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2800685,
                "title": "python-brute-force-with-early-break",
                "content": "https://leetcode.com/submissions/detail/840697361/  \\nRuntime: 436 ms, faster than 79.86% of Python online submissions for Number of Subarrays With GCD Equal to K.  \\nMemory Usage: 13.4 MB, less than 93.75% of Python online submissions for Number of Subarrays With GCD Equal to K.  \\n\\n```\\nclass Solution(object):\\n    def subarrayGCD(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        d = {}\\n        def getGCD(x, y):\\n            if x>y: x,y=y,x\\n            if (x,y) in d: # search in the dictionary first\\n                return d[(x,y)]\\n            # if not in the dictionary, calculate the GCD\\n            while(y):\\n                x, y = y, x%y\\n            d[(x,y)] = abs(x)\\n            return abs(x)\\n        \\n        l, result = len(nums), 0\\n        for i in range(l-1):\\n            if nums[i]==k: result += 1\\n            has_gcd = False # whether existing a pair of nums with gcd==k in this trajectory\\n            for j in range(i, l-1):\\n                if nums[j]%k!=0: break\\n                gcd = getGCD(nums[j], nums[j+1])\\n                if gcd<k:\\n                    break\\n                elif gcd==k:\\n                    has_gcd = True\\n                    result += 1\\n                elif has_gcd:\\n                    result += 1\\n                elif i<j:\\n                    for h in range(i, j):\\n                        if getGCD(nums[h], nums[j+1])==k:\\n                            has_gcd = True\\n                            result += 1\\n                            break\\n        if nums[-1]==k: result += 1 # edge\\n        return result\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def subarrayGCD(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        d = {}\\n        def getGCD(x, y):\\n            if x>y: x,y=y,x\\n            if (x,y) in d: # search in the dictionary first\\n                return d[(x,y)]\\n            # if not in the dictionary, calculate the GCD\\n            while(y):\\n                x, y = y, x%y\\n            d[(x,y)] = abs(x)\\n            return abs(x)\\n        \\n        l, result = len(nums), 0\\n        for i in range(l-1):\\n            if nums[i]==k: result += 1\\n            has_gcd = False # whether existing a pair of nums with gcd==k in this trajectory\\n            for j in range(i, l-1):\\n                if nums[j]%k!=0: break\\n                gcd = getGCD(nums[j], nums[j+1])\\n                if gcd<k:\\n                    break\\n                elif gcd==k:\\n                    has_gcd = True\\n                    result += 1\\n                elif has_gcd:\\n                    result += 1\\n                elif i<j:\\n                    for h in range(i, j):\\n                        if getGCD(nums[h], nums[j+1])==k:\\n                            has_gcd = True\\n                            result += 1\\n                            break\\n        if nums[-1]==k: result += 1 # edge\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2737143,
                "title": "detailed-solution-100-faster-100-less-memory-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int subarrayGCD(vector<int>& nums, int k) {\\n        \\n        int result = 0; // We may not have any subarray.\\n        \\n        int n = nums.size();\\n        \\n        for (int l = 0; l < n; l++)\\n        {\\n            int current_gcd = nums[l]; // Choose a left anchor, mark it as gcd\\n            for (int r = l; r < n; r++)\\n            {\\n                /* \\n                We update our current_gcd value in the inner loop. \\n                If we somehow reach to k at some point, we\\'ll draw an arrow from our left anchor to the that point. \\n                If we found a subarray that has elements with gcd k, increment result.\\n                We repeat that steps for each left anchor.\\n                */ \\n                current_gcd = gcd(current_gcd, nums[r]); \\n                if (current_gcd == k)\\n                    result++;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subarrayGCD(vector<int>& nums, int k) {\\n        \\n        int result = 0; // We may not have any subarray.\\n        \\n        int n = nums.size();\\n        \\n        for (int l = 0; l < n; l++)\\n        {\\n            int current_gcd = nums[l]; // Choose a left anchor, mark it as gcd\\n            for (int r = l; r < n; r++)\\n            {\\n                /* \\n                We update our current_gcd value in the inner loop. \\n                If we somehow reach to k at some point, we\\'ll draw an arrow from our left anchor to the that point. \\n                If we found a subarray that has elements with gcd k, increment result.\\n                We repeat that steps for each left anchor.\\n                */ \\n                current_gcd = gcd(current_gcd, nums[r]); \\n                if (current_gcd == k)\\n                    result++;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2735645,
                "title": "rust-double-loop",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe max size is 1000, double loop works fine.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N^2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nimpl Solution {\\n    pub fn subarray_gcd(nums: Vec<i32>, k: i32) -> i32 {\\n        let (mut ret, n) = (0, nums.len());\\n\\n        for i in 0 .. n {\\n            let mut d = 0;\\n\\n            for j in i .. n {\\n                if d == 0 { d = nums[j]; }\\n                else      { d = Self::gcd(d, nums[j]); }\\n\\n                if d % k != 0 { break }\\n                if d == k { ret += 1; }\\n            }\\n        }\\n        \\n        ret\\n    }\\n\\n    fn gcd(a: i32, b: i32) -> i32 {\\n        if a % b == 0 { return b }\\n        if b > a { return Self::gcd(b, a) }\\n        Self::gcd(b, a % b)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn subarray_gcd(nums: Vec<i32>, k: i32) -> i32 {\\n        let (mut ret, n) = (0, nums.len());\\n\\n        for i in 0 .. n {\\n            let mut d = 0;\\n\\n            for j in i .. n {\\n                if d == 0 { d = nums[j]; }\\n                else      { d = Self::gcd(d, nums[j]); }\\n\\n                if d % k != 0 { break }\\n                if d == k { ret += 1; }\\n            }\\n        }\\n        \\n        ret\\n    }\\n\\n    fn gcd(a: i32, b: i32) -> i32 {\\n        if a % b == 0 { return b }\\n        if b > a { return Self::gcd(b, a) }\\n        Self::gcd(b, a % b)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2735363,
                "title": "rust-two-pointer",
                "content": "```\\nfn gcd(a: i32, b: i32) -> i32 {\\n    if b == 0 {\\n        a\\n    } else {\\n        gcd(b, a % b)\\n    }\\n}\\n\\nimpl Solution {\\n    pub fn subarray_gcd(nums: Vec<i32>, k: i32) -> i32 {\\n        let n = nums.len();\\n        let mut rez = 0;\\n        for i in 0..n {\\n            let mut g = nums[i];\\n            let mut j = i;\\n            while g >= k && j < n {\\n                g = gcd(g, nums[j]);\\n                if g == k {\\n                    rez += 1;\\n                }\\n                j += 1;\\n            }\\n        }\\n        rez\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nfn gcd(a: i32, b: i32) -> i32 {\\n    if b == 0 {\\n        a\\n    } else {\\n        gcd(b, a % b)\\n    }\\n}\\n\\nimpl Solution {\\n    pub fn subarray_gcd(nums: Vec<i32>, k: i32) -> i32 {\\n        let n = nums.len();\\n        let mut rez = 0;\\n        for i in 0..n {\\n            let mut g = nums[i];\\n            let mut j = i;\\n            while g >= k && j < n {\\n                g = gcd(g, nums[j]);\\n                if g == k {\\n                    rez += 1;\\n                }\\n                j += 1;\\n            }\\n        }\\n        rez\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2735170,
                "title": "easy-java-solution",
                "content": "# Number of Subarrays with GCD Equal to K\\n# Easy Java Solution\\n\\n```\\nclass Solution {\\n    public int subarrayGCD(int[] nums, int k) {\\n        int ans=0;\\n        for(int i=0;i<nums.length;i++){\\n            int temp=nums[i];\\n            if(temp==k){\\n                ans++;\\n            }\\n            for(int j=i+1;j<nums.length;j++){\\n                if(nums[j]>=k){\\n                    temp=gcd(nums[j],temp);\\n                    if(temp==k){\\n                        ans++;\\n                    }\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n        }\\n    return ans;\\n    }\\n    public static int gcd(int a, int b){ \\n        return b==0?a:gcd(b,a%b);     \\n    } \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int subarrayGCD(int[] nums, int k) {\\n        int ans=0;\\n        for(int i=0;i<nums.length;i++){\\n            int temp=nums[i];\\n            if(temp==k){\\n                ans++;\\n            }\\n            for(int j=i+1;j<nums.length;j++){\\n                if(nums[j]>=k){\\n                    temp=gcd(nums[j],temp);\\n                    if(temp==k){\\n                        ans++;\\n                    }\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n        }\\n    return ans;\\n    }\\n    public static int gcd(int a, int b){ \\n        return b==0?a:gcd(b,a%b);     \\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2734759,
                "title": "java-solution-with-explanation-9ms",
                "content": "Idea is simple and intuitive. We\\'ll check every subarray of the given array nums in O(n2) time and calculate the GCD for every subarray.\\nWe\\'ll use 2 for loops, i denotes start of the subarray and j denotes end of the subarray. For optimation while taking i we\\'ll check if nums[i]%K!=0 if so subarray containing this element can\\'t have GCD equal k.\\n\\n**Time Complexity: O(N2*log(max(nums)))**\\nGCD function takes log(min(a,b)). \\n\\n```\\nclass Solution {\\n    public int subarrayGCD(int[] nums, int k) {\\n        int result=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]%k!=0) continue;\\n            int gcd=nums[i];\\n            for(int j=i;j<nums.length;j++){\\n                gcd=getGCD(gcd,nums[j]);\\n                if(gcd==k) result++;\\n            }\\n        }\\n        return result;\\n    }\\n    public int getGCD(int a,int b){\\n        if(a==0) return b;\\n        return getGCD(b%a,a);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int subarrayGCD(int[] nums, int k) {\\n        int result=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]%k!=0) continue;\\n            int gcd=nums[i];\\n            for(int j=i;j<nums.length;j++){\\n                gcd=getGCD(gcd,nums[j]);\\n                if(gcd==k) result++;\\n            }\\n        }\\n        return result;\\n    }\\n    public int getGCD(int a,int b){\\n        if(a==0) return b;\\n        return getGCD(b%a,a);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2734412,
                "title": "c-n-2-approach-easy-to-understand",
                "content": "In this **when we r iterating every j from i, till end. We are computing GCD also**\\nIn this image I have discussed the approach to clear any doubt.\\n![image](https://assets.leetcode.com/users/images/93da8e4d-bf9c-417a-949f-cacb4a1e4530_1666499155.408868.jpeg)\\n\\n**T.C : O(n^2)\\nS.C : O(1)**\\n\\n**C++ code**\\n\\n```\\nclass Solution {\\npublic:\\n    int subarrayGCD(vector<int>& nums, int k) {\\n        \\n        int res = 0;\\n        for(int i = 0; i < nums.size(); i++) {\\n            int saveGcd = nums[i];\\n            for(int j = i; j < nums.size(); j++) {\\n                saveGcd = __gcd(saveGcd, nums[j]);\\n                if(saveGcd == k) {\\n                    res++;\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subarrayGCD(vector<int>& nums, int k) {\\n        \\n        int res = 0;\\n        for(int i = 0; i < nums.size(); i++) {\\n            int saveGcd = nums[i];\\n            for(int j = i; j < nums.size(); j++) {\\n                saveGcd = __gcd(saveGcd, nums[j]);\\n                if(saveGcd == k) {\\n                    res++;\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2734273,
                "title": "java-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int subarrayGCD(int[] nums, int k) {\\n        \\n        int res = 0;\\n        int n = nums.length;\\n\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] == k) {\\n                res++;\\n            }\\n            int gcd = nums[i];\\n            for (int j = i + 1; j < n; j++) {\\n                gcd = gcd(gcd, nums[j]);\\n                if (gcd == k) {\\n                    res++;\\n                }\\n            }\\n        }\\n\\n        return res;\\n        \\n    }\\n\\n\\n    public int gcd(int a, int b) {\\n        return b == 0 ? a : gcd(b, a % b);\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int subarrayGCD(int[] nums, int k) {\\n        \\n        int res = 0;\\n        int n = nums.length;\\n\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] == k) {\\n                res++;\\n            }\\n            int gcd = nums[i];\\n            for (int j = i + 1; j < n; j++) {\\n                gcd = gcd(gcd, nums[j]);\\n                if (gcd == k) {\\n                    res++;\\n                }\\n            }\\n        }\\n\\n        return res;\\n        \\n    }\\n\\n\\n    public int gcd(int a, int b) {\\n        return b == 0 ? a : gcd(b, a % b);\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2734272,
                "title": "brute-force",
                "content": "```\\nclass Solution {\\npublic:\\n    int subarrayGCD(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        int cnt = 0;\\n        for(int i = 0;i<nums.size();i++){\\n            int cur = 0;\\n            for(int j=i;j<n;j++){\\n                cur = __gcd(cur,nums[j]);\\n                cnt+=(cur==k);\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int subarrayGCD(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        int cnt = 0;\\n        for(int i = 0;i<nums.size();i++){\\n            int cur = 0;\\n            for(int j=i;j<n;j++){\\n                cur = __gcd(cur,nums[j]);\\n                cnt+=(cur==k);\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2734200,
                "title": "python-simple-2-nested-loops-o-n-2",
                "content": "```\\nclass Solution:\\n    def subarrayGCD(self, nums: List[int], k: int) -> int:\\n        ans=0\\n        n=len(nums)\\n        for i in range(n):\\n            g=nums[i]\\n            for j in range(i,n):\\n                g=math.gcd(g,nums[j])\\n                if g==k: ans+=1           \\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def subarrayGCD(self, nums: List[int], k: int) -> int:\\n        ans=0\\n        n=len(nums)\\n        for i in range(n):\\n            g=nums[i]\\n            for j in range(i,n):\\n                g=math.gcd(g,nums[j])\\n                if g==k: ans+=1           \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2734170,
                "title": "c-beginner-sample-tc-explained",
                "content": "```\\nclass Solution {\\npublic:\\n    int subarrayGCD(vector<int>& nums, int k) {\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            int curGcd=nums[i];\\n            for(int j=i;j<nums.size();j++){\\n                 if(__gcd(curGcd, nums[j])==k){\\n                     ans++;\\n                 }\\n                curGcd=__gcd(curGcd, nums[j]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nWe use brute force with TC: O(N^2) to generate all the subarrays, for we calculate the gcd as given below:\\n\\nTest case:\\nnums = [9,3,1,2,6,3], k = 3\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\nformat: oldgcd:current number=new gcd \\n\\nsubarrays starting with index:0\\n9:9=9  **9:3=3**  3:1=1  1:2=1  1:6=1  1:3=1  \\nsubarrays starting with index:1\\n**3:3=3**  3:1=1  1:2=1  1:6=1  1:3=1  \\nsubarrays starting with index:2\\n1:1=1  1:2=1  1:6=1  1:3=1             \\nsubarrays starting with index:3\\n2:2=2  2:6=2  2:3=1  \\nsubarrays starting with index:4\\n6:6=6  **6:3=3**\\nsubarrays starting with index:5\\n**3:3=3**  \\n\\nAns: 4\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subarrayGCD(vector<int>& nums, int k) {\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            int curGcd=nums[i];\\n            for(int j=i;j<nums.size();j++){\\n                 if(__gcd(curGcd, nums[j])==k){\\n                     ans++;\\n                 }\\n                curGcd=__gcd(curGcd, nums[j]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2734152,
                "title": "c-easy",
                "content": "class Solution {\\npublic:\\n    int subarrayGCD(vector<int>& v, int k) {\\n        int ans=0;\\n        for(int i=0;i<v.size();i++) {\\n            int g = v[i];\\n            for(int j=i;j<v.size();j++) { //cal gcd for each subarray which start with ind i\\n                g = __gcd(g ,v[j]);\\n                if(g == k)\\n                    ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int subarrayGCD(vector<int>& v, int k) {\\n        int ans=0;\\n        for(int i=0;i<v.size();i++) {\\n            int g = v[i];\\n            for(int j=i;j<v.size();j++) { //cal gcd for each subarray which start with ind i\\n                g = __gcd(g ,v[j]);\\n                if(g == k)\\n                    ans++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2734144,
                "title": "python-brute-force",
                "content": "# Complexity\\n- Time complexity: O(n<sup>2</sup>)\\n- Space complexity: O(1)\\n\\n# Code :\\n```\\nclass Solution:\\n    def subarrayGCD(self, nums: List[int], k: int) -> int:\\n        def gcd(n1, n2):\\n            if n2==0:\\n                return n1\\n            return gcd(n2, n1%n2)\\n        \\n        ans = 0\\n        n = len(nums)\\n        for i in range(n):\\n            curr_gcd = 0\\n            for j in range(i, n):\\n                curr_gcd = gcd(curr_gcd, nums[j])\\n                if  curr_gcd == k:\\n                    ans += 1\\n        \\n        return ans\\n```\\n\\n----------------\\n**Upvote the post if you find it helpful.\\nHappy coding.**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def subarrayGCD(self, nums: List[int], k: int) -> int:\\n        def gcd(n1, n2):\\n            if n2==0:\\n                return n1\\n            return gcd(n2, n1%n2)\\n        \\n        ans = 0\\n        n = len(nums)\\n        for i in range(n):\\n            curr_gcd = 0\\n            for j in range(i, n):\\n                curr_gcd = gcd(curr_gcd, nums[j])\\n                if  curr_gcd == k:\\n                    ans += 1\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2734140,
                "title": "python-straight-forward-solution",
                "content": "```\\n    def subarrayGCD(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        def gcd(a, b):\\n            if b == 0:\\n                return a\\n            else:\\n                return gcd(b, a % b)\\n        \\n        res = 0\\n        for i in range(len(nums)):\\n            minV = nums[i]\\n            for j in range(i, len(nums)):\\n                if i == j and nums[i] == k:\\n                    res += 1\\n                else:\\n                    minV = gcd(minV, nums[j])\\n                    if minV < k:\\n                        break\\n                    elif minV == k:\\n                        res += 1\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def subarrayGCD(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        def gcd(a, b):\\n            if b == 0:\\n                return a\\n            else:\\n                return gcd(b, a % b)\\n        \\n        res = 0\\n        for i in range(len(nums)):\\n            minV = nums[i]\\n            for j in range(i, len(nums)):\\n                if i == j and nums[i] == k:\\n                    res += 1\\n                else:\\n                    minV = gcd(minV, nums[j])\\n                    if minV < k:\\n                        break\\n                    elif minV == k:\\n                        res += 1\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2734138,
                "title": "brute-force",
                "content": "```\\nclass Solution:\\n    def gcd(self, a, b):\\n        while b:\\n            a, b = b, a % b\\n        return a\\n    \\n    def subarrayGCD(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        res = 0\\n        for i in range(n):\\n            curr = nums[i]\\n            for j in range(i, n):\\n                curr = self.gcd(curr, nums[j])\\n                if curr == k:\\n                    res += 1\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def gcd(self, a, b):\\n        while b:\\n            a, b = b, a % b\\n        return a\\n    \\n    def subarrayGCD(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        res = 0\\n        for i in range(n):\\n            curr = nums[i]\\n            for j in range(i, n):\\n                curr = self.gcd(curr, nums[j])\\n                if curr == k:\\n                    res += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2734131,
                "title": "c-brute-force-easy-to-understand",
                "content": "```\\nint subarrayGCD(vector<int>& nums, int k) {\\n        int ans=0 , n=nums.size() ;\\n        \\n        for(int i=0 ; i<n ; i++)\\n        {\\n            int g = nums[i] ;\\n            for(int j=i ; j<n ; j++)\\n            {\\n                g = __gcd(nums[j] , g) ;\\n                if( g == k )  ans++ ;\\n            }\\n        }\\n        return ans ;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint subarrayGCD(vector<int>& nums, int k) {\\n        int ans=0 , n=nums.size() ;\\n        \\n        for(int i=0 ; i<n ; i++)\\n        {\\n            int g = nums[i] ;\\n            for(int j=i ; j<n ; j++)\\n            {\\n                g = __gcd(nums[j] , g) ;\\n                if( g == k )  ans++ ;\\n            }\\n        }\\n        return ans ;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2734128,
                "title": "javascript-recursion",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar subarrayGCD = function(nums, k) {\\n    let ans = 0;\\n    \\n    for (let i = 0; i < nums.length; i++) {\\n        let sub = [];\\n        for (let j = i; j < nums.length; j++) {\\n            if (nums[j] >= k) {\\n                sub.push(nums[j]);\\n                const gcd = findGcd(sub);\\n                if (gcd === k) {\\n                    ans++;\\n                }\\n            } else {\\n                break;\\n            }\\n        }\\n    }\\n    \\n    return ans;\\n};\\n    \\nfunction findGcd(arr) {\\n    let ans = arr[0];\\n    for (let i = 1; i < arr.length; i++) {\\n        ans = gcd(arr[i], ans);\\n        if (ans === 1) {\\n            return ans;\\n        }\\n    }\\n    return ans;\\n}\\n\\nfunction gcd(a, b) {\\n    if (!a) {\\n        return b;\\n    }\\n    return gcd(b % a, a);\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar subarrayGCD = function(nums, k) {\\n    let ans = 0;\\n    \\n    for (let i = 0; i < nums.length; i++) {\\n        let sub = [];\\n        for (let j = i; j < nums.length; j++) {\\n            if (nums[j] >= k) {\\n                sub.push(nums[j]);\\n                const gcd = findGcd(sub);\\n                if (gcd === k) {\\n                    ans++;\\n                }\\n            } else {\\n                break;\\n            }\\n        }\\n    }\\n    \\n    return ans;\\n};\\n    \\nfunction findGcd(arr) {\\n    let ans = arr[0];\\n    for (let i = 1; i < arr.length; i++) {\\n        ans = gcd(arr[i], ans);\\n        if (ans === 1) {\\n            return ans;\\n        }\\n    }\\n    return ans;\\n}\\n\\nfunction gcd(a, b) {\\n    if (!a) {\\n        return b;\\n    }\\n    return gcd(b % a, a);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2734124,
                "title": "clean-c-implementation",
                "content": "## Number of Subarrays with GCD Equal to K\\n\\nSince the constraints are small, we can use naive bruteforce to find the GCD of every subarray and check if it\\'s equal to K. The iteration over all subarrays can be done in **O(n^3)** (will fail due to TLE) or **O(n^2)** (will pass) time complexity.\\n\\nAn optimisation, here, would be to stop iterating once the GCD of the currently expanding subarray goes less than K because GCD cannot increase as we take more elements. I will leave the proof as an exercise for the reader.\\n\\n**C++ Solution**\\n\\n```cpp\\nint subarrayGCD (vector <int>& nums, int k) {\\n  int count = 0;\\n  int n = nums.size();\\n  \\n  for (int l = 0; l < n; ++l) {\\n    int gcd = 0;\\n    \\n    for (int r = l; r < n; ++r) {\\n      gcd = std::gcd(gcd, nums[r]);\\n      \\n      if (gcd < k)\\n        break;\\n      if (gcd == k)\\n        ++count;\\n    }\\n  }\\n  \\n  return count;\\n}\\n```\\n\\n**Time Complexity: O(n^2)**\\n**Space Complexity: O(1)**\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint subarrayGCD (vector <int>& nums, int k) {\\n  int count = 0;\\n  int n = nums.size();\\n  \\n  for (int l = 0; l < n; ++l) {\\n    int gcd = 0;\\n    \\n    for (int r = l; r < n; ++r) {\\n      gcd = std::gcd(gcd, nums[r]);\\n      \\n      if (gcd < k)\\n        break;\\n      if (gcd == k)\\n        ++count;\\n    }\\n  }\\n  \\n  return count;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4063189,
                "title": "check-out-this-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:(n^2logn(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int gcd(int a,int b){\\n        if(b==0){\\n            return a;\\n        }\\n        return gcd(b,a%b);\\n    }\\n    public int subarrayGCD(int[] nums, int k) {\\n        int ans=0;\\n        for(int i=0;i<nums.length;i++){\\n            int currgcd=nums[i];\\n             if(currgcd==k)  // if element ==k then it is subarray gcd\\n                ans++;\\n            for(int j=i+1;j<nums.length;j++){\\n                if(nums[j]<k)\\n                // if element is less than k it can have gcd\\n                break;\\n\\n                currgcd=gcd(nums[j],currgcd);\\n                if(currgcd==k){\\n                    ans++;\\n                }\\n            }    \\n        }\\n        return ans;\\n    }\\n}\\n\\n// 9 3 1 2 6 3\\n// 9\\n// 9 3\\n// 9 3 1\\n// 9 3 1 2\\n// 9 3 1 2 6\\n// 9 3 1 2 6 3\\n// 3 \\n// 3 1 \\n// so on \\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int gcd(int a,int b){\\n        if(b==0){\\n            return a;\\n        }\\n        return gcd(b,a%b);\\n    }\\n    public int subarrayGCD(int[] nums, int k) {\\n        int ans=0;\\n        for(int i=0;i<nums.length;i++){\\n            int currgcd=nums[i];\\n             if(currgcd==k)  // if element ==k then it is subarray gcd\\n                ans++;\\n            for(int j=i+1;j<nums.length;j++){\\n                if(nums[j]<k)\\n                // if element is less than k it can have gcd\\n                break;\\n\\n                currgcd=gcd(nums[j],currgcd);\\n                if(currgcd==k){\\n                    ans++;\\n                }\\n            }    \\n        }\\n        return ans;\\n    }\\n}\\n\\n// 9 3 1 2 6 3\\n// 9\\n// 9 3\\n// 9 3 1\\n// 9 3 1 2\\n// 9 3 1 2 6\\n// 9 3 1 2 6 3\\n// 3 \\n// 3 1 \\n// so on \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4056719,
                "title": "java-easy-solution-using-gcd-function-6ms-easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int subarrayGCD(int[] nums, int k) {\\n        int subAr = 0;\\n        for(int i=0; i<nums.length; i++) {\\n            int mul=nums[i];\\n            if(mul==k) subAr++;\\n            for(int j=i+1; j<nums.length; j++){\\n                if(nums[j]<k) break;\\n                mul=gcd(mul, nums[j]);\\n                if(mul==k){\\n                    subAr++;\\n                }\\n            }\\n        }\\n        return subAr;\\n    }\\n    private int gcd(int a, int b) {\\n        if (b == 0)\\n            return a;\\n        return gcd(b, a % b);\\n    } \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int subarrayGCD(int[] nums, int k) {\\n        int subAr = 0;\\n        for(int i=0; i<nums.length; i++) {\\n            int mul=nums[i];\\n            if(mul==k) subAr++;\\n            for(int j=i+1; j<nums.length; j++){\\n                if(nums[j]<k) break;\\n                mul=gcd(mul, nums[j]);\\n                if(mul==k){\\n                    subAr++;\\n                }\\n            }\\n        }\\n        return subAr;\\n    }\\n    private int gcd(int a, int b) {\\n        if (b == 0)\\n            return a;\\n        return gcd(b, a % b);\\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4056710,
                "title": "easy-java-soltution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int subarrayGCD(int[] nums, int k) {\\n        int subAr = 0;\\n        for(int i=0; i<nums.length; i++) {\\n            int mul=nums[i];\\n            if(mul==k) subAr++;\\n            for(int j=i+1; j<nums.length; j++){\\n                if(nums[j]<k) break;\\n                mul=gcd(mul, nums[j]);\\n                if(mul==k){\\n                    subAr++;\\n                }\\n            }\\n        }\\n        return subAr;\\n    }\\n    private int gcd(int a, int b) {\\n        if (b == 0)\\n            return a;\\n        return gcd(b, a % b);\\n    } \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int subarrayGCD(int[] nums, int k) {\\n        int subAr = 0;\\n        for(int i=0; i<nums.length; i++) {\\n            int mul=nums[i];\\n            if(mul==k) subAr++;\\n            for(int j=i+1; j<nums.length; j++){\\n                if(nums[j]<k) break;\\n                mul=gcd(mul, nums[j]);\\n                if(mul==k){\\n                    subAr++;\\n                }\\n            }\\n        }\\n        return subAr;\\n    }\\n    private int gcd(int a, int b) {\\n        if (b == 0)\\n            return a;\\n        return gcd(b, a % b);\\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3980446,
                "title": "for-loop",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\n\\n   function cgcd(a, b) {\\n        if (a == 0)\\n            return b;\\n        return cgcd(b % a, a);\\n    }\\n      \\nvar subarrayGCD = function(nums, k) {\\n    let len=nums.length\\n    let count=0\\n    for(let i=0;i<nums.length;i++){\\n\\n    \\n    let gcd=nums[i]\\n    for(let j=i;j<len;j++){\\n        gcd=cgcd(gcd,nums[j])\\n        if(gcd===k){\\n            count++\\n        }\\n        if(gcd<k){\\n            break\\n        }\\n    }\\n\\n    }\\n    return count\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\n\\n   function cgcd(a, b) {\\n        if (a == 0)\\n            return b;\\n        return cgcd(b % a, a);\\n    }\\n      \\nvar subarrayGCD = function(nums, k) {\\n    let len=nums.length\\n    let count=0\\n    for(let i=0;i<nums.length;i++){\\n\\n    \\n    let gcd=nums[i]\\n    for(let j=i;j<len;j++){\\n        gcd=cgcd(gcd,nums[j])\\n        if(gcd===k){\\n            count++\\n        }\\n        if(gcd<k){\\n            break\\n        }\\n    }\\n\\n    }\\n    return count\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3908386,
                "title": "c-brute-force-very-easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int subarrayGCD(vector<int>& nums, int k) {\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            int temp=0;\\n            for(int j=i;j<nums.size();j++){\\n                temp=__gcd(temp,nums[j]);\\n                if(temp==k){\\n                    ans++;\\n                }\\n                else if(temp<k)break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![vote.png](https://assets.leetcode.com/users/images/70d1864b-0bb7-42c4-a63e-d134efd12fcd_1692011319.0946612.png)\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subarrayGCD(vector<int>& nums, int k) {\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            int temp=0;\\n            for(int j=i;j<nums.size();j++){\\n                temp=__gcd(temp,nums[j]);\\n                if(temp==k){\\n                    ans++;\\n                }\\n                else if(temp<k)break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3898535,
                "title": "c-brute-force-very-easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int subarrayGCD(vector<int>& nums, int k) {\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            int temp=0;\\n            for(int j=i;j<nums.size();j++){\\n                temp=__gcd(temp,nums[j]);\\n                if(temp==k){\\n                    ans++;\\n                }\\n                else if(temp<k)break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![vote.png](https://assets.leetcode.com/users/images/e6c3acf3-6f93-48cd-9681-5498d6a1cac2_1691832719.1511877.png)\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subarrayGCD(vector<int>& nums, int k) {\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            int temp=0;\\n            for(int j=i;j<nums.size();j++){\\n                temp=__gcd(temp,nums[j]);\\n                if(temp==k){\\n                    ans++;\\n                }\\n                else if(temp<k)break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3892836,
                "title": "easiest-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int subarrayGCD(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> v(n);\\n        v[n-1]=nums[n-1];\\n\\n        int ans = 0;\\n        if(nums[n-1]==k)\\n        ans+=1;\\n\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(nums[i]==k)\\n            ans+=1;\\n\\n            for(int j=i+1;j<n;j++)\\n            {\\n                v[j]=__gcd(nums[i],v[j]);\\n                if(v[j]==k)\\n                ans+=1;\\n            }\\n            v[i] = nums[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subarrayGCD(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> v(n);\\n        v[n-1]=nums[n-1];\\n\\n        int ans = 0;\\n        if(nums[n-1]==k)\\n        ans+=1;\\n\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(nums[i]==k)\\n            ans+=1;\\n\\n            for(int j=i+1;j<n;j++)\\n            {\\n                v[j]=__gcd(nums[i],v[j]);\\n                if(v[j]==k)\\n                ans+=1;\\n            }\\n            v[i] = nums[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3887265,
                "title": "python-3",
                "content": "# Complexity\\n- Time complexity: O(N^2 * log(M))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def subarrayGCD(self, nums: List[int], k: int) -> int:\\n\\n\\n        N = len(nums)\\n        ans = 0\\n\\n\\n        def gcd(a, b):\\n            while b:\\n                a, b = b, a%b\\n            return a\\n\\n        for i in range(N):\\n            tmp = nums[i]\\n            for j in range(i, N):\\n\\n                tmp = gcd(tmp, nums[j])\\n                if tmp == k:\\n                    ans += 1\\n\\n                if tmp < k:\\n                    break\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def subarrayGCD(self, nums: List[int], k: int) -> int:\\n\\n\\n        N = len(nums)\\n        ans = 0\\n\\n\\n        def gcd(a, b):\\n            while b:\\n                a, b = b, a%b\\n            return a\\n\\n        for i in range(N):\\n            tmp = nums[i]\\n            for j in range(i, N):\\n\\n                tmp = gcd(tmp, nums[j])\\n                if tmp == k:\\n                    ans += 1\\n\\n                if tmp < k:\\n                    break\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3817774,
                "title": "number-of-subarrays-with-gcd-equal-to-k-easy-and-simple-approach",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n        int subarrayGCD(vector<int>& nums, int k) \\n        {\\n\\t\\tint cnt = 0;\\n        for (int i = 0; i < size(nums); i++)\\n        {\\n            int currGcd = 0;\\n            for (int j = i; j < size(nums); j++)\\n            {\\n                currGcd = gcd(currGcd, nums[j]);\\n                if (currGcd == k)\\n                {\\n                    cnt++;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Array",
                    "Math",
                    "Number Theory"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n        int subarrayGCD(vector<int>& nums, int k) \\n        {\\n\\t\\tint cnt = 0;\\n        for (int i = 0; i < size(nums); i++)\\n        {\\n            int currGcd = 0;\\n            for (int j = i; j < size(nums); j++)\\n            {\\n                currGcd = gcd(currGcd, nums[j]);\\n                if (currGcd == k)\\n                {\\n                    cnt++;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3660219,
                "title": "java-o-n-2-log-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int gcd(int a,int b){\\n        if(b!=0){\\n            return gcd(b,a%b);\\n        }\\n        else{\\n            return a;\\n        }\\n    }\\n    public int subarrayGCD(int[] nums, int k) {\\n        int count=0;\\n        for(int i=0;i<nums.length;i++){\\n            int curr=nums[i];\\n            if(curr==k){\\n                count++;\\n            }\\n            for(int j=i+1;j<nums.length;j++){\\n                if(nums[j]<k){\\n                    break;\\n                }\\n                curr=gcd(curr,nums[j]);\\n                if(curr==k){\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int gcd(int a,int b){\\n        if(b!=0){\\n            return gcd(b,a%b);\\n        }\\n        else{\\n            return a;\\n        }\\n    }\\n    public int subarrayGCD(int[] nums, int k) {\\n        int count=0;\\n        for(int i=0;i<nums.length;i++){\\n            int curr=nums[i];\\n            if(curr==k){\\n                count++;\\n            }\\n            for(int j=i+1;j<nums.length;j++){\\n                if(nums[j]<k){\\n                    break;\\n                }\\n                curr=gcd(curr,nums[j]);\\n                if(curr==k){\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3638927,
                "title": "easiest-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int subarrayGCD(vector<int>& nums, int k) {\\n        int count=0;\\n       for(int i=0;i<nums.size();i++){\\n         int  gcd=0;\\n           for(int j=i;j<nums.size();j++){\\n           gcd=__gcd(gcd,nums[j]);\\n           if(gcd==k)\\n           count++;\\n           }\\n       } \\n       return count;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subarrayGCD(vector<int>& nums, int k) {\\n        int count=0;\\n       for(int i=0;i<nums.size();i++){\\n         int  gcd=0;\\n           for(int j=i;j<nums.size();j++){\\n           gcd=__gcd(gcd,nums[j]);\\n           if(gcd==k)\\n           count++;\\n           }\\n       } \\n       return count;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3607691,
                "title": "o-n-time-complexity-o-1-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar subarrayGCD = function(nums, k) {\\n  let res = 0;\\n  let left = 0;\\n  let cur = nums[0], right = -1, pos = -1;\\n  for (let i = 0; i < nums.length; i++) {\\n    if (nums[i] % k !== 0) {\\n      left = i + 1;\\n      cur = nums[i+1];\\n    } else {\\n      cur = gcd(cur, nums[i]);\\n      if (cur === k) {\\n        for (let j = i; j >= pos; j--) {\\n          if (gcd(nums[i], nums[j]) === k) {\\n            right = j;\\n            cur = nums[i];\\n            pos = i;\\n            break;\\n          }\\n        }\\n      }\\n      res += Math.max(0, right - left + 1);\\n    }\\n  }\\n  return res;\\n};\\n\\nconst gcd = (a, b) => {\\n  if (!b) {\\n    return a;\\n  }\\n  return gcd(b, a % b);\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar subarrayGCD = function(nums, k) {\\n  let res = 0;\\n  let left = 0;\\n  let cur = nums[0], right = -1, pos = -1;\\n  for (let i = 0; i < nums.length; i++) {\\n    if (nums[i] % k !== 0) {\\n      left = i + 1;\\n      cur = nums[i+1];\\n    } else {\\n      cur = gcd(cur, nums[i]);\\n      if (cur === k) {\\n        for (let j = i; j >= pos; j--) {\\n          if (gcd(nums[i], nums[j]) === k) {\\n            right = j;\\n            cur = nums[i];\\n            pos = i;\\n            break;\\n          }\\n        }\\n      }\\n      res += Math.max(0, right - left + 1);\\n    }\\n  }\\n  return res;\\n};\\n\\nconst gcd = (a, b) => {\\n  if (!b) {\\n    return a;\\n  }\\n  return gcd(b, a % b);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3601309,
                "title": "o-n-2-python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def subarrayGCD(self, nums: List[int], k: int) -> int:\\n\\n    \\n\\n        c=0\\n        n=len(nums)\\n        for i in range(n):\\n            res=nums[i]\\n            for j in range(i,n):\\n                if nums[j]%k: break\\n                res=gcd(res,nums[j])\\n                if res==k: c+=1\\n\\n        return c        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def subarrayGCD(self, nums: List[int], k: int) -> int:\\n\\n    \\n\\n        c=0\\n        n=len(nums)\\n        for i in range(n):\\n            res=nums[i]\\n            for j in range(i,n):\\n                if nums[j]%k: break\\n                res=gcd(res,nums[j])\\n                if res==k: c+=1\\n\\n        return c        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3599371,
                "title": "dynamic-programming-solution-with-detailed-explanation",
                "content": "# Intuition\\nThe idea behind this solution is very simple. We simply iterate over all possible subarrays. For each subarray, we calculate the GCD of its items and keep track of the `count` variable, which we use to hold the number of subarrays satisfying the requirement.\\n\\n# Approach\\nIn order to efficiently calculate the GCD of many numbers, we need to know this property:\\n$$ GCD(a, b, c, ..) = GCD(a, GCD(b, GCD(c, ...))) $$\\n\\nThat means, if we know the GCD all items from index `i` to index `j`, we can easily calculate GCD of items from `i` to `j + 1` by using the same formula: \\n\\n$$ GCD[i, j + 1] = GCD[GCD[i , j], \\\\space nums[j + 1]] $$\\n\\nThis can be easily implemented using a 2D array `GCD` where `GCD[i][j]` denotes the GCD of subarray starting from `i` and ending at `j`.\\n\\n# Complexity\\n- Time complexity: $$O(N^2logM)$$ with $$N$$ being the size of the input array `nums` and $$M$$ being the maximum values of `nums[i]`.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N^2)$$ with $$N$$ being the size of the input array `nums` since we are using a 2D array to cache values.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc min(nums ...int) int {\\n\\tmin := nums[0]\\n\\tfor _, num := range nums {\\n\\t\\tif num < min {\\n\\t\\t\\tmin = num\\n\\t\\t}\\n\\t}\\n\\n\\treturn min\\n}\\n\\nfunc max(nums ...int) int {\\n\\tmax := nums[0]\\n\\tfor _, num := range nums {\\n\\t\\tif num > max {\\n\\t\\t\\tmax = num\\n\\t\\t}\\n\\t}\\n\\n\\treturn max\\n}\\n\\nfunc gcd(a int, b int) int {\\n\\tsmaller := min(a, b)\\n\\tlarger := max(a, b)\\n\\n\\tfor smaller > 0 {\\n\\t\\ttemp := smaller\\n\\t\\tsmaller = larger % smaller\\n\\t\\tlarger = temp\\n\\t}\\n\\n\\treturn larger\\n}\\n\\nfunc subarrayGCD(nums []int, k int) int {\\n\\tcount := 0\\n\\tn := len(nums)\\n\\tgcdArray := make([][]int, n)\\n\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tgcdArray[i] = make([]int, n)\\n\\t}\\n\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tfor j := i; j < n; j++ {\\n\\t\\t\\tif i == j {\\n\\t\\t\\t\\tgcdArray[i][j] = nums[i]\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tgcdArray[i][j] = gcd(gcdArray[i][j - 1], nums[j])\\n\\t\\t\\t}\\n\\n\\t\\t\\tif gcdArray[i][j] == k {\\n\\t\\t\\t\\tcount++\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn count\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Math",
                    "Dynamic Programming",
                    "Number Theory"
                ],
                "code": "```\\nfunc min(nums ...int) int {\\n\\tmin := nums[0]\\n\\tfor _, num := range nums {\\n\\t\\tif num < min {\\n\\t\\t\\tmin = num\\n\\t\\t}\\n\\t}\\n\\n\\treturn min\\n}\\n\\nfunc max(nums ...int) int {\\n\\tmax := nums[0]\\n\\tfor _, num := range nums {\\n\\t\\tif num > max {\\n\\t\\t\\tmax = num\\n\\t\\t}\\n\\t}\\n\\n\\treturn max\\n}\\n\\nfunc gcd(a int, b int) int {\\n\\tsmaller := min(a, b)\\n\\tlarger := max(a, b)\\n\\n\\tfor smaller > 0 {\\n\\t\\ttemp := smaller\\n\\t\\tsmaller = larger % smaller\\n\\t\\tlarger = temp\\n\\t}\\n\\n\\treturn larger\\n}\\n\\nfunc subarrayGCD(nums []int, k int) int {\\n\\tcount := 0\\n\\tn := len(nums)\\n\\tgcdArray := make([][]int, n)\\n\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tgcdArray[i] = make([]int, n)\\n\\t}\\n\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tfor j := i; j < n; j++ {\\n\\t\\t\\tif i == j {\\n\\t\\t\\t\\tgcdArray[i][j] = nums[i]\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tgcdArray[i][j] = gcd(gcdArray[i][j - 1], nums[j])\\n\\t\\t\\t}\\n\\n\\t\\t\\tif gcdArray[i][j] == k {\\n\\t\\t\\t\\tcount++\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn count\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3567105,
                "title": "scala-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nobject Solution {\\n  def subarrayGCD(nums: Array[Int], k: Int): Int = {\\n    @annotation.tailrec\\n    def gcd(a: Int, b: Int): Int = if (b == 0) a else gcd(b, a % b)\\n    val n = nums.length\\n    def f(i: Int, curGCD: Int, acc: Int): Int = {\\n      if(curGCD >= k && i < n){\\n        val num = nums(i)\\n        val tempGCD = gcd(curGCD, num)\\n        if(tempGCD == k) f(i + 1, tempGCD, acc + 1)\\n        else f(i + 1, tempGCD, acc)\\n      } else acc\\n    }\\n    (nums.indices).map(i => f(i, nums(i), 0)).sum\\n  }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n  def subarrayGCD(nums: Array[Int], k: Int): Int = {\\n    @annotation.tailrec\\n    def gcd(a: Int, b: Int): Int = if (b == 0) a else gcd(b, a % b)\\n    val n = nums.length\\n    def f(i: Int, curGCD: Int, acc: Int): Int = {\\n      if(curGCD >= k && i < n){\\n        val num = nums(i)\\n        val tempGCD = gcd(curGCD, num)\\n        if(tempGCD == k) f(i + 1, tempGCD, acc + 1)\\n        else f(i + 1, tempGCD, acc)\\n      } else acc\\n    }\\n    (nums.indices).map(i => f(i, nums(i), 0)).sum\\n  }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3517048,
                "title": "c-solution-faster-than-100-o-n-2-log-max",
                "content": "```\\npublic class Solution {\\n    public int SubarrayGCD(int[] nums, int k) {\\n        int gcd(int a,int b) => (b == 0) ? a : gcd(b,a % b); \\n        int res = 0;\\n        for(int i = 0; i < nums.Length;i++){\\n            int curGcd = nums[i], j = i;\\n            while(j < nums.Length && curGcd >= k){\\n                curGcd = gcd(curGcd,nums[j]);\\n                if(curGcd == k)res++;\\n                j++;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Number Theory"
                ],
                "code": "```\\npublic class Solution {\\n    public int SubarrayGCD(int[] nums, int k) {\\n        int gcd(int a,int b) => (b == 0) ? a : gcd(b,a % b); \\n        int res = 0;\\n        for(int i = 0; i < nums.Length;i++){\\n            int curGcd = nums[i], j = i;\\n            while(j < nums.Length && curGcd >= k){\\n                curGcd = gcd(curGcd,nums[j]);\\n                if(curGcd == k)res++;\\n                j++;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3464124,
                "title": "simple-code-beginner-friendly",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nNumber Theory\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int subarrayGCD(int[] nums, int k) {\\n        int count=0;\\n        for(int i=0;i<nums.length;i++){\\n            int hcf=0;\\n            for(int j=i;j<nums.length;j++){\\n                hcf=gcd(hcf,nums[j]);\\n                if(hcf==k){\\n                    count++;\\n                }\\n                if(hcf<k){\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    public int gcd(int a, int b){\\n        if(a==0) return b;\\n        if(b==0) return a;\\n        if(a==b) return b;\\n        while(a!=b){\\n            if(a==0) return b;\\n            if(b==0) return a;\\n            if(a==b) return b;\\n            if(a>b) a=a%b;\\n            else b=b%a;\\n        }\\n        return a;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Counting",
                    "Iterator",
                    "Number Theory"
                ],
                "code": "```\\nclass Solution {\\n    public int subarrayGCD(int[] nums, int k) {\\n        int count=0;\\n        for(int i=0;i<nums.length;i++){\\n            int hcf=0;\\n            for(int j=i;j<nums.length;j++){\\n                hcf=gcd(hcf,nums[j]);\\n                if(hcf==k){\\n                    count++;\\n                }\\n                if(hcf<k){\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    public int gcd(int a, int b){\\n        if(a==0) return b;\\n        if(b==0) return a;\\n        if(a==b) return b;\\n        while(a!=b){\\n            if(a==0) return b;\\n            if(b==0) return a;\\n            if(a==b) return b;\\n            if(a>b) a=a%b;\\n            else b=b%a;\\n        }\\n        return a;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3443412,
                "title": "c-brute",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // int findgcd(vector<int>nums, int idx){\\n    // if (idx == arr.size() - 1) {\\n    //     return arr[idx];\\n    // }\\n    // int a = arr[idx];\\n    // int b = GcdOfArray(arr, idx + 1);\\n    // return __gcd(\\n    //     a, b);    \\n    // }\\n    int subarrayGCD(vector<int>& nums, int k) {\\n        int count = 0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==k) count++;\\n        }\\n      for(int i=0;i<nums.size();i++){\\n          int gcd = nums[i];\\n          bool flag = false;\\n          for(int j=i+1;j<nums.size();j++){\\n              if(nums[j]%k != 0) break;\\n              gcd = __gcd(gcd,nums[j]);\\n              if(gcd == k) count++;\\n          }\\n      }\\n        return count;\\n    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // int findgcd(vector<int>nums, int idx){\\n    // if (idx == arr.size() - 1) {\\n    //     return arr[idx];\\n    // }\\n    // int a = arr[idx];\\n    // int b = GcdOfArray(arr, idx + 1);\\n    // return __gcd(\\n    //     a, b);    \\n    // }\\n    int subarrayGCD(vector<int>& nums, int k) {\\n        int count = 0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==k) count++;\\n        }\\n      for(int i=0;i<nums.size();i++){\\n          int gcd = nums[i];\\n          bool flag = false;\\n          for(int j=i+1;j<nums.size();j++){\\n              if(nums[j]%k != 0) break;\\n              gcd = __gcd(gcd,nums[j]);\\n              if(gcd == k) count++;\\n          }\\n      }\\n        return count;\\n    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3387217,
                "title": "brute-force-with-optimizations",
                "content": "\\n\\n# Simple Brute Force\\n```\\nclass Solution:\\n    def subarrayGCD(self, nums: List[int], k: int) -> int:\\n        def gcd(a,b):\\n            if b == 0:\\n                return a\\n            return gcd(b,a%b)\\n            \\n        ans = 0\\n        size = len(nums)\\n        for i in range(size):\\n            g = nums[i]\\n            for j in range(i,size):\\n                g = gcd(g,nums[j])\\n                if g == k:\\n                    ans += 1\\n        \\n        return ans\\n```\\n# Brute Force with optimizations\\n```\\nclass Solution:\\n    def subarrayGCD(self, nums: List[int], k: int) -> int:\\n        def gcd(a,b):\\n            if b == 0:\\n                return a\\n            return gcd(b,a%b)\\n            \\n        ans = 0\\n        size = len(nums)\\n        for i in range(size):\\n            g = nums[i]\\n            if g % k != 0:\\n                continue \\n            for j in range(i,size):\\n                g = gcd(g,nums[j])\\n                if g == k:\\n                    ans += 1\\n                elif g < k:\\n                    break\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def subarrayGCD(self, nums: List[int], k: int) -> int:\\n        def gcd(a,b):\\n            if b == 0:\\n                return a\\n            return gcd(b,a%b)\\n            \\n        ans = 0\\n        size = len(nums)\\n        for i in range(size):\\n            g = nums[i]\\n            for j in range(i,size):\\n                g = gcd(g,nums[j])\\n                if g == k:\\n                    ans += 1\\n        \\n        return ans\\n```\n```\\nclass Solution:\\n    def subarrayGCD(self, nums: List[int], k: int) -> int:\\n        def gcd(a,b):\\n            if b == 0:\\n                return a\\n            return gcd(b,a%b)\\n            \\n        ans = 0\\n        size = len(nums)\\n        for i in range(size):\\n            g = nums[i]\\n            if g % k != 0:\\n                continue \\n            for j in range(i,size):\\n                g = gcd(g,nums[j])\\n                if g == k:\\n                    ans += 1\\n                elif g < k:\\n                    break\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3320882,
                "title": "understandable",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int subarrayGCD(vector<int>& nums, int k) {\\n        int cnt=0;\\n        \\n        for(int i=0; i<nums.size(); i++){\\n            int a=nums[i];\\n            for(int j=i; j<nums.size(); j++){\\n                a=__gcd(a, nums[j]);\\n                if(a==k)cnt++;\\n                if(nums[j]%k!=0) break;\\n                \\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subarrayGCD(vector<int>& nums, int k) {\\n        int cnt=0;\\n        \\n        for(int i=0; i<nums.size(); i++){\\n            int a=nums[i];\\n            for(int j=i; j<nums.size(); j++){\\n                a=__gcd(a, nums[j]);\\n                if(a==k)cnt++;\\n                if(nums[j]%k!=0) break;\\n                \\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3320880,
                "title": "understandable",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int subarrayGCD(vector<int>& nums, int k) {\\n        int cnt=0;\\n        \\n        for(int i=0; i<nums.size(); i++){\\n            int a=nums[i];\\n            for(int j=i; j<nums.size(); j++){\\n                a=__gcd(a, nums[j]);\\n                if(a==k)cnt++;\\n                if(nums[j]%k!=0) break;\\n                \\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subarrayGCD(vector<int>& nums, int k) {\\n        int cnt=0;\\n        \\n        for(int i=0; i<nums.size(); i++){\\n            int a=nums[i];\\n            for(int j=i; j<nums.size(); j++){\\n                a=__gcd(a, nums[j]);\\n                if(a==k)cnt++;\\n                if(nums[j]%k!=0) break;\\n                \\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3293551,
                "title": "sliding-window-soln",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int subarrayGCD(vector<int>& nums, int k) {\\n        \\n        int count=0;\\n        for(int i=0;i<nums.size();i++)\\n       {\\n           if(nums[i]==k)\\n           {\\n               count++;\\n           }\\n       }\\n       \\n       int i=0;int j;\\n       while(i<nums.size()-1)\\n       {\\n           j=i+1;\\n           int temp=nums[i];\\n           while(j<nums.size())\\n           {\\n               int curr=__gcd(temp,nums[j]);\\n               if(curr==k)\\n               {\\n                   count++;\\n                   temp=curr;\\n                   j++;\\n               }\\n               else\\n               {\\n                   temp=__gcd(temp,nums[j]);\\n                   j++;\\n                //    break;\\n               }\\n           }\\n           i++;\\n       }\\nreturn count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subarrayGCD(vector<int>& nums, int k) {\\n        \\n        int count=0;\\n        for(int i=0;i<nums.size();i++)\\n       {\\n           if(nums[i]==k)\\n           {\\n               count++;\\n           }\\n       }\\n       \\n       int i=0;int j;\\n       while(i<nums.size()-1)\\n       {\\n           j=i+1;\\n           int temp=nums[i];\\n           while(j<nums.size())\\n           {\\n               int curr=__gcd(temp,nums[j]);\\n               if(curr==k)\\n               {\\n                   count++;\\n                   temp=curr;\\n                   j++;\\n               }\\n               else\\n               {\\n                   temp=__gcd(temp,nums[j]);\\n                   j++;\\n                //    break;\\n               }\\n           }\\n           i++;\\n       }\\nreturn count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3272652,
                "title": "c-easy-approach",
                "content": "# Intuition\\nLet GCD of an array elements is X, now add a new element Y to the array. The GCD of the resultant array is GCD(X,Y).\\n\\n# Approach\\nGenerate all the subarrays using two nested loops, for each new element added to the subarray, calculate the gcd of the previous array and the newly added element. Check if the GCD is equal to given number and increment count if yes.\\n\\nI used in-built function to calculate GCD of two numbers.\\n\\n# Complexity\\n- Time complexity:\\nO(n2)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int subarrayGCD(vector<int>& nums, int k) {\\n        int s=0;\\n        for(int i=0;i<nums.size();++i)\\n        {\\n            int t=nums[i];\\n            for(int j=i;j<nums.size();++j)\\n            {\\n                t=__gcd(nums[j],t);\\n                if(t==k)\\n                 s++;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subarrayGCD(vector<int>& nums, int k) {\\n        int s=0;\\n        for(int i=0;i<nums.size();++i)\\n        {\\n            int t=nums[i];\\n            for(int j=i;j<nums.size();++j)\\n            {\\n                t=__gcd(nums[j],t);\\n                if(t==k)\\n                 s++;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3272416,
                "title": "c-o-n-log-n-non-recursive-segment-tree-solution",
                "content": "```cpp\\n// <editor-fold defaultstate=\"collapsed\" desc=\"#define out(...)\">\\n#ifndef out\\n#define out(...)\\n#endif\\n// </editor-fold>\\n\\ntemplate<class Tree, class Pred>\\ninline int search(int n, Tree &&tree, Pred &&test, int l) { // return the smallest index test failed\\n    assert(0 <= l && l < n);\\n    l += n;\\n    int stack[40], top = 0, id = 0;\\n    for (int r = n << 1; l < r; l >>= 1, r >>= 1) {\\n        if (l & 1) {\\n            if (!test(tree[l])) {\\n                id = l;\\n                break;\\n            }\\n            ++l;\\n        }\\n        if (r & 1) stack[top++] = --r;\\n    }\\n    if (!id) {\\n        while (top) {\\n            int x = stack[--top];\\n            if (test(tree[x])) continue;\\n            id = x;\\n            break;\\n        }\\n        if (!id) return n;\\n    }\\n    while (id < n) if (test(tree[id <<= 1])) ++id;\\n    return id - n;\\n}\\n\\nconst int N = 1005;\\nstatic int tree[N * 2];\\n\\nclass SegTree {\\n    int n{};\\npublic:\\n    explicit SegTree(const int arr[], int n) : n(n) {\\n        copy(arr, arr + n, tree + n);\\n        for (int i = n - 1; i > 0; --i) tree[i] = gcd(tree[i << 1], tree[i << 1 | 1]);\\n    }\\n\\n    [[nodiscard]]\\n    int query(int pos) const { // find the smallest index that gcd value among (pos,pos+1,...index) is 1\\n        auto test = [val = 0](int x) mutable {\\n            if (x == 1) return false;\\n            if (!val) return val = x, true;\\n            int t = gcd(val, x);\\n\\t\\t\\tif (t == 1) return false;\\n            return val = t, true;\\n        };\\n        return search(n, tree, test, pos);\\n    }\\n};\\n\\ninline int solve(const int arr[], int n) { // calculate how many subarray of arr having gcd is 1\\n    out(vector<int>(arr, arr + n));\\n    if (n == 1) return arr[0] == 1;\\n    if (n == 2) {\\n        int t = (arr[0] == 1) + (arr[1] == 1);\\n        return t ? t + 1 : gcd(arr[0], arr[1]) == 1;\\n    }\\n    SegTree seg(arr, n);\\n    if (tree[1] != 1) return 0;\\n    int ans = 0;\\n    for (int i = 0; i < n; ++i) {\\n        int pos = seg.query(i);\\n        if (pos == n) break;\\n        ans += n - pos;\\n    }\\n    return ans;\\n}\\n\\nclass Solution {\\npublic:\\n    // allow call like Solution().subarrayGCD({4}, 7);\\n    static int subarrayGCD(vector<int> &&nums, int k) {\\n        return subarrayGCD(nums, k);\\n    }\\n\\n    static int subarrayGCD(vector<int> &nums, int k) {\\n        size_t n = nums.size();\\n        const int *data = nums.data();\\n        int ans = 0;\\n        for (int i = 0; i < n;) {\\n            int &x = nums[i];\\n            assert(x > 0);\\n            if (x % k) {\\n                ++i;\\n                continue;\\n            }\\n            x /= k;\\n            int j = i + 1;\\n            for (; j < n; ++j) {\\n                int &y = nums[j];\\n                if (y % k) break;\\n                assert(y > 0);\\n                y /= k;\\n            }\\n            ans += solve(data + i, j - i);\\n            i = j;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Tree"
                ],
                "code": "```cpp\\n// <editor-fold defaultstate=\"collapsed\" desc=\"#define out(...)\">\\n#ifndef out\\n#define out(...)\\n#endif\\n// </editor-fold>\\n\\ntemplate<class Tree, class Pred>\\ninline int search(int n, Tree &&tree, Pred &&test, int l) { // return the smallest index test failed\\n    assert(0 <= l && l < n);\\n    l += n;\\n    int stack[40], top = 0, id = 0;\\n    for (int r = n << 1; l < r; l >>= 1, r >>= 1) {\\n        if (l & 1) {\\n            if (!test(tree[l])) {\\n                id = l;\\n                break;\\n            }\\n            ++l;\\n        }\\n        if (r & 1) stack[top++] = --r;\\n    }\\n    if (!id) {\\n        while (top) {\\n            int x = stack[--top];\\n            if (test(tree[x])) continue;\\n            id = x;\\n            break;\\n        }\\n        if (!id) return n;\\n    }\\n    while (id < n) if (test(tree[id <<= 1])) ++id;\\n    return id - n;\\n}\\n\\nconst int N = 1005;\\nstatic int tree[N * 2];\\n\\nclass SegTree {\\n    int n{};\\npublic:\\n    explicit SegTree(const int arr[], int n) : n(n) {\\n        copy(arr, arr + n, tree + n);\\n        for (int i = n - 1; i > 0; --i) tree[i] = gcd(tree[i << 1], tree[i << 1 | 1]);\\n    }\\n\\n    [[nodiscard]]\\n    int query(int pos) const { // find the smallest index that gcd value among (pos,pos+1,...index) is 1\\n        auto test = [val = 0](int x) mutable {\\n            if (x == 1) return false;\\n            if (!val) return val = x, true;\\n            int t = gcd(val, x);\\n\\t\\t\\tif (t == 1) return false;\\n            return val = t, true;\\n        };\\n        return search(n, tree, test, pos);\\n    }\\n};\\n\\ninline int solve(const int arr[], int n) { // calculate how many subarray of arr having gcd is 1\\n    out(vector<int>(arr, arr + n));\\n    if (n == 1) return arr[0] == 1;\\n    if (n == 2) {\\n        int t = (arr[0] == 1) + (arr[1] == 1);\\n        return t ? t + 1 : gcd(arr[0], arr[1]) == 1;\\n    }\\n    SegTree seg(arr, n);\\n    if (tree[1] != 1) return 0;\\n    int ans = 0;\\n    for (int i = 0; i < n; ++i) {\\n        int pos = seg.query(i);\\n        if (pos == n) break;\\n        ans += n - pos;\\n    }\\n    return ans;\\n}\\n\\nclass Solution {\\npublic:\\n    // allow call like Solution().subarrayGCD({4}, 7);\\n    static int subarrayGCD(vector<int> &&nums, int k) {\\n        return subarrayGCD(nums, k);\\n    }\\n\\n    static int subarrayGCD(vector<int> &nums, int k) {\\n        size_t n = nums.size();\\n        const int *data = nums.data();\\n        int ans = 0;\\n        for (int i = 0; i < n;) {\\n            int &x = nums[i];\\n            assert(x > 0);\\n            if (x % k) {\\n                ++i;\\n                continue;\\n            }\\n            x /= k;\\n            int j = i + 1;\\n            for (; j < n; ++j) {\\n                int &y = nums[j];\\n                if (y % k) break;\\n                assert(y > 0);\\n                y /= k;\\n            }\\n            ans += solve(data + i, j - i);\\n            i = j;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3200124,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nsimply appling loop and checking and updating value of current\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int subarrayGCD(int[] nums, int k) {\\n        int count=0;\\n        for(int i=0;i<nums.length;i++){\\n          int curr=nums[i];\\n\\n            if(nums[i]==k)count++;\\n            for(int j=i+1;j<nums.length;j++){\\n                curr=gcd(nums[j],curr);\\n                if(curr==k)count++;\\n                \\n            }\\n        }\\n        return count;\\n    }\\n\\n public static int gcd(int a,int b){\\n     if(b==0)return a;\\n     return gcd(b,a%b);\\n }\\n\\n\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int subarrayGCD(int[] nums, int k) {\\n        int count=0;\\n        for(int i=0;i<nums.length;i++){\\n          int curr=nums[i];\\n\\n            if(nums[i]==k)count++;\\n            for(int j=i+1;j<nums.length;j++){\\n                curr=gcd(nums[j],curr);\\n                if(curr==k)count++;\\n                \\n            }\\n        }\\n        return count;\\n    }\\n\\n public static int gcd(int a,int b){\\n     if(b==0)return a;\\n     return gcd(b,a%b);\\n }\\n\\n\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3196374,
                "title": "a-simple-easy-to-understand-solution-in-java",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int subarrayGCD(int[] nums, int k) {\\n        int ans = 0;\\n        for(int i=0; i<nums.length; i++){\\n            int cur = nums[i];\\n            for(int j=i; j<nums.length; j++){\\n                cur = gcd(cur, nums[j]);\\n                if(cur>k){\\n                    ans+=0;\\n                }\\n                if(cur==k){\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    static int gcd(int a, int b){\\n        if(b==0){\\n            return a;\\n        }\\n        return gcd(b,a%b);\\n    } \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int subarrayGCD(int[] nums, int k) {\\n        int ans = 0;\\n        for(int i=0; i<nums.length; i++){\\n            int cur = nums[i];\\n            for(int j=i; j<nums.length; j++){\\n                cur = gcd(cur, nums[j]);\\n                if(cur>k){\\n                    ans+=0;\\n                }\\n                if(cur==k){\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    static int gcd(int a, int b){\\n        if(b==0){\\n            return a;\\n        }\\n        return gcd(b,a%b);\\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3156645,
                "title": "c-golang",
                "content": "# Code\\n```\\n// C++\\nclass Solution {\\n    int gcd(int m, int n) {\\n        if(n == 0) return m;\\n        return gcd(n, m % n);\\n    }\\npublic:\\n    int subarrayGCD(vector<int>& nums, int k) {\\n        int ans = 0;\\n        for(int i = 0; i < nums.size(); i++) {  \\n            int val = nums[i];\\n            for(int j = i; j < nums.size(); j++) {\\n                val = gcd(val, nums[j]);\\n                if(val == k) ans++;\\n            }   \\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n// Golang\\nfunc gcd(m, n int) int {\\n    if n == 0 {return m}\\n    return gcd(n, m % n)\\n}\\n\\nfunc subarrayGCD(nums []int, k int) int {\\n    var ans int = 0\\n    for i := 0; i < len(nums); i++ {  \\n        var val int = nums[i]\\n        for j := i; j < len(nums); j++ {\\n            val = gcd(val, nums[j])\\n            if val == k {\\n                ans++\\n            }\\n        }   \\n    }\\n    return ans\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Go",
                    "Math",
                    "Number Theory"
                ],
                "code": "```\\n// C++\\nclass Solution {\\n    int gcd(int m, int n) {\\n        if(n == 0) return m;\\n        return gcd(n, m % n);\\n    }\\npublic:\\n    int subarrayGCD(vector<int>& nums, int k) {\\n        int ans = 0;\\n        for(int i = 0; i < nums.size(); i++) {  \\n            int val = nums[i];\\n            for(int j = i; j < nums.size(); j++) {\\n                val = gcd(val, nums[j]);\\n                if(val == k) ans++;\\n            }   \\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n// Golang\\nfunc gcd(m, n int) int {\\n    if n == 0 {return m}\\n    return gcd(n, m % n)\\n}\\n\\nfunc subarrayGCD(nums []int, k int) int {\\n    var ans int = 0\\n    for i := 0; i < len(nums); i++ {  \\n        var val int = nums[i]\\n        for j := i; j < len(nums); j++ {\\n            val = gcd(val, nums[j])\\n            if val == k {\\n                ans++\\n            }\\n        }   \\n    }\\n    return ans\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3151743,
                "title": "c-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\ncheck gcd of every subarray \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can check gcd of every subarray using two nested loops & inbuilt `__gcd` function\\n\\n# Complexity\\n- Time complexity:`O(n^2)`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:`O(1)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int subarrayGCD(vector<int>& nums, int k) {\\n\\n        int n = nums.size() , count = 0;\\n        int i = 0;\\n\\n        while(i < n){\\n            int curr_gcd = nums[i] , j = i++;\\n            while(j < n){\\n                curr_gcd = __gcd(curr_gcd,nums[j++]);\\n                if(k == curr_gcd) count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Iterator",
                    "Number Theory"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subarrayGCD(vector<int>& nums, int k) {\\n\\n        int n = nums.size() , count = 0;\\n        int i = 0;\\n\\n        while(i < n){\\n            int curr_gcd = nums[i] , j = i++;\\n            while(j < n){\\n                curr_gcd = __gcd(curr_gcd,nums[j++]);\\n                if(k == curr_gcd) count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3148151,
                "title": "python-brainstorm-dp-like-gcd-number-sequence-gcd-number-gcd-sequence",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def subarrayGCD(self, nums: List[int], k: int) -> int:\\n\\n        def getGCD(x, y):\\n            if x>y: x,y = y,x\\n            div, mod = divmod(y, x)\\n            if mod == 0: return x\\n            return getGCD(mod, x)\\n        \\n        # init with length 1 sequence\\n        ans = sum(f==k for f in nums)\\n\\n        # iterate to length 2->len(nums) sequence \\n        for i in range(1, len(nums)): \\n            for j in range(len(nums)-i):\\n                x = nums[j] # check the sequence with length = i+1, start from j\\n                y = nums[j+1] # y contains the gcd of sequence with length i, starting from j+1\\n                gcd = getGCD(x, y)\\n                nums[j] = gcd # update j with the gcd (the gcd of a number and a sequence equals the gcd of the number and the gcd of the sequence )\\n                if gcd == k: ans += 1\\n        return ans\\n                    \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def subarrayGCD(self, nums: List[int], k: int) -> int:\\n\\n        def getGCD(x, y):\\n            if x>y: x,y = y,x\\n            div, mod = divmod(y, x)\\n            if mod == 0: return x\\n            return getGCD(mod, x)\\n        \\n        # init with length 1 sequence\\n        ans = sum(f==k for f in nums)\\n\\n        # iterate to length 2->len(nums) sequence \\n        for i in range(1, len(nums)): \\n            for j in range(len(nums)-i):\\n                x = nums[j] # check the sequence with length = i+1, start from j\\n                y = nums[j+1] # y contains the gcd of sequence with length i, starting from j+1\\n                gcd = getGCD(x, y)\\n                nums[j] = gcd # update j with the gcd (the gcd of a number and a sequence equals the gcd of the number and the gcd of the sequence )\\n                if gcd == k: ans += 1\\n        return ans\\n                    \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3139707,
                "title": "c-o-n-2-log-n-approach",
                "content": "```\\n#include<algorithm>\\n#include<bits/stdc++.h>\\nclass Solution {\\npublic:\\n    int subarrayGCD(vector<int>& nums, int k) {\\n        int count=0;\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=i;j<nums.size();j++){\\n                int temp=__gcd(nums[i],nums[j]);\\n                nums[i]=temp;\\n                if(temp==k){\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include<algorithm>\\n#include<bits/stdc++.h>\\nclass Solution {\\npublic:\\n    int subarrayGCD(vector<int>& nums, int k) {\\n        int count=0;\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=i;j<nums.size();j++){\\n                int temp=__gcd(nums[i],nums[j]);\\n                nums[i]=temp;\\n                if(temp==k){\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3104442,
                "title": "java-solution-easy-to-understand-explained-with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int subarrayGCD(int[] nums, int k) {\\n        int res=0;\\n        for(int i=0;i<nums.length;i++){\\n            int l=nums[i];\\n            if(l==k)res++;//if the current element is equal to k then we increment the res\\n            for(int j=i+1;j<nums.length;j++){\\n                l=gcd(l,nums[j]);//finding gcd and increment the res if the gcd is equal to k\\n                if(l==k)res++;\\n            }\\n        }\\n        return res;\\n    }\\n    public int gcd(int a,int b){\\n        if(b==0)return a;\\n        return gcd(b,a%b);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int subarrayGCD(int[] nums, int k) {\\n        int res=0;\\n        for(int i=0;i<nums.length;i++){\\n            int l=nums[i];\\n            if(l==k)res++;//if the current element is equal to k then we increment the res\\n            for(int j=i+1;j<nums.length;j++){\\n                l=gcd(l,nums[j]);//finding gcd and increment the res if the gcd is equal to k\\n                if(l==k)res++;\\n            }\\n        }\\n        return res;\\n    }\\n    public int gcd(int a,int b){\\n        if(b==0)return a;\\n        return gcd(b,a%b);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3017897,
                "title": "2447-number-of-subarrays-with-gcd-equal-to-k",
                "content": "```\\nclass Solution {\\n    public int subarrayGCD(int[] nums, int k) {\\n        int c=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]==k) \\n                c++;\\n            int xx=0;\\n            for(int j=i+1;j<nums.length;j++)\\n            {\\n                \\n                if(j==i+1)\\n                {  \\n                    xx=gcd(nums[i],nums[j]);\\n                }\\n                else\\n                {\\n                    xx = gcd(xx, nums[j]);\\n                }\\n                \\n                if(xx==k)\\n                    {\\n                       c++;\\n                    }\\n                else if(xx < k) \\n                    break;\\n            }\\n        }\\n        return c;\\n    }\\n    static int gcd(int a,int b)\\n    {\\n        if(b==0) return a;\\n        return gcd(b, a%b);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int subarrayGCD(int[] nums, int k) {\\n        int c=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]==k) \\n                c++;\\n            int xx=0;\\n            for(int j=i+1;j<nums.length;j++)\\n            {\\n                \\n                if(j==i+1)\\n                {  \\n                    xx=gcd(nums[i],nums[j]);\\n                }\\n                else\\n                {\\n                    xx = gcd(xx, nums[j]);\\n                }\\n                \\n                if(xx==k)\\n                    {\\n                       c++;\\n                    }\\n                else if(xx < k) \\n                    break;\\n            }\\n        }\\n        return c;\\n    }\\n    static int gcd(int a,int b)\\n    {\\n        if(b==0) return a;\\n        return gcd(b, a%b);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2997675,
                "title": "c-easy-simple-with-approach",
                "content": "# Approach \\nLookinf at the constraints, it is possible to find all subarrays using 0(N^2) time complexity and using __gcd stl function with O(log(min(a,b))) time comp. to find GCD of each subarray\\n\\n# Complexity\\n- Time complexity: O(N*NlogK)\\n\\n- Space complexity: O(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int subarrayGCD(vector<int>& nums, int k) {\\n        int cnt=0, n;\\n        for(int i=0; i<nums.size(); i++){\\n            n=nums[i];\\n            for(int j=i; j<nums.size(); j++){\\n                n=__gcd(n, nums[j]);\\n                if(n==k) cnt++;\\n            }\\n        }\\n\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subarrayGCD(vector<int>& nums, int k) {\\n        int cnt=0, n;\\n        for(int i=0; i<nums.size(); i++){\\n            n=nums[i];\\n            for(int j=i; j<nums.size(); j++){\\n                n=__gcd(n, nums[j]);\\n                if(n==k) cnt++;\\n            }\\n        }\\n\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2992604,
                "title": "c-easy-solution-forloop",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int subarrayGCD(vector<int>& nums, int k) {\\n        int m=0;\\n        for(int i=0;i<nums.size();i++){\\n            int  cur=0;\\n            for(int j=i;j<nums.size();j++){\\n            cur= gcd(cur,nums[j]);\\n            if(cur==k)\\n            m++;\\n            }\\n        }\\n        return m;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subarrayGCD(vector<int>& nums, int k) {\\n        int m=0;\\n        for(int i=0;i<nums.size();i++){\\n            int  cur=0;\\n            for(int j=i;j<nums.size();j++){\\n            cur= gcd(cur,nums[j]);\\n            if(cur==k)\\n            m++;\\n            }\\n        }\\n        return m;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2992602,
                "title": "easy-c-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int subarrayGCD(vector<int>& nums, int k) {\\n        int c=0;\\n        for(int i=0;i<nums.size();i++){\\n            int curg=0;\\n            for(int j=i;j<nums.size();j++){\\n                 curg=gcd(curg,nums[j]);\\n                 if(curg==k){\\n                 c+=1;\\n                 }\\n            }\\n        }\\n        return c;\\n        \\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subarrayGCD(vector<int>& nums, int k) {\\n        int c=0;\\n        for(int i=0;i<nums.size();i++){\\n            int curg=0;\\n            for(int j=i;j<nums.size();j++){\\n                 curg=gcd(curg,nums[j]);\\n                 if(curg==k){\\n                 c+=1;\\n                 }\\n            }\\n        }\\n        return c;\\n        \\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2948227,
                "title": "c-brute-force-t-c-o-n-n-log-n-s-c-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n\\t\\n\\t/*\\n\\t\\tT.C. : O(N*N*log(N))\\n\\t\\tS.C. : O(1)\\n\\t*/\\n\\n    int subarrayGCD(vector<int>& nums, int k) {\\n        int ans = 0, n = nums.size();\\n        \\n        for(int i=0; i<n; i++){\\n            int temp = nums[i];\\n            for(int j=i; j<n; j++){\\n                temp = __gcd(nums[j], temp);\\n                \\n                if(temp < k) break;\\n                \\n                if(temp == k) ans++;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\t\\n\\t/*\\n\\t\\tT.C. : O(N*N*log(N))\\n\\t\\tS.C. : O(1)\\n\\t*/\\n\\n    int subarrayGCD(vector<int>& nums, int k) {\\n        int ans = 0, n = nums.size();\\n        \\n        for(int i=0; i<n; i++){\\n            int temp = nums[i];\\n            for(int j=i; j<n; j++){\\n                temp = __gcd(nums[j], temp);\\n                \\n                if(temp < k) break;\\n                \\n                if(temp == k) ans++;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2932004,
                "title": "c",
                "content": "```\\nint findGCD(int a, int b){\\n    int M , m;\\n    if(a >= b){\\n        M = a;\\n        m = b;\\n    }\\n    else{\\n        M = b;\\n        m = a;\\n    }\\n    int tmp;\\n    while(m > 0){\\n        tmp = M % m;\\n        M = m;\\n        m = tmp;\\n    }\\n    return M;\\n}\\nint subarrayGCD(int* nums, int numsSize, int k){\\n    int ans = 0;\\n    int n = numsSize;\\n    for(int i = 0; i < n; i++){\\n        if(nums[i] < k)\\n            continue;\\n        int gcd = nums[i];\\n        if(gcd == k)\\n            ans++;\\n        for(int j = i+1; j < n; j++){\\n            gcd = findGCD(gcd, nums[j]);\\n            if(gcd == k)\\n                ans++;\\n            if(gcd < k)\\n                break;\\n        }\\n    }\\n    return ans;\\n\\n}\\n```",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nint findGCD(int a, int b){\\n    int M , m;\\n    if(a >= b){\\n        M = a;\\n        m = b;\\n    }\\n    else{\\n        M = b;\\n        m = a;\\n    }\\n    int tmp;\\n    while(m > 0){\\n        tmp = M % m;\\n        M = m;\\n        m = tmp;\\n    }\\n    return M;\\n}\\nint subarrayGCD(int* nums, int numsSize, int k){\\n    int ans = 0;\\n    int n = numsSize;\\n    for(int i = 0; i < n; i++){\\n        if(nums[i] < k)\\n            continue;\\n        int gcd = nums[i];\\n        if(gcd == k)\\n            ans++;\\n        for(int j = i+1; j < n; j++){\\n            gcd = findGCD(gcd, nums[j]);\\n            if(gcd == k)\\n                ans++;\\n            if(gcd < k)\\n                break;\\n        }\\n    }\\n    return ans;\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2895976,
                "title": "c-straightforward",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int gcd(int a, int b){\\n        return b == 0 ? a : gcd(b, a % b);\\n    }\\n\\n    int subarrayGCD(vector<int>& nums, int k) {\\n        int res = 0;\\n        for(int i = 0; i < nums.size(); i++){\\n            res += nums[i] == k;\\n            int mod = nums[i];\\n            for(int j = i + 1; j < nums.size(); j++){\\n                int tmp = gcd(nums[i], nums[j]);  \\n                mod = gcd(mod, tmp);  //get the mimumum mod in subarray\\n                if(mod == k) res++;\\n                else if(mod < k) break;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int gcd(int a, int b){\\n        return b == 0 ? a : gcd(b, a % b);\\n    }\\n\\n    int subarrayGCD(vector<int>& nums, int k) {\\n        int res = 0;\\n        for(int i = 0; i < nums.size(); i++){\\n            res += nums[i] == k;\\n            int mod = nums[i];\\n            for(int j = i + 1; j < nums.size(); j++){\\n                int tmp = gcd(nums[i], nums[j]);  \\n                mod = gcd(mod, tmp);  //get the mimumum mod in subarray\\n                if(mod == k) res++;\\n                else if(mod < k) break;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2894604,
                "title": "o-n-solution-with-a-edge-case-in-c",
                "content": "For k==1,we are running Brute force\\nBut for every other value here is a O(n) solution\\n,,,\\n\\n\\t\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\tint gcd(int a,int b)\\n\\t\\t{\\n\\t\\t\\twhile(a!=b)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(a>b)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\ta=a-b;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t b=b-a;\\n\\t\\t\\t}\\n\\t\\t\\treturn a;\\n\\t\\t}\\n\\n\\n\\n    int subarrayGCD(vector<int>& nums, int k) {\\n        int sum=0;\\n      \\n           int inc=1;\\n        if(k==1)\\n        {\\n             int count = 0;\\n        \\n        // [1] we try checking every subarray\\n            for (int i = 0; i < nums.size(); i++)\\n            {\\n                int g = nums[i];\\n                for (int j = i; j < nums.size(); j++)\\n                {\\n                    g = gcd(g, nums[j]);\\n                    if (g == k) count += 1;\\n\\n                    // [2] occasionally, many of them fail\\n                    if (g < k)  break;\\n                }\\n            }\\n            \\n        return count;\\n\\n        }\\n          else\\n          {\\n             \\n             for(int j=0;j<nums.size()-1;j++)\\n             {\\n                 if(gcd(nums[j],nums[j+1])==k)\\n                 {\\n                     sum=sum+inc;\\n                                  inc++;                   //till we finding gcd in same subarry we incrementing count and also inc\\n                 }\\n                 else\\n                 {\\n                     inc=1;\\n                     //break;\\n                 }\\n\\n             }\\n        \\n                for(int i=0;i<nums.size();i++)            //this loop is for checking the elements in array which is equal to k\\n                {\\n                    if(nums[i]==k)\\n                        sum++;\\n\\n\\n                }   \\n          }\\n        \\n        return sum;\\n       \\n    }\\n};\\n\\n\\n\\n\\n\\'\\'\\'",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\tint gcd(int a,int b)\\n\\t\\t{\\n\\t\\t\\twhile(a!=b)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(a>b)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\ta=a-b;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2844799,
                "title": "python3-sliding-gcd-and-early-stopping-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe know that the gcd of 2+ numbers can only be decreasing or staying as it can only be as high as the smallest number in the array.\\n\\nAlso we should know that gcd(x, y, z) = gcd(x, gcd(y,z))\\n\\nThis gives us a formula for updating the gcd in a sliding window.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nWe update the gcd in every iteration of the nested loop using the previous gcd. \\n\\nOur early stopping criteria are:\\n1) If the first number in the array is not divisable by k we cann immediately proceed as k can never be gcd of the array then\\n2) If the gcd goes below k we can immediately stop as gcd will never grow again\\n\\nEvery time we encounter the gcd beeing k, we increase the counter.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nWorst case: O(N^2*O(log(k)), where O(log(min(a, b)) is the complexity of the gcd algorithm and k is the searched gcd.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1) no extra space required.\\n# Code\\n```\\nimport math\\n\\nclass Solution:\\n    def subarrayGCD(self, nums: List[int], k: int) -> int:\\n\\n        # bruteforce the solution with sliding window\\n        result = 0\\n        for idx, num1 in enumerate(nums):\\n\\n            # the gcd can only be the number and decrease during th\\n            # second loop\\n            if num1 % k:\\n                continue\\n            gcd = num1\\n            # go through all subarrays starting at this point\\n            for num2 in nums[idx:]:\\n\\n                # get the new gcd\\n                gcd = math.gcd(num2, gcd)\\n\\n                # check whether it is equal than we increase the\\n                # counter\\n                # if it is lower we can break, as gcd will never\\n                # increase\\n                if gcd == k:\\n                    result += 1\\n                if gcd < k:\\n                    break\\n        return result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport math\\n\\nclass Solution:\\n    def subarrayGCD(self, nums: List[int], k: int) -> int:\\n\\n        # bruteforce the solution with sliding window\\n        result = 0\\n        for idx, num1 in enumerate(nums):\\n\\n            # the gcd can only be the number and decrease during th\\n            # second loop\\n            if num1 % k:\\n                continue\\n            gcd = num1\\n            # go through all subarrays starting at this point\\n            for num2 in nums[idx:]:\\n\\n                # get the new gcd\\n                gcd = math.gcd(num2, gcd)\\n\\n                # check whether it is equal than we increase the\\n                # counter\\n                # if it is lower we can break, as gcd will never\\n                # increase\\n                if gcd == k:\\n                    result += 1\\n                if gcd < k:\\n                    break\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2835238,
                "title": "python-simple-maths",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def subarrayGCD(self, nums, k):\\n        n, count = len(nums), 0\\n\\n        for i in range(n):\\n            ans = nums[i]\\n            for j in range(i,n):\\n                ans = math.gcd(ans,nums[j])\\n                if ans == k:\\n                    count += 1\\n                elif ans < k:\\n                    break\\n\\n        return count\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def subarrayGCD(self, nums, k):\\n        n, count = len(nums), 0\\n\\n        for i in range(n):\\n            ans = nums[i]\\n            for j in range(i,n):\\n                ans = math.gcd(ans,nums[j])\\n                if ans == k:\\n                    count += 1\\n                elif ans < k:\\n                    break\\n\\n        return count\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832275,
                "title": "cpp-easy-12ms",
                "content": "```\\nclass Solution {\\npublic:\\n    int gcd(int a, int b){\\n        if(a==0)\\n            return b;\\n        return gcd(b%a,a);\\n    }\\n    int subarrayGCD(vector<int>& nums, int k) {\\n        int ct=0;\\n        int sz = nums.size();\\n        for(int i=0; i<sz; ++i){\\n            int temp_gcd = nums[i];\\n            if(temp_gcd==k) ct++;\\n            for(int j=i+1; j<sz; ++j){\\n                temp_gcd = gcd(temp_gcd, nums[j]);\\n                if(temp_gcd<k)\\n                    break;\\n                if(temp_gcd==k)\\n                    ct++;\\n            }\\n        }\\n        return ct;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int gcd(int a, int b){\\n        if(a==0)\\n            return b;\\n        return gcd(b%a,a);\\n    }\\n    int subarrayGCD(vector<int>& nums, int k) {\\n        int ct=0;\\n        int sz = nums.size();\\n        for(int i=0; i<sz; ++i){\\n            int temp_gcd = nums[i];\\n            if(temp_gcd==k) ct++;\\n            for(int j=i+1; j<sz; ++j){\\n                temp_gcd = gcd(temp_gcd, nums[j]);\\n                if(temp_gcd<k)\\n                    break;\\n                if(temp_gcd==k)\\n                    ct++;\\n            }\\n        }\\n        return ct;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2826931,
                "title": "try-all-subarrays-optimisation",
                "content": "Try all subarrays.\\n\\n**Optimisation:**\\nAs you calculate the GCD of more numbers, it can only become smaller. Once it becomes smaller than k, you know that any larger subarrays containing all the current elements will not work.\\n\\n**C++ Code:**\\n```\\nclass Solution {\\npublic:\\n    int subarrayGCD(vector<int>& nums, int k) {\\n        int ans = 0;\\n        for (int i = 0; i < nums.size(); i++) {\\n            int curr = nums[i];\\n            for (int j = i; j < nums.size(); j++) {\\n                curr = gcd(curr, nums[j]);\\n                if (curr == k)\\n                    ans++;\\n                else if (curr < k) \\n                    break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nSimilar problem:\\nhttps://leetcode.com/problems/number-of-subarrays-with-lcm-equal-to-k/\\n\\n**C++ Code for LCM Problem:**\\n```\\nclass Solution {\\n    int findLCM(int a, int b) {\\n        return a*b / gcd(a,b);\\n    }\\npublic:\\n    int subarrayLCM(vector<int>& nums, int k) {\\n        int ans = 0;\\n        for (int i = 0; i < nums.size(); i++) {\\n            int curr = nums[i];\\n            for (int j = i; j < nums.size(); j++) {\\n                curr = findLCM(curr, nums[j]);\\n                if (curr == k) \\n                    ans++;\\n                else if (curr > k) \\n                    break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int subarrayGCD(vector<int>& nums, int k) {\\n        int ans = 0;\\n        for (int i = 0; i < nums.size(); i++) {\\n            int curr = nums[i];\\n            for (int j = i; j < nums.size(); j++) {\\n                curr = gcd(curr, nums[j]);\\n                if (curr == k)\\n                    ans++;\\n                else if (curr < k) \\n                    break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    int findLCM(int a, int b) {\\n        return a*b / gcd(a,b);\\n    }\\npublic:\\n    int subarrayLCM(vector<int>& nums, int k) {\\n        int ans = 0;\\n        for (int i = 0; i < nums.size(); i++) {\\n            int curr = nums[i];\\n            for (int j = i; j < nums.size(); j++) {\\n                curr = findLCM(curr, nums[j]);\\n                if (curr == k) \\n                    ans++;\\n                else if (curr > k) \\n                    break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2824300,
                "title": "fast-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n->61 ms\\n- Space complexity:\\n-> 9 MB\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int subarrayGCD(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            int x=nums[i];\\n            for(int j=i;j<n;j++){\\n                x=__gcd(x,nums[j]);\\n                if(x==k){\\n                    ans++;\\n                }\\n            }\\n        }\\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subarrayGCD(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            int x=nums[i];\\n            for(int j=i;j<n;j++){\\n                x=__gcd(x,nums[j]);\\n                if(x==k){\\n                    ans++;\\n                }\\n            }\\n        }\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2821397,
                "title": "best-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int subarrayGCD(vector<int>& nums, int k) {\\n        int re=0;\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=i;j<nums.size();j++){nums[i]=gcd(nums[i],nums[j]);\\n                if(gcd(nums[i],nums[j])==k)re++;\\n                if(gcd(nums[i],nums[j])<k)break;\\n            }\\n        }return re;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subarrayGCD(vector<int>& nums, int k) {\\n        int re=0;\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=i;j<nums.size();j++){nums[i]=gcd(nums[i],nums[j]);\\n                if(gcd(nums[i],nums[j])==k)re++;\\n                if(gcd(nums[i],nums[j])<k)break;\\n            }\\n        }return re;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2821165,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int subarrayGCD(vector<int>& nums, int k) {\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==k) ans++;\\n        }\\n        for(int i=0;i<nums.size();i++){\\n            int gcd=nums[i];\\n            for(int j=i+1;j<nums.size();j++){\\n                if(nums[j]%k!=0) break;\\n                gcd=__gcd(gcd,nums[j]);\\n                if(gcd==k) ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n//Please upvote if you like the code ..",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subarrayGCD(vector<int>& nums, int k) {\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==k) ans++;\\n        }\\n        for(int i=0;i<nums.size();i++){\\n            int gcd=nums[i];\\n            for(int j=i+1;j<nums.size();j++){\\n                if(nums[j]%k!=0) break;\\n                gcd=__gcd(gcd,nums[j]);\\n                if(gcd==k) ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2818940,
                "title": "python-solution-2-solutions-easy-understanding",
                "content": "**1ST SOLUTION WITH BUILT-IN FUNCTION**\\n```\\nimport math\\nclass Solution:\\n    def subarrayGCD(self, nums: List[int], k: int) -> int:\\n        c=0\\n        for i in range(len(nums)):\\n            x=nums[i]\\n            for j in range(i,len(nums)):\\n                x=math.gcd(x,nums[j])\\n                if x==k:\\n                    c+=1 \\n        return c \\n        \\n``` \\n**2ND SOLUTION WITHOUT BUILT-IN FUNCTION** \\n\\n```\\nclass Solution:\\n    def subarrayGCD(self, nums: List[int], k: int) -> int:\\n        c=0\\n        for i in range(len(nums)):\\n            x=nums[i]\\n            for j in range(i,len(nums)):\\n                x=computeGCD(x,nums[j])\\n                if x==k:\\n                    c+=1 \\n        return c \\n    \\ndef computeGCD(x, y):\\n    while(y):\\n        x, y = y, x % y\\n    return x\\n        \\n```\\n**Please upvote if you found the solution helpful**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nimport math\\nclass Solution:\\n    def subarrayGCD(self, nums: List[int], k: int) -> int:\\n        c=0\\n        for i in range(len(nums)):\\n            x=nums[i]\\n            for j in range(i,len(nums)):\\n                x=math.gcd(x,nums[j])\\n                if x==k:\\n                    c+=1 \\n        return c \\n        \\n```\n```\\nclass Solution:\\n    def subarrayGCD(self, nums: List[int], k: int) -> int:\\n        c=0\\n        for i in range(len(nums)):\\n            x=nums[i]\\n            for j in range(i,len(nums)):\\n                x=computeGCD(x,nums[j])\\n                if x==k:\\n                    c+=1 \\n        return c \\n    \\ndef computeGCD(x, y):\\n    while(y):\\n        x, y = y, x % y\\n    return x\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2816118,
                "title": "just-a-small-proof-of-why-hcf-lcm-product",
                "content": "LCM(x,y) * GCD(x,y) = x * y  \\n\\n\\nTHIS IS ONLY VALID FOR 2 VARIABLES \\nFAILS IF USED FOR MULTIVARIABLES\\n\\n\\nproof 1:\\n\\nLet us express both numbers in their prime factorisation. Note that by the fundamental theorem of arithmetic, any number can be only represented in one prime factorisation:\\n\\nX=2a\\u22173b\\u22175c\\u22177d\\u22EF(1)\\nY=2p\\u22173q\\u22175r\\u22177s\\u22EF(2)\\nThe highest common factor of X,Y is 2min(a,p)\\u22173min(b,q)\\u22175min(c,r)\\u22EF, which multiplies the smallest powers of 2, 3, 5 and so on.\\n\\nThe lowest common multiple is 2max(a,p)\\u22173max(b,q)\\u22175max(c,r)\\u22EF, which multiplies the largest powers of 2, 3, 5 and so on.\\n\\nSince one number cannot have a power which is both the smallest and largest, then HCF(X,Y)\\u2217LCM(X,Y)=2a2p\\u22173b3q\\u22175c5r\\u22EF in some order. This is equal to (1) multiplied by (2), which is equal to X multiplied by Y.\\n\\n\\n\\nproof 2:\\n\\n\\nGiven two numbers, a,b, let d:=gcd(a,b) and then f:=a/d and g:=b/d, giving a=df and b=dg.\\n\\nNow we know that the least common multiple, c, of a and b has to be divisible by df and by dg. We also know that f and g have no common factors (otherwise d would be bigger by that factor). So c=dfg is the smallest number that can fulfill all these requirements.\\n\\nThen ab=df\\u22C5dg=d\\u22C5dfg=gcd\\u22C5lcm\\n\\n\\n\\nproof 3:\\n\\n\\nLet c = gcd(a,b)\\nThen a = c*x for some x, and b = c*y for some y.\\nx and y are coprime by defintion of gcd.\\n\\nBy definition, lcm(a,b) is divisible by a=c*x and b=c*y, therefore\\nlcm(a,b) = c*x*y (since x and y are coprime)\\n\\nlcm(a,b)*gcd(a,b) = (c^2)*x*y = (c*x)*(c*y) = a*b",
                "solutionTags": [],
                "code": "LCM(x,y) * GCD(x,y) = x * y  \\n\\n\\nTHIS IS ONLY VALID FOR 2 VARIABLES \\nFAILS IF USED FOR MULTIVARIABLES\\n\\n\\nproof 1:\\n\\nLet us express both numbers in their prime factorisation. Note that by the fundamental theorem of arithmetic, any number can be only represented in one prime factorisation:\\n\\nX=2a\\u22173b\\u22175c\\u22177d\\u22EF(1)\\nY=2p\\u22173q\\u22175r\\u22177s\\u22EF(2)\\nThe highest common factor of X,Y is 2min(a,p)\\u22173min(b,q)\\u22175min(c,r)\\u22EF, which multiplies the smallest powers of 2, 3, 5 and so on.\\n\\nThe lowest common multiple is 2max(a,p)\\u22173max(b,q)\\u22175max(c,r)\\u22EF, which multiplies the largest powers of 2, 3, 5 and so on.\\n\\nSince one number cannot have a power which is both the smallest and largest, then HCF(X,Y)\\u2217LCM(X,Y)=2a2p\\u22173b3q\\u22175c5r\\u22EF in some order. This is equal to (1) multiplied by (2), which is equal to X multiplied by Y.\\n\\n\\n\\nproof 2:\\n\\n\\nGiven two numbers, a,b, let d:=gcd(a,b) and then f:=a/d and g:=b/d, giving a=df and b=dg.\\n\\nNow we know that the least common multiple, c, of a and b has to be divisible by df and by dg. We also know that f and g have no common factors (otherwise d would be bigger by that factor). So c=dfg is the smallest number that can fulfill all these requirements.\\n\\nThen ab=df\\u22C5dg=d\\u22C5dfg=gcd\\u22C5lcm\\n\\n\\n\\nproof 3:\\n\\n\\nLet c = gcd(a,b)\\nThen a = c*x for some x, and b = c*y for some y.\\nx and y are coprime by defintion of gcd.\\n\\nBy definition, lcm(a,b) is divisible by a=c*x and b=c*y, therefore\\nlcm(a,b) = c*x*y (since x and y are coprime)\\n\\nlcm(a,b)*gcd(a,b) = (c^2)*x*y = (c*x)*(c*y) = a*b",
                "codeTag": "Unknown"
            },
            {
                "id": 2814449,
                "title": "2447-number-of-subarrays-with-gcd-equal-to-k-python3-gcd-recursive",
                "content": "# Code\\n```\\nclass Solution:\\n    def subarrayGCD(self, nums: List[int], k: int) -> int:\\n        c=0\\n        for i in range(len(nums)):\\n            a=nums[i]\\n            for j in range(i,len(nums)):\\n                a=gcd(a,nums[j])\\n                if a==k:\\n                    c+=1\\n        return c\\n\\ndef gcd(a,b):\\n    if b==0:\\n        return abs(a)\\n    else:\\n        return gcd(b,a%b)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def subarrayGCD(self, nums: List[int], k: int) -> int:\\n        c=0\\n        for i in range(len(nums)):\\n            a=nums[i]\\n            for j in range(i,len(nums)):\\n                a=gcd(a,nums[j])\\n                if a==k:\\n                    c+=1\\n        return c\\n\\ndef gcd(a,b):\\n    if b==0:\\n        return abs(a)\\n    else:\\n        return gcd(b,a%b)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2812950,
                "title": "javascript-solution",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar subarrayGCD = function(nums, k) {\\n    let res = 0;\\n    for(let i=0; i<nums.length; i++){\\n        let num = nums[i];\\n        for(let j=i; j<nums.length; j++){\\n            num = gcd(num, nums[j]);\\n            if(num === k){\\n                res ++;\\n            }else if(num < k){\\n                break;\\n            }\\n        }\\n        \\n    }\\n    return res;  \\n};\\n\\nfunction gcd(a, b) {\\n    let max = Math.max(a, b);\\n    let min = Math.min(a, b);\\n    if (max % min === 0) {\\n        return min;\\n    } else {\\n        return gcd(max % min, min);\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar subarrayGCD = function(nums, k) {\\n    let res = 0;\\n    for(let i=0; i<nums.length; i++){\\n        let num = nums[i];\\n        for(let j=i; j<nums.length; j++){\\n            num = gcd(num, nums[j]);\\n            if(num === k){\\n                res ++;\\n            }else if(num < k){\\n                break;\\n            }\\n        }\\n        \\n    }\\n    return res;  \\n};\\n\\nfunction gcd(a, b) {\\n    let max = Math.max(a, b);\\n    let min = Math.min(a, b);\\n    if (max % min === 0) {\\n        return min;\\n    } else {\\n        return gcd(max % min, min);\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2811834,
                "title": "c-easy",
                "content": "# Code:\\n```\\nclass Solution {\\npublic:\\n    int subarrayGCD(vector<int>& nums, int k) {\\n        int n= nums.size();\\n        int ans=0;\\n\\n        for(int i=0; i<n; i++){\\n            int currGcd= nums[i];\\n\\n            for(int j=i; j<n; j++){\\n                currGcd= gcd(currGcd, nums[j]);\\n\\n                if(currGcd==k) ans++;\\n                if(currGcd<k) break;\\n            }\\n        }      \\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subarrayGCD(vector<int>& nums, int k) {\\n        int n= nums.size();\\n        int ans=0;\\n\\n        for(int i=0; i<n; i++){\\n            int currGcd= nums[i];\\n\\n            for(int j=i; j<n; j++){\\n                currGcd= gcd(currGcd, nums[j]);\\n\\n                if(currGcd==k) ans++;\\n                if(currGcd<k) break;\\n            }\\n        }      \\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2811605,
                "title": "have-a-look-into-my-java-8-ms-solution",
                "content": "# Intuition\\neach time we are going to check the current element gcd. \\nif the current gcd is less than k then no way will the subsequent elements can make the gcd equal to k starting from current element .(do a dry run with the 1st test case u will get it ) \\n\\nIf by chance gcd is more then or equal to k we will try to get all the gcds with all subsequent elements until the gcd falls below k . \\n\\n\\n\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n  O(n^2) in worst case \\n\\n\\n# Code\\n```\\nclass Solution {\\n    int findGCD(int a,int b){\\n       while(a!=b){\\n           if(a>b)\\n               a=a-b;\\n           else\\n                b=b-a;\\n       }\\n       return b;\\n    }//find gcd of two numbers \\n\\n    public int subarrayGCD(int[] A, int k) {\\n        int cnt=0;\\n        int gcd=0;\\n        int n=A.length;\\n\\n        for(int i=0;i<n;i++){\\n            gcd=findGCD(A[i],A[i]);\\n            if(gcd==k)\\n                 cnt++;\\n\\n            if(gcd<k)\\n                   continue;\\n            for(int j=i+1;j<n;j++){\\n                gcd=findGCD(gcd,A[j]);\\n                if(gcd==k)\\n                     cnt++;\\n\\n                if(gcd<k)\\n                    break;\\n            }\\n        }//\\n\\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int findGCD(int a,int b){\\n       while(a!=b){\\n           if(a>b)\\n               a=a-b;\\n           else\\n                b=b-a;\\n       }\\n       return b;\\n    }//find gcd of two numbers \\n\\n    public int subarrayGCD(int[] A, int k) {\\n        int cnt=0;\\n        int gcd=0;\\n        int n=A.length;\\n\\n        for(int i=0;i<n;i++){\\n            gcd=findGCD(A[i],A[i]);\\n            if(gcd==k)\\n                 cnt++;\\n\\n            if(gcd<k)\\n                   continue;\\n            for(int j=i+1;j<n;j++){\\n                gcd=findGCD(gcd,A[j]);\\n                if(gcd==k)\\n                     cnt++;\\n\\n                if(gcd<k)\\n                    break;\\n            }\\n        }//\\n\\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2810594,
                "title": "java-simple-solution-explained-hashmap",
                "content": "# Hey leetcoders, this question is pretty much similar to this question ...\\n2470. https://leetcode.com/problems/number-of-subarrays-with-lcm-equal-to-k/\\n\\nSolution : https://leetcode.com/problems/number-of-subarrays-with-lcm-equal-to-k/discuss/2810508/Java-Simple-Solution-(explained)-HashMap\\n\\n---\\n\\n# ***Explanation \\uD83D\\uDC47***\\n* Create a map `Map<Integer,Integer> map` storing `nums[i]` as key and `frequency[nums[i]]` as value\\n* Create a `count` variable to store the subarray count\\n* Iterate over the nums array and store `nums[i]` with its frequency in `map`\\n* Create another map to `Map<Integer,Integer> map2 ` store the gcd of every 2 numbers\\n*  Now, to get gcd of 2 number we can create a `gcd(a,b)` function\\n* So if our `gcd(a,b) == k` then we will increase `count` with `freq` as that value will be included everytime same duplicate element is reached\\n* Then just put `gcd(a,b)` in the `map2` with its `count`\\n* Here lastly our `map` becomes `map2` and `return count`\\n---\\n\\n# \\u2615 *Java Code \\uD83D\\uDC47*\\n```\\nclass Solution {\\n    public int subarrayGCD(int[] nums, int k) {\\n        Map<Integer,Integer> map = new HashMap<>();\\n        int count = 0;\\n        for(int i=0;i<nums.length;i++){\\n            map.put(nums[i],map.getOrDefault(nums[i],0)+1);\\n            Map<Integer,Integer> map2 = new HashMap<>();\\n            for(Map.Entry<Integer,Integer> entry : map.entrySet()){\\n                int key = entry.getKey();\\n                int value = entry.getValue();\\n                \\n                int hcf = gcd(key,nums[i]);\\n                if(hcf ==  k) count += value;\\n                map2.put(hcf,map2.getOrDefault(hcf,0)+value);\\n                map = map2;\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    static int gcd(int a,int b){\\n        if(b == 0){\\n            return a;\\n        }\\n        return gcd(b,a%b);\\n    }\\n}\\n```\\n\\n# *Complexity Analysis \\uD83D\\uDC47*\\n\\n\\u2705 **Time Complexity ~ O(n * log(k))**\\n\\u2705 **Space Complexity ~ O(n * log(k))**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int subarrayGCD(int[] nums, int k) {\\n        Map<Integer,Integer> map = new HashMap<>();\\n        int count = 0;\\n        for(int i=0;i<nums.length;i++){\\n            map.put(nums[i],map.getOrDefault(nums[i],0)+1);\\n            Map<Integer,Integer> map2 = new HashMap<>();\\n            for(Map.Entry<Integer,Integer> entry : map.entrySet()){\\n                int key = entry.getKey();\\n                int value = entry.getValue();\\n                \\n                int hcf = gcd(key,nums[i]);\\n                if(hcf ==  k) count += value;\\n                map2.put(hcf,map2.getOrDefault(hcf,0)+value);\\n                map = map2;\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    static int gcd(int a,int b){\\n        if(b == 0){\\n            return a;\\n        }\\n        return gcd(b,a%b);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2810013,
                "title": "easy-c-code",
                "content": "class Solution {\\npublic:\\n    int subarrayGCD(vector<int>& nums, int k) {\\n        \\n        int cnt(0);\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int num = nums[i];\\n            for(int j=i;j<nums.size();j++)\\n            {\\n                num = __gcd(num,nums[j]);\\n                \\n                if(num==k)\\n                    cnt++;\\n                if(num<k)\\n                    break;\\n            }\\n        }\\n        return cnt;\\n    }\\n};",
                "solutionTags": [
                    "Math"
                ],
                "code": "class Solution {\\npublic:\\n    int subarrayGCD(vector<int>& nums, int k) {\\n        \\n        int cnt(0);\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int num = nums[i];\\n            for(int j=i;j<nums.size();j++)\\n            {\\n                num = __gcd(num,nums[j]);\\n                \\n                if(num==k)\\n                    cnt++;\\n                if(num<k)\\n                    break;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2808737,
                "title": "java-greedy",
                "content": "```\\nclass Solution {\\n    public int subarrayGCD(int[] nums, int k) {\\n        int res = 0;\\n        int len = nums.length;\\n    \\n        int j = 0;\\n        int i = 0;\\n        \\n        while(i< len){\\n            j = i;\\n            int GCD = nums[j];\\n            while(j < len){\\n                GCD = gcd(GCD,nums[j]);\\n                if(GCD == k){\\n                   res++;\\n                   j++; \\n                }else if(GCD % k == 0){\\n                    j++;\\n                }else{\\n                    break;\\n                }\\n            }\\n            i++;\\n        }\\n        \\n        \\n        return res;\\n    }\\n    \\n    private int gcd(int m, int n){\\n        return n == 0? m : gcd(n,m%n);\\n    }\\n    \\n    \\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int subarrayGCD(int[] nums, int k) {\\n        int res = 0;\\n        int len = nums.length;\\n    \\n        int j = 0;\\n        int i = 0;\\n        \\n        while(i< len){\\n            j = i;\\n            int GCD = nums[j];\\n            while(j < len){\\n                GCD = gcd(GCD,nums[j]);\\n                if(GCD == k){\\n                   res++;\\n                   j++; \\n                }else if(GCD % k == 0){\\n                    j++;\\n                }else{\\n                    break;\\n                }\\n            }\\n            i++;\\n        }\\n        \\n        \\n        return res;\\n    }\\n    \\n    private int gcd(int m, int n){\\n        return n == 0? m : gcd(n,m%n);\\n    }\\n    \\n    \\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2805513,
                "title": "c-easy-gcd-solution",
                "content": "```\\nclass Solution {\\npublic:\\n\\tint subarrayGCD(vector<int>& a, int k) {\\n\\t\\tint n = a.size(), ct = 0;\\n\\t\\tfor (int i = 0; i < n; ++i) {\\n\\t\\t\\tint g = a[i];\\n\\t\\t\\tfor (int j = i; j < n; ++j) {\\n\\t\\t\\t\\tg = __gcd(g, a[j]);\\n\\t\\t\\t\\tif (g == k) ct++;\\n\\t\\t\\t\\tif ( g < k) break;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ct;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tint subarrayGCD(vector<int>& a, int k) {\\n\\t\\tint n = a.size(), ct = 0;\\n\\t\\tfor (int i = 0; i < n; ++i) {\\n\\t\\t\\tint g = a[i];\\n\\t\\t\\tfor (int j = i; j < n; ++j) {\\n\\t\\t\\t\\tg = __gcd(g, a[j]);\\n\\t\\t\\t\\tif (g == k) ct++;\\n\\t\\t\\t\\tif ( g < k) break;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ct;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2804096,
                "title": "easy-solution-in-java",
                "content": "# class Solution {\\n    public int gcd(int a,int b)\\n    {\\n        if(b==0) return a;\\n        return gcd(b,a%b);\\n    }\\n    public int subarrayGCD(int[] nums, int k) {\\n        int c=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int prev=nums[i];\\n            for(int j=i;j<nums.length;j++)\\n            {\\n                if(nums[j]%k!=0) break;\\n                int a=gcd(nums[j],prev);\\n                if(a==k)\\n                {\\n                    c++;\\n                }\\n                prev=a;\\n            }\\n        }\\n        return c;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int gcd(int a,int b)\\n    {\\n        if(b==0) return a;\\n        return gcd(b,a%b);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2804017,
                "title": "simple-c-solution",
                "content": "```\\nint subarrayGCD(vector<int>& nums, int k) {\\n        int c=0;\\n        for(int i=0;i<nums.size();++i)\\n        {\\n            int r=nums[i];\\n            for(int j=i;j<nums.size();++j)\\n            {\\n                if(__gcd(nums[j],r)==k)\\n                {\\n                    c++;\\n                }\\n                r=__gcd(nums[j],r);\\n                if(r<k)\\n                    break;\\n            }\\n        }\\n        return c;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint subarrayGCD(vector<int>& nums, int k) {\\n        int c=0;\\n        for(int i=0;i<nums.size();++i)\\n        {\\n            int r=nums[i];\\n            for(int j=i;j<nums.size();++j)\\n            {\\n                if(__gcd(nums[j],r)==k)\\n                {\\n                    c++;\\n                }\\n                r=__gcd(nums[j],r);\\n                if(r<k)\\n                    break;\\n            }\\n        }\\n        return c;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2803839,
                "title": "c-easy-brute-force-solution-faster-than-80",
                "content": "```\\nclass Solution {\\npublic:\\n    int subarrayGCD(vector<int>& nums, int k) {\\n        int cnt=0;\\n        for(int i=0;i<nums.size();i++){\\n            int gcd = nums[i];\\n            for(int j=i;j<nums.size();j++){\\n                gcd= __gcd(gcd,nums[j]);\\n                  if(gcd==k)\\n                    cnt++;\\n                  if(gcd<k)\\n                    break;\\n                \\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subarrayGCD(vector<int>& nums, int k) {\\n        int cnt=0;\\n        for(int i=0;i<nums.size();i++){\\n            int gcd = nums[i];\\n            for(int j=i;j<nums.size();j++){\\n                gcd= __gcd(gcd,nums[j]);\\n                  if(gcd==k)\\n                    cnt++;\\n                  if(gcd<k)\\n                    break;\\n                \\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2803737,
                "title": "brute-force-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int subarrayGCD(vector<int>& nums, int k) {\\n        int c=0;\\n        for(int i=0;i<nums.size();++i)\\n        {\\n            int r=nums[i];\\n            for(int j=i;j<nums.size();++j)\\n            {\\n                if(__gcd(nums[j],r)==k)\\n                {\\n                    c++;\\n                }\\n                r=__gcd(nums[j],r);\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int subarrayGCD(vector<int>& nums, int k) {\\n        int c=0;\\n        for(int i=0;i<nums.size();++i)\\n        {\\n            int r=nums[i];\\n            for(int j=i;j<nums.size();++j)\\n            {\\n                if(__gcd(nums[j],r)==k)\\n                {\\n                    c++;\\n                }\\n                r=__gcd(nums[j],r);\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2787220,
                "title": "c-brute-force-simple",
                "content": "class Solution {\\npublic:\\n    int subarrayGCD(vector<int>& nums, int k) {\\n        \\n\\t\\tint n=nums.size();\\n        int gcd;\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            gcd=nums[i];\\n            for(int j=i;j<n;j++){\\n                gcd=__gcd(gcd,nums[j]);\\n                if(gcd==k) ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int subarrayGCD(vector<int>& nums, int k) {\\n        \\n\\t\\tint n=nums.size();\\n        int gcd;\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            gcd=nums[i];\\n            for(int j=i;j<n;j++){\\n                gcd=__gcd(gcd,nums[j]);\\n                if(gcd==k) ans++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2770429,
                "title": "check-all-potential-subarrays-94-speed",
                "content": "![image](https://assets.leetcode.com/users/images/aa5cb7a7-71bc-4a40-99da-0f7687b61835_1667395266.7916238.png)\\n```\\nfrom math import gcd\\nclass Solution:\\n    def subarrayGCD(self, nums: List[int], k: int) -> int:\\n        ans = 0\\n        len_nums = len(nums)\\n        for i in range(len_nums):\\n            if nums[i] == k:\\n                ans += 1\\n            elif nums[i] % k:\\n                continue\\n            if i < len_nums - 1:\\n                running_gcd = gcd(nums[i], nums[i + 1])\\n                if running_gcd == k:\\n                    ans += 1\\n                for j in range(i + 2, len_nums):\\n                    running_gcd = gcd(running_gcd, nums[j])\\n                    if running_gcd == k:\\n                        ans += 1\\n                    else:\\n                        break\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfrom math import gcd\\nclass Solution:\\n    def subarrayGCD(self, nums: List[int], k: int) -> int:\\n        ans = 0\\n        len_nums = len(nums)\\n        for i in range(len_nums):\\n            if nums[i] == k:\\n                ans += 1\\n            elif nums[i] % k:\\n                continue\\n            if i < len_nums - 1:\\n                running_gcd = gcd(nums[i], nums[i + 1])\\n                if running_gcd == k:\\n                    ans += 1\\n                for j in range(i + 2, len_nums):\\n                    running_gcd = gcd(running_gcd, nums[j])\\n                    if running_gcd == k:\\n                        ans += 1\\n                    else:\\n                        break\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2763221,
                "title": "count-subarrays-c",
                "content": "This approach will check every subarray\\'s GCD smartly.\\nKey point: For a given i ( starting index of subarray) and j (ending index) there will be 3 cases:\\n1. gcd of subarray = k. Here we Will simply increase our gcd count (ans)\\n2. If gcd of subarray is not divisible by k, then we stop and start with new starting index.\\n3. If gcd is divisble by k, we increment j (last index of subarray).\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int subarrayGCD(vector<int>& nums, int k) {\\n       int n = nums.size();\\n        int ans = 0;\\n        int gcd; //to store gcd of subarray.\\n        for(int i = 0; i<n;++i){\\n\\t\\t\\tgcd = nums[i];\\n            if(gcd==k) ++ans;  // checking for subarray of size one. Here if its not divisible by k you can chose to not enter the while loop.\\n            int j = i+1; //last index of subarray.\\n            while(j<n){\\n                gcd = __gcd(gcd,nums[j]); \\n                if(gcd==k) {++ans;}    //Case 1\\n                else if(gcd%k){        //Case 2\\n                    break;\\n                }\\n                ++j;                   //Case 3\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subarrayGCD(vector<int>& nums, int k) {\\n       int n = nums.size();\\n        int ans = 0;\\n        int gcd; //to store gcd of subarray.\\n        for(int i = 0; i<n;++i){\\n\\t\\t\\tgcd = nums[i];\\n            if(gcd==k) ++ans;  // checking for subarray of size one. Here if its not divisible by k you can chose to not enter the while loop.\\n            int j = i+1; //last index of subarray.\\n            while(j<n){\\n                gcd = __gcd(gcd,nums[j]); \\n                if(gcd==k) {++ans;}    //Case 1\\n                else if(gcd%k){        //Case 2\\n                    break;\\n                }\\n                ++j;                   //Case 3\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2754682,
                "title": "c-builtin-easy",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    int subarrayGCD(vector<int>& a, int key) \\n    {   \\n        int res=0,k;\\n        for(int i=0;i<a.size();i++)\\n        {\\n            k=a[i];\\n            for(int j=i;j<a.size();j++)\\n            {\\n                if(a[j]%key)break;\\n                k = __gcd(k,a[j]);\\n                if(k==key)res++;\\n            }\\n        }\\n        return res; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int subarrayGCD(vector<int>& a, int key) \\n    {   \\n        int res=0,k;\\n        for(int i=0;i<a.size();i++)\\n        {\\n            k=a[i];\\n            for(int j=i;j<a.size();j++)\\n            {\\n                if(a[j]%key)break;\\n                k = __gcd(k,a[j]);\\n                if(k==key)res++;\\n            }\\n        }\\n        return res; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2752979,
                "title": "javascript",
                "content": "\\n```\\nconst gcd = (a, b) => (b === 0 ? a : gcd(b, a % b));\\n\\nvar subarrayGCD = function (nums, k) {\\n    let n = 0;\\n    let i = 0;\\n\\n    while (i < nums.length) {\\n        if (nums[i] === k) n++;\\n\\n        if (nums[i] >= k) {\\n            let g = nums[i];\\n            let j = i + 1;\\n\\n            while (j < nums.length && nums[j] >= k) {\\n                g = gcd(g, nums[j]);\\n                if (g === k) n++;\\n                j++;\\n            }\\n        }\\n\\n        i++;\\n    }\\n\\n    return n;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst gcd = (a, b) => (b === 0 ? a : gcd(b, a % b));\\n\\nvar subarrayGCD = function (nums, k) {\\n    let n = 0;\\n    let i = 0;\\n\\n    while (i < nums.length) {\\n        if (nums[i] === k) n++;\\n\\n        if (nums[i] >= k) {\\n            let g = nums[i];\\n            let j = i + 1;\\n\\n            while (j < nums.length && nums[j] >= k) {\\n                g = gcd(g, nums[j]);\\n                if (g === k) n++;\\n                j++;\\n            }\\n        }\\n\\n        i++;\\n    }\\n\\n    return n;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2750615,
                "title": "my-solution",
                "content": "```\\n/**\\n * Time Complexity: O(n * n)\\n * Space Complexity: O(1)\\n * where `n` is the length of the vector `nums`\\n */\\nclass Solution {\\n public:\\n  int subarrayGCD(const vector<int> &nums, const int k) {\\n    const int n = static_cast<int>(nums.size());\\n    int ret = 0;\\n    for (int start = 0; start < n; ++start) {\\n      int gcd = nums[start];\\n      for (int end = start; end < n; ++end) {\\n        gcd = get_gcd(gcd, nums[end]);\\n        if (gcd % k != 0) {\\n          break;\\n        }\\n        if (gcd == k) {\\n          ++ret;\\n        }\\n      }\\n    }\\n    return ret;\\n  }\\n  \\n private:\\n  int get_gcd(const int a, const int b) {\\n    if (a == 0) {\\n      return b;\\n    }\\n    return get_gcd(b % a, a);\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Time Complexity: O(n * n)\\n * Space Complexity: O(1)\\n * where `n` is the length of the vector `nums`\\n */\\nclass Solution {\\n public:\\n  int subarrayGCD(const vector<int> &nums, const int k) {\\n    const int n = static_cast<int>(nums.size());\\n    int ret = 0;\\n    for (int start = 0; start < n; ++start) {\\n      int gcd = nums[start];\\n      for (int end = start; end < n; ++end) {\\n        gcd = get_gcd(gcd, nums[end]);\\n        if (gcd % k != 0) {\\n          break;\\n        }\\n        if (gcd == k) {\\n          ++ret;\\n        }\\n      }\\n    }\\n    return ret;\\n  }\\n  \\n private:\\n  int get_gcd(const int a, const int b) {\\n    if (a == 0) {\\n      return b;\\n    }\\n    return get_gcd(b % a, a);\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2749296,
                "title": "python-brute-force-o-n-2",
                "content": "```\\nfrom math import gcd\\nclass Solution:\\n    def subarrayGCD(self, nums: List[int], k: int) -> int:\\n        res = 0\\n        n = len(nums)\\n        for i in range(n):\\n            curgcd = nums[i]\\n            for j in range(i,n):\\n                curgcd = gcd(curgcd, nums[j])\\n                if curgcd == k: res +=1\\n                elif curgcd < k: break\\n        return res",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom math import gcd\\nclass Solution:\\n    def subarrayGCD(self, nums: List[int], k: int) -> int:\\n        res = 0\\n        n = len(nums)\\n        for i in range(n):\\n            curgcd = nums[i]\\n            for j in range(i,n):\\n                curgcd = gcd(curgcd, nums[j])\\n                if curgcd == k: res +=1\\n                elif curgcd < k: break\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 2747581,
                "title": "c-brute-force",
                "content": "```\\nclass Solution {\\npublic:\\n    int subarrayGCD(vector<int>& nums, int k) {\\n        int res=0;\\n        for(int i=0;i<size(nums);++i)\\n            for(int j=i;j<size(nums)&&nums[j]%k==0;++j){\\n                nums[i]=__gcd(nums[i],nums[j]);\\n                res+=nums[i]==k;\\n            }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subarrayGCD(vector<int>& nums, int k) {\\n        int res=0;\\n        for(int i=0;i<size(nums);++i)\\n            for(int j=i;j<size(nums)&&nums[j]%k==0;++j){\\n                nums[i]=__gcd(nums[i],nums[j]);\\n                res+=nums[i]==k;\\n            }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2746249,
                "title": "c-using-euclideans-algorithm",
                "content": "```\\nclass Solution {\\npublic:\\n    //function to find gcd of two nos\\n    int findGCD(int x , int y){\\n        while(y){\\n            int temp = x;\\n            x = y;\\n            y = temp % y;\\n        }\\n        return x;\\n    }\\n    \\n    int subarrayGCD(vector<int>& nums, int k) {\\n        \\n        int ans = 0;\\n        \\n        for(int i = 0 ; i < nums.size() ; i++){\\n            //subarray\\n            vector<int> temp = {nums[i]};\\n            //if the element is k itself then it on its own can be a vaid gcd subarray\\n            if(nums[i] ==  k){\\n                ans++;\\n            }\\n            int gcd = nums[i];\\n            for(int j = i + 1 ; j < nums.size() ; j++){\\n                //adding elements and finding gcd of all elements till now simultaneously\\n                temp.push_back(nums[j]);\\n                gcd = findGCD(gcd , nums[j]);\\n                //incrementing ans if gcd is k\\n                if(gcd == k){\\n                    ans++;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //function to find gcd of two nos\\n    int findGCD(int x , int y){\\n        while(y){\\n            int temp = x;\\n            x = y;\\n            y = temp % y;\\n        }\\n        return x;\\n    }\\n    \\n    int subarrayGCD(vector<int>& nums, int k) {\\n        \\n        int ans = 0;\\n        \\n        for(int i = 0 ; i < nums.size() ; i++){\\n            //subarray\\n            vector<int> temp = {nums[i]};\\n            //if the element is k itself then it on its own can be a vaid gcd subarray\\n            if(nums[i] ==  k){\\n                ans++;\\n            }\\n            int gcd = nums[i];\\n            for(int j = i + 1 ; j < nums.size() ; j++){\\n                //adding elements and finding gcd of all elements till now simultaneously\\n                temp.push_back(nums[j]);\\n                gcd = findGCD(gcd , nums[j]);\\n                //incrementing ans if gcd is k\\n                if(gcd == k){\\n                    ans++;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2745924,
                "title": "scala-but-written-like-java",
                "content": "\\n# Code\\n```\\nobject Solution {\\n    def gcd(a: Int, b: Int): Int = {\\n        if (b == 0) return a;\\n        return gcd(b, a % b);\\n    }\\n\\n    def subarrayGCD(nums: Array[Int], k: Int): Int = {\\n        val n = nums.length\\n        var count = 0\\n        for(i <- nums.indices) {\\n            var j = i\\n            var curGCD = nums(i)\\n\\n            while (curGCD >= k && j < nums.length) {\\n                val num = nums(j)\\n                curGCD = gcd(curGCD, num)\\n                if (curGCD == k) {\\n                    count = count + 1;\\n                }\\n                j = j + 1;\\n            }\\n        }\\n\\n        return count\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def gcd(a: Int, b: Int): Int = {\\n        if (b == 0) return a;\\n        return gcd(b, a % b);\\n    }\\n\\n    def subarrayGCD(nums: Array[Int], k: Int): Int = {\\n        val n = nums.length\\n        var count = 0\\n        for(i <- nums.indices) {\\n            var j = i\\n            var curGCD = nums(i)\\n\\n            while (curGCD >= k && j < nums.length) {\\n                val num = nums(j)\\n                curGCD = gcd(curGCD, num)\\n                if (curGCD == k) {\\n                    count = count + 1;\\n                }\\n                j = j + 1;\\n            }\\n        }\\n\\n        return count\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2745434,
                "title": "cpp-segment-tree",
                "content": "# Complexity\\n- Time complexity:\\nO(n^2logn)\\n\\n- Space complexity:\\n   O(n)\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\nvector<int >st;\\nvoid allocate_memory(int n)\\n{\\n  st.resize(4*n);\\n  return;\\n}\\nvoid build(vector<int>& nums,int si,int sl,int sr)\\n{\\n  if(sl==sr)\\n  {\\n    st[si]=nums[sl];\\n    return;\\n  }\\n   int mid=sl+(sr-sl)/2;\\n   build(nums,2*si,sl,mid);\\n   build(nums,2*si+1,mid+1,sr);\\n   st[si]=__gcd(st[2*si],st[2*si+1]);//gcd\\n   return;\\n}\\nint query(int si,int sl,int sr,int l,int r)\\n{\\n  if(sl>r or sr<l)return 0;\\n  if(sl>=l and sr<=r)return st[si];\\n  int mid=sl+(sr-sl)/2;\\n  int left=query(2*si,sl,mid,l,r);\\n  int right=query(2*si+1,mid+1,sr,l,r);\\n  return __gcd(left,right);\\n}\\n    int subarrayGCD(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        allocate_memory(n);\\n        build(nums,1,0,n-1);\\n        int counter=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i;j<n;j++)\\n            {\\n                counter+=(query(1,0,n-1,i,j)==k);\\n            }\\n        }\\n        return counter;\\n    }\\n};\\n```\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\n   O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nvector<int >st;\\nvoid allocate_memory(int n)\\n{\\n  st.resize(4*n);\\n  return;\\n}\\nvoid build(vector<int>& nums,int si,int sl,int sr)\\n{\\n  if(sl==sr)\\n  {\\n    st[si]=nums[sl];\\n    return;\\n  }\\n   int mid=sl+(sr-sl)/2;\\n   build(nums,2*si,sl,mid);\\n   build(nums,2*si+1,mid+1,sr);\\n   st[si]=__gcd(st[2*si],st[2*si+1]);//gcd\\n   return;\\n}\\nint query(int si,int sl,int sr,int l,int r)\\n{\\n  if(sl>r or sr<l)return 0;\\n  if(sl>=l and sr<=r)return st[si];\\n  int mid=sl+(sr-sl)/2;\\n  int left=query(2*si,sl,mid,l,r);\\n  int right=query(2*si+1,mid+1,sr,l,r);\\n  return __gcd(left,right);\\n}\\n    int subarrayGCD(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int> terminations;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]%k!=0)\\n            {\\n                nums[i]=-1;\\n                terminations.push_back(i);\\n            }\\n            else\\n                 nums[i]=nums[i]/k;\\n        }\\n        allocate_memory(n);\\n        build(nums,1,0,n-1);\\n        terminations.push_back(n);\\n        int i=0,j=0;\\n        int count=0;\\n        while(i<n)\\n        {\\n          while(j<n and nums[j]!=-1 and query(1,0,n-1,i,j)!=1)\\n                j++;\\n            if(j==n)break;\\n            if(nums[j]==-1)\\n            {\\n                i=j+1;\\n                j++;\\n                continue;\\n            }\\n            int ind=lower_bound(terminations.begin(),terminations.end(),j)-terminations.begin();\\n            int n_=terminations[ind];\\n            count+=(n_-j);\\n            i++;\\n            j=max(i,j);\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\nvector<int >st;\\nvoid allocate_memory(int n)\\n{\\n  st.resize(4*n);\\n  return;\\n}\\nvoid build(vector<int>& nums,int si,int sl,int sr)\\n{\\n  if(sl==sr)\\n  {\\n    st[si]=nums[sl];\\n    return;\\n  }\\n   int mid=sl+(sr-sl)/2;\\n   build(nums,2*si,sl,mid);\\n   build(nums,2*si+1,mid+1,sr);\\n   st[si]=__gcd(st[2*si],st[2*si+1]);//gcd\\n   return;\\n}\\nint query(int si,int sl,int sr,int l,int r)\\n{\\n  if(sl>r or sr<l)return 0;\\n  if(sl>=l and sr<=r)return st[si];\\n  int mid=sl+(sr-sl)/2;\\n  int left=query(2*si,sl,mid,l,r);\\n  int right=query(2*si+1,mid+1,sr,l,r);\\n  return __gcd(left,right);\\n}\\n    int subarrayGCD(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        allocate_memory(n);\\n        build(nums,1,0,n-1);\\n        int counter=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i;j<n;j++)\\n            {\\n                counter+=(query(1,0,n-1,i,j)==k);\\n            }\\n        }\\n        return counter;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\nvector<int >st;\\nvoid allocate_memory(int n)\\n{\\n  st.resize(4*n);\\n  return;\\n}\\nvoid build(vector<int>& nums,int si,int sl,int sr)\\n{\\n  if(sl==sr)\\n  {\\n    st[si]=nums[sl];\\n    return;\\n  }\\n   int mid=sl+(sr-sl)/2;\\n   build(nums,2*si,sl,mid);\\n   build(nums,2*si+1,mid+1,sr);\\n   st[si]=__gcd(st[2*si],st[2*si+1]);//gcd\\n   return;\\n}\\nint query(int si,int sl,int sr,int l,int r)\\n{\\n  if(sl>r or sr<l)return 0;\\n  if(sl>=l and sr<=r)return st[si];\\n  int mid=sl+(sr-sl)/2;\\n  int left=query(2*si,sl,mid,l,r);\\n  int right=query(2*si+1,mid+1,sr,l,r);\\n  return __gcd(left,right);\\n}\\n    int subarrayGCD(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int> terminations;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]%k!=0)\\n            {\\n                nums[i]=-1;\\n                terminations.push_back(i);\\n            }\\n            else\\n                 nums[i]=nums[i]/k;\\n        }\\n        allocate_memory(n);\\n        build(nums,1,0,n-1);\\n        terminations.push_back(n);\\n        int i=0,j=0;\\n        int count=0;\\n        while(i<n)\\n        {\\n          while(j<n and nums[j]!=-1 and query(1,0,n-1,i,j)!=1)\\n                j++;\\n            if(j==n)break;\\n            if(nums[j]==-1)\\n            {\\n                i=j+1;\\n                j++;\\n                continue;\\n            }\\n            int ind=lower_bound(terminations.begin(),terminations.end(),j)-terminations.begin();\\n            int n_=terminations[ind];\\n            count+=(n_-j);\\n            i++;\\n            j=max(i,j);\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2745070,
                "title": "rust-solution",
                "content": "```\\nimpl Solution {\\n    pub fn subarray_gcd(nums: Vec<i32>, k: i32) -> i32 {\\n        use std::cmp::Ordering::{Equal, Less};\\n        fn gcd(a: i32, b: i32) -> i32 {\\n            match b > 0 {\\n                true => gcd(b, a % b),\\n                false => a,\\n            }\\n        }\\n\\n        let mut res = 0;\\n        for (i, mut a) in nums.iter().cloned().enumerate().filter(|(_, a)| a % k == 0) {\\n            for &b in &nums[i..] {\\n                a = gcd(a, b);\\n                match a.cmp(&k) {\\n                    Equal => res += 1,\\n                    Less => break,\\n                    _ => (),\\n                }\\n            }\\n        }\\n        res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn subarray_gcd(nums: Vec<i32>, k: i32) -> i32 {\\n        use std::cmp::Ordering::{Equal, Less};\\n        fn gcd(a: i32, b: i32) -> i32 {\\n            match b > 0 {\\n                true => gcd(b, a % b),\\n                false => a,\\n            }\\n        }\\n\\n        let mut res = 0;\\n        for (i, mut a) in nums.iter().cloned().enumerate().filter(|(_, a)| a % k == 0) {\\n            for &b in &nums[i..] {\\n                a = gcd(a, b);\\n                match a.cmp(&k) {\\n                    Equal => res += 1,\\n                    Less => break,\\n                    _ => (),\\n                }\\n            }\\n        }\\n        res\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2744006,
                "title": "javascript-solution-90-faster",
                "content": "```\\nfunction calculateGcd(a, b) {\\n    if (a == 0)\\n        return b;\\n    return calculateGcd(b % a, a);\\n}\\n\\nvar subarrayGCD = function(nums, k) {\\n    let count = 0;\\n    \\n    for(let i=0; i<nums.length; i++) {\\n        let gcd = nums[i];\\n        for(let j=i;j<nums.length;j++) {\\n            gcd = calculateGcd(gcd, nums[j]);\\n            if(gcd === k) {\\n                count++;\\n            }\\n            if(gcd < k) {\\n                break;\\n            }\\n        }\\n    }\\n    return count;\\n};\\n```",
                "solutionTags": [
                    "Array",
                    "Math"
                ],
                "code": "```\\nfunction calculateGcd(a, b) {\\n    if (a == 0)\\n        return b;\\n    return calculateGcd(b % a, a);\\n}\\n\\nvar subarrayGCD = function(nums, k) {\\n    let count = 0;\\n    \\n    for(let i=0; i<nums.length; i++) {\\n        let gcd = nums[i];\\n        for(let j=i;j<nums.length;j++) {\\n            gcd = calculateGcd(gcd, nums[j]);\\n            if(gcd === k) {\\n                count++;\\n            }\\n            if(gcd < k) {\\n                break;\\n            }\\n        }\\n    }\\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2743392,
                "title": "python-bruteforce-solution",
                "content": "\\nMath basics:\\n`GCD(a,b,c) = GCD(GCD(a,b),c)`\\nFor example, `gcd(12,4,2) = gcd(gcd(12,4),2) = gcd(4,2) = 2`\\n\\nBrute-force approach: set i as start index of an array, j as end index of an array.\\nWhen we calculating GCD of `nums[i:j]`, we can use previous result `g=gcd(nums[i:j-1])`\\nso that `g=gcd(g,nums[j])`.\\n\\nHere\\'s the code:\\n\\n```\\nclass Solution:\\n    def subarrayGCD(self, nums: List[int], k: int) -> int:\\n        ans=0\\n        n=len(nums)\\n        for i in range(n):\\n            g=-1\\n            for j in range(i,n):\\n                if(g==-1):\\n                    g=nums[j]\\n                else:\\n                    g=math.gcd(g,nums[j])\\n                if(g==k):\\n                    ans+=1\\n        return ans\\n```\\nTime Complexity: O(n^2)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def subarrayGCD(self, nums: List[int], k: int) -> int:\\n        ans=0\\n        n=len(nums)\\n        for i in range(n):\\n            g=-1\\n            for j in range(i,n):\\n                if(g==-1):\\n                    g=nums[j]\\n                else:\\n                    g=math.gcd(g,nums[j])\\n                if(g==k):\\n                    ans+=1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2742782,
                "title": "a-few-solutions",
                "content": "Brute-force count all subarrays `i..j` inclusive ending at each `j`<sup>th</sup> index from `j = 0..N-1` inclusive.\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun gcd(a_: Int, b_: Int): Int {\\n        var a = Math.max(a_, b_)\\n        var b = Math.min(a_, b_)\\n        return if (b == 0) a else gcd(b, a % b)\\n    }\\n    fun subarrayGCD(A: IntArray, K: Int): Int {\\n        var cnt = 0\\n        for (j in 0 until A.size) {\\n            for (i in 0..j) {\\n                A[i] = gcd(A[i], A[j])\\n                cnt += if (A[i] == K) 1 else 0\\n            }\\n        }\\n        return cnt\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet gcd = (a_, b_) => {\\n    let a = Math.max(a_, b_),\\n        b = Math.min(a_, b_);\\n    return !b ? a : gcd(b, a % b);\\n};\\nlet subarrayGCD = (A, K, cnt = 0) => {\\n    for (let j = 0; j < A.length; ++j) {\\n        for (let i = 0; i <= j; ++i) {\\n            A[i] = gcd(A[i], A[j]);\\n            cnt += Number(A[i] == K);\\n        }\\n    }\\n    return cnt;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def subarrayGCD(self, A: List[int], K: int, cnt = 0) -> int:\\n        def gcd(a, b):\\n            a, b = max(a, b), min(a, b)\\n            return a if not b else gcd(b, a % b)\\n        for j in range(len(A)):\\n            for i in range(j + 1):\\n                A[i] = gcd(A[i], A[j])\\n                cnt += int(A[i] == K)\\n        return cnt\\n```\\n\\n*Rust*\\n```\\ntype VI = Vec<i32>;\\nuse std::cmp::min;\\nuse std::cmp::max;\\nimpl Solution {\\n    pub fn subarray_gcd(mut A: VI, K: i32) -> i32 {\\n        fn gcd(a_: i32, b_: i32) -> i32 {\\n            let a = max(a_, b_);\\n            let b = min(a_, b_);\\n            if b == 0 { a } else { gcd(b, a % b) }\\n        }\\n        let mut cnt = 0;\\n        for j in 0..A.len() {\\n            for i in 0..=j {\\n                A[i] = gcd(A[i], A[j]);\\n                cnt += if A[i] == K { 1 } else { 0 };\\n            }\\n        }\\n        cnt\\n    }\\n}\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int subarrayGCD(VI& A, int K, int cnt = 0) {\\n        for (auto j{ 0 }; j < A.size(); ++j) {\\n            for (auto i{ 0 }; i <= j; ++i) {\\n                A[i] = gcd(A[i], A[j]);\\n                cnt += int(A[i] == K);\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun gcd(a_: Int, b_: Int): Int {\\n        var a = Math.max(a_, b_)\\n        var b = Math.min(a_, b_)\\n        return if (b == 0) a else gcd(b, a % b)\\n    }\\n    fun subarrayGCD(A: IntArray, K: Int): Int {\\n        var cnt = 0\\n        for (j in 0 until A.size) {\\n            for (i in 0..j) {\\n                A[i] = gcd(A[i], A[j])\\n                cnt += if (A[i] == K) 1 else 0\\n            }\\n        }\\n        return cnt\\n    }\\n}\\n```\n```\\nlet gcd = (a_, b_) => {\\n    let a = Math.max(a_, b_),\\n        b = Math.min(a_, b_);\\n    return !b ? a : gcd(b, a % b);\\n};\\nlet subarrayGCD = (A, K, cnt = 0) => {\\n    for (let j = 0; j < A.length; ++j) {\\n        for (let i = 0; i <= j; ++i) {\\n            A[i] = gcd(A[i], A[j]);\\n            cnt += Number(A[i] == K);\\n        }\\n    }\\n    return cnt;\\n};\\n```\n```\\nclass Solution:\\n    def subarrayGCD(self, A: List[int], K: int, cnt = 0) -> int:\\n        def gcd(a, b):\\n            a, b = max(a, b), min(a, b)\\n            return a if not b else gcd(b, a % b)\\n        for j in range(len(A)):\\n            for i in range(j + 1):\\n                A[i] = gcd(A[i], A[j])\\n                cnt += int(A[i] == K)\\n        return cnt\\n```\n```\\ntype VI = Vec<i32>;\\nuse std::cmp::min;\\nuse std::cmp::max;\\nimpl Solution {\\n    pub fn subarray_gcd(mut A: VI, K: i32) -> i32 {\\n        fn gcd(a_: i32, b_: i32) -> i32 {\\n            let a = max(a_, b_);\\n            let b = min(a_, b_);\\n            if b == 0 { a } else { gcd(b, a % b) }\\n        }\\n        let mut cnt = 0;\\n        for j in 0..A.len() {\\n            for i in 0..=j {\\n                A[i] = gcd(A[i], A[j]);\\n                cnt += if A[i] == K { 1 } else { 0 };\\n            }\\n        }\\n        cnt\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int subarrayGCD(VI& A, int K, int cnt = 0) {\\n        for (auto j{ 0 }; j < A.size(); ++j) {\\n            for (auto i{ 0 }; i <= j; ++i) {\\n                A[i] = gcd(A[i], A[j]);\\n                cnt += int(A[i] == K);\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2742418,
                "title": "easy-and-understandable-c-solution",
                "content": "Brute force approach - basic approach would be to consider all the subarrays and check and find the array with gcd equals to k. since the constraints are on easier side we will be able to get answer with brute force also.\\n\\n\\n\\noptimised approach -  slight optimisation would be we know once gcd is less than k it will remain less than k for all subarrays with same starting element so break out of the loop.\\n\\n     class Solution { \\n\\t public:\\n\\t  int subarrayGCD(vector<int>& nums, int k) {\\n        int ans =0;\\n        for(int i=0;i<nums.size();i++){\\n            int gcd = nums[i];\\n            for(int j=i;j<nums.size();j++){\\n                gcd = __gcd(gcd,nums[j]);\\n                if(gcd == k){\\n                    ans++;\\n                }\\n                if(gcd < k){\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    } \\n\\t};\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution { \\n\\t public:\\n\\t  int subarrayGCD(vector<int>& nums, int k) {\\n        int ans =0;\\n        for(int i=0;i<nums.size();i++){\\n            int gcd = nums[i];\\n            for(int j=i;j<nums.size();j++){\\n                gcd = __gcd(gcd,nums[j]);\\n                if(gcd == k){\\n                    ans++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2742181,
                "title": "rust-how-to-speed-up",
                "content": "Any idea to speed up the following Rust code? The results are: _Runtime: 37 ms, faster than 12.50% ... Memory Usage: 2.2 MB, less than 50.00% ..._\\n\\nThe main idea is based on a rolling update of GCD because in the inner loop we\\'re only extending the sequence. However, this is reset every time we iterate the outer loop.\\n\\n```\\npub fn gcd(mut a: i32, mut b: i32) -> i32 {\\n    while b != 0 {\\n        let t = a % b;\\n        a = b;\\n        b = t;\\n    }\\n    a\\n}\\n\\npub fn subarray_gcd(nums: Vec<i32>, k: i32) -> i32 {\\n    let mut count: i32 = 0;\\n    // check every subarray\\n    for a_i in 0..nums.len() {\\n        // rolling update of gcd\\n        let mut prev_gcd = nums[a_i];\\n        for b_i in (a_i)..nums.len() {\\n            // speed up special case of subarrays of length 1\\n            prev_gcd = if a_i == b_i {\\n                nums[a_i]\\n            } else {\\n                gcd(prev_gcd, nums[b_i])\\n            };\\n            if prev_gcd == k {\\n                count += 1;\\n            }\\n        }\\n    }\\n    count\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\npub fn gcd(mut a: i32, mut b: i32) -> i32 {\\n    while b != 0 {\\n        let t = a % b;\\n        a = b;\\n        b = t;\\n    }\\n    a\\n}\\n\\npub fn subarray_gcd(nums: Vec<i32>, k: i32) -> i32 {\\n    let mut count: i32 = 0;\\n    // check every subarray\\n    for a_i in 0..nums.len() {\\n        // rolling update of gcd\\n        let mut prev_gcd = nums[a_i];\\n        for b_i in (a_i)..nums.len() {\\n            // speed up special case of subarrays of length 1\\n            prev_gcd = if a_i == b_i {\\n                nums[a_i]\\n            } else {\\n                gcd(prev_gcd, nums[b_i])\\n            };\\n            if prev_gcd == k {\\n                count += 1;\\n            }\\n        }\\n    }\\n    count\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2741997,
                "title": "simple-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int subarrayGCD(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        int ans = 0;\\n        for(int i=0;i<n;i++) {\\n            int cur = nums[i];\\n            \\n            for(int j=i;j<n;j++) {\\n                cur = __gcd(cur,nums[j]);\\n                \\n                if(cur == k) ans++;\\n                else if(cur < k) break;\\n                else continue;\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int subarrayGCD(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        int ans = 0;\\n        for(int i=0;i<n;i++) {\\n            int cur = nums[i];\\n            \\n            for(int j=i;j<n;j++) {\\n                cur = __gcd(cur,nums[j]);\\n                \\n                if(cur == k) ans++;\\n                else if(cur < k) break;\\n                else continue;\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2741725,
                "title": "c-easy-brute-force",
                "content": "class Solution {\\npublic:\\n    int subarrayGCD(vector<int>& nums, int k) {\\n        int cnt = 0;\\n        for(int i = 0 ; i < nums.size(); i++){\\n            int g = nums[i];\\n            for(int j = i; j< nums.size() ; j++){\\n                g=__gcd(nums[j],g);\\n                 cnt+=(g==k);\\n            }\\n        }\\n        return cnt;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int subarrayGCD(vector<int>& nums, int k) {\\n        int cnt = 0;\\n        for(int i = 0 ; i < nums.size(); i++){\\n            int g = nums[i];\\n            for(int j = i; j< nums.size() ; j++){\\n                g=__gcd(nums[j],g);\\n                 cnt+=(g==k);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2740899,
                "title": "brute-force-solution",
                "content": "Please upvote if you like the solution.\\n```\\nimport math\\nclass Solution:\\n    def subarrayGCD(self, nums: List[int], k: int) -> int:\\n        c=0\\n        for i in range(len(nums)):\\n            ng=0\\n            for j in range(i,len(nums)):\\n                ng=math.gcd(ng,nums[j])\\n                if ng==k:\\n                    c+=1\\n                if ng<k or ng%k!=0:\\n                    break\\n        return c\\n```",
                "solutionTags": [],
                "code": "```\\nimport math\\nclass Solution:\\n    def subarrayGCD(self, nums: List[int], k: int) -> int:\\n        c=0\\n        for i in range(len(nums)):\\n            ng=0\\n            for j in range(i,len(nums)):\\n                ng=math.gcd(ng,nums[j])\\n                if ng==k:\\n                    c+=1\\n                if ng<k or ng%k!=0:\\n                    break\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2740459,
                "title": "javascript-early-return",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar subarrayGCD = function(nums, k) {\\n    const len = nums.length\\n    let result = 0\\n    \\n    \\n    function calcGCD(m, n) {\\n        if (m < n)  return calcGCD(n, m)\\n        if (n === 0)    return m\\n        return calcGCD(n, m % n)\\n    }\\n    \\n    \\n    for (const i of nums.keys()) {\\n        let a = nums[i]\\n        if (a % k !== 0)    continue\\n        \\n        let outcome = 0\\n        if (a === k)    outcome++\\n        for (let j = 1 + i; j < len; j++) {\\n            const b = nums[j]\\n            const gcd = calcGCD(a, b)\\n            if (gcd === k) {\\n                outcome++\\n            }\\n\\n            a = gcd\\n            if (a < k)  break\\n        }\\n        \\n        result += outcome\\n    }\\n    \\n    \\n    return result\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar subarrayGCD = function(nums, k) {\\n    const len = nums.length\\n    let result = 0\\n    \\n    \\n    function calcGCD(m, n) {\\n        if (m < n)  return calcGCD(n, m)\\n        if (n === 0)    return m\\n        return calcGCD(n, m % n)\\n    }\\n    \\n    \\n    for (const i of nums.keys()) {\\n        let a = nums[i]\\n        if (a % k !== 0)    continue\\n        \\n        let outcome = 0\\n        if (a === k)    outcome++\\n        for (let j = 1 + i; j < len; j++) {\\n            const b = nums[j]\\n            const gcd = calcGCD(a, b)\\n            if (gcd === k) {\\n                outcome++\\n            }\\n\\n            a = gcd\\n            if (a < k)  break\\n        }\\n        \\n        result += outcome\\n    }\\n    \\n    \\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2740146,
                "title": "javascript-106ms",
                "content": "```\\nconst gcd = (a, b) => {\\n        if (!b) return a;\\n        return gcd(b, a % b);\\n    }\\n\\nconst subarrayGCD = (nums, k) => {\\n    const n = nums.length;\\n    \\n    const boundary = Array(n).fill(-1);\\n    const closestPartnerToMakeGCD = Array(n).fill(-1);\\n   \\n    for (let i=0; i<n; i++) {\\n        const curr =nums[i];\\n        boundary[i]=i-1>=0?boundary[i-1]:boundary[i];\\n        if (curr%k) boundary[i]=i;\\n        for (let j=i; j>=Math.max(0,boundary[i]); j--) {\\n            const part = nums[j];\\n            if (gcd(part,curr)===k) {\\n                closestPartnerToMakeGCD[i]=j;\\n                break;\\n            }\\n        }\\n    }\\n\\t\\n    let res =0;\\n    for (let i=0; i<n; i++) {\\n        const curr = nums[i];\\n        const p = closestPartnerToMakeGCD[i];\\n\\t\\tif (p===-1) continue;\\n        res+=p-boundary[i];\\n    }\\n    return res;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst gcd = (a, b) => {\\n        if (!b) return a;\\n        return gcd(b, a % b);\\n    }\\n\\nconst subarrayGCD = (nums, k) => {\\n    const n = nums.length;\\n    \\n    const boundary = Array(n).fill(-1);\\n    const closestPartnerToMakeGCD = Array(n).fill(-1);\\n   \\n    for (let i=0; i<n; i++) {\\n        const curr =nums[i];\\n        boundary[i]=i-1>=0?boundary[i-1]:boundary[i];\\n        if (curr%k) boundary[i]=i;\\n        for (let j=i; j>=Math.max(0,boundary[i]); j--) {\\n            const part = nums[j];\\n            if (gcd(part,curr)===k) {\\n                closestPartnerToMakeGCD[i]=j;\\n                break;\\n            }\\n        }\\n    }\\n\\t\\n    let res =0;\\n    for (let i=0; i<n; i++) {\\n        const curr = nums[i];\\n        const p = closestPartnerToMakeGCD[i];\\n\\t\\tif (p===-1) continue;\\n        res+=p-boundary[i];\\n    }\\n    return res;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2739727,
                "title": "2447-number-of-subarrays-with-gcd-equal-to-k",
                "content": "```\\npublic class Solution {\\n    public int SubarrayGCD(int[] nums, int k)\\n    {\\n        var cnt = 0;\\n        for (var i = 0; i < nums.Length; i++)\\n        {\\n            var currGcd = 0;\\n            for (var j = i; j < nums.Length; j++)\\n            {\\n                currGcd = gcd(currGcd, nums[j]);\\n                if (currGcd == k)\\n                    cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n    private int gcd(int a, int b)\\n    {\\n        return b == 0 ? a : gcd(b, a % b);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int SubarrayGCD(int[] nums, int k)\\n    {\\n        var cnt = 0;\\n        for (var i = 0; i < nums.Length; i++)\\n        {\\n            var currGcd = 0;\\n            for (var j = i; j < nums.Length; j++)\\n            {\\n                currGcd = gcd(currGcd, nums[j]);\\n                if (currGcd == k)\\n                    cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n    private int gcd(int a, int b)\\n    {\\n        return b == 0 ? a : gcd(b, a % b);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2739580,
                "title": "100-faster-simple-c",
                "content": "Sliding Window technique that generally comes in mind seeing these type of ques, will not work here.\\n**Reason**-  condition for shrinking window size is not definite here.\\n\\n**Approach**- Brute Force with few optimisation like if we get an element which is smaller than k( required GCD) then we dont need to proceed further in array as now gcd will always be less than or equal to smallest element for which we are finding gcd.\\n\\n**Maths-**\\n*  GCD(a,b,c) = GCD( GCD( a,b ), c )\\n*  GCD(a,b) will always lie in range of 1<=GCD<=min(a,b)\\n\\n**Code-**\\n```\\nclass Solution {\\npublic:\\n    int subarrayGCD(vector<int>& nums, int k) {\\n        int cnt=0;\\n        for(int i=0;i<nums.size();i++){\\n            int gcd=nums[i];\\n            for(int j=i;j<nums.size();j++){\\n                if(nums[j]<k)break;                                          //Optimisation\\n                gcd=GCD(gcd,nums[j]);\\n                if(gcd==k)cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n    int GCD(int a, int b){\\n        while(b){\\n            int tmp=b;\\n            b=a%b;\\n            a=tmp;\\n        }\\n        return a;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int subarrayGCD(vector<int>& nums, int k) {\\n        int cnt=0;\\n        for(int i=0;i<nums.size();i++){\\n            int gcd=nums[i];\\n            for(int j=i;j<nums.size();j++){\\n                if(nums[j]<k)break;                                          //Optimisation\\n                gcd=GCD(gcd,nums[j]);\\n                if(gcd==k)cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n    int GCD(int a, int b){\\n        while(b){\\n            int tmp=b;\\n            b=a%b;\\n            a=tmp;\\n        }\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2739021,
                "title": "java-100-faster-gcd-brute-force-easy",
                "content": "```\\nclass Solution {\\n    public int sol(int a, int b){\\n        if(b == 0){\\n            return a;\\n        }\\n        return sol(b, a%b);\\n    }\\n    public int subarrayGCD(int[] nums, int k) {\\n        int n = nums.length;\\n        int cnt = 0;\\n        for(int i = 0; i<n; i++){\\n            int gcd = 0;\\n            for(int j = i; j<n; j++){\\n                gcd = sol(gcd, nums[j]);\\n                if(gcd == k)\\n                    cnt++;\\n\\t\\t\\t\\tif(gcd < k)\\n\\t\\t\\t\\t\\tbreak;\\n            }\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int sol(int a, int b){\\n        if(b == 0){\\n            return a;\\n        }\\n        return sol(b, a%b);\\n    }\\n    public int subarrayGCD(int[] nums, int k) {\\n        int n = nums.length;\\n        int cnt = 0;\\n        for(int i = 0; i<n; i++){\\n            int gcd = 0;\\n            for(int j = i; j<n; j++){\\n                gcd = sol(gcd, nums[j]);\\n                if(gcd == k)\\n                    cnt++;\\n\\t\\t\\t\\tif(gcd < k)\\n\\t\\t\\t\\t\\tbreak;\\n            }\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2738584,
                "title": "java-brute-force-solution-faster-than-100-submissions-100-less-memory-usage",
                "content": "```\\nclass Solution {\\n    \\n    static int gcd(int a, int b)\\n    {\\n        if (b == 0)\\n            return a;\\n \\n        else\\n            return gcd(b, a % b);\\n    }\\n    \\n    public int subarrayGCD(int[] nums, int k) {\\n        \\n        int ans = 0;\\n        \\n        for(int i = 0; i<nums.length; i++){\\n            int gcd = nums[i];\\n            for(int j = i; j<nums.length; j++){\\n                gcd = gcd(nums[j], gcd);\\n                if(gcd == k){\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    static int gcd(int a, int b)\\n    {\\n        if (b == 0)\\n            return a;\\n \\n        else\\n            return gcd(b, a % b);\\n    }\\n    \\n    public int subarrayGCD(int[] nums, int k) {\\n        \\n        int ans = 0;\\n        \\n        for(int i = 0; i<nums.length; i++){\\n            int gcd = nums[i];\\n            for(int j = i; j<nums.length; j++){\\n                gcd = gcd(nums[j], gcd);\\n                if(gcd == k){\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2738256,
                "title": "rust-6ms-bruteforce-with-comments-and-tests",
                "content": "[6ms](https://leetcode.com/submissions/detail/829131707/)\\n\\nThe gist is that\\n1. If GCD of some set S is G, then GCD of set (S union {n}) is just GCD of G and n; no need to calculate GCD of (S union {n}) as a whole!\\n2. The problem asks for number of contiguous subarray, hence we can do (fixed start, variable end) subarray operations and apply 1.\\n\\n```\\npub struct Solution;\\n\\nimpl Solution {\\n    fn gcd(mut i: usize, mut j: usize) -> usize {\\n        if i == 0 || j == 0 {\\n            return 0;\\n        } else {\\n            // i       = j       * q_0     + r_0\\n            // j       = r_0     * q_1     + r_1\\n            // r_0     = r_1     * q_2     + r_2\\n            // ...\\n            // r_{i-1} = r_i     * q_{i+1} + r_{i}\\n            // r_i     = r_{i+1} * q_{i+2} + 0\\n            // Then r_{i+1} = GCD of a and b.\\n            let mut r;\\n            while {\\n                r = i % j;\\n                r != 0\\n            } {\\n                i = j;\\n                j = r;\\n            }\\n            j\\n        }\\n    }\\n    pub fn subarray_gcd(nums: Vec<i32>, k: i32) -> i32 {\\n        let mut cnt = 0;\\n        let k = k as usize;\\n\\n        // The problem asks only for contiguous subarr, even hints for\\n        // brute-force. Hence do brute-force here.\\n        // We check [0..1], [0..2], ..., [0..len]\\n        // then             [1..2], ..., [1..len]\\n        //                                    ...\\n        //                               [len-1..len]\\n        // For each row, notice GCD of subarr is non-increasing:\\n        // if GCD of set S is G, then GCD of set (S union {num}) is just\\n        // GCD of G and num.\\n        // Hence, for each row, we maintain a variable, s.t. column by column\\n        // we can do GCD calculation just once, i.e. just do GCD of the old\\n        // variable and the newly added element.\\n        for start in 0..nums.len() {\\n            // Maximum possible GCD of each row,\\n            // decreases as subarr longer and longer.\\n            let mut gcd_of_subarr = unsafe {\\n                // unsafe reason: get_unchecked\\n                // It\\'s okay since here we iterate on known valid boundary\\n                *nums.get_unchecked(start) as usize\\n            };\\n            for end in start + 1..nums.len() + 1 {\\n                unsafe {\\n                    // unsafe reason: get_unchecked\\n                    // It\\'s okay since here we iterate on known valid boundary\\n                    gcd_of_subarr = Self::gcd(\\n                        *nums.get_unchecked(start..end).last().unwrap() as usize,\\n                        gcd_of_subarr,\\n                    );\\n                    if gcd_of_subarr == k {\\n                        cnt += 1;\\n                    } else if gcd_of_subarr < k {\\n                        // The larger the set the smaller the GCD\\n                        // If it\\'s below k then just prune unnecessary calc\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        cnt\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use crate::Solution;\\n    #[test]\\n    fn test_gcd() {\\n        assert_eq!(Solution::gcd(10, 3), 1);\\n        assert_eq!(Solution::gcd(3, 11), 1);\\n        assert_eq!(Solution::gcd(100, 84), 4);\\n    }\\n    #[test]\\n    fn test_soln() {\\n        assert_eq!(Solution::subarray_gcd(vec![9, 3, 1, 2, 6, 3], 3), 4);\\n        assert_eq!(Solution::subarray_gcd(vec![4], 7), 0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\npub struct Solution;\\n\\nimpl Solution {\\n    fn gcd(mut i: usize, mut j: usize) -> usize {\\n        if i == 0 || j == 0 {\\n            return 0;\\n        } else {\\n            // i       = j       * q_0     + r_0\\n            // j       = r_0     * q_1     + r_1\\n            // r_0     = r_1     * q_2     + r_2\\n            // ...\\n            // r_{i-1} = r_i     * q_{i+1} + r_{i}\\n            // r_i     = r_{i+1} * q_{i+2} + 0\\n            // Then r_{i+1} = GCD of a and b.\\n            let mut r;\\n            while {\\n                r = i % j;\\n                r != 0\\n            } {\\n                i = j;\\n                j = r;\\n            }\\n            j\\n        }\\n    }\\n    pub fn subarray_gcd(nums: Vec<i32>, k: i32) -> i32 {\\n        let mut cnt = 0;\\n        let k = k as usize;\\n\\n        // The problem asks only for contiguous subarr, even hints for\\n        // brute-force. Hence do brute-force here.\\n        // We check [0..1], [0..2], ..., [0..len]\\n        // then             [1..2], ..., [1..len]\\n        //                                    ...\\n        //                               [len-1..len]\\n        // For each row, notice GCD of subarr is non-increasing:\\n        // if GCD of set S is G, then GCD of set (S union {num}) is just\\n        // GCD of G and num.\\n        // Hence, for each row, we maintain a variable, s.t. column by column\\n        // we can do GCD calculation just once, i.e. just do GCD of the old\\n        // variable and the newly added element.\\n        for start in 0..nums.len() {\\n            // Maximum possible GCD of each row,\\n            // decreases as subarr longer and longer.\\n            let mut gcd_of_subarr = unsafe {\\n                // unsafe reason: get_unchecked\\n                // It\\'s okay since here we iterate on known valid boundary\\n                *nums.get_unchecked(start) as usize\\n            };\\n            for end in start + 1..nums.len() + 1 {\\n                unsafe {\\n                    // unsafe reason: get_unchecked\\n                    // It\\'s okay since here we iterate on known valid boundary\\n                    gcd_of_subarr = Self::gcd(\\n                        *nums.get_unchecked(start..end).last().unwrap() as usize,\\n                        gcd_of_subarr,\\n                    );\\n                    if gcd_of_subarr == k {\\n                        cnt += 1;\\n                    } else if gcd_of_subarr < k {\\n                        // The larger the set the smaller the GCD\\n                        // If it\\'s below k then just prune unnecessary calc\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        cnt\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use crate::Solution;\\n    #[test]\\n    fn test_gcd() {\\n        assert_eq!(Solution::gcd(10, 3), 1);\\n        assert_eq!(Solution::gcd(3, 11), 1);\\n        assert_eq!(Solution::gcd(100, 84), 4);\\n    }\\n    #[test]\\n    fn test_soln() {\\n        assert_eq!(Solution::subarray_gcd(vec![9, 3, 1, 2, 6, 3], 3), 4);\\n        assert_eq!(Solution::subarray_gcd(vec![4], 7), 0);\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2738108,
                "title": "python-sliding-window-solution-o-n-log-n",
                "content": "```\\nclass Solution:\\n    def subarrayGCD(self, nums: List[int], k: int) -> int:\\n        left, count, lastGCDIndex = 0, 0, 0\\n        for right, num in enumerate(nums):\\n            currentLen = right - left + 1\\n            if left == right:\\n                if num == k:\\n                    count += 1 \\n                    lastGCDIndex = right\\n                elif num % k == 0:\\n                    lastGCDIndex = right\\n                else:\\n                    left = right + 1\\n            else:\\n                if num == k:\\n                    count += currentLen\\n                    lastGCDIndex = right\\n                elif gcd(num, nums[right - 1]) == k:\\n                    lastGCDIndex = right\\n                    count += (currentLen - 1)\\n                elif num % k == 0:\\n                    count += currentLen - (currentLen - lastGCDIndex)\\n                else:\\n                    left = right + 1\\n        return count\\n```",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def subarrayGCD(self, nums: List[int], k: int) -> int:\\n        left, count, lastGCDIndex = 0, 0, 0\\n        for right, num in enumerate(nums):\\n            currentLen = right - left + 1\\n            if left == right:\\n                if num == k:\\n                    count += 1 \\n                    lastGCDIndex = right\\n                elif num % k == 0:\\n                    lastGCDIndex = right\\n                else:\\n                    left = right + 1\\n            else:\\n                if num == k:\\n                    count += currentLen\\n                    lastGCDIndex = right\\n                elif gcd(num, nums[right - 1]) == k:\\n                    lastGCDIndex = right\\n                    count += (currentLen - 1)\\n                elif num % k == 0:\\n                    count += currentLen - (currentLen - lastGCDIndex)\\n                else:\\n                    left = right + 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2738103,
                "title": "brute-force-solution-28-ms-and-100-faster-in-c",
                "content": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long gcd(ll a, ll b) {      //For FAST Execution \\n        if (b > a) {\\n             return gcd(b, a);\\n        }\\n        if (b == 0) {\\n            return a;\\n        }\\n        return gcd(b, a % b);\\n        }\\n    int subarrayGCD(vector<int>& nums, int k) {\\n        int ans=0;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            int val=0;\\n            for(int j=i;j<n;j++){\\n                val=gcd(val,nums[j]);   //brute force O(N*N)\\n                if(val==k)ans++;\\n\\t\\t\\t\\t//cout<<val<<\" \";\\n                if(val < k || (val%k)!=0) break;\\n            }\\n           \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long gcd(ll a, ll b) {      //For FAST Execution \\n        if (b > a) {\\n             return gcd(b, a);\\n        }\\n        if (b == 0) {\\n            return a;\\n        }\\n        return gcd(b, a % b);\\n        }\\n    int subarrayGCD(vector<int>& nums, int k) {\\n        int ans=0;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            int val=0;\\n            for(int j=i;j<n;j++){\\n                val=gcd(val,nums[j]);   //brute force O(N*N)\\n                if(val==k)ans++;\\n\\t\\t\\t\\t//cout<<val<<\" \";\\n                if(val < k || (val%k)!=0) break;\\n            }\\n           \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2737988,
                "title": "sliding-window-3ms-complexity",
                "content": "```\\npublic int subarrayGCD(int[] nums, int k) {\\n\\n        int count = 0, s=-1, e, repeatCount = 0, pre = 0;\\n\\n        LinkedList<PosOfTwo> stack = new LinkedList<>();\\n\\n        for(int i=0; i<nums.length; i++){\\n\\n            if(nums[i] % k == 0 && s == -1) s = i;\\n\\n            if(pre == k && nums[i] == pre) repeatCount++;\\n            else pre = nums[i];\\n\\n            if(nums[i] == k && ((i < nums.length-1 && nums[i+1] != k )|| i == nums.length-1)) {\\n                stack.add(new PosOfTwo(i, repeatCount + 1));\\n                repeatCount = 0;\\n            }\\n\\n            if(nums[i] % k != 0 || (i == nums.length-1 && nums[i] % k == 0)) {\\n                e = (i == nums.length-1 && nums[i] % k == 0) ? i : (i-1);\\n                for(PosOfTwo p:stack){\\n                    int rCount = e - p.lastPos, lCount = p.lastPos - s - (p.count - 1), multiplier = p.count;\\n                    lCount += (lCount*rCount);\\n                    count += (p.count * (p.count + 1) / 2) + (lCount+rCount) * multiplier;\\n                }\\n                stack.clear();\\n                repeatCount = 0;\\n                s=-1;\\n            }\\n\\n        }\\n\\n        int s1 = -1, gcd = 0;\\n\\n        for(int i=0; i<nums.length; i++){\\n            if (s1 == -1 && nums[i] % k == 0) s1 = i;\\n            gcd = gcd(nums[i], gcd);\\n            if(i > 0 && gcd == k && nums[i] != k) {\\n                if(gcd(nums[i], nums[i-1]) != k) count--;\\n                count += (i - s1);\\n            }\\n            if(nums[i] == k || (i != s1 && gcd != k && i< nums.length-1 && gcd(gcd,nums[i+1]) != k)) {\\n                s1 = -1;\\n                gcd = 0;\\n            }\\n        }\\n\\n\\n        return count;\\n    }\\n\\n   public int gcd(int x, int y){\\n        return y == 0 ? x : gcd(y, x%y);\\n    }\\n\\n    class PosOfTwo{\\n        int lastPos, count;\\n\\n        public PosOfTwo(int lastPos, int count) {\\n            this.lastPos = lastPos;\\n            this.count = count;\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\npublic int subarrayGCD(int[] nums, int k) {\\n\\n        int count = 0, s=-1, e, repeatCount = 0, pre = 0;\\n\\n        LinkedList<PosOfTwo> stack = new LinkedList<>();\\n\\n        for(int i=0; i<nums.length; i++){\\n\\n            if(nums[i] % k == 0 && s == -1) s = i;\\n\\n            if(pre == k && nums[i] == pre) repeatCount++;\\n            else pre = nums[i];\\n\\n            if(nums[i] == k && ((i < nums.length-1 && nums[i+1] != k )|| i == nums.length-1)) {\\n                stack.add(new PosOfTwo(i, repeatCount + 1));\\n                repeatCount = 0;\\n            }\\n\\n            if(nums[i] % k != 0 || (i == nums.length-1 && nums[i] % k == 0)) {\\n                e = (i == nums.length-1 && nums[i] % k == 0) ? i : (i-1);\\n                for(PosOfTwo p:stack){\\n                    int rCount = e - p.lastPos, lCount = p.lastPos - s - (p.count - 1), multiplier = p.count;\\n                    lCount += (lCount*rCount);\\n                    count += (p.count * (p.count + 1) / 2) + (lCount+rCount) * multiplier;\\n                }\\n                stack.clear();\\n                repeatCount = 0;\\n                s=-1;\\n            }\\n\\n        }\\n\\n        int s1 = -1, gcd = 0;\\n\\n        for(int i=0; i<nums.length; i++){\\n            if (s1 == -1 && nums[i] % k == 0) s1 = i;\\n            gcd = gcd(nums[i], gcd);\\n            if(i > 0 && gcd == k && nums[i] != k) {\\n                if(gcd(nums[i], nums[i-1]) != k) count--;\\n                count += (i - s1);\\n            }\\n            if(nums[i] == k || (i != s1 && gcd != k && i< nums.length-1 && gcd(gcd,nums[i+1]) != k)) {\\n                s1 = -1;\\n                gcd = 0;\\n            }\\n        }\\n\\n\\n        return count;\\n    }\\n\\n   public int gcd(int x, int y){\\n        return y == 0 ? x : gcd(y, x%y);\\n    }\\n\\n    class PosOfTwo{\\n        int lastPos, count;\\n\\n        public PosOfTwo(int lastPos, int count) {\\n            this.lastPos = lastPos;\\n            this.count = count;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2737931,
                "title": "c-simple-and-easy-approach",
                "content": "int subarrayGCD(vector<int>& nums, int k) {\\n\\n     int c=0;\\n\\t \\n        for(int i=0;i<nums.size();i++){\\n\\t\\t\\n            int ans=0;\\n\\t\\t\\n            for(int j=i;j<nums.size();j++){\\n\\t\\t\\t\\n\\t\\t\\t// here only we will check first that if the starting of the subarray is divsible by k or not if not then just break the loop  we are doing this because we are checking  every posiible subarray and it will reduce some time //\\n\\t\\t\\t\\n                if(nums[j]%k!=0){ \\n\\t\\t\\t\\tbreak;\\n                }\\n                ans=gcd(ans,nums[j]);\\n                if(ans==k){\\n                    c++;\\n                }\\n            }\\n        }\\n        return c;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "int subarrayGCD(vector<int>& nums, int k) {\\n\\n     int c=0;\\n\\t \\n        for(int i=0;i<nums.size();i++){\\n\\t\\t\\n            int ans=0;\\n\\t\\t\\n            for(int j=i;j<nums.size();j++){\\n\\t\\t\\t\\n\\t\\t\\t// here only we will check first that if the starting of the subarray is divsible by k or not if not then just break the loop  we are doing this because we are checking  every posiible subarray and it will reduce some time //\\n\\t\\t\\t\\n                if(nums[j]%k!=0){ \\n\\t\\t\\t\\tbreak;\\n                }\\n                ans=gcd(ans,nums[j]);\\n                if(ans==k){\\n                    c++;\\n                }\\n            }\\n        }\\n        return c;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2737888,
                "title": "basic-practice-brute-force-or-dp-python",
                "content": "1- A solution format\\n\\n```\\nclass Solution:\\n    def subarrayGCD(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        \\n        dp = [[1] * n for _ in range(n)]\\n        \\n        res = 0\\n        \\n        for i in range(n):\\n            dp[i][i] = nums[i]\\n            if dp[i][i] == k:\\n                res += 1\\n        \\n        for i in range(n):\\n            for j in range(i+1, n):\\n                dp[i][j] = math.gcd(dp[i][j-1], nums[j])\\n                if dp[i][j] == k:\\n                    res += 1\\n        \\n        return res\\n                \\n```\\n\\n2- Video Explanation: [Click Here](https://youtu.be/brOULH02Q-0;)\\n\\n3- Analysis or Summary\\n\\nFor each subarray starting from index i ending at index j, we compute the gcd.\\nThis requires O(n ** 2) time. We could mimic the way we do DP. \\n\\nThe reason we could do this is due to the observation: if we compute the\\ngcd d of a[i], a[i+1], ..., a[j], the could get the gcd of a[i], a[i+1], ... a[j], a[j+1]\\nby computing gdc(d, a[j+1]).\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def subarrayGCD(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        \\n        dp = [[1] * n for _ in range(n)]\\n        \\n        res = 0\\n        \\n        for i in range(n):\\n            dp[i][i] = nums[i]\\n            if dp[i][i] == k:\\n                res += 1\\n        \\n        for i in range(n):\\n            for j in range(i+1, n):\\n                dp[i][j] = math.gcd(dp[i][j-1], nums[j])\\n                if dp[i][j] == k:\\n                    res += 1\\n        \\n        return res\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2737703,
                "title": "java-7ms-faster-than-100-of-all-java-submissions-easy-java-code-easy-understanding",
                "content": "```java\\n\\nclass Solution {\\n    public static int findGcd(int a,int b){\\n        if(a == 0){\\n            return b;\\n        }\\n        \\n        return findGcd(b%a,a);\\n    }\\n    public int subarrayGCD(int[] nums, int k) {\\n        int ans=0;\\n        int n = nums.length;\\n        for(int i=0;i<n;i++){\\n            if(nums[i] < k){\\n                continue;\\n            }\\n            int gcd = nums[i];\\n            \\n            if(gcd == k){\\n                ans++;\\n            }\\n            \\n            for(int j=i+1;j<n;j++){\\n                \\n                if(nums[j] < k){\\n                    break;\\n                }\\n                \\n                gcd  =findGcd(gcd,nums[j]);\\n                \\n                if(gcd == k){\\n                    ans++;\\n                }\\n                \\n            }\\n        }\\n        \\n        \\n        \\n        return ans;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\n\\nclass Solution {\\n    public static int findGcd(int a,int b){\\n        if(a == 0){\\n            return b;\\n        }\\n        \\n        return findGcd(b%a,a);\\n    }\\n    public int subarrayGCD(int[] nums, int k) {\\n        int ans=0;\\n        int n = nums.length;\\n        for(int i=0;i<n;i++){\\n            if(nums[i] < k){\\n                continue;\\n            }\\n            int gcd = nums[i];\\n            \\n            if(gcd == k){\\n                ans++;\\n            }\\n            \\n            for(int j=i+1;j<n;j++){\\n                \\n                if(nums[j] < k){\\n                    break;\\n                }\\n                \\n                gcd  =findGcd(gcd,nums[j]);\\n                \\n                if(gcd == k){\\n                    ans++;\\n                }\\n                \\n            }\\n        }\\n        \\n        \\n        \\n        return ans;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2737654,
                "title": "simple-brute-force-solution-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int subarrayGCD(vector<int>& nums, int k) {\\n        int ans = 0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int g = nums[i];\\n            if(g==k)\\n                ans++;\\n            for(int j=i+1;j<nums.size();j++)\\n            {\\n                g = __gcd(g,nums[j]);\\n                if(g==k)\\n                    ans++;\\n                else if(g<k)\\n                    break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int subarrayGCD(vector<int>& nums, int k) {\\n        int ans = 0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int g = nums[i];\\n            if(g==k)\\n                ans++;\\n            for(int j=i+1;j<nums.size();j++)\\n            {\\n                g = __gcd(g,nums[j]);\\n                if(g==k)\\n                    ans++;\\n                else if(g<k)\\n                    break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2737424,
                "title": "c-two-pointer-18-lines",
                "content": "```C++\\nclass Solution {\\npublic:\\n    int subarrayGCD(vector<int>& nums, int k) {\\n        int ans = 0, L=0,R=0, cur_gcd = 0, n = nums.size();\\n        while(L<n && R<n) {\\n            cur_gcd = gcd(cur_gcd, nums[R]);\\n            if(cur_gcd == k) ans++;\\n            if(cur_gcd >= k) R++;\\n            if(cur_gcd < k || R>=n) {\\n                L = L+1;\\n                R = L;\\n                cur_gcd = 0;\\n            } \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```C++\\nclass Solution {\\npublic:\\n    int subarrayGCD(vector<int>& nums, int k) {\\n        int ans = 0, L=0,R=0, cur_gcd = 0, n = nums.size();\\n        while(L<n && R<n) {\\n            cur_gcd = gcd(cur_gcd, nums[R]);\\n            if(cur_gcd == k) ans++;\\n            if(cur_gcd >= k) R++;\\n            if(cur_gcd < k || R>=n) {\\n                L = L+1;\\n                R = L;\\n                cur_gcd = 0;\\n            } \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2737230,
                "title": "python3-easy-solution",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def subarrayGCD(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        i = 0;j = 0;ans = 0\\n        \\n        while(i<n):\\n            #print(gcd)\\n            gcd = nums[i]\\n            for j in range(i,n):\\n                gcd = GCD(nums[j],gcd)\\n                if(gcd==k):\\n                    ans+=1\\n                elif(gcd<k):\\n                    break\\n            i+=1\\n        return ans\\n            \\n            \\ndef GCD(a,b):\\n    if(b==0):\\n        return a\\n    else:\\n        return GCD(b,a%b)\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def subarrayGCD(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        i = 0;j = 0;ans = 0\\n        \\n        while(i<n):\\n            #print(gcd)\\n            gcd = nums[i]\\n            for j in range(i,n):\\n                gcd = GCD(nums[j],gcd)\\n                if(gcd==k):\\n                    ans+=1\\n                elif(gcd<k):\\n                    break\\n            i+=1\\n        return ans\\n            \\n            \\ndef GCD(a,b):\\n    if(b==0):\\n        return a\\n    else:\\n        return GCD(b,a%b)\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2737217,
                "title": "faster-than-100-java",
                "content": "```\\n//finding gcd\\n    public int gcd(int a, int b) {\\n        if (b == 0)\\n            return a;\\n        return gcd(b, a % b);\\n    }\\n    public int subarrayGCD(int[] nums, int k) {\\n        int count = 0;\\n        //First count the numbers itself\\n        for (int i =0; i<nums.length; i++) {\\n            if (nums[i] == k)\\n                count++;\\n        }\\n        for (int i =0; i<nums.length; i++) {\\n            int gcd = nums[i];\\n            for (int j = i+1; j < nums.length; j++){\\n                if (nums[j] < k)\\n                    break;\\n                gcd = gcd(gcd, nums[j]);\\n                if (gcd == k)\\n                    count++;\\n            }\\n        }\\n        return count;\\n\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n//finding gcd\\n    public int gcd(int a, int b) {\\n        if (b == 0)\\n            return a;\\n        return gcd(b, a % b);\\n    }\\n    public int subarrayGCD(int[] nums, int k) {\\n        int count = 0;\\n        //First count the numbers itself\\n        for (int i =0; i<nums.length; i++) {\\n            if (nums[i] == k)\\n                count++;\\n        }\\n        for (int i =0; i<nums.length; i++) {\\n            int gcd = nums[i];\\n            for (int j = i+1; j < nums.length; j++){\\n                if (nums[j] < k)\\n                    break;\\n                gcd = gcd(gcd, nums[j]);\\n                if (gcd == k)\\n                    count++;\\n            }\\n        }\\n        return count;\\n\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2737057,
                "title": "python3-beats-100-100",
                "content": "[170 ms, 14 MB] beats [100.00%, 100.00%]\\n\\n```\\nclass Solution:\\n    def subarrayGCD(self, nums, k):\\n        cnt=0 # number of working subsets\\n        for i in range(len(nums)): # left bound\\n            runningGCD = nums[i]\\n            for j in range(i, len(nums)):\\n                runningGCD = gcd(runningGCD, nums[j]) # generate new gcd of given subset\\n                if runningGCD==k:\\n                    cnt+=1\\n                elif runningGCD<k:\\n                    break\\n        return cnt\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def subarrayGCD(self, nums, k):\\n        cnt=0 # number of working subsets\\n        for i in range(len(nums)): # left bound\\n            runningGCD = nums[i]\\n            for j in range(i, len(nums)):\\n                runningGCD = gcd(runningGCD, nums[j]) # generate new gcd of given subset\\n                if runningGCD==k:\\n                    cnt+=1\\n                elif runningGCD<k:\\n                    break\\n        return cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2736946,
                "title": "python-beat-100-100",
                "content": "Explain: use slow and fast pointer to find the longest subarrays that  are divisable by k. Then track temp gcd until it == k, then add res += (f-j) because once the gcd is k, the subarray from i to any of f-j would satisfy requirment.\\n```\\nclass Solution:\\n    def subarrayGCD(self, nums: List[int], k: int) -> int:\\n        def gcd(a, b):\\n            if  b == 0: \\n                return a\\n            return gcd(b , a % b)\\n        \\n        s, f = 0, 0\\n        \\n        n, res = len(nums), 0\\n        \\n        while s < n:\\n            \\n            while f<n and nums[f] % k != 0: \\n                f += 1\\n            s = f\\n            \\n            while f<n and nums[f] % k == 0: \\n                f += 1\\n            \\n            for i in range(s, f):\\n                tp_gcd = nums[i]\\n                for j in range(i, f):\\n                    tp_gcd = gcd(tp_gcd, nums[j])\\n                    if tp_gcd == k:\\n                        res += (f-j)\\n                        break\\n            \\n            s = f\\n            \\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def subarrayGCD(self, nums: List[int], k: int) -> int:\\n        def gcd(a, b):\\n            if  b == 0: \\n                return a\\n            return gcd(b , a % b)\\n        \\n        s, f = 0, 0\\n        \\n        n, res = len(nums), 0\\n        \\n        while s < n:\\n            \\n            while f<n and nums[f] % k != 0: \\n                f += 1\\n            s = f\\n            \\n            while f<n and nums[f] % k == 0: \\n                f += 1\\n            \\n            for i in range(s, f):\\n                tp_gcd = nums[i]\\n                for j in range(i, f):\\n                    tp_gcd = gcd(tp_gcd, nums[j])\\n                    if tp_gcd == k:\\n                        res += (f-j)\\n                        break\\n            \\n            s = f\\n            \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2736927,
                "title": "java-inbuilt-gcd-brute-force-approach",
                "content": "```\\nclass Solution {\\n    public int subarrayGCD(int[] nums, int k) {\\n        int cnt = 0;\\n        for(int i = 0; i < nums.length; i += 1) {\\n            BigInteger hcf = BigInteger.ZERO;\\n            for(int j = i; j < nums.length && nums[i] % k == 0; j += 1) {\\n                hcf = hcf.gcd(BigInteger.valueOf(nums[j]));\\n                if(hcf.intValue() == k) cnt += 1;\\n            }\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int subarrayGCD(int[] nums, int k) {\\n        int cnt = 0;\\n        for(int i = 0; i < nums.length; i += 1) {\\n            BigInteger hcf = BigInteger.ZERO;\\n            for(int j = i; j < nums.length && nums[i] % k == 0; j += 1) {\\n                hcf = hcf.gcd(BigInteger.valueOf(nums[j]));\\n                if(hcf.intValue() == k) cnt += 1;\\n            }\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2736870,
                "title": "java-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int subarrayGCD(int[] nums, int k) {\\n        int ans=0;\\n        for(int i=0;i<nums.length;i++){\\n            int nx = 0;\\n            for(int j=i;j<nums.length;j++){\\n                nx = gcd(nums[j],nx);\\n                if(nx==k){\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    public int gcd(int a,int b){\\n        if(a<b){\\n            return gcd(b,a);\\n        }\\n        return b==0?a:gcd(b,a%b);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int subarrayGCD(int[] nums, int k) {\\n        int ans=0;\\n        for(int i=0;i<nums.length;i++){\\n            int nx = 0;\\n            for(int j=i;j<nums.length;j++){\\n                nx = gcd(nums[j],nx);\\n                if(nx==k){\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    public int gcd(int a,int b){\\n        if(a<b){\\n            return gcd(b,a);\\n        }\\n        return b==0?a:gcd(b,a%b);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2736838,
                "title": "2-approach-including-dp",
                "content": "```\\nclass Solution(object):\\n    def subarrayGCD(self, nums, k):\\n        count = 0\\n        for i in range(len(nums)):\\n            if nums[i]%k!= 0:\\n                continue\\n            gcd_ = nums[i]\\n            for j in range(i, len(nums)):\\n                if nums[j]%k!= 0:\\n                    break\\n                gcd_ = math.gcd(gcd_, nums[j])\\n                if gcd_ == k:\\n                    count+=1\\n        return count\\n```\\n\\n#### DP\\n\\n```\\nclass Solution:\\n    def subarrayGCD(self, nums: List[int], k: int) -> int:\\n        dp = {}\\n        def gcd_checker(arr):\\n            if len(set(arr)) == 1:\\n                return arr[0]\\n            if tuple(arr) in dp:\\n                return dp[tuple(arr)]\\n            if len(arr) == 1:\\n                return arr[0]\\n            gcd_ = gcd(arr[0], gcd_checker(arr[1:]))\\n            dp[tuple(arr)] = gcd_\\n            return dp[tuple(arr)]\\n        \\n        count = 0\\n        for i in range(len(nums)):\\n            if nums[i]%k!= 0:\\n                continue\\n            for j in range(i, len(nums)):\\n                if nums[j]%k!= 0:\\n                    break\\n                if gcd_checker(nums[i:j+1]) == k:\\n                    count+=1\\n        return count\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution(object):\\n    def subarrayGCD(self, nums, k):\\n        count = 0\\n        for i in range(len(nums)):\\n            if nums[i]%k!= 0:\\n                continue\\n            gcd_ = nums[i]\\n            for j in range(i, len(nums)):\\n                if nums[j]%k!= 0:\\n                    break\\n                gcd_ = math.gcd(gcd_, nums[j])\\n                if gcd_ == k:\\n                    count+=1\\n        return count\\n```\n```\\nclass Solution:\\n    def subarrayGCD(self, nums: List[int], k: int) -> int:\\n        dp = {}\\n        def gcd_checker(arr):\\n            if len(set(arr)) == 1:\\n                return arr[0]\\n            if tuple(arr) in dp:\\n                return dp[tuple(arr)]\\n            if len(arr) == 1:\\n                return arr[0]\\n            gcd_ = gcd(arr[0], gcd_checker(arr[1:]))\\n            dp[tuple(arr)] = gcd_\\n            return dp[tuple(arr)]\\n        \\n        count = 0\\n        for i in range(len(nums)):\\n            if nums[i]%k!= 0:\\n                continue\\n            for j in range(i, len(nums)):\\n                if nums[j]%k!= 0:\\n                    break\\n                if gcd_checker(nums[i:j+1]) == k:\\n                    count+=1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2736826,
                "title": "c-easy-solution-brute-force-algorithms",
                "content": "# Approach\\n\\npseudocode that prints all divisors of n by brute force\\n \\ndefine printDivisors, n\\n    for all numbers from 1 to n\\n        if the number is a divisor of n\\n            print the number\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int subarrayGCD(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        int ans = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            int currval = 0;\\n            for(int j = i; j < n; j++)\\n            {\\n                currval = __gcd(currval , nums[j]);\\n                if(currval == k)\\n                {\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subarrayGCD(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        int ans = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            int currval = 0;\\n            for(int j = i; j < n; j++)\\n            {\\n                currval = __gcd(currval , nums[j]);\\n                if(currval == k)\\n                {\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2736764,
                "title": "c-100-efficient-beginner-friendly-code",
                "content": "![Uploading file...]()\\n```\\nclass Solution {\\npublic:\\n    int subarrayGCD(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        int c=0;\\n        int d=0;\\n        for(int i=0;i<n;i++){\\n            d=0;\\n            for(int j=i;j<n;j++){\\n                d=__gcd(d,nums[j]);\\n                 if(d==k){\\n                     c++;\\n                 }\\n            }\\n            \\n        }\\n        return c;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int subarrayGCD(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        int c=0;\\n        int d=0;\\n        for(int i=0;i<n;i++){\\n            d=0;\\n            for(int j=i;j<n;j++){\\n                d=__gcd(d,nums[j]);\\n                 if(d==k){\\n                     c++;\\n                 }",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1655506,
                "content": [
                    {
                        "username": "abc29298727",
                        "content": "In example 1, why [9, 3, 6, 3] isn\\'t a subarray?"
                    },
                    {
                        "username": "yukelid",
                        "content": "not contiguous"
                    },
                    {
                        "username": "ARIELQ",
                        "content": "I also didn\\'t see the \"contiguous\" at the first place, and wasted half hour wondering why...."
                    },
                    {
                        "username": "abc29298727",
                        "content": "[@extrarishabh](/extrarishabh) Thanks a lot!"
                    },
                    {
                        "username": "abc29298727",
                        "content": "[@nubbins](/nubbins) Thanks a lot!"
                    },
                    {
                        "username": "nubbins",
                        "content": "Check the definition of subarray - it must be contiguous. There is no contiguous 9, 3,6,3 in example 1"
                    },
                    {
                        "username": "extrarishabh",
                        "content": "its not a subarray its a subsequence. read the concept of subarrays and subsequences"
                    },
                    {
                        "username": "bhautikkapadiya6",
                        "content": "class Solution {\\n    public int subarrayGCD(int[] nums, int k) {\\n        int n=nums.length;\\n        int count=0;\\n        if(n==1 && nums[0]<k){\\n            return 0;\\n        }\\n        else if(n==1 && nums[0]>k){\\n            return 1;\\n        }\\n        for(int i=0;i<n;i++){\\n            if(nums[i]%k==0){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n64/87 test case are pass how to solve this?"
                    },
                    {
                        "username": "Farhan_313",
                        "content": "[23,6,9]\\nk=6\\nwhy false   ......."
                    },
                    {
                        "username": "chandantiwari1",
                        "content": "c++ easy and understandable solution 100% result\\n\\n `your inline code...your inline code...`int subarrayGCD(vector<int>& nums, int k) {\\n        int sz=nums.size();\\n        int cnt=0;\\n        for(int i=0;i<sz;i++){\\n            int  gcd=nums[i];\\n            if(gcd==k) cnt++;\\n            for(int j=i+1;j<sz;j++){\\n                gcd= __gcd(gcd,nums[j]);\\n                if(gcd==k) cnt++;\\n            }\\n        }\\n        return cnt;\\n    } `your inline code...your inline code...`"
                    }
                ]
            },
            {
                "id": 2033051,
                "content": [
                    {
                        "username": "abc29298727",
                        "content": "In example 1, why [9, 3, 6, 3] isn\\'t a subarray?"
                    },
                    {
                        "username": "yukelid",
                        "content": "not contiguous"
                    },
                    {
                        "username": "ARIELQ",
                        "content": "I also didn\\'t see the \"contiguous\" at the first place, and wasted half hour wondering why...."
                    },
                    {
                        "username": "abc29298727",
                        "content": "[@extrarishabh](/extrarishabh) Thanks a lot!"
                    },
                    {
                        "username": "abc29298727",
                        "content": "[@nubbins](/nubbins) Thanks a lot!"
                    },
                    {
                        "username": "nubbins",
                        "content": "Check the definition of subarray - it must be contiguous. There is no contiguous 9, 3,6,3 in example 1"
                    },
                    {
                        "username": "extrarishabh",
                        "content": "its not a subarray its a subsequence. read the concept of subarrays and subsequences"
                    },
                    {
                        "username": "bhautikkapadiya6",
                        "content": "class Solution {\\n    public int subarrayGCD(int[] nums, int k) {\\n        int n=nums.length;\\n        int count=0;\\n        if(n==1 && nums[0]<k){\\n            return 0;\\n        }\\n        else if(n==1 && nums[0]>k){\\n            return 1;\\n        }\\n        for(int i=0;i<n;i++){\\n            if(nums[i]%k==0){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n64/87 test case are pass how to solve this?"
                    },
                    {
                        "username": "Farhan_313",
                        "content": "[23,6,9]\\nk=6\\nwhy false   ......."
                    },
                    {
                        "username": "chandantiwari1",
                        "content": "c++ easy and understandable solution 100% result\\n\\n `your inline code...your inline code...`int subarrayGCD(vector<int>& nums, int k) {\\n        int sz=nums.size();\\n        int cnt=0;\\n        for(int i=0;i<sz;i++){\\n            int  gcd=nums[i];\\n            if(gcd==k) cnt++;\\n            for(int j=i+1;j<sz;j++){\\n                gcd= __gcd(gcd,nums[j]);\\n                if(gcd==k) cnt++;\\n            }\\n        }\\n        return cnt;\\n    } `your inline code...your inline code...`"
                    }
                ]
            },
            {
                "id": 2014247,
                "content": [
                    {
                        "username": "abc29298727",
                        "content": "In example 1, why [9, 3, 6, 3] isn\\'t a subarray?"
                    },
                    {
                        "username": "yukelid",
                        "content": "not contiguous"
                    },
                    {
                        "username": "ARIELQ",
                        "content": "I also didn\\'t see the \"contiguous\" at the first place, and wasted half hour wondering why...."
                    },
                    {
                        "username": "abc29298727",
                        "content": "[@extrarishabh](/extrarishabh) Thanks a lot!"
                    },
                    {
                        "username": "abc29298727",
                        "content": "[@nubbins](/nubbins) Thanks a lot!"
                    },
                    {
                        "username": "nubbins",
                        "content": "Check the definition of subarray - it must be contiguous. There is no contiguous 9, 3,6,3 in example 1"
                    },
                    {
                        "username": "extrarishabh",
                        "content": "its not a subarray its a subsequence. read the concept of subarrays and subsequences"
                    },
                    {
                        "username": "bhautikkapadiya6",
                        "content": "class Solution {\\n    public int subarrayGCD(int[] nums, int k) {\\n        int n=nums.length;\\n        int count=0;\\n        if(n==1 && nums[0]<k){\\n            return 0;\\n        }\\n        else if(n==1 && nums[0]>k){\\n            return 1;\\n        }\\n        for(int i=0;i<n;i++){\\n            if(nums[i]%k==0){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n64/87 test case are pass how to solve this?"
                    },
                    {
                        "username": "Farhan_313",
                        "content": "[23,6,9]\\nk=6\\nwhy false   ......."
                    },
                    {
                        "username": "chandantiwari1",
                        "content": "c++ easy and understandable solution 100% result\\n\\n `your inline code...your inline code...`int subarrayGCD(vector<int>& nums, int k) {\\n        int sz=nums.size();\\n        int cnt=0;\\n        for(int i=0;i<sz;i++){\\n            int  gcd=nums[i];\\n            if(gcd==k) cnt++;\\n            for(int j=i+1;j<sz;j++){\\n                gcd= __gcd(gcd,nums[j]);\\n                if(gcd==k) cnt++;\\n            }\\n        }\\n        return cnt;\\n    } `your inline code...your inline code...`"
                    }
                ]
            },
            {
                "id": 1672954,
                "content": [
                    {
                        "username": "abc29298727",
                        "content": "In example 1, why [9, 3, 6, 3] isn\\'t a subarray?"
                    },
                    {
                        "username": "yukelid",
                        "content": "not contiguous"
                    },
                    {
                        "username": "ARIELQ",
                        "content": "I also didn\\'t see the \"contiguous\" at the first place, and wasted half hour wondering why...."
                    },
                    {
                        "username": "abc29298727",
                        "content": "[@extrarishabh](/extrarishabh) Thanks a lot!"
                    },
                    {
                        "username": "abc29298727",
                        "content": "[@nubbins](/nubbins) Thanks a lot!"
                    },
                    {
                        "username": "nubbins",
                        "content": "Check the definition of subarray - it must be contiguous. There is no contiguous 9, 3,6,3 in example 1"
                    },
                    {
                        "username": "extrarishabh",
                        "content": "its not a subarray its a subsequence. read the concept of subarrays and subsequences"
                    },
                    {
                        "username": "bhautikkapadiya6",
                        "content": "class Solution {\\n    public int subarrayGCD(int[] nums, int k) {\\n        int n=nums.length;\\n        int count=0;\\n        if(n==1 && nums[0]<k){\\n            return 0;\\n        }\\n        else if(n==1 && nums[0]>k){\\n            return 1;\\n        }\\n        for(int i=0;i<n;i++){\\n            if(nums[i]%k==0){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n64/87 test case are pass how to solve this?"
                    },
                    {
                        "username": "Farhan_313",
                        "content": "[23,6,9]\\nk=6\\nwhy false   ......."
                    },
                    {
                        "username": "chandantiwari1",
                        "content": "c++ easy and understandable solution 100% result\\n\\n `your inline code...your inline code...`int subarrayGCD(vector<int>& nums, int k) {\\n        int sz=nums.size();\\n        int cnt=0;\\n        for(int i=0;i<sz;i++){\\n            int  gcd=nums[i];\\n            if(gcd==k) cnt++;\\n            for(int j=i+1;j<sz;j++){\\n                gcd= __gcd(gcd,nums[j]);\\n                if(gcd==k) cnt++;\\n            }\\n        }\\n        return cnt;\\n    } `your inline code...your inline code...`"
                    }
                ]
            }
        ]
    }
]