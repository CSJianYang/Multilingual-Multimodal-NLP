[
    {
        "title": "The Winner University",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1576139,
                "content": [
                    {
                        "username": "xyz12345",
                        "content": "with nye as\\n(\\nselect count(student_id) as nnum\\nfrom newyork\\nwhere score >= 90)\\n\\n, cal as\\n(select count(student_id) as cnum\\nfrom california\\nwhere score >= 90)\\n\\nselect \\ncase   when  nnum > cnum then   \"New York University\"\\n          when  cnum >nnum  then   \"California University\"\\n          else    \"No Winner\"\\nend as winner\\nfrom nye, cal"
                    },
                    {
                        "username": "Paonevergivup",
                        "content": "with cte as(\\nselect \"NYU\" as School,count(student_id) as count_student\\nfrom NewYork\\nwhere score>=90\\nunion all\\nselect \"CU\" as School,count(student_id) as count_student\\nfrom California\\nwhere score>=90)\\n, cte2 as(\\nselect School, dense_rank() over(order by count_student desc) as rank_num\\nfrom cte)\\n\\nselect case when count(School)>1 then \"No Winner\" when School=\"NYU\" then \"New York University\" else \"California University\"  end as winner\\nfrom cte2\\nwhere rank_num=1"
                    }
                ]
            },
            {
                "id": 1576107,
                "content": [
                    {
                        "username": "xyz12345",
                        "content": "with nye as\\n(\\nselect count(student_id) as nnum\\nfrom newyork\\nwhere score >= 90)\\n\\n, cal as\\n(select count(student_id) as cnum\\nfrom california\\nwhere score >= 90)\\n\\nselect \\ncase   when  nnum > cnum then   \"New York University\"\\n          when  cnum >nnum  then   \"California University\"\\n          else    \"No Winner\"\\nend as winner\\nfrom nye, cal"
                    },
                    {
                        "username": "Paonevergivup",
                        "content": "with cte as(\\nselect \"NYU\" as School,count(student_id) as count_student\\nfrom NewYork\\nwhere score>=90\\nunion all\\nselect \"CU\" as School,count(student_id) as count_student\\nfrom California\\nwhere score>=90)\\n, cte2 as(\\nselect School, dense_rank() over(order by count_student desc) as rank_num\\nfrom cte)\\n\\nselect case when count(School)>1 then \"No Winner\" when School=\"NYU\" then \"New York University\" else \"California University\"  end as winner\\nfrom cte2\\nwhere rank_num=1"
                    }
                ]
            }
        ]
    },
    {
        "title": "Time Needed to Buy Tickets",
        "question_content": "<p>There are <code>n</code> people in a line queuing to buy tickets, where the <code>0<sup>th</sup></code> person is at the <strong>front</strong> of the line and the <code>(n - 1)<sup>th</sup></code> person is at the <strong>back</strong> of the line.</p>\n\n<p>You are given a <strong>0-indexed</strong> integer array <code>tickets</code> of length <code>n</code> where the number of tickets that the <code>i<sup>th</sup></code> person would like to buy is <code>tickets[i]</code>.</p>\n\n<p>Each person takes <strong>exactly 1 second</strong> to buy a ticket. A person can only buy <strong>1 ticket at a time</strong> and has to go back to <strong>the end</strong> of the line (which happens <strong>instantaneously</strong>) in order to buy more tickets. If a person does not have any tickets left to buy, the person will <strong>leave </strong>the line.</p>\n\n<p>Return <em>the <strong>time taken</strong> for the person at position </em><code>k</code><em>&nbsp;</em><strong><em>(0-indexed)</em>&nbsp;</strong><em>to finish buying tickets</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> tickets = [2,3,2], k = 2\n<strong>Output:</strong> 6\n<strong>Explanation:</strong> \n- In the first pass, everyone in the line buys a ticket and the line becomes [1, 2, 1].\n- In the second pass, everyone in the line buys a ticket and the line becomes [0, 1, 0].\nThe person at&nbsp;position 2 has successfully bought 2 tickets and it took 3 + 3 = 6 seconds.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> tickets = [5,1,1,1], k = 0\n<strong>Output:</strong> 8\n<strong>Explanation:</strong>\n- In the first pass, everyone in the line buys a ticket and the line becomes [4, 0, 0, 0].\n- In the next 4 passes, only the person in position 0 is buying tickets.\nThe person at&nbsp;position 0 has successfully bought 5 tickets and it took 4 + 1 + 1 + 1 + 1 = 8 seconds.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == tickets.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 100</code></li>\n\t<li><code>1 &lt;= tickets[i] &lt;= 100</code></li>\n\t<li><code>0 &lt;= k &lt; n</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 1576932,
                "title": "c-one-pass",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n## Solution 1. Brute Force Simulation\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/time-needed-to-buy-tickets/\\n// Author: github.com/lzl124631x\\n// Time: O(SUM(A))\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& A, int k) {\\n        int step = 0;\\n        while (true) {\\n            for (int i = 0; i < A.size(); ++i) {\\n                if (A[i] == 0) continue;\\n                A[i]--;\\n                ++step;\\n                if (A[k] == 0) return step;\\n            }\\n        }\\n    }\\n};\\n```\\n\\n## Solution 2. One Pass\\n\\nFor `i <= k`, `A[i]` contributes `min(A[k], A[i])` steps.\\n\\nFor `i > k`, `A[i]` contributes `min(A[k] - 1, A[i])` steps.\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/time-needed-to-buy-tickets/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& A, int k) {\\n        int ans = 0;\\n        for (int i = 0; i < A.size(); ++i) {\\n            ans += min(A[k] - (i > k), A[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/problems/time-needed-to-buy-tickets/\\n// Author: github.com/lzl124631x\\n// Time: O(SUM(A))\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& A, int k) {\\n        int step = 0;\\n        while (true) {\\n            for (int i = 0; i < A.size(); ++i) {\\n                if (A[i] == 0) continue;\\n                A[i]--;\\n                ++step;\\n                if (A[k] == 0) return step;\\n            }\\n        }\\n    }\\n};\\n```\n```cpp\\n// OJ: https://leetcode.com/problems/time-needed-to-buy-tickets/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& A, int k) {\\n        int ans = 0;\\n        for (int i = 0; i < A.size(); ++i) {\\n            ans += min(A[k] - (i > k), A[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1577093,
                "title": "o-n",
                "content": "We know the value of `k`-th element. Elements before `k` (and the element itself) will appear in the line `min(t[k], t[i])` times.\\n\\nAll elements after `k` will appear in the line  `min(t[k] - 1, t[i])` times.\\n\\n**Python 3**\\n```python\\nclass Solution:\\n    def timeRequiredToBuy(self, t: List[int], k: int) -> int:\\n        return sum(min(v, t[k] if i <= k else t[k] - 1) for i, v in enumerate(t))\\n```\\n**Java**\\n```java\\npublic int timeRequiredToBuy(int[] t, int k) {\\n    return IntStream.range(0, t.length).map(i -> Math.min(t[i], i > k ? t[k] - 1 : t[k])).sum();\\n}\\n```\\n**C++**\\n```cpp\\nint timeRequiredToBuy(vector<int>& t, int k) {\\n    int res = 0, sz = t.size(), cap = t[k];\\n    for (int i = 0; i < sz; ++i)\\n        res += min(cap - (i > k), t[i]);\\n    return res;\\n}\\n```\\nAlso a (slightly mouthful) functional version.\\n```cpp\\nint timeRequiredToBuy(vector<int>& t, int k) {\\n    return accumulate(begin(t), begin(t) + k + 1, 0, [&](int s, int v){ return s + min(v, t[k]); })\\n        + accumulate(begin(t) + k + 1, end(t), 0, [&](int s, int v){ return s + min(v, t[k] - 1); });\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```python\\nclass Solution:\\n    def timeRequiredToBuy(self, t: List[int], k: int) -> int:\\n        return sum(min(v, t[k] if i <= k else t[k] - 1) for i, v in enumerate(t))\\n```\n```java\\npublic int timeRequiredToBuy(int[] t, int k) {\\n    return IntStream.range(0, t.length).map(i -> Math.min(t[i], i > k ? t[k] - 1 : t[k])).sum();\\n}\\n```\n```cpp\\nint timeRequiredToBuy(vector<int>& t, int k) {\\n    int res = 0, sz = t.size(), cap = t[k];\\n    for (int i = 0; i < sz; ++i)\\n        res += min(cap - (i > k), t[i]);\\n    return res;\\n}\\n```\n```cpp\\nint timeRequiredToBuy(vector<int>& t, int k) {\\n    return accumulate(begin(t), begin(t) + k + 1, 0, [&](int s, int v){ return s + min(v, t[k]); })\\n        + accumulate(begin(t) + k + 1, end(t), 0, [&](int s, int v){ return s + min(v, t[k] - 1); });\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1577018,
                "title": "python-bruteforce-and-o-n",
                "content": "Please upvote if you find it helpful\\n\\nBruteForce:\\n```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: list[int], k: int) -> int:\\n        secs = 0 \\n        i = 0\\n        while tickets[k] != 0:\\n            if tickets[i] != 0: # if it is zero that means we dont have to count it anymore\\n                tickets[i] -= 1 # decrease the value by 1 everytime\\n                secs += 1 # increase secs by 1\\n\\n            i = (i + 1) % len(tickets) # since after getting to the end of the array we have to return to the first value so we use the mod operator\\n            \\n        return secs\\n```\\n\\nO(N):\\n```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        return sum(min(x, tickets[k] if i <= k else tickets[k] - 1) for i, x in enumerate(tickets))\\n```\\nThe values before tickets[k] will appear min(x, t[x]) times and values after tickets[k] will appear min(x, t[x] -1) times\\nLet\\'s take an example:\\n`tickets = [5, 2, 3, 4]` and `k = 2`\\n```1st iteration: [4, 1, 2, 3]```\\n```2nd iteration: [3, 0, 1, 2]```\\n```3rd iteration: [2, 0, 0, 1]```\\nYou see `tickets[0]` appeared 3 times which is min(5, 3) and that is 3, \\n             `tickets[1]` appeared 2 times which is min(2, 3) that is 2, \\n\\t\\t\\t `tickets[2]` appeared 3 times which is min(3, 3) that is 3 and \\n\\t\\t\\t `tickets[3]` appeared 2 times which is min(4, 2) that is 2.\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: list[int], k: int) -> int:\\n        secs = 0 \\n        i = 0\\n        while tickets[k] != 0:\\n            if tickets[i] != 0: # if it is zero that means we dont have to count it anymore\\n                tickets[i] -= 1 # decrease the value by 1 everytime\\n                secs += 1 # increase secs by 1\\n\\n            i = (i + 1) % len(tickets) # since after getting to the end of the array we have to return to the first value so we use the mod operator\\n            \\n        return secs\\n```\n```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        return sum(min(x, tickets[k] if i <= k else tickets[k] - 1) for i, x in enumerate(tickets))\\n```\n```1st iteration: [4, 1, 2, 3]```\n```2nd iteration: [3, 0, 1, 2]```\n```3rd iteration: [2, 0, 0, 1]```",
                "codeTag": "Java"
            },
            {
                "id": 1576926,
                "title": "java-o-n-one-pass-explained",
                "content": "**Explanation / Approach:**\\nBrute force is somewhat easy to come up with. You just need to iterate as long as tickets[k] != 0.\\n\\n**For an optimized approach :**\\n1. Add min(tickets[i],tickets[k]) upto k (inclusive).\\n2. Add min(tickets[i],tickets[k] - 1) after k.\\n3. Return the count.\\n\\nTime : O(n) , Space : O(1)\\n```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int res = 0;\\n        for(int i = 0;i<tickets.length;i++){\\n            if(i <= k){\\n                res += Math.min(tickets[k],tickets[i]);\\n            }else{\\n                res += Math.min(tickets[k] - 1,tickets[i]);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int res = 0;\\n        for(int i = 0;i<tickets.length;i++){\\n            if(i <= k){\\n                res += Math.min(tickets[k],tickets[i]);\\n            }else{\\n                res += Math.min(tickets[k] - 1,tickets[i]);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1589830,
                "title": "c-brute-force-vs-single-pass-solution-compared-and-explained-100-time-80-space",
                "content": "Given the constraints, we can easily afford to go for a brute force-ish solution first (a fully legitimate approach during any interview, as long as you keep the computationt time reasonable - I wouldn\\'t do this if either the queue length or the amount of tickets each queuer might buy were in the order of billions!), so we will go for it first.\\n\\nIn order to solve our problem we will first of all declare an accumulator variable `res`, initially set to `0` and that will store how many turns we have to wait until the `k`th slot has bought all his tickets.\\n\\nWe will then have an outer loop just to check that - `ts[k]` still having pending tickets to buy and inside it we will run another one, using the pointer `i` to parse `ts` until `ts[k]` is not `0` and in which we will:\\n* check if the currently pointed element `ts[i]` still has elements to remove and, in case:\\n\\t* decrease `ts[i]` by `1`;\\n\\t* increase `res` by `1`.\\n\\nOnce done, we can just `return` `res` :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& ts, int k) {\\n        // support variables\\n        int res = 0;\\n        // running loops until we get all our tickets\\n        while (ts[k]) {\\n            // running one loop\\n            for (int i = 0, lmt = ts.size(); i < lmt && ts[k]; i++) {\\n                // decreasing one slot and increasing res, if the slot still queues\\n                if (ts[i]) {\\n                    ts[i]--;\\n                    res++;\\n                }\\n            } \\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nBut, wait a minute \\uD83E\\uDD14 ...\\n\\nDo we really need to decrease all the cells one by one?\\n\\nWell, probably not, since we might quickly notice that the waiting time each slot to the left of `k` contributes is equal to the minimum between its current value and `ts[k]`, that we will call `target` for convenience; and it\\'s almost the same for all the elements to the right of it, being the minimum between its current value and `target - 1` (since we will go and touch them always after having decreased `ts[k]`.\\n\\nSo, we can put this into code and get much better performance with this version:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& ts, int k) {\\n        // support variables\\n        int res = 0, target = ts[k];\\n        // parsing the queue\\n        for (int i = 0, lmt = ts.size(); i < lmt; i++) {\\n            // getting the minimum between the current value and what we need to get\\n            res += min(ts[i], target - (i > k));\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nFinal micro-optimised version to avoid one conditional inside the loop (which probably would not even shine in terms of performance compared to allocating variables for a sole `for` loop unless we were to get really big ranges):\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& ts, int k) {\\n        // support variables\\n        int res = 0, target = ts[k];\\n        // parsing the queue up to k, included\\n        for (int i = 0; i <= k; i++) {\\n            // getting the minimum between the current value and target\\n            res += min(ts[i], target);\\n        }\\n        // parsing the queue up from  k, excluded\\n        target--;\\n        for (int i = k + 1, lmt = ts.size(); i < lmt; i++) {\\n            // getting the minimum between the current value and target\\n            res += min(ts[i], target);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Queue"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& ts, int k) {\\n        // support variables\\n        int res = 0;\\n        // running loops until we get all our tickets\\n        while (ts[k]) {\\n            // running one loop\\n            for (int i = 0, lmt = ts.size(); i < lmt && ts[k]; i++) {\\n                // decreasing one slot and increasing res, if the slot still queues\\n                if (ts[i]) {\\n                    ts[i]--;\\n                    res++;\\n                }\\n            } \\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& ts, int k) {\\n        // support variables\\n        int res = 0, target = ts[k];\\n        // parsing the queue\\n        for (int i = 0, lmt = ts.size(); i < lmt; i++) {\\n            // getting the minimum between the current value and what we need to get\\n            res += min(ts[i], target - (i > k));\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& ts, int k) {\\n        // support variables\\n        int res = 0, target = ts[k];\\n        // parsing the queue up to k, included\\n        for (int i = 0; i <= k; i++) {\\n            // getting the minimum between the current value and target\\n            res += min(ts[i], target);\\n        }\\n        // parsing the queue up from  k, excluded\\n        target--;\\n        for (int i = k + 1, lmt = ts.size(); i < lmt; i++) {\\n            // getting the minimum between the current value and target\\n            res += min(ts[i], target);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1577090,
                "title": "easy-to-understand",
                "content": "```\\nvar timeRequiredToBuy = function(tickets, k) {\\n     \\n    let countTime = 0;\\n\\n    while(tickets[k] !== 0){\\n\\n        for(let i = 0; i < tickets.length; i++){\\n            \\n            if(tickets[k] == 0){\\n                return countTime;\\n            }\\n            if(tickets[i] !== 0){\\n                tickets[i] = tickets[i] - 1;\\n                countTime++;\\n            }\\n        }\\n\\n    }\\n\\n    return countTime;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar timeRequiredToBuy = function(tickets, k) {\\n     \\n    let countTime = 0;\\n\\n    while(tickets[k] !== 0){\\n\\n        for(let i = 0; i < tickets.length; i++){\\n            \\n            if(tickets[k] == 0){\\n                return countTime;\\n            }\\n            if(tickets[i] !== 0){\\n                tickets[i] = tickets[i] - 1;\\n                countTime++;\\n            }\\n        }\\n\\n    }\\n\\n    return countTime;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1778911,
                "title": "python-o-n-easy-method",
                "content": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n\\t\\t#Loop through all elements in list only once.  \\n\\t\\t\\n        nums = tickets \\n        time_sec = 0\\n\\t\\t# save the number of tickets to be bought by person standing at k position\\n        least_tickets = nums[k]     \\n\\t\\t#(3) Any person nums[i] having tickets more than the k pos person, will buy tickets least_tickets times only.\\n\\t\\t#(2) Person nums[i] having tickets less than kth person ( nums[i] < least_tickets ), and standing before him(i<k), will be able to buy nums[i] amount.\\n\\t\\t#(1) Person nums[i] standing after kth person having more tickets than kth person, will be able to buy one less than the ticket kth person can buy(condition: least_tickets - 1).\\n        for i in range(len(nums)):                  \\n            if k < i and nums[i] >= least_tickets :         #(1)\\n                time_sec += (least_tickets - 1)\\n            elif nums[i] < least_tickets :                   #(2)\\n                time_sec += nums[i]\\n            else:                                            #(3)\\n                time_sec += least_tickets\\n\\t\\t\\t\\t\\n        return time_sec\\n        \\nPlease upvote if you find it useful and well-explained!",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Queue"
                ],
                "code": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n\\t\\t#Loop through all elements in list only once.  \\n\\t\\t\\n        nums = tickets \\n        time_sec = 0\\n\\t\\t# save the number of tickets to be bought by person standing at k position\\n        least_tickets = nums[k]     \\n\\t\\t#(3) Any person nums[i] having tickets more than the k pos person, will buy tickets least_tickets times only.\\n\\t\\t#(2) Person nums[i] having tickets less than kth person ( nums[i] < least_tickets ), and standing before him(i<k), will be able to buy nums[i] amount.\\n\\t\\t#(1) Person nums[i] standing after kth person having more tickets than kth person, will be able to buy one less than the ticket kth person can buy(condition: least_tickets - 1).\\n        for i in range(len(nums)):                  \\n            if k < i and nums[i] >= least_tickets :         #(1)\\n                time_sec += (least_tickets - 1)\\n            elif nums[i] < least_tickets :                   #(2)\\n                time_sec += nums[i]\\n            else:                                            #(3)\\n                time_sec += least_tickets\\n\\t\\t\\t\\t\\n        return time_sec\\n        \\nPlease upvote if you find it useful and well-explained!",
                "codeTag": "Java"
            },
            {
                "id": 1576991,
                "title": "python-1-liner",
                "content": "```python\\nreturn sum(min(tickets[k] - (i > k), num) for i, num in enumerate(tickets))\\n```",
                "solutionTags": [],
                "code": "```python\\nreturn sum(min(tickets[k] - (i > k), num) for i, num in enumerate(tickets))\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1577014,
                "title": "java-easy-solution-o-n",
                "content": "**Time Needed to Buy Tickets**\\n\\nSimple and crisp Solution - \\n\\n**Input:** tickets = [2,3,2], k = 2\\n**Output:** 6\\n**Explanation:** \\n- In the first pass, everyone in the line buys a ticket and the line becomes [1, 2, 1].\\n- In the second pass, everyone in the line buys a ticket and the line becomes [0, 1, 0].\\nThe person at position 2 has successfully bought 2 tickets and it took 3 + 3 = 6 seconds.\\n\\n```\\npublic int timeRequiredToBuy(int[] tickets, int k) {\\n        int timeTaken = 0;\\n        while(tickets[k] > 0) {\\n        \\tfor(int i = 0; i < tickets.length; i++) {\\n        \\t\\tif(tickets[i] > 0) {\\n        \\t\\t\\ttickets[i]--;\\n        \\t\\t\\ttimeTaken++;\\n        \\t\\t}\\n                if(tickets[k] == 0)  break;\\n        \\t}\\n        }\\n        return timeTaken;\\n    }\\n```\\n\\t\\nTime Complexity - **O(n^2)**\\n\\n\\t\\n```\\n\\tpublic int timeRequiredToBuy(int[] tickets, int k) {\\n\\t      int timeTaken = 0;\\n          for(int i = 0; i < tickets.length; i++){\\n                if(tickets[i] <= tickets[k]){\\n                     timeTaken += tickets[i];\\n                }\\n                else  timeTaken += tickets[k];\\n                if(i > k && tickets[i] >= tickets[k])  timeTaken--;\\n          }\\n          return timeTaken;\\n    }\\n```\\t\\n\\t\\nTime Complexity - **O(n)**\\n\\nCredit - @yadavharsha50",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int timeRequiredToBuy(int[] tickets, int k) {\\n        int timeTaken = 0;\\n        while(tickets[k] > 0) {\\n        \\tfor(int i = 0; i < tickets.length; i++) {\\n        \\t\\tif(tickets[i] > 0) {\\n        \\t\\t\\ttickets[i]--;\\n        \\t\\t\\ttimeTaken++;\\n        \\t\\t}\\n                if(tickets[k] == 0)  break;\\n        \\t}\\n        }\\n        return timeTaken;\\n    }\\n```\n```\\n\\tpublic int timeRequiredToBuy(int[] tickets, int k) {\\n\\t      int timeTaken = 0;\\n          for(int i = 0; i < tickets.length; i++){\\n                if(tickets[i] <= tickets[k]){\\n                     timeTaken += tickets[i];\\n                }\\n                else  timeTaken += tickets[k];\\n                if(i > k && tickets[i] >= tickets[k])  timeTaken--;\\n          }\\n          return timeTaken;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1584144,
                "title": "c-very-easy-o-n-my-thought",
                "content": "Hint :- Simple solustion is to count time for every element and return sum of it. \\n\\nJust bruthforces, Element before k index take min of element or that index value and ,after k index it take min of element-1 or that index. Here element-1 because in last round we will not go for element which index is greater then k.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n            int ans =0;\\n            int n = tickets.size();\\n            int ele = tickets[k];\\n            for(int i=0;i< n; i++){\\n                    if(i<=k){\\n                        ans+= min(ele, tickets[i]);\\n                    }else{\\n                        ans+= min(ele-1, tickets[i]);   \\n                    }\\n            }\\n            return ans;\\n    }\\n};\\n```\\n\\n**Upvote If like my solustion ::)**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n            int ans =0;\\n            int n = tickets.size();\\n            int ele = tickets[k];\\n            for(int i=0;i< n; i++){\\n                    if(i<=k){\\n                        ans+= min(ele, tickets[i]);\\n                    }else{\\n                        ans+= min(ele-1, tickets[i]);   \\n                    }\\n            }\\n            return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3189150,
                "title": "c-solution-beats-100-easy-to-understand-and-easy-solution",
                "content": "# Intuition\\nWe have to just keep decreasing 1 from each element.\\n\\n# Approach\\n1. We will traverse the array and keep decreasing 1 from every element till the element at kth position gets 0.\\n2. We will also keep a count variable to keep track of the steps required for kth element to reach 0.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int count = 0, i = 0;\\n\\n        while(tickets[k] != 0){\\n            if(i == tickets.size()){\\n                i = 0;\\n            }\\n            if(tickets[i] == 0){\\n                i++;\\n                continue;\\n            }\\n            tickets[i]--;\\n            count++;\\n            i++;\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int count = 0, i = 0;\\n\\n        while(tickets[k] != 0){\\n            if(i == tickets.size()){\\n                i = 0;\\n            }\\n            if(tickets[i] == 0){\\n                i++;\\n                continue;\\n            }\\n            tickets[i]--;\\n            count++;\\n            i++;\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1582397,
                "title": "1-ms-java-solution",
                "content": "```\\n public int timeRequiredToBuy(int[] tickets, int k) {\\n        \\n        int seconds = 0;\\n        int i = 0;\\n        while(tickets[k] != 0)\\n        {\\n            if(tickets[i] != 0)\\n            {\\n                tickets[i] = tickets[i] -1;\\n                seconds++;\\n            }\\n            if(i == tickets.length - 1)\\n            {\\n                i = 0;\\n                continue;\\n            }\\n                i++;\\n        }\\n\\n        return seconds;\\n    }\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n public int timeRequiredToBuy(int[] tickets, int k) {\\n        \\n        int seconds = 0;\\n        int i = 0;\\n        while(tickets[k] != 0)\\n        {\\n            if(tickets[i] != 0)\\n            {\\n                tickets[i] = tickets[i] -1;\\n                seconds++;\\n            }\\n            if(i == tickets.length - 1)\\n            {\\n                i = 0;\\n                continue;\\n            }\\n                i++;\\n        }\\n\\n        return seconds;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2037468,
                "title": "simple-c-code",
                "content": "# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        queue<pair<int,int>>q;\\n        int time = 0;\\n        for(int i = 0; i < tickets.size(); i++)\\n        {\\n            q.push({tickets[i],i});\\n        }\\n        while(!q.empty())\\n        {\\n            pair<int,int> tmp = q.front();\\n            q.pop();\\n            --tmp.first;\\n            ++time;\\n            if(tmp.first == 0 && tmp.second == k)\\n            {\\n                break;\\n            }\\n            else if(tmp.first != 0)\\n            {\\n                q.push({tmp.first,tmp.second});\\n            }\\n        }\\n        return time;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        queue<pair<int,int>>q;\\n        int time = 0;\\n        for(int i = 0; i < tickets.size(); i++)\\n        {\\n            q.push({tickets[i],i});\\n        }\\n        while(!q.empty())\\n        {\\n            pair<int,int> tmp = q.front();\\n            q.pop();\\n            --tmp.first;\\n            ++time;\\n            if(tmp.first == 0 && tmp.second == k)\\n            {\\n                break;\\n            }\\n            else if(tmp.first != 0)\\n            {\\n                q.push({tmp.first,tmp.second});\\n            }\\n        }\\n        return time;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1577912,
                "title": "brute-deque-optimised-in-one-pass",
                "content": "1)BRUTE FORCE APPROACH -> \\nA) SIMULATE THE GIVEN PROBLEM USING DEQUE DATA STRUCTURE  \\nKEEP A COUNTER WHEN KTH ELEMENT BECOMES 0 THATS EASY :)\\n\\nTC -> O(K * ARR[K]) -> IN WORST CASE IF K IS LAST ELEMENT\\nSC -> O(2*N) -> TAKEN A PAIR\\n\\nCODE -> \\n```\\n\\t\\tdeque<pair<int,int>>dq;\\n        for(int i = 0;  i < tickets.size(); i++) {\\n            dq.push_back({tickets[i] , i});\\n        }\\n        int ans = 0;\\n        while(!dq.empty()) {\\n            int val = dq.front().first;\\n            int idx = dq.front().second;\\n            val--;\\n            ans++;\\n            if(idx == k && val == 0) {\\n                break;\\n            }\\n            if(val == 0) {\\n                dq.pop_front();\\n            } else {\\n                dq.pop_front();\\n                dq.push_back({val, idx});\\n            }\\n        }\\n        return ans;\\n```\\n\\nOPTIMISED APPROACH->\\n\\nTHINK WITH RESPECT TO K -> TAKE 2 CASES\\n1) ELEMENTS BEFORE K -> WILL TAKE MIN(ARR[I] , ARR[K]) STEPS IN TOTAL\\n2) ELEMENTS AFTER K  ->  WILL TAKE MIN(ARR[I] , ARR[K] - 1 STEPS) IN TOTAL\\n3) YOUR ANS IS (1 + 2) -> \\n\\nCODE -> \\n```\\n\\t int ans = 1;\\n        int val = tickets[k];\\n        for(int i = 0 ; i < tickets.size(); i++) {\\n            if(i < k) {\\n                //THE ELEMENTS THAT LIE BEFORE K\\n                if(tickets[i]  < val) {\\n                    ans += tickets[i];\\n                } else {\\n                    ans += val;\\n                }\\n            } else {\\n                //THE ELEMENTS THAT LIE AFTER K\\n                if(tickets[i] < val - 1) {\\n                    ans += tickets[i];\\n                } else {\\n                    ans += (val - 1);\\n                }   \\n            }   \\n        } \\n        return ans;\\n```\\n\\nTC -> O(N) SINGLE PASS\\nSC -> O(1) :)\\n\\nTHANK YOU DO SHARE AND UPVOTE IF YOU LIKED THE APPROACH\\n",
                "solutionTags": [
                    "Queue"
                ],
                "code": "```\\n\\t\\tdeque<pair<int,int>>dq;\\n        for(int i = 0;  i < tickets.size(); i++) {\\n            dq.push_back({tickets[i] , i});\\n        }\\n        int ans = 0;\\n        while(!dq.empty()) {\\n            int val = dq.front().first;\\n            int idx = dq.front().second;\\n            val--;\\n            ans++;\\n            if(idx == k && val == 0) {\\n                break;\\n            }\\n            if(val == 0) {\\n                dq.pop_front();\\n            } else {\\n                dq.pop_front();\\n                dq.push_back({val, idx});\\n            }\\n        }\\n        return ans;\\n```\n```\\n\\t int ans = 1;\\n        int val = tickets[k];\\n        for(int i = 0 ; i < tickets.size(); i++) {\\n            if(i < k) {\\n                //THE ELEMENTS THAT LIE BEFORE K\\n                if(tickets[i]  < val) {\\n                    ans += tickets[i];\\n                } else {\\n                    ans += val;\\n                }\\n            } else {\\n                //THE ELEMENTS THAT LIE AFTER K\\n                if(tickets[i] < val - 1) {\\n                    ans += tickets[i];\\n                } else {\\n                    ans += (val - 1);\\n                }   \\n            }   \\n        } \\n        return ans;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3918164,
                "title": "brute-force-optimized-queue-interviewer-mindset",
                "content": "# Intuition\\n1. Brute force using loop iteration\\n2. optimised using one loop\\n3. Queue solution for more in depth\\n\\n# Approach\\nWe find out min of tickets[i] and tickets[k]\\n\\n\\n\\n## Brute force approach\\n- Time complexity: O(N^2)\\n```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k){\\n        int n= tickets.length;\\n        int time=0;\\n    \\n        if(tickets[k]==1) return k+1;\\n        while(tickets[k]>0){\\n            for(int i=0;i<n;i++){\\n                if(tickets[i]==0) continue;\\n                tickets[i]=tickets[i]-1;\\n                time++;\\n                if(tickets[k]==0) break;\\n            }\\n        }k--;\\n        return time;\\n    }\\n}\\n\\n```\\n## Optimized approach: without extra space\\n\\n- Time complexity: O(N)\\n- - space complexity: O(1)\\n```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int time = 0;\\n        for(int i = 0;i<tickets.length;i++){\\n            if(i <= k){\\n                time += Math.min(tickets[k],tickets[i]);\\n            }else{\\n                time+= Math.min(tickets[k] - 1,tickets[i]);\\n            }\\n        }\\n        return time;\\n    }\\n}\\n\\n```\\n## Queue approach : taking extra space\\n- Time complexity: O(N)\\n- space complexity: O(N)\\n```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        Queue<Integer> q = new LinkedList<>();\\n\\n        for ( int i = 0; i < tickets.length; i++){\\n           q.add(i);\\n        }\\n        int count = 0;\\n        while(!q.isEmpty()){\\n            ++count;\\n            int front = q.poll();\\n            if(tickets[front] >= 1){\\n                tickets[front] -= 1;\\n            }\\n            if(k == front && tickets[front] == 0){\\n                break;\\n            }\\n            if(k != front && tickets[front] == 0){\\n                continue;\\n            }\\n            q.add(front);\\n        }\\n        return count;\\n    }\\n}\\n```\\n![cat-upvote.jpg](https://assets.leetcode.com/users/images/7c799b02-abd9-44f8-98a2-e4830340d206_1692193011.7738297.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k){\\n        int n= tickets.length;\\n        int time=0;\\n    \\n        if(tickets[k]==1) return k+1;\\n        while(tickets[k]>0){\\n            for(int i=0;i<n;i++){\\n                if(tickets[i]==0) continue;\\n                tickets[i]=tickets[i]-1;\\n                time++;\\n                if(tickets[k]==0) break;\\n            }\\n        }k--;\\n        return time;\\n    }\\n}\\n\\n```\n```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int time = 0;\\n        for(int i = 0;i<tickets.length;i++){\\n            if(i <= k){\\n                time += Math.min(tickets[k],tickets[i]);\\n            }else{\\n                time+= Math.min(tickets[k] - 1,tickets[i]);\\n            }\\n        }\\n        return time;\\n    }\\n}\\n\\n```\n```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        Queue<Integer> q = new LinkedList<>();\\n\\n        for ( int i = 0; i < tickets.length; i++){\\n           q.add(i);\\n        }\\n        int count = 0;\\n        while(!q.isEmpty()){\\n            ++count;\\n            int front = q.poll();\\n            if(tickets[front] >= 1){\\n                tickets[front] -= 1;\\n            }\\n            if(k == front && tickets[front] == 0){\\n                break;\\n            }\\n            if(k != front && tickets[front] == 0){\\n                continue;\\n            }\\n            q.add(front);\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3615121,
                "title": "100-beats-o-n-solution-without-using-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n       int n=tickets.size();\\n       int total=tickets[k];\\n\\n        for(int i=0;i<k;i++){\\n            total+=min(tickets[k],tickets[i]);\\n        }\\n        for(int i=k+1;i<n;i++){\\n            total+=min(tickets[k]-1,tickets[i]);\\n        }\\n        return total;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n       int n=tickets.size();\\n       int total=tickets[k];\\n\\n        for(int i=0;i<k;i++){\\n            total+=min(tickets[k],tickets[i]);\\n        }\\n        for(int i=k+1;i<n;i++){\\n            total+=min(tickets[k]-1,tickets[i]);\\n        }\\n        return total;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2567182,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n    int count=0;\\n        while(tickets[k]>0){\\n            for(int i=0;i<tickets.length;i++){\\n                if(tickets[i]>0){\\n                    tickets[i]-=1;\\n                    count++;\\n                }\\n                if(tickets[k]==0)break;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n    int count=0;\\n        while(tickets[k]>0){\\n            for(int i=0;i<tickets.length;i++){\\n                if(tickets[i]>0){\\n                    tickets[i]-=1;\\n                    count++;\\n                }\\n                if(tickets[k]==0)break;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2489688,
                "title": "python-simple-and-clean-beats-77-69",
                "content": "### Please upvote if you find this helpful. \\u270C\\n<img src=\"https://assets.leetcode.com/users/images/b8e25620-d320-420a-ae09-94c7453bd033_1678818986.7001078.jpeg\" alt=\"Cute Robot - Stable diffusion\" width=\"200\"/>\\n\\n*This is an NFT*\\n\\n##### **Single Pass Solution**\\n1. People before *k-th* person will take mininum of reqd tickets and *k-th* person ticket\\n2. People after *k-th* person will take 1 ticket less than, because after oue person takes the ticket the objective will be completed and we do not need to count more time for people **standing after him**\\n\\n##### **Implementation**\\n```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        num = tickets[k]\\n        res = 0\\n        for i in range(k+1):\\n            res += min(tickets[i],num)\\n        for i in range(k+1,len(tickets)):\\n            res += min(tickets[i],num-1)\\n        return res\\n```\\n\\n![image](https://assets.leetcode.com/users/images/7ab4074a-00a1-49e3-a1fb-fc62d50bfe0f_1661594988.4600484.png)\\n",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        num = tickets[k]\\n        res = 0\\n        for i in range(k+1):\\n            res += min(tickets[i],num)\\n        for i in range(k+1,len(tickets)):\\n            res += min(tickets[i],num-1)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1763737,
                "title": "java-solution-faster-than-100-of-all-submissions-o-n",
                "content": "```\\n\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n      int output = 0;\\n      int n = tickets.length;\\n      for  (int i = 0;i<n;i++){\\n          if(tickets[i] < tickets[k]){\\n              output += tickets[i];\\n          }else{\\n                if(i <= k){\\n                  output += tickets[k];\\n              }else { \\n                  output += tickets[k] - 1;\\n              } \\n          }\\n\\n      }\\n      return output;\\n    }\\n}\\n```\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n      int output = 0;\\n      int n = tickets.length;\\n      for  (int i = 0;i<n;i++){\\n          if(tickets[i] < tickets[k]){\\n              output += tickets[i];\\n          }else{\\n                if(i <= k){\\n                  output += tickets[k];\\n              }else { \\n                  output += tickets[k] - 1;\\n              } \\n          }\\n\\n      }\\n      return output;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1577071,
                "title": "c-0ms-explained-easy-one-pass",
                "content": "Three cases possible are,\\n\\n`If` the ticket holders have less tickets to buy than our Kth ticket holder, they will have got all the tickets they wanted before kth ticket holder gets all its tickets,\\n\\n`else if` the ticket holders have more ticketsto buy than our Kth ticket holder, and they are ahead in line(position < k) then, they will have bought `tickets[k]` tickets before kth ticket holder gets all the tickets it needs,\\n\\n`else if` the ticket holders have more tickets to buy than our Kth ticket holder, and they are behind in line(position > k) then, they will have bought 1 ticket less than `tickets[k]` before kth ticket holder gets all the tickets it needs.\\n\\n```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        \\n        int ticket = tickets[k];\\n        int res = 0;\\n        for(int i = 0; i<tickets.size(); i++){\\n          if(tickets[i] < ticket) res+=tickets[i];\\n          else if(tickets[i] >= ticket and i <= k) res+=ticket;\\n          else if(tickets[i] >= ticket and i > k) res+=ticket-1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        \\n        int ticket = tickets[k];\\n        int res = 0;\\n        for(int i = 0; i<tickets.size(); i++){\\n          if(tickets[i] < ticket) res+=tickets[i];\\n          else if(tickets[i] >= ticket and i <= k) res+=ticket;\\n          else if(tickets[i] >= ticket and i > k) res+=ticket-1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3490739,
                "title": "very-easy-java-solution-using-queue",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        Queue<Integer> queue = new LinkedList<>();\\n        int ans = 0;\\n        for(int i = 0; i < tickets.length; i++){\\n            queue.add(i);\\n        }\\n        while(!queue.isEmpty()){\\n            int index = queue.poll();\\n            tickets[index]--;\\n            ans++;\\n            if(tickets[index] == 0 && index == k){\\n                return ans;\\n            }\\n            if(tickets[index] > 0){\\n                queue.add(index);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        Queue<Integer> queue = new LinkedList<>();\\n        int ans = 0;\\n        for(int i = 0; i < tickets.length; i++){\\n            queue.add(i);\\n        }\\n        while(!queue.isEmpty()){\\n            int index = queue.poll();\\n            tickets[index]--;\\n            ans++;\\n            if(tickets[index] == 0 && index == k){\\n                return ans;\\n            }\\n            if(tickets[index] > 0){\\n                queue.add(index);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2607037,
                "title": "java-simple-code-100-faster",
                "content": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int seconds = 0;\\n        for(int i = 0; i < tickets.length; i++){\\n            if(tickets[i] < tickets[k]) seconds += tickets[i]; // only add the time needed to buy his tickets\\n            else{\\n                if(i <= k) seconds += tickets[k]; \\n                else seconds += tickets[k] - 1; \\n            }\\n        }\\n        return seconds;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int seconds = 0;\\n        for(int i = 0; i < tickets.length; i++){\\n            if(tickets[i] < tickets[k]) seconds += tickets[i]; // only add the time needed to buy his tickets\\n            else{\\n                if(i <= k) seconds += tickets[k]; \\n                else seconds += tickets[k] - 1; \\n            }\\n        }\\n        return seconds;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2495619,
                "title": "one-pass-c-easy-to-understand",
                "content": "People infront of our target person will get all their tickets before our target man if they want tickets less than or equal to him. If they want more tickets than him they will only get tickets equal to him till target man gets all his tickets.\\n\\nFor people behind target man, they will get all tickets if they want tickets strictly less than him. If they want more than him, they will get one less than tickets target man wants till he gets all his tickets.\\n\\'\\'\\'\\n              \\n    class Solution {\\n    public:\\n        int timeRequiredToBuy(vector<int>& tickets, int k) {\\n            int n=tickets.size();\\n            int time=tickets[k];\\n            for(int i=0;i<tickets.size();i++){\\n            //Elements infront of target\\n                  //If they are smaller or equal to target value collect them whole \\n                  //If they are greater collect target value\\n            if(i<k){\\n                if(tickets[i]<=tickets[k]){\\n                    time+=tickets[i];\\n                }\\n                else{\\n                    time+=tickets[k];\\n                }\\n            }\\n            //Elements behind target\\n                  //If they are smaller than target value collect them whole \\n                  //If they are greater collect (target-1) value\\n            else if(i>k){\\n                if(tickets[i]<tickets[k]){\\n                    time+=tickets[i];\\n                }\\n                else{\\n                    time+=(tickets[k]-1);\\n                }\\n            }\\n        }\\n        return time;\\n    }\\n};\\n\\t\\t\\t        \\n\\t\\t\\t      \\n\\'\\'\\'",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n    public:\\n        int timeRequiredToBuy(vector<int>& tickets, int k) {\\n            int n=tickets.size();\\n            int time=tickets[k];\\n            for(int i=0;i<tickets.size();i++){\\n            //Elements infront of target\\n                  //If they are smaller or equal to target value collect them whole \\n                  //If they are greater collect target value\\n            if(i<k){\\n                if(tickets[i]<=tickets[k]){\\n                    time+=tickets[i];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1642918,
                "title": "simple-c-solution-0ms",
                "content": "This is easy to understand solution..\\nDo give a like!.\\n\\n\\n\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n    int n=tickets.size(),ans=0;\\n    \\n    for(int i=0;i<n;i++)\\n    {\\n        if(i>k)\\n            ans+=min(tickets[i],tickets[k]-1);\\n        else if(i<k)\\n            ans+=min(tickets[i],tickets[k]);\\n        else\\n            ans+=tickets[k];\\n                \\n    }\\n        \\n    return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "This is easy to understand solution..\\nDo give a like!.\\n\\n\\n\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n    int n=tickets.size(),ans=0;\\n    \\n    for(int i=0;i<n;i++)\\n    {\\n        if(i>k)\\n            ans+=min(tickets[i],tickets[k]-1);\\n        else if(i<k)\\n            ans+=min(tickets[i],tickets[k]);\\n        else\\n            ans+=tickets[k];\\n                \\n    }\\n        \\n    return ans;\\n    }\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 3485730,
                "title": "python3-queue",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        \\n        n=len(tickets)\\n        q=deque([i for i in range(n)])\\n        \\n        time=0\\n        \\n        while q:\\n            for i in range(len(q)):\\n\\n                node=q.popleft()\\n                tickets[node]-=1\\n                if tickets[node]>=1:\\n                    q.append(node)\\n                \\n                time+=1\\n                if tickets[k]==0:\\n                    return time\\n                \\n                \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Queue"
                ],
                "code": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        \\n        n=len(tickets)\\n        q=deque([i for i in range(n)])\\n        \\n        time=0\\n        \\n        while q:\\n            for i in range(len(q)):\\n\\n                node=q.popleft()\\n                tickets[node]-=1\\n                if tickets[node]>=1:\\n                    q.append(node)\\n                \\n                time+=1\\n                if tickets[k]==0:\\n                    return time\\n                \\n                \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2253744,
                "title": "c-2-ways-bruteforce-optimal",
                "content": "# Method-1 [Brute Force]\\n\\n![image](https://assets.leetcode.com/users/images/c883d3c4-59d3-430e-a16d-5e1b6532e52b_1657263680.476677.png)\\n\\n**n==t.size()\\nT->O(tickets[k] * n) && S->(1)**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint timeRequiredToBuy(vector<int>& t, int k) {\\n\\t\\t\\tint time=0;\\n\\t\\t\\twhile(1){\\n\\t\\t\\t\\tfor(int i=0;i<t.size();i++){\\n\\t\\t\\t\\t\\tif(t[i]>0){\\n\\t\\t\\t\\t\\t\\tt[i]--;\\n\\t\\t\\t\\t\\t\\ttime++;\\n\\t\\t\\t\\t\\t\\tif(t[k]==0)return time;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\t};\\n\\t\\n\\t\\n# Method-2 [Optimal solution]\\t\\n\\t\\n![image](https://assets.leetcode.com/users/images/98e24ff0-6f30-429b-8292-63a194bf3895_1657264759.6914196.png)\\n\\n**In one pass!\\nT->O(n) && S->O(1)**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint timeRequiredToBuy(vector<int>& t, int k) {\\n\\t\\t\\tint time=0;\\n\\t\\t\\tfor(int i=0;i<t.size();i++){\\n\\t\\t\\t\\tif(t[i]<t[k])time+=t[i];\\n\\t\\t\\t\\telse time+=t[k];\\n\\t\\t\\t\\tif(i>k && t[i]>=t[k])time--;\\n\\t\\t\\t}\\n\\t\\t\\treturn time;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint timeRequiredToBuy(vector<int>& t, int k) {\\n\\t\\t\\tint time=0;\\n\\t\\t\\twhile(1){\\n\\t\\t\\t\\tfor(int i=0;i<t.size();i++){\\n\\t\\t\\t\\t\\tif(t[i]>0){\\n\\t\\t\\t\\t\\t\\tt[i]--;\\n\\t\\t\\t\\t\\t\\ttime++;\\n\\t\\t\\t\\t\\t\\tif(t[k]==0)return time;\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2147186,
                "title": "c-queue-cycle",
                "content": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        queue<int> q;\\n        for(int i : tickets) q.push(i);\\n        int res = 0;\\n        int p = k;\\n        \\n        while(true){\\n            res++;\\n            if(q.front()-- > 1) q.push(q.front());\\n            else if(p == 0) break;\\n            q.pop();\\n            if(--p < 0) p = q.size() - 1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        queue<int> q;\\n        for(int i : tickets) q.push(i);\\n        int res = 0;\\n        int p = k;\\n        \\n        while(true){\\n            res++;\\n            if(q.front()-- > 1) q.push(q.front());\\n            else if(p == 0) break;\\n            q.pop();\\n            if(--p < 0) p = q.size() - 1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2104569,
                "title": "0-ms-java-solution",
                "content": "suppose the given array is [2,3,7,5,1,2,7] and k is pointing to element = 5.\\nwe need to find that each element is reduced how many times till we get 0 at the index 3. The element before 5 will be reduced by = **minimum of (value of ith element, value of kth element)**\\n the element before 5 are [2,3,7,5] and these will be reduced to [0,0,2,0] when the kth guy get ticket \\n \\n![image](https://assets.leetcode.com/users/images/bfea9c2c-94db-4fa0-8e6b-f20bf067424a_1654226809.5009036.png)\\n\\nnow element after 5 are [1,2,7] here we have a case, the element 1,2 will be completly reduce to 0 but the element greater than k will reduce to 1 lesser than the kth element (shown below ) because the kth element guy got the ticket and we don\\'t need to worry about the leftover.\\n\\n![image](https://assets.leetcode.com/users/images/c826088c-eaf7-4d83-9543-a55494e2c89c_1654226960.949127.png)\\n\\n**please upvote my solution if u like it \\u2764\\uFE0F** \\n```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int count = 0;\\n        for(int i = 0 ; i < tickets.length; ++i){\\n            if(i <=k){\\n                count += Math.min(tickets[i], tickets[k]);\\n            }\\n            else\\n                count += Math.min(tickets[i], tickets[k] - 1);\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int count = 0;\\n        for(int i = 0 ; i < tickets.length; ++i){\\n            if(i <=k){\\n                count += Math.min(tickets[i], tickets[k]);\\n            }\\n            else\\n                count += Math.min(tickets[i], tickets[k] - 1);\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2084750,
                "title": "python-simple-readable-easy-to-understand-solution-beats-69",
                "content": "The approach is as follows:\\n1. Keep track of the number of seconds (this is what will be returned)\\n2. As long as the person at k index still has tickets to buy:\\n\\t* Sell tickets to everyone in the line who still has tickets to buy\\n\\t* Add a second for each ticket sold\\n3. Return how many seconds were needed to sell the person at k index all of their tickets\\n```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        num_seconds = 0\\n        \\n        while tickets[k] > 0:\\n            for i in range(len(tickets)):\\n                if tickets[i] > 0 and tickets[k] > 0:\\n                    tickets[i] -= 1\\n                    num_seconds += 1\\n\\n        return num_seconds\\n```\\n![image](https://assets.leetcode.com/users/images/6c478172-bc00-416c-9d13-fbda59d8cb15_1653763898.4271393.png)\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        num_seconds = 0\\n        \\n        while tickets[k] > 0:\\n            for i in range(len(tickets)):\\n                if tickets[i] > 0 and tickets[k] > 0:\\n                    tickets[i] -= 1\\n                    num_seconds += 1\\n\\n        return num_seconds\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1958399,
                "title": "c-easy-o-n",
                "content": "***Upvote If you like the solution***\\n```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int num=tickets[k],tt=0;\\n        for(int i=0;i<tickets.size();i++){\\n            if(num>tickets[i]){\\n                tt+=tickets[i];\\n            }\\n            else if(num<=tickets[i]){\\n                tt+=num;\\n            }\\n        }\\n        for(int i=k+1;i<tickets.size();i++){\\n            if(tickets[i]>=num){\\n                tt-=1;\\n            }\\n        }\\n        return tt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int num=tickets[k],tt=0;\\n        for(int i=0;i<tickets.size();i++){\\n            if(num>tickets[i]){\\n                tt+=tickets[i];\\n            }\\n            else if(num<=tickets[i]){\\n                tt+=num;\\n            }\\n        }\\n        for(int i=k+1;i<tickets.size();i++){\\n            if(tickets[i]>=num){\\n                tt-=1;\\n            }\\n        }\\n        return tt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1612829,
                "title": "python-o-n-time-complexity-faster-than-97",
                "content": "```\\nclass Solution(object):\\n    def timeRequiredToBuy(self, tickets, k):\\n        ans = 0\\n        \\n\\t\\t# people at the front will always get 1 ticket first\\n\\t\\t# get minimum to know how many times a person will queue and buy before kth person\\n        for tix in range(k+1):\\n            ans += min(tickets[tix], tickets[k])\\n\\n\\t\\t# contrary to people at the front, \\n\\t\\t# kth person will only go behind everyone *(people initially behind k)* for tickets[k]-1 times \\n        for tix in range(k+1, len(tickets)):\\n            ans += min(tickets[tix], tickets[k]-1)\\n            \\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def timeRequiredToBuy(self, tickets, k):\\n        ans = 0\\n        \\n\\t\\t# people at the front will always get 1 ticket first\\n\\t\\t# get minimum to know how many times a person will queue and buy before kth person\\n        for tix in range(k+1):\\n            ans += min(tickets[tix], tickets[k])\\n\\n\\t\\t# contrary to people at the front, \\n\\t\\t# kth person will only go behind everyone *(people initially behind k)* for tickets[k]-1 times \\n        for tix in range(k+1, len(tickets)):\\n            ans += min(tickets[tix], tickets[k]-1)\\n            \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1576949,
                "title": "python3-1-line",
                "content": "Please check out this [commit](https://github.com/gaosanyong/leetcode/commit/8d693371fa97ea3b0717d02448c77201b15e5d12) for solutions of weekly 267.\\n\\n```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        return sum(min(tickets[k]-int(i>k), x) for i, x in enumerate(tickets))\\n```\\n\\n```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        ans = behind = 0 \\n        for i, x in enumerate(tickets): \\n            if i > k: behind = 1\\n            if x < tickets[k] - behind: ans += x\\n            else: ans += tickets[k] - behind\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        return sum(min(tickets[k]-int(i>k), x) for i, x in enumerate(tickets))\\n```\n```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        ans = behind = 0 \\n        for i, x in enumerate(tickets): \\n            if i > k: behind = 1\\n            if x < tickets[k] - behind: ans += x\\n            else: ans += tickets[k] - behind\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3981218,
                "title": "two-simple-solutions-in-python3-queue-ds-inifinite-looping",
                "content": "# Intuition\\nFollowing to the description of the problem, the task goal is to calculate **min amount of time**, that `K`- buyer needs to spend in order to buy tickets.\\n\\nSomehow we need to iterate over all buyers, reduce the current amount of tickets they\\'re bying at the moment, shift the current buyer to **the END of a** `queue` and repeat the process.\\n\\n---\\n\\n- **Queue DS**\\n\\nIf you haven\\'t already familiar with [Queue DS](https://en.wikipedia.org/wiki/Queue_(abstract_data_type)), just follow the link to know more!\\n\\n1. change `tickets` variable by initializing a `deque` and **map** `i` and `v` for current buyer, \\n2. initialize `ans` variable and `while` loop, that\\'ll iterate **infinitely**\\n3. pop from `tickets` current buyer\\n4. increment total amount `ans` \\n5. check, if the current buyer has bought all of the tickets, and return `ans`\\n6. otherwise, if he needs to buy **more** tickets, return him to the `tickets` queue\\n\\n```python\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: list[int], k: int) -> int:\\n        tickets = deque([[i, v] for i, v in enumerate(tickets)])\\n        ans = 0\\n\\n        while True:\\n            i, v = tickets.popleft()\\n            ans += 1\\n\\n            if i == k and v - 1 == 0:\\n                return ans\\n            \\n            if v > 1:\\n                tickets.append([i, v - 1])\\n```\\n# Complexity\\n- Time complexity: **O(n)**, because of iterating infinitely over all `tickets` buyers\\n\\n- Space complexity: **O(n)**, to map indexes and values for `tickets`\\n\\n---\\n\\n- **Inifinite looping**\\nThe approach is the same, but we **mutate** the initial values of `tickets`.\\n\\n# Code\\n```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: list[int], k: int) -> int:\\n        if tickets[k] == 0:\\n            return 0\\n        \\n        i = 0\\n        ans = 0\\n\\n        while True:\\n            if tickets[i]:\\n                tickets[i] -= 1\\n                ans += 1\\n\\n            if i == k and tickets[i] == 0:\\n                return ans\\n            \\n            i += 1\\n            \\n            if i == len(tickets):\\n                i = 0\\n\\n```\\n\\n# Complexity\\n- Time complexity: **O(n)**, because of iterating infinitely over all `tickets` buyers\\n\\n- Space complexity: **O(1)**, because we don\\'t use extra space.\\n",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Queue"
                ],
                "code": "```python\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: list[int], k: int) -> int:\\n        tickets = deque([[i, v] for i, v in enumerate(tickets)])\\n        ans = 0\\n\\n        while True:\\n            i, v = tickets.popleft()\\n            ans += 1\\n\\n            if i == k and v - 1 == 0:\\n                return ans\\n            \\n            if v > 1:\\n                tickets.append([i, v - 1])\\n```\n```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: list[int], k: int) -> int:\\n        if tickets[k] == 0:\\n            return 0\\n        \\n        i = 0\\n        ans = 0\\n\\n        while True:\\n            if tickets[i]:\\n                tickets[i] -= 1\\n                ans += 1\\n\\n            if i == k and tickets[i] == 0:\\n                return ans\\n            \\n            i += 1\\n            \\n            if i == len(tickets):\\n                i = 0\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367526,
                "title": "time-needed-to-buy-tickets-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n*m)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int i, time=0;\\n        while(true)\\n        {\\n            for(i=0 ; i<tickets.size() ; i++)\\n            {\\n                if(tickets[k]==0)\\n                    return time;\\n                else if(tickets[i]>0)\\n                {\\n                    tickets[i]--;\\n                    time++;\\n                }\\n            }\\n            i=0;\\n        }\\n        return time;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/792a2ee3-fa92-4936-9a87-216cd9a9ac02_1682613207.1269994.jpeg)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int i, time=0;\\n        while(true)\\n        {\\n            for(i=0 ; i<tickets.size() ; i++)\\n            {\\n                if(tickets[k]==0)\\n                    return time;\\n                else if(tickets[i]>0)\\n                {\\n                    tickets[i]--;\\n                    time++;\\n                }\\n            }\\n            i=0;\\n        }\\n        return time;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3158772,
                "title": "easy-solution-with-explanation",
                "content": "If you like it, please upvote\\n\\n# Code\\n```\\n/**\\n * @param {number[]} tickets\\n * @param {number} k\\n * @return {number}\\n */\\nvar timeRequiredToBuy = function(tickets, k) {\\n    // current index\\n    let i = 0;\\n    // number of steps\\n    let steps = 0;\\n\\n    // while tickets[k] > 0\\n    while (tickets[k]) {\\n        // we do not need to reset i because it is easier to calculate index in the array\\n        const index = i % tickets.length;\\n        if (tickets[index]) {\\n            // if element is not 0 then decrement the value and increment the number of steps\\n            tickets[index]--;\\n            steps++;\\n        }\\n        // every time move to next element\\n        i++;\\n    }\\n\\n    return steps;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} tickets\\n * @param {number} k\\n * @return {number}\\n */\\nvar timeRequiredToBuy = function(tickets, k) {\\n    // current index\\n    let i = 0;\\n    // number of steps\\n    let steps = 0;\\n\\n    // while tickets[k] > 0\\n    while (tickets[k]) {\\n        // we do not need to reset i because it is easier to calculate index in the array\\n        const index = i % tickets.length;\\n        if (tickets[index]) {\\n            // if element is not 0 then decrement the value and increment the number of steps\\n            tickets[index]--;\\n            steps++;\\n        }\\n        // every time move to next element\\n        i++;\\n    }\\n\\n    return steps;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3076905,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int ans =0;\\n        for(int i=0;i<tickets.length;i++){\\n            if(i<=k){\\n                ans+=Math.min(tickets[i],tickets[k]);\\n            }else{\\n                ans+=Math.min(tickets[k]-1,tickets[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int ans =0;\\n        for(int i=0;i<tickets.length;i++){\\n            if(i<=k){\\n                ans+=Math.min(tickets[i],tickets[k]);\\n            }else{\\n                ans+=Math.min(tickets[k]-1,tickets[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3061869,
                "title": "java-1ms-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int count = 0;\\n        while (tickets[k] != 0) {\\n            for (int i = 0; i < tickets.length; i++) {\\n                if (tickets[i] > 0) {\\n                    count++;\\n                    tickets[i]--;\\n                }\\n                if (i == k && tickets[k] == 0) break;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int count = 0;\\n        while (tickets[k] != 0) {\\n            for (int i = 0; i < tickets.length; i++) {\\n                if (tickets[i] > 0) {\\n                    count++;\\n                    tickets[i]--;\\n                }\\n                if (i == k && tickets[k] == 0) break;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2936461,
                "title": "cpp-queue-easiest-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int time=0;\\n        queue<int> q;\\n        int n=tickets.size();\\n        for(int i=0;i<n;i++) q.push(i);\\n\\n        while(true)\\n        {\\n            if(tickets[k]==0) break;\\n            int curr=q.front();\\n            time++;\\n            tickets[curr]--;\\n            q.pop();\\n            if(tickets[curr]!=0) \\n            {\\n                q.push(curr);\\n            }\\n        }\\n        return time;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int time=0;\\n        queue<int> q;\\n        int n=tickets.size();\\n        for(int i=0;i<n;i++) q.push(i);\\n\\n        while(true)\\n        {\\n            if(tickets[k]==0) break;\\n            int curr=q.front();\\n            time++;\\n            tickets[curr]--;\\n            q.pop();\\n            if(tickets[curr]!=0) \\n            {\\n                q.push(curr);\\n            }\\n        }\\n        return time;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2919190,
                "title": "c-basic-solution-beats-100",
                "content": "# Intuition\\nBasic C++ Solution using logic\\n\\n# Approach\\nCounting tickets to be bought before and after k by taking minima.\\n\\n# Complexity\\n- Time complexity:O(n)\\n\\n\\n- Space complexity:O(1)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int time=0;\\n        for(int i=0;i<tickets.size();i++){\\n            if(i<=k)\\n              time+=min(tickets[i],tickets[k]);\\n            else\\n              time+=min(tickets[k]-1,tickets[i]);\\n        }\\n        return time;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int time=0;\\n        for(int i=0;i<tickets.size();i++){\\n            if(i<=k)\\n              time+=min(tickets[i],tickets[k]);\\n            else\\n              time+=min(tickets[k]-1,tickets[i]);\\n        }\\n        return time;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2903503,
                "title": "js-very-easy-and-fast-solution-o-n",
                "content": "# Code\\n```\\n/**\\n * @param {number[]} tickets\\n * @param {number} k\\n * @return {number}\\n */\\nvar timeRequiredToBuy = function(tickets, k) {\\n    let output = 0;\\n    const kTickets = tickets[k];\\n    for (let i = 0; i < tickets.length; i++) {\\n        if (i !== k) {\\n            const currentTickets = tickets[i];\\n            const dif = currentTickets - kTickets;\\n            if (i < k) {\\n                output += kTickets + (dif < 0 ? dif : 0);\\n            } else {\\n                output += (dif + 1 > 0 ? kTickets - 1 : currentTickets);\\n            }\\n        }\\n    }\\n    return output + kTickets;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} tickets\\n * @param {number} k\\n * @return {number}\\n */\\nvar timeRequiredToBuy = function(tickets, k) {\\n    let output = 0;\\n    const kTickets = tickets[k];\\n    for (let i = 0; i < tickets.length; i++) {\\n        if (i !== k) {\\n            const currentTickets = tickets[i];\\n            const dif = currentTickets - kTickets;\\n            if (i < k) {\\n                output += kTickets + (dif < 0 ? dif : 0);\\n            } else {\\n                output += (dif + 1 > 0 ? kTickets - 1 : currentTickets);\\n            }\\n        }\\n    }\\n    return output + kTickets;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2852598,
                "title": "java-code-without-queue-o-1-space-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    \\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        \\n    int ans=0;\\n\\n    while(tickets[k]>0){\\n        \\n    int count=0;\\n\\n    for(int j=0;j<tickets.length;j++){\\n\\n        if(tickets[j]>0&&tickets[k]!=0){\\n            tickets[j]-=1;\\n            count+=1;\\n        }\\n\\n    }\\n\\n    ans=ans+count;\\n\\n    }\\n\\n    return ans;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Queue",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        \\n    int ans=0;\\n\\n    while(tickets[k]>0){\\n        \\n    int count=0;\\n\\n    for(int j=0;j<tickets.length;j++){\\n\\n        if(tickets[j]>0&&tickets[k]!=0){\\n            tickets[j]-=1;\\n            count+=1;\\n        }\\n\\n    }\\n\\n    ans=ans+count;\\n\\n    }\\n\\n    return ans;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2724197,
                "title": "c-100-faster-than-all-easy",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n   int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int n=tickets.size();\\n        int time=tickets[k];\\n        for(int i=0;i<tickets.size();i++){\\n        if(i<k){\\n            if(tickets[i]<=tickets[k]){\\n                time+=tickets[i];\\n            }\\n            else{\\n                time+=tickets[k];\\n            }\\n        }\\n        else if(i>k){\\n            if(tickets[i]<tickets[k]){\\n                time+=tickets[i];\\n            }\\n            else{\\n                time+=(tickets[k]-1);\\n            }\\n        }\\n    }\\n    return time;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int n=tickets.size();\\n        int time=tickets[k];\\n        for(int i=0;i<tickets.size();i++){\\n        if(i<k){\\n            if(tickets[i]<=tickets[k]){\\n                time+=tickets[i];\\n            }\\n            else{\\n                time+=tickets[k];\\n            }\\n        }\\n        else if(i>k){\\n            if(tickets[i]<tickets[k]){\\n                time+=tickets[i];\\n            }\\n            else{\\n                time+=(tickets[k]-1);\\n            }\\n        }\\n    }\\n    return time;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2596216,
                "title": "java-time-complexity-o-n-and-space-complexity-o-1-100-faster",
                "content": "Idea is quite simple\\n1. All the seconds will be consumed if tickets[i] < tickets [k].\\n2. If tickets[i] > tickets[k] then only tickets[k] will be consumed.\\n3. Just an exception to the 2nd point is that for the last iteration when all the people will consume 1 second, this will be people from 0 -> k. Hence we do tickets[k] - 1\\n\\n```\\nint minRequired = tickets[k];\\n        int output = 0;\\n\\n        for (int i = 0; i < tickets.length; i++) {\\n            if(tickets[i] < minRequired){\\n                output += tickets[i];\\n            }else {\\n\\n                if(i > k){\\n                    output--;\\n                }\\n                output += minRequired;\\n            }\\n        }\\n\\n        return output;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "Idea is quite simple\\n1. All the seconds will be consumed if tickets[i] < tickets [k].\\n2. If tickets[i] > tickets[k] then only tickets[k] will be consumed.\\n3. Just an exception to the 2nd point is that for the last iteration when all the people will consume 1 second, this will be people from 0 -> k. Hence we do tickets[k] - 1\\n\\n```\\nint minRequired = tickets[k];\\n        int output = 0;\\n\\n        for (int i = 0; i < tickets.length; i++) {\\n            if(tickets[i] < minRequired){\\n                output += tickets[i];\\n            }else {\\n\\n                if(i > k){\\n                    output--;\\n                }\\n                output += minRequired;\\n            }\\n        }\\n\\n        return output;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2558725,
                "title": "java-solution-using-single-queue",
                "content": "In this solution, I multiply the target index \\'k\\' content with \\'-1\\'. to keep track of the customer.\\nAnd, I reduce the number of tickets by 1. Once the target customer\\'s tickets count reduces to zero, I return the time-taken.\\n\\n```java\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        \\n        if(tickets[k] == 0) return 0;\\n        \\n        tickets[k] = -1 * tickets[k];\\n        \\n        Deque<Integer> queue = new ArrayDeque<>();\\n        for(int n : tickets){\\n            if(n != 0) queue.offerLast(n);\\n        }\\n        \\n        int timeTaken = 0;\\n        \\n        while(!queue.isEmpty()){\\n            int ticket = queue.pollFirst();\\n            \\n            boolean target = ticket < 0;\\n            \\n            if(ticket < 0) ticket += 1;\\n            else ticket -= 1;\\n            \\n            ++timeTaken;\\n            \\n            if(ticket == 0 && target) break;\\n            if(ticket != 0) queue.offerLast(ticket);\\n        }\\n        \\n        return timeTaken;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Queue",
                    "Iterator"
                ],
                "code": "```java\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        \\n        if(tickets[k] == 0) return 0;\\n        \\n        tickets[k] = -1 * tickets[k];\\n        \\n        Deque<Integer> queue = new ArrayDeque<>();\\n        for(int n : tickets){\\n            if(n != 0) queue.offerLast(n);\\n        }\\n        \\n        int timeTaken = 0;\\n        \\n        while(!queue.isEmpty()){\\n            int ticket = queue.pollFirst();\\n            \\n            boolean target = ticket < 0;\\n            \\n            if(ticket < 0) ticket += 1;\\n            else ticket -= 1;\\n            \\n            ++timeTaken;\\n            \\n            if(ticket == 0 && target) break;\\n            if(ticket != 0) queue.offerLast(ticket);\\n        }\\n        \\n        return timeTaken;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2195525,
                "title": "java-o-n-100-faster-solution",
                "content": "class Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int t=tickets[k],tt=0;\\n        \\n        for(int i=0;i<tickets.length;i++){\\n            if(i<=k){\\n                if(tickets[i]<=t){\\n                    tt+=tickets[i];\\n                }else{\\n                    tt+=t;\\n                }\\n            }else{\\n                if(tickets[i]<t){\\n                    tt+=tickets[i];\\n                }else{\\n                    tt+=(t-1);\\n                }\\n            }\\n        }\\n        \\n        return tt;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Iterator"
                ],
                "code": "class Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int t=tickets[k],tt=0;\\n        \\n        for(int i=0;i<tickets.length;i++){\\n            if(i<=k){\\n                if(tickets[i]<=t){\\n                    tt+=tickets[i];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2126547,
                "title": "c-solution-0ms-100-faster-explained",
                "content": "**Method:**\\n\\n* There can be 3 cases:\\n* Case 1 :\\n    * If the ticket holders have less tickets to buy than our Kth ticket holder\\n    * Then, they will have got all the tickets they wanted before kth ticket holder gets all its tickets\\n* Case 2:\\n    * if the ticket holders have more tickets to buy than our Kth ticket holder and they are ahead in line(position < k) \\n    * Then, they will have bought \"tickets[k]\" tickets before kth ticket holder gets all the tickets it needs\\n* Case 3:\\n    * if the ticket holders have more tickets to buy than our Kth ticket holder, and they are behind in line(position > k) \\n    * Then, they will have bought 1 ticket less than tickets[k] before kth ticket holder gets all the tickets it needs.\\n\\n\\n**Code:**\\n\\n```\\nclass Solution\\n{\\npublic:\\n    int timeRequiredToBuy(vector<int> &tickets, int k)\\n    {\\n        int n = tickets.size();\\n        int t = tickets[k];\\n        int s = 0;\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (tickets[i] < t)\\n            {\\n                s += tickets[i];\\n            }\\n            else\\n            {\\n                if (i <= k)\\n                {\\n                    s += t;\\n                }\\n                else\\n                {\\n                    s += t - 1;\\n                }\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int timeRequiredToBuy(vector<int> &tickets, int k)\\n    {\\n        int n = tickets.size();\\n        int t = tickets[k];\\n        int s = 0;\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (tickets[i] < t)\\n            {\\n                s += tickets[i];\\n            }\\n            else\\n            {\\n                if (i <= k)\\n                {\\n                    s += t;\\n                }\\n                else\\n                {\\n                    s += t - 1;\\n                }\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1903082,
                "title": "python-solution-using-list-as-queue",
                "content": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        c=0\\n        while(tickets[k]!=0):\\n            c+=1\\n\\t\\t\\t#check if kth element is now the first element of our queue.\\n            if(tickets[0]==1):\\n                tickets.pop(0)\\n                if(k==0):\\n                    return(c)\\n                else:\\n                    k-=1\\n            else:\\n\\t\\t\\t#if no of tickets of person at first position in queue are more than 1 we move to the back\\n                tickets.append(tickets[0]-1)\\n                tickets.pop(0)\\n                if(k==0):\\n                    k=len(tickets)-1\\n                else:\\n                    k-=1\\n```",
                "solutionTags": [
                    "Python",
                    "Queue"
                ],
                "code": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        c=0\\n        while(tickets[k]!=0):\\n            c+=1\\n\\t\\t\\t#check if kth element is now the first element of our queue.\\n            if(tickets[0]==1):\\n                tickets.pop(0)\\n                if(k==0):\\n                    return(c)\\n                else:\\n                    k-=1\\n            else:\\n\\t\\t\\t#if no of tickets of person at first position in queue are more than 1 we move to the back\\n                tickets.append(tickets[0]-1)\\n                tickets.pop(0)\\n                if(k==0):\\n                    k=len(tickets)-1\\n                else:\\n                    k-=1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1826842,
                "title": "c-solution-with-comments-faster-than-100-o-n-time-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int need = tickets[k];\\n        int wait = need; // k has to buy their own tickets.\\n        \\n        // For each person ahead of k in line, k has to wait for them\\n        // to buy up to as many tickets as k needs.\\n        for (int i = 0; i < k; ++i) {\\n            wait += tickets[i] > need ? need : tickets[i];\\n        }\\n        \\n        // For each person in line after k, k has to wait for them\\n        // to buy up to 1 fewer ticket than k needs.\\n        --need;\\n        for (int i = k + 1; i < tickets.size(); ++i) {\\n            wait += tickets[i] > need ? need : tickets[i];\\n        }\\n        \\n        return wait;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int need = tickets[k];\\n        int wait = need; // k has to buy their own tickets.\\n        \\n        // For each person ahead of k in line, k has to wait for them\\n        // to buy up to as many tickets as k needs.\\n        for (int i = 0; i < k; ++i) {\\n            wait += tickets[i] > need ? need : tickets[i];\\n        }\\n        \\n        // For each person in line after k, k has to wait for them\\n        // to buy up to 1 fewer ticket than k needs.\\n        --need;\\n        for (int i = k + 1; i < tickets.size(); ++i) {\\n            wait += tickets[i] > need ? need : tickets[i];\\n        }\\n        \\n        return wait;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1726337,
                "title": "c-o-n-solution",
                "content": "eg: [84,49,5,24,70,77,87,8]\\n       k = 3\\n\\t   time added due to index 0(84) : 24\\n\\t   time added due to index 1(49) : 24\\n\\t   time added due to index 2(5) : 5\\n\\t   time added due to index 3(24) : 24\\n\\t   time added due to index 4(70) : 23 (because index 3 becomes 0 first).\\n\\t   time added due to index 5(77) : 23 (because index 3 becomes 0 first).\\n\\t   time added due to index 5(87) : 23 (because index 3 becomes 0 first).\\n\\t   time added due to index 6(8) : 8\\n     total time = 154 ans\\n```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int n = tickets.size();\\n        int time = 0;\\n        for(int i = 0;i < n;i++){\\n            if(tickets[i] <= tickets[k])\\n                time += tickets[i];\\n            else\\n                time += tickets[k];\\n            if(i > k && tickets[i] >= tickets[k])\\n                time--;\\n        }\\n        return time;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int n = tickets.size();\\n        int time = 0;\\n        for(int i = 0;i < n;i++){\\n            if(tickets[i] <= tickets[k])\\n                time += tickets[i];\\n            else\\n                time += tickets[k];\\n            if(i > k && tickets[i] >= tickets[k])\\n                time--;\\n        }\\n        return time;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1604802,
                "title": "python-one-pass-o-1-solution",
                "content": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        \\n        x=tickets[k]\\n        answer=0\\n        for i in range(0,k+1):\\n            answer+=min(x,tickets[i])\\n        \\n        for i in range(k+1,len(tickets)):\\n            answer+=min(x-1,tickets[i]) \\n        \\n        return answer",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        \\n        x=tickets[k]\\n        answer=0\\n        for i in range(0,k+1):\\n            answer+=min(x,tickets[i])\\n        \\n        for i in range(k+1,len(tickets)):\\n            answer+=min(x-1,tickets[i]) \\n        \\n        return answer",
                "codeTag": "Java"
            },
            {
                "id": 1599519,
                "title": "one-pass-100-solution-o-n",
                "content": "if you like it pls upvote\\n\\nJava\\n```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int res = 0;\\n        \\n        for(int i = 0;i<k;i++){\\n            if(tickets[i] >= tickets[k])\\n                res+= tickets[k];\\n            else\\n                res+= tickets[i];\\n        }\\n        for(int i = k+1;i<tickets.length;i++){\\n            if(tickets[i] >= tickets[k]-1)\\n                res+= tickets[k]-1;\\n            else\\n                res+= tickets[i];\\n        }\\n        \\n        return res + tickets[k];\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int res = 0;\\n        \\n        for(int i = 0;i<k;i++){\\n            if(tickets[i] >= tickets[k])\\n                res+= tickets[k];\\n            else\\n                res+= tickets[i];\\n        }\\n        for(int i = k+1;i<tickets.length;i++){\\n            if(tickets[i] >= tickets[k]-1)\\n                res+= tickets[k]-1;\\n            else\\n                res+= tickets[i];\\n        }\\n        \\n        return res + tickets[k];\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1577065,
                "title": "c-brute-force",
                "content": "```\\nint timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int res = 0;\\n        while(tickets[k] != 0){\\n            for(int i=0; i<tickets.size(); i++){\\n                if(tickets[i] > 0){\\n                    tickets[i] -= 1;\\n                    res += 1;\\n                }\\n                if(tickets[k] == 0) break;\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int res = 0;\\n        while(tickets[k] != 0){\\n            for(int i=0; i<tickets.size(); i++){\\n                if(tickets[i] > 0){\\n                    tickets[i] -= 1;\\n                    res += 1;\\n                }\\n                if(tickets[k] == 0) break;\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1577017,
                "title": "javascript-one-pass",
                "content": "```javascript\\nvar timeRequiredToBuy = function(tickets, k) {\\n    let total = 0;\\n    for (let i = 0; i < tickets.length; i++) {\\n        if (i === k || tickets[i] < tickets[k]) {\\n            total += tickets[i];\\n        } else if (i > k) {\\n            total +=  tickets[k] - 1;\\n        } else {\\n            total += tickets[k];\\n        }\\n    }\\n    return total;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar timeRequiredToBuy = function(tickets, k) {\\n    let total = 0;\\n    for (let i = 0; i < tickets.length; i++) {\\n        if (i === k || tickets[i] < tickets[k]) {\\n            total += tickets[i];\\n        } else if (i > k) {\\n            total +=  tickets[k] - 1;\\n        } else {\\n            total += tickets[k];\\n        }\\n    }\\n    return total;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1576972,
                "title": "c-2073-time-needed-to-buy-tickets",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int ans = 0; \\n        for (int i = 0; i < tickets.size(); ++i) {\\n            if (i == k+1) tickets[k] -= 1; \\n            ans += min(tickets[i], tickets[k]); \\n        }\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int ans = 0; \\n        for (int i = 0; i < tickets.size(); ++i) {\\n            if (i == k+1) tickets[k] -= 1; \\n            ans += min(tickets[i], tickets[k]); \\n        }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1576966,
                "title": "python-brute-force",
                "content": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        ret = 0\\n        while tickets[k]:\\n            for i, t in enumerate(tickets):\\n                if t > 0:\\n                    tickets[i] = tickets[i] - 1\\n                    ret += 1\\n                if i == k:\\n                    if tickets[i] == 0:\\n                        return ret\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        ret = 0\\n        while tickets[k]:\\n            for i, t in enumerate(tickets):\\n                if t > 0:\\n                    tickets[i] = tickets[i] - 1\\n                    ret += 1\\n                if i == k:\\n                    if tickets[i] == 0:\\n                        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1576950,
                "title": "java-easy-to-understand",
                "content": "\\n```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] arr, int k) {\\n        int count = 0;\\n        while(true)\\n        {\\n            for(int i=0;i<arr.length;i++)\\n            {\\n                if(arr[i]>0)\\n                {\\n                    arr[i] = arr[i]-1;\\n                    count = count+1;\\n                }\\n                if(arr[k] == 0)\\n                {\\n                    return count;\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] arr, int k) {\\n        int count = 0;\\n        while(true)\\n        {\\n            for(int i=0;i<arr.length;i++)\\n            {\\n                if(arr[i]>0)\\n                {\\n                    arr[i] = arr[i]-1;\\n                    count = count+1;\\n                }\\n                if(arr[k] == 0)\\n                {\\n                    return count;\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3894192,
                "title": "c-linq",
                "content": "```\\npublic class Solution {\\n    public int TimeRequiredToBuy(int[] tickets, int k)\\n      => tickets\\n          .Select((n, i) => Math.Min(n, tickets[k]) - (i > k && n >= tickets[k] ? 1 : 0))\\n          .Sum();\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int TimeRequiredToBuy(int[] tickets, int k)\\n      => tickets\\n          .Select((n, i) => Math.Min(n, tickets[k]) - (i > k && n >= tickets[k] ? 1 : 0))\\n          .Sum();\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3668409,
                "title": "c-solution-using-binary-search",
                "content": "\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int summation(vector<int>tickets){\\n        int sum = 0 ; \\n        for(int i = 0 ; i < tickets.size() ; i++){\\n            sum += tickets[i];\\n        }\\n        return sum;\\n    }\\n    int solve(vector<int> tickets, int k,int mid){\\n        int i = 0;\\n        int n = tickets.size();\\n        while(mid != 0){\\n            if(tickets[i] != 0){\\n                mid--;\\n                tickets[i]--;\\n            }\\n            i = (i + 1) % n;;\\n            if(tickets[k] == 0){\\n                return 0;\\n            }\\n        }\\n        return 1;\\n    }\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int sum = summation(tickets);\\n        \\n        int s = 1 , e = sum , ans = 0;\\n\\n        while(s <= e){\\n            int mid = s + (e - s) / 2;\\n            int val = solve(tickets,k,mid);\\n\\n            if(val == 0){\\n                ans = mid;\\n                e = mid - 1;\\n            }\\n            else{\\n                s = mid + 1;\\n            }\\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int summation(vector<int>tickets){\\n        int sum = 0 ; \\n        for(int i = 0 ; i < tickets.size() ; i++){\\n            sum += tickets[i];\\n        }\\n        return sum;\\n    }\\n    int solve(vector<int> tickets, int k,int mid){\\n        int i = 0;\\n        int n = tickets.size();\\n        while(mid != 0){\\n            if(tickets[i] != 0){\\n                mid--;\\n                tickets[i]--;\\n            }\\n            i = (i + 1) % n;;\\n            if(tickets[k] == 0){\\n                return 0;\\n            }\\n        }\\n        return 1;\\n    }\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int sum = summation(tickets);\\n        \\n        int s = 1 , e = sum , ans = 0;\\n\\n        while(s <= e){\\n            int mid = s + (e - s) / 2;\\n            int val = solve(tickets,k,mid);\\n\\n            if(val == 0){\\n                ans = mid;\\n                e = mid - 1;\\n            }\\n            else{\\n                s = mid + 1;\\n            }\\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3633906,
                "title": "time-needed-to-buy-tickets-queue-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI will be taking the given array index in the queue array rather than the acutal stored values.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe will first enqueue index of the given array in the queue array. We are queuing the array index rather than its value because we need to focus on the person for who we need to find the time taken to buy his tickets. The time will be incremented by 1s for everytime we iterate over the loop. First we will assign the first/front element of the queue to the temp variable(here in my program it is front). Then we will dequeue that first element from the <b>queue</b>. After that we will start checking with the conditions. First condition is, we will check for the value of the tickets[front] is atleast 1 if it is, then we will decrement it by 1. Second Condition, we will check if the front(temp variable) is equal to the k and if the value of the tickets[front] is 0 if it is, then we will break the loop and return the time. Third Condition, we will check if the front!=k and the tickets[front] is equal to 0 if it is, we will continue with the iteration we don\\'t enqueue that element again in the queue. If the condition 2, 3 fails then will enqueue that front(temp variable) in the queue again.\\n\\nAt last of the code I have reintialized the head and tail to -1; As sometimes there are some unexpected behavior in leetcode while executing the test cases.\\n\\n# Code\\n```\\n#include <stdio.h>\\n#include <stdlib.h>\\n\\n#define N 10000 \\n\\nint queue[N];\\n\\nint head=-1, tail=-1; \\n\\nint isEmpty(), isFull();\\n\\nvoid enqueue(int x), dequeue();\\nint peek();\\n\\nint isEmpty() {\\n    if(head == -1 && tail==-1) \\n        return 1;\\n    else \\n        return 0;\\n}\\n\\nint isFull() {\\n    if(tail==N-1)\\n        return 1;\\n    else\\n        return 0;\\n}\\n\\nvoid enqueue(int x) {\\n    if(isFull()) { \\n        printf(\"ERROR: queue overflow\\\\n\");\\n        exit(1); //Enqueuing Failure\\n    }\\n    else if(isEmpty()) {\\n        tail++, head++;\\n        queue[tail] = x;\\n    }\\n    else {\\n        queue[++tail] = x;\\n    }\\n}\\n\\nvoid dequeue() {\\n   if(isEmpty()) {\\n    printf(\"ERROR: queue underflow\\\\n add some elements\\\\n\");\\n   }\\n   else if(head == tail) {\\n    head = -1;\\n    tail = -1;\\n   }\\n   else if(!isEmpty()) {\\n    queue[head++];\\n   }\\n}\\n\\nint peek() {\\n    if(isEmpty()) {\\n        printf(\"NO ELEMENTS\\\\n\");\\n        return;\\n    }\\n    else {\\n       return queue[head];\\n    }\\n}\\n\\n\\nint timeRequiredToBuy(int* tickets, int ticketsSize, int k){\\n    int time=0;\\n    for(int itr=0; itr<ticketsSize; itr++) {\\n        enqueue(itr);\\n    }\\n    while(1) {\\n       time++; \\n       int front=peek();\\n       dequeue();\\n       if(tickets[front]>=1) \\n\\t       tickets[front]--;\\n       if(tickets[front]==0 && front!=k)\\n\\t       continue;\\n       if(tickets[front]==0 && front==k)\\n\\t       break;\\n       enqueue(front);\\n    }\\n    head=-1;\\n    tail=-1;\\n    return time;\\n}\\n\\n```",
                "solutionTags": [
                    "C",
                    "Queue"
                ],
                "code": "```\\n#include <stdio.h>\\n#include <stdlib.h>\\n\\n#define N 10000 \\n\\nint queue[N];\\n\\nint head=-1, tail=-1; \\n\\nint isEmpty(), isFull();\\n\\nvoid enqueue(int x), dequeue();\\nint peek();\\n\\nint isEmpty() {\\n    if(head == -1 && tail==-1) \\n        return 1;\\n    else \\n        return 0;\\n}\\n\\nint isFull() {\\n    if(tail==N-1)\\n        return 1;\\n    else\\n        return 0;\\n}\\n\\nvoid enqueue(int x) {\\n    if(isFull()) { \\n        printf(\"ERROR: queue overflow\\\\n\");\\n        exit(1); //Enqueuing Failure\\n    }\\n    else if(isEmpty()) {\\n        tail++, head++;\\n        queue[tail] = x;\\n    }\\n    else {\\n        queue[++tail] = x;\\n    }\\n}\\n\\nvoid dequeue() {\\n   if(isEmpty()) {\\n    printf(\"ERROR: queue underflow\\\\n add some elements\\\\n\");\\n   }\\n   else if(head == tail) {\\n    head = -1;\\n    tail = -1;\\n   }\\n   else if(!isEmpty()) {\\n    queue[head++];\\n   }\\n}\\n\\nint peek() {\\n    if(isEmpty()) {\\n        printf(\"NO ELEMENTS\\\\n\");\\n        return;\\n    }\\n    else {\\n       return queue[head];\\n    }\\n}\\n\\n\\nint timeRequiredToBuy(int* tickets, int ticketsSize, int k){\\n    int time=0;\\n    for(int itr=0; itr<ticketsSize; itr++) {\\n        enqueue(itr);\\n    }\\n    while(1) {\\n       time++; \\n       int front=peek();\\n       dequeue();\\n       if(tickets[front]>=1) \\n\\t       tickets[front]--;\\n       if(tickets[front]==0 && front!=k)\\n\\t       continue;\\n       if(tickets[front]==0 && front==k)\\n\\t       break;\\n       enqueue(front);\\n    }\\n    head=-1;\\n    tail=-1;\\n    return time;\\n}\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3450924,
                "title": "javascript-100-o-n-time-o-1-space",
                "content": "# Approach\\n\\nTake the `tickets` array below as an example.\\n\\n`[ 8, 2, 4, 6, 1]`\\n\\nIf we wanted to compute the result for `k = 2` (`tickets[2] = 4`), we would have to consider the following scenarios:\\n\\n1. It would take 4 seconds to buy the tickets for the target person, since `tickets[k] == 4`\\n2. `tickets[0]` is 8, but we only need 4 tickets, therefore we only wait for him 4 times\\n3. `tickets[1]` is 2, which is smaller than 4. This person would leave the before we finish buying our tickets, therefore we would only wait for him 2 times\\n4. `tickets[3]` is 6, but we are initially in front of him, therefore we only wait for him after we are placed at the back of the queue, or `tickets[k] - 1` times\\n\\n```\\nfunction timeRequiredToBuy(tickets, k) {\\n    // Scenario 1\\n    let result = tickets[k];\\n\\n    // Scenario 2 and 3\\n    for (let i = 0; i < k; i++) {\\n        result += Math.min(tickets[k], tickets[i]);\\n    }\\n\\n    // Scenario 4\\n    for (let i = k + 1; i < tickets.length; i++) {\\n        result += Math.min(tickets[k] - 1, tickets[i]);\\n    }\\n\\n    return result;\\n};\\n```\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n",
                "solutionTags": [
                    "JavaScript",
                    "Math"
                ],
                "code": "```\\nfunction timeRequiredToBuy(tickets, k) {\\n    // Scenario 1\\n    let result = tickets[k];\\n\\n    // Scenario 2 and 3\\n    for (let i = 0; i < k; i++) {\\n        result += Math.min(tickets[k], tickets[i]);\\n    }\\n\\n    // Scenario 4\\n    for (let i = k + 1; i < tickets.length; i++) {\\n        result += Math.min(tickets[k] - 1, tickets[i]);\\n    }\\n\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3198622,
                "title": "100-easy-js-solution-explained-with-proper-intuition-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n- Implemented the problem with the *greedy approach* that involves buying tickets from a queue.\\n- The *goal* of the problem is :-\\n*\"To calculate the amount of time required to buy all the tickets at position k, where each purchase takes one unit of time and the buyer moves to the next position in the queue after each purchase.\"*\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n- The *tickets* array represents the number of available tickets at each *position* in the *queue*, and the function *timeRequiredToBuy* takes *two* *arguments*: *tickets* and *k*.\\n1. The approach taken in the below code is to use a *while* loop that continues until the kth element of the tickets array becomes 0. \\n2. Within the *while* loop, the code uses a *modulo operator* to wrap around the queue and ensure that it starts over at the beginning after reaching the end.\\n3. On each *iteration* of the *while* loop, the code checks if the current position has any *available tickets*.\\n4.  If it does, it *decrements* the ticket count and increments a counter for the number of tickets purchased.\\n5. Finally, the function returns the *total count of tickets* purchased, which represents the *time required to buy all the tickets at position k.*\\n\\n\\n# Complexity\\n- Time complexity: $$O(N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n1. Here N is the length of the tickets array. \\n2. This is because the while loop will continue until the kth element of the tickets array becomes 0, and each iteration of the while loop will iterate over each element of the tickets array once.\\n\\n\\n\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n1. Because the only additional space used is for the variables i, count, and pos, which are all constant in size and do not depend on the size of the input.\\n2.  The tickets array is modified in place, so no additional space is used for it.\\n\\n\\n\\n\\n\\n# Code\\n```\\n/**\\n * @param {number[]} tickets\\n * @param {number} k\\n * @return {number}\\n */\\nvar timeRequiredToBuy = function(tickets, k) {\\n\\n    let N = tickets.length;\\n\\n    // current index\\n    let i = 0;\\n\\n    // no. of count\\n    let count = 0;\\n\\n    while (tickets[k] > 0) {\\n\\n        let pos = i % N;\\n\\n        if (tickets[pos]) {\\n\\n            tickets[pos]--;\\n            count++;\\n        }  \\n        // moving everytime to next element\\n        i++;\\n    }\\n    return count;\\n};\\n```\\n\\n![cat img for upvote on LC.jpeg](https://assets.leetcode.com/users/images/6f36285e-0bab-460e-9f8c-0f16bf19e852_1676657371.1775663.jpeg)\\n",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Queue",
                    "Simulation"
                ],
                "code": "```\\n/**\\n * @param {number[]} tickets\\n * @param {number} k\\n * @return {number}\\n */\\nvar timeRequiredToBuy = function(tickets, k) {\\n\\n    let N = tickets.length;\\n\\n    // current index\\n    let i = 0;\\n\\n    // no. of count\\n    let count = 0;\\n\\n    while (tickets[k] > 0) {\\n\\n        let pos = i % N;\\n\\n        if (tickets[pos]) {\\n\\n            tickets[pos]--;\\n            count++;\\n        }  \\n        // moving everytime to next element\\n        i++;\\n    }\\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2847752,
                "title": "time-needed-to-buy-tickets",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nimport java.util.*;\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        Queue<Integer> q = new LinkedList<>();\\n        for ( int i = 0; i < tickets.length; i++){\\n           q.add(i);\\n        }\\n        int count = 0;\\n        while(!q.isEmpty()){\\n            ++count;\\n            int front = q.poll();\\n            if(tickets[front] >= 1){\\n                tickets[front] -= 1;\\n            }\\n            if(k == front && tickets[front] == 0){\\n                break;\\n            }\\n            if(k != front && tickets[front] == 0){\\n                continue;\\n            }\\nq.add(front);\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Queue"
                ],
                "code": "```\\nimport java.util.*;\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        Queue<Integer> q = new LinkedList<>();\\n        for ( int i = 0; i < tickets.length; i++){\\n           q.add(i);\\n        }\\n        int count = 0;\\n        while(!q.isEmpty()){\\n            ++count;\\n            int front = q.poll();\\n            if(tickets[front] >= 1){\\n                tickets[front] -= 1;\\n            }\\n            if(k == front && tickets[front] == 0){\\n                break;\\n            }\\n            if(k != front && tickets[front] == 0){\\n                continue;\\n            }\\nq.add(front);\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2833494,
                "title": "explained-java-soln",
                "content": "\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n\\n        int time=0;\\n\\n  \\n       for(int i =0; i<tickets.length;i++){\\n// if position i<k and tickets[i]<tickets[k], means all tickets of i will be purchase before k, hence time+=tickets[i].   \\n\\n           if(i<k){\\n               if(tickets[i]<=tickets[k])\\n                time+=tickets[i];\\n// if tickets[i]>tickets[k] and programs ends when tickets[k]==0, then no need to count time for i after k==0 , hence time+=tickets[k]\\n                else \\n                time+=tickets[k];\\n           }\\n// if position i>k and tickets[i]<tickets[k], means all tickets of i will be purchase before k, hence time+=tickets[i]. \\n\\n           if(i>k){\\n               if(tickets[i]<tickets[k])\\n                time+=tickets[i];\\n// if tickets[i]>tickets[k] and programs ends when tickets[k]==0, then no need to count time for i after k==0 , hence time+=tickets[k]-1(cause loop will break before time hits ticket[k] for later part.),\\n                else\\n                time+=tickets[k]-1;\\n           }\\n//if i==k just add time+=tickets[k]\\n\\n                if(i==k) time+=tickets[k];\\n\\n\\n\\n           \\n           System.out.println(time);\\n           \\n\\n\\n       }\\n\\n        \\n\\n        return time;\\n\\n\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n\\n        int time=0;\\n\\n  \\n       for(int i =0; i<tickets.length;i++){\\n// if position i<k and tickets[i]<tickets[k], means all tickets of i will be purchase before k, hence time+=tickets[i].   \\n\\n           if(i<k){\\n               if(tickets[i]<=tickets[k])\\n                time+=tickets[i];\\n// if tickets[i]>tickets[k] and programs ends when tickets[k]==0, then no need to count time for i after k==0 , hence time+=tickets[k]\\n                else \\n                time+=tickets[k];\\n           }\\n// if position i>k and tickets[i]<tickets[k], means all tickets of i will be purchase before k, hence time+=tickets[i]. \\n\\n           if(i>k){\\n               if(tickets[i]<tickets[k])\\n                time+=tickets[i];\\n// if tickets[i]>tickets[k] and programs ends when tickets[k]==0, then no need to count time for i after k==0 , hence time+=tickets[k]-1(cause loop will break before time hits ticket[k] for later part.),\\n                else\\n                time+=tickets[k]-1;\\n           }\\n//if i==k just add time+=tickets[k]\\n\\n                if(i==k) time+=tickets[k];\\n\\n\\n\\n           \\n           System.out.println(time);\\n           \\n\\n\\n       }\\n\\n        \\n\\n        return time;\\n\\n\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2557446,
                "title": "js-two-approaches-with-explanation-easy-to-understand",
                "content": "I just found this Blog and Github repository with solutions to Leetcode problems.\\nhttps://leet-codes.blogspot.com/2022/09/2073-time-needed-to-buy-tickets-queue.html\\nIt is very useful, and I just wanted to share it with you.\\nNote: You can bookmark it as a resource, and for another approaches\\n<br>\\n\\n**Javascript One Liner code**\\n\\n```\\n/**\\n * @param {number[]} tickets\\n * @param {number} k\\n * @return {number}\\n */\\nvar timeRequiredToBuy = function(tickets, k) {\\n    return tickets.reduce((x, v, i)=>x + Math.min(v, tickets[k] - (i > k)), 0);\\n};\\n```\\n\\n```\\nRuntime: 96 ms, faster than 38.86% of JavaScript online submissions for Time Needed to Buy Tickets.\\nMemory Usage: 41.6 MB, less than 89.10% of JavaScript online submissions for Time Needed to Buy Tickets.\\n```\\n\\n",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} tickets\\n * @param {number} k\\n * @return {number}\\n */\\nvar timeRequiredToBuy = function(tickets, k) {\\n    return tickets.reduce((x, v, i)=>x + Math.min(v, tickets[k] - (i > k)), 0);\\n};\\n```\n```\\nRuntime: 96 ms, faster than 38.86% of JavaScript online submissions for Time Needed to Buy Tickets.\\nMemory Usage: 41.6 MB, less than 89.10% of JavaScript online submissions for Time Needed to Buy Tickets.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2553069,
                "title": "python-easy-queue-and-recursion-solution",
                "content": "```\\nfrom collections import deque\\n\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        queue = deque(tickets)\\n        \\n        self.time_taken = 0\\n        \\n        self.rec(queue, k)\\n        \\n        return self.time_taken\\n    \\n    def rec(self, queue, k):\\n        for idx, ele in enumerate(queue):\\n            if ele:\\n                queue[idx] -= 1\\n                if idx == k and not queue[idx]:\\n                    self.time_taken += 1\\n                    return self.time_taken\\n                else:\\n                    self.time_taken += 1\\n        self.rec(queue, k)\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion",
                    "Queue"
                ],
                "code": "```\\nfrom collections import deque\\n\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        queue = deque(tickets)\\n        \\n        self.time_taken = 0\\n        \\n        self.rec(queue, k)\\n        \\n        return self.time_taken\\n    \\n    def rec(self, queue, k):\\n        for idx, ele in enumerate(queue):\\n            if ele:\\n                queue[idx] -= 1\\n                if idx == k and not queue[idx]:\\n                    self.time_taken += 1\\n                    return self.time_taken\\n                else:\\n                    self.time_taken += 1\\n        self.rec(queue, k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2458459,
                "title": "go-simple-solution-using-queue-60-faster-70-less-memory-needed",
                "content": "func timeRequiredToBuy(tickets []int, k int) int {\\n\\n\\tout := 0\\n\\tendMainLoop := false\\n\\n\\tfor !endMainLoop {\\n\\n\\t\\tend := len(tickets)\\n\\n\\t\\tif tickets[k] == 1 {\\n\\t\\t\\tend = k + 1\\n\\t\\t\\tendMainLoop = true\\n\\t\\t}\\n\\n\\t\\tfor i := 0; i < end; i++ {\\n\\n\\t\\t\\telem := tickets[0]\\n\\n\\t\\t\\tif elem > 0 {\\n\\t\\t\\t\\telem--\\n\\t\\t\\t\\tout++\\n\\t\\t\\t}\\n\\n\\t\\t\\ttickets = append(tickets[1:], elem)\\n\\t\\t}\\n\\t}\\n\\n\\treturn out\\n}",
                "solutionTags": [
                    "Go"
                ],
                "code": "func timeRequiredToBuy(tickets []int, k int) int {\\n\\n\\tout := 0\\n\\tendMainLoop := false\\n\\n\\tfor !endMainLoop {\\n\\n\\t\\tend := len(tickets)\\n\\n\\t\\tif tickets[k] == 1 {\\n\\t\\t\\tend = k + 1\\n\\t\\t\\tendMainLoop = true\\n\\t\\t}\\n\\n\\t\\tfor i := 0; i < end; i++ {\\n\\n\\t\\t\\telem := tickets[0]\\n\\n\\t\\t\\tif elem > 0 {\\n\\t\\t\\t\\telem--\\n\\t\\t\\t\\tout++\\n\\t\\t\\t}\\n\\n\\t\\t\\ttickets = append(tickets[1:], elem)\\n\\t\\t}\\n\\t}\\n\\n\\treturn out\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 2429131,
                "title": "c-simply-explained-with-steps",
                "content": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int step = 0;\\n        while (true) {\\n            for (int i = 0; i < tickets.size(); ++i) {\\n                if (tickets[i] == 0) continue; // skips element, does not count if ticket is 0, like it\\'s not even there\\n                tickets[i]--; // decreases by 1 of all elements one by one\\n                ++step; // 1 second increment\\n                if (tickets[k] == 0) return step; // if target is having 0 tickets, return total time\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int step = 0;\\n        while (true) {\\n            for (int i = 0; i < tickets.size(); ++i) {\\n                if (tickets[i] == 0) continue; // skips element, does not count if ticket is 0, like it\\'s not even there\\n                tickets[i]--; // decreases by 1 of all elements one by one\\n                ++step; // 1 second increment\\n                if (tickets[k] == 0) return step; // if target is having 0 tickets, return total time\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2400565,
                "title": "c-easy-approach",
                "content": "Basically we need to find the time to make tickets[k] equals to zero.\\nIn every iteration if the element is not equal to zero then decrease it by one and increase the count of time.\\nint i could be greatter than n so use i%n so that it remains in range of array given.\\n```\\nint timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int n=tickets.size();\\n        int time=0;\\n        int i=0;\\n        while(tickets[k]!=0){\\n            if(tickets[i%n]!=0){\\n                tickets[i%n]--;\\n                time++;\\n            }\\n            i++;\\n        }\\n        return time;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nint timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int n=tickets.size();\\n        int time=0;\\n        int i=0;\\n        while(tickets[k]!=0){\\n            if(tickets[i%n]!=0){\\n                tickets[i%n]--;\\n                time++;\\n            }\\n            i++;\\n        }\\n        return time;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2343054,
                "title": "short-javascript-solution",
                "content": "```\\nvar timeRequiredToBuy = function (tickets, k) {\\n    let seconds = 0;\\n\\n    while (tickets[k] > 0) {\\n        for (let i = 0; i < tickets.length; i++) {\\n            if (tickets[k] === 0) break\\n            if (tickets[i] > 0) {\\n                tickets[i]--\\n                seconds++\\n            }\\n        }\\n    }\\n\\t\\n    return seconds\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar timeRequiredToBuy = function (tickets, k) {\\n    let seconds = 0;\\n\\n    while (tickets[k] > 0) {\\n        for (let i = 0; i < tickets.length; i++) {\\n            if (tickets[k] === 0) break\\n            if (tickets[i] > 0) {\\n                tickets[i]--\\n                seconds++\\n            }\\n        }\\n    }\\n\\t\\n    return seconds\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2326133,
                "title": "c-all-approaches-complexity-analysis-efficient-solution",
                "content": "2 APPROACHES : \\n1. Queue\\nTC : O( t )   ->t is the time ( iterations) done to make the tickets[ k ]=0 \\nSC : O(N)  -> We store N elements in queue at first\\n\\n2. Vector :\\nTC : O( t ) \\nSC : O(1) ->no extra space required\\n\\nNOTE  :The runtime and memory usage of vector soution is less than that of Queue solution .\\n(as it can be seen clearly as well from the complexity analysis) \\n\\nUPVOTE IF YOU LIKE \\uD83D\\uDE0A\\n```\\nclass Solution {\\npublic:\\n// USING QUEUE : \\n    int timeRequiredToBuy(vector<int>& nums, int k) {\\n        int ans=0;\\n        queue<pair<int,int>>q;\\n        for(int i=0;i<nums.size();i++){\\n            q.push({nums[i],i});\\n        }\\n    \\n        while(!q.empty()){\\n            pair<int,int>p=q.front();\\n            q.pop();\\n            p.first--;\\n            ans+=1;\\n            if(p.second==k && p.first==0)return ans;\\n            else if(p.first!=0)q.push(p);\\n        }\\n        return ans;\\n    }\\n};\\n\\n/*\\nUSING VECTOR :\\nRuntime and memory usage of This solution is better than the queue sol.\\n*/\\nint timeRequiredToBuy(vector<int>& nums, int k) {\\n        int ans=0;\\n        while(nums[k]!=0){\\n            for(int i=0;i<nums.size();i++){\\n                if(nums[i]==0 && i!=k)continue;\\n                nums[i]--;\\n                ans+=1;\\n                if(nums[k]==0)return ans;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n```",
                "solutionTags": [
                    "C",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n// USING QUEUE : \\n    int timeRequiredToBuy(vector<int>& nums, int k) {\\n        int ans=0;\\n        queue<pair<int,int>>q;\\n        for(int i=0;i<nums.size();i++){\\n            q.push({nums[i],i});\\n        }\\n    \\n        while(!q.empty()){\\n            pair<int,int>p=q.front();\\n            q.pop();\\n            p.first--;\\n            ans+=1;\\n            if(p.second==k && p.first==0)return ans;\\n            else if(p.first!=0)q.push(p);\\n        }\\n        return ans;\\n    }\\n};\\n\\n/*\\nUSING VECTOR :\\nRuntime and memory usage of This solution is better than the queue sol.\\n*/\\nint timeRequiredToBuy(vector<int>& nums, int k) {\\n        int ans=0;\\n        while(nums[k]!=0){\\n            for(int i=0;i<nums.size();i++){\\n                if(nums[i]==0 && i!=k)continue;\\n                nums[i]--;\\n                ans+=1;\\n                if(nums[k]==0)return ans;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2319753,
                "title": "o-n-python-treat-kth-and-kth-differently",
                "content": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        c=0\\n        l=len(tickets)\\n        for i in range(l):\\n            if i <= k:\\n                c+= min(tickets[k],tickets[i])\\n            else:\\n                c+= min(tickets[k]-1,tickets[i])\\n        return c\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        c=0\\n        l=len(tickets)\\n        for i in range(l):\\n            if i <= k:\\n                c+= min(tickets[k],tickets[i])\\n            else:\\n                c+= min(tickets[k]-1,tickets[i])\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2296280,
                "title": "python-easy-solution",
                "content": "```\\nclass Solution(object):\\n    def timeRequiredToBuy(self, tickets, k):\\n        \"\"\"\\n        :type tickets: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        seconds = 0\\n        while tickets[k]!=0:\\n            \\n            for i in range(len(tickets)):\\n                if tickets[i]!=0 and tickets[k]!=0:\\n                    tickets[i] = tickets[i]-1\\n                    seconds +=1\\n        return seconds\\n                \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def timeRequiredToBuy(self, tickets, k):\\n        \"\"\"\\n        :type tickets: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        seconds = 0\\n        while tickets[k]!=0:\\n            \\n            for i in range(len(tickets)):\\n                if tickets[i]!=0 and tickets[k]!=0:\\n                    tickets[i] = tickets[i]-1\\n                    seconds +=1\\n        return seconds\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2282082,
                "title": "java-easy-solution-o-n-2-mehods",
                "content": "#### 1) \\n```\\nclass Solution {\\n  public int timeRequiredToBuy(int[] tickets, int k) {\\n        int ans = 0;\\n        for (int i = 0; i < tickets.length; i++) {\\n             ans += Math.min(tickets[i], tickets[k]);\\n\\n            if (i > k && tickets[i] >= tickets[k]) {\\n                ans--;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```\\n#### 2)\\n```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int ans = 0;\\n        while (tickets[k] != 0) {\\n            for (int i = 0; i < tickets.length; i++) {\\n                if (tickets[k] == 0) {\\n                    return ans;\\n                }\\n                if (tickets[i] != 0) {\\n                    tickets[i] = tickets[i] - 1;\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public int timeRequiredToBuy(int[] tickets, int k) {\\n        int ans = 0;\\n        for (int i = 0; i < tickets.length; i++) {\\n             ans += Math.min(tickets[i], tickets[k]);\\n\\n            if (i > k && tickets[i] >= tickets[k]) {\\n                ans--;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int ans = 0;\\n        while (tickets[k] != 0) {\\n            for (int i = 0; i < tickets.length; i++) {\\n                if (tickets[k] == 0) {\\n                    return ans;\\n                }\\n                if (tickets[i] != 0) {\\n                    tickets[i] = tickets[i] - 1;\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2271454,
                "title": "best-solution-in-c",
                "content": "**Please upvote if you like it :)**\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int count=0;\\n        while(tickets[k])\\n        {\\n            for(int i=0;i<tickets.size();i++)\\n            {\\n                if(tickets[i])\\n                {\\n                    tickets[i]=tickets[i]-1;\\n                    count++;\\n                    if(tickets[k]==0)\\n                        return count;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int count=0;\\n        while(tickets[k])\\n        {\\n            for(int i=0;i<tickets.size();i++)\\n            {\\n                if(tickets[i])\\n                {\\n                    tickets[i]=tickets[i]-1;\\n                    count++;\\n                    if(tickets[k]==0)\\n                        return count;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2269001,
                "title": "use-only-one-for-loop-10-lines-of-codes-bruteforce-java-solution",
                "content": "\\n2073. Time Needed to Buy Tickets\\njava solution\\nOnly 10 lines of codes\\n```\\n\\n\\npublic int timeRequiredToBuy(int[] tickets, int k) {\\n          int time=0;\\n          for(int i=0; i<tickets.length; i++){\\n              if(tickets[i]<tickets[k]) time+=tickets[i];\\n              else if(i<=k && tickets[i]>=tickets[k])time+=tickets[k];\\n              else if(i>k && tickets[i]>=tickets[k]) time+=tickets[k]-1;   \\n          }\\n          return(time);\\n    }\\n\\t\\n\\t```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Queue"
                ],
                "code": "```\\n\\n\\npublic int timeRequiredToBuy(int[] tickets, int k) {\\n          int time=0;\\n          for(int i=0; i<tickets.length; i++){\\n              if(tickets[i]<tickets[k]) time+=tickets[i];\\n              else if(i<=k && tickets[i]>=tickets[k])time+=tickets[k];\\n              else if(i>k && tickets[i]>=tickets[k]) time+=tickets[k]-1;   \\n          }\\n          return(time);\\n    }\\n\\t\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 2235304,
                "title": "java",
                "content": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int ans=0;\\n        \\n        //find the kth person and find m tickets to buy \\n        int times=tickets[k];\\n        \\n        //loop the array m-1 times\\n        for(int i:tickets)\\n        {   \\n            //if i>=m-1, that means this person has enough tickets to buy\\n            if(i>=times)\\n            {\\n                ans+=times-1;\\n            }else  //if i<m-1 that means this person does not have enough tickets to buy\\n            {\\n                ans+=i;\\n            }\\n        }\\n        \\n        //last lopp and stop at the person k\\n        for(int i=0;i<k+1;i++)\\n        {   ////if i>m-1, that means this person has enough tickets to buy\\n            if(tickets[i]>times-1)\\n            {\\n                ans++;\\n            }\\n        }\\n        \\n        return ans;\\n      \\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int ans=0;\\n        \\n        //find the kth person and find m tickets to buy \\n        int times=tickets[k];\\n        \\n        //loop the array m-1 times\\n        for(int i:tickets)\\n        {   \\n            //if i>=m-1, that means this person has enough tickets to buy\\n            if(i>=times)\\n            {\\n                ans+=times-1;\\n            }else  //if i<m-1 that means this person does not have enough tickets to buy\\n            {\\n                ans+=i;\\n            }\\n        }\\n        \\n        //last lopp and stop at the person k\\n        for(int i=0;i<k+1;i++)\\n        {   ////if i>m-1, that means this person has enough tickets to buy\\n            if(tickets[i]>times-1)\\n            {\\n                ans++;\\n            }\\n        }\\n        \\n        return ans;\\n      \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2153645,
                "title": "c-o-n-solution-0ms-100-faster",
                "content": "**Important observations**\\n* Person standing at index i, before kth index , will buy either **tickets[k]** ticket or **tickets[i]** whichever is minimum,  before kth person buys the ticket. same is applicable for kth person.\\n* Person after kth index, will buy minimum of  **tickets[k] -1** ticket or **tickets[i]** ticket, before kth person buys all the tickets.\\n```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int res = 0;\\n        for(int i = 0; i <= k; i++) {\\n            res += min(tickets[k], tickets[i]);\\n        }\\n        for(int i = k + 1; i < tickets.size(); i++) {\\n            res += min(tickets[k] - 1 , tickets[i]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int res = 0;\\n        for(int i = 0; i <= k; i++) {\\n            res += min(tickets[k], tickets[i]);\\n        }\\n        for(int i = k + 1; i < tickets.size(); i++) {\\n            res += min(tickets[k] - 1 , tickets[i]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2098427,
                "title": "c-easy-solution-brute-force-to-optimized",
                "content": "\\n\\n\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        \\n        \\n// <------------------------------------------------------------------->\\n     \\n\\t \\n\\t \\n\\t \\n\\t \\n\\t \\n\\t \\n\\t // Approach - 1 TC O(N*K) and SC O(1)\\n        int n=tickets.size();\\n        int cnt=0;\\n        while(tickets[k]>0)\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                if(tickets[i]>0)\\n                {\\n                    tickets[i]--;\\n                    cnt++;\\n                }\\n                if(tickets[k]==0 )\\n                {\\n                    return cnt;\\n                }\\n            }\\n        }\\n        return cnt;\\n        \\n        \\n// <------------------------------------------------------------------->\\n\\n        // Appraoch - 2 TC O(N) and SC O(1)\\n        int i=0;\\n        int n=tickets.size();\\n        int sum=0;\\n        while(i<n)\\n        {\\n            if(i<=k)\\n                sum+=min(tickets[i],tickets[k]);\\n            else\\n                sum+=min(tickets[i],tickets[k]-1);\\n            i++;\\n        }\\n        return sum;\\n        \\n        \\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        \\n        \\n// <------------------------------------------------------------------->\\n     \\n\\t \\n\\t \\n\\t \\n\\t \\n\\t \\n\\t \\n\\t // Approach - 1 TC O(N*K) and SC O(1)\\n        int n=tickets.size();\\n        int cnt=0;\\n        while(tickets[k]>0)\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                if(tickets[i]>0)\\n                {\\n                    tickets[i]--;\\n                    cnt++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2096061,
                "title": "c-easy-solution-and-understandable",
                "content": "Solution 1 :\\n```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int sum = 0, x = tickets[k];\\n        for(int i = 0; i <= k; i++){\\n            if(tickets[i] <= x)\\n                sum+=tickets[i];\\n            else\\n                sum+=x;\\n        }\\n        for(int i = k + 1; i < tickets.size(); i++){\\n            if(tickets[i] <= (x-1))\\n                sum+=tickets[i];\\n            else\\n                sum+=(x-1);\\n        }\\n        return sum;\\n    }\\n};\\n```\\nSolution 2 :\\n```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int t = 0;\\n        while(tickets[k] > 0){\\n            for(int i = 0; i < tickets.size(); i++){\\n                if(tickets[i] > 0){\\n                    t++;\\n                    tickets[i]--;\\n                }\\n                if(tickets[k]==0)\\n                    break;\\n            }\\n        }\\n        return t;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int sum = 0, x = tickets[k];\\n        for(int i = 0; i <= k; i++){\\n            if(tickets[i] <= x)\\n                sum+=tickets[i];\\n            else\\n                sum+=x;\\n        }\\n        for(int i = k + 1; i < tickets.size(); i++){\\n            if(tickets[i] <= (x-1))\\n                sum+=tickets[i];\\n            else\\n                sum+=(x-1);\\n        }\\n        return sum;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int t = 0;\\n        while(tickets[k] > 0){\\n            for(int i = 0; i < tickets.size(); i++){\\n                if(tickets[i] > 0){\\n                    t++;\\n                    tickets[i]--;\\n                }\\n                if(tickets[k]==0)\\n                    break;\\n            }\\n        }\\n        return t;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2011975,
                "title": "simple-python-solution-with-detailed-explanation-easy-to-understand",
                "content": "iterate through tickets, if any number is bigger than ticket[k], when index <= k, nums + tickets[k] (because you can\\'t go over tickets[k] steps to finish purchasing tickets for the kth person), however, for people behind kth person, you only need to purchase ticket[k]-1 steps. if tickets[i] is smaller than ticket[k], these people will only take tickets[i] steps before they leave the queue.\\n\\nif you like my solution, please give me a thumb up!\\n\\n```\\n\\n```class Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        \\n        nums = 0        \\n        \\n        for i in range(len(tickets)):       \\n                if tickets[i] >= tickets[k]:\\n                    if i <= k:\\n                        nums += tickets[k]\\n                    else:\\n                        nums += tickets[k] - 1\\n                else:\\n                        nums += tickets[i]\\n\\n        return nums",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1937637,
                "title": "faster-than-94-90-javascript-solution",
                "content": "```\\nvar timeRequiredToBuy = function (tickets, k) {\\n  let ans = 0;\\n  let i = 0;\\n  while (tickets[k] !== 0) {\\n    if (i === tickets.length) {\\n      i = 0;\\n    }\\n    if (tickets[i] != 0) {\\n      tickets[i] -= 1;\\n      ans++;\\n    }\\n    i++;\\n  }\\n  return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar timeRequiredToBuy = function (tickets, k) {\\n  let ans = 0;\\n  let i = 0;\\n  while (tickets[k] !== 0) {\\n    if (i === tickets.length) {\\n      i = 0;\\n    }\\n    if (tickets[i] != 0) {\\n      tickets[i] -= 1;\\n      ans++;\\n    }\\n    i++;\\n  }\\n  return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1934516,
                "title": "java-queue-solution-with-explanation",
                "content": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int time = 0;\\n        Queue<Integer> queue = new LinkedList<>();\\n        for(int i=0;i <tickets.length; i++) {\\n            queue.add(i);\\n        }\\n        int count=0;\\n        while(!queue.isEmpty()) {\\n            count++;\\n            int index = queue.poll();\\n            if(tickets[index] >= 1) {\\n                tickets[index] -= 1;\\n            }\\n            //now I will check he can go back to last of queue or not\\n            if(index != k && tickets[index] == 0) { \\n                //he is the normal guy, which means he can leave the queue\\n                continue;\\n            }\\n            //he is the Kth guy, he cannot leave the Queue instead he can BREAK the Queue :)\\n            if(index == k && tickets[index] == 0) {\\n                break;\\n            }\\n            //in all other case we need to add the guy back to Queue\\n            queue.offer(index);\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int time = 0;\\n        Queue<Integer> queue = new LinkedList<>();\\n        for(int i=0;i <tickets.length; i++) {\\n            queue.add(i);\\n        }\\n        int count=0;\\n        while(!queue.isEmpty()) {\\n            count++;\\n            int index = queue.poll();\\n            if(tickets[index] >= 1) {\\n                tickets[index] -= 1;\\n            }\\n            //now I will check he can go back to last of queue or not\\n            if(index != k && tickets[index] == 0) { \\n                //he is the normal guy, which means he can leave the queue\\n                continue;\\n            }\\n            //he is the Kth guy, he cannot leave the Queue instead he can BREAK the Queue :)\\n            if(index == k && tickets[index] == 0) {\\n                break;\\n            }\\n            //in all other case we need to add the guy back to Queue\\n            queue.offer(index);\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1921486,
                "title": "c-cpp-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int ans = 0,n = tickets.size();\\n        while(tickets[k] > 0){\\n            for(int i = 0;i<n && tickets[k] > 0;i++){\\n                if(tickets[i] > 0){\\n                    ans++;\\n                    tickets[i]--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/06178cb3-e0a6-4b9f-add8-fd6380c82517_1649302549.1251898.png)\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int ans = 0,n = tickets.size();\\n        while(tickets[k] > 0){\\n            for(int i = 0;i<n && tickets[k] > 0;i++){\\n                if(tickets[i] > 0){\\n                    ans++;\\n                    tickets[i]--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1914472,
                "title": "python-easy-solution-one-pass-no-extra-memory",
                "content": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        length = len(tickets)\\n        count = 0\\n        \\n        for i in range(k+1):\\n            if tickets[i] - tickets[k] < 0:\\n                count += tickets[i]\\n            else:\\n                count += tickets[k]\\n        \\n        for i in range(k+1, length):\\n            if tickets[i] - (tickets[k] - 1) < 0:\\n                count += tickets[i]\\n            else:\\n                count += tickets[k] - 1\\n                \\n        return count\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        length = len(tickets)\\n        count = 0\\n        \\n        for i in range(k+1):\\n            if tickets[i] - tickets[k] < 0:\\n                count += tickets[i]\\n            else:\\n                count += tickets[k]\\n        \\n        for i in range(k+1, length):\\n            if tickets[i] - (tickets[k] - 1) < 0:\\n                count += tickets[i]\\n            else:\\n                count += tickets[k] - 1\\n                \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1904304,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        n = len(tickets)\\n        item = tickets[k]\\n        time = 0\\n        \\n        while tickets[k] != 0:\\n            for i in range(n):\\n                if tickets[i] > 0:\\n                    tickets[i] -= 1\\n                    time += 1\\n                \\n                if i == k and tickets[i] == 0:\\n                    return time\\n        \\n        return time\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        n = len(tickets)\\n        item = tickets[k]\\n        time = 0\\n        \\n        while tickets[k] != 0:\\n            for i in range(n):\\n                if tickets[i] > 0:\\n                    tickets[i] -= 1\\n                    time += 1\\n                \\n                if i == k and tickets[i] == 0:\\n                    return time\\n        \\n        return time\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1894215,
                "title": "c-solution-o-n-time-o-1-space-just-two-loops-0-ms",
                "content": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n      int timeTaken = 0;\\n      int ticketsAtIndexK = tickets[k];\\n      for(int i = k+1; i < tickets.size(); i++)\\n        timeTaken += min(tickets[i], ticketsAtIndexK - 1);\\n      \\n      for(int i = 0; i <= k; i++)\\n        timeTaken += min(tickets[i], ticketsAtIndexK);\\n      \\n      return timeTaken;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n      int timeTaken = 0;\\n      int ticketsAtIndexK = tickets[k];\\n      for(int i = k+1; i < tickets.size(); i++)\\n        timeTaken += min(tickets[i], ticketsAtIndexK - 1);\\n      \\n      for(int i = 0; i <= k; i++)\\n        timeTaken += min(tickets[i], ticketsAtIndexK);\\n      \\n      return timeTaken;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1888755,
                "title": "c-solution-with-queue-and-shallow-copies",
                "content": "Put references to the elements of the array in a queue. This allows you to monitor directly tickets[k], preventing you from becoming insane in keeping track of it with a variable.\\n\\n``` \\nclass Solution {\\npublic:\\n    // Time Complexity: O(n*tickets[k]), it loops for the entire queue (size = n, n times) until tickets[k] becomes 0 (k times)\\n    // Space Complexity: O(n), creates a queue of size n\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        \\n        queue<int*> q;\\n        for(int i=0; i< tickets.size(); i++)\\n            q.push(&tickets[i]);                // add references of the tickets to a queue\\n        \\n        int count = 0;\\n        while(tickets[k] != 0)                  // repeat until ticket[k] is zero\\n        {\\n            int* ptr = q.front();               // get the reference at the front of the queue, namely ticket[i]\\n            q.pop();                            // remove it from the queue\\n            (*ptr)--;                           // reduce the value of ticket[i]\\n            if(*ptr != 0)                       // if it is not zero, \\n                q.push(ptr);                    // add it back to the queue\\n            count++;                            // increase counter\\n        }\\n        return count;                           // return the counter\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "``` \\nclass Solution {\\npublic:\\n    // Time Complexity: O(n*tickets[k]), it loops for the entire queue (size = n, n times) until tickets[k] becomes 0 (k times)\\n    // Space Complexity: O(n), creates a queue of size n\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        \\n        queue<int*> q;\\n        for(int i=0; i< tickets.size(); i++)\\n            q.push(&tickets[i]);                // add references of the tickets to a queue\\n        \\n        int count = 0;\\n        while(tickets[k] != 0)                  // repeat until ticket[k] is zero\\n        {\\n            int* ptr = q.front();               // get the reference at the front of the queue, namely ticket[i]\\n            q.pop();                            // remove it from the queue\\n            (*ptr)--;                           // reduce the value of ticket[i]\\n            if(*ptr != 0)                       // if it is not zero, \\n                q.push(ptr);                    // add it back to the queue\\n            count++;                            // increase counter\\n        }\\n        return count;                           // return the counter\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1857998,
                "title": "python-simple-solution",
                "content": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        seconds = 0\\n        while True:\\n            for i in range(len(tickets)):\\n                if tickets[i] != 0:\\n                    seconds += 1\\n                    tickets[i] -= 1\\n                else:\\n                    continue\\n                if tickets[k] == 0:\\n                    return seconds",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        seconds = 0\\n        while True:\\n            for i in range(len(tickets)):\\n                if tickets[i] != 0:\\n                    seconds += 1\\n                    tickets[i] -= 1\\n                else:\\n                    continue\\n                if tickets[k] == 0:\\n                    return seconds",
                "codeTag": "Java"
            },
            {
                "id": 1820628,
                "title": "o-n-long-but-understandable-code-try-this-python",
                "content": "class Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n\\t\\n        second=0\\n        a=tickets[k]\\n        while a!=0:\\n            for i in range(len(tickets)):\\n                if tickets[i]!=0:\\n                    second+=1\\n                    tickets[i]=tickets[i]-1\\n                a=tickets[k]\\n                if a==0:\\n                    return second\\n            a=tickets[k]\\n            \\n        return second",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "class Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n\\t\\n        second=0\\n        a=tickets[k]\\n        while a!=0:\\n            for i in range(len(tickets)):\\n                if tickets[i]!=0:\\n                    second+=1\\n                    tickets[i]=tickets[i]-1\\n                a=tickets[k]\\n                if a==0:\\n                    return second\\n            a=tickets[k]\\n            \\n        return second",
                "codeTag": "Java"
            },
            {
                "id": 1802939,
                "title": "python-3-easy-to-understand",
                "content": "Runtime: 64 ms, faster than 43.29% of Python3 online submissions for Time Needed to Buy Tickets.\\nMemory Usage: 13.9 MB, less than 86.76% of Python3 online submissions for Time Needed to Buy Tickets\\n```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        p = 0                       #pointer\\n        clock = 0                   #clock\\n        while tickets[k] > 0:       #stop when person k has bought all required tickets\\n            if tickets[p] != 0:     #only buy a ticket if person p still needs to buy tickets\\n                tickets[p] -= 1     #person p buys a ticket\\n                clock += 1          #increment clock whenever a ticket is bought\\n            p += 1                  #move pointer to next person\\n            p %= len(tickets)       #loop pointer from end of list to start of list\\n        return clock\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        p = 0                       #pointer\\n        clock = 0                   #clock\\n        while tickets[k] > 0:       #stop when person k has bought all required tickets\\n            if tickets[p] != 0:     #only buy a ticket if person p still needs to buy tickets\\n                tickets[p] -= 1     #person p buys a ticket\\n                clock += 1          #increment clock whenever a ticket is bought\\n            p += 1                  #move pointer to next person\\n            p %= len(tickets)       #loop pointer from end of list to start of list\\n        return clock\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1793517,
                "title": "c-tc-o-n-sc-o-1-100-faster",
                "content": "class Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        \\n        int result=0;\\n        \\n        for(int i=0;i<tickets.size();i++){\\n            \\n            result+= i<=k ?min(tickets[i],tickets[k]): min(tickets[i],tickets[k]-1);\\n            \\n        }\\n        return result;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        \\n        int result=0;\\n        \\n        for(int i=0;i<tickets.size();i++){\\n            \\n            result+= i<=k ?min(tickets[i],tickets[k]): min(tickets[i],tickets[k]-1);\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1746430,
                "title": "typescript-100",
                "content": "Your runtime beats 100 % of typescript submissions\\nYour memory usage beats 14.29 % of typescript submissions (43.5 MB)\\n```\\nfunction timeRequiredToBuy(tickets: number[], k: number): number {\\n    let result: number = 0;\\n    for (let i: number = 0; true; i = i === tickets.length ? 0 : i + 1) {\\n        if (tickets[i] > 0) {\\n            tickets[i]--;\\n            result++;\\n            if (tickets[i] === 0 && i === k) {\\n                break;\\n            }\\n        }\\n    }\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction timeRequiredToBuy(tickets: number[], k: number): number {\\n    let result: number = 0;\\n    for (let i: number = 0; true; i = i === tickets.length ? 0 : i + 1) {\\n        if (tickets[i] > 0) {\\n            tickets[i]--;\\n            result++;\\n            if (tickets[i] === 0 && i === k) {\\n                break;\\n            }\\n        }\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1744017,
                "title": "c-faster-than-100-of-submissions-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int ans=0;\\n        for(int i=0; i<k+1; i++){\\n            if(tickets[i]<=tickets[k]){\\n                ans+=tickets[i];\\n            }\\n            else{\\n                ans+=tickets[k];\\n            }\\n        }\\n        for(int i=k+1; i<tickets.size(); i++){\\n             if(tickets[i]<tickets[k]){\\n                ans+=tickets[i];\\n            }\\n            else{\\n                ans+=tickets[k]-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int ans=0;\\n        for(int i=0; i<k+1; i++){\\n            if(tickets[i]<=tickets[k]){\\n                ans+=tickets[i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1742844,
                "title": "java-o-n-soln-easy-for-beginners",
                "content": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int count=0,i=0;\\n        while(tickets[k]!=0){\\n            if(i==tickets.length-1){\\n                if(tickets[i]==0){\\n                    i=0;\\n                continue;\\n            }\\n            else{\\n                tickets[i]=tickets[i]-1;\\n                count++;\\n                i=0;\\n                continue;\\n            }\\n            }\\n            else{\\n            if(tickets[i]==0){\\n                i++;\\n                continue;\\n            }\\n            else{\\n                tickets[i]=tickets[i]-1;\\n                count++;\\n            }\\n            i++;\\n            }\\n        }\\n        return count;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int count=0,i=0;\\n        while(tickets[k]!=0){\\n            if(i==tickets.length-1){\\n                if(tickets[i]==0){\\n                    i=0;\\n                continue;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1741714,
                "title": "java-easy-solution-optimal-100-faster-o-n-tc-o-1-sc",
                "content": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int ans=0;\\n        for(int i=k;i>=0;i--)\\n            ans+=Math.min(tickets[k],tickets[i]);\\n        for(int i=tickets.length-1;i>k;i--)\\n            ans+=Math.min(tickets[k]-1,tickets[i]);\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int ans=0;\\n        for(int i=k;i>=0;i--)\\n            ans+=Math.min(tickets[k],tickets[i]);\\n        for(int i=tickets.length-1;i>k;i--)\\n            ans+=Math.min(tickets[k]-1,tickets[i]);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1715695,
                "title": "java-easy-understanding-0ms-for-loop",
                "content": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int count = 0;\\n        int val = tickets[k];\\n        for(int i=0; i<tickets.length; i++){\\n            if(i <= k)\\n                count += (val > tickets[i]) ? tickets[i] : val;\\n            else\\n                count += (val > tickets[i]) ? tickets[i] : val-1;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int count = 0;\\n        int val = tickets[k];\\n        for(int i=0; i<tickets.length; i++){\\n            if(i <= k)\\n                count += (val > tickets[i]) ? tickets[i] : val;\\n            else\\n                count += (val > tickets[i]) ? tickets[i] : val-1;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1688697,
                "title": "java-o-n-easy-to-understand-intuition",
                "content": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        if(tickets == null || tickets.length == 0 || k > tickets.length) \\n            return 0;\\n        \\n        /*\\n          Intuition: Since 1 ticket is bought in 1 second. Number of tickets bought will give us the total time taken. \\n          We know we have to buy \"tickets[k]\" number of tickets. 2 cases possible: \\n\\n    Case-1: Going in a loop we are purchasing tickets and until we purchase \"tickets[k]\" number of tickets the people infront(left) of us buy tickets which is equal to Math.min(tickets[i], tickets[k]) because tickets[i] can be greater/lesser than tickets[k], and we can only buy the minimum of both. \\n          Ex-1: tickets[i], tickets[k] => 2, 4 implies i\\'th person can only buy 2 tickets. \\n          Ex-2: tickets[i], tickets[k] => 5, 3 implies i\\'th person can only buy 3 tickets and he still has 2 more tickets to buy which we dont have to wait for\\n        \\n    Case-2: Once we buy all the required tickets (i.e., tickets[k] becomes 0) we no longer have to buy(count) the tickets which are behind(right) of us. That means we only have to buy tickets until the last iteration before which tickets[k] becomes 0 i.e., the previous iteration where tickets[k]-1 are the amount of tickets to be bought.\\n    \\n    Note: If above cases don\\'t make sense. Think of it this way, we have divided the cases into 2 parts. One which are on & before(to the left) of \\'k\\' and other which are to the right of \\'k\\'\\n        */\\n        \\n        \\n        int timeTaken = 0; // TimeTaken = TicketsBought\\n        \\n        \\n        // The way to calculate number of tickets bought\\n        for(int i=0; i<tickets.length; i++) {\\n            if(i <= k) {\\n                timeTaken += Math.min(tickets[i], tickets[k]);  // Case 1\\n            } else {\\n                timeTaken += Math.min(tickets[k]-1, tickets[i]); // Case 2\\n            }\\n        }\\n        \\n        return timeTaken;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        if(tickets == null || tickets.length == 0 || k > tickets.length) \\n            return 0;\\n        \\n        /*\\n          Intuition: Since 1 ticket is bought in 1 second. Number of tickets bought will give us the total time taken. \\n          We know we have to buy \"tickets[k]\" number of tickets. 2 cases possible: \\n\\n    Case-1: Going in a loop we are purchasing tickets and until we purchase \"tickets[k]\" number of tickets the people infront(left) of us buy tickets which is equal to Math.min(tickets[i], tickets[k]) because tickets[i] can be greater/lesser than tickets[k], and we can only buy the minimum of both. \\n          Ex-1: tickets[i], tickets[k] => 2, 4 implies i\\'th person can only buy 2 tickets. \\n          Ex-2: tickets[i], tickets[k] => 5, 3 implies i\\'th person can only buy 3 tickets and he still has 2 more tickets to buy which we dont have to wait for\\n        \\n    Case-2: Once we buy all the required tickets (i.e., tickets[k] becomes 0) we no longer have to buy(count) the tickets which are behind(right) of us. That means we only have to buy tickets until the last iteration before which tickets[k] becomes 0 i.e., the previous iteration where tickets[k]-1 are the amount of tickets to be bought.\\n    \\n    Note: If above cases don\\'t make sense. Think of it this way, we have divided the cases into 2 parts. One which are on & before(to the left) of \\'k\\' and other which are to the right of \\'k\\'\\n        */\\n        \\n        \\n        int timeTaken = 0; // TimeTaken = TicketsBought\\n        \\n        \\n        // The way to calculate number of tickets bought\\n        for(int i=0; i<tickets.length; i++) {\\n            if(i <= k) {\\n                timeTaken += Math.min(tickets[i], tickets[k]);  // Case 1\\n            } else {\\n                timeTaken += Math.min(tickets[k]-1, tickets[i]); // Case 2\\n            }\\n        }\\n        \\n        return timeTaken;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1650061,
                "title": "0-ms-o-n-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int n=tickets.size();\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            ans+= min(tickets[k]-(i>k),tickets[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int n=tickets.size();\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            ans+= min(tickets[k]-(i>k),tickets[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1650041,
                "title": "c-o-n-one-pass",
                "content": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int n=tickets.size();\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            if(tickets[i]>=tickets[k]) ans+=(i<=k?tickets[k]:tickets[k]-1);\\n            else ans+=tickets[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int n=tickets.size();\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            if(tickets[i]>=tickets[k]) ans+=(i<=k?tickets[k]:tickets[k]-1);\\n            else ans+=tickets[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1637234,
                "title": "java-100-faster-short-solution",
                "content": "```\\npublic int timeRequiredToBuy(int[] tickets, int k) {\\n        int timeTakenForK = 0;\\n       \\n        for(int i = 0; i < tickets.length; i++){\\n            if(i < k) timeTakenForK+=Math.min(tickets[k], tickets[i]);\\n            if(i > k) timeTakenForK+=Math.min(tickets[k] - 1, tickets[i]);\\n            if(i == k)timeTakenForK+=tickets[k];}\\n  \\n        return timeTakenForK;}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int timeRequiredToBuy(int[] tickets, int k) {\\n        int timeTakenForK = 0;\\n       \\n        for(int i = 0; i < tickets.length; i++){\\n            if(i < k) timeTakenForK+=Math.min(tickets[k], tickets[i]);\\n            if(i > k) timeTakenForK+=Math.min(tickets[k] - 1, tickets[i]);\\n            if(i == k)timeTakenForK+=tickets[k];}\\n  \\n        return timeTakenForK;}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1632040,
                "title": "easy-one-pass-o-n",
                "content": "For the people ahead of the person at `idx=k` they all get down to the minimum of their value and the value of the person at position `k`, for the people behind that person, since we stop as soon as the the person at position `k` has bought all his/her tickets, they get to minimum of  their value and the value of the person at position `k` minus `1`.\\n```\\nclass Solution(object):\\n    def timeRequiredToBuy(self, tickets, k):\\n        \"\"\"\\n        :type tickets: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        tot, idx = 0, len(tickets)-1\\n\\n        while(idx>=0):\\n            tot += min(tickets[k], tickets[idx]) if idx<=k else min(tickets[k]-1, tickets[idx])\\n            idx-=1\\n            \\n        return tot \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def timeRequiredToBuy(self, tickets, k):\\n        \"\"\"\\n        :type tickets: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        tot, idx = 0, len(tickets)-1\\n\\n        while(idx>=0):\\n            tot += min(tickets[k], tickets[idx]) if idx<=k else min(tickets[k]-1, tickets[idx])\\n            idx-=1\\n            \\n        return tot \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1622513,
                "title": "easy-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int ans=0,n=tickets.size(),fix=tickets[k];\\n        for(int i=0;i<fix-1;i++){\\n            for(int j=0;j<n;j++){\\n                if(tickets[j]>0) ans++;\\n                tickets[j]--;\\n            }\\n        }\\n        for(int j=0;j<=k;j++){\\n            if(tickets[j]>0) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int ans=0,n=tickets.size(),fix=tickets[k];\\n        for(int i=0;i<fix-1;i++){\\n            for(int j=0;j<n;j++){\\n                if(tickets[j]>0) ans++;\\n                tickets[j]--;\\n            }\\n        }\\n        for(int j=0;j<=k;j++){\\n            if(tickets[j]>0) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1603655,
                "title": "java-o-n-0ms-4-line-answer",
                "content": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int ans=0;\\n        for(int i=0; i<=k; i++) ans+=Math.min(tickets[i], tickets[k]);\\n        for(int i=k+1; i<tickets.length; i++)ans+=Math.min(tickets[i], tickets[k]-1);\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int ans=0;\\n        for(int i=0; i<=k; i++) ans+=Math.min(tickets[i], tickets[k]);\\n        for(int i=k+1; i<tickets.length; i++)ans+=Math.min(tickets[i], tickets[k]-1);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1591130,
                "title": "java-100-easy-solution",
                "content": "Apulatjonov\\n```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int count = 0;\\n        for(int i = 0; i < tickets.length; i++){\\n            if(tickets[i] < tickets[k]){\\n                count += tickets[i];\\n            }else{\\n                count += tickets[k];\\n            }\\n        }\\n        for(int i = k; i < tickets.length; i++){\\n            if(tickets[i] >= tickets[k])\\n                count--;\\n        }\\n        return ++count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int count = 0;\\n        for(int i = 0; i < tickets.length; i++){\\n            if(tickets[i] < tickets[k]){\\n                count += tickets[i];\\n            }else{\\n                count += tickets[k];\\n            }\\n        }\\n        for(int i = k; i < tickets.length; i++){\\n            if(tickets[i] >= tickets[k])\\n                count--;\\n        }\\n        return ++count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1588109,
                "title": "c-simple-for-loop",
                "content": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int t = tickets[k];\\n        for(int i = 0; i < k; i++) {\\n            t += min(tickets[i], tickets[k]);\\n        }\\n        for(int i = k+1; i<tickets.size(); i++) {\\n            t += min(tickets[i], tickets[k]-1);\\n        }\\n        return t;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int t = tickets[k];\\n        for(int i = 0; i < k; i++) {\\n            t += min(tickets[i], tickets[k]);\\n        }\\n        for(int i = k+1; i<tickets.size(); i++) {\\n            t += min(tickets[i], tickets[k]-1);\\n        }\\n        return t;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1583361,
                "title": "javascript-brute-force",
                "content": "```\\nvar timeRequiredToBuy = function(tickets, k) {\\n    let time = 0\\n    while(tickets[k]){\\n        for(i = 0; i < tickets.length; i++){\\n           if(tickets[i] && tickets[k]) {\\n               time+=1\\n               tickets[i]-=1\\n           } \\n        }\\n    }\\n    return time\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar timeRequiredToBuy = function(tickets, k) {\\n    let time = 0\\n    while(tickets[k]){\\n        for(i = 0; i < tickets.length; i++){\\n           if(tickets[i] && tickets[k]) {\\n               time+=1\\n               tickets[i]-=1\\n           } \\n        }\\n    }\\n    return time\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1582832,
                "title": "c-gcc-100-bytes-0-ms-5-9-mb",
                "content": "```\\ni,s;timeRequiredToBuy(int*a,int n,int k){i=s=0;\\nwhile(a[k])a[i]-=a[i]?s++,1:0,i=++i<n?i:0;return s;}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\ni,s;timeRequiredToBuy(int*a,int n,int k){i=s=0;\\nwhile(a[k])a[i]-=a[i]?s++,1:0,i=++i<n?i:0;return s;}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1581974,
                "title": "python-2-line-explain",
                "content": "- For k\\'s first ticket, it\\'ll take k seconds to get the turn\\n- After that, ppl before k will need -1 tickets, after k remain same\\n- Then for the remaining rounds, each ppl will buy at most ticket[k] -1 before job done, plus ticket[k] seconds for k to buy\\n\\n```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        remaining = [t-1 for t in tickets[:k]] + tickets[k+1:]\\n        return k + sum(min(r, tickets[k] - 1) for r in remaining) + tickets[k]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        remaining = [t-1 for t in tickets[:k]] + tickets[k+1:]\\n        return k + sum(min(r, tickets[k] - 1) for r in remaining) + tickets[k]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1581364,
                "title": "python-easy-solution",
                "content": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        a=tickets[k]\\n        x=0\\n        while(a!=0):\\n            for i in range(len(tickets)):\\n                if(tickets[i]!=0):\\n                    x=x+1\\n                    tickets[i]=tickets[i]-1\\n                a=tickets[k]\\n                if(a==0):\\n                    return(x)\\n\\t\\t\\t#print(tickets)\\n            a=tickets[k]\\n        return(x)\\n```\\nIf u liked the code then plz...UPVOTE",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        a=tickets[k]\\n        x=0\\n        while(a!=0):\\n            for i in range(len(tickets)):\\n                if(tickets[i]!=0):\\n                    x=x+1\\n                    tickets[i]=tickets[i]-1\\n                a=tickets[k]\\n                if(a==0):\\n                    return(x)\\n\\t\\t\\t#print(tickets)\\n            a=tickets[k]\\n        return(x)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1580231,
                "title": "python-o-n-faster-than-99",
                "content": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        x = tickets[k]\\n        res = 0\\n        for i in range(k + 1):\\n            res += min(x, tickets[i])\\n\\n        for i in range(k + 1, len(tickets)):\\n            res += min(x - 1, tickets[i])\\n\\n        return res",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        x = tickets[k]\\n        res = 0\\n        for i in range(k + 1):\\n            res += min(x, tickets[i])\\n\\n        for i in range(k + 1, len(tickets)):\\n            res += min(x - 1, tickets[i])\\n\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 1580050,
                "title": "c-o-n-tc-and-o-1-sc-clean",
                "content": "A simple Approch should be to traverse the array and adding elements eqaul to , or less than kth element .\\n\\n\\n\\'\\'\\'\\n\\n         int timeRequiredToBuy(vector<int>& tickets, int k) {\\n\\n        int t = 0;  //time taken by kth person to buy the tickets\\n\\t\\t\\n        for(int i = 0; i<tickets.size(); i++){\\n\\t\\t\\n            if(i <= k){\\n\\t\\t\\t//for person is placed earliear than kth person \\n                t = t+ min(tickets[i],  tickets[k]);\\n            }\\n            if(i > k){\\n\\t\\t\\t// for persons placed after the kth person\\n                t = t+ min(tickets[i],  tickets[k]-1);\\n            }\\n        }return t;\\n\\t\\t\\'\\'\\'\\n\\t\\t\\nDry run this code with different test cases and eventually you will know the conditions\\n\\t\\t",
                "solutionTags": [
                    "C"
                ],
                "code": "A simple Approch should be to traverse the array and adding elements eqaul to , or less than kth element .\\n\\n\\n\\'\\'\\'\\n\\n         int timeRequiredToBuy(vector<int>& tickets, int k) {\\n\\n        int t = 0;  //time taken by kth person to buy the tickets\\n\\t\\t\\n        for(int i = 0; i<tickets.size(); i++){\\n\\t\\t\\n            if(i <= k){\\n\\t\\t\\t//for person is placed earliear than kth person \\n                t = t+ min(tickets[i],  tickets[k]);\\n            }\\n            if(i > k){\\n\\t\\t\\t// for persons placed after the kth person\\n                t = t+ min(tickets[i],  tickets[k]-1);\\n            }\\n        }return t;\\n\\t\\t\\'\\'\\'\\n\\t\\t\\nDry run this code with different test cases and eventually you will know the conditions\\n\\t\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1579383,
                "title": "python-one-pass-solution",
                "content": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        n = len(tickets)\\n        res = tickets[k] #it has to buy all at kth position\\n        \\n        for i in range(n):\\n            if i < k:\\n                res += min(tickets[i], tickets[k])  # for all pos before k it will exhaust all tickets or get till number till kth place\\n                \\n            elif i > k:\\n                res += min(tickets[i], tickets[k]-1) #for all pos after k it can exhaust all tickets or get 1 less than the kth gets finished\\n                \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        n = len(tickets)\\n        res = tickets[k] #it has to buy all at kth position\\n        \\n        for i in range(n):\\n            if i < k:\\n                res += min(tickets[i], tickets[k])  # for all pos before k it will exhaust all tickets or get till number till kth place\\n                \\n            elif i > k:\\n                res += min(tickets[i], tickets[k]-1) #for all pos after k it can exhaust all tickets or get 1 less than the kth gets finished\\n                \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1578792,
                "title": "c-simple-approach-brute-force",
                "content": "```\\nclass Solution {\\npublic:\\nint timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int count = 0;\\n        while(tickets[k] != 0){\\n            for(int i=0; i<tickets.size(); i++){\\n                { if(tickets[i] > 0) \\n                {\\n                    tickets[i]--;\\n                    count++;\\n                }\\n                }\\n              if(tickets[k] == 0) break;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int count = 0;\\n        while(tickets[k] != 0){\\n            for(int i=0; i<tickets.size(); i++){\\n                { if(tickets[i] > 0) \\n                {\\n                    tickets[i]--;\\n                    count++;\\n                }\\n                }\\n              if(tickets[k] == 0) break;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1578006,
                "title": "c-solution-beats-100-o-n-onepass",
                "content": "```\\nint timeRequiredToBuy(vector<int>& tk, int k) {\\n        int val=tk[k];\\n        int ans=0;\\n        for(int i=0;i<tk.size();i++){\\n            if(tk[i]>val)ans+=val;\\n            else ans+=tk[i];\\n            if(i>k && tk[i]>=tk[k])ans--;\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint timeRequiredToBuy(vector<int>& tk, int k) {\\n        int val=tk[k];\\n        int ans=0;\\n        for(int i=0;i<tk.size();i++){\\n            if(tk[i]>val)ans+=val;\\n            else ans+=tk[i];\\n            if(i>k && tk[i]>=tk[k])ans--;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1577999,
                "title": "c-brute-force-to-optimal-easy-to-understand",
                "content": "Time Needed to Buy Tickets - \\n\\n\\n**1) Brute Force -**\\n\\n```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) \\n    {\\n          int cnt=0;\\n          while(tickets[k]!=0)\\n          {\\n              for(int i=0;i<tickets.size();i++)\\n              {\\n                  if(tickets[i]>0)\\n                  {\\n                      tickets[i]-=1;\\n                      cnt++;\\n                  }\\n                 if(tickets[k]==0)\\n                  {break;}\\n              }\\n          }\\n       return cnt; \\n    }\\n};\\n```\\n\\n**2) Optimal Solution - O(n)**\\n\\n```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) \\n    {\\n          int cnt=0;\\n          for(int i=0;i<tickets.size();i++)\\n          {\\n              cnt+=min(tickets[k] - (i>k),tickets[i]);\\n          }\\n       return cnt; \\n    }\\n};\\n```\\n\\nPlease comment if you have any doubt.\\nWill get back to you as soon as possible.\\n**UPVOTE if you find it useful!**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) \\n    {\\n          int cnt=0;\\n          while(tickets[k]!=0)\\n          {\\n              for(int i=0;i<tickets.size();i++)\\n              {\\n                  if(tickets[i]>0)\\n                  {\\n                      tickets[i]-=1;\\n                      cnt++;\\n                  }\\n                 if(tickets[k]==0)\\n                  {break;}\\n              }\\n          }\\n       return cnt; \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) \\n    {\\n          int cnt=0;\\n          for(int i=0;i<tickets.size();i++)\\n          {\\n              cnt+=min(tickets[k] - (i>k),tickets[i]);\\n          }\\n       return cnt; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1577952,
                "title": "c-one-traversal-solution-one-pass-o-n-beats-100-of-c-codes",
                "content": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int n = tickets.size();\\n        int time = 0;\\n        \\n        for(int i=0; i<n; i++){\\n            if(tickets[i] <= tickets[k])\\n                time += tickets[i];\\n            else\\n                time += tickets[k];\\n            if(i > k && tickets[i] >= tickets[k])\\n                time--;\\n        }\\n        return time;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int n = tickets.size();\\n        int time = 0;\\n        \\n        for(int i=0; i<n; i++){\\n            if(tickets[i] <= tickets[k])\\n                time += tickets[i];\\n            else\\n                time += tickets[k];\\n            if(i > k && tickets[i] >= tickets[k])\\n                time--;\\n        }\\n        return time;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1577387,
                "title": "c-one-pass-solution",
                "content": "**Intuition**\\npeople ```k``` and people before ```k``` will need to buy ```Min(tickets[i], tickets[k])```.\\npeople after ```k``` don\\'t need to buy any tickets if people ```k``` already got all the tickets, so people after ```k``` need to buy  ```Min(tickets[i], tickets[k] - 1)```.\\n\\n**Complexity**\\n- Time: O(n)\\n- Space: O(1)\\n\\n**Implementation**\\n```\\npublic class Solution {\\n    public int TimeRequiredToBuy(int[] tickets, int k) {\\n        \\n        int res  = 0;\\n        \\n        for(int i = 0; i < tickets.Length; i++)\\n        {\\n            if(i <= k)\\n                res += Math.Min(tickets[i], tickets[k]);\\n            else if(i > k)\\n                res += Math.Min(tickets[i], tickets[k] - 1);\\n        }\\n       \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```k```\n```k```\n```Min(tickets[i], tickets[k])```\n```k```\n```k```\n```k```\n```Min(tickets[i], tickets[k] - 1)```\n```\\npublic class Solution {\\n    public int TimeRequiredToBuy(int[] tickets, int k) {\\n        \\n        int res  = 0;\\n        \\n        for(int i = 0; i < tickets.Length; i++)\\n        {\\n            if(i <= k)\\n                res += Math.Min(tickets[i], tickets[k]);\\n            else if(i > k)\\n                res += Math.Min(tickets[i], tickets[k] - 1);\\n        }\\n       \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1577113,
                "title": "c-one-pass-simulation",
                "content": "<strong>Logical Thinking</strong>\\n<p>We can easily solve this problem through <code>simulation</code>. Suppose the <code>k<sup>th</sup></code> person needs <code>target = tickets[k]</code> tickets, then when this person leaves, the people in front of him <code>i < k</code> must have bought the same number of tickets (if they need more tickets), i.e. each of them bought <code>min(target, tickets[i])</code>. Similarly, the people behind him <code>i > k</code> must have bought <code>1</code> less tickets, i.e. <code>min(target - 1, tickets[i])</code>.</p>\\n\\n\\n<strong>C++</strong>\\n\\n```\\n//  Topic   : 2073. Time Needed to Buy Tickets (https://leetcode.com/problems/time-needed-to-buy-tickets/)\\n//  Author  : YCX\\n//  Time    : O(N)\\n//  Space   : O(1)\\n\\n\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int ans = 0, target = tickets[k], n = tickets.size();\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (i <= k)\\n                ans += min<int>(tickets[i], target);\\n            else\\n                ans += min<int>(tickets[i], target - 1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Simulation"
                ],
                "code": "```\\n//  Topic   : 2073. Time Needed to Buy Tickets (https://leetcode.com/problems/time-needed-to-buy-tickets/)\\n//  Author  : YCX\\n//  Time    : O(N)\\n//  Space   : O(1)\\n\\n\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int ans = 0, target = tickets[k], n = tickets.size();\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (i <= k)\\n                ans += min<int>(tickets[i], target);\\n            else\\n                ans += min<int>(tickets[i], target - 1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1577096,
                "title": "c-brute-force",
                "content": "```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    \\n    void solve(vector<int> &nums, int k)\\n    {\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            if(nums[i]==0)\\n                continue;\\n            nums[i] = nums[i]-1;\\n                ans++;\\n            if(nums[k] == 0)\\n                return;\\n        }\\n    }\\n    \\n    int timeRequiredToBuy(vector<int> &nums, int k) \\n    {    \\n        while(true)\\n        {\\n            if(nums[k]==0)\\n                break;\\n            solve(nums,k);    \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    \\n    void solve(vector<int> &nums, int k)\\n    {\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            if(nums[i]==0)\\n                continue;\\n            nums[i] = nums[i]-1;\\n                ans++;\\n            if(nums[k] == 0)\\n                return;\\n        }\\n    }\\n    \\n    int timeRequiredToBuy(vector<int> &nums, int k) \\n    {    \\n        while(true)\\n        {\\n            if(nums[k]==0)\\n                break;\\n            solve(nums,k);    \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1576994,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        \\n        res = i = 0\\n        \\n        while tickets[k]:\\n            try:\\n                j = tickets[i]\\n                if j:\\n                    tickets[i] = j - 1\\n                    i += 1\\n                    res += 1\\n                else:\\n                    i += 1\\n            except:\\n                i = 0\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        \\n        res = i = 0\\n        \\n        while tickets[k]:\\n            try:\\n                j = tickets[i]\\n                if j:\\n                    tickets[i] = j - 1\\n                    i += 1\\n                    res += 1\\n                else:\\n                    i += 1\\n            except:\\n                i = 0\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1576925,
                "title": "java-brute-force-easy-to-understand",
                "content": "```\\nclass Solution\\n{\\n    public int timeRequiredToBuy(int[] tickets, int k)\\n    {\\n        int time = 0;\\n        while(true)\\n        {\\n            for(int i = 0; i < tickets.length; i++)\\n            {\\n                if(tickets[i]-- >= 1)\\n                    time++;\\n                if(tickets[k] == 0)\\n                    return time;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution\\n{\\n    public int timeRequiredToBuy(int[] tickets, int k)\\n    {\\n        int time = 0;\\n        while(true)\\n        {\\n            for(int i = 0; i < tickets.length; i++)\\n            {\\n                if(tickets[i]-- >= 1)\\n                    time++;\\n                if(tickets[k] == 0)\\n                    return time;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1576918,
                "title": "python-java-easy-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n\\t\\t\\tres = 0\\n\\t\\t\\tfor i, ticket in enumerate(tickets):\\n\\t\\t\\t\\tif i <= k:\\n\\t\\t\\t\\t\\tres += min(ticket, tickets[k])\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tif ticket < tickets[k]:\\n\\t\\t\\t\\t\\t\\tres += ticket\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tres += tickets[k] - 1\\n\\t\\t\\treturn res\\n\\t\\t\\t\\n\\t\\t\\t\\n\\tclass Solution {\\n\\t\\tpublic int timeRequiredToBuy(int[] tickets, int k) {\\n\\t\\t\\tint res = 0;\\n\\t\\t\\tfor (int i = 0; i < tickets.length; i ++) {\\n\\t\\t\\t\\tif (i <= k) {\\n\\t\\t\\t\\t\\tres += Math.min(tickets[i], tickets[k]);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tif (tickets[i] < tickets[k]) {\\n\\t\\t\\t\\t\\t\\tres += tickets[i];\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tres += tickets[k] - 1;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution:\\n\\t\\tdef timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n\\t\\t\\tres = 0\\n\\t\\t\\tfor i, ticket in enumerate(tickets):\\n\\t\\t\\t\\tif i <= k:\\n\\t\\t\\t\\t\\tres += min(ticket, tickets[k])\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tif ticket < tickets[k]:\\n\\t\\t\\t\\t\\t\\tres += ticket\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tres += tickets[k] - 1\\n\\t\\t\\treturn res\\n\\t\\t\\t\\n\\t\\t\\t\\n\\tclass Solution {\\n\\t\\tpublic int timeRequiredToBuy(int[] tickets, int k) {\\n\\t\\t\\tint res = 0;\\n\\t\\t\\tfor (int i = 0; i < tickets.length; i ++) {\\n\\t\\t\\t\\tif (i <= k) {\\n\\t\\t\\t\\t\\tres += Math.min(tickets[i], tickets[k]);\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 4077206,
                "title": "o-n-with-readable-code-simple-for-loop",
                "content": "## Approach\\n<!-- Describe your approach to solving the problem. -->\\ndeclare variable ans = 0, this variable will be the counter (and the answer).\\nthe target is tickets[k]. \\nif the index is less or equal to k (the target index):\\n- if the tickets[index] is bigger than target add ans equals target.\\n- else (tickets[index] is less than target) add ans equals tickets[index].\\n\\nelse (index is bigger than k (the target index))\\n- if the tickets[index] is bigger than target add ans equals target-1 (-1 because we assume that in the last recursion stopped in target index).\\n- else (tickets[index] is less than target) add ans equals tickets[index].\\n\\n# Complexity\\n- Time complexity: o(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: o(1) (?)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int ans = 0 ;\\n        for(int x = 0 ; x<tickets.length ; x++){\\n            if(x <= k){\\n                if(tickets[x] >= tickets[k]){\\n                    ans += tickets[k];\\n                }else{\\n                    ans += tickets[x];\\n                }\\n            }else{\\n                if(tickets[x] >= tickets[k]){\\n                    ans += tickets[k]-1;\\n                }else{\\n                    ans += tickets[x];\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int ans = 0 ;\\n        for(int x = 0 ; x<tickets.length ; x++){\\n            if(x <= k){\\n                if(tickets[x] >= tickets[k]){\\n                    ans += tickets[k];\\n                }else{\\n                    ans += tickets[x];\\n                }\\n            }else{\\n                if(tickets[x] >= tickets[k]){\\n                    ans += tickets[k]-1;\\n                }else{\\n                    ans += tickets[x];\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4061851,
                "title": "beats-100-cpp",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int ans=0;\\n\\n        while(tickets[k]>0){\\n            for(int j=0;j<tickets.size();j++){\\n//decrementing ticket at j and incrementing ans only if k > 0 && j > 0\\n                if(tickets[k]!=0 && tickets[j]>0){\\n                    tickets[j]--;\\n                    ans++;\\n                }\\n        }\\n\\n        \\n    }\\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int ans=0;\\n\\n        while(tickets[k]>0){\\n            for(int j=0;j<tickets.size();j++){\\n//decrementing ticket at j and incrementing ans only if k > 0 && j > 0\\n                if(tickets[k]!=0 && tickets[j]>0){\\n                    tickets[j]--;\\n                    ans++;\\n                }\\n        }\\n\\n        \\n    }\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4059886,
                "title": "easiest-solution-cpp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nJust need to think how can we iterate the vector again and again\\nand to do this i have used the method of circular queue.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int cnt=0;\\n        int i=0;\\n        int n=tickets.size();\\n        while(1)\\n        {\\n            if(tickets[i]!=0)\\n            {\\n                cnt++;\\n                tickets[i]--;\\n            }\\n            if(i==k&&tickets[k]==0)\\n             return cnt;\\n            i=(i+1)%n;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int cnt=0;\\n        int i=0;\\n        int n=tickets.size();\\n        while(1)\\n        {\\n            if(tickets[i]!=0)\\n            {\\n                cnt++;\\n                tickets[i]--;\\n            }\\n            if(i==k&&tickets[k]==0)\\n             return cnt;\\n            i=(i+1)%n;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4055339,
                "title": "0-ms-solution-java",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere, we mainly take count of contribution of every index value while a loop runs.\\n\\nIf value at any index (i) **before** given index (k) is **greater**, then **it will contribute same as tickets[k**]. Because, while running the loop the value of tickets[i] will run  for (tickets[k]) times.\\n\\nIf value at any index (i) **after** given index (k) is **greater** or equals, then **it will contribute same as (tickets[k]-1)**. Because, before reaching the loop for the last time, index at k will get the ticket. So, we won\\'t take the last count.\\n\\nIf value at any index (i) is less than value at given index (k), then the we will not change the value of it. Because, it will be 0 before tickets[k] time. It will contribute tickets[i].\\n\\nWe will update the no of contibution with value of any index.\\nThen, we will take the sum of the whole array and that\\'s the answer. \\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int sum=0;\\n        for (int i=0;i<tickets.length;i++){\\n            if (k>i &&tickets[k]<=tickets[i]){\\n            tickets[i]=tickets[k];\\n            }\\n            if (k<i &&tickets[k]<=tickets[i]){\\n            tickets[i]=tickets[k]-1;\\n            }\\n        }\\n\\n        for (int i=0;i<tickets.length;i++){\\n            sum+=tickets[i];\\n        }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int sum=0;\\n        for (int i=0;i<tickets.length;i++){\\n            if (k>i &&tickets[k]<=tickets[i]){\\n            tickets[i]=tickets[k];\\n            }\\n            if (k<i &&tickets[k]<=tickets[i]){\\n            tickets[i]=tickets[k]-1;\\n            }\\n        }\\n\\n        for (int i=0;i<tickets.length;i++){\\n            sum+=tickets[i];\\n        }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4048214,
                "title": "java-simple-using-queue-t-n",
                "content": "# Intuition\\nUsed Queue\\n\\n# Approach\\n1. Number of People in queue.(count same as ticket).\\n2. remove from queue when tickets[queue.peek()] == 0,\\n3. otherwise queue.add(queue.peek()) & queue.remove(); \\n\\n# Complexity\\n- Time complexity:\\nOnly one while loop : T(n)\\nremove and add take : O(1)\\nTherfore TimeComplexity : T(n).\\n\\n- Space complexity:\\nSpace Complexity is the space taken by queue which is O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        Queue<Integer> queue = new LinkedList<>();\\n        for(int i = 0; i < tickets.length; i++){\\n            queue.add(i);\\n        }\\n        int count = 0;\\n        while(!queue.isEmpty()){\\n            tickets[queue.peek()]--;\\n            if(tickets[queue.peek()] == 0){\\n                queue.remove();\\n            }else if(tickets[queue.peek()] != 0){\\n                queue.add(queue.peek());\\n                queue.remove();\\n            }\\n            count++;\\n            if(tickets[k] == 0){\\n                return count;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        Queue<Integer> queue = new LinkedList<>();\\n        for(int i = 0; i < tickets.length; i++){\\n            queue.add(i);\\n        }\\n        int count = 0;\\n        while(!queue.isEmpty()){\\n            tickets[queue.peek()]--;\\n            if(tickets[queue.peek()] == 0){\\n                queue.remove();\\n            }else if(tickets[queue.peek()] != 0){\\n                queue.add(queue.peek());\\n                queue.remove();\\n            }\\n            count++;\\n            if(tickets[k] == 0){\\n                return count;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4045024,
                "title": "time-needed-to-buy-tickets",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ndecreasing array values with base case condition until ticket[k] becomes zero.\\nAnd if there is only one ticket needs to buy then just do time = k+1\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->2ms\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n39.80 mb\\n\\n# Code\\n```\\nimport java.util.*;\\nclass Solution {\\n    public int time=0;\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        if(tickets[k]==1){\\n            return k+1;\\n        }\\n        while(tickets[k]>0){\\n            for(int i = 0;i<tickets.length;i++){\\n                if(tickets[i]==0){\\n                    continue;\\n                }\\n                time++;\\n                tickets[i] = tickets[i] - 1;\\n                if(tickets[k]==0){\\n                    break;\\n                }\\n            }\\n        }\\n        return time;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nimport java.util.*;\\nclass Solution {\\n    public int time=0;\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        if(tickets[k]==1){\\n            return k+1;\\n        }\\n        while(tickets[k]>0){\\n            for(int i = 0;i<tickets.length;i++){\\n                if(tickets[i]==0){\\n                    continue;\\n                }\\n                time++;\\n                tickets[i] = tickets[i] - 1;\\n                if(tickets[k]==0){\\n                    break;\\n                }\\n            }\\n        }\\n        return time;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4037603,
                "title": "easy-solution-to-timerequiredtobuy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- I could move the elements position for each round\\n- I just need the seconds value\\n- How do I know when to stop iterating?\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSolution with JavaScript. Reduce each element by one until the `k`$$th$$ element is equal to cero.\\n\\n# Complexity\\n- Time complexity: ---\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} tickets\\n * @param {number} k\\n * @return {number}\\n */\\nvar timeRequiredToBuy = function (tickets, k) {\\n    let sec = 0;\\n    const ticketsLength = tickets.length;\\n    \\n    while (tickets[k]!==0) {\\n        for (let i = 0; i < ticketsLength; i++) {\\n            if (tickets[i] > 0) {\\n                tickets[i]--;\\n                sec++;\\n            }\\n            if(i===k) if(tickets[k]===0) break;\\n        }\\n    }\\n    return sec;\\n}; \\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} tickets\\n * @param {number} k\\n * @return {number}\\n */\\nvar timeRequiredToBuy = function (tickets, k) {\\n    let sec = 0;\\n    const ticketsLength = tickets.length;\\n    \\n    while (tickets[k]!==0) {\\n        for (let i = 0; i < ticketsLength; i++) {\\n            if (tickets[i] > 0) {\\n                tickets[i]--;\\n                sec++;\\n            }\\n            if(i===k) if(tickets[k]===0) break;\\n        }\\n    }\\n    return sec;\\n}; \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4036091,
                "title": "easy-solution-100",
                "content": "# Approach\\nLinear Search\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tic, int k) {\\n        int ans=0;\\n        for(int i=0;i<tic.size();i++)\\n        {\\n            if(tic[i]>tic[k])\\n            {\\n                ans+=tic[k];\\n            }\\n            else\\n            {\\n                ans+=tic[i];\\n            }\\n            if(tic[i]>=tic[k]&&i>k)\\n            {\\n                ans--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tic, int k) {\\n        int ans=0;\\n        for(int i=0;i<tic.size();i++)\\n        {\\n            if(tic[i]>tic[k])\\n            {\\n                ans+=tic[k];\\n            }\\n            else\\n            {\\n                ans+=tic[i];\\n            }\\n            if(tic[i]>=tic[k]&&i>k)\\n            {\\n                ans--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4033039,
                "title": "beats-100-runtime-and-100-memory",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n???\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\n# @param {Integer[]} tickets\\n# @param {Integer} k\\n# @return {Integer}\\ndef time_required_to_buy(tickets, k)\\n\\n    amount_of_tickets = tickets[k]\\n    track_location_of_k = k\\n    seconds = 0\\n    index = 0\\n    val = nil\\n    while tickets.size > 0  \\n        if 0 != k\\n            k = k - 1\\n        else\\n            if tickets[k] == 1\\n                return seconds + 1\\n            end\\n\\n            k = tickets.size - 1\\n        end\\n\\n        val = tickets.shift\\n        val = val - 1\\n\\n        if val != 0\\n            tickets << val\\n        end\\n\\n        seconds = seconds + 1\\n    end\\n\\n    seconds\\nend\\n\\n\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {Integer[]} tickets\\n# @param {Integer} k\\n# @return {Integer}\\ndef time_required_to_buy(tickets, k)\\n\\n    amount_of_tickets = tickets[k]\\n    track_location_of_k = k\\n    seconds = 0\\n    index = 0\\n    val = nil\\n    while tickets.size > 0  \\n        if 0 != k\\n            k = k - 1\\n        else\\n            if tickets[k] == 1\\n                return seconds + 1\\n            end\\n\\n            k = tickets.size - 1\\n        end\\n\\n        val = tickets.shift\\n        val = val - 1\\n\\n        if val != 0\\n            tickets << val\\n        end\\n\\n        seconds = seconds + 1\\n    end\\n\\n    seconds\\nend\\n\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4032185,
                "title": "c-o-n-deque-implementation-logic",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n     int time=0;\\n     deque<int>dq;\\n     //storing indexes of given array of tickets\\n     for(int i=0;i<tickets.size();i++){\\n         dq.push_back(i);\\n     }\\n     //k points to original array of tickets\\n     while(tickets[k]!=0){\\n         //selling ticket 1 at a time \\n         tickets[dq.front()]=tickets[dq.front()]-1;\\n         //increasing time by 1\\n         time++;\\n         //if person completes buying popping out its index from deque\\n         if(tickets[dq.front()]==0){\\n             dq.pop_front();\\n         }\\n         //pushing back that index to end of deque\\n         else{\\n             int temp=dq.front();\\n             dq.pop_front();\\n             dq.push_back(temp);\\n         }\\n     }\\n     return time;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n     int time=0;\\n     deque<int>dq;\\n     //storing indexes of given array of tickets\\n     for(int i=0;i<tickets.size();i++){\\n         dq.push_back(i);\\n     }\\n     //k points to original array of tickets\\n     while(tickets[k]!=0){\\n         //selling ticket 1 at a time \\n         tickets[dq.front()]=tickets[dq.front()]-1;\\n         //increasing time by 1\\n         time++;\\n         //if person completes buying popping out its index from deque\\n         if(tickets[dq.front()]==0){\\n             dq.pop_front();\\n         }\\n         //pushing back that index to end of deque\\n         else{\\n             int temp=dq.front();\\n             dq.pop_front();\\n             dq.push_back(temp);\\n         }\\n     }\\n     return time;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4022322,
                "title": "easy-o-n",
                "content": "\\n# Code\\n```\\n/**\\n * @param {number[]} tickets\\n * @param {number} k\\n * @return {number}\\n */\\nvar timeRequiredToBuy = function(tickets, k) {\\n    let max = tickets[k]\\n    let total = 0\\n    let rem = 0\\n\\n    for(let idx in tickets) {\\n        let ticket = tickets[idx]\\n        if(idx > k && ticket >= max) rem++\\n        total += Math.min(max, ticket)\\n    }\\n\\n    return total - rem\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} tickets\\n * @param {number} k\\n * @return {number}\\n */\\nvar timeRequiredToBuy = function(tickets, k) {\\n    let max = tickets[k]\\n    let total = 0\\n    let rem = 0\\n\\n    for(let idx in tickets) {\\n        let ticket = tickets[idx]\\n        if(idx > k && ticket >= max) rem++\\n        total += Math.min(max, ticket)\\n    }\\n\\n    return total - rem\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4008932,
                "title": "0ms-beats-100-00-of-users-with-java",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int count = 0;\\n\\n        for(int i=0;i<tickets.length;i++){\\n            if(tickets[i] >= tickets[k]){\\n                if(i>k){\\n                    count += tickets[k] - 1;\\n                }\\n                else{\\n                    count += tickets[k];\\n                }\\n            }\\n            else{\\n                count += tickets[i];\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int count = 0;\\n\\n        for(int i=0;i<tickets.length;i++){\\n            if(tickets[i] >= tickets[k]){\\n                if(i>k){\\n                    count += tickets[k] - 1;\\n                }\\n                else{\\n                    count += tickets[k];\\n                }\\n            }\\n            else{\\n                count += tickets[i];\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4008532,
                "title": "go",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc timeRequiredToBuy(tickets []int, k int) int {\\n\\n\\tc := 0\\n\\ti := 0\\n\\n\\tfor {\\n\\n\\t\\tif tickets[i] != 0 {\\n\\t\\t\\ttickets[i] -= 1\\n\\t\\t\\tc += 1\\n\\t\\t}\\n\\t\\tfmt.Println(c, i, tickets[i])\\n\\t\\tif i == k && tickets[k] == 0 {\\n\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\n\\t\\tif len(tickets)-1 == i {\\n\\t\\t\\ti = 0\\n\\t\\t} else {\\n\\t\\t\\ti++\\n\\t\\t}\\n\\n\\t}\\n\\n    return c\\n\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc timeRequiredToBuy(tickets []int, k int) int {\\n\\n\\tc := 0\\n\\ti := 0\\n\\n\\tfor {\\n\\n\\t\\tif tickets[i] != 0 {\\n\\t\\t\\ttickets[i] -= 1\\n\\t\\t\\tc += 1\\n\\t\\t}\\n\\t\\tfmt.Println(c, i, tickets[i])\\n\\t\\tif i == k && tickets[k] == 0 {\\n\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\n\\t\\tif len(tickets)-1 == i {\\n\\t\\t\\ti = 0\\n\\t\\t} else {\\n\\t\\t\\ti++\\n\\t\\t}\\n\\n\\t}\\n\\n    return c\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4002763,
                "title": "javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} tickets\\n * @param {number} k\\n * @return {number}\\n */\\nvar timeRequiredToBuy = function(tickets, k) {\\n  let queue = []\\n  let totalTime = 0;\\n  for(let i = 0; i < tickets.length; i++){\\n    queue.push({pos:i, no_of_tickets_needTo_buy: tickets[i]})\\n  }\\n  while(queue.length > 0){\\n    const person = queue.shift();\\n    if(person.no_of_tickets_needTo_buy > 0){\\n      person.no_of_tickets_needTo_buy --\\n      queue.push(person)\\n      totalTime ++\\n      if(person.pos === k && person.no_of_tickets_needTo_buy === 0) return totalTime;\\n    }\\n  }\\n  return totalTime\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} tickets\\n * @param {number} k\\n * @return {number}\\n */\\nvar timeRequiredToBuy = function(tickets, k) {\\n  let queue = []\\n  let totalTime = 0;\\n  for(let i = 0; i < tickets.length; i++){\\n    queue.push({pos:i, no_of_tickets_needTo_buy: tickets[i]})\\n  }\\n  while(queue.length > 0){\\n    const person = queue.shift();\\n    if(person.no_of_tickets_needTo_buy > 0){\\n      person.no_of_tickets_needTo_buy --\\n      queue.push(person)\\n      totalTime ++\\n      if(person.pos === k && person.no_of_tickets_needTo_buy === 0) return totalTime;\\n    }\\n  }\\n  return totalTime\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4002364,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int cnt = 0, a = 0;\\n\\n        while(tickets[k] != 0){\\n            if(a == tickets.size()){\\n                a = 0;\\n            }\\n            if(tickets[a] == 0){\\n                a++;\\n                continue;\\n            }\\n            tickets[a]--;\\n            cnt++;\\n            a++;\\n        }\\n\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int cnt = 0, a = 0;\\n\\n        while(tickets[k] != 0){\\n            if(a == tickets.size()){\\n                a = 0;\\n            }\\n            if(tickets[a] == 0){\\n                a++;\\n                continue;\\n            }\\n            tickets[a]--;\\n            cnt++;\\n            a++;\\n        }\\n\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4001871,
                "title": "c-solution-using-queue",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        queue<int> line;\\n        int n = tickets.size();\\n        int time = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            line.push(i);\\n        }\\n\\n        while (!line.empty()) {\\n            int current = line.front(); \\n            line.pop();\\n\\n            if (tickets[current] > 0) {\\n                tickets[current]--;\\n                time++;\\n\\n                if (current == k && tickets[k] == 0) {\\n                    break;\\n                }\\n\\n                line.push(current); \\n            }\\n        }\\n        return time;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        queue<int> line;\\n        int n = tickets.size();\\n        int time = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            line.push(i);\\n        }\\n\\n        while (!line.empty()) {\\n            int current = line.front(); \\n            line.pop();\\n\\n            if (tickets[current] > 0) {\\n                tickets[current]--;\\n                time++;\\n\\n                if (current == k && tickets[k] == 0) {\\n                    break;\\n                }\\n\\n                line.push(current); \\n            }\\n        }\\n        return time;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4001811,
                "title": "c-iterative-solve",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int n = tickets.size();\\n        vector<int> remain = tickets;\\n        int time = 0;\\n\\n        while (remain[k] > 0) {\\n            for (int i = 0; i < n; i++) {\\n                if (remain[i] > 0) {\\n                    remain[i]--;\\n                    time++;\\n\\n                    if (i==k && remain[i]==0) { \\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return time;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int n = tickets.size();\\n        vector<int> remain = tickets;\\n        int time = 0;\\n\\n        while (remain[k] > 0) {\\n            for (int i = 0; i < n; i++) {\\n                if (remain[i] > 0) {\\n                    remain[i]--;\\n                    time++;\\n\\n                    if (i==k && remain[i]==0) { \\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return time;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3998439,
                "title": "o-n-c-solution",
                "content": "# Complexity\\n- Time complexity:\\n***O(N)***\\n\\n- Space complexity:\\n**O(1)**\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& a, int k) {\\n        int cnt = 0;\\n        for(int i = 0;i<a.size();i++){\\n            if(i<=k)cnt+=min(a[i],a[k]);\\n            else cnt+=min(a[k]-1,a[i]);\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& a, int k) {\\n        int cnt = 0;\\n        for(int i = 0;i<a.size();i++){\\n            if(i<=k)cnt+=min(a[i],a[k]);\\n            else cnt+=min(a[k]-1,a[i]);\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3998421,
                "title": "100-easy-c-solution-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& a, int k) {\\n        int cnt = 0;\\n        while(a[k]){\\n            for(int i = 0;i<a.size();i++){\\n                if(a[i])a[i]--,cnt++;\\n                if(!a[k])break;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& a, int k) {\\n        int cnt = 0;\\n        while(a[k]){\\n            for(int i = 0;i<a.size();i++){\\n                if(a[i])a[i]--,cnt++;\\n                if(!a[k])break;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3995977,
                "title": "easy-o-1-solution-without-queue",
                "content": "# Intuition\\nnothing XD\\n\\n# Approach\\niterate over array and keep track \\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int i=0;\\n        int sec=0;\\n        while(tickets[k]>0){\\n\\n            if(tickets[i]>0){\\n                tickets[i] = tickets[i]-1;\\n                i = (i+1)%tickets.length;\\n                sec++;\\n            }else{\\n                i = (i+1)%tickets.length;\\n            }\\n        }\\n\\n        return sec;\\n        \\n\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int i=0;\\n        int sec=0;\\n        while(tickets[k]>0){\\n\\n            if(tickets[i]>0){\\n                tickets[i] = tickets[i]-1;\\n                i = (i+1)%tickets.length;\\n                sec++;\\n            }else{\\n                i = (i+1)%tickets.length;\\n            }\\n        }\\n\\n        return sec;\\n        \\n\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3985951,
                "title": "simple-c-100-fast",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& t, int k) {\\n        int ans=0;\\n        while(t[k]!=0){\\n            for(int i=0;i<t.size();i++){\\n                if(t[i]>0){\\n                    t[i]=t[i]-1;\\n                    ans++;\\n                }\\n                if(t[k]==0)break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& t, int k) {\\n        int ans=0;\\n        while(t[k]!=0){\\n            for(int i=0;i<t.size();i++){\\n                if(t[i]>0){\\n                    t[i]=t[i]-1;\\n                    ans++;\\n                }\\n                if(t[k]==0)break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3984228,
                "title": "simple-c-approach",
                "content": "\\n# Complexity\\n- Time complexity:\\nLinear Time complexity\\n\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int time=0;\\n        int i=0;\\n        int n=tickets.size();\\n        while(tickets[k]!=0){\\n            if(tickets[i%n]!=0){\\n                tickets[i%n]--;\\n                time++;\\n                i++;\\n            }\\n            else{\\n                i++;\\n            }\\n        }\\n        return time;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int time=0;\\n        int i=0;\\n        int n=tickets.size();\\n        while(tickets[k]!=0){\\n            if(tickets[i%n]!=0){\\n                tickets[i%n]--;\\n                time++;\\n                i++;\\n            }\\n            else{\\n                i++;\\n            }\\n        }\\n        return time;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3980174,
                "title": "nice-and-elegant-solution-in-java-beats-100-rt-and-98-memory",
                "content": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int count = 0;\\n        int n = tickets[k];\\n        while (n > 0) {\\n            for (int i = 0; i < tickets.length; i++) {\\n                if (tickets[i]-- > 0) {\\n                    count++;\\n                    if (i == k) {\\n                        n--;\\n                    }\\n                    if (tickets[k] == 0) {\\n                        return count;\\n                    }\\n                }\\n            }\\n        }\\n        return count;        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int count = 0;\\n        int n = tickets[k];\\n        while (n > 0) {\\n            for (int i = 0; i < tickets.length; i++) {\\n                if (tickets[i]-- > 0) {\\n                    count++;\\n                    if (i == k) {\\n                        n--;\\n                    }\\n                    if (tickets[k] == 0) {\\n                        return count;\\n                    }\\n                }\\n            }\\n        }\\n        return count;        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3980063,
                "title": "java-easy-o-n-100-beats-full-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nLet\\'s assume there are n person standing in the queue a\\na1, a2, a3, ... ak ... an\\ni\\'th person will buy ai number of tickets. \\n\\nObservations\\nFor any person standing at the j\\'th position in the queue such that \\nj <= k, \\nthe one thing is sure, that person will make the k\\'th person to wait by min(aj, ak)\\n\\nand if \\nj > k\\nthen the j\\'th person will make the k\\'th person to wait longer by min(aj, ak-1)\\n\\nUsing the above two observations, we can write an algorithm with O(N) Time Complexity\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        // O(N) solution\\n        int time = 0; \\n        for ( int i=0; i < tickets.length; i++){\\n            if ( i <= k){\\n                time += ( tickets[i] <= tickets[k])?tickets[i]:tickets[k];\\n            }\\n            else{\\n                time += (tickets[i] < tickets[k])?tickets[i]: (tickets[k]-1);\\n            }\\n        }\\n        return time;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        // O(N) solution\\n        int time = 0; \\n        for ( int i=0; i < tickets.length; i++){\\n            if ( i <= k){\\n                time += ( tickets[i] <= tickets[k])?tickets[i]:tickets[k];\\n            }\\n            else{\\n                time += (tickets[i] < tickets[k])?tickets[i]: (tickets[k]-1);\\n            }\\n        }\\n        return time;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3971374,
                "title": "js-time-o-n-space-o-1-single-for-loop",
                "content": "# Intuition & Approach\\nCycle the array, if tickets at i is greater than or equal to tickets at k you add to seconds the value of tickets at k, otherwise (if the number is smaller) you add tickets at k.\\nif the number at k is larger then the number at i and it is positioned after k so that i > k, you need to subtract 1 for each occourrence (we need to stop when tickets[k] reaches 0, so we dont need to count iterations afterwards)\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} tickets\\n * @param {number} k\\n * @return {number}\\n */\\nvar timeRequiredToBuy = function(tickets, k) {\\n    let seconds = 0\\n    for(let i = 0; i < tickets.length; i++){\\n        if(tickets[i] >= tickets[k]){\\n            seconds += tickets[k]\\n            if(i > k) {\\n                seconds -= 1\\n            }\\n        } else {\\n            seconds += tickets[i]\\n        }\\n    }\\n    return seconds\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} tickets\\n * @param {number} k\\n * @return {number}\\n */\\nvar timeRequiredToBuy = function(tickets, k) {\\n    let seconds = 0\\n    for(let i = 0; i < tickets.length; i++){\\n        if(tickets[i] >= tickets[k]){\\n            seconds += tickets[k]\\n            if(i > k) {\\n                seconds -= 1\\n            }\\n        } else {\\n            seconds += tickets[i]\\n        }\\n    }\\n    return seconds\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3966793,
                "title": "with-basic-python-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        count=0\\n        while True:\\n            for i in range(len(tickets)):\\n                if tickets[i]>0:\\n                    tickets[i]-=1\\n                    count+=1\\n                if tickets[k]==0:\\n                    return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        count=0\\n        while True:\\n            for i in range(len(tickets)):\\n                if tickets[i]>0:\\n                    tickets[i]-=1\\n                    count+=1\\n                if tickets[k]==0:\\n                    return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3963719,
                "title": "easy-to-understand-python3-solution-tc-m-o-n-sc-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        count = 0\\n\\n        check = tickets[k]\\n\\n        while check != 0:\\n            for i in range(len(tickets)):\\n                if tickets[i] > 0:\\n                    if tickets[k] == 0:\\n                        break\\n                    count += 1\\n                    tickets[i] -= 1\\n            check = tickets[k]\\n            \\n        return count\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        count = 0\\n\\n        check = tickets[k]\\n\\n        while check != 0:\\n            for i in range(len(tickets)):\\n                if tickets[i] > 0:\\n                    if tickets[k] == 0:\\n                        break\\n                    count += 1\\n                    tickets[i] -= 1\\n            check = tickets[k]\\n            \\n        return count\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3956695,
                "title": "python-one-liner",
                "content": "# Approach\\n- the ticket less than the kth customer must spend all their time\\nsum(i for i in tickets if i <= tickets[k])\\n- the ticket more than the kth customer must spend the time equal to the kth customer\\nlen([i for i in tickets if i > tickets[k]])*tickets[k]\\n- the ticket more than the kth customer but after the kth customer need to minus one seconds beacuse when the kth customer finished, the program finished\\nlen([i for i in tickets[k+1:] if i >= tickets[k]])\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        return sum(i for i in tickets if i <= tickets[k]) + len([i for i in tickets if i > tickets[k]])*tickets[k] - len([i for i in tickets[k+1:] if i >= tickets[k]])\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        return sum(i for i in tickets if i <= tickets[k]) + len([i for i in tickets if i > tickets[k]])*tickets[k] - len([i for i in tickets[k+1:] if i >= tickets[k]])\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1628030,
                "content": [
                    {
                        "username": "tejartr445",
                        "content": "I feel this version of leetcode is not as good as old one, yeah this has many good features like it added timer and it have gave few other new features but the solutions sections and discuss sections aren\\'t that good as they were before "
                    },
                    {
                        "username": "Yash2k04",
                        "content": "and it\\'s also not support chrome extension leethub, prevoiusly all the solutions are also upload to github as well. its pretty helpful but missing in this new update. "
                    },
                    {
                        "username": "CristianM92",
                        "content": "Agree!"
                    },
                    {
                        "username": "Ankur_028",
                        "content": "just use queue data structure ! and push the indexes in it. and increase the time count after every iteration."
                    },
                    {
                        "username": "bparanj",
                        "content": "This tip is worth 100 upvotes. Amazing!!!"
                    },
                    {
                        "username": "hancu345",
                        "content": "The most important thing to solve this problem is to take into consideration the fact that all people behind K-th person, which have more tickets to buy than K-th person, can only buy k-1 tickets. For example: if the person behind K-th person wants to buy 73 tickets, and k-th person wants to but 24, if you simulate this queue in real life you will see that at the 24th pass, the k-th person will buy the 24th ticket, but the person behind won\\'t buy the 24th ticket because k-th person has already finished buying his tickets.\\n"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "this question was asked by uber"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "use Deque!"
                    },
                    {
                        "username": "Revati_Shimpi",
                        "content": "class Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int count=0,i=0;\\n        while(tickets[k]!=0){ //UNTIL tickets at k =0\\n            for(i=0;i<tickets.length;i++){ //TRAVERSES THE WHOLE ARRAY AND REDUCES TICKET COUNT BY 1\\n            if(tickets[i]!=0){\\n                count++;\\n                tickets[i]--;\\n            }\\n         }\\n    }\\n    return count; //AS SOON AS TICKETS AT K=0 RETURNS THE COUNT i.e. The time at which it is over\\n    }\\n} \\nWhere is my code wrong logically?"
                    },
                    {
                        "username": "suyash_5050",
                        "content": "when your k element in array becomes 0 then to it is decreasing further element in the array always make sure to stop traversing immediate after tickets[k] == 0 !!\\n*** Just add one if condition ***\\n\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n\\n        int time = 0;\\n        \\n        while(tickets[k] != 0){\\n\\n            for(int i=0; i<tickets.size(); i++){\\n\\n                if(tickets[i] > 0){\\n                    tickets[i]--;\\n                    time++;\\n                }\\n                if(tickets[k] == 0){\\n                    break;\\n                }\\n                \\n            }\\n        }\\n        return time;\\n    }\\n};"
                    },
                    {
                        "username": "Bek_Shoyatbekov",
                        "content": "Is it correct  problem? "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "yes\\n"
                    }
                ]
            },
            {
                "id": 1928915,
                "content": [
                    {
                        "username": "tejartr445",
                        "content": "I feel this version of leetcode is not as good as old one, yeah this has many good features like it added timer and it have gave few other new features but the solutions sections and discuss sections aren\\'t that good as they were before "
                    },
                    {
                        "username": "Yash2k04",
                        "content": "and it\\'s also not support chrome extension leethub, prevoiusly all the solutions are also upload to github as well. its pretty helpful but missing in this new update. "
                    },
                    {
                        "username": "CristianM92",
                        "content": "Agree!"
                    },
                    {
                        "username": "Ankur_028",
                        "content": "just use queue data structure ! and push the indexes in it. and increase the time count after every iteration."
                    },
                    {
                        "username": "bparanj",
                        "content": "This tip is worth 100 upvotes. Amazing!!!"
                    },
                    {
                        "username": "hancu345",
                        "content": "The most important thing to solve this problem is to take into consideration the fact that all people behind K-th person, which have more tickets to buy than K-th person, can only buy k-1 tickets. For example: if the person behind K-th person wants to buy 73 tickets, and k-th person wants to but 24, if you simulate this queue in real life you will see that at the 24th pass, the k-th person will buy the 24th ticket, but the person behind won\\'t buy the 24th ticket because k-th person has already finished buying his tickets.\\n"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "this question was asked by uber"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "use Deque!"
                    },
                    {
                        "username": "Revati_Shimpi",
                        "content": "class Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int count=0,i=0;\\n        while(tickets[k]!=0){ //UNTIL tickets at k =0\\n            for(i=0;i<tickets.length;i++){ //TRAVERSES THE WHOLE ARRAY AND REDUCES TICKET COUNT BY 1\\n            if(tickets[i]!=0){\\n                count++;\\n                tickets[i]--;\\n            }\\n         }\\n    }\\n    return count; //AS SOON AS TICKETS AT K=0 RETURNS THE COUNT i.e. The time at which it is over\\n    }\\n} \\nWhere is my code wrong logically?"
                    },
                    {
                        "username": "suyash_5050",
                        "content": "when your k element in array becomes 0 then to it is decreasing further element in the array always make sure to stop traversing immediate after tickets[k] == 0 !!\\n*** Just add one if condition ***\\n\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n\\n        int time = 0;\\n        \\n        while(tickets[k] != 0){\\n\\n            for(int i=0; i<tickets.size(); i++){\\n\\n                if(tickets[i] > 0){\\n                    tickets[i]--;\\n                    time++;\\n                }\\n                if(tickets[k] == 0){\\n                    break;\\n                }\\n                \\n            }\\n        }\\n        return time;\\n    }\\n};"
                    },
                    {
                        "username": "Bek_Shoyatbekov",
                        "content": "Is it correct  problem? "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "yes\\n"
                    }
                ]
            },
            {
                "id": 1930154,
                "content": [
                    {
                        "username": "tejartr445",
                        "content": "I feel this version of leetcode is not as good as old one, yeah this has many good features like it added timer and it have gave few other new features but the solutions sections and discuss sections aren\\'t that good as they were before "
                    },
                    {
                        "username": "Yash2k04",
                        "content": "and it\\'s also not support chrome extension leethub, prevoiusly all the solutions are also upload to github as well. its pretty helpful but missing in this new update. "
                    },
                    {
                        "username": "CristianM92",
                        "content": "Agree!"
                    },
                    {
                        "username": "Ankur_028",
                        "content": "just use queue data structure ! and push the indexes in it. and increase the time count after every iteration."
                    },
                    {
                        "username": "bparanj",
                        "content": "This tip is worth 100 upvotes. Amazing!!!"
                    },
                    {
                        "username": "hancu345",
                        "content": "The most important thing to solve this problem is to take into consideration the fact that all people behind K-th person, which have more tickets to buy than K-th person, can only buy k-1 tickets. For example: if the person behind K-th person wants to buy 73 tickets, and k-th person wants to but 24, if you simulate this queue in real life you will see that at the 24th pass, the k-th person will buy the 24th ticket, but the person behind won\\'t buy the 24th ticket because k-th person has already finished buying his tickets.\\n"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "this question was asked by uber"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "use Deque!"
                    },
                    {
                        "username": "Revati_Shimpi",
                        "content": "class Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int count=0,i=0;\\n        while(tickets[k]!=0){ //UNTIL tickets at k =0\\n            for(i=0;i<tickets.length;i++){ //TRAVERSES THE WHOLE ARRAY AND REDUCES TICKET COUNT BY 1\\n            if(tickets[i]!=0){\\n                count++;\\n                tickets[i]--;\\n            }\\n         }\\n    }\\n    return count; //AS SOON AS TICKETS AT K=0 RETURNS THE COUNT i.e. The time at which it is over\\n    }\\n} \\nWhere is my code wrong logically?"
                    },
                    {
                        "username": "suyash_5050",
                        "content": "when your k element in array becomes 0 then to it is decreasing further element in the array always make sure to stop traversing immediate after tickets[k] == 0 !!\\n*** Just add one if condition ***\\n\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n\\n        int time = 0;\\n        \\n        while(tickets[k] != 0){\\n\\n            for(int i=0; i<tickets.size(); i++){\\n\\n                if(tickets[i] > 0){\\n                    tickets[i]--;\\n                    time++;\\n                }\\n                if(tickets[k] == 0){\\n                    break;\\n                }\\n                \\n            }\\n        }\\n        return time;\\n    }\\n};"
                    },
                    {
                        "username": "Bek_Shoyatbekov",
                        "content": "Is it correct  problem? "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "yes\\n"
                    }
                ]
            },
            {
                "id": 2010067,
                "content": [
                    {
                        "username": "tejartr445",
                        "content": "I feel this version of leetcode is not as good as old one, yeah this has many good features like it added timer and it have gave few other new features but the solutions sections and discuss sections aren\\'t that good as they were before "
                    },
                    {
                        "username": "Yash2k04",
                        "content": "and it\\'s also not support chrome extension leethub, prevoiusly all the solutions are also upload to github as well. its pretty helpful but missing in this new update. "
                    },
                    {
                        "username": "CristianM92",
                        "content": "Agree!"
                    },
                    {
                        "username": "Ankur_028",
                        "content": "just use queue data structure ! and push the indexes in it. and increase the time count after every iteration."
                    },
                    {
                        "username": "bparanj",
                        "content": "This tip is worth 100 upvotes. Amazing!!!"
                    },
                    {
                        "username": "hancu345",
                        "content": "The most important thing to solve this problem is to take into consideration the fact that all people behind K-th person, which have more tickets to buy than K-th person, can only buy k-1 tickets. For example: if the person behind K-th person wants to buy 73 tickets, and k-th person wants to but 24, if you simulate this queue in real life you will see that at the 24th pass, the k-th person will buy the 24th ticket, but the person behind won\\'t buy the 24th ticket because k-th person has already finished buying his tickets.\\n"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "this question was asked by uber"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "use Deque!"
                    },
                    {
                        "username": "Revati_Shimpi",
                        "content": "class Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int count=0,i=0;\\n        while(tickets[k]!=0){ //UNTIL tickets at k =0\\n            for(i=0;i<tickets.length;i++){ //TRAVERSES THE WHOLE ARRAY AND REDUCES TICKET COUNT BY 1\\n            if(tickets[i]!=0){\\n                count++;\\n                tickets[i]--;\\n            }\\n         }\\n    }\\n    return count; //AS SOON AS TICKETS AT K=0 RETURNS THE COUNT i.e. The time at which it is over\\n    }\\n} \\nWhere is my code wrong logically?"
                    },
                    {
                        "username": "suyash_5050",
                        "content": "when your k element in array becomes 0 then to it is decreasing further element in the array always make sure to stop traversing immediate after tickets[k] == 0 !!\\n*** Just add one if condition ***\\n\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n\\n        int time = 0;\\n        \\n        while(tickets[k] != 0){\\n\\n            for(int i=0; i<tickets.size(); i++){\\n\\n                if(tickets[i] > 0){\\n                    tickets[i]--;\\n                    time++;\\n                }\\n                if(tickets[k] == 0){\\n                    break;\\n                }\\n                \\n            }\\n        }\\n        return time;\\n    }\\n};"
                    },
                    {
                        "username": "Bek_Shoyatbekov",
                        "content": "Is it correct  problem? "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "yes\\n"
                    }
                ]
            },
            {
                "id": 2010064,
                "content": [
                    {
                        "username": "tejartr445",
                        "content": "I feel this version of leetcode is not as good as old one, yeah this has many good features like it added timer and it have gave few other new features but the solutions sections and discuss sections aren\\'t that good as they were before "
                    },
                    {
                        "username": "Yash2k04",
                        "content": "and it\\'s also not support chrome extension leethub, prevoiusly all the solutions are also upload to github as well. its pretty helpful but missing in this new update. "
                    },
                    {
                        "username": "CristianM92",
                        "content": "Agree!"
                    },
                    {
                        "username": "Ankur_028",
                        "content": "just use queue data structure ! and push the indexes in it. and increase the time count after every iteration."
                    },
                    {
                        "username": "bparanj",
                        "content": "This tip is worth 100 upvotes. Amazing!!!"
                    },
                    {
                        "username": "hancu345",
                        "content": "The most important thing to solve this problem is to take into consideration the fact that all people behind K-th person, which have more tickets to buy than K-th person, can only buy k-1 tickets. For example: if the person behind K-th person wants to buy 73 tickets, and k-th person wants to but 24, if you simulate this queue in real life you will see that at the 24th pass, the k-th person will buy the 24th ticket, but the person behind won\\'t buy the 24th ticket because k-th person has already finished buying his tickets.\\n"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "this question was asked by uber"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "use Deque!"
                    },
                    {
                        "username": "Revati_Shimpi",
                        "content": "class Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int count=0,i=0;\\n        while(tickets[k]!=0){ //UNTIL tickets at k =0\\n            for(i=0;i<tickets.length;i++){ //TRAVERSES THE WHOLE ARRAY AND REDUCES TICKET COUNT BY 1\\n            if(tickets[i]!=0){\\n                count++;\\n                tickets[i]--;\\n            }\\n         }\\n    }\\n    return count; //AS SOON AS TICKETS AT K=0 RETURNS THE COUNT i.e. The time at which it is over\\n    }\\n} \\nWhere is my code wrong logically?"
                    },
                    {
                        "username": "suyash_5050",
                        "content": "when your k element in array becomes 0 then to it is decreasing further element in the array always make sure to stop traversing immediate after tickets[k] == 0 !!\\n*** Just add one if condition ***\\n\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n\\n        int time = 0;\\n        \\n        while(tickets[k] != 0){\\n\\n            for(int i=0; i<tickets.size(); i++){\\n\\n                if(tickets[i] > 0){\\n                    tickets[i]--;\\n                    time++;\\n                }\\n                if(tickets[k] == 0){\\n                    break;\\n                }\\n                \\n            }\\n        }\\n        return time;\\n    }\\n};"
                    },
                    {
                        "username": "Bek_Shoyatbekov",
                        "content": "Is it correct  problem? "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "yes\\n"
                    }
                ]
            },
            {
                "id": 1969342,
                "content": [
                    {
                        "username": "tejartr445",
                        "content": "I feel this version of leetcode is not as good as old one, yeah this has many good features like it added timer and it have gave few other new features but the solutions sections and discuss sections aren\\'t that good as they were before "
                    },
                    {
                        "username": "Yash2k04",
                        "content": "and it\\'s also not support chrome extension leethub, prevoiusly all the solutions are also upload to github as well. its pretty helpful but missing in this new update. "
                    },
                    {
                        "username": "CristianM92",
                        "content": "Agree!"
                    },
                    {
                        "username": "Ankur_028",
                        "content": "just use queue data structure ! and push the indexes in it. and increase the time count after every iteration."
                    },
                    {
                        "username": "bparanj",
                        "content": "This tip is worth 100 upvotes. Amazing!!!"
                    },
                    {
                        "username": "hancu345",
                        "content": "The most important thing to solve this problem is to take into consideration the fact that all people behind K-th person, which have more tickets to buy than K-th person, can only buy k-1 tickets. For example: if the person behind K-th person wants to buy 73 tickets, and k-th person wants to but 24, if you simulate this queue in real life you will see that at the 24th pass, the k-th person will buy the 24th ticket, but the person behind won\\'t buy the 24th ticket because k-th person has already finished buying his tickets.\\n"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "this question was asked by uber"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "use Deque!"
                    },
                    {
                        "username": "Revati_Shimpi",
                        "content": "class Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int count=0,i=0;\\n        while(tickets[k]!=0){ //UNTIL tickets at k =0\\n            for(i=0;i<tickets.length;i++){ //TRAVERSES THE WHOLE ARRAY AND REDUCES TICKET COUNT BY 1\\n            if(tickets[i]!=0){\\n                count++;\\n                tickets[i]--;\\n            }\\n         }\\n    }\\n    return count; //AS SOON AS TICKETS AT K=0 RETURNS THE COUNT i.e. The time at which it is over\\n    }\\n} \\nWhere is my code wrong logically?"
                    },
                    {
                        "username": "suyash_5050",
                        "content": "when your k element in array becomes 0 then to it is decreasing further element in the array always make sure to stop traversing immediate after tickets[k] == 0 !!\\n*** Just add one if condition ***\\n\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n\\n        int time = 0;\\n        \\n        while(tickets[k] != 0){\\n\\n            for(int i=0; i<tickets.size(); i++){\\n\\n                if(tickets[i] > 0){\\n                    tickets[i]--;\\n                    time++;\\n                }\\n                if(tickets[k] == 0){\\n                    break;\\n                }\\n                \\n            }\\n        }\\n        return time;\\n    }\\n};"
                    },
                    {
                        "username": "Bek_Shoyatbekov",
                        "content": "Is it correct  problem? "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "yes\\n"
                    }
                ]
            },
            {
                "id": 1919927,
                "content": [
                    {
                        "username": "tejartr445",
                        "content": "I feel this version of leetcode is not as good as old one, yeah this has many good features like it added timer and it have gave few other new features but the solutions sections and discuss sections aren\\'t that good as they were before "
                    },
                    {
                        "username": "Yash2k04",
                        "content": "and it\\'s also not support chrome extension leethub, prevoiusly all the solutions are also upload to github as well. its pretty helpful but missing in this new update. "
                    },
                    {
                        "username": "CristianM92",
                        "content": "Agree!"
                    },
                    {
                        "username": "Ankur_028",
                        "content": "just use queue data structure ! and push the indexes in it. and increase the time count after every iteration."
                    },
                    {
                        "username": "bparanj",
                        "content": "This tip is worth 100 upvotes. Amazing!!!"
                    },
                    {
                        "username": "hancu345",
                        "content": "The most important thing to solve this problem is to take into consideration the fact that all people behind K-th person, which have more tickets to buy than K-th person, can only buy k-1 tickets. For example: if the person behind K-th person wants to buy 73 tickets, and k-th person wants to but 24, if you simulate this queue in real life you will see that at the 24th pass, the k-th person will buy the 24th ticket, but the person behind won\\'t buy the 24th ticket because k-th person has already finished buying his tickets.\\n"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "this question was asked by uber"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "use Deque!"
                    },
                    {
                        "username": "Revati_Shimpi",
                        "content": "class Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int count=0,i=0;\\n        while(tickets[k]!=0){ //UNTIL tickets at k =0\\n            for(i=0;i<tickets.length;i++){ //TRAVERSES THE WHOLE ARRAY AND REDUCES TICKET COUNT BY 1\\n            if(tickets[i]!=0){\\n                count++;\\n                tickets[i]--;\\n            }\\n         }\\n    }\\n    return count; //AS SOON AS TICKETS AT K=0 RETURNS THE COUNT i.e. The time at which it is over\\n    }\\n} \\nWhere is my code wrong logically?"
                    },
                    {
                        "username": "suyash_5050",
                        "content": "when your k element in array becomes 0 then to it is decreasing further element in the array always make sure to stop traversing immediate after tickets[k] == 0 !!\\n*** Just add one if condition ***\\n\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n\\n        int time = 0;\\n        \\n        while(tickets[k] != 0){\\n\\n            for(int i=0; i<tickets.size(); i++){\\n\\n                if(tickets[i] > 0){\\n                    tickets[i]--;\\n                    time++;\\n                }\\n                if(tickets[k] == 0){\\n                    break;\\n                }\\n                \\n            }\\n        }\\n        return time;\\n    }\\n};"
                    },
                    {
                        "username": "Bek_Shoyatbekov",
                        "content": "Is it correct  problem? "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "yes\\n"
                    }
                ]
            }
        ]
    },
    {
        "title": "Reverse Nodes in Even Length Groups",
        "question_content": "<p>You are given the <code>head</code> of a linked list.</p>\n\n<p>The nodes in the linked list are <strong>sequentially</strong> assigned to <strong>non-empty</strong> groups whose lengths form the sequence of the natural numbers (<code>1, 2, 3, 4, ...</code>). The <strong>length</strong> of a group is the number of nodes assigned to it. In other words,</p>\n\n<ul>\n\t<li>The <code>1<sup>st</sup></code> node is assigned to the first group.</li>\n\t<li>The <code>2<sup>nd</sup></code> and the <code>3<sup>rd</sup></code> nodes are assigned to the second group.</li>\n\t<li>The <code>4<sup>th</sup></code>, <code>5<sup>th</sup></code>, and <code>6<sup>th</sup></code> nodes are assigned to the third group, and so on.</li>\n</ul>\n\n<p>Note that the length of the last group may be less than or equal to <code>1 + the length of the second to last group</code>.</p>\n\n<p><strong>Reverse</strong> the nodes in each group with an <strong>even</strong> length, and return <em>the</em> <code>head</code> <em>of the modified linked list</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/10/25/eg1.png\" style=\"width: 699px; height: 124px;\" />\n<pre>\n<strong>Input:</strong> head = [5,2,6,3,9,1,7,3,8,4]\n<strong>Output:</strong> [5,6,2,3,9,1,4,8,3,7]\n<strong>Explanation:</strong>\n- The length of the first group is 1, which is odd, hence no reversal occurs.\n- The length of the second group is 2, which is even, hence the nodes are reversed.\n- The length of the third group is 3, which is odd, hence no reversal occurs.\n- The length of the last group is 4, which is even, hence the nodes are reversed.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/10/25/eg2.png\" style=\"width: 284px; height: 114px;\" />\n<pre>\n<strong>Input:</strong> head = [1,1,0,6]\n<strong>Output:</strong> [1,0,1,6]\n<strong>Explanation:</strong>\n- The length of the first group is 1. No reversal occurs.\n- The length of the second group is 2. The nodes are reversed.\n- The length of the last group is 1. No reversal occurs.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/11/17/ex3.png\" style=\"width: 348px; height: 114px;\" />\n<pre>\n<strong>Input:</strong> head = [1,1,0,6,5]\n<strong>Output:</strong> [1,0,1,5,6]\n<strong>Explanation:</strong>\n- The length of the first group is 1. No reversal occurs.\n- The length of the second group is 2. The nodes are reversed.\n- The length of the last group is 2. The nodes are reversed.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the list is in the range <code>[1, 10<sup>5</sup>]</code>.</li>\n\t<li><code>0 &lt;= Node.val &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 1576952,
                "title": "c-well-commented-clear-code-idea-explained-in-brief",
                "content": "\\n\\n**Idea**\\n* I traverse the list in groups where the sizes are in the increasing order of natural numbers. \\n* Whenever a group with even length is encountered, that group is reversed using the reverse function and I proceed with processing the next group. \\n* The solution involves several pointers which track the current group\\u2019s head, tail and the next group\\u2019s head. \\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    \\n    // Function to reverse a linked list\\n    ListNode* reverseList(ListNode* head) {\\n        if(!head)\\n            return head;\\n        ListNode* prev = NULL;\\n        while(head) {\\n            ListNode* temp = head -> next;\\n            head -> next = prev;\\n            prev = head;\\n            head = temp;\\n        }\\n        \\n        return prev;\\n    }\\n    \\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        // Creating a dummy node to avoid adding checks for the first node\\n        ListNode* dummy = new ListNode();\\n        dummy -> next = head;\\n        \\n        ListNode* prev = dummy;\\n        \\n        // Loop to determine the lengths of groups\\n        for(int len = 1; len < 1e5 && head; len++) {\\n            ListNode* tail = head;\\n            ListNode* nextHead;\\n            \\n            // Determining the length of the current group\\n            // Its maximum length can be equal to len\\n            int j = 1;\\n            while(j < len && tail && tail -> next) {\\n                tail = tail -> next;\\n                j++;\\n            }\\n            \\n            // Head of the next group\\n            nextHead = tail -> next;\\n            \\n            if((j % 2) == 0) {\\n                // If even sized group is found\\n                // Reversing the group and setting prev and head appropriately\\n                tail -> next = NULL;\\n                prev -> next = reverseList(head);\\n                prev = head;\\n                head -> next = nextHead;\\n                head = nextHead;\\n            } else {\\n                // If group is odd sized, then simply going towards the next group\\n                prev = tail;\\n                head = nextHead;\\n            }\\n        }\\n        \\n        // Returning the head\\n        return dummy -> next;\\n    }\\n};\\n```\\n\\n**Complexity Analysis**\\n*Space Complexity: O(1)*\\n*Time Complexity: O(n)*",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // Function to reverse a linked list\\n    ListNode* reverseList(ListNode* head) {\\n        if(!head)\\n            return head;\\n        ListNode* prev = NULL;\\n        while(head) {\\n            ListNode* temp = head -> next;\\n            head -> next = prev;\\n            prev = head;\\n            head = temp;\\n        }\\n        \\n        return prev;\\n    }\\n    \\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        // Creating a dummy node to avoid adding checks for the first node\\n        ListNode* dummy = new ListNode();\\n        dummy -> next = head;\\n        \\n        ListNode* prev = dummy;\\n        \\n        // Loop to determine the lengths of groups\\n        for(int len = 1; len < 1e5 && head; len++) {\\n            ListNode* tail = head;\\n            ListNode* nextHead;\\n            \\n            // Determining the length of the current group\\n            // Its maximum length can be equal to len\\n            int j = 1;\\n            while(j < len && tail && tail -> next) {\\n                tail = tail -> next;\\n                j++;\\n            }\\n            \\n            // Head of the next group\\n            nextHead = tail -> next;\\n            \\n            if((j % 2) == 0) {\\n                // If even sized group is found\\n                // Reversing the group and setting prev and head appropriately\\n                tail -> next = NULL;\\n                prev -> next = reverseList(head);\\n                prev = head;\\n                head -> next = nextHead;\\n                head = nextHead;\\n            } else {\\n                // If group is odd sized, then simply going towards the next group\\n                prev = tail;\\n                head = nextHead;\\n            }\\n        }\\n        \\n        // Returning the head\\n        return dummy -> next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1576911,
                "title": "java-two-pointers-stack",
                "content": "**Idea :** \\n1. \\ttemp is pointing end of a particular group\\n1. \\tstart is pointing starting of a particular group\\n1. \\twhile traversing put node\\'s values in stack (LIFO)\\n1. \\twhen the count of nodes in a group is == to the count of nodes required for that group and is even \\nthen move start pointer ahead and update values of nodes in that group.\\n```\\nclass Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        int groupRequired = 1;\\n        ListNode temp = head;\\n        while(temp != null){\\n            int count = 0;\\n            ListNode start = temp;\\n            Stack<Integer> stack = new Stack<>();\\n            while(count != groupRequired && temp != null){\\n                stack.push(temp.val);\\n                temp = temp.next;\\n                count++;\\n            }\\n            if(count % 2 == 0) {\\n                while(start != temp){\\n                    start.val = stack.pop();\\n                    start = start.next;\\n                }\\n            }\\n            groupRequired++;\\n        }\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        int groupRequired = 1;\\n        ListNode temp = head;\\n        while(temp != null){\\n            int count = 0;\\n            ListNode start = temp;\\n            Stack<Integer> stack = new Stack<>();\\n            while(count != groupRequired && temp != null){\\n                stack.push(temp.val);\\n                temp = temp.next;\\n                count++;\\n            }\\n            if(count % 2 == 0) {\\n                while(start != temp){\\n                    start.val = stack.pop();\\n                    start = start.next;\\n                }\\n            }\\n            groupRequired++;\\n        }\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1577032,
                "title": "python-reverse-linked-list-o-1-space",
                "content": "Similiar to [25. Reverse Nodes in k-Group](https://leetcode.com/problems/reverse-nodes-in-k-group/), reverse a range of linked list when the range has an even length\\n```\\ndef reverseEvenLengthGroups(head):\\n\\tprev = head\\n\\td = 2 # the head doesn\\'t need to be reversed anytime so starts with length 2\\n\\twhile prev.next:\\n\\t\\tnode, n = prev, 0\\n\\t\\tfor _ in range(d):\\n\\t\\t\\tif not node.next:\\n\\t\\t\\t\\tbreak\\n\\t\\t\\tn += 1\\n\\t\\t\\tnode = node.next\\n\\t\\tif n & 1:  # odd length\\n\\t\\t\\tprev = node\\n\\t\\telse:      # even length\\n\\t\\t\\tnode, rev = prev.next, None\\n\\t\\t\\tfor _ in range(n):\\n\\t\\t\\t\\tnode.next, node, rev = rev, node.next, node\\n\\t\\t\\tprev.next.next, prev.next, prev = node, rev, prev.next\\n\\t\\td += 1\\n\\treturn head\\n```\\n\\nCheat during the contest to save time, convert linked list to a list and then just do slice reversion.\\nOf course cost extra O(n) space\\n```\\ndef reverseEvenLengthGroups(self, head):\\n\\ta = []\\n\\tnode = head\\n\\twhile node:\\n\\t\\ta.append(node.val)\\n\\t\\tnode = node.next\\n\\ti, d, n = 0, 1, len(a)\\n\\twhile i < n:\\n\\t\\tif min(d, n-i) & 1 == 0:\\n\\t\\t\\ta[i:i+d] = a[i:i+d][::-1]\\n\\t\\ti += d\\n\\t\\td += 1\\n\\tnode = head\\n\\tfor x in a:\\n\\t\\tnode.val = x\\n\\t\\tnode = node.next\\n\\treturn head\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef reverseEvenLengthGroups(head):\\n\\tprev = head\\n\\td = 2 # the head doesn\\'t need to be reversed anytime so starts with length 2\\n\\twhile prev.next:\\n\\t\\tnode, n = prev, 0\\n\\t\\tfor _ in range(d):\\n\\t\\t\\tif not node.next:\\n\\t\\t\\t\\tbreak\\n\\t\\t\\tn += 1\\n\\t\\t\\tnode = node.next\\n\\t\\tif n & 1:  # odd length\\n\\t\\t\\tprev = node\\n\\t\\telse:      # even length\\n\\t\\t\\tnode, rev = prev.next, None\\n\\t\\t\\tfor _ in range(n):\\n\\t\\t\\t\\tnode.next, node, rev = rev, node.next, node\\n\\t\\t\\tprev.next.next, prev.next, prev = node, rev, prev.next\\n\\t\\td += 1\\n\\treturn head\\n```\n```\\ndef reverseEvenLengthGroups(self, head):\\n\\ta = []\\n\\tnode = head\\n\\twhile node:\\n\\t\\ta.append(node.val)\\n\\t\\tnode = node.next\\n\\ti, d, n = 0, 1, len(a)\\n\\twhile i < n:\\n\\t\\tif min(d, n-i) & 1 == 0:\\n\\t\\t\\ta[i:i+d] = a[i:i+d][::-1]\\n\\t\\ti += d\\n\\t\\td += 1\\n\\tnode = head\\n\\tfor x in a:\\n\\t\\tnode.val = x\\n\\t\\tnode = node.next\\n\\treturn head\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1577372,
                "title": "constant-memory",
                "content": "> Trap: if the last group is incomplete, we still need to reverse it if it has even number of elements.\\n\\nI re-used the `reverseList` function from my solution for [92. Reverse Linked List II](https://leetcode.com/problems/reverse-linked-list-ii/). It reverses `n` elements starting from a specific node.\\n\\nNow, we just need to find the groups. For each grop, we track `start` (`start->next` is the first element in the group), and the number of elements available.\\n\\n**C++**\\n```cpp\\nListNode* reverseList(ListNode* cur, int n) {\\n    ListNode *start = cur, *prev = nullptr;\\n    while (--n >= 0) {\\n        swap(cur->next, prev);\\n        if (--n >= 0)\\n            swap(prev->next, cur);\\n    }\\n    start->next = cur;\\n    return prev;\\n}  \\nListNode* reverseEvenLengthGroups(ListNode* head) {\\n    int group = 2, cnt = 0;\\n    auto *start = head, *p = head->next;\\n    while (p != nullptr) {\\n        if (++cnt == group) {\\n            if (group % 2 == 0) {\\n                p = start->next;\\n                start->next = reverseList(start->next, cnt);\\n            }\\n            start = p;\\n            cnt = 0;\\n            ++group;\\n        }\\n        p = p->next;\\n    }\\n    if (cnt % 2 == 0 && start->next != nullptr)\\n        start->next = reverseList(start->next, cnt);\\n    return head;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nListNode* reverseList(ListNode* cur, int n) {\\n    ListNode *start = cur, *prev = nullptr;\\n    while (--n >= 0) {\\n        swap(cur->next, prev);\\n        if (--n >= 0)\\n            swap(prev->next, cur);\\n    }\\n    start->next = cur;\\n    return prev;\\n}  \\nListNode* reverseEvenLengthGroups(ListNode* head) {\\n    int group = 2, cnt = 0;\\n    auto *start = head, *p = head->next;\\n    while (p != nullptr) {\\n        if (++cnt == group) {\\n            if (group % 2 == 0) {\\n                p = start->next;\\n                start->next = reverseList(start->next, cnt);\\n            }\\n            start = p;\\n            cnt = 0;\\n            ++group;\\n        }\\n        p = p->next;\\n    }\\n    if (cnt % 2 == 0 && start->next != nullptr)\\n        start->next = reverseList(start->next, cnt);\\n    return head;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1577077,
                "title": "java-reverse-list-o-1-space",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        // Check corner case with null.\\n        if (head == null) {\\n            return null;\\n        }\\n        \\n        // Count number of nodes in total.\\n        ListNode ptr = head;\\n        int total = 0;\\n        while (ptr != null) {\\n            total++;\\n            ptr = ptr.next;\\n        }\\n        \\n        int numOfNodes = 1;\\n        ListNode cur = head, pre = null;\\n        while (cur != null) {\\n            numOfNodes = Math.min(numOfNodes, total);\\n            total -= numOfNodes;\\n            if (numOfNodes % 2 == 1) {\\n                // Odd: Move pointers.\\n                int cnt = 0;\\n                while (cur != null && cnt++ < numOfNodes) {\\n                    pre = cur;\\n                    cur = cur.next;\\n                }\\n            } else {\\n                // Even: Reverse List\\n                ListNode[] res = reverseList(cur, numOfNodes);\\n                pre.next = res[0];\\n                pre = cur;\\n                cur = res[1];\\n            }\\n            numOfNodes++;\\n        }\\n        return head;\\n    }\\n    \\n    // Reverse from node with n nodes.\\n    private ListNode[] reverseList(ListNode node, int n) {\\n        ListNode pre = null, cur = node, post = null;\\n        while (n-- > 0) {\\n            post = cur.next;\\n            cur.next = pre;\\n            pre = cur;\\n            cur = post;\\n        }\\n        node.next = cur;\\n        return new ListNode[]{pre, post};\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        // Check corner case with null.\\n        if (head == null) {\\n            return null;\\n        }\\n        \\n        // Count number of nodes in total.\\n        ListNode ptr = head;\\n        int total = 0;\\n        while (ptr != null) {\\n            total++;\\n            ptr = ptr.next;\\n        }\\n        \\n        int numOfNodes = 1;\\n        ListNode cur = head, pre = null;\\n        while (cur != null) {\\n            numOfNodes = Math.min(numOfNodes, total);\\n            total -= numOfNodes;\\n            if (numOfNodes % 2 == 1) {\\n                // Odd: Move pointers.\\n                int cnt = 0;\\n                while (cur != null && cnt++ < numOfNodes) {\\n                    pre = cur;\\n                    cur = cur.next;\\n                }\\n            } else {\\n                // Even: Reverse List\\n                ListNode[] res = reverseList(cur, numOfNodes);\\n                pre.next = res[0];\\n                pre = cur;\\n                cur = res[1];\\n            }\\n            numOfNodes++;\\n        }\\n        return head;\\n    }\\n    \\n    // Reverse from node with n nodes.\\n    private ListNode[] reverseList(ListNode node, int n) {\\n        ListNode pre = null, cur = node, post = null;\\n        while (n-- > 0) {\\n            post = cur.next;\\n            cur.next = pre;\\n            pre = cur;\\n            cur = post;\\n        }\\n        node.next = cur;\\n        return new ListNode[]{pre, post};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1577058,
                "title": "python3-using-stack",
                "content": "Downvoters, leave a comment! \\n\\nPlease check out this [commit](https://github.com/gaosanyong/leetcode/commit/8d693371fa97ea3b0717d02448c77201b15e5d12) for solutions of weekly 267.\\n```\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        n, node = 0, head\\n        while node: n, node = n+1, node.next\\n        \\n        k, node = 0, head \\n        while n: \\n            k += 1\\n            size = min(k, n)\\n            stack = []\\n            if not size & 1: \\n                temp = node \\n                for _ in range(size): \\n                    stack.append(temp.val)\\n                    temp = temp.next \\n            for _ in range(size): \\n                if stack: node.val = stack.pop()\\n                node = node.next \\n            n -= size\\n        return head \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        n, node = 0, head\\n        while node: n, node = n+1, node.next\\n        \\n        k, node = 0, head \\n        while n: \\n            k += 1\\n            size = min(k, n)\\n            stack = []\\n            if not size & 1: \\n                temp = node \\n                for _ in range(size): \\n                    stack.append(temp.val)\\n                    temp = temp.next \\n            for _ in range(size): \\n                if stack: node.val = stack.pop()\\n                node = node.next \\n            n -= size\\n        return head \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1577265,
                "title": "java-easy-code",
                "content": "class Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        \\n        ListNode temp = head;\\n        int num=1;\\n        \\n        while(temp!=null)\\n        {\\n            int count=0;\\n            ListNode start = temp;\\n            Stack st = new Stack();\\n            \\n            while(count!=num && temp!=null)\\n            {\\n                st.push(temp.val);\\n                temp=temp.next;\\n                count++;\\n                    \\n            }\\n            \\n            if(count%2==0)\\n            {\\n                while(temp!=start)\\n                {\\n                  start.val=(int) st.pop();\\n                 start=start.next;  \\n                }\\n                \\n            }\\n            \\n            num++;\\n        }\\n        \\n        \\n        return head;\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        \\n        ListNode temp = head;\\n        int num=1;\\n        \\n        while(temp!=null)\\n        {\\n            int count=0;\\n            ListNode start = temp;\\n            Stack st = new Stack();\\n            \\n            while(count!=num && temp!=null)\\n            {\\n                st.push(temp.val);\\n                temp=temp.next;\\n                count++;\\n                    \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3746598,
                "title": "java-c-o-n-solution-readable-code-illustration",
                "content": "This problem can be broken down into 2 steps:\\n\\n1.  Since we need to reverse the nodes in each group with an even length, we need to check length of each group. It it is odd then there is no need to reverse.\\n2.  If we need to reverse the **N** nodes, how to do that? Following is my idea:\\n \\n\\n\\t\\nIf the structure of the linkedlist is like this:\\n\\n\\n\\t\\t1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 \\n\\t\\n\\t\\nSince group 1 will always have one node. It doesn\\'t need to be reversed.\\n\\nWe will have node as a pointer :\\n```\\n\\tListNode node=head;\\n\\tint group=1;\\n```\\n\\nAfter we have node as the pointer, the linked list will look like this:\\n```\\n\\t1 (node) -> 2 -> 3 -> 4 -> 5 -> 6 -> 7\\n```\\nNow we will start counting & reversing from 2nd node.\\nTo count number of nodes in a group we will use following code:\\n```\\n\\tint countNodes=0;\\n    ListNode temp=node.next;\\n     while(temp!=null && countNodes<group)\\n\\t\\t {\\n\\t\\t\\t  temp=temp.next;\\n              countNodes++;\\n         }\\n```\\n\\nSuppose that there are **even** nodes to be reversed, we just use the \"reverse linked list\" trick to reverse the k nodes. Please refer to \"https://leetcode.com/problems/reverse-linked-list/\" if you don\\'t know how to reverse a linked list.\\n\\nIf **countNodes is even** i.e for second group `countNodes= 2, we can reverse 2 to 3`  using the following code:\\n\\n```\\n\\tListNode curr=node.next,prev=null,next=null;\\n     for(int i=0;i<countNodes;i++)\\n\\t\\t{\\n\\t\\t\\t  next=curr.next;\\n              curr.next=prev;\\n              prev=curr;\\n              curr=next;\\n        }             \\n```\\n\\nThis is the illustartion of the first 2 steps:\\n\\n```\\n    We will begin reversing form 2nd node\\n\\t\\n    Step1: 1 (node)  -> 2      3 -> 4 -> 5 -> 6 -> 7\\n\\tStep2: 1 (node)  -> 2 <- 3      4 -> 5 -> 6 -> 7\\n\\t\\n```\\n\\nThis is an easy and general algorithm to reverse a linked list. However, if you are careful enough, you will find that after the for-loop, the link from 3 to 4 will be cut (as shown in step 2).\\n\\nNow we need to reconstruct the linked list and fix the issue. You will figure out that at step3, the 3 is the **prev** node, 4 is the **curr** node.\\n\\n```\\nstep2: 1 (node) -> 2 <- 3 (prev)    4 (curr) -> 5 -> 6 -> 7\\n```\\n\\n\\t\\nWe can fix the sequence based on the following codes. The basic idea is to link the `node to 3` and `link 2 to 4`:\\n\\n```\\n\\tListNode tail=node.next;\\n    tail.next=curr;\\n    node.next=prev;\\n    node=tail;\\n```\\n\\nThen the result is:\\n```\\n\\tafter first line:        1 (node) -> 2 (tail)  <- 3 (prev)    4 (curr) -> 5 -> 6 -> 7\\n\\tafter second line:       1 (node) -> 2 (tail)  <- 3 (prev)    4 (curr) -> 5 -> 6 -> 7\\n\\t\\t\\t\\t\\t\\t\\t\\t         |________________________\\u2191\\n\\tafter third line:   \\n\\t\\t\\t\\t\\t\\t\\t\\t |--------------------\\u2193\\n\\t\\t\\t\\t\\t\\t     1 (node)    2 (tail)  <- 3 (prev)    4 (curr) -> 5 -> 6 -> 7\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t     |________________________\\u2191\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t   \\n\\tafter forth line:\\t     1  -> 3  -> 2  (node) -> 4 -> 5 -> 6 -> 7\\n```\\n\\nNow we get the new **node** as pointer, and we can repeat the process.\\n\\n` `**Edge Case**:  if the last group is incomplete, we still need to reverse it if it has even number of elements.\\n\\n\\n\\nIf group has odd number of nodes then we can skip the reverse process by following code:\\n```\\n\\tfor(int i=0;i<countNodes;i++)\\n\\t\\t node=node.next;\\n```\\n\\nHere is the code:\\n\\n**Java**\\n\\n```\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n\\n        //  if LL has 1 or 2 nodes only\\n        if (head.next == null || head.next.next == null) return head;\\n        ListNode node = head;\\n        int group = 1;\\n\\n        while (node != null && node.next != null) {\\n            group++;\\n\\t\\t\\t\\n            //first check number of nodes \\n            int countNodes = 0;\\n            ListNode temp = node.next;\\n            while (temp != null && countNodes < group) {\\n                temp = temp.next;\\n                countNodes++;\\n            }\\n\\t\\t\\t\\n\\t\\t\\t//now we have count now we will check if it is even then do reverse else skip\\n            if (countNodes % 2 == 0) {\\n                ListNode curr = node.next, prev = null, next = null;\\n                for (int i = 0; i < countNodes; i++) {\\n                    next = curr.next;\\n                    curr.next = prev;\\n                    prev = curr;\\n                    curr = next;\\n                }\\n\\n                ListNode tail = node.next;\\n                tail.next = curr;\\n                node.next = prev;\\n                node = tail;\\n            } else {\\n                for (int i = 0; i < countNodes; i++)\\n                    node = node.next;\\n            }\\n        }\\n        return head;\\n    }\\n```\\n\\n**C++**\\n```\\nListNode* reverseEvenLengthGroups(ListNode *head)\\n\\t\\t{\\n\\t\\t\\t//  if LL has 1 or 2 nodes only\\n\\t\\t\\tif (head->next == nullptr || head->next->next == nullptr) return head;\\n\\n\\t\\t\\tListNode *node = head;\\n\\t\\t\\tint group = 1;\\n\\n\\t\\t\\twhile (node != nullptr && node->next != nullptr)\\n\\t\\t\\t{\\n\\t\\t\\t\\tgroup++;\\n\\n\\t\\t\\t\\tint countNodes = 0;\\n\\t\\t\\t\\tListNode *temp = node->next;\\n\\t\\t\\t\\twhile (temp != nullptr && countNodes < group)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\ttemp = temp->next;\\n\\t\\t\\t\\t\\tcountNodes++;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (countNodes % 2 == 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tListNode *curr = node->next, *prev = nullptr, *next = nullptr;\\n\\t\\t\\t\\t\\tfor (int i = 0; i < countNodes; i++)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tnext = curr->next;\\n\\t\\t\\t\\t\\t\\tcurr->next = prev;\\n\\t\\t\\t\\t\\t\\tprev = curr;\\n\\t\\t\\t\\t\\t\\tcurr = next;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tListNode *tail = node->next;\\n\\t\\t\\t\\t\\ttail->next = curr;\\n\\t\\t\\t\\t\\tnode->next = prev;\\n\\t\\t\\t\\t\\tnode = tail;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tfor (int i = 0; i < countNodes; i++)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tnode = node->next;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn head;\\n\\t\\t}\\n```\\n\\n![image](https://assets.leetcode.com/users/images/8e188750-ff71-4621-b32f-f28d92186d1b_1689008854.9552872.jpeg)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C",
                    "Linked List"
                ],
                "code": "```\\n\\tListNode node=head;\\n\\tint group=1;\\n```\n```\\n\\t1 (node) -> 2 -> 3 -> 4 -> 5 -> 6 -> 7\\n```\n```\\n\\tint countNodes=0;\\n    ListNode temp=node.next;\\n     while(temp!=null && countNodes<group)\\n\\t\\t {\\n\\t\\t\\t  temp=temp.next;\\n              countNodes++;\\n         }\\n```\n```\\n\\tListNode curr=node.next,prev=null,next=null;\\n     for(int i=0;i<countNodes;i++)\\n\\t\\t{\\n\\t\\t\\t  next=curr.next;\\n              curr.next=prev;\\n              prev=curr;\\n              curr=next;\\n        }             \\n```\n```\\n    We will begin reversing form 2nd node\\n\\t\\n    Step1: 1 (node)  -> 2      3 -> 4 -> 5 -> 6 -> 7\\n\\tStep2: 1 (node)  -> 2 <- 3      4 -> 5 -> 6 -> 7\\n\\t\\n```\n```\\nstep2: 1 (node) -> 2 <- 3 (prev)    4 (curr) -> 5 -> 6 -> 7\\n```\n```\\n\\tListNode tail=node.next;\\n    tail.next=curr;\\n    node.next=prev;\\n    node=tail;\\n```\n```\\n\\tafter first line:        1 (node) -> 2 (tail)  <- 3 (prev)    4 (curr) -> 5 -> 6 -> 7\\n\\tafter second line:       1 (node) -> 2 (tail)  <- 3 (prev)    4 (curr) -> 5 -> 6 -> 7\\n\\t\\t\\t\\t\\t\\t\\t\\t         |________________________\\u2191\\n\\tafter third line:   \\n\\t\\t\\t\\t\\t\\t\\t\\t |--------------------\\u2193\\n\\t\\t\\t\\t\\t\\t     1 (node)    2 (tail)  <- 3 (prev)    4 (curr) -> 5 -> 6 -> 7\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t     |________________________\\u2191\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t   \\n\\tafter forth line:\\t     1  -> 3  -> 2  (node) -> 4 -> 5 -> 6 -> 7\\n```\n```\\n\\tfor(int i=0;i<countNodes;i++)\\n\\t\\t node=node.next;\\n```\n```\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n\\n        //  if LL has 1 or 2 nodes only\\n        if (head.next == null || head.next.next == null) return head;\\n        ListNode node = head;\\n        int group = 1;\\n\\n        while (node != null && node.next != null) {\\n            group++;\\n\\t\\t\\t\\n            //first check number of nodes \\n            int countNodes = 0;\\n            ListNode temp = node.next;\\n            while (temp != null && countNodes < group) {\\n                temp = temp.next;\\n                countNodes++;\\n            }\\n\\t\\t\\t\\n\\t\\t\\t//now we have count now we will check if it is even then do reverse else skip\\n            if (countNodes % 2 == 0) {\\n                ListNode curr = node.next, prev = null, next = null;\\n                for (int i = 0; i < countNodes; i++) {\\n                    next = curr.next;\\n                    curr.next = prev;\\n                    prev = curr;\\n                    curr = next;\\n                }\\n\\n                ListNode tail = node.next;\\n                tail.next = curr;\\n                node.next = prev;\\n                node = tail;\\n            } else {\\n                for (int i = 0; i < countNodes; i++)\\n                    node = node.next;\\n            }\\n        }\\n        return head;\\n    }\\n```\n```\\nListNode* reverseEvenLengthGroups(ListNode *head)\\n\\t\\t{\\n\\t\\t\\t//  if LL has 1 or 2 nodes only\\n\\t\\t\\tif (head->next == nullptr || head->next->next == nullptr) return head;\\n\\n\\t\\t\\tListNode *node = head;\\n\\t\\t\\tint group = 1;\\n\\n\\t\\t\\twhile (node != nullptr && node->next != nullptr)\\n\\t\\t\\t{\\n\\t\\t\\t\\tgroup++;\\n\\n\\t\\t\\t\\tint countNodes = 0;\\n\\t\\t\\t\\tListNode *temp = node->next;\\n\\t\\t\\t\\twhile (temp != nullptr && countNodes < group)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\ttemp = temp->next;\\n\\t\\t\\t\\t\\tcountNodes++;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (countNodes % 2 == 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tListNode *curr = node->next, *prev = nullptr, *next = nullptr;\\n\\t\\t\\t\\t\\tfor (int i = 0; i < countNodes; i++)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tnext = curr->next;\\n\\t\\t\\t\\t\\t\\tcurr->next = prev;\\n\\t\\t\\t\\t\\t\\tprev = curr;\\n\\t\\t\\t\\t\\t\\tcurr = next;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tListNode *tail = node->next;\\n\\t\\t\\t\\t\\ttail->next = curr;\\n\\t\\t\\t\\t\\tnode->next = prev;\\n\\t\\t\\t\\t\\tnode = tail;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tfor (int i = 0; i < countNodes; i++)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tnode = node->next;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn head;\\n\\t\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3832053,
                "title": "clean-python-solution-simple-beats-100-explanation",
                "content": "# Intuition\\nWhen considering this problem, we need to be comfortable with various linked list operations and concepts. These include understanding how to traverse a linked list, reverse a section of it without disrupting the rest of the list, and reconnect reversed segments seamlessly back into the list. With these tools in hand, the problem becomes a matter of grouping nodes, reversing the groups of even length, and then reconnecting these altered groups back into a complete linked list.\\n\\n# Approach\\nWe use a two-pointer approach to solve this problem. One pointer, `connector`, keeps track of the node preceding the current group. The other, `curr`, navigates the nodes within the current group.\\n\\nThe process begins with `curr` pointing to the head of the list and `connector` being None. We also have two counters, `group_count` to keep track of which group we are in, and `count` to track the length of the current group.\\n\\nWe have a helper function, `reverse_between`, which performs an in-place reversal of a section of the linked list starting from the node after `pre`, and does this for `n` nodes. It uses the classic three-pointer method for list reversal, with a twist to maintain the continuity of the list. Instead of breaking off the section to be reversed, it leaves the start node of this section linked to the rest of the list and moves the remaining nodes one by one to the front. This results in the list being reversed, but the original start node is now the end node of the reversed section and still connected to the rest of the list. After the reversal, the function returns the new end node of the section (which was the original start node).\\n\\nWe proceed with traversing the list, checking at each step whether we are at the end of a group. This is determined either by the counters `group_count` and `count` being equal, or by reaching the end of the list (`curr.next` is None). If we are at the end of a group and the group has an even length, we reverse it with our helper function and update the pointers accordingly. We then increment `group_count` and reset `count` to 0. We repeat this until we have traversed the entire list.\\n\\nThis approach ensures that even-length groups are reversed while maintaining the continuity of the list.\\n\\n# Complexity\\n- Time complexity: The time complexity is **O(n)**, where n is the number of nodes in the linked list. We achieve this by traversing the list only once, with each operation (reversing and reconnecting a group) taking constant time.\\n\\n- Space complexity: The space complexity is **O(1)**. We use a fixed amount of space to store our pointers and counters, and since we perform the reversal in-place, we do not use any additional data structures that scale with the size of the input.\\n\\nFor a detailed explanation of the list reversal process used in reverse_between, you can refer to this [problem](https://leetcode.com/problems/reverse-linked-list-ii/description/).\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        connector = None\\n        curr = head\\n        group_count = 1\\n        count = 1\\n\\n        def reverse_between(pre, n):\\n            start = pre.next\\n            then = start.next\\n            after = start\\n\\n            for _ in range(n - 1):\\n                start.next = then.next\\n                then.next = pre.next\\n                pre.next = then\\n                then = start.next\\n\\n            return after\\n\\n        while curr:\\n            if group_count == count or not curr.next:\\n                if count % 2 == 0:\\n                    curr = reverse_between(connector, count)\\n                connector = curr\\n                group_count += 1\\n                count = 0\\n\\n            count += 1\\n            curr = curr.next\\n\\n        return head\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        connector = None\\n        curr = head\\n        group_count = 1\\n        count = 1\\n\\n        def reverse_between(pre, n):\\n            start = pre.next\\n            then = start.next\\n            after = start\\n\\n            for _ in range(n - 1):\\n                start.next = then.next\\n                then.next = pre.next\\n                pre.next = then\\n                then = start.next\\n\\n            return after\\n\\n        while curr:\\n            if group_count == count or not curr.next:\\n                if count % 2 == 0:\\n                    curr = reverse_between(connector, count)\\n                connector = curr\\n                group_count += 1\\n                count = 0\\n\\n            count += 1\\n            curr = curr.next\\n\\n        return head\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2519575,
                "title": "python-simple-neat-solution-o-n-time-o-1-space",
                "content": "```\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        start_joint = head \\n        group_size = 1\\n        while start_joint and start_joint.next: \\n            group_size += 1\\n            start = end = start_joint.next \\n            group_num = 1 \\n            while end and end.next and group_num < group_size: \\n                end = end.next \\n                group_num += 1 \\n            end_joint = end.next \\n            if group_num % 2 != 0: \\n                start_joint = end \\n                continue \\n            start_joint.next = self.reverse(start, end, end_joint)\\n            start_joint = start \\n        return head\\n    def reverse(self, start, end, end_joint): \\n        prev, curr = end_joint, start\\n        while curr and curr != end_joint: \\n            next_node = curr.next\\n            curr.next = prev\\n            prev, curr = curr, next_node\\n        return prev\\n```\\nComments: This questions is a hard, it uses concepts from other hard questions like Reverse K-Nodes in Group, do not attempt if you are a beginner or haven\\'t had experience with those type of problems. The helper function reverse neatly reverses between start and end, makes sure the reversed end points to the node after end originally(end_joint), and `start_joint.next = self.reverse()` ties it all up. The remainder of the tricky part is handling the odd/even and not matching group_sizes. For those still confused of why there is start_joint, end_joint, this is because you need to maintain the node before and after the part that is being reversed.\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        start_joint = head \\n        group_size = 1\\n        while start_joint and start_joint.next: \\n            group_size += 1\\n            start = end = start_joint.next \\n            group_num = 1 \\n            while end and end.next and group_num < group_size: \\n                end = end.next \\n                group_num += 1 \\n            end_joint = end.next \\n            if group_num % 2 != 0: \\n                start_joint = end \\n                continue \\n            start_joint.next = self.reverse(start, end, end_joint)\\n            start_joint = start \\n        return head\\n    def reverse(self, start, end, end_joint): \\n        prev, curr = end_joint, start\\n        while curr and curr != end_joint: \\n            next_node = curr.next\\n            curr.next = prev\\n            prev, curr = curr, next_node\\n        return prev\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1577126,
                "title": "java-recursion-well-commented",
                "content": "very similar to \\n* https://leetcode.com/problems/reverse-nodes-in-k-group/\\n\\n```\\nclass Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        // passing head and current group length\\n\\t\\treturn helper(head, 1);\\n    }\\n    \\n    public ListNode helper(ListNode head, int curr_grp){\\n        if(head == null) return head;\\n        ListNode curr = head, save = null;\\n\\t\\t// \"check\" for the last group when curr == null and we have to decide\\n\\t\\t//  whether to reverse the group or not\\n        int temp = curr_grp, check = 1;\\n        ListNode reverse_head = null;\\n        while(temp > 1){\\n            curr = curr.next;\\n            if(curr == null){\\n                if(check % 2 == 0)\\n                    return reverse(head);\\n                return head;\\n            }\\n            check++;\\n            temp--;\\n        }\\n        save = curr.next;\\n        curr.next = null;\\n        ListNode rec_ = helper(save, curr_grp + 1);\\n        if(curr != null && (curr_grp % 2) == 0){    // reversing this group\\n            reverse_head = reverse(head);\\n            head.next = rec_;\\n            return reverse_head;\\n        }\\n        curr.next = rec_;    // odd length so not required\\n        return head;\\n    }\\n\\t// reverse\\n    public ListNode reverse(ListNode head){\\n        ListNode prev = null;\\n        ListNode curr = head, frwd = curr;\\n        while(curr != null){\\n            frwd = frwd.next;\\n            curr.next = prev;\\n            prev = curr;\\n            curr = frwd;\\n        }\\n        return prev;\\n    }\\n}\\n//    i was able to do this just a minute before the contest ends but then i realised i had a\\n//    penalty of 5 minutes so didn\\'t got submitted :(",
                "solutionTags": [],
                "code": "class Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        // passing head and current group length\\n\\t\\treturn helper(head, 1);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1576946,
                "title": "c-recursion",
                "content": "**Connect with me on LinkedIn**: https://www.linkedin.com/in/abhay5349singh/\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    ListNode *rev(ListNode* head, int &len, int k){\\n        if(head==NULL) return head;\\n        \\n        ListNode *nextHead; // head node of next group\\n\\t\\tListNode* prevNextHead; // last node of current group\\n        nextHead=head, prevNextHead=nextHead;\\n\\t\\t\\n        for(int i=0;i<k;i++){\\n            prevNextHead=nextHead;\\n            nextHead=nextHead->next;\\n        }\\n        len-=k;\\n        \\n        ListNode *newHead=rev(nextHead,len,min(k+1,len)); // for edge cases like: [0,4,2,1,3] --> [0,2,4,3,1], we need to pass on length of next group accordingly\\n        \\n        ListNode *p, *q;\\n        p=head, q=NULL;\\n        if(k%2==0){ // if length is even, we need to reverse the links of current group\\n            while(p!=nextHead){\\n                ListNode* on=p->next;\\n                p->next=q;\\n                q=p;\\n                p=on;\\n            }\\n        }\\n        if(k%2==0){\\n            head->next=newHead; // as we have reversed the links, initial head node is now last node for the group \\n        }else{\\n            prevNextHead->next=newHead;\\n        }\\n        return (k%2==0 ? q:head);\\n    }\\n    \\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        \\n        if(head==NULL || head->next==NULL) return head;\\n        \\n        ListNode* p=head;\\n        int len=1;\\n        while(p->next!=NULL){\\n            p=p->next;\\n            len++;\\n        }\\n        \\n        return rev(head,len,1);\\n    }\\n};\\n```\\n\\n**Do Upvote if it helps**",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    ListNode *rev(ListNode* head, int &len, int k){\\n        if(head==NULL) return head;\\n        \\n        ListNode *nextHead; // head node of next group\\n\\t\\tListNode* prevNextHead; // last node of current group\\n        nextHead=head, prevNextHead=nextHead;\\n\\t\\t\\n        for(int i=0;i<k;i++){\\n            prevNextHead=nextHead;\\n            nextHead=nextHead->next;\\n        }\\n        len-=k;\\n        \\n        ListNode *newHead=rev(nextHead,len,min(k+1,len)); // for edge cases like: [0,4,2,1,3] --> [0,2,4,3,1], we need to pass on length of next group accordingly\\n        \\n        ListNode *p, *q;\\n        p=head, q=NULL;\\n        if(k%2==0){ // if length is even, we need to reverse the links of current group\\n            while(p!=nextHead){\\n                ListNode* on=p->next;\\n                p->next=q;\\n                q=p;\\n                p=on;\\n            }\\n        }\\n        if(k%2==0){\\n            head->next=newHead; // as we have reversed the links, initial head node is now last node for the group \\n        }else{\\n            prevNextHead->next=newHead;\\n        }\\n        return (k%2==0 ? q:head);\\n    }\\n    \\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        \\n        if(head==NULL || head->next==NULL) return head;\\n        \\n        ListNode* p=head;\\n        int len=1;\\n        while(p->next!=NULL){\\n            p=p->next;\\n            len++;\\n        }\\n        \\n        return rev(head,len,1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2183665,
                "title": "javascript-solution-iterative-approach",
                "content": "```\\nvar reverseEvenLengthGroups = function(head) {\\n    let groupSize = 2;\\n\\n    let start = head;\\n\\n    let prev = head;\\n    let curr = head.next;\\n\\n    let count = 0;\\n    \\n    while (curr != null) {\\n        if (count === groupSize) {\\n            if (groupSize % 2 === 0) { // we only reverse when it is even\\n                const end = curr;\\n                const tail = start.next; // the starting node of the reverse linked list will be the tail after the reverse takes place\\n                reverseList(start, end, count); // we need to reverse everything in the middle of start and end \\n                start = tail; // we set the new start to the end of the reversed linked list\\n            }\\n            else { // when groupSize is even we don\\'t need to reverse, but need to set the new start to the prev node\\n                start = prev;\\n            }\\n            count = 0; // whenever we reached the group size we need to reset our count and up our groupSize\\n            ++groupSize;\\n        }\\n        else { // just a normal traversal when we haven\\'t hit our groupSize\\n            prev = curr;        \\n            curr = curr.next;\\n            ++count;\\n        }\\n    }\\n   \\n    if (count % 2 === 0) { // in the case where we ended early on even count\\n         reverseList(start, null, count);\\n    }\\n    \\n    return head;\\n    \\n    \\n    function reverseList(start, end, count) {\\n        if (start.next == null) return start; // for case when we have a single node\\n        \\n        let prev = start;\\n        \\n        let curr = start.next;\\n        let tail = start.next;\\n        \\n        for (let i = 0; i < count; ++i) {\\n            const next = curr.next;\\n            curr.next = prev;\\n            prev = curr;\\n            curr = next;\\n        }\\n        \\n        start.next = prev;\\n        tail.next = end;\\n        \\n        return ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Linked List"
                ],
                "code": "```\\nvar reverseEvenLengthGroups = function(head) {\\n    let groupSize = 2;\\n\\n    let start = head;\\n\\n    let prev = head;\\n    let curr = head.next;\\n\\n    let count = 0;\\n    \\n    while (curr != null) {\\n        if (count === groupSize) {\\n            if (groupSize % 2 === 0) { // we only reverse when it is even\\n                const end = curr;\\n                const tail = start.next; // the starting node of the reverse linked list will be the tail after the reverse takes place\\n                reverseList(start, end, count); // we need to reverse everything in the middle of start and end \\n                start = tail; // we set the new start to the end of the reversed linked list\\n            }\\n            else { // when groupSize is even we don\\'t need to reverse, but need to set the new start to the prev node\\n                start = prev;\\n            }\\n            count = 0; // whenever we reached the group size we need to reset our count and up our groupSize\\n            ++groupSize;\\n        }\\n        else { // just a normal traversal when we haven\\'t hit our groupSize\\n            prev = curr;        \\n            curr = curr.next;\\n            ++count;\\n        }\\n    }\\n   \\n    if (count % 2 === 0) { // in the case where we ended early on even count\\n         reverseList(start, null, count);\\n    }\\n    \\n    return head;\\n    \\n    \\n    function reverseList(start, end, count) {\\n        if (start.next == null) return start; // for case when we have a single node\\n        \\n        let prev = start;\\n        \\n        let curr = start.next;\\n        let tail = start.next;\\n        \\n        for (let i = 0; i < count; ++i) {\\n            const next = curr.next;\\n            curr.next = prev;\\n            prev = curr;\\n            curr = next;\\n        }\\n        \\n        start.next = prev;\\n        tail.next = end;\\n        \\n        return ;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1576971,
                "title": "python-time-o-n-space-o-1",
                "content": "```\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        group = 2\\n        tail = head # tail of previous group\\n        while tail and tail.next:\\n            cnt = 1 # actual size of the current group\\n            cur = tail.next # first node of the current group\\n            while cur.next and cnt < group:\\n                cur = cur.next\\n                cnt += 1\\n            pre, cur = tail, tail.next\\n            if cnt % 2 == 0: # if group size is even \\n                while cnt and cur:\\n                    nxt = cur.next\\n                    cur.next = pre\\n                    pre = cur\\n                    cur = nxt\\n                    cnt -= 1\\n                first = tail.next # first node of the original group\\n                first.next = cur\\n                tail.next = pre\\n                tail = first\\n            else:\\n                while cnt and cur:\\n                    pre, cur = cur, cur.next\\n                    cnt -= 1\\n                tail = pre\\n            group += 1\\n        return head\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        group = 2\\n        tail = head # tail of previous group\\n        while tail and tail.next:\\n            cnt = 1 # actual size of the current group\\n            cur = tail.next # first node of the current group\\n            while cur.next and cnt < group:\\n                cur = cur.next\\n                cnt += 1\\n            pre, cur = tail, tail.next\\n            if cnt % 2 == 0: # if group size is even \\n                while cnt and cur:\\n                    nxt = cur.next\\n                    cur.next = pre\\n                    pre = cur\\n                    cur = nxt\\n                    cnt -= 1\\n                first = tail.next # first node of the original group\\n                first.next = cur\\n                tail.next = pre\\n                tail = first\\n            else:\\n                while cnt and cur:\\n                    pre, cur = cur, cur.next\\n                    cnt -= 1\\n                tail = pre\\n            group += 1\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1576942,
                "title": "c-solution-put-nodes-into-an-array",
                "content": "\\n\\nIf length of group nodes is even then reverse this group in the arr, and then re-construct the List.\\n\\n```\\nclass Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        vector<ListNode*> arr;\\n        auto node = head;\\n        while(node) {\\n            arr.push_back(node);\\n            node = node->next;\\n        }\\n        int idx = 0;\\n        int cnt = 1;\\n        while(idx < arr.size()) {\\n            int offset = min(idx + cnt, (int)arr.size());\\n            if((offset - idx) % 2 == 0)\\n                reverse(arr.begin() + idx, arr.begin() + offset);\\n            idx += cnt;\\n            ++cnt;\\n        }\\n        for(int i = 1; i < arr.size(); i++) {\\n            arr[i - 1]->next = arr[i];\\n        }\\n        arr.back()->next = NULL;\\n        return arr[0];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        vector<ListNode*> arr;\\n        auto node = head;\\n        while(node) {\\n            arr.push_back(node);\\n            node = node->next;\\n        }\\n        int idx = 0;\\n        int cnt = 1;\\n        while(idx < arr.size()) {\\n            int offset = min(idx + cnt, (int)arr.size());\\n            if((offset - idx) % 2 == 0)\\n                reverse(arr.begin() + idx, arr.begin() + offset);\\n            idx += cnt;\\n            ++cnt;\\n        }\\n        for(int i = 1; i < arr.size(); i++) {\\n            arr[i - 1]->next = arr[i];\\n        }\\n        arr.back()->next = NULL;\\n        return arr[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1660389,
                "title": "c-solution-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        return reverseEvenLengthGroups(head, 1);\\n    }\\n    \\n    ListNode* reverseEvenLengthGroups(ListNode* head, int k) {\\n        \\n        if (head == NULL)\\n            return NULL;\\n        \\n        int count = 0;\\n        ListNode *cNode = NULL, *nNode = NULL, *pNode = NULL;\\n        \\n        for (count = 0, cNode = head; count < k && cNode != NULL; ++count)\\n            cNode = cNode->next;\\n        \\n        if (count % 2 == 1) {\\n            for (cNode = head; count > 0; --count) {\\n                pNode = cNode;\\n                cNode = cNode->next;\\n            }\\n            \\n            pNode->next = reverseEvenLengthGroups(cNode, k+1);\\n            \\n            return head;\\n        } else {\\n        \\n            for (cNode = head; count > 0; --count) {\\n                nNode = cNode->next;\\n                cNode->next = pNode;\\n                pNode = cNode;\\n                cNode = nNode;\\n            }\\n            \\n            head->next = reverseEvenLengthGroups(cNode, k+1);\\n            \\n            return pNode;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        return reverseEvenLengthGroups(head, 1);\\n    }\\n    \\n    ListNode* reverseEvenLengthGroups(ListNode* head, int k) {\\n        \\n        if (head == NULL)\\n            return NULL;\\n        \\n        int count = 0;\\n        ListNode *cNode = NULL, *nNode = NULL, *pNode = NULL;\\n        \\n        for (count = 0, cNode = head; count < k && cNode != NULL; ++count)\\n            cNode = cNode->next;\\n        \\n        if (count % 2 == 1) {\\n            for (cNode = head; count > 0; --count) {\\n                pNode = cNode;\\n                cNode = cNode->next;\\n            }\\n            \\n            pNode->next = reverseEvenLengthGroups(cNode, k+1);\\n            \\n            return head;\\n        } else {\\n        \\n            for (cNode = head; count > 0; --count) {\\n                nNode = cNode->next;\\n                cNode->next = pNode;\\n                pNode = cNode;\\n                cNode = nNode;\\n            }\\n            \\n            head->next = reverseEvenLengthGroups(cNode, k+1);\\n            \\n            return pNode;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1577114,
                "title": "c-vector-solution",
                "content": "**Create Vector from linked list : O(n)\\nDo operations on vector : O(n)\\nCreate linked list from vector : O(n)\\n3*O(n) :\\nOverall Time : O(n)\\nSpace : O(n)**\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        \\n        vector<int> res, ans;\\n        while(head != nullptr)\\n        {\\n            res.push_back(head->val);\\n            head=head->next;\\n        }\\n        \\n        int c=1;\\n        for(int i=0; i<res.size(); i+=c-1)\\n        {\\n            vector<int> temp;\\n            int j=i, co=c;\\n            while(co-- && j<res.size())\\n            {\\n                temp.push_back(res[j]);\\n                j++;\\n            }\\n            if(temp.size()%2==0)\\n                reverse(temp.begin(), temp.end());\\n            ans.insert(ans.end(), temp.begin(), temp.end());\\n            c++;\\n        }\\n        \\n        ListNode* ptr = new ListNode(ans[0]);\\n        ListNode* h = ptr;\\n        \\n        for(int i=1; i<ans.size(); i++)\\n        {\\n            ListNode* node = new ListNode(ans[i]);\\n            ptr->next = node;\\n            ptr = node;\\n        }\\n        \\n        return h;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        \\n        vector<int> res, ans;\\n        while(head != nullptr)\\n        {\\n            res.push_back(head->val);\\n            head=head->next;\\n        }\\n        \\n        int c=1;\\n        for(int i=0; i<res.size(); i+=c-1)\\n        {\\n            vector<int> temp;\\n            int j=i, co=c;\\n            while(co-- && j<res.size())\\n            {\\n                temp.push_back(res[j]);\\n                j++;\\n            }\\n            if(temp.size()%2==0)\\n                reverse(temp.begin(), temp.end());\\n            ans.insert(ans.end(), temp.begin(), temp.end());\\n            c++;\\n        }\\n        \\n        ListNode* ptr = new ListNode(ans[0]);\\n        ListNode* h = ptr;\\n        \\n        for(int i=1; i<ans.size(); i++)\\n        {\\n            ListNode* node = new ListNode(ans[i]);\\n            ptr->next = node;\\n            ptr = node;\\n        }\\n        \\n        return h;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1576979,
                "title": "c-2074-reverse-nodes-in-even-length-groups",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        int n = 0; \\n        for (ListNode* node = head; node; node = node->next, ++n); \\n        \\n        ListNode* node = head; \\n        for (int k = 1; n; ++k) {\\n            int size = min(k, n); \\n            stack<int> stk; \\n            if (size % 2 == 0) {\\n                ListNode* temp = node; \\n                for (int i = 0; i < size; ++i) {\\n                    stk.push(temp->val); \\n                    temp = temp->next; \\n                }\\n            }\\n            for (int i = 0; i < size; ++i) {\\n                if (stk.size()) node->val = stk.top(), stk.pop(); \\n                node = node->next; \\n            }\\n            n -= size; \\n        }\\n        return head; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        int n = 0; \\n        for (ListNode* node = head; node; node = node->next, ++n); \\n        \\n        ListNode* node = head; \\n        for (int k = 1; n; ++k) {\\n            int size = min(k, n); \\n            stack<int> stk; \\n            if (size % 2 == 0) {\\n                ListNode* temp = node; \\n                for (int i = 0; i < size; ++i) {\\n                    stk.push(temp->val); \\n                    temp = temp->next; \\n                }\\n            }\\n            for (int i = 0; i < size; ++i) {\\n                if (stk.size()) node->val = stk.top(), stk.pop(); \\n                node = node->next; \\n            }\\n            n -= size; \\n        }\\n        return head; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1576917,
                "title": "c-two-pass",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n## Solution 1. Two Pass\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/reverse-nodes-in-even-length-groups/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\nclass Solution {\\n    int getLength(ListNode *head) {\\n        int len = 0;\\n        for (; head; head = head->next) ++len;\\n        return len;\\n    }\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        ListNode dummy, *tail = &dummy;\\n        for (int i = 0, total = getLength(head); head; ++i) {\\n            int len = min(total, i + 1); // the length of the current section\\n            ListNode *newTail = NULL; // The new tail if we need to reverse the current section\\n            for (int j = 0; j < len && head; ++j) {\\n                auto p = head;\\n                head = head->next;\\n                if (len % 2) { // direct append\\n                    tail->next = p;\\n                    tail = p;\\n                } else { // append in reverse order\\n                    if (newTail == NULL) newTail = p;\\n                    p->next = tail->next; \\n                    tail->next = p;\\n                }\\n            }\\n            if (newTail) tail = newTail;\\n            tail->next = NULL;\\n            total -= len;\\n        }\\n        return dummy.next;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/problems/reverse-nodes-in-even-length-groups/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\nclass Solution {\\n    int getLength(ListNode *head) {\\n        int len = 0;\\n        for (; head; head = head->next) ++len;\\n        return len;\\n    }\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        ListNode dummy, *tail = &dummy;\\n        for (int i = 0, total = getLength(head); head; ++i) {\\n            int len = min(total, i + 1); // the length of the current section\\n            ListNode *newTail = NULL; // The new tail if we need to reverse the current section\\n            for (int j = 0; j < len && head; ++j) {\\n                auto p = head;\\n                head = head->next;\\n                if (len % 2) { // direct append\\n                    tail->next = p;\\n                    tail = p;\\n                } else { // append in reverse order\\n                    if (newTail == NULL) newTail = p;\\n                    p->next = tail->next; \\n                    tail->next = p;\\n                }\\n            }\\n            if (newTail) tail = newTail;\\n            tail->next = NULL;\\n            total -= len;\\n        }\\n        return dummy.next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3862614,
                "title": "best-c-solution-simple-approach-with-comments-beats-100",
                "content": "\\n\\n\\n### - Time complexity: O(N)\\n\\n### - Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // Reverse function\\n    ListNode* reverse(ListNode* head) {\\n        if(head == NULL)\\n            return head;\\n        \\n        ListNode* prev = NULL, *forward = NULL;\\n        while(head != NULL) {\\n            forward = head->next;\\n            head->next = prev;\\n            prev = head;\\n            head = forward;\\n        }\\n        return prev;\\n    }\\n    \\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        ListNode* dummy = new ListNode(), *prev = dummy;\\n        dummy->next = head;\\n        \\n        // Step 1 - determine the length of groups\\n        for(int len = 1; len < 1e5 && head; len++) {\\n            ListNode* tail = head, *nextHead;\\n            \\n            // Determining the length of the current group\\n            // Its maximum length can be equal to len\\n            int j = 1;\\n            while(j < len && tail != NULL && tail->next != NULL) {\\n                tail = tail->next;\\n                j++;\\n            }\\n            \\n            // Head of the next group\\n            nextHead = tail->next;\\n            if((j % 2) == 0) {\\n                // If group size is even then reverse the group and set prev and head\\n                tail->next = NULL;\\n                prev->next = reverse(head);\\n                prev = head;\\n                head->next = nextHead;\\n                head = nextHead;\\n            }\\n            else {     // If group is odd sized then simply go to the next group\\n                prev = tail;\\n                head = nextHead;\\n            }\\n        }\\n\\n        return dummy->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // Reverse function\\n    ListNode* reverse(ListNode* head) {\\n        if(head == NULL)\\n            return head;\\n        \\n        ListNode* prev = NULL, *forward = NULL;\\n        while(head != NULL) {\\n            forward = head->next;\\n            head->next = prev;\\n            prev = head;\\n            head = forward;\\n        }\\n        return prev;\\n    }\\n    \\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        ListNode* dummy = new ListNode(), *prev = dummy;\\n        dummy->next = head;\\n        \\n        // Step 1 - determine the length of groups\\n        for(int len = 1; len < 1e5 && head; len++) {\\n            ListNode* tail = head, *nextHead;\\n            \\n            // Determining the length of the current group\\n            // Its maximum length can be equal to len\\n            int j = 1;\\n            while(j < len && tail != NULL && tail->next != NULL) {\\n                tail = tail->next;\\n                j++;\\n            }\\n            \\n            // Head of the next group\\n            nextHead = tail->next;\\n            if((j % 2) == 0) {\\n                // If group size is even then reverse the group and set prev and head\\n                tail->next = NULL;\\n                prev->next = reverse(head);\\n                prev = head;\\n                head->next = nextHead;\\n                head = nextHead;\\n            }\\n            else {     // If group is odd sized then simply go to the next group\\n                prev = tail;\\n                head = nextHead;\\n            }\\n        }\\n\\n        return dummy->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3651408,
                "title": "python-c-faster-than-90-easy-implementation-clean-concise-code",
                "content": "# Approach\\n```txt\\nk = odd\\ndummy -> 1 -> || 2 -> 3 -> 4 || -> 5 -> 6 -> 7\\n       grpPrev            kth  grpNxt   --> No Reverse \\n```\\n```txt\\nk = even\\ndummy -> 1 -> || 2 -> 3 -> 4 -> 5 || -> 6 -> 7\\n        grpPrev                kth   grpNxt  --> Reverse \\n```\\n\\n# Complexity\\n- Time complexity: O(N)\\n- Space complexity: O(1)\\n\\n# Code\\n```python []\\nclass ListNode:\\n    def __init__(self, val=0, next=None):\\n        self.val = val\\n        self.next = next\\n\\nclass Solution:\\n\\n    def getKth(self, cur, k):\\n        cnt = k\\n        while cur and cur.next and  k > 0:\\n            cur = cur.next\\n            k -= 1\\n        return [cur, cnt - k]\\n\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        dummy = ListNode(0, head)\\n        groupPrev = dummy\\n\\n        k = 1\\n        while groupPrev and groupPrev.next:\\n            kth, newK = self.getKth(groupPrev, k)\\n            k = newK\\n            groupNext = kth.next\\n\\n            if k%2:\\n                groupPrev = kth\\n            else:\\n                prev, curr = kth.next, groupPrev.next\\n                while curr and curr != groupNext:\\n                    # storing for future use\\n                    nxt = curr.next\\n\\n                    # pointing to the prev ptr\\n                    curr.next = prev\\n\\n                    # updating the ptr\\'s\\n                    prev = curr\\n                    curr = nxt\\n                tmp = groupPrev.next\\n                groupPrev.next = kth\\n                groupPrev = tmp\\n            k += 1\\n        return dummy.next\\n\\n\\n```\\n```C++ []\\n\\nclass Solution {\\npublic:\\n\\n\\nvoid swap(ListNode* A, ListNode* B)\\n{\\n    int tmp = A->val;\\n    A->val = B->val;\\n    B->val = tmp;\\n}\\n\\nvoid reverse_node(vector<ListNode*> &arr)\\n{\\n    int i = 0, j = arr.size()-1;\\n\\n    while(i<=j) swap(arr[i++], arr[j--]);\\n    \\n}\\n\\n\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        \\n        vector<ListNode*>res;\\n        int i = 1;\\n        int cnt = 0;\\n        \\n        ListNode *ptr = head;\\n\\n        while(ptr != NULL)\\n        {\\n           \\n           res.push_back(ptr);\\n           ptr = ptr->next;\\n           cnt++;\\n\\n           if(cnt == i)\\n           {\\n               if(cnt % 2 == 0) reverse_node(res);\\n               res.clear();\\n               cnt = 0;\\n               i++;\\n           }\\n\\n        }\\n\\n        if(cnt%2 == 0) reverse_node(res);\\n\\n\\n        return head;\\n\\n    }\\n};\\n\\n```\\n\\nYou Can also Look At My SDE Prep Repo [\\uD83E\\uDDE2 GitHub](https://github.com/Ayon-SSP/The-SDE-Prep)\\n",
                "solutionTags": [
                    "C++",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```txt\\nk = odd\\ndummy -> 1 -> || 2 -> 3 -> 4 || -> 5 -> 6 -> 7\\n       grpPrev            kth  grpNxt   --> No Reverse \\n```\n```txt\\nk = even\\ndummy -> 1 -> || 2 -> 3 -> 4 -> 5 || -> 6 -> 7\\n        grpPrev                kth   grpNxt  --> Reverse \\n```\n```python []\\nclass ListNode:\\n    def __init__(self, val=0, next=None):\\n        self.val = val\\n        self.next = next\\n\\nclass Solution:\\n\\n    def getKth(self, cur, k):\\n        cnt = k\\n        while cur and cur.next and  k > 0:\\n            cur = cur.next\\n            k -= 1\\n        return [cur, cnt - k]\\n\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        dummy = ListNode(0, head)\\n        groupPrev = dummy\\n\\n        k = 1\\n        while groupPrev and groupPrev.next:\\n            kth, newK = self.getKth(groupPrev, k)\\n            k = newK\\n            groupNext = kth.next\\n\\n            if k%2:\\n                groupPrev = kth\\n            else:\\n                prev, curr = kth.next, groupPrev.next\\n                while curr and curr != groupNext:\\n                    # storing for future use\\n                    nxt = curr.next\\n\\n                    # pointing to the prev ptr\\n                    curr.next = prev\\n\\n                    # updating the ptr\\'s\\n                    prev = curr\\n                    curr = nxt\\n                tmp = groupPrev.next\\n                groupPrev.next = kth\\n                groupPrev = tmp\\n            k += 1\\n        return dummy.next\\n\\n\\n```\n```C++ []\\n\\nclass Solution {\\npublic:\\n\\n\\nvoid swap(ListNode* A, ListNode* B)\\n{\\n    int tmp = A->val;\\n    A->val = B->val;\\n    B->val = tmp;\\n}\\n\\nvoid reverse_node(vector<ListNode*> &arr)\\n{\\n    int i = 0, j = arr.size()-1;\\n\\n    while(i<=j) swap(arr[i++], arr[j--]);\\n    \\n}\\n\\n\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        \\n        vector<ListNode*>res;\\n        int i = 1;\\n        int cnt = 0;\\n        \\n        ListNode *ptr = head;\\n\\n        while(ptr != NULL)\\n        {\\n           \\n           res.push_back(ptr);\\n           ptr = ptr->next;\\n           cnt++;\\n\\n           if(cnt == i)\\n           {\\n               if(cnt % 2 == 0) reverse_node(res);\\n               res.clear();\\n               cnt = 0;\\n               i++;\\n           }\\n\\n        }\\n\\n        if(cnt%2 == 0) reverse_node(res);\\n\\n\\n        return head;\\n\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3454408,
                "title": "python-3-14-lines-w-example-t-m-97-52",
                "content": "```\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: ListNode) -> ListNode:\\n\\n        node, nums, ans = head, [], []\\n        T = lambda x: x*(x+1)//2\\n        flip = lambda x: x if len(x)%2 else x[::-1]         #  Example: head = 1->5->4->2->6->3->0->8\\n\\n        while node:                                         #    nums = [1,5,4,2,6,3,0,8]\\n            nums.append(node.val)\\n            node = node.next\\n\\n        for i in range(ceil(-0.5+sqrt(0.25+2*len(nums)))):  #     ans = [[1], [5,4], [2,6,3], [0,8]]\\n            ans.append(nums[T(i):T(i+1)])\\n\\n        ans = chain(*map(flip,ans))                         #     ans = chain(*[[1], [4,5], [2,6,3], [8,0]])\\n                                                            #         = chain([1], [4,5], [2,6,3], [8,0])\\n                                                            #         = [1, 4,5, 2,6,3, 8,0]\\n\\n        node = head                                         #    head = 1->4->5->2->6->3->8->0\\n        for a in ans:\\n            node.val  = a\\n            node = node.next\\n\\n        return head\\n```\\n[https://leetcode.com/problems/reverse-nodes-in-even-length-groups/submissions/939576037/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(*N*).",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: ListNode) -> ListNode:\\n\\n        node, nums, ans = head, [], []\\n        T = lambda x: x*(x+1)//2\\n        flip = lambda x: x if len(x)%2 else x[::-1]         #  Example: head = 1->5->4->2->6->3->0->8\\n\\n        while node:                                         #    nums = [1,5,4,2,6,3,0,8]\\n            nums.append(node.val)\\n            node = node.next\\n\\n        for i in range(ceil(-0.5+sqrt(0.25+2*len(nums)))):  #     ans = [[1], [5,4], [2,6,3], [0,8]]\\n            ans.append(nums[T(i):T(i+1)])\\n\\n        ans = chain(*map(flip,ans))                         #     ans = chain(*[[1], [4,5], [2,6,3], [8,0]])\\n                                                            #         = chain([1], [4,5], [2,6,3], [8,0])\\n                                                            #         = [1, 4,5, 2,6,3, 8,0]\\n\\n        node = head                                         #    head = 1->4->5->2->6->3->8->0\\n        for a in ans:\\n            node.val  = a\\n            node = node.next\\n\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3302693,
                "title": "python-easy-to-understand",
                "content": "\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if not head.next or not head.next.next:\\n            return head\\n\\n        dummy = before = nullCheck = head\\n        before = head\\n        count = 1\\n        \\n        while head:\\n            # length check\\n            length = 0\\n            while nullCheck and length < count:\\n                nullCheck = nullCheck.next\\n                length += 1\\n            \\n            # odd length\\n            if length % 2 == 1:\\n                for _ in range(length):\\n                    before = head\\n                    head = head.next\\n            \\n            else:\\n                tail = head\\n\\n                # reverse\\n                prev = None\\n                for _ in range(length):\\n                    nextNode = head.next\\n                    head.next = prev\\n                    prev = head\\n                    head = nextNode\\n                \\n                # join\\n                before.next = prev\\n                before = tail\\n                tail.next = head\\n            \\n            count += 1\\n        \\n        return dummy\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if not head.next or not head.next.next:\\n            return head\\n\\n        dummy = before = nullCheck = head\\n        before = head\\n        count = 1\\n        \\n        while head:\\n            # length check\\n            length = 0\\n            while nullCheck and length < count:\\n                nullCheck = nullCheck.next\\n                length += 1\\n            \\n            # odd length\\n            if length % 2 == 1:\\n                for _ in range(length):\\n                    before = head\\n                    head = head.next\\n            \\n            else:\\n                tail = head\\n\\n                # reverse\\n                prev = None\\n                for _ in range(length):\\n                    nextNode = head.next\\n                    head.next = prev\\n                    prev = head\\n                    head = nextNode\\n                \\n                # join\\n                before.next = prev\\n                before = tail\\n                tail.next = head\\n            \\n            count += 1\\n        \\n        return dummy\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2982897,
                "title": "c-faster-than-90-easy-implementation-clean-concise-code",
                "content": "\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n\\n\\nvoid swap(ListNode* A, ListNode* B)\\n{\\n    int tmp = A->val;\\n    A->val = B->val;\\n    B->val = tmp;\\n}\\n\\nvoid reverse_node(vector<ListNode*> &arr)\\n{\\n    int i = 0, j = arr.size()-1;\\n\\n    while(i<=j) swap(arr[i++], arr[j--]);\\n    \\n}\\n\\n\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        \\n        vector<ListNode*>res;\\n        int i = 1;\\n        int cnt = 0;\\n        \\n        ListNode *ptr = head;\\n\\n        while(ptr != NULL)\\n        {\\n           \\n           res.push_back(ptr);\\n           ptr = ptr->next;\\n           cnt++;\\n\\n           if(cnt == i)\\n           {\\n               if(cnt % 2 == 0) reverse_node(res);\\n               res.clear();\\n               cnt = 0;\\n               i++;\\n           }\\n\\n        }\\n\\n        if(cnt%2 == 0) reverse_node(res);\\n\\n\\n        return head;\\n\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n\\n\\nvoid swap(ListNode* A, ListNode* B)\\n{\\n    int tmp = A->val;\\n    A->val = B->val;\\n    B->val = tmp;\\n}\\n\\nvoid reverse_node(vector<ListNode*> &arr)\\n{\\n    int i = 0, j = arr.size()-1;\\n\\n    while(i<=j) swap(arr[i++], arr[j--]);\\n    \\n}\\n\\n\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        \\n        vector<ListNode*>res;\\n        int i = 1;\\n        int cnt = 0;\\n        \\n        ListNode *ptr = head;\\n\\n        while(ptr != NULL)\\n        {\\n           \\n           res.push_back(ptr);\\n           ptr = ptr->next;\\n           cnt++;\\n\\n           if(cnt == i)\\n           {\\n               if(cnt % 2 == 0) reverse_node(res);\\n               res.clear();\\n               cnt = 0;\\n               i++;\\n           }\\n\\n        }\\n\\n        if(cnt%2 == 0) reverse_node(res);\\n\\n\\n        return head;\\n\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2724203,
                "title": "c-94-faster-than-all-easy",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        if(!head)\\n            return head;\\n        ListNode* prev = NULL;\\n        while(head) {\\n            ListNode* temp = head -> next;\\n            head -> next = prev;\\n            prev = head;\\n            head = temp;\\n        }\\n        \\n        return prev;\\n    }\\n    \\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        ListNode* dummy = new ListNode();\\n        dummy -> next = head;\\n        \\n        ListNode* prev = dummy;\\n        \\n        for(int len = 1; len < 1e5 && head; len++) {\\n            ListNode* tail = head;\\n            ListNode* nextHead;\\n            \\n            int j = 1;\\n            while(j < len && tail && tail -> next) {\\n                tail = tail -> next;\\n                j++;\\n            }\\n            \\n            nextHead = tail -> next;\\n            \\n            if((j % 2) == 0) {\\n                tail -> next = NULL;\\n                prev -> next = reverseList(head);\\n                prev = head;\\n                head -> next = nextHead;\\n                head = nextHead;\\n            } else {\\n                prev = tail;\\n                head = nextHead;\\n            }\\n        }\\n        \\n        return dummy -> next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        if(!head)\\n            return head;\\n        ListNode* prev = NULL;\\n        while(head) {\\n            ListNode* temp = head -> next;\\n            head -> next = prev;\\n            prev = head;\\n            head = temp;\\n        }\\n        \\n        return prev;\\n    }\\n    \\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        ListNode* dummy = new ListNode();\\n        dummy -> next = head;\\n        \\n        ListNode* prev = dummy;\\n        \\n        for(int len = 1; len < 1e5 && head; len++) {\\n            ListNode* tail = head;\\n            ListNode* nextHead;\\n            \\n            int j = 1;\\n            while(j < len && tail && tail -> next) {\\n                tail = tail -> next;\\n                j++;\\n            }\\n            \\n            nextHead = tail -> next;\\n            \\n            if((j % 2) == 0) {\\n                tail -> next = NULL;\\n                prev -> next = reverseList(head);\\n                prev = head;\\n                head -> next = nextHead;\\n                head = nextHead;\\n            } else {\\n                prev = tail;\\n                head = nextHead;\\n            }\\n        }\\n        \\n        return dummy -> next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2534967,
                "title": "java-solution-with-comments-for-better-understanding",
                "content": "```\\npublic ListNode reverseEvenLengthGroups(ListNode head) {\\n        //If there is only one node or only two nodes in the list then list remains unchanged\\n        if(head.next == null || head.next.next == null) return head;\\n        \\n        \\n        //Since group 1 will always have one node\\n        ListNode temp = head;\\n        ListNode prevNode = head;\\n        int group = 1;\\n        \\n        while(temp.next != null){\\n            //Move to the next group\\n            group++;\\n\\n            //Find how many nodes will be in this group. \\n            //Number of nodes cannot exceed group number\\n            int nodes = 0;\\n            while(temp.next != null && nodes < group){\\n                temp = temp.next;\\n                nodes++;\\n            }\\n\\n            //After this loop, temp will be pointing to the last node of this group\\n            ListNode nodeAfterGroup = temp.next;\\n\\n            //If the length of this group is even then reverse this group\\n            if(nodes % 2 == 0){\\n                //Get the list to reverse\\n                ListNode listToReverse = prevNode.next;\\n                ListNode ptr = listToReverse;\\n                while(ptr != temp) ptr = ptr.next;\\n                ptr.next = null;\\n\\n                //Reverse this list\\n                listToReverse = reverse(listToReverse);\\n                ListNode revPtr = listToReverse;\\n                while(revPtr.next != null) revPtr = revPtr.next;\\n\\n                //Attach it back to the original list properly \\n                prevNode.next = listToReverse;\\n                revPtr.next = nodeAfterGroup;\\n                \\n                //Make sure temp now points to the last node of this group after we reversed it.\\n                temp = revPtr;\\n            }\\n                \\n            //Set the previousNode as temp i.e., the node just before the beginning of next group\\n            prevNode = temp;\\n        }\\n        \\n        return head;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\npublic ListNode reverseEvenLengthGroups(ListNode head) {\\n        //If there is only one node or only two nodes in the list then list remains unchanged\\n        if(head.next == null || head.next.next == null) return head;\\n        \\n        \\n        //Since group 1 will always have one node\\n        ListNode temp = head;\\n        ListNode prevNode = head;\\n        int group = 1;\\n        \\n        while(temp.next != null){\\n            //Move to the next group\\n            group++;\\n\\n            //Find how many nodes will be in this group. \\n            //Number of nodes cannot exceed group number\\n            int nodes = 0;\\n            while(temp.next != null && nodes < group){\\n                temp = temp.next;\\n                nodes++;\\n            }\\n\\n            //After this loop, temp will be pointing to the last node of this group\\n            ListNode nodeAfterGroup = temp.next;\\n\\n            //If the length of this group is even then reverse this group\\n            if(nodes % 2 == 0){\\n                //Get the list to reverse\\n                ListNode listToReverse = prevNode.next;\\n                ListNode ptr = listToReverse;\\n                while(ptr != temp) ptr = ptr.next;\\n                ptr.next = null;\\n\\n                //Reverse this list\\n                listToReverse = reverse(listToReverse);\\n                ListNode revPtr = listToReverse;\\n                while(revPtr.next != null) revPtr = revPtr.next;\\n\\n                //Attach it back to the original list properly \\n                prevNode.next = listToReverse;\\n                revPtr.next = nodeAfterGroup;\\n                \\n                //Make sure temp now points to the last node of this group after we reversed it.\\n                temp = revPtr;\\n            }\\n                \\n            //Set the previousNode as temp i.e., the node just before the beginning of next group\\n            prevNode = temp;\\n        }\\n        \\n        return head;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2384715,
                "title": "c-iterative-method",
                "content": "This problem is similar as [reverse-nodes-in-k-group](https://leetcode.com/problems/reverse-nodes-in-k-group/) here k vary .\\n```\\nclass Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head)\\n    {\\n        int len=0;  ListNode*cur=head;\\n        while(cur!=NULL)\\n        { len++ ;cur=cur->next;}                                                                                  //count length of linked list\\n        \\n        ListNode* dummy=new ListNode(0) ;\\n\\t\\tListNode *nex=NULL ,*prev=NULL;\\n        dummy->next=head ; prev=dummy;\\n        \\n        int k=1;\\n\\t\\t\\n        while(len>0)\\n        {\\n            cur=prev->next;\\n            nex=cur->next;\\n                                                \\n            if((k%2!=0 && len>=k) || (len<k && len%2!=0))\\n               for(int i=1;i<k && (len-i) ;i++)                                     // no reverse at odd group and if last group is odd\\n                cur=cur->next;\\n            \\n            else if((k%2==0 && len>=k) || (len<k && len%2==0)) \\n                for(int i=1;i<k && (len-i) ;i++)                                // reverse at even group and if last group is even\\n               {\\n                cur->next=nex->next;\\n                nex->next=prev->next;\\n                prev->next=nex;\\n                nex=cur->next;\\n               }\\n            \\n            len-=k;\\n            prev=cur;\\n            k++;\\n        }\\n        return dummy->next;\\n    }\\n};\\nFeel free to ask any doubt in comment section",
                "solutionTags": [
                    "C",
                    "Iterator"
                ],
                "code": "class Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head)\\n    {\\n        int len=0;  ListNode*cur=head;\\n        while(cur!=NULL)\\n        { len++ ;cur=cur->next;}",
                "codeTag": "Java"
            },
            {
                "id": 1584154,
                "title": "java-easy-explained-solution-o-n-time-complexity-o-1-space-complexity",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public static ListNode reverse(ListNode head,ListNode last,int len){\\n        while(len>0){\\n            ListNode temp=head.next;\\n            head.next=last;\\n            last=head;\\n            head=temp;\\n            len--;\\n        }\\n        return last;\\n    }\\n    public static int len(ListNode node,int maxlen){\\n        int cnt=0;\\n        while(node.next!=null && maxlen>0){\\n            node=node.next;\\n            cnt++;\\n            maxlen--;\\n        }\\n        return cnt;\\n    }\\n    public static ListNode next(ListNode node,int size){\\n        while(size>0){\\n            node=node.next;\\n            size--;\\n        }\\n        return node;\\n    }\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        //It is very obvious that we cann\\'t reverse grp of size 1 so head node will not change in modified LinkedList.\\n        int grpno=2;\\n        ListNode res=head;\\n        while(head!=null){\\n            \\n            //Finding the grp length of given grpno bcz it is always not true that grpno == grp length(mainly in last part of LL)\\n            int grplen=len(head,grpno);\\n            \\n            //Find the node ending at the given grplen\\n            ListNode node=next(head,grplen);\\n            \\n            ListNode temp=head.next;\\n            //reverse the grp with grplen even\\n            if(grplen%2==0){\\n                head.next=reverse(head.next,node.next,grplen);\\n                head=temp;\\n            }\\n            else{\\n                head=node;\\n            }\\n            grpno++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public static ListNode reverse(ListNode head,ListNode last,int len){\\n        while(len>0){\\n            ListNode temp=head.next;\\n            head.next=last;\\n            last=head;\\n            head=temp;\\n            len--;\\n        }\\n        return last;\\n    }\\n    public static int len(ListNode node,int maxlen){\\n        int cnt=0;\\n        while(node.next!=null && maxlen>0){\\n            node=node.next;\\n            cnt++;\\n            maxlen--;\\n        }\\n        return cnt;\\n    }\\n    public static ListNode next(ListNode node,int size){\\n        while(size>0){\\n            node=node.next;\\n            size--;\\n        }\\n        return node;\\n    }\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        //It is very obvious that we cann\\'t reverse grp of size 1 so head node will not change in modified LinkedList.\\n        int grpno=2;\\n        ListNode res=head;\\n        while(head!=null){\\n            \\n            //Finding the grp length of given grpno bcz it is always not true that grpno == grp length(mainly in last part of LL)\\n            int grplen=len(head,grpno);\\n            \\n            //Find the node ending at the given grplen\\n            ListNode node=next(head,grplen);\\n            \\n            ListNode temp=head.next;\\n            //reverse the grp with grplen even\\n            if(grplen%2==0){\\n                head.next=reverse(head.next,node.next,grplen);\\n                head=temp;\\n            }\\n            else{\\n                head=node;\\n            }\\n            grpno++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4055037,
                "title": "java-solution-using-arraylist",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n\\n    static void reverse(ArrayList<Integer> arr, int i, int j){\\n\\n        while(i<j){\\n            int a = arr.get(i);\\n            arr.set(i,arr.get(j));\\n            arr.set(j,a);\\n            i++;\\n            j--;\\n        }\\n    }\\n\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n\\n        if(head.next==null) return head;\\n\\n        ArrayList<Integer> arr = new ArrayList<>();\\n\\n        ListNode t = head;\\n\\n        while(t!=null){\\n            arr.add(t.val);\\n            t=t.next;\\n        }\\n\\n        int prev = 2;\\n        int idx = -1;\\n\\n        for(int i=1; i+prev-1<arr.size();){\\n            reverse(arr,i,i+prev-1);\\n            if(i+2*prev+1>=arr.size()) idx = i+prev;\\n            else{\\n                idx = i+2*prev+1;\\n            }\\n            i=i+2*prev+1;\\n            prev=prev+2;\\n        }\\n\\n        if(arr.size()-idx>0 && (arr.size()-idx)%2==0){\\n            reverse(arr,idx,arr.size()-1);\\n        }\\n\\n        \\n\\n        ListNode ans = new ListNode(-1);\\n        t=ans;\\n        for(int i=0; i<arr.size(); i++){\\n            t.next = new ListNode(arr.get(i));\\n            t=t.next;\\n        }\\n\\n        return ans.next;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n\\n    static void reverse(ArrayList<Integer> arr, int i, int j){\\n\\n        while(i<j){\\n            int a = arr.get(i);\\n            arr.set(i,arr.get(j));\\n            arr.set(j,a);\\n            i++;\\n            j--;\\n        }\\n    }\\n\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n\\n        if(head.next==null) return head;\\n\\n        ArrayList<Integer> arr = new ArrayList<>();\\n\\n        ListNode t = head;\\n\\n        while(t!=null){\\n            arr.add(t.val);\\n            t=t.next;\\n        }\\n\\n        int prev = 2;\\n        int idx = -1;\\n\\n        for(int i=1; i+prev-1<arr.size();){\\n            reverse(arr,i,i+prev-1);\\n            if(i+2*prev+1>=arr.size()) idx = i+prev;\\n            else{\\n                idx = i+2*prev+1;\\n            }\\n            i=i+2*prev+1;\\n            prev=prev+2;\\n        }\\n\\n        if(arr.size()-idx>0 && (arr.size()-idx)%2==0){\\n            reverse(arr,idx,arr.size()-1);\\n        }\\n\\n        \\n\\n        ListNode ans = new ListNode(-1);\\n        t=ans;\\n        for(int i=0; i<arr.size(); i++){\\n            t.next = new ListNode(arr.get(i));\\n            t=t.next;\\n        }\\n\\n        return ans.next;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3878657,
                "title": "not-so-fast-but-understandable-py",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n****1)First convert linked list to list.\\n\\n2)Then create the temporary list of the desired length like 1,2,3,4...\\n\\n3)Then check if length of temp list is even:\\nif it is even then first reverse it and add it to the ans list\\nelse add temp to ans directly.\\n\\n4)Then we have to check for the remaining elements:\\nlike temp of size 1,2,3 are present but of size 4 is not present, there should be 1,2,3 element remaing in the list.\\n\\n5)so we have to check the no. of remaing element is even then reverse them else add as it is to the ans list.\\n\\n6)Then The final step is to convert the list to linked list again.****\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        l = []\\n        ans = []\\n        while head:\\n            l.append(head.val)\\n            head = head.next\\n\\n        right = 1\\n        left = 0\\n        while left+right<=len(l):\\n            temp = l[left:left+right]\\n            if len(temp)%2==0:\\n                temp = temp[::-1]\\n                ans+= temp\\n            else:\\n                ans+= temp\\n            left+=right\\n            right+=1\\n\\n        remain = len(l)-len(ans)\\n        temp2=[]\\n        if remain%2==0:\\n            for i in range(-remain,0,1):\\n                temp2.append(l[i])\\n            ans+=temp2[::-1]\\n        else:    \\n            for i in range(-remain,0,1):\\n                ans.append(l[i])\\n\\n\\n        head=temp=ListNode(ans[0])\\n        for i in range(1,len(ans)):\\n            temp.next = ListNode(ans[i])\\n            temp = temp.next\\n        return head\\n\\n\\n        \\n```\\n**IF YOU LIKE IT PLEASE UPVOTE :))**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        l = []\\n        ans = []\\n        while head:\\n            l.append(head.val)\\n            head = head.next\\n\\n        right = 1\\n        left = 0\\n        while left+right<=len(l):\\n            temp = l[left:left+right]\\n            if len(temp)%2==0:\\n                temp = temp[::-1]\\n                ans+= temp\\n            else:\\n                ans+= temp\\n            left+=right\\n            right+=1\\n\\n        remain = len(l)-len(ans)\\n        temp2=[]\\n        if remain%2==0:\\n            for i in range(-remain,0,1):\\n                temp2.append(l[i])\\n            ans+=temp2[::-1]\\n        else:    \\n            for i in range(-remain,0,1):\\n                ans.append(l[i])\\n\\n\\n        head=temp=ListNode(ans[0])\\n        for i in range(1,len(ans)):\\n            temp.next = ListNode(ans[i])\\n            temp = temp.next\\n        return head\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3718294,
                "title": "efficient-approach-reverse-even-length-groups-optimal-space-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe code uses a recursive approach to reverse even-length groups of nodes in a linked list. It iterates through the list, reversing each group individually. The time complexity is O(n), and the space complexity is O(n) due to the recursive calls.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- If the head is NULL or there\\'s only one node, return the head.\\n- Initialize count to 0.\\n- If the group\\'s length is even and there are enough remaining nodes, or if n is less than or equal to k and n is even, reverse the group.\\n- Within a loop, reverse the links between nodes by updating pointers.\\n- Recursively update head->next and return the reversed group\\'s head.\\n- If the group\\'s length is odd or there are fewer remaining nodes, update pointers without reversing.\\n- Recursively update prev->next and return the original head.\\n- Calculate the total number of nodes.\\n- Call the recursive function with initial parameters.\\n- Return the modified linked list.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity is **O(n)** as each node is visited once. \\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is **O(n)** due to the recursive calls, with a maximum depth of n/2.\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    ListNode* reveven(ListNode* head, int k, int& n){\\n        if(head==NULL|| head->next == NULL) return head;\\n        int count = 0;\\n        if((k%2 == 0 && n>=k) || (n<=k && n%2 == 0)){\\n            ListNode* curr = head;\\n            ListNode* prev = NULL;\\n            ListNode* nextt = NULL;\\n            while(count < k && curr!= NULL){\\n                nextt = curr->next;\\n                curr->next = prev;\\n                prev = curr;\\n                curr = nextt;\\n                count++;\\n                n--;\\n            }\\n            head->next = reveven(curr,k+1,n);\\n            return prev;\\n        }\\n        else{\\n            ListNode* curr = head;\\n            ListNode* prev = NULL;\\n            while(count < k && curr!= NULL){\\n                prev = curr;\\n                curr = curr->next;\\n                count++;\\n                n--;\\n            }\\n            prev->next = reveven(curr,k+1,n);\\n            return head;\\n        }\\n    }\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        \\n        if(head==NULL) return head;\\n        int n = 0;\\n        ListNode* temp = head;\\n        while(temp!=NULL){\\n            temp= temp->next;\\n            n++;\\n        }\\n\\n        return reveven(head, 1,n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    ListNode* reveven(ListNode* head, int k, int& n){\\n        if(head==NULL|| head->next == NULL) return head;\\n        int count = 0;\\n        if((k%2 == 0 && n>=k) || (n<=k && n%2 == 0)){\\n            ListNode* curr = head;\\n            ListNode* prev = NULL;\\n            ListNode* nextt = NULL;\\n            while(count < k && curr!= NULL){\\n                nextt = curr->next;\\n                curr->next = prev;\\n                prev = curr;\\n                curr = nextt;\\n                count++;\\n                n--;\\n            }\\n            head->next = reveven(curr,k+1,n);\\n            return prev;\\n        }\\n        else{\\n            ListNode* curr = head;\\n            ListNode* prev = NULL;\\n            while(count < k && curr!= NULL){\\n                prev = curr;\\n                curr = curr->next;\\n                count++;\\n                n--;\\n            }\\n            prev->next = reveven(curr,k+1,n);\\n            return head;\\n        }\\n    }\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        \\n        if(head==NULL) return head;\\n        int n = 0;\\n        ListNode* temp = head;\\n        while(temp!=NULL){\\n            temp= temp->next;\\n            n++;\\n        }\\n\\n        return reveven(head, 1,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3578732,
                "title": "python-solution-use-4-pointers-with-clear-explanation",
                "content": "This solution was inspired by @astroash\\'s C++ solution, which can be found at https://leetcode.com/problems/reverse-nodes-in-even-length-groups/solutions/1576952/c-well-commented-clear-code-idea-explained-in-brief/. \\nThis is an implementation of the same solution in Python. The key aspects of this solution will be outlined in this post, with emphasis on the major features and the steps taken to solve the problem.\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis problem is essentially a variant of the \\'partial reverse linked list\\' problem, where we only reverse parts of the linked list based on some criteria. In this case, we reverse parts of the linked list that fall into groups of even lengths. Key points in solving this type of problem include:\\n\\n1. Identify the **pattern** of the specific part of the linked list that needs to be reversed and divide it into groups.\\n2. Understand the role of the **prev**, **head**, **tail**, and **next_head** pointers:\\n   - **prev** refers to the node **before** the pattern group. It links the reversed group back to the unmodified part of the list.\\n   - **head** refers to the **start** of the pattern group, which becomes the tail after the group is reversed.\\n   - **tail** refers to the **end** of the pattern group, which becomes the head after the group is reversed.\\n   - **next_head** refers to the **start** of the next group. It links the reversed group to the next part of the list.\\n3. Deal with **edge** conditions. A sentinel node is useful in dealing with edge conditions that may occur at the head or end of the linked list.\\n\\n# Approach\\n![\\u672A\\u547D\\u540D\\u6587\\u4EF6 (16).png](https://assets.leetcode.com/users/images/55cbcf64-5288-4bd4-bceb-a0963d00a90e_1685449691.6244676.png)\\n\\nWe first segment the linked list into different groups based on the provided conditions. We then check each group and reverse it if its length is even. The reversal is achieved using the prev, head, tail, and next_head pointers.\\n\\n1. We define a helper function, `reverse()`, that reverses a linked list from a specified head node and returns the head of the reversed list.\\n2. We create a sentinel node that will aid in handling edge conditions. It also simplifies our code by providing a uniform starting point for each group.\\n3. For each length from 1 to 100000, we manually segment the linked list into groups. For each group, we identify the head, tail, and next_head nodes.\\n4. We check if the group is of even length. If it is, we reverse it by calling our `reverse()` function, and then link the reversed group back to the list.\\n\\n# Complexity\\n\\n- Time complexity: O(n), where n is the number of nodes in the linked list.\\n- Space complexity: O(1), because no additional space is used apart from the original linked list.\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        def reverse(head):\\n            if not head:\\n                return head\\n            prev = None\\n            while head:\\n                next_node = head.next\\n                head.next = prev\\n                prev = head\\n                head = next_node\\n            return prev\\n\\n        sentinel = ListNode(0, head)\\n        prev = sentinel\\n        for length in range(1, 100000):\\n            if not head:\\n                break\\n            tail = head\\n            j = 1\\n            while j < length and tail and tail.next:\\n                tail = tail.next\\n                j += 1\\n\\n            next_head = tail.next\\n\\n            if j % 2 == 0:\\n                tail.next = None\\n                prev.next = reverse(head)\\n                head.next = next_head\\n                prev = head\\n                head = next_head\\n            else:\\n                prev = tail\\n                head = next_head\\n\\n        return sentinel.next\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        def reverse(head):\\n            if not head:\\n                return head\\n            prev = None\\n            while head:\\n                next_node = head.next\\n                head.next = prev\\n                prev = head\\n                head = next_node\\n            return prev\\n\\n        sentinel = ListNode(0, head)\\n        prev = sentinel\\n        for length in range(1, 100000):\\n            if not head:\\n                break\\n            tail = head\\n            j = 1\\n            while j < length and tail and tail.next:\\n                tail = tail.next\\n                j += 1\\n\\n            next_head = tail.next\\n\\n            if j % 2 == 0:\\n                tail.next = None\\n                prev.next = reverse(head)\\n                head.next = next_head\\n                prev = head\\n                head = next_head\\n            else:\\n                prev = tail\\n                head = next_head\\n\\n        return sentinel.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3287091,
                "title": "simple-c-solution-faster-than-97",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        ListNode *cur=head,*prev=NULL;\\n        int count=0;\\n        while(cur){\\n            count++;\\n            cur=cur->next;\\n        }\\n        cur=head;\\n        int grpNo=1;\\n        while(cur && grpNo<=count){\\n            int x=grpNo;\\n            while(cur && x){\\n                prev=cur;\\n                cur=cur->next;\\n                x--;\\n            }\\n            count-=grpNo;\\n            grpNo++;\\n            if(cur && grpNo<=count){\\n                ListNode *nxt;\\n                x=grpNo;\\n                while(cur->next && x-1>0){\\n                    nxt=cur->next;\\n                    cur->next=nxt->next;\\n                    nxt->next=prev->next;\\n                    prev->next=nxt;\\n                    x--;\\n                }\\n                prev=cur;\\n                cur=cur->next;\\n                count-=grpNo;\\n                grpNo++;\\n            }\\n            else\\n                break;\\n        }\\n        if(count && count%2==0){\\n            ListNode *nxt;\\n                int x=count;\\n                while(cur->next && x-1>0){\\n                    nxt=cur->next;\\n                    cur->next=nxt->next;\\n                    nxt->next=prev->next;\\n                    prev->next=nxt;\\n                    x--;\\n                }\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        ListNode *cur=head,*prev=NULL;\\n        int count=0;\\n        while(cur){\\n            count++;\\n            cur=cur->next;\\n        }\\n        cur=head;\\n        int grpNo=1;\\n        while(cur && grpNo<=count){\\n            int x=grpNo;\\n            while(cur && x){\\n                prev=cur;\\n                cur=cur->next;\\n                x--;\\n            }\\n            count-=grpNo;\\n            grpNo++;\\n            if(cur && grpNo<=count){\\n                ListNode *nxt;\\n                x=grpNo;\\n                while(cur->next && x-1>0){\\n                    nxt=cur->next;\\n                    cur->next=nxt->next;\\n                    nxt->next=prev->next;\\n                    prev->next=nxt;\\n                    x--;\\n                }\\n                prev=cur;\\n                cur=cur->next;\\n                count-=grpNo;\\n                grpNo++;\\n            }\\n            else\\n                break;\\n        }\\n        if(count && count%2==0){\\n            ListNode *nxt;\\n                int x=count;\\n                while(cur->next && x-1>0){\\n                    nxt=cur->next;\\n                    cur->next=nxt->next;\\n                    nxt->next=prev->next;\\n                    prev->next=nxt;\\n                    x--;\\n                }\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3143164,
                "title": "o-n-java-solutions-beats-97",
                "content": "# Approach\\nUse sliding window idea by keeping track of last node (of previous group), left node (of current group), pointer node (traverse list), groupSize, count of nodes in current group.\\n\\nOnce you start iterating, you will have to reverse current group if it meets the 2 conditions.\\n1. Count == groupSize\\n2. groupSize is even\\n\\nYou reverse and connect the reversed list back to your main list. Then you must update your iteration pointer since it will be in the back of the reversed list.\\n\\nAlso update last seen node (of previous group), new left node, count, and groupsize.\\n\\nDo the same reverse for the remaining nodes.\\n\\n# Complexity\\n- Time complexity:\\nO(N): One iteration of list is done.\\n\\n- Space complexity:\\nO(1): Constant # of variables/pointers\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        if(head == null) return head;\\n\\n        int groupSize = 1;\\n        int count = 0;\\n        ListNode left = null;\\n        ListNode ptr = head;\\n        ListNode last = null;\\n        \\n        while(ptr != null) {\\n            count++;\\n            if(count == groupSize) {\\n                if(groupSize  % 2 == 0) {\\n                    ListNode end = ptr.next;\\n                   // reverse\\n                    ListNode cur = left;\\n                    ListNode next = null;\\n                    ListNode prev = ptr.next;\\n                    while(cur != end) {\\n                        next = cur.next;\\n                        cur.next = prev;\\n                        prev = cur;\\n                        cur = next;\\n                    }\\n                    // connect\\n                    last.next = prev;\\n                    ptr = left;\\n                   \\n                }\\n                last = ptr;\\n                left = ptr.next;\\n                count = 0;\\n                groupSize++;\\n            }\\n            ptr = ptr.next;\\n        }\\n\\n        if(count > 0 && count % 2 == 0) {\\n            // reverse\\n            ListNode cur = left;\\n            ListNode next = null;\\n            ListNode prev = ptr;\\n\\n            while(cur != null) {\\n                next = cur.next;\\n                cur.next = prev;\\n                prev = cur;\\n                cur = next;\\n            }\\n\\n            last.next = prev;\\n        }\\n\\n        return head;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        if(head == null) return head;\\n\\n        int groupSize = 1;\\n        int count = 0;\\n        ListNode left = null;\\n        ListNode ptr = head;\\n        ListNode last = null;\\n        \\n        while(ptr != null) {\\n            count++;\\n            if(count == groupSize) {\\n                if(groupSize  % 2 == 0) {\\n                    ListNode end = ptr.next;\\n                   // reverse\\n                    ListNode cur = left;\\n                    ListNode next = null;\\n                    ListNode prev = ptr.next;\\n                    while(cur != end) {\\n                        next = cur.next;\\n                        cur.next = prev;\\n                        prev = cur;\\n                        cur = next;\\n                    }\\n                    // connect\\n                    last.next = prev;\\n                    ptr = left;\\n                   \\n                }\\n                last = ptr;\\n                left = ptr.next;\\n                count = 0;\\n                groupSize++;\\n            }\\n            ptr = ptr.next;\\n        }\\n\\n        if(count > 0 && count % 2 == 0) {\\n            // reverse\\n            ListNode cur = left;\\n            ListNode next = null;\\n            ListNode prev = ptr;\\n\\n            while(cur != null) {\\n                next = cur.next;\\n                cur.next = prev;\\n                prev = cur;\\n                cur = next;\\n            }\\n\\n            last.next = prev;\\n        }\\n\\n        return head;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2849465,
                "title": "python-solution-using-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        gr = 1\\n        stack = []\\n\\n        node = head\\n\\n        while(node):\\n            stack = []\\n\\n            temp = node\\n\\n            for _ in range(gr):\\n\\n                if temp == None:\\n                    break\\n\\n                stack.append(temp.val)\\n                temp = temp.next\\n\\n            if len(stack)%2 == 0:\\n                while(stack):\\n                    node.val = stack.pop()\\n                    node = node.next\\n            else:\\n                for _ in range(gr):\\n                    if node == None:\\n                        break\\n\\n                    node = node.next\\n\\n            gr += 1\\n\\n        return head\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List",
                    "Stack"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        gr = 1\\n        stack = []\\n\\n        node = head\\n\\n        while(node):\\n            stack = []\\n\\n            temp = node\\n\\n            for _ in range(gr):\\n\\n                if temp == None:\\n                    break\\n\\n                stack.append(temp.val)\\n                temp = temp.next\\n\\n            if len(stack)%2 == 0:\\n                while(stack):\\n                    node.val = stack.pop()\\n                    node = node.next\\n            else:\\n                for _ in range(gr):\\n                    if node == None:\\n                        break\\n\\n                    node = node.next\\n\\n            gr += 1\\n\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2809531,
                "title": "java-solution",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    \\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        ListNode dummy = new ListNode(0, head);\\n        ListNode prev = dummy;\\n        int groupSize = 1;\\n        while(prev.next != null) {\\n            ListNode curr = prev;\\n            int count = 0;\\n            for(int i = 0; i < groupSize && curr.next != null; ++i) {\\n                curr = curr.next;\\n                count += 1;\\n            }\\n            \\n            if(count % 2 == 0) {\\n                ListNode nextGroupHead = curr.next;\\n                curr.next = null;\\n                \\n                ListNode groupHead = prev.next;\\n                prev.next = reverseList(groupHead);\\n                groupHead.next = nextGroupHead;\\n                prev = groupHead;\\n            } else {\\n                prev = curr;\\n            }\\n            \\n            groupSize += 1;\\n        }\\n        \\n        return dummy.next;\\n    }\\n    \\n    private ListNode reverseList(ListNode node) {\\n        ListNode prev = null;\\n        while(node != null) {\\n            ListNode next = node.next;\\n            node.next = prev;\\n            prev = node;\\n            node = next;\\n        }\\n        return prev;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    \\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        ListNode dummy = new ListNode(0, head);\\n        ListNode prev = dummy;\\n        int groupSize = 1;\\n        while(prev.next != null) {\\n            ListNode curr = prev;\\n            int count = 0;\\n            for(int i = 0; i < groupSize && curr.next != null; ++i) {\\n                curr = curr.next;\\n                count += 1;\\n            }\\n            \\n            if(count % 2 == 0) {\\n                ListNode nextGroupHead = curr.next;\\n                curr.next = null;\\n                \\n                ListNode groupHead = prev.next;\\n                prev.next = reverseList(groupHead);\\n                groupHead.next = nextGroupHead;\\n                prev = groupHead;\\n            } else {\\n                prev = curr;\\n            }\\n            \\n            groupSize += 1;\\n        }\\n        \\n        return dummy.next;\\n    }\\n    \\n    private ListNode reverseList(ListNode node) {\\n        ListNode prev = null;\\n        while(node != null) {\\n            ListNode next = node.next;\\n            node.next = prev;\\n            prev = node;\\n            node = next;\\n        }\\n        return prev;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2782454,
                "title": "java-concise",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n\\n// 12:29\\n\\nclass Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        if (head == null || head.next == null)\\n            return head;\\n        \\n        int groupSize = 1;\\n        ListNode current = head, lastOfGroup = new ListNode(-1);\\n\\n        while(current != null) {\\n            ListNode start = current, last = null, temp = current;\\n            int size = 0;\\n            while(size < groupSize && temp != null) {\\n                temp = temp.next;\\n                size++;\\n            }\\n        \\n            if (size % 2 == 0) {\\n                lastOfGroup.next = reverse(start, temp);\\n                lastOfGroup = start;\\n                current = temp;\\n            } else {\\n                current = start;\\n                for(int j = 1; j <= groupSize; j++) {\\n                    if (current != null) {\\n                        lastOfGroup.next = current; \\n                        current = current.next;\\n                        lastOfGroup = lastOfGroup.next;\\n                    }\\n                }\\n            }\\n            groupSize++;\\n        }\\n        return head;\\n    }\\n\\n    private ListNode reverse(ListNode head, ListNode tail) {\\n        ListNode current = head, prev = null, next = null;\\n        while(current != tail) {\\n            next = current.next;\\n            current.next = prev;\\n            prev = current;\\n            current = next;\\n        }\\n        return prev;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n\\n// 12:29\\n\\nclass Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        if (head == null || head.next == null)\\n            return head;\\n        \\n        int groupSize = 1;\\n        ListNode current = head, lastOfGroup = new ListNode(-1);\\n\\n        while(current != null) {\\n            ListNode start = current, last = null, temp = current;\\n            int size = 0;\\n            while(size < groupSize && temp != null) {\\n                temp = temp.next;\\n                size++;\\n            }\\n        \\n            if (size % 2 == 0) {\\n                lastOfGroup.next = reverse(start, temp);\\n                lastOfGroup = start;\\n                current = temp;\\n            } else {\\n                current = start;\\n                for(int j = 1; j <= groupSize; j++) {\\n                    if (current != null) {\\n                        lastOfGroup.next = current; \\n                        current = current.next;\\n                        lastOfGroup = lastOfGroup.next;\\n                    }\\n                }\\n            }\\n            groupSize++;\\n        }\\n        return head;\\n    }\\n\\n    private ListNode reverse(ListNode head, ListNode tail) {\\n        ListNode current = head, prev = null, next = null;\\n        while(current != tail) {\\n            next = current.next;\\n            current.next = prev;\\n            prev = current;\\n            current = next;\\n        }\\n        return prev;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2598790,
                "title": "c-solution",
                "content": "```\\nListNode* reverse(ListNode* head,int k)\\n    {\\n        if(!head or !head->next) return head;\\n        //useful in finding len and in odd case\\n        ListNode* cur = head, *tail = head;\\n        int len = 0;\\n        //finding length of every segment each time\\n        while(cur && len < k) {\\n            tail = cur;\\n            cur = cur->next;\\n            len++;\\n        }\\n        // cout<<len<<\" \";\\n        if(len%2==0)\\n        {\\n            int cnt=len;\\n            ListNode* prev=nullptr,*cur=head,*n;\\n            while(cur and cnt--)\\n            {\\n                n=cur->next;\\n                cur->next=prev;\\n                prev=cur;\\n                cur=n;\\n            }\\n            \\n            head->next=reverse(n,len+1);\\n            return prev;\\n        }\\n        tail->next=reverse(cur,len+1);\\n        return head;        \\n    }\\n    \\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        if(!head or !head->next) return head;\\n        return reverse(head,1);\\n        \\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nListNode* reverse(ListNode* head,int k)\\n    {\\n        if(!head or !head->next) return head;\\n        //useful in finding len and in odd case\\n        ListNode* cur = head, *tail = head;\\n        int len = 0;\\n        //finding length of every segment each time\\n        while(cur && len < k) {\\n            tail = cur;\\n            cur = cur->next;\\n            len++;\\n        }\\n        // cout<<len<<\" \";\\n        if(len%2==0)\\n        {\\n            int cnt=len;\\n            ListNode* prev=nullptr,*cur=head,*n;\\n            while(cur and cnt--)\\n            {\\n                n=cur->next;\\n                cur->next=prev;\\n                prev=cur;\\n                cur=n;\\n            }\\n            \\n            head->next=reverse(n,len+1);\\n            return prev;\\n        }\\n        tail->next=reverse(cur,len+1);\\n        return head;        \\n    }\\n    \\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        if(!head or !head->next) return head;\\n        return reverse(head,1);\\n        \\n    }\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2495340,
                "title": "python-easy-to-catch-o-n",
                "content": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\n\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if head.next == None:\\n            return head\\n        last: Optional[ListNode] = head\\n        first: Optional[ListNode] = head\\n        prev: Optional[ListNode] = head\\n        lastprev: Optional[ListNode] = head\\n        group: int = 1\\n        length: int = 1\\n            \\n        while last:\\n            # length += 1\\n            if length == group:\\n                if length%2==0:\\n                    prev.next = last\\n                    nextG = last.next\\n                    prev = self.reverse(first,last)\\n                    prev.next = nextG\\n                    last = nextG   \\n                    first = nextG\\n                    group += 1\\n                    length = 1\\n                    continue\\n                \\n                first = last.next\\n                prev = last\\n                group += 1\\n                length = 1\\n                last = last.next\\n                continue\\n            length += 1\\n            lastprev = last\\n            last = last.next\\n            \\n        if (length - 1) != 0 and (length - 1)%2==0:\\n            prev.next = lastprev\\n            self.reverse(first,lastprev).next = last\\n        return head\\n        \\n    def reverse(self,first: Optional[ListNode],last: Optional[ListNode]):\\n        \\n        # to reverse\\n        prev: Optional[ListNode] = None\\n        current: Optional[ListNode] = first\\n        last: Optional[ListNode] = last.next\\n        temp: Optional[ListNode]\\n            \\n        while (current != last):\\n            temp = current.next\\n            current.next = prev\\n            prev = current\\n            current = temp\\n        \\n        return first\\n```",
                "solutionTags": [
                    "Python",
                    "Linked List"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\n\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if head.next == None:\\n            return head\\n        last: Optional[ListNode] = head\\n        first: Optional[ListNode] = head\\n        prev: Optional[ListNode] = head\\n        lastprev: Optional[ListNode] = head\\n        group: int = 1\\n        length: int = 1\\n            \\n        while last:\\n            # length += 1\\n            if length == group:\\n                if length%2==0:\\n                    prev.next = last\\n                    nextG = last.next\\n                    prev = self.reverse(first,last)\\n                    prev.next = nextG\\n                    last = nextG   \\n                    first = nextG\\n                    group += 1\\n                    length = 1\\n                    continue\\n                \\n                first = last.next\\n                prev = last\\n                group += 1\\n                length = 1\\n                last = last.next\\n                continue\\n            length += 1\\n            lastprev = last\\n            last = last.next\\n            \\n        if (length - 1) != 0 and (length - 1)%2==0:\\n            prev.next = lastprev\\n            self.reverse(first,lastprev).next = last\\n        return head\\n        \\n    def reverse(self,first: Optional[ListNode],last: Optional[ListNode]):\\n        \\n        # to reverse\\n        prev: Optional[ListNode] = None\\n        current: Optional[ListNode] = first\\n        last: Optional[ListNode] = last.next\\n        temp: Optional[ListNode]\\n            \\n        while (current != last):\\n            temp = current.next\\n            current.next = prev\\n            prev = current\\n            current = temp\\n        \\n        return first\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2494303,
                "title": "python-o-n-01-easy",
                "content": "```\\n  \\nclass Solution:\\n  def length(self,head):\\n    fast= head \\n    count=0\\n    while fast and fast.next:\\n      fast = fast.next.next \\n      count+=2\\n    if fast:\\n      return count+1 \\n    return count \\n  \\n  def reverseEvenLengthGroups(self ,\\n  head):\\n    size = self.length(head)\\n    temp = head \\n    res = None\\n    updater = res \\n    even = False \\n    k = 1\\n    \\n    while (size>=k) or (size<k and size%2==0 and size>1):\\n     \\n      cond = size<k and size%2==0\\n      if (not even) and (not cond):\\n        curr = temp\\n        i = 1 \\n        while i <= k:\\n          if res==None:\\n            res = curr \\n            updater = res \\n          else:\\n            updater.next = curr \\n            updater = curr\\n          curr = curr.next\\n          i = i+1 \\n        temp = curr\\n      \\n     \\n      if even or cond:\\n        if size<k:\\n          k = size\\n        i = 1\\n        curr = temp.next\\n        prev = temp \\n        next_updater = prev \\n        while i  < k:\\n          next = curr.next\\n          curr.next = prev\\n          prev = curr \\n          curr = next \\n          i+=1\\n        \\n        updater.next = prev \\n        updater = next_updater\\n        temp = curr \\n        \\n      even = not even\\n      size -=k\\n      k+=1 \\n    \\n    updater.next = temp \\n    return res \\n```",
                "solutionTags": [
                    "Python",
                    "Linked List"
                ],
                "code": "```\\n  \\nclass Solution:\\n  def length(self,head):\\n    fast= head \\n    count=0\\n    while fast and fast.next:\\n      fast = fast.next.next \\n      count+=2\\n    if fast:\\n      return count+1 \\n    return count \\n  \\n  def reverseEvenLengthGroups(self ,\\n  head):\\n    size = self.length(head)\\n    temp = head \\n    res = None\\n    updater = res \\n    even = False \\n    k = 1\\n    \\n    while (size>=k) or (size<k and size%2==0 and size>1):\\n     \\n      cond = size<k and size%2==0\\n      if (not even) and (not cond):\\n        curr = temp\\n        i = 1 \\n        while i <= k:\\n          if res==None:\\n            res = curr \\n            updater = res \\n          else:\\n            updater.next = curr \\n            updater = curr\\n          curr = curr.next\\n          i = i+1 \\n        temp = curr\\n      \\n     \\n      if even or cond:\\n        if size<k:\\n          k = size\\n        i = 1\\n        curr = temp.next\\n        prev = temp \\n        next_updater = prev \\n        while i  < k:\\n          next = curr.next\\n          curr.next = prev\\n          prev = curr \\n          curr = next \\n          i+=1\\n        \\n        updater.next = prev \\n        updater = next_updater\\n        temp = curr \\n        \\n      even = not even\\n      size -=k\\n      k+=1 \\n    \\n    updater.next = temp \\n    return res \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2250551,
                "title": "most-straightforward-solution-with-comments",
                "content": "\\nclass Solution {\\npublic:\\n\\t\\n\\t// Reverse function to reverse the even length parts of linked list, and returns\\n\\t// the new head and tail of reversed linked list\\n    pair<ListNode*,ListNode*> reverse(ListNode *head)\\n    {\\n        pair<ListNode*,ListNode*>ans;\\n        ans.second = head;\\n        \\n        ListNode *p = head,*q = NULL,*r = NULL;\\n        \\n        while(p)\\n        {\\n            r = q;\\n            q = p;\\n            p = p->next;\\n            q->next = r;\\n        }\\n        head = q;\\n        ans.first = head;\\n        \\n        return ans;\\n    }\\n    \\n    ListNode *helper(ListNode *head,int k)\\n    {\\n         if(head == NULL)\\n        {\\n            return NULL;\\n        }\\n        \\n        ListNode *p = head,*q = head;\\n        ListNode *nhead = NULL,*ntail = NULL;\\n        int i = 1;\\n        \\n        while(q && i < k)\\n        {\\n            q = q->next;\\n            i++;\\n        }\\n        \\n        ListNode *nextHead = NULL;\\n        if(q)\\n        {\\n            nextHead = q->next;\\n            q->next = NULL;\\n        }\\n        \\n\\t\\t// important condition for reverse -> \\n\\t\\t// i) k is even (even length portion) and q!=NULL to ensure that this portion is not\\n\\t\\t// the last portion , (as last portion may have incomplete nodes)\\n\\t\\t\\n\\t\\t// ii) If k is not even but the last portion has even no. of nodes\\n\\t\\t// (i-1)%2 == 0 for even no. of nodes, i is increased +1 more before exit so -1 is done\\n\\t\\t// and q == NULL to ensure that this is the incomplete nodes portion the last portion\\n\\n        if((k%2 == 0 && q!=NULL)) || (q == NULL && (i-1)%2 == 0))\\n        {\\n            pair<ListNode*,ListNode*> ans = reverse(p);\\n            nhead = ans.first;\\n            ntail = ans.second; \\n        }\\n        else\\n        {\\n            nhead = p;\\n            ntail = q;\\n        }\\n        \\n        if(ntail)\\n        {\\n            ntail->next = helper(nextHead,k+1);\\n\\t\\t\\t// k+1 for next portion\\n        }\\n        \\n        return nhead;\\n    }\\n    \\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        if(head == NULL)\\n        {\\n            return NULL;\\n        }\\n        \\n        return helper(head,1);\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Linked List",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n\\t\\n\\t// Reverse function to reverse the even length parts of linked list, and returns\\n\\t// the new head and tail of reversed linked list\\n    pair<ListNode*,ListNode*> reverse(ListNode *head)\\n    {\\n        pair<ListNode*,ListNode*>ans;\\n        ans.second = head;\\n        \\n        ListNode *p = head,*q = NULL,*r = NULL;\\n        \\n        while(p)\\n        {\\n            r = q;\\n            q = p;\\n            p = p->next;\\n            q->next = r;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2234029,
                "title": "c-solution-o-n-time",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    ListNode* reverse(ListNode* head)\\n    {\\n        if(head == NULL) return NULL;\\n        if(head->next == NULL) return head;\\n        ListNode* tmp = NULL;\\n        ListNode* trav = head;\\n        ListNode *flag = head->next;\\n        \\n        while(trav != NULL)\\n        {\\n            trav->next = tmp;\\n            tmp = trav;\\n            trav = flag;\\n            if(flag != NULL) flag = flag->next;\\n        }\\n        \\n        return tmp;\\n    }\\n    \\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        \\n        if(head == NULL) return NULL;\\n        if(head->next == NULL) return head;\\n        \\n        int len = 1, temp;\\n        vector<ListNode*> v;\\n        ListNode* trav = head;\\n        ListNode* tmp = NULL;\\n        int count = 0;\\n        \\n        while(trav != NULL)\\n        {\\n            v.push_back(trav);\\n            temp = len;\\n            for(int i=0; i<temp-1; i++)\\n            {\\n                if(trav == NULL) break;\\n                trav = trav->next;\\n            }\\n            if(trav != NULL)\\n            {\\n                tmp = trav->next;\\n                trav->next = NULL;\\n                trav = tmp;\\n                len++;\\n            }\\n            \\n        }\\n        \\n        for(int i=1; i<v.size()-1; i++)\\n        {\\n            v[i] = reverse(v[i]);\\n            i++; \\n        }\\n                \\n        for(int i=0; i<v.size()-1; i++)\\n        {\\n            trav = v[i];\\n            while(trav->next != NULL)\\n            {\\n                trav = trav->next;\\n            }\\n            if(i != v.size()-2) trav->next = v[i+1];\\n        }\\n        \\n        tmp = trav;\\n        \\n        trav = v[v.size()-1];\\n        while(trav != NULL)\\n        {\\n            trav = trav->next;\\n            count++;\\n        }\\n        \\n        if(count % 2 == 0)\\n        {\\n            v[v.size()-1] = reverse(v[v.size()-1]);\\n        }\\n        \\n        tmp->next = v[v.size()-1];\\n        \\n        return v[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    ListNode* reverse(ListNode* head)\\n    {\\n        if(head == NULL) return NULL;\\n        if(head->next == NULL) return head;\\n        ListNode* tmp = NULL;\\n        ListNode* trav = head;\\n        ListNode *flag = head->next;\\n        \\n        while(trav != NULL)\\n        {\\n            trav->next = tmp;\\n            tmp = trav;\\n            trav = flag;\\n            if(flag != NULL) flag = flag->next;\\n        }\\n        \\n        return tmp;\\n    }\\n    \\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        \\n        if(head == NULL) return NULL;\\n        if(head->next == NULL) return head;\\n        \\n        int len = 1, temp;\\n        vector<ListNode*> v;\\n        ListNode* trav = head;\\n        ListNode* tmp = NULL;\\n        int count = 0;\\n        \\n        while(trav != NULL)\\n        {\\n            v.push_back(trav);\\n            temp = len;\\n            for(int i=0; i<temp-1; i++)\\n            {\\n                if(trav == NULL) break;\\n                trav = trav->next;\\n            }\\n            if(trav != NULL)\\n            {\\n                tmp = trav->next;\\n                trav->next = NULL;\\n                trav = tmp;\\n                len++;\\n            }\\n            \\n        }\\n        \\n        for(int i=1; i<v.size()-1; i++)\\n        {\\n            v[i] = reverse(v[i]);\\n            i++; \\n        }\\n                \\n        for(int i=0; i<v.size()-1; i++)\\n        {\\n            trav = v[i];\\n            while(trav->next != NULL)\\n            {\\n                trav = trav->next;\\n            }\\n            if(i != v.size()-2) trav->next = v[i+1];\\n        }\\n        \\n        tmp = trav;\\n        \\n        trav = v[v.size()-1];\\n        while(trav != NULL)\\n        {\\n            trav = trav->next;\\n            count++;\\n        }\\n        \\n        if(count % 2 == 0)\\n        {\\n            v[v.size()-1] = reverse(v[v.size()-1]);\\n        }\\n        \\n        tmp->next = v[v.size()-1];\\n        \\n        return v[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2118503,
                "title": "trick-to-solve-it-very-easily",
                "content": "```\\n// This Question can be solved easily using two standard methods of LinkedList\\n// 1) addFirst (it adds node in front of the LinkedList)\\n// 2) addLast (it adds node in end of the LinkedList)\\n\\nclass Solution {\\n    \\n    static ListNode oh;\\n    static ListNode ot;\\n    static ListNode th;\\n    static ListNode tt;\\n    \\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        \\n        oh = null;\\n        ot = null;\\n        th = null;\\n        tt = null;\\n        \\n        if(head == null || head.next == null)\\n            return head;\\n        \\n        int size = length(head);\\n        int idx = 1;\\n        ListNode curr = head;\\n        int group = 1;\\n        \\n        while(curr!=null)\\n        {\\n            int temp = size - idx + 1;\\n            if((temp>=group && group%2 == 0) || (temp<group && temp%2 == 0))\\n            {\\n                int k = group;\\n                while(k-->0 && curr!=null)\\n                {\\n                    ListNode t = curr.next;\\n                    curr.next = null;\\n                    addFirst(curr);\\n                    curr = t;\\n                    idx++;\\n                }\\n            }\\n            else\\n            { \\n                int k = group;\\n                while(k-->0 && curr!=null)\\n                {\\n                    ListNode t = curr.next;\\n                    curr.next = null;\\n                    addLast(curr);\\n                    curr = t;\\n                    idx++;\\n                }\\n            }\\n            \\n            if(oh==null && ot==null)\\n            {\\n                oh = th;\\n                ot = tt;\\n            }\\n            else\\n            {\\n                ot.next = th;\\n                ot = tt;\\n            }\\n            \\n            th = null;\\n            tt = null;\\n            group++;\\n        }\\n        \\n        return oh;\\n    }\\n    \\n    public int length (ListNode head)\\n    {\\n        if(head==null) return 0;\\n        ListNode curr = head;\\n        int k = 0;\\n        while(curr!=null)\\n        {\\n             k++;\\n            curr = curr.next;\\n        }\\n        return k;\\n    }\\n    \\n    public void addFirst(ListNode head)\\n    {\\n        if(tt == null && th == null)\\n        {\\n            th = head;\\n            tt = head;\\n        }\\n        else\\n        {\\n            head.next = th;\\n            th = head;\\n        }\\n    }\\n    \\n    public void addLast(ListNode head)\\n    {\\n        if(tt == null && th == null)\\n        {\\n            th = head;\\n            tt = head;\\n        }\\n        else\\n        {\\n            tt.next = head;\\n            tt = head;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// This Question can be solved easily using two standard methods of LinkedList\\n// 1) addFirst (it adds node in front of the LinkedList)\\n// 2) addLast (it adds node in end of the LinkedList)\\n\\nclass Solution {\\n    \\n    static ListNode oh;\\n    static ListNode ot;\\n    static ListNode th;\\n    static ListNode tt;\\n    \\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        \\n        oh = null;\\n        ot = null;\\n        th = null;\\n        tt = null;\\n        \\n        if(head == null || head.next == null)\\n            return head;\\n        \\n        int size = length(head);\\n        int idx = 1;\\n        ListNode curr = head;\\n        int group = 1;\\n        \\n        while(curr!=null)\\n        {\\n            int temp = size - idx + 1;\\n            if((temp>=group && group%2 == 0) || (temp<group && temp%2 == 0))\\n            {\\n                int k = group;\\n                while(k-->0 && curr!=null)\\n                {\\n                    ListNode t = curr.next;\\n                    curr.next = null;\\n                    addFirst(curr);\\n                    curr = t;\\n                    idx++;\\n                }\\n            }\\n            else\\n            { \\n                int k = group;\\n                while(k-->0 && curr!=null)\\n                {\\n                    ListNode t = curr.next;\\n                    curr.next = null;\\n                    addLast(curr);\\n                    curr = t;\\n                    idx++;\\n                }\\n            }\\n            \\n            if(oh==null && ot==null)\\n            {\\n                oh = th;\\n                ot = tt;\\n            }\\n            else\\n            {\\n                ot.next = th;\\n                ot = tt;\\n            }\\n            \\n            th = null;\\n            tt = null;\\n            group++;\\n        }\\n        \\n        return oh;\\n    }\\n    \\n    public int length (ListNode head)\\n    {\\n        if(head==null) return 0;\\n        ListNode curr = head;\\n        int k = 0;\\n        while(curr!=null)\\n        {\\n             k++;\\n            curr = curr.next;\\n        }\\n        return k;\\n    }\\n    \\n    public void addFirst(ListNode head)\\n    {\\n        if(tt == null && th == null)\\n        {\\n            th = head;\\n            tt = head;\\n        }\\n        else\\n        {\\n            head.next = th;\\n            th = head;\\n        }\\n    }\\n    \\n    public void addLast(ListNode head)\\n    {\\n        if(tt == null && th == null)\\n        {\\n            th = head;\\n            tt = head;\\n        }\\n        else\\n        {\\n            tt.next = head;\\n            tt = head;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2102638,
                "title": "c-solution",
                "content": "Approach: **T.C -> O(n), S.C -> O(1)**\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        ListNode* prev = nullptr, *next = nullptr, *curr = head;\\n        while(curr) {\\n            next = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = next;\\n        }\\n        return prev;\\n    }\\n    \\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        \\n        ListNode* dummy = new ListNode(0);\\n        dummy->next = head;\\n        ListNode* prev = dummy;\\n        \\n        for(int len = 1; len <= 1e5 && head; len++) {\\n            // len denotes the max length of a current group\\n            ListNode* tail = head;\\n            ListNode* nextHead;\\n            \\n            // Determine the length of the current group\\n            int j = 1;\\n            while(j < len and tail and tail->next) {\\n                tail = tail->next;\\n                j++;\\n            }\\n            \\n            nextHead = tail->next;\\n            \\n            if(j % 2 == 0) {\\n                \\n                // isolate and reverse the group\\n                tail->next = nullptr;\\n                prev->next = reverseList(head);\\n                prev = head;\\n                head->next = nextHead;\\n                head = nextHead;\\n            }\\n            \\n            else {\\n                prev = tail;\\n                head = nextHead;\\n            }\\n        }\\n        \\n        return dummy->next;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        ListNode* prev = nullptr, *next = nullptr, *curr = head;\\n        while(curr) {\\n            next = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = next;\\n        }\\n        return prev;\\n    }\\n    \\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        \\n        ListNode* dummy = new ListNode(0);\\n        dummy->next = head;\\n        ListNode* prev = dummy;\\n        \\n        for(int len = 1; len <= 1e5 && head; len++) {\\n            // len denotes the max length of a current group\\n            ListNode* tail = head;\\n            ListNode* nextHead;\\n            \\n            // Determine the length of the current group\\n            int j = 1;\\n            while(j < len and tail and tail->next) {\\n                tail = tail->next;\\n                j++;\\n            }\\n            \\n            nextHead = tail->next;\\n            \\n            if(j % 2 == 0) {\\n                \\n                // isolate and reverse the group\\n                tail->next = nullptr;\\n                prev->next = reverseList(head);\\n                prev = head;\\n                head->next = nextHead;\\n                head = nextHead;\\n            }\\n            \\n            else {\\n                prev = tail;\\n                head = nextHead;\\n            }\\n        }\\n        \\n        return dummy->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2084250,
                "title": "brute-force-cpp",
                "content": "```\\n ListNode* curr=head;\\n        vector<int>v;\\n        while(curr!=NULL)\\n        {\\n            v.push_back(curr->val);\\n            curr=curr->next;\\n        }\\n        int n=v.size();\\n        int k=1,i=0;\\n        while(n>1)\\n        {\\n            if(k==1)\\n            {\\n                n-=1;\\n                k++;\\n                i++;\\n            }\\n            if(k%2==0&&n>=k)\\n            {\\n                n-=k;\\n                reverse(v.begin()+i,v.begin()+i+k);\\n                i+=k;\\n                k++;\\n            }\\n            else if(k%2!=0&&n>=k)\\n            {\\n                n-=k;\\n                i+=k;\\n                k++;\\n            }\\n            else if(n<k&&n%2==0)\\n            {\\n                reverse(v.begin()+i,v.end());\\n                n-=k;\\n            }\\n            else\\n                break;\\n            \\n        }\\n        \\n        ListNode* res=new ListNode(0);\\n        ListNode* a=res;\\n        for(auto x:v)\\n        {\\n            a->next=new ListNode(x);\\n            a=a->next;\\n        }\\n        return res->next;\\n```",
                "solutionTags": [],
                "code": "```\\n ListNode* curr=head;\\n        vector<int>v;\\n        while(curr!=NULL)\\n        {\\n            v.push_back(curr->val);\\n            curr=curr->next;\\n        }\\n        int n=v.size();\\n        int k=1,i=0;\\n        while(n>1)\\n        {\\n            if(k==1)\\n            {\\n                n-=1;\\n                k++;\\n                i++;\\n            }\\n            if(k%2==0&&n>=k)\\n            {\\n                n-=k;\\n                reverse(v.begin()+i,v.begin()+i+k);\\n                i+=k;\\n                k++;\\n            }\\n            else if(k%2!=0&&n>=k)\\n            {\\n                n-=k;\\n                i+=k;\\n                k++;\\n            }\\n            else if(n<k&&n%2==0)\\n            {\\n                reverse(v.begin()+i,v.end());\\n                n-=k;\\n            }\\n            else\\n                break;\\n            \\n        }\\n        \\n        ListNode* res=new ListNode(0);\\n        ListNode* a=res;\\n        for(auto x:v)\\n        {\\n            a->next=new ListNode(x);\\n            a=a->next;\\n        }\\n        return res->next;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1925750,
                "title": "c-easy-stack-solution",
                "content": "\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tListNode* reverseEvenLengthGroups(ListNode* head) {\\n\\t\\t\\tListNode* root = head->next;\\n\\t\\t\\tfor(int i = 2; root; i++){\\n\\t\\t\\t\\t\\tstack<int>s; \\n\\t\\t\\t\\t\\tListNode* tmp = root;\\n\\t\\t\\t\\t\\tint cnt = 0;\\n\\t\\t\\t\\t\\twhile(cnt!=i and tmp) cnt++,s.push(tmp->val),tmp = tmp->next; \\n\\t\\t\\t\\t\\tif((i%2==0 and cnt==i) or (cnt%2==0 and !tmp)){\\n\\t\\t\\t\\t\\t\\twhile(cnt--){\\n\\t\\t\\t\\t\\t\\t\\troot->val = s.top();s.pop(); root = root->next;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse root = tmp;\\n\\t\\t\\t}\\n\\t\\t\\treturn head;\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tListNode* reverseEvenLengthGroups(ListNode* head) {\\n\\t\\t\\tListNode* root = head->next;\\n\\t\\t\\tfor(int i = 2; root; i++){\\n\\t\\t\\t\\t\\tstack<int>s; \\n\\t\\t\\t\\t\\tListNode* tmp = root;\\n\\t\\t\\t\\t\\tint cnt = 0;\\n\\t\\t\\t\\t\\twhile(cnt!=i and tmp) cnt++,s.push(tmp->val),tmp = tmp->next; \\n\\t\\t\\t\\t\\tif((i%2==0 and cnt==i) or (cnt%2==0 and !tmp)){\\n\\t\\t\\t\\t\\t\\twhile(cnt--){\\n\\t\\t\\t\\t\\t\\t\\troot->val = s.top();s.pop(); root = root->next;\\n\\t\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1822855,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode *helper(ListNode *head,int reqLen,ListNode *parent) {\\n        if(!head || !head->next) {\\n            return head;\\n        }\\n        int count=1;\\n        ListNode *tmp=head;\\n        while(count<reqLen && tmp) {\\n            tmp=tmp->next;\\n            count++;\\n        }\\n        if(!tmp) {\\n            count--;\\n        }\\n        if(count%2==0) {\\n            ListNode *later=NULL,*curr=head,*prev=NULL,*target=tmp?tmp->next:NULL;\\n            if(parent) {\\n                parent->next=NULL;\\n            }\\n            while(curr!=target) {\\n                later=curr->next;\\n                curr->next=prev;\\n                prev=curr;\\n                curr=later;\\n            }\\n            if(parent) {\\n                parent->next=prev;\\n            }\\n            head->next=target?helper(target,reqLen+1,head):head->next;\\n            return prev;\\n        }\\n        else {\\n            if(parent) {\\n                parent->next=head;\\n            }\\n            if(tmp) {\\n                tmp->next=helper(tmp->next,reqLen+1,tmp);\\n            }\\n            return head;\\n        }\\n    }\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        return helper(head,1,NULL);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode *helper(ListNode *head,int reqLen,ListNode *parent) {\\n        if(!head || !head->next) {\\n            return head;\\n        }\\n        int count=1;\\n        ListNode *tmp=head;\\n        while(count<reqLen && tmp) {\\n            tmp=tmp->next;\\n            count++;\\n        }\\n        if(!tmp) {\\n            count--;\\n        }\\n        if(count%2==0) {\\n            ListNode *later=NULL,*curr=head,*prev=NULL,*target=tmp?tmp->next:NULL;\\n            if(parent) {\\n                parent->next=NULL;\\n            }\\n            while(curr!=target) {\\n                later=curr->next;\\n                curr->next=prev;\\n                prev=curr;\\n                curr=later;\\n            }\\n            if(parent) {\\n                parent->next=prev;\\n            }\\n            head->next=target?helper(target,reqLen+1,head):head->next;\\n            return prev;\\n        }\\n        else {\\n            if(parent) {\\n                parent->next=head;\\n            }\\n            if(tmp) {\\n                tmp->next=helper(tmp->next,reqLen+1,tmp);\\n            }\\n            return head;\\n        }\\n    }\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        return helper(head,1,NULL);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1789918,
                "title": "lc-2074-reverse-nodes-in-even-length-groups-simple-python-maps-iteration",
                "content": "```\\n\\'\\'\\'\\nProblem: LC 2074 - Reverse Nodes in Even Length Groups\\nAuthor: Anando Zaman\\nDifficulty: Medium\\nDate: February 21, 2022\\n\\nNotes:\\nNodes are grouped based on their positions.\\nSo first node is group 1\\nNext two nodes are group 2\\nNext three nodes are group 3\\nNext four nodes are group 4.\\n\\nWe only want to reverse the groups that have even lengths\\nand return head of modified linkedList\\n\\nNOTE:\\nLength of the last group may be less than or equal to 1 + the length of the second to last group.\\n\\n\\nSOLUTION:\\nCreate three helper functions that takes the next node and a length:\\n    - NextHeadAndLastNodes_Reversed: Returns the first and last index of next sublist\\n    - NextHeadAndLastNodes_Reversed: Returns the first and last index of next reversed sublist\\n    - nextValidSubListSize: Returns the max size of the grouping possible\\n\\nUse a local variable to track the desired length of each grouping.\\nWe use the nextValidSubListSize function to determine if that length is possible, if not, return the number of nodes it supports.\\n\\nDepending on whether that result is odd or even, we return the reversed/non-reversed result\\nas a mapping of \\'head\\' and \\'last\\' nodes.\\n\\nUpdate our curr.next to point to the returned sublist, then continue reversing the next group\\nnodes starting at last.next node.\\n\\'\\'\\'\\n\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        \\n        def nextValidSubListSize(head: ListNode, len_: int):\\n            \\n            node_cnt = 0\\n            while head and node_cnt < len_:\\n                head = head.next\\n                node_cnt += 1\\n                \\n            return node_cnt\\n            \\n        \\n        def NextHeadAndLastNodes_Reversed(head: ListNode, len_: int):\\n            if not head:\\n                return {\\'head\\':None, \\'last\\':None}\\n            \\n            last = head\\n            prev, curr = None, head\\n            \\n            while (len_ > 0 and curr):\\n                temp = curr.next\\n                curr.next = prev\\n                prev = curr\\n                curr = temp\\n                len_ -= 1\\n                \\n            new_head = prev\\n            last.next = curr # linkage needed so that we can reference next grouping\\n            return {\\'head\\':new_head, \\'last\\':last}\\n        \\n        def NextHeadAndLastNodes(head: ListNode, len_:int):\\n            if not head:\\n                return {\\'head\\':None, \\'last\\':None}\\n            \\n            prev = None\\n            curr = head\\n            while curr and len_ > 0:\\n                prev = curr\\n                curr = curr.next\\n                len_ -= 1\\n                \\n            return {\\'head\\':head, \\'last\\':prev}\\n        \\n        # MAIN EXECUTION\\n        nodes_len = 1\\n        curr = head\\n        while curr:\\n            nodes_len += 1\\n            nodes_size_avail =  nextValidSubListSize(curr.next, nodes_len)\\n            \\n            NextHeadLastMap = {}\\n            if nodes_size_avail % 2 == 0:\\n                NextHeadLastMap = NextHeadAndLastNodes_Reversed(curr.next, nodes_len)\\n            else:\\n                NextHeadLastMap = NextHeadAndLastNodes(curr.next, nodes_len)\\n            \\n            curr.next = NextHeadLastMap[\\'head\\']\\n            curr = NextHeadLastMap[\\'last\\']\\n            \\n        return head\\n        \\n        \\n                \\n            \\n            \\n            \\n            \\n            \\n```",
                "solutionTags": [
                    "Python3",
                    "Linked List"
                ],
                "code": "```\\n\\'\\'\\'\\nProblem: LC 2074 - Reverse Nodes in Even Length Groups\\nAuthor: Anando Zaman\\nDifficulty: Medium\\nDate: February 21, 2022\\n\\nNotes:\\nNodes are grouped based on their positions.\\nSo first node is group 1\\nNext two nodes are group 2\\nNext three nodes are group 3\\nNext four nodes are group 4.\\n\\nWe only want to reverse the groups that have even lengths\\nand return head of modified linkedList\\n\\nNOTE:\\nLength of the last group may be less than or equal to 1 + the length of the second to last group.\\n\\n\\nSOLUTION:\\nCreate three helper functions that takes the next node and a length:\\n    - NextHeadAndLastNodes_Reversed: Returns the first and last index of next sublist\\n    - NextHeadAndLastNodes_Reversed: Returns the first and last index of next reversed sublist\\n    - nextValidSubListSize: Returns the max size of the grouping possible\\n\\nUse a local variable to track the desired length of each grouping.\\nWe use the nextValidSubListSize function to determine if that length is possible, if not, return the number of nodes it supports.\\n\\nDepending on whether that result is odd or even, we return the reversed/non-reversed result\\nas a mapping of \\'head\\' and \\'last\\' nodes.\\n\\nUpdate our curr.next to point to the returned sublist, then continue reversing the next group\\nnodes starting at last.next node.\\n\\'\\'\\'\\n\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        \\n        def nextValidSubListSize(head: ListNode, len_: int):\\n            \\n            node_cnt = 0\\n            while head and node_cnt < len_:\\n                head = head.next\\n                node_cnt += 1\\n                \\n            return node_cnt\\n            \\n        \\n        def NextHeadAndLastNodes_Reversed(head: ListNode, len_: int):\\n            if not head:\\n                return {\\'head\\':None, \\'last\\':None}\\n            \\n            last = head\\n            prev, curr = None, head\\n            \\n            while (len_ > 0 and curr):\\n                temp = curr.next\\n                curr.next = prev\\n                prev = curr\\n                curr = temp\\n                len_ -= 1\\n                \\n            new_head = prev\\n            last.next = curr # linkage needed so that we can reference next grouping\\n            return {\\'head\\':new_head, \\'last\\':last}\\n        \\n        def NextHeadAndLastNodes(head: ListNode, len_:int):\\n            if not head:\\n                return {\\'head\\':None, \\'last\\':None}\\n            \\n            prev = None\\n            curr = head\\n            while curr and len_ > 0:\\n                prev = curr\\n                curr = curr.next\\n                len_ -= 1\\n                \\n            return {\\'head\\':head, \\'last\\':prev}\\n        \\n        # MAIN EXECUTION\\n        nodes_len = 1\\n        curr = head\\n        while curr:\\n            nodes_len += 1\\n            nodes_size_avail =  nextValidSubListSize(curr.next, nodes_len)\\n            \\n            NextHeadLastMap = {}\\n            if nodes_size_avail % 2 == 0:\\n                NextHeadLastMap = NextHeadAndLastNodes_Reversed(curr.next, nodes_len)\\n            else:\\n                NextHeadLastMap = NextHeadAndLastNodes(curr.next, nodes_len)\\n            \\n            curr.next = NextHeadLastMap[\\'head\\']\\n            curr = NextHeadLastMap[\\'last\\']\\n            \\n        return head\\n        \\n        \\n                \\n            \\n            \\n            \\n            \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1776421,
                "title": "c-naive-approach-but-easy-to-understand",
                "content": "```\\n  int calculate(ListNode* head)\\n    {\\n        int count=0;\\n        while(head!=NULL)\\n        {\\n            count++;\\n            head=head->next;\\n        }\\n        return count;\\n    }\\n    ListNode* reverse(ListNode* head,int len)\\n    {\\n        ListNode* curr=head;\\n        ListNode* prev=NULL,*next=NULL;\\n        while(curr!=NULL && len>0)\\n        {\\n             next=curr->next;\\n            ListNode* newTemp=new ListNode(curr->val);\\n             newTemp->next=prev;\\n            prev=newTemp;\\n            curr=curr->next;\\n            len--;\\n        }\\n        \\n        return prev;\\n    }\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        int totalnodes=calculate(head);\\n        int i=1;\\n        ListNode* pseudonode=new ListNode(-1);\\n        ListNode* prev=pseudonode;\\n        while(i)\\n        {\\n            int remnodes=totalnodes-i;\\n            if(remnodes>0)\\n            {\\n                int val=i;\\n                prev->next=head;\\n                if(i%2==0)\\n                {\\n                    ListNode* newlist=reverse(head,i);\\n                    ListNode* temp=newlist;\\n                    while(temp!=NULL)\\n                    {\\n                        temp=temp->next;\\n                    }\\n                    prev->next=newlist;\\n                }\\n                 while(val>0 && head!=NULL)\\n                    {\\n                     val--;\\n                        prev=prev->next;\\n                        head=head->next;\\n                    }\\n            }\\n            else\\n            {\\n                if(totalnodes%2==0)\\n                {\\n                      ListNode* newlist=reverse(head,i);\\n                      prev->next=newlist;\\n                     return pseudonode->next;\\n                }\\n                else\\n                {\\n                    prev->next=head;\\n                    return pseudonode->next;\\n                }\\n            }\\n            totalnodes-=i; i++;\\n        }\\n        return pseudonode->next;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n  int calculate(ListNode* head)\\n    {\\n        int count=0;\\n        while(head!=NULL)\\n        {\\n            count++;\\n            head=head->next;\\n        }\\n        return count;\\n    }\\n    ListNode* reverse(ListNode* head,int len)\\n    {\\n        ListNode* curr=head;\\n        ListNode* prev=NULL,*next=NULL;\\n        while(curr!=NULL && len>0)\\n        {\\n             next=curr->next;\\n            ListNode* newTemp=new ListNode(curr->val);\\n             newTemp->next=prev;\\n            prev=newTemp;\\n            curr=curr->next;\\n            len--;\\n        }\\n        \\n        return prev;\\n    }\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        int totalnodes=calculate(head);\\n        int i=1;\\n        ListNode* pseudonode=new ListNode(-1);\\n        ListNode* prev=pseudonode;\\n        while(i)\\n        {\\n            int remnodes=totalnodes-i;\\n            if(remnodes>0)\\n            {\\n                int val=i;\\n                prev->next=head;\\n                if(i%2==0)\\n                {\\n                    ListNode* newlist=reverse(head,i);\\n                    ListNode* temp=newlist;\\n                    while(temp!=NULL)\\n                    {\\n                        temp=temp->next;\\n                    }\\n                    prev->next=newlist;\\n                }\\n                 while(val>0 && head!=NULL)\\n                    {\\n                     val--;\\n                        prev=prev->next;\\n                        head=head->next;\\n                    }\\n            }\\n            else\\n            {\\n                if(totalnodes%2==0)\\n                {\\n                      ListNode* newlist=reverse(head,i);\\n                      prev->next=newlist;\\n                     return pseudonode->next;\\n                }\\n                else\\n                {\\n                    prev->next=head;\\n                    return pseudonode->next;\\n                }\\n            }\\n            totalnodes-=i; i++;\\n        }\\n        return pseudonode->next;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1732265,
                "title": "kotlin-easy-recursive",
                "content": "Shortly this solution uses backtracking reverse groups from last group\\n\\n```\\nclass Solution {\\n    fun reverseEvenLengthGroups(head: ListNode?): ListNode? {\\n        return reverse(head, arrayOf(null), intArrayOf(1), 1)\\n    }\\n    \\n    private fun reverse(head: ListNode?, tail: Array<ListNode?>, k: IntArray, g: Int): ListNode? {\\n        if (head == null || head.next == null) return head\\n        if (k[0] == g) {\\n            tail[0] = reverse(head.next, tail, intArrayOf(1), g + 1)\\n            return head.apply { this.next = tail[0] }\\n        }\\n        val rest = reverse(head.next, tail, k.apply { this[0]++ }, g)\\n        if ((k[0] and 1) == 0) {\\n            head.next.next = head\\n            head.next = tail[0]  \\n            return rest\\n        }\\n        return head\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    fun reverseEvenLengthGroups(head: ListNode?): ListNode? {\\n        return reverse(head, arrayOf(null), intArrayOf(1), 1)\\n    }\\n    \\n    private fun reverse(head: ListNode?, tail: Array<ListNode?>, k: IntArray, g: Int): ListNode? {\\n        if (head == null || head.next == null) return head\\n        if (k[0] == g) {\\n            tail[0] = reverse(head.next, tail, intArrayOf(1), g + 1)\\n            return head.apply { this.next = tail[0] }\\n        }\\n        val rest = reverse(head.next, tail, k.apply { this[0]++ }, g)\\n        if ((k[0] and 1) == 0) {\\n            head.next.next = head\\n            head.next = tail[0]  \\n            return rest\\n        }\\n        return head\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1697132,
                "title": "reverse-nodes-in-even-length-groups-o-n-faster-than-75-submission",
                "content": "\\tLogic is to maintain the window of even length list and reverse them .\\n...\\nListNode* reverse(ListNode* head)\\n    {\\n        if(head == NULL || head->next ==NULL )\\n            return head;\\n        \\n        ListNode* newhead = reverse(head->next);\\n        head->next->next = head;\\n        head->next = NULL;\\n        \\n        return newhead;\\n        \\n    }\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        if(head->next == NULL)\\n            return head;\\n        \\n        ListNode* temp = head;\\n        ListNode* tempprev = head;\\n        ListNode* temphead = head;\\n        ListNode* tempheadprev = head;\\n        int k = 1;\\n        int tempk = k;\\n        bool isodd = true;\\n        int flag = 1;\\n        while(temp!=NULL)\\n        {\\n            if(isodd)\\n            {\\n                while(temp != NULL && k)\\n                {   \\n                    tempprev = temp;\\n                    temp = temp->next;\\n                    k--;\\n                    \\n                }\\n                if(k != 0 && ((tempk - k)%2) == 0)\\n                {   \\n                    //cout<<tempk<<\" \"<<k<<endl;\\n                    flag = 0;\\n                    break;\\n                }\\n                else if(k != 0 && (((tempk - k)%2) != 0))\\n                {   \\n                    break;\\n                }\\n                temphead = temp;\\n                tempheadprev = tempprev;\\n                isodd = false;\\n                k = tempk + 1;\\n                tempk++;\\n            }\\n            else\\n            {\\n                while(temp != NULL && k)\\n                {\\n                    k--;\\n                    tempprev = temp;\\n                    temp = temp->next;\\n                }\\n                \\n                    //cout<<tempk<<\" \"<<k<<endl;\\n                if(k != 0 && (((tempk - k)%2) == 0))\\n                {   \\n                    flag = 0;\\n                    break;\\n                }\\n                else if(k != 0 && (((tempk - k)%2) != 0))\\n                {   \\n                    break;\\n                }\\n                tempprev->next = NULL;\\n                ListNode* newhead = reverse(temphead);\\n                tempheadprev->next = newhead;\\n                temphead->next = temp;\\n                tempheadprev = temphead;\\n                temphead = temp;\\n                \\n                k = tempk + 1;\\n                tempk++;\\n                isodd = true;\\n            }\\n        }\\n        if(flag == 0)\\n        {   \\n            tempprev->next = NULL;\\n            ListNode* newhead = reverse(temphead);\\n            tempheadprev->next = newhead;\\n            temphead->next = temp;\\n        }\\n        return head;\\n    }\\n\\t...\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "\\tLogic is to maintain the window of even length list and reverse them .\\n...\\nListNode* reverse(ListNode* head)\\n    {\\n        if(head == NULL || head->next ==NULL )\\n            return head;\\n        \\n        ListNode* newhead = reverse(head->next);\\n        head->next->next = head;\\n        head->next = NULL;\\n        \\n        return newhead;\\n        \\n    }\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        if(head->next == NULL)\\n            return head;\\n        \\n        ListNode* temp = head;\\n        ListNode* tempprev = head;\\n        ListNode* temphead = head;\\n        ListNode* tempheadprev = head;\\n        int k = 1;\\n        int tempk = k;\\n        bool isodd = true;\\n        int flag = 1;\\n        while(temp!=NULL)\\n        {\\n            if(isodd)\\n            {\\n                while(temp != NULL && k)\\n                {   \\n                    tempprev = temp;\\n                    temp = temp->next;\\n                    k--;\\n                    \\n                }\\n                if(k != 0 && ((tempk - k)%2) == 0)\\n                {   \\n                    //cout<<tempk<<\" \"<<k<<endl;\\n                    flag = 0;\\n                    break;\\n                }\\n                else if(k != 0 && (((tempk - k)%2) != 0))\\n                {   \\n                    break;\\n                }\\n                temphead = temp;\\n                tempheadprev = tempprev;\\n                isodd = false;\\n                k = tempk + 1;\\n                tempk++;\\n            }\\n            else\\n            {\\n                while(temp != NULL && k)\\n                {\\n                    k--;\\n                    tempprev = temp;\\n                    temp = temp->next;\\n                }\\n                \\n                    //cout<<tempk<<\" \"<<k<<endl;\\n                if(k != 0 && (((tempk - k)%2) == 0))\\n                {   \\n                    flag = 0;\\n                    break;\\n                }\\n                else if(k != 0 && (((tempk - k)%2) != 0))\\n                {   \\n                    break;\\n                }\\n                tempprev->next = NULL;\\n                ListNode* newhead = reverse(temphead);\\n                tempheadprev->next = newhead;\\n                temphead->next = temp;\\n                tempheadprev = temphead;\\n                temphead = temp;\\n                \\n                k = tempk + 1;\\n                tempk++;\\n                isodd = true;\\n            }\\n        }\\n        if(flag == 0)\\n        {   \\n            tempprev->next = NULL;\\n            ListNode* newhead = reverse(temphead);\\n            tempheadprev->next = newhead;\\n            temphead->next = temp;\\n        }\\n        return head;\\n    }\\n\\t...\\n",
                "codeTag": "C++"
            },
            {
                "id": 1678290,
                "title": "java-solution-without-extra-space",
                "content": "This method has two helper functions.\\n\\n1) height  - to determine height of list (straightforward)\\n2) reverese - to reverse the group ( usual reverse function with little tweak by just pointing intial head to last element of the group.\\n\\nAlgo:\\n1) if your current number (count % 2 == 0) is even then do reverse else just move forward in the list.\\n2) On the each loop just decrement height by count and once the height becomes less than number,\\n   break loop in case if its even , if its odd just increment the number and continue with the loop because even will take care of it.\\n```    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        ListNode temp = head;\\n        int count = 1;\\n        int height = height(head);\\n        while (head != null) {\\n            if (count%2 == 0) {\\n                if (height < count && height %2 == 1)\\n                    break;\\n                ListNode next = head.next;\\n                head.next = reverse(head.next, count);\\n                head = next;\\n                if (height < count)\\n                    break;\\n            }\\n            else {\\n                if (height < count) {\\n                    if (height %2 == 1)\\n                        break;\\n                    else {\\n                        count++;\\n                        continue;\\n                    }\\n                }\\n                int index = count;\\n                while (head != null && index-- > 0 && count !=1) \\n                    head = head.next;\\n            }\\n            height -= count;\\n            count++;\\n        }\\n        return temp;\\n    }\\n    public int height (ListNode head) {\\n        int height = 0;\\n        while (head != null) {\\n            head = head.next;\\n            height++;\\n        }\\n        return height;\\n    }\\n    \\n    public ListNode reverse(ListNode head, int count) {\\n        if (head == null)\\n            return head;\\n        ListNode pointer = head, prev = null;\\n        while (head != null && count-- > 0) {\\n            ListNode next = head.next;\\n            head.next = prev;\\n            prev = head;\\n            head = next;\\n        }\\n        pointer.next = head;\\n        return prev;\\n    }",
                "solutionTags": [],
                "code": "This method has two helper functions.\\n\\n1) height  - to determine height of list (straightforward)\\n2) reverese - to reverse the group ( usual reverse function with little tweak by just pointing intial head to last element of the group.\\n\\nAlgo:\\n1) if your current number (count % 2 == 0) is even then do reverse else just move forward in the list.\\n2) On the each loop just decrement height by count and once the height becomes less than number,\\n   break loop in case if its even , if its odd just increment the number and continue with the loop because even will take care of it.\\n```    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        ListNode temp = head;\\n        int count = 1;\\n        int height = height(head);\\n        while (head != null) {\\n            if (count%2 == 0) {\\n                if (height < count && height %2 == 1)\\n                    break;\\n                ListNode next = head.next;\\n                head.next = reverse(head.next, count);\\n                head = next;\\n                if (height < count)\\n                    break;\\n            }\\n            else {\\n                if (height < count) {\\n                    if (height %2 == 1)\\n                        break;\\n                    else {\\n                        count++;\\n                        continue;\\n                    }\\n                }\\n                int index = count;\\n                while (head != null && index-- > 0 && count !=1) \\n                    head = head.next;\\n            }\\n            height -= count;\\n            count++;\\n        }\\n        return temp;\\n    }\\n    public int height (ListNode head) {\\n        int height = 0;\\n        while (head != null) {\\n            head = head.next;\\n            height++;\\n        }\\n        return height;\\n    }\\n    \\n    public ListNode reverse(ListNode head, int count) {\\n        if (head == null)\\n            return head;\\n        ListNode pointer = head, prev = null;\\n        while (head != null && count-- > 0) {\\n            ListNode next = head.next;\\n            head.next = prev;\\n            prev = head;\\n            head = next;\\n        }\\n        pointer.next = head;\\n        return prev;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1657173,
                "title": "java-solution-using-recursion",
                "content": "\\tclass Solution {\\n\\t\\tpublic ListNode reverseEvenLengthGroups(ListNode head) {\\n\\t\\t\\tint count = 0;\\n\\t\\t\\tListNode slow = head;\\n\\n\\t\\t\\twhile(slow!=null) {\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\tslow = slow.next;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn helper(head, count, 1);\\n\\t\\t}\\n\\n\\t\\tpublic ListNode helper(ListNode head, int length, int groupLength) {\\n\\t\\t\\tListNode current = head;\\n\\t\\t\\tListNode prev = null;\\n\\n\\t\\t\\tif(length < groupLength) groupLength = length;\\n\\n\\t\\t\\tif(groupLength%2 == 1) {\\n\\t\\t\\t\\tint k = groupLength;\\n\\t\\t\\t\\twhile(k-- > 0 && current!=null) {\\n\\t\\t\\t\\t\\tprev = current;\\n\\t\\t\\t\\t\\tcurrent = current.next;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif(current!=null)\\n\\t\\t\\t\\t\\tprev.next = helper(current, length-groupLength, groupLength+1);\\n\\n\\t\\t\\t\\treturn head;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tint k = groupLength;\\n\\t\\t\\t\\tListNode next = null;\\n\\n\\t\\t\\t\\twhile(k-- > 0 && current!=null) {\\n\\t\\t\\t\\t\\tnext = current.next;\\n\\t\\t\\t\\t\\tcurrent.next = prev;\\n\\t\\t\\t\\t\\tprev = current;\\n\\t\\t\\t\\t\\tcurrent = next;    \\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(current!=null)\\n\\t\\t\\t\\t\\thead.next = helper(current, length-groupLength, groupLength+1);\\n\\n\\t\\t\\t\\treturn prev;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic ListNode reverseEvenLengthGroups(ListNode head) {\\n\\t\\t\\tint count = 0;\\n\\t\\t\\tListNode slow = head;\\n\\n\\t\\t\\twhile(slow!=null) {\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\tslow = slow.next;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1652176,
                "title": "python-o-1-space",
                "content": "Approach:\\n\\tCount number of nodes until they are less than those in previous group.\\n\\ti.e. **groupCount+1>count**\\n\\tIf count is odd then modify pointers.\\n\\tElse reverse those nodes and also modify pointers.\\n\\nptr1 = pointer to last node of previous group\\nptr2 = pointer to start of current group\\nptr3 = pointer to start of next group\\nptr4 = pointer to end of current group\\n\\n```\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        groupCount = 0\\n        ptr1 = None\\n        ptr2 = head\\n        \\n        while ptr2:\\n            count = 0\\n            ptr3 = ptr2\\n            ptr4 = None\\n            while ptr3 and count<groupCount+1:\\n                ptr4 = ptr3\\n                ptr3 = ptr3.next\\n                count += 1\\n            \\n            if count%2:\\n                ptr1 = ptr4\\n            else:\\n                ptr1.next = self.reverse(ptr2, ptr3)\\n                ptr1 = ptr2\\n            ptr2 = ptr3\\n            groupCount += 1\\n        \\n        return head\\n            \\n    def reverse(self, curr, until):\\n        prev = until\\n        next = curr.next\\n        \\n        while next!=until:\\n            curr.next = prev\\n            prev = curr\\n            curr = next\\n            next = next.next\\n        \\n        curr.next = prev\\n        return curr\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        groupCount = 0\\n        ptr1 = None\\n        ptr2 = head\\n        \\n        while ptr2:\\n            count = 0\\n            ptr3 = ptr2\\n            ptr4 = None\\n            while ptr3 and count<groupCount+1:\\n                ptr4 = ptr3\\n                ptr3 = ptr3.next\\n                count += 1\\n            \\n            if count%2:\\n                ptr1 = ptr4\\n            else:\\n                ptr1.next = self.reverse(ptr2, ptr3)\\n                ptr1 = ptr2\\n            ptr2 = ptr3\\n            groupCount += 1\\n        \\n        return head\\n            \\n    def reverse(self, curr, until):\\n        prev = until\\n        next = curr.next\\n        \\n        while next!=until:\\n            curr.next = prev\\n            prev = curr\\n            curr = next\\n            next = next.next\\n        \\n        curr.next = prev\\n        return curr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1650251,
                "title": "python-recursion",
                "content": "```\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        def reverse(head, k):\\n            if head is None:\\n                return\\n\\t\\t\\t# traverse k node\\n            temp, kth, count = head, None, 0\\n            while temp and count < k:\\n                kth = temp\\n                temp = temp.next\\n                count += 1\\n\\t\\t\\t# return head for odd count\\n            if count % 2 and count != k: \\n                return head\\n            else:\\n                k = count # if count is even, reset k to count\\n            x = reverse(temp, k + 1)  # temp is (k + 1)th node\\n\\t\\t\\t# reverse list if k is even\\n            if k % 2 == 0:\\n                curr, pre = head, None\\n                while curr != temp:\\n                    next_ = curr.next\\n                    curr.next = pre\\n                    pre = curr\\n                    curr = next_\\n                head.next = x\\n                return pre\\n\\t\\t\\t\\n\\t\\t\\t# if k is odd\\n            kth.next = x\\n            return head\\n            \\n        return reverse(head, 1)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        def reverse(head, k):\\n            if head is None:\\n                return\\n\\t\\t\\t# traverse k node\\n            temp, kth, count = head, None, 0\\n            while temp and count < k:\\n                kth = temp\\n                temp = temp.next\\n                count += 1\\n\\t\\t\\t# return head for odd count\\n            if count % 2 and count != k: \\n                return head\\n            else:\\n                k = count # if count is even, reset k to count\\n            x = reverse(temp, k + 1)  # temp is (k + 1)th node\\n\\t\\t\\t# reverse list if k is even\\n            if k % 2 == 0:\\n                curr, pre = head, None\\n                while curr != temp:\\n                    next_ = curr.next\\n                    curr.next = pre\\n                    pre = curr\\n                    curr = next_\\n                head.next = x\\n                return pre\\n\\t\\t\\t\\n\\t\\t\\t# if k is odd\\n            kth.next = x\\n            return head\\n            \\n        return reverse(head, 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1594762,
                "title": "c-solution-easy-to-understand",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void reverselist(ListNode*& leftnode, ListNode*& rightnode, ListNode*& head) {\\n        ListNode* prevptr=rightnode;\\n        ListNode* currptr=leftnode;\\n        ListNode* nextptr;\\n        while(currptr!=rightnode){\\n            nextptr=currptr->next;\\n            currptr->next=prevptr;\\n            prevptr=currptr;\\n            currptr=nextptr;\\n        }\\n        head=prevptr;\\n    }\\n    void reverseList(ListNode*& leftnode, ListNode*& rightnode) {\\n        ListNode* prevptr=rightnode;\\n        ListNode* currptr=leftnode->next;\\n        ListNode* nextptr;\\n        while(currptr!=rightnode){\\n            nextptr=currptr->next;\\n            currptr->next=prevptr;\\n            prevptr=currptr;\\n            currptr=nextptr;\\n        }\\n        leftnode->next=prevptr;\\n    }\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        ListNode* rightnode=head;\\n        while(right>0 && rightnode){\\n            rightnode=rightnode->next;\\n            right--;\\n        }\\n        ListNode* leftnode=head;\\n        if(left!=1){\\n            left=left-2;\\n            while(left--) leftnode=leftnode->next;\\n            reverseList(leftnode, rightnode);\\n            return head;\\n        }\\n        reverselist(leftnode, rightnode, head);\\n        return head;\\n    }\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        ListNode* temp=head;\\n        int length=0;\\n        while(temp){\\n            length++;\\n            temp=temp->next;\\n        }\\n        int k=1, i=1;\\n        while((k*(k+1)/2)<=length){\\n            if(k%2==0){\\n                head=reverseBetween(head, i, i+k-1);\\n            }\\n            i+=k;\\n            k++;\\n        }\\n        if((length-i+1)%2==0){\\n            head=reverseBetween(head, i, length);\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void reverselist(ListNode*& leftnode, ListNode*& rightnode, ListNode*& head) {\\n        ListNode* prevptr=rightnode;\\n        ListNode* currptr=leftnode;\\n        ListNode* nextptr;\\n        while(currptr!=rightnode){\\n            nextptr=currptr->next;\\n            currptr->next=prevptr;\\n            prevptr=currptr;\\n            currptr=nextptr;\\n        }\\n        head=prevptr;\\n    }\\n    void reverseList(ListNode*& leftnode, ListNode*& rightnode) {\\n        ListNode* prevptr=rightnode;\\n        ListNode* currptr=leftnode->next;\\n        ListNode* nextptr;\\n        while(currptr!=rightnode){\\n            nextptr=currptr->next;\\n            currptr->next=prevptr;\\n            prevptr=currptr;\\n            currptr=nextptr;\\n        }\\n        leftnode->next=prevptr;\\n    }\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        ListNode* rightnode=head;\\n        while(right>0 && rightnode){\\n            rightnode=rightnode->next;\\n            right--;\\n        }\\n        ListNode* leftnode=head;\\n        if(left!=1){\\n            left=left-2;\\n            while(left--) leftnode=leftnode->next;\\n            reverseList(leftnode, rightnode);\\n            return head;\\n        }\\n        reverselist(leftnode, rightnode, head);\\n        return head;\\n    }\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        ListNode* temp=head;\\n        int length=0;\\n        while(temp){\\n            length++;\\n            temp=temp->next;\\n        }\\n        int k=1, i=1;\\n        while((k*(k+1)/2)<=length){\\n            if(k%2==0){\\n                head=reverseBetween(head, i, i+k-1);\\n            }\\n            i+=k;\\n            k++;\\n        }\\n        if((length-i+1)%2==0){\\n            head=reverseBetween(head, i, length);\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1581686,
                "title": "c-brute-force-solution",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        vector<vector<ListNode *>> arr;\\n        \\n        ListNode *p = head;\\n        if(!p)\\n            return p;\\n        \\n        \\n        int c = 0;\\n        \\n        while(p){\\n            c++;\\n            vector<ListNode *> v;\\n            for(int i = 0; i < c && p; i++){\\n                v.push_back(p);\\n                p = p->next;\\n            }\\n\\n            arr.push_back(v);\\n        }\\n        \\n        vector<ListNode *> l;\\n\\n        for(int i = 0; i < arr.size(); i++){\\n\\n            if(arr[i].size() % 2 == 0)\\n                reverse(arr[i].begin(), arr[i].end());\\n            \\n            for(int j = 0; j < arr[i].size(); j++)\\n                l.push_back(arr[i][j]);\\n        }\\n        \\n        for(int i = 1; i < l.size(); i++){\\n            l[i]->next = NULL;\\n            l[i-1]->next = l[i];\\n        }\\n            \\n        return l[0];\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        vector<vector<ListNode *>> arr;\\n        \\n        ListNode *p = head;\\n        if(!p)\\n            return p;\\n        \\n        \\n        int c = 0;\\n        \\n        while(p){\\n            c++;\\n            vector<ListNode *> v;\\n            for(int i = 0; i < c && p; i++){\\n                v.push_back(p);\\n                p = p->next;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1580899,
                "title": "brute-force-well-commented-and-easy-to-understand-java-solution",
                "content": "**Intuition** : we will be Creating a linkedlist (templist say) having all nodes which belongs to a single group (size k) and if k is odd then merge templist and resulting linkedlist directly and if k is even then we will reverse templist first and then merge it with resulting linkedlist.\\n**Approach :**  \\n1. traverse the given list in groups.\\n2. while traversing on a group we will be creating our templist and updating given linkedlist simultaneously.\\n3. Check if the size of the group we traversed was even ? if yes then reverse templist.\\n4. Merge templist and resulting Linkedlist.\\n\\n```\\nclass Solution {\\n    \\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        \\n        //ans is going to be head of our resulting linkedlist\\n        \\n\\n//         adding 1st group nodes to ans and removing them from given list\\n//         1st group only contains head of given linkedlist\\n        ListNode ans=head;  \\n        ListNode temp=head.next;\\n        \\n        head.next=null;\\n        head=temp;\\n        int size=Size(head); //size of given likedlist\\n        \\n        int k=2;  //size of current group \\n        \\n        \\n// this loop will create a linkedlist templist having all nodes of a group (of size k)\\n        while(temp!=null && k<=size){\\n            \\n            ListNode templist=null; \\n            int count=k;\\n            \\n//             adding all nodes of group to templist and removing respective nodes from given linkedlist\\n            while(count-->0){\\n                \\n                templist=addLast(templist,temp.val);  \\n                temp=remFirst(temp);\\n                \\n            }\\n            \\n//             now check if size of group is even then\\n            if(k%2==0){\\n                templist=rev(templist);  //reverse templist\\n            }\\n            \\n            ans= add(ans,templist);  //merge ans and templist \\n            \\n            size-=k;\\n            k++; \\n        }\\n        \\n        size=Size(temp);\\n        if(size%2==0){\\n            temp=rev(temp);\\n        }\\n        ans=add(ans,temp);\\n        return ans;\\n    }\\n    \\n//     Function to determine size of the LinkedList\\n    public int Size(ListNode head){\\n        ListNode temp=head;\\n        int size=0;\\n        while(temp!=null){\\n            temp=temp.next;\\n            size++;\\n        }\\n        return size;\\n    }\\n    \\n//     this Function will add a node(having data val) at the last of linkedlist\\n    public ListNode addLast(ListNode head,int val){\\n        ListNode nn= new ListNode(val);\\n        if(head==null){\\n            return nn;\\n        }\\n        \\n        ListNode temp=head;\\n        \\n        while(temp.next!=null){\\n            temp=temp.next;\\n        }\\n        \\n        temp.next=nn;\\n        return head;\\n    }\\n    \\n    \\n//     this function will remove the first node of the linkedlist\\n    public ListNode remFirst(ListNode head){\\n        ListNode temp=head;\\n        head=head.next;\\n        temp.next=null;\\n        return head;\\n    }\\n    \\n    \\n//     This function will merge two linkedlist\\n    public ListNode add(ListNode list1,ListNode list2){\\n        \\n        ListNode temp=list1;\\n        while(temp.next!=null){\\n            temp=temp.next;\\n        }\\n        temp.next=list2;\\n        return list1;\\n    }\\n    \\n//     this Function will reverse the LinkedList\\n    public ListNode rev(ListNode head){\\n        \\n        ListNode prev=null;\\n        ListNode curr= head;\\n        while(curr!=null){\\n            ListNode currnext=curr.next;\\n            curr.next=prev;\\n            prev=curr;\\n            curr=currnext;\\n        }\\n        head=prev;\\n        return head;\\n        \\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        \\n        //ans is going to be head of our resulting linkedlist\\n        \\n\\n//         adding 1st group nodes to ans and removing them from given list\\n//         1st group only contains head of given linkedlist\\n        ListNode ans=head;  \\n        ListNode temp=head.next;\\n        \\n        head.next=null;\\n        head=temp;\\n        int size=Size(head); //size of given likedlist\\n        \\n        int k=2;  //size of current group \\n        \\n        \\n// this loop will create a linkedlist templist having all nodes of a group (of size k)\\n        while(temp!=null && k<=size){\\n            \\n            ListNode templist=null; \\n            int count=k;\\n            \\n//             adding all nodes of group to templist and removing respective nodes from given linkedlist\\n            while(count-->0){\\n                \\n                templist=addLast(templist,temp.val);  \\n                temp=remFirst(temp);\\n                \\n            }\\n            \\n//             now check if size of group is even then\\n            if(k%2==0){\\n                templist=rev(templist);  //reverse templist\\n            }\\n            \\n            ans= add(ans,templist);  //merge ans and templist \\n            \\n            size-=k;\\n            k++; \\n        }\\n        \\n        size=Size(temp);\\n        if(size%2==0){\\n            temp=rev(temp);\\n        }\\n        ans=add(ans,temp);\\n        return ans;\\n    }\\n    \\n//     Function to determine size of the LinkedList\\n    public int Size(ListNode head){\\n        ListNode temp=head;\\n        int size=0;\\n        while(temp!=null){\\n            temp=temp.next;\\n            size++;\\n        }\\n        return size;\\n    }\\n    \\n//     this Function will add a node(having data val) at the last of linkedlist\\n    public ListNode addLast(ListNode head,int val){\\n        ListNode nn= new ListNode(val);\\n        if(head==null){\\n            return nn;\\n        }\\n        \\n        ListNode temp=head;\\n        \\n        while(temp.next!=null){\\n            temp=temp.next;\\n        }\\n        \\n        temp.next=nn;\\n        return head;\\n    }\\n    \\n    \\n//     this function will remove the first node of the linkedlist\\n    public ListNode remFirst(ListNode head){\\n        ListNode temp=head;\\n        head=head.next;\\n        temp.next=null;\\n        return head;\\n    }\\n    \\n    \\n//     This function will merge two linkedlist\\n    public ListNode add(ListNode list1,ListNode list2){\\n        \\n        ListNode temp=list1;\\n        while(temp.next!=null){\\n            temp=temp.next;\\n        }\\n        temp.next=list2;\\n        return list1;\\n    }\\n    \\n//     this Function will reverse the LinkedList\\n    public ListNode rev(ListNode head){\\n        \\n        ListNode prev=null;\\n        ListNode curr= head;\\n        while(curr!=null){\\n            ListNode currnext=curr.next;\\n            curr.next=prev;\\n            prev=curr;\\n            curr=currnext;\\n        }\\n        head=prev;\\n        return head;\\n        \\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1580446,
                "title": "2074-reverse-nodes-in-even-length-groups",
                "content": "---\\n\\n- Contest - https://leetcode.com/contest/weekly-contest-267/\\n  - Q1 Answer\\n    - https://leetcode.com/problems/time-needed-to-buy-tickets/discuss/1578174/2073.-Time-Needed-to-Buy-Tickets\\n  - Q2 Answer\\n    - below\\n      - https://leetcode.com/problems/reverse-nodes-in-even-length-groups/discuss/1580446/2074.-Reverse-Nodes-in-Even-Length-Groups\\n  - Q3 Answer\\n    - https://leetcode.com/problems/decode-the-slanted-ciphertext/discuss/1588186/2075.-Decode-the-Slanted-Ciphertext\\n\\n---\\n\\nTwo solutions:\\n- Creating intermediate arrays\\n- Without creating intermediate arrays\\n\\n---\\n\\nHope it is simple to understand.\\n\\n---\\n\\n**Creating intermediate arrays**\\n\\n```\\nvar reverseEvenLengthGroups = function (head) {\\n    let values = [],\\n        temp;\\n\\n    // from linked list, fill into array\\n    temp = head;\\n    while (temp) {\\n        values.push(temp.val);\\n        temp = temp.next;\\n    }\\n\\n    // cut into parts - if length is even (2, 4, 6, .. also last can be even), reverse and overwrite\\n    let n = values.length;\\n    for (let k = 0, count = 1; k < n; k += count, count++) {\\n        let reversePart = values.slice(k, k + count).reverse();\\n        if (reversePart.length % 2 === 0)\\n            for (let i = 0; i < reversePart.length; i++) {\\n                values[k + i] = reversePart[i];\\n            }\\n    }\\n\\n    // from array, fill into linked list\\n    temp = head;\\n    for (let v of values) {\\n        temp.val = v;\\n        temp = temp.next;\\n    }\\n\\n    return head;\\n};\\n```\\n\\n---\\n\\n**Without creating intermediate arrays**\\n\\n```\\nvar reverseEvenLengthGroups = function (head) {\\n    let values = [],\\n        temp;\\n\\n    // from linked list, fill into array\\n    temp = head;\\n    while (temp) {\\n        values.push(temp.val);\\n        temp = temp.next;\\n    }\\n\\n    // take into parts - if length is even (2, 4, 6, .. also last can be even), reverse and overwrite\\n    let n = values.length;\\n    for (let k = 0, count = 1; k < n; k += count, count++) {\\n        let size = Math.min(k + count, n) - k;\\n        if (size % 2 === 0)\\n            for (let i = k, j = k + size - 1; i < j; i++, j--) {\\n                [values[i], values[j]] = [values[j], values[i]];\\n            }\\n    }\\n\\n    // from array, fill into linked list\\n    temp = head;\\n    for (let v of values) {\\n        temp.val = v;\\n        temp = temp.next;\\n    }\\n\\n    return head;\\n};\\n```\\n\\n---\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar reverseEvenLengthGroups = function (head) {\\n    let values = [],\\n        temp;\\n\\n    // from linked list, fill into array\\n    temp = head;\\n    while (temp) {\\n        values.push(temp.val);\\n        temp = temp.next;\\n    }\\n\\n    // cut into parts - if length is even (2, 4, 6, .. also last can be even), reverse and overwrite\\n    let n = values.length;\\n    for (let k = 0, count = 1; k < n; k += count, count++) {\\n        let reversePart = values.slice(k, k + count).reverse();\\n        if (reversePart.length % 2 === 0)\\n            for (let i = 0; i < reversePart.length; i++) {\\n                values[k + i] = reversePart[i];\\n            }\\n    }\\n\\n    // from array, fill into linked list\\n    temp = head;\\n    for (let v of values) {\\n        temp.val = v;\\n        temp = temp.next;\\n    }\\n\\n    return head;\\n};\\n```\n```\\nvar reverseEvenLengthGroups = function (head) {\\n    let values = [],\\n        temp;\\n\\n    // from linked list, fill into array\\n    temp = head;\\n    while (temp) {\\n        values.push(temp.val);\\n        temp = temp.next;\\n    }\\n\\n    // take into parts - if length is even (2, 4, 6, .. also last can be even), reverse and overwrite\\n    let n = values.length;\\n    for (let k = 0, count = 1; k < n; k += count, count++) {\\n        let size = Math.min(k + count, n) - k;\\n        if (size % 2 === 0)\\n            for (let i = k, j = k + size - 1; i < j; i++, j--) {\\n                [values[i], values[j]] = [values[j], values[i]];\\n            }\\n    }\\n\\n    // from array, fill into linked list\\n    temp = head;\\n    for (let v of values) {\\n        temp.val = v;\\n        temp = temp.next;\\n    }\\n\\n    return head;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1580441,
                "title": "java-recursive-o-n-in-place-o-1-space",
                "content": "```\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        return rec(0,1,head)[0];\\n    }\\n    private boolean evenNumberGroup = false;\\n    //return {head, tail for rev}\\n    private ListNode[] rec(int i, int group, ListNode currNode){\\n        if(currNode == null) {\\n            evenNumberGroup = i%2==0;\\n            return new ListNode[2];\\n        }\\n        i++;\\n        ListNode[] ret = rec(i%group, group + i/group, currNode.next);\\n        if(i==group)\\n            evenNumberGroup = i%2==0;\\n        if(ret[1]!=null && evenNumberGroup && i!=group ){\\n            currNode.next = ret[1].next;\\n            ret[1].next = currNode;\\n            ret[1] = currNode;\\n            return ret;\\n        }\\n        currNode.next = ret[0];\\n        ret[1]=ret[0]=currNode;\\n        return ret;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        return rec(0,1,head)[0];\\n    }\\n    private boolean evenNumberGroup = false;\\n    //return {head, tail for rev}\\n    private ListNode[] rec(int i, int group, ListNode currNode){\\n        if(currNode == null) {\\n            evenNumberGroup = i%2==0;\\n            return new ListNode[2];\\n        }\\n        i++;\\n        ListNode[] ret = rec(i%group, group + i/group, currNode.next);\\n        if(i==group)\\n            evenNumberGroup = i%2==0;\\n        if(ret[1]!=null && evenNumberGroup && i!=group ){\\n            currNode.next = ret[1].next;\\n            ret[1].next = currNode;\\n            ret[1] = currNode;\\n            return ret;\\n        }\\n        currNode.next = ret[0];\\n        ret[1]=ret[0]=currNode;\\n        return ret;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1580122,
                "title": "2-solution-c-clean-code-with-comment",
                "content": "```\\n//solution 1\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        // not effitient solution\\n        // cheating code, convert to array then make linked list again\\n        vector<int> elements;\\n        ListNode* current = head;\\n        while(current != nullptr) {\\n            elements.push_back(current->val);\\n            current = current->next;\\n        }\\n        \\n        vector<int> ans;\\n        int index = 0;\\n        for(int len = 1; len <= elements.size(); len++) {\\n            // end of the current segment \\n            int n = min(index + len, (int)elements.size());\\n            \\n            //trick for last segment...if they have odd then no reverse\\n            //else reversly add the elements to the ans array\\n            if((n-index)%2 == 1) {\\n                for(; index < n && index < elements.size(); index++) \\n                    ans.push_back(elements[index]);\\n            }\\n            else {\\n                for(int i = n-1; i >= index; i--) \\n                    ans.push_back(elements[i]);\\n                index = n;\\n            }\\n        }\\n        \\n        // make linked list from array \\n        head = new ListNode(ans[0]);\\n        current = head;\\n        for(int i = 1; i < ans.size(); i++) {\\n            current->next = new ListNode(ans[i]);\\n            current = current-> next;\\n        }\\n        \\n        return head;\\n    }\\n};\\n\\n\\n//solution 2\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        int length = 1;\\n        ListNode* current = head;\\n        while(current != nullptr) {\\n            int count = 0;\\n            ListNode* tmp = current;\\n            stack<int> stk;\\n            while(count != length && current != nullptr) {\\n                count++;\\n                stk.push(current->val);\\n                current = current->next;\\n            }\\n            \\n            if(count%2 == 0) {\\n                while(tmp != current) {\\n                    tmp->val = stk.top();\\n                    stk.pop();\\n                    tmp = tmp->next;\\n                }\\n            }\\n            \\n            length++;\\n        }\\n        \\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n//solution 1\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        // not effitient solution\\n        // cheating code, convert to array then make linked list again\\n        vector<int> elements;\\n        ListNode* current = head;\\n        while(current != nullptr) {\\n            elements.push_back(current->val);\\n            current = current->next;\\n        }\\n        \\n        vector<int> ans;\\n        int index = 0;\\n        for(int len = 1; len <= elements.size(); len++) {\\n            // end of the current segment \\n            int n = min(index + len, (int)elements.size());\\n            \\n            //trick for last segment...if they have odd then no reverse\\n            //else reversly add the elements to the ans array\\n            if((n-index)%2 == 1) {\\n                for(; index < n && index < elements.size(); index++) \\n                    ans.push_back(elements[index]);\\n            }\\n            else {\\n                for(int i = n-1; i >= index; i--) \\n                    ans.push_back(elements[i]);\\n                index = n;\\n            }\\n        }\\n        \\n        // make linked list from array \\n        head = new ListNode(ans[0]);\\n        current = head;\\n        for(int i = 1; i < ans.size(); i++) {\\n            current->next = new ListNode(ans[i]);\\n            current = current-> next;\\n        }\\n        \\n        return head;\\n    }\\n};\\n\\n\\n//solution 2\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        int length = 1;\\n        ListNode* current = head;\\n        while(current != nullptr) {\\n            int count = 0;\\n            ListNode* tmp = current;\\n            stack<int> stk;\\n            while(count != length && current != nullptr) {\\n                count++;\\n                stk.push(current->val);\\n                current = current->next;\\n            }\\n            \\n            if(count%2 == 0) {\\n                while(tmp != current) {\\n                    tmp->val = stk.top();\\n                    stk.pop();\\n                    tmp = tmp->next;\\n                }\\n            }\\n            \\n            length++;\\n        }\\n        \\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1577570,
                "title": "c-solution-brute-force-o-n-space",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        vector<int>v;\\n        for(;head!=NULL;head=head->next)\\n        {\\n            v.push_back(head->val);\\n        }\\n        int n=v.size();\\n        map<int,vector<int>>mp;\\n        int len=1;\\n        for(int i=0;i<n;i++)\\n        {\\n             if(mp[len].size()==len)\\n            {\\n                len++;\\n            }\\n            mp[len].push_back(v[i]);\\n        }\\n        for(auto &it:mp)\\n        {\\n            if(it.second.size()%2==0)\\n            {\\n                reverse(it.second.begin(),it.second.end());\\n            }\\n        }\\n        ListNode*dummy_node=new ListNode(-1);\\n        ListNode*curr=dummy_node;\\n        for(auto it:mp)\\n        {\\n            for(auto ch:it.second)\\n            {\\n               curr->next=new ListNode(ch);\\n                curr=curr->next;\\n            }\\n        }\\n        return dummy_node->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        vector<int>v;\\n        for(;head!=NULL;head=head->next)\\n        {\\n            v.push_back(head->val);\\n        }\\n        int n=v.size();\\n        map<int,vector<int>>mp;\\n        int len=1;\\n        for(int i=0;i<n;i++)\\n        {\\n             if(mp[len].size()==len)\\n            {\\n                len++;\\n            }\\n            mp[len].push_back(v[i]);\\n        }\\n        for(auto &it:mp)\\n        {\\n            if(it.second.size()%2==0)\\n            {\\n                reverse(it.second.begin(),it.second.end());\\n            }\\n        }\\n        ListNode*dummy_node=new ListNode(-1);\\n        ListNode*curr=dummy_node;\\n        for(auto it:mp)\\n        {\\n            for(auto ch:it.second)\\n            {\\n               curr->next=new ListNode(ch);\\n                curr=curr->next;\\n            }\\n        }\\n        return dummy_node->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1577392,
                "title": "easy-to-understand-java-solution",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        ListNode prev = new ListNode(0);\\n        prev.next = head;\\n        \\n        ListNode dummyHead = new ListNode(0);\\n        dummyHead.next = head;\\n        \\n        int length = 0;\\n        ListNode node = head;\\n        while(node != null) {\\n            node = node.next;\\n            length++;\\n        }\\n        \\n        int currentGroup = 1;\\n        \\n        while(length > 0 ) {\\n            \\n            //next group is not last group, and number of nodes are odd\\n            if (length >= currentGroup && currentGroup % 2 != 0) {\\n                int temp = currentGroup;\\n                while(temp > 0) {\\n                    prev = head;\\n                    head = head.next;\\n                    temp = temp - 1;\\n                }\\n                length = length - currentGroup;\\n                //remining is last group, and number of nodes are odd\\n            } else if (length < currentGroup && length % 2 != 0) {\\n                break;\\n                //next group is even\\n            } else {\\n                ListNode tempNode = reverseList(prev, Math.min(currentGroup, length));\\n                head = tempNode.next;\\n                prev = tempNode;\\n                length = length - currentGroup;\\n            }\\n            \\n            currentGroup++;\\n        }\\n        return dummyHead.next;\\n    }\\n    \\n    \\n    // l >= 2\\n    private ListNode reverseList(ListNode prev, int l) {\\n\\n        ListNode curr = prev.next;\\n        ListNode temp = curr;\\n        \\n        while (curr != null && l > 0) {\\n            ListNode next = curr.next;\\n            \\n            curr.next = prev.next;\\n            prev.next = next;\\n            \\n            \\n            temp.next = next.next;\\n            next.next = curr;\\n\\n            curr = temp.next;\\n            \\n            l = l - 2;\\n        }\\n        \\n        return temp;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        ListNode prev = new ListNode(0);\\n        prev.next = head;\\n        \\n        ListNode dummyHead = new ListNode(0);\\n        dummyHead.next = head;\\n        \\n        int length = 0;\\n        ListNode node = head;\\n        while(node != null) {\\n            node = node.next;\\n            length++;\\n        }\\n        \\n        int currentGroup = 1;\\n        \\n        while(length > 0 ) {\\n            \\n            //next group is not last group, and number of nodes are odd\\n            if (length >= currentGroup && currentGroup % 2 != 0) {\\n                int temp = currentGroup;\\n                while(temp > 0) {\\n                    prev = head;\\n                    head = head.next;\\n                    temp = temp - 1;\\n                }\\n                length = length - currentGroup;\\n                //remining is last group, and number of nodes are odd\\n            } else if (length < currentGroup && length % 2 != 0) {\\n                break;\\n                //next group is even\\n            } else {\\n                ListNode tempNode = reverseList(prev, Math.min(currentGroup, length));\\n                head = tempNode.next;\\n                prev = tempNode;\\n                length = length - currentGroup;\\n            }\\n            \\n            currentGroup++;\\n        }\\n        return dummyHead.next;\\n    }\\n    \\n    \\n    // l >= 2\\n    private ListNode reverseList(ListNode prev, int l) {\\n\\n        ListNode curr = prev.next;\\n        ListNode temp = curr;\\n        \\n        while (curr != null && l > 0) {\\n            ListNode next = curr.next;\\n            \\n            curr.next = prev.next;\\n            prev.next = next;\\n            \\n            \\n            temp.next = next.next;\\n            next.next = curr;\\n\\n            curr = temp.next;\\n            \\n            l = l - 2;\\n        }\\n        \\n        return temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1577331,
                "title": "python-o-n-time-o-1-space",
                "content": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\t#helper function which reverses the linked list upto given length\\n        def help(head,n):\\n            a=head\\n            pre=None\\n            cur=head\\n            jam=head\\n            nex=head\\n            while nex and n:\\n                n-=1\\n                cur=nex\\n                nex=nex.next\\n                cur.next=pre\\n                pre=cur\\n            jam.next=nex            \\n            return cur\\n\\t\\t# traverse through the linked list and if its odd do nothing else call helper function\\n        le=0\\n        b=head\\n        while b:#length of complete linked list\\n            le+=1\\n            b=b.next\\n        cc=1\\n        ss=0\\n        r=head\\n        par=None\\n        opp=le\\n        while ss<=opp-1 and r:#while we reach the end\\n            if cc%2!=0:#if odd traverse the linked lisst normally\\n                op=cc\\n                while op and r:\\n                    par=r\\n                    r=r.next\\n                    op-=1\\n            else:    #else call helper function and reverse\\n                par.next=help(r,cc)\\n                op=cc            \\n                while op and par:\\n                    par=par.next            \\n                    op-=1\\n                r=par.next\\n            if ss==opp-1:\\n                break\\n            le-=cc\\n            cc+=1\\n            if le<cc:#if we got the number as 4 but we only have 2 left then we need to reverse the 2 nodes this helps to solve that edge case\\n                cc=le\\n            ss+=cc\\n        return head\\n                \\n            \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\t#helper function which reverses the linked list upto given length\\n        def help(head,n):\\n            a=head\\n            pre=None\\n            cur=head\\n            jam=head\\n            nex=head\\n            while nex and n:\\n                n-=1\\n                cur=nex\\n                nex=nex.next\\n                cur.next=pre\\n                pre=cur\\n            jam.next=nex            \\n            return cur\\n\\t\\t# traverse through the linked list and if its odd do nothing else call helper function\\n        le=0\\n        b=head\\n        while b:#length of complete linked list\\n            le+=1\\n            b=b.next\\n        cc=1\\n        ss=0\\n        r=head\\n        par=None\\n        opp=le\\n        while ss<=opp-1 and r:#while we reach the end\\n            if cc%2!=0:#if odd traverse the linked lisst normally\\n                op=cc\\n                while op and r:\\n                    par=r\\n                    r=r.next\\n                    op-=1\\n            else:    #else call helper function and reverse\\n                par.next=help(r,cc)\\n                op=cc            \\n                while op and par:\\n                    par=par.next            \\n                    op-=1\\n                r=par.next\\n            if ss==opp-1:\\n                break\\n            le-=cc\\n            cc+=1\\n            if le<cc:#if we got the number as 4 but we only have 2 left then we need to reverse the 2 nodes this helps to solve that edge case\\n                cc=le\\n            ss+=cc\\n        return head\\n                \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1577047,
                "title": "easy-commented-cpp-solution",
                "content": "The idea is to keep a running `curGrpSize` which keeps the current size and compare it to `grpSize` (which keeps the natural number to corresponding to the required size for the current grp).\\nEach grp will begin from `l->next` and end at `r.`\\nAs the `grpSize == curGrpSize`, we check if grpSize is even. If it is even, we reverse the grp using revList method, otherwise we move to the next grp.\\n\\n```\\n\\n\\nclass Solution {\\npublic:\\n    // method to reverse List, returns [head, tail];\\n    vector<ListNode*> revList(ListNode* head){\\n        ListNode* prev = NULL, * curr = head, *nxt = NULL;\\n        while(curr){\\n            nxt = curr -> next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = nxt;\\n        }\\n        return {prev, head};\\n    }\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        // grpSize will keep the Natural Number, which should be the size of the grp\\n        int grpSize = 1;\\n        // curGrpSize will keep the current size\\n        int curGrpSize = 1;\\n        // dummy will help in flipping from the next node if necessary\\n        ListNode* dummy = new ListNode();\\n        dummy->next = head;\\n        // The grp will start from l->next and end at r.\\n        ListNode* l = dummy, *r = head;\\n        while(r){\\n            // if the grp is even and has ended\\n            if(curGrpSize == grpSize and grpSize%2 == 0){\\n                // save imp pointers before flipping grp\\n                ListNode* tempHead = l->next;\\n                ListNode* tempLastNext = r->next;\\n                // make r pointer of grp as null so that reversing stops there\\n                r->next = NULL;\\n                // reverse the grp\\n                vector<ListNode*> nodes = revList(tempHead);\\n                // reconnect necessary pointers\\n                l->next = nodes[0];\\n                nodes[1]->next = tempLastNext;\\n                // prepare for next grp\\n                l =  nodes[1];\\n                r =  nodes[1]->next;\\n                grpSize++;\\n                curGrpSize = 1;\\n            }\\n            // if a grp has ended, but is odd\\n            else if(curGrpSize == grpSize){\\n                l = r;\\n                r = r->next;\\n                grpSize++;\\n                curGrpSize = 1;\\n            }\\n            // if a grp has not ended\\n            else{\\n                r = r->next;\\n                curGrpSize++;\\n            }\\n        }\\n        \\n        // if the last group is less than its Natural Number size, but is even.\\n        if((curGrpSize-1)%2 == 0){\\n            if(!l) return head;\\n            vector<ListNode*> nodes = revList(l -> next);\\n            l->next = nodes[0];\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\n\\nclass Solution {\\npublic:\\n    // method to reverse List, returns [head, tail];\\n    vector<ListNode*> revList(ListNode* head){\\n        ListNode* prev = NULL, * curr = head, *nxt = NULL;\\n        while(curr){\\n            nxt = curr -> next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = nxt;\\n        }\\n        return {prev, head};\\n    }\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        // grpSize will keep the Natural Number, which should be the size of the grp\\n        int grpSize = 1;\\n        // curGrpSize will keep the current size\\n        int curGrpSize = 1;\\n        // dummy will help in flipping from the next node if necessary\\n        ListNode* dummy = new ListNode();\\n        dummy->next = head;\\n        // The grp will start from l->next and end at r.\\n        ListNode* l = dummy, *r = head;\\n        while(r){\\n            // if the grp is even and has ended\\n            if(curGrpSize == grpSize and grpSize%2 == 0){\\n                // save imp pointers before flipping grp\\n                ListNode* tempHead = l->next;\\n                ListNode* tempLastNext = r->next;\\n                // make r pointer of grp as null so that reversing stops there\\n                r->next = NULL;\\n                // reverse the grp\\n                vector<ListNode*> nodes = revList(tempHead);\\n                // reconnect necessary pointers\\n                l->next = nodes[0];\\n                nodes[1]->next = tempLastNext;\\n                // prepare for next grp\\n                l =  nodes[1];\\n                r =  nodes[1]->next;\\n                grpSize++;\\n                curGrpSize = 1;\\n            }\\n            // if a grp has ended, but is odd\\n            else if(curGrpSize == grpSize){\\n                l = r;\\n                r = r->next;\\n                grpSize++;\\n                curGrpSize = 1;\\n            }\\n            // if a grp has not ended\\n            else{\\n                r = r->next;\\n                curGrpSize++;\\n            }\\n        }\\n        \\n        // if the last group is less than its Natural Number size, but is even.\\n        if((curGrpSize-1)%2 == 0){\\n            if(!l) return head;\\n            vector<ListNode*> nodes = revList(l -> next);\\n            l->next = nodes[0];\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1577010,
                "title": "javascript-simple-value-change",
                "content": "```javascript\\nvar reverseEvenLengthGroups = function(head) {\\n    const headNode = new ListNode(0, head);\\n    let prev = headNode;\\n    let group = 0;\\n    while (prev.next) {\\n        group++;\\n        const values = [];\\n        let start = prev\\n        for (let count = 0; count < group && start.next; count++) {\\n            start = start.next;\\n            values.push(start.val);\\n        }\\n        if (values.length % 2 === 0) {\\n            start = prev;\\n            for (let count = 0; count < group && start.next; count++) {\\n                start = start.next;\\n                start.val = values.pop();\\n            }\\n        }\\n        for (let count = 0; count < group && prev.next; count++) {\\n            prev = prev.next;\\n        }\\n    }\\n    return headNode.next;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar reverseEvenLengthGroups = function(head) {\\n    const headNode = new ListNode(0, head);\\n    let prev = headNode;\\n    let group = 0;\\n    while (prev.next) {\\n        group++;\\n        const values = [];\\n        let start = prev\\n        for (let count = 0; count < group && start.next; count++) {\\n            start = start.next;\\n            values.push(start.val);\\n        }\\n        if (values.length % 2 === 0) {\\n            start = prev;\\n            for (let count = 0; count < group && start.next; count++) {\\n                start = start.next;\\n                start.val = values.pop();\\n            }\\n        }\\n        for (let count = 0; count < group && prev.next; count++) {\\n            prev = prev.next;\\n        }\\n    }\\n    return headNode.next;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1576995,
                "title": "python3-reversing-slices",
                "content": "We change the linked list into normal list.\\nWe reverse the groups in the list.\\nWe create a new linked list and return the head.\\nTime is O(N). \\nSpace is O(N).\\n```\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        nodes=[]\\n        node=head\\n        while node:\\n            nodes.append(node.val)\\n            node=node.next\\n        n=len(nodes)\\n        i=0\\n        j=1\\n        while i<n:\\n            if j%2==0 and i+j<=n or 0==(n-i)%2 and n-i<j:\\n                nodes[i:i+j]=nodes[i:i+j][::-1]\\n            i+=j\\n            j+=1\\n        \\n        newHead=ListNode(nodes[0])\\n        node=newHead\\n        for x in nodes[1:]:\\n            node.next=ListNode(x)\\n            node=node.next    \\n        \\n        return newHead\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        nodes=[]\\n        node=head\\n        while node:\\n            nodes.append(node.val)\\n            node=node.next\\n        n=len(nodes)\\n        i=0\\n        j=1\\n        while i<n:\\n            if j%2==0 and i+j<=n or 0==(n-i)%2 and n-i<j:\\n                nodes[i:i+j]=nodes[i:i+j][::-1]\\n            i+=j\\n            j+=1\\n        \\n        newHead=ListNode(nodes[0])\\n        node=newHead\\n        for x in nodes[1:]:\\n            node.next=ListNode(x)\\n            node=node.next    \\n        \\n        return newHead\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1576945,
                "title": "python-solution-using-group-dictionary",
                "content": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    \\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        \\n        group_dict = defaultdict(list)\\n        temp = head\\n        group = 1\\n        count = 0\\n        while temp:\\n            group_dict[group].append(temp)\\n            temp = temp.next\\n            count+=1\\n            if count % group == 0:\\n                count = 0\\n                group+= 1\\n        head = None\\n        curr = None\\n        for i in range(1, group+1):\\n            if i == 1:\\n                head = group_dict[i][0]\\n                head.next = None\\n                curr = head\\n                continue\\n            lst = group_dict[i]\\n            if len(lst) % 2 == 0:\\n                lst.reverse()\\n            for root  in lst:\\n                curr.next = root\\n                curr = root\\n            curr.next = None\\n                \\n        return head\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    \\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        \\n        group_dict = defaultdict(list)\\n        temp = head\\n        group = 1\\n        count = 0\\n        while temp:\\n            group_dict[group].append(temp)\\n            temp = temp.next\\n            count+=1\\n            if count % group == 0:\\n                count = 0\\n                group+= 1\\n        head = None\\n        curr = None\\n        for i in range(1, group+1):\\n            if i == 1:\\n                head = group_dict[i][0]\\n                head.next = None\\n                curr = head\\n                continue\\n            lst = group_dict[i]\\n            if len(lst) % 2 == 0:\\n                lst.reverse()\\n            for root  in lst:\\n                curr.next = root\\n                curr = root\\n            curr.next = None\\n                \\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4059620,
                "title": "python-brute-force-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\n        values = []\\n        grp = 1\\n        itr = head\\n        temp = []\\n        while(itr!=None):\\n            temp.append(itr.val)\\n            if len(temp) == grp:\\n                if len(temp)%2 == 0:\\n                    temp = temp[::-1]\\n                values.append(temp)\\n                grp += 1\\n                temp = []\\n            itr = itr.next\\n        if len(temp)!= 0:\\n            if len(temp)%2 == 0:\\n                temp = temp[::-1]\\n            values.append(temp)\\n        itr = head\\n        for i in values:\\n            for j in i:\\n                itr.val = j\\n                itr = itr.next\\n        return head\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\n        values = []\\n        grp = 1\\n        itr = head\\n        temp = []\\n        while(itr!=None):\\n            temp.append(itr.val)\\n            if len(temp) == grp:\\n                if len(temp)%2 == 0:\\n                    temp = temp[::-1]\\n                values.append(temp)\\n                grp += 1\\n                temp = []\\n            itr = itr.next\\n        if len(temp)!= 0:\\n            if len(temp)%2 == 0:\\n                temp = temp[::-1]\\n            values.append(temp)\\n        itr = head\\n        for i in values:\\n            for j in i:\\n                itr.val = j\\n                itr = itr.next\\n        return head\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4047401,
                "title": "accepted-swift",
                "content": "```\\nclass Solution {\\n    func reverseEvenLengthGroups(_ head: ListNode?) -> ListNode? {\\n\\n        func reverse(\\n            _ size: Int,\\n            _ tail: ListNode?,\\n            _ begin: ListNode?,\\n            _ end: ListNode?\\n        ) -> ListNode? {\\n            \\n            guard size != 0, size % 2 == 0 else {\\n                return end\\n            }\\n\\n            var prev = begin\\n            var cur = prev?.next\\n\\n            while true {\\n                let next = cur?.next\\n                cur?.next = prev\\n                prev = cur\\n                cur = next\\n\\n                if prev === end {\\n                    break\\n                }\\n            }\\n\\n            tail?.next = prev\\n            begin?.next = cur\\n\\n            return begin\\n        }\\n        \\n        var tail: ListNode?\\n        var begin = head\\n        var end: ListNode?\\n        var cur = head\\n\\n        var target = 1\\n        var size = 0\\n\\n        while true {\\n\\n            if cur != nil {\\n                size += 1\\n                end = cur\\n            }\\n            \\n            if size == target || cur == nil {\\n                tail = reverse(size, tail, begin, end)\\n\\n                cur = tail\\n                begin = cur?.next\\n                end = cur?.next\\n\\n                target += 1\\n                size = 0\\n            }\\n\\n            if cur == nil {\\n                break\\n            }\\n\\n            cur = cur?.next\\n        }\\n\\n        return head\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func reverseEvenLengthGroups(_ head: ListNode?) -> ListNode? {\\n\\n        func reverse(\\n            _ size: Int,\\n            _ tail: ListNode?,\\n            _ begin: ListNode?,\\n            _ end: ListNode?\\n        ) -> ListNode? {\\n            \\n            guard size != 0, size % 2 == 0 else {\\n                return end\\n            }\\n\\n            var prev = begin\\n            var cur = prev?.next\\n\\n            while true {\\n                let next = cur?.next\\n                cur?.next = prev\\n                prev = cur\\n                cur = next\\n\\n                if prev === end {\\n                    break\\n                }\\n            }\\n\\n            tail?.next = prev\\n            begin?.next = cur\\n\\n            return begin\\n        }\\n        \\n        var tail: ListNode?\\n        var begin = head\\n        var end: ListNode?\\n        var cur = head\\n\\n        var target = 1\\n        var size = 0\\n\\n        while true {\\n\\n            if cur != nil {\\n                size += 1\\n                end = cur\\n            }\\n            \\n            if size == target || cur == nil {\\n                tail = reverse(size, tail, begin, end)\\n\\n                cur = tail\\n                begin = cur?.next\\n                end = cur?.next\\n\\n                target += 1\\n                size = 0\\n            }\\n\\n            if cur == nil {\\n                break\\n            }\\n\\n            cur = cur?.next\\n        }\\n\\n        return head\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4042361,
                "title": "java-o-1-space-solution-beats-96",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        ListNode oddTail = null, evenTail = null, curr = head;\\n        int currSize = 1;\\n        while (curr != null) {\\n            int mySize = 0;\\n            ListNode dummy = curr;\\n            while (dummy != null && mySize++ < currSize) dummy = dummy.next;\\n            if (mySize < currSize) currSize = mySize;\\n            if ((currSize & 1) == 1) {\\n                for (int i = 0; i < currSize; i++) {\\n                    if (i == currSize - 1) oddTail = curr;\\n                    curr = curr.next;\\n                }\\n            } else {\\n                evenTail = curr;\\n                ListNode prev = null;\\n                for (int i = 0; i < currSize && curr != null; i++) {\\n                    ListNode temp = curr.next;\\n                    curr.next = prev;\\n                    prev = curr;\\n                    curr = temp;\\n                }\\n                oddTail.next = prev;\\n                evenTail.next = curr;\\n                oddTail = evenTail;\\n            }\\n            currSize++;\\n        }\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        ListNode oddTail = null, evenTail = null, curr = head;\\n        int currSize = 1;\\n        while (curr != null) {\\n            int mySize = 0;\\n            ListNode dummy = curr;\\n            while (dummy != null && mySize++ < currSize) dummy = dummy.next;\\n            if (mySize < currSize) currSize = mySize;\\n            if ((currSize & 1) == 1) {\\n                for (int i = 0; i < currSize; i++) {\\n                    if (i == currSize - 1) oddTail = curr;\\n                    curr = curr.next;\\n                }\\n            } else {\\n                evenTail = curr;\\n                ListNode prev = null;\\n                for (int i = 0; i < currSize && curr != null; i++) {\\n                    ListNode temp = curr.next;\\n                    curr.next = prev;\\n                    prev = curr;\\n                    curr = temp;\\n                }\\n                oddTail.next = prev;\\n                evenTail.next = curr;\\n                oddTail = evenTail;\\n            }\\n            currSize++;\\n        }\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4038421,
                "title": "python3-straightforward-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        lst = []\\n        while head != None:\\n            lst.append(head.val)\\n            head = head.next\\n        N = len(lst)\\n        groups = []\\n        size = 1\\n        i = 0\\n        while i+size < N:\\n            tmp = []\\n            for j in range(i, size+i):\\n                tmp.append(lst[j])\\n            groups.append(tmp)\\n            i += size\\n            size += 1\\n        tmp = []\\n        for j in range(i, N):\\n            tmp.append(lst[j])\\n        groups.append(tmp)\\n\\n        ans = []\\n        for i, g in enumerate(groups):\\n            if len(g)%2==0:\\n                for j in range(len(g)-1, -1, -1):\\n                    ans.append(g[j])\\n            else:\\n                for j in range(len(g)):\\n                    ans.append(g[j])\\n\\n        root = ListNode(ans[0])\\n        prev = root\\n        for i in range(1, len(ans)):\\n            tmp = ListNode(ans[i])\\n            prev.next = tmp\\n            prev = tmp\\n\\n        return root\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        lst = []\\n        while head != None:\\n            lst.append(head.val)\\n            head = head.next\\n        N = len(lst)\\n        groups = []\\n        size = 1\\n        i = 0\\n        while i+size < N:\\n            tmp = []\\n            for j in range(i, size+i):\\n                tmp.append(lst[j])\\n            groups.append(tmp)\\n            i += size\\n            size += 1\\n        tmp = []\\n        for j in range(i, N):\\n            tmp.append(lst[j])\\n        groups.append(tmp)\\n\\n        ans = []\\n        for i, g in enumerate(groups):\\n            if len(g)%2==0:\\n                for j in range(len(g)-1, -1, -1):\\n                    ans.append(g[j])\\n            else:\\n                for j in range(len(g)):\\n                    ans.append(g[j])\\n\\n        root = ListNode(ans[0])\\n        prev = root\\n        for i in range(1, len(ans)):\\n            tmp = ListNode(ans[i])\\n            prev.next = tmp\\n            prev = tmp\\n\\n        return root\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4013470,
                "title": "c-c-iterative-one-pass-solution-with-five-pointers-95-time-complexity",
                "content": "Idea is very similar to solving [#25: Reverse nodes in k-group](https://leetcode.com/problems/reverse-nodes-in-k-group/). You only need five pointers to solve this problem. In the worst case, each node is traversed twice since you do not know the length of the next segment prior to visiting the node once.\\n\\n```\\nclass Solution {\\nprivate:\\n    ListNode *prev, *node, *next, *beforeprev;\\n    void reverseGroup(ListNode* beforeprev, ListNode* last, int k) {\\n        prev = beforeprev;\\n        node = prev->next;\\n        next = node->next;\\n        for (int i = 0; i < k - 1; i++) {\\n            node->next = prev;\\n            prev = node;\\n            node = next;\\n            next = node ? next->next : next;\\n        }\\n        node->next = prev;\\n        prev = node;\\n        node = next;\\n        beforeprev->next->next = last;\\n        beforeprev->next = prev;\\n    }\\n    \\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        node = head;\\n        int n = 2;\\n        while (node->next) {\\n            beforeprev = node;\\n            int i = 0;\\n            for (; i < n && node->next; i++) {\\n                node = node->next;\\n            }\\n            if (i % 2 == 0) {\\n                ListNode *save = beforeprev->next;\\n                reverseGroup(beforeprev, node ? node->next : 0, i);\\n                node = save;\\n            }\\n            n++;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    ListNode *prev, *node, *next, *beforeprev;\\n    void reverseGroup(ListNode* beforeprev, ListNode* last, int k) {\\n        prev = beforeprev;\\n        node = prev->next;\\n        next = node->next;\\n        for (int i = 0; i < k - 1; i++) {\\n            node->next = prev;\\n            prev = node;\\n            node = next;\\n            next = node ? next->next : next;\\n        }\\n        node->next = prev;\\n        prev = node;\\n        node = next;\\n        beforeprev->next->next = last;\\n        beforeprev->next = prev;\\n    }\\n    \\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        node = head;\\n        int n = 2;\\n        while (node->next) {\\n            beforeprev = node;\\n            int i = 0;\\n            for (; i < n && node->next; i++) {\\n                node = node->next;\\n            }\\n            if (i % 2 == 0) {\\n                ListNode *save = beforeprev->next;\\n                reverseGroup(beforeprev, node ? node->next : 0, i);\\n                node = save;\\n            }\\n            n++;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4012613,
                "title": "reverse-list-in-groups-of-k-method",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int findSize(ListNode *head){\\n        int ct=0;\\n        while(head) {\\n            head=head->next;\\n            ct++;\\n        }\\n        return ct;\\n    }\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        if(!head) return head;\\n        ListNode *dummy = new ListNode(-100);\\n        dummy->next=head;\\n        ListNode *prev=dummy,*curr;\\n        \\n        int size = findSize(head);\\n        \\n        for(int i=1,ct=1;i<size;i+=ct-1){\\n            curr=prev->next;\\n            // cout<<i<<\" \";\\n            for(int j=0;j<ct-1;j++){\\n                if(ct%2==0 and i+ct-1<size){\\n                    ListNode *nxt = curr->next;\\n                    curr->next = nxt->next;\\n                    nxt->next=prev->next;\\n                    prev->next=nxt;\\n                }\\n                else if(i+ct-1>=size){\\n                    int sz = findSize(curr);\\n                    // cout<<sz;\\n                    if(sz%2==0){\\n                        while(curr->next){\\n                            ListNode *nxt = curr->next;\\n                            curr->next = nxt->next;\\n                            nxt->next=prev->next;\\n                            prev->next=nxt;\\n                        }\\n                    }\\n                    else break;\\n                }\\n                else curr=curr->next;\\n            }\\n            \\n            prev=curr;\\n            ct++;\\n        }\\n        \\n        return dummy->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int findSize(ListNode *head){\\n        int ct=0;\\n        while(head) {\\n            head=head->next;\\n            ct++;\\n        }\\n        return ct;\\n    }\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        if(!head) return head;\\n        ListNode *dummy = new ListNode(-100);\\n        dummy->next=head;\\n        ListNode *prev=dummy,*curr;\\n        \\n        int size = findSize(head);\\n        \\n        for(int i=1,ct=1;i<size;i+=ct-1){\\n            curr=prev->next;\\n            // cout<<i<<\" \";\\n            for(int j=0;j<ct-1;j++){\\n                if(ct%2==0 and i+ct-1<size){\\n                    ListNode *nxt = curr->next;\\n                    curr->next = nxt->next;\\n                    nxt->next=prev->next;\\n                    prev->next=nxt;\\n                }\\n                else if(i+ct-1>=size){\\n                    int sz = findSize(curr);\\n                    // cout<<sz;\\n                    if(sz%2==0){\\n                        while(curr->next){\\n                            ListNode *nxt = curr->next;\\n                            curr->next = nxt->next;\\n                            nxt->next=prev->next;\\n                            prev->next=nxt;\\n                        }\\n                    }\\n                    else break;\\n                }\\n                else curr=curr->next;\\n            }\\n            \\n            prev=curr;\\n            ct++;\\n        }\\n        \\n        return dummy->next;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3986533,
                "title": "readable-ruby-solution-reverse-even-length-groups-in-o-n-time-o-1-space",
                "content": "# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode\\n#     attr_accessor :val, :next\\n#     def initialize(val = 0, _next = nil)\\n#         @val = val\\n#         @next = _next\\n#     end\\n# end\\n# @param {ListNode} head\\n# @return {ListNode}\\ndef reverse_even_length_groups(head)\\n    return head if !head.next || !head.next.next\\n\\n    select = head\\n    group = 1\\n    while select && select.next\\n        group += 1\\n\\n        # Check number of nodes\\n        count = 0\\n        temp = select.next\\n        while temp && count < group\\n            temp = temp.next\\n            count += 1\\n        end\\n\\n        # IF event THEN reverse\\n        if count % 2 == 0\\n            curr = select.next\\n            prev = nil\\n            for i in 0...count\\n                next_node = curr.next\\n                curr.next = prev\\n                prev = curr\\n                curr = next_node\\n            end\\n\\n            tail = select.next\\n            tail.next = curr\\n            select.next = prev\\n            select = tail\\n        else\\n            for i in 0...count\\n                select = select.next\\n            end\\n        end\\n    end\\n    head\\n    # Time Complexity: O(n)\\n    # Space Complexity: O(1)\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode\\n#     attr_accessor :val, :next\\n#     def initialize(val = 0, _next = nil)\\n#         @val = val\\n#         @next = _next\\n#     end\\n# end\\n# @param {ListNode} head\\n# @return {ListNode}\\ndef reverse_even_length_groups(head)\\n    return head if !head.next || !head.next.next\\n\\n    select = head\\n    group = 1\\n    while select && select.next\\n        group += 1\\n\\n        # Check number of nodes\\n        count = 0\\n        temp = select.next\\n        while temp && count < group\\n            temp = temp.next\\n            count += 1\\n        end\\n\\n        # IF event THEN reverse\\n        if count % 2 == 0\\n            curr = select.next\\n            prev = nil\\n            for i in 0...count\\n                next_node = curr.next\\n                curr.next = prev\\n                prev = curr\\n                curr = next_node\\n            end\\n\\n            tail = select.next\\n            tail.next = curr\\n            select.next = prev\\n            select = tail\\n        else\\n            for i in 0...count\\n                select = select.next\\n            end\\n        end\\n    end\\n    head\\n    # Time Complexity: O(n)\\n    # Space Complexity: O(1)\\nend\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3986487,
                "title": "readable-typescript-solution-reverse-even-length-groups-in-o-n-time-o-1-space",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * class ListNode {\\n *     val: number\\n *     next: ListNode | null\\n *     constructor(val?: number, next?: ListNode | null) {\\n *         this.val = (val===undefined ? 0 : val)\\n *         this.next = (next===undefined ? null : next)\\n *     }\\n * }\\n */\\n\\nfunction reverseEvenLengthGroups(head: ListNode | null): ListNode | null {\\n    if (!head.next || !head.next.next) return head;\\n    \\n    let select = head;\\n    let group = 1;\\n    while (select && select.next) {\\n        group++;\\n\\n        // Check number of nodes\\n        let count = 0;\\n        let temp = select.next;\\n        while (temp && count < group) {\\n            temp = temp.next\\n            count++;\\n        }\\n\\n        // IF even THEN reverse\\n        if (count % 2 === 0) {\\n            let curr = select.next;\\n            let prev = null;\\n            for (let i = 0; i < count; i++) {\\n                const nextNode = curr.next;\\n                curr.next = prev;\\n                prev = curr;\\n                curr = nextNode;\\n            }\\n\\n            let tail = select.next;\\n            tail.next = curr;\\n            select.next = prev;\\n            select = tail;\\n        } else {\\n            for (let i = 0; i < count; i++) {\\n                select = select.next;\\n            }\\n        }\\n    }\\n    return head;\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * class ListNode {\\n *     val: number\\n *     next: ListNode | null\\n *     constructor(val?: number, next?: ListNode | null) {\\n *         this.val = (val===undefined ? 0 : val)\\n *         this.next = (next===undefined ? null : next)\\n *     }\\n * }\\n */\\n\\nfunction reverseEvenLengthGroups(head: ListNode | null): ListNode | null {\\n    if (!head.next || !head.next.next) return head;\\n    \\n    let select = head;\\n    let group = 1;\\n    while (select && select.next) {\\n        group++;\\n\\n        // Check number of nodes\\n        let count = 0;\\n        let temp = select.next;\\n        while (temp && count < group) {\\n            temp = temp.next\\n            count++;\\n        }\\n\\n        // IF even THEN reverse\\n        if (count % 2 === 0) {\\n            let curr = select.next;\\n            let prev = null;\\n            for (let i = 0; i < count; i++) {\\n                const nextNode = curr.next;\\n                curr.next = prev;\\n                prev = curr;\\n                curr = nextNode;\\n            }\\n\\n            let tail = select.next;\\n            tail.next = curr;\\n            select.next = prev;\\n            select = tail;\\n        } else {\\n            for (let i = 0; i < count; i++) {\\n                select = select.next;\\n            }\\n        }\\n    }\\n    return head;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3984990,
                "title": "c-simple-implementation-with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    ListNode* reverseNode(ListNode*head){\\n        ListNode* prev=NULL;\\n        ListNode* curr=head;\\n        ListNode* nxt=head->next;\\n        while(curr!=NULL){\\n            nxt=curr->next;\\n            curr->next=prev;\\n            prev=curr;\\n            curr=nxt;\\n        }\\n        //setting head of reversed node\\n        return prev;\\n    }\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        if(head==NULL||head->next==NULL){\\n            return head;\\n        }\\n        int group=1;\\n        ListNode* t1=head;\\n        ListNode* t2=head;\\n        //here prev and nxr refers to different context\\n        ListNode* prev=head;\\n        ListNode* nxt=head->next;\\n        ListNode* revHead=NULL;\\n        while(t1!=NULL&&t2!=NULL){\\n            if(group%2==0){\\n                //then we have to reverse it \\n                int count=1;\\n                while(t2->next!=NULL&&count!=group){\\n                    t2=t2->next;\\n                    count++;\\n                }\\n                //reverse only if in even group node\\'s length is even\\n                if(count%2==0){\\n                //storing addres of t2\\'s next group\\n                nxt=t2->next;\\n                //reverse nodes from t1 to t2\\n                t2->next=NULL;\\n                revHead=reverseNode(t1);\\n                //t1 holds head of reversed list\\n                //conneting the nodes\\n                prev->next->next=nxt;\\n                prev->next=revHead;  \\n                prev=t1;\\n                }\\n                else{\\n                    //changing prev position\\n                    prev=t2;\\n                    nxt=t2->next;                    \\n                }\\n            }else{\\n                //check if group lenght is even then only reverse it\\n                int count=1;\\n                while(t2->next!=NULL&&count!=group){\\n                    t2=t2->next;\\n                    count++;\\n                }\\n                if(count%2==0){\\n                    //its means group length is still even so reverse it\\n                     //storing addres of t2\\'s next group\\n                    nxt=t2->next;\\n                    //reverse nodes from t1 to t2\\n                    t2->next=NULL;\\n                    revHead=reverseNode(t1);\\n                //t1 holds head of reversed list\\n                //conneting the nodes\\n                prev->next->next=nxt;\\n                prev->next=revHead;  \\n                prev=t1;\\n                }else{\\n                    //changing prev position\\n                    prev=t2;\\n                    nxt=t2->next;\\n                }\\n            }\\n            t1=nxt;\\n            t2=nxt;\\n            group++;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* reverseNode(ListNode*head){\\n        ListNode* prev=NULL;\\n        ListNode* curr=head;\\n        ListNode* nxt=head->next;\\n        while(curr!=NULL){\\n            nxt=curr->next;\\n            curr->next=prev;\\n            prev=curr;\\n            curr=nxt;\\n        }\\n        //setting head of reversed node\\n        return prev;\\n    }\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        if(head==NULL||head->next==NULL){\\n            return head;\\n        }\\n        int group=1;\\n        ListNode* t1=head;\\n        ListNode* t2=head;\\n        //here prev and nxr refers to different context\\n        ListNode* prev=head;\\n        ListNode* nxt=head->next;\\n        ListNode* revHead=NULL;\\n        while(t1!=NULL&&t2!=NULL){\\n            if(group%2==0){\\n                //then we have to reverse it \\n                int count=1;\\n                while(t2->next!=NULL&&count!=group){\\n                    t2=t2->next;\\n                    count++;\\n                }\\n                //reverse only if in even group node\\'s length is even\\n                if(count%2==0){\\n                //storing addres of t2\\'s next group\\n                nxt=t2->next;\\n                //reverse nodes from t1 to t2\\n                t2->next=NULL;\\n                revHead=reverseNode(t1);\\n                //t1 holds head of reversed list\\n                //conneting the nodes\\n                prev->next->next=nxt;\\n                prev->next=revHead;  \\n                prev=t1;\\n                }\\n                else{\\n                    //changing prev position\\n                    prev=t2;\\n                    nxt=t2->next;                    \\n                }\\n            }else{\\n                //check if group lenght is even then only reverse it\\n                int count=1;\\n                while(t2->next!=NULL&&count!=group){\\n                    t2=t2->next;\\n                    count++;\\n                }\\n                if(count%2==0){\\n                    //its means group length is still even so reverse it\\n                     //storing addres of t2\\'s next group\\n                    nxt=t2->next;\\n                    //reverse nodes from t1 to t2\\n                    t2->next=NULL;\\n                    revHead=reverseNode(t1);\\n                //t1 holds head of reversed list\\n                //conneting the nodes\\n                prev->next->next=nxt;\\n                prev->next=revHead;  \\n                prev=t1;\\n                }else{\\n                    //changing prev position\\n                    prev=t2;\\n                    nxt=t2->next;\\n                }\\n            }\\n            t1=nxt;\\n            t2=nxt;\\n            group++;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3976647,
                "title": "java-o-n-solution",
                "content": "# Intuition\\nI used ArrayList\\n\\n# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        List<Integer> list = new ArrayList<>();\\n        ListNode temp = head;\\n        while (temp != null) {\\n            list.add(temp.val);\\n            temp = temp.next;\\n        }\\n        int idx = 0, count = 0;\\n        while (idx < list.size()) {\\n            if ((Math.min(idx + count, list.size() - 1) - idx) % 2 == 1)\\n                reverse(list, idx, Math.min(idx + count, list.size() - 1));\\n            idx += count + 1;\\n            count++;\\n        }\\n        temp = head;\\n        count = 0;\\n        while (temp != null) {\\n            temp.val = list.get(count++);\\n            temp = temp.next;\\n        }\\n        return head;\\n    }\\n\\n    private static void reverse(List<Integer> list, int l, int r) {\\n        for (int i = l, k = 0; i <= (r + l) / 2; i++) {\\n            int t = list.get(r - k);\\n            list.set(r - k++, list.get(i));\\n            list.set(i, t);\\n        }\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        List<Integer> list = new ArrayList<>();\\n        ListNode temp = head;\\n        while (temp != null) {\\n            list.add(temp.val);\\n            temp = temp.next;\\n        }\\n        int idx = 0, count = 0;\\n        while (idx < list.size()) {\\n            if ((Math.min(idx + count, list.size() - 1) - idx) % 2 == 1)\\n                reverse(list, idx, Math.min(idx + count, list.size() - 1));\\n            idx += count + 1;\\n            count++;\\n        }\\n        temp = head;\\n        count = 0;\\n        while (temp != null) {\\n            temp.val = list.get(count++);\\n            temp = temp.next;\\n        }\\n        return head;\\n    }\\n\\n    private static void reverse(List<Integer> list, int l, int r) {\\n        for (int i = l, k = 0; i <= (r + l) / 2; i++) {\\n            int t = list.get(r - k);\\n            list.set(r - k++, list.get(i));\\n            list.set(i, t);\\n        }\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3964587,
                "title": "java-beats-96-o-n-time-o-1-space-simple-solution",
                "content": "# Intuition\\nI think is HARD problem.\\nComing up with the logic of the solution is quite easy. It all consists in implementing the reversal of the linked list with the input: head, tail and the previous element behind the head\\nThe difficulty lies in writing the algorithm itself and handling the edge cases\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: (1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        if (head == null) return head;\\n        ListNode node = head;\\n        ListNode temp = head;\\n        int i = 2;\\n        int ind = 0;\\n        while (node.next != null) {\\n            node = temp;\\n            ind = 0;\\n            while (ind < i && node.next != null) {\\n                node = node.next;\\n                ind++;\\n            }\\n            if ((i % 2 == 0 && node.next != null) || (node.next == null && ind % 2 == 0)) {\\n                ListNode temp1 = temp.next;\\n                temp.next = reverse(temp1, node, node.next);\\n                temp = temp1;\\n            } else if (node.next != null) {\\n                temp = node;\\n            }\\n            i++;\\n        }\\n        return head;\\n    }\\n\\n    private ListNode reverse(ListNode head, ListNode tail, ListNode prev1) {\\n        if (head == null) return head;\\n        ListNode prev = prev1;\\n        ListNode curr = head;\\n        ListNode next = curr.next == null ? null : curr.next;\\n        while (curr != tail) {\\n            curr.next = prev;\\n            prev = curr;\\n            curr = next;\\n            next = next.next == null ? null : next.next;\\n        }\\n        curr.next = prev;\\n        return curr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        if (head == null) return head;\\n        ListNode node = head;\\n        ListNode temp = head;\\n        int i = 2;\\n        int ind = 0;\\n        while (node.next != null) {\\n            node = temp;\\n            ind = 0;\\n            while (ind < i && node.next != null) {\\n                node = node.next;\\n                ind++;\\n            }\\n            if ((i % 2 == 0 && node.next != null) || (node.next == null && ind % 2 == 0)) {\\n                ListNode temp1 = temp.next;\\n                temp.next = reverse(temp1, node, node.next);\\n                temp = temp1;\\n            } else if (node.next != null) {\\n                temp = node;\\n            }\\n            i++;\\n        }\\n        return head;\\n    }\\n\\n    private ListNode reverse(ListNode head, ListNode tail, ListNode prev1) {\\n        if (head == null) return head;\\n        ListNode prev = prev1;\\n        ListNode curr = head;\\n        ListNode next = curr.next == null ? null : curr.next;\\n        while (curr != tail) {\\n            curr.next = prev;\\n            prev = curr;\\n            curr = next;\\n            next = next.next == null ? null : next.next;\\n        }\\n        curr.next = prev;\\n        return curr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3960822,
                "title": "don-t-use-this-code-don-t",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI am speechless, 3 - 4 hours... I am glad I kept with it but whatever you do. Don\\'t try to understand it. I was so stubborn I didn\\'t want to look up the right way to do it so I just kept trying and trying.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        \\n        ListNode * dummy = new ListNode(0, head);\\n        ListNode * curr = dummy->next;\\n        ListNode * prevNode = nullptr;\\n        ListNode * prevprevNode = nullptr;\\n\\n        int index, nodesAccessed = 0;\\n        int needToBeAcessed = 1;\\n        int groupCount = 0;\\n\\n        bool checking = false;\\n        int checkingInt = 0;\\n\\n\\n        while(curr != nullptr)\\n        {\\n            if(nodesAccessed == needToBeAcessed)\\n            {\\n\\n                ListNode * prev = nullptr;\\n                ListNode * firstNode = nullptr;\\n\\n                if(curr->next != nullptr) firstNode = curr;\\n\\n                for(int i = 0; i < (nodesAccessed + 1); i++)\\n                {\\n                    checkingInt++;\\n                    if(curr == nullptr){\\n                        checking = true;\\n                        break;\\n                    } \\n                    ListNode* nextNode = curr->next; \\n                    curr->next = prev;            \\n                    prev = curr;                   \\n                    curr = nextNode;                \\n                }\\n\\n                \\n\\n                prevNode->next = prev;\\n                if(firstNode != nullptr && curr != nullptr) firstNode->next = curr;\\n                nodesAccessed = 0; groupCount = 0; needToBeAcessed += 2; \\n\\n                if(checking != true) checkingInt = 0;\\n                if(checking != true) groupCount = 0;\\n\\n\\n            }\\n\\n            nodesAccessed++;\\n            groupCount++;\\n\\n            index++;\\n            prevNode = curr;\\n\\n            if(curr != nullptr) curr = curr->next;\\n        }\\n\\n        if(groupCount % 2 == 0)\\n        {\\n            ListNode * first = head;\\n\\n            for(int i = 0; i < groupCount + 1; i++)\\n            {\\n                first = first->next;\\n            }\\n\\n            ListNode * second = head;\\n\\n            while(first!=nullptr)\\n            {\\n                first = first->next;\\n                second = second->next;\\n            }\\n\\n\\n            ListNode * curr = second->next;\\n            ListNode * prev = nullptr;\\n\\n            for(int j = 0; j < groupCount; j++)\\n            {\\n                if(curr == nullptr) break;\\n                ListNode* nextNode = curr->next; \\n                curr->next = prev;            \\n                prev = curr;                   \\n                curr = nextNode;   \\n            }\\n\\n            second->next = prev;\\n\\n        }\\n\\n        if(checking == true)\\n        {\\n            if(checkingInt % 2 == 0){\\n\\n\\n                ListNode * first = head;\\n\\n                for(int i = 0; i < checkingInt; i++)\\n                {\\n                    first = first->next;\\n                }\\n\\n                ListNode * second = head;\\n\\n                while(first!=nullptr)\\n                {\\n                    first = first->next;\\n                    second = second->next;\\n                }\\n\\n                ListNode * curr = second->next;\\n                ListNode * prev = nullptr;\\n\\n\\n\\n\\n                \\n\\n                for(int j = 0; j < checkingInt; j++)\\n                {\\n                    if(curr == nullptr) break;\\n                    ListNode* nextNode = curr->next; \\n                    curr->next = prev;            \\n                    prev = curr;                   \\n                    curr = nextNode;   \\n                }\\n                \\n\\n                second->next = prev;\\n            }\\n        }\\n\\n\\n        return dummy->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        \\n        ListNode * dummy = new ListNode(0, head);\\n        ListNode * curr = dummy->next;\\n        ListNode * prevNode = nullptr;\\n        ListNode * prevprevNode = nullptr;\\n\\n        int index, nodesAccessed = 0;\\n        int needToBeAcessed = 1;\\n        int groupCount = 0;\\n\\n        bool checking = false;\\n        int checkingInt = 0;\\n\\n\\n        while(curr != nullptr)\\n        {\\n            if(nodesAccessed == needToBeAcessed)\\n            {\\n\\n                ListNode * prev = nullptr;\\n                ListNode * firstNode = nullptr;\\n\\n                if(curr->next != nullptr) firstNode = curr;\\n\\n                for(int i = 0; i < (nodesAccessed + 1); i++)\\n                {\\n                    checkingInt++;\\n                    if(curr == nullptr){\\n                        checking = true;\\n                        break;\\n                    } \\n                    ListNode* nextNode = curr->next; \\n                    curr->next = prev;            \\n                    prev = curr;                   \\n                    curr = nextNode;                \\n                }\\n\\n                \\n\\n                prevNode->next = prev;\\n                if(firstNode != nullptr && curr != nullptr) firstNode->next = curr;\\n                nodesAccessed = 0; groupCount = 0; needToBeAcessed += 2; \\n\\n                if(checking != true) checkingInt = 0;\\n                if(checking != true) groupCount = 0;\\n\\n\\n            }\\n\\n            nodesAccessed++;\\n            groupCount++;\\n\\n            index++;\\n            prevNode = curr;\\n\\n            if(curr != nullptr) curr = curr->next;\\n        }\\n\\n        if(groupCount % 2 == 0)\\n        {\\n            ListNode * first = head;\\n\\n            for(int i = 0; i < groupCount + 1; i++)\\n            {\\n                first = first->next;\\n            }\\n\\n            ListNode * second = head;\\n\\n            while(first!=nullptr)\\n            {\\n                first = first->next;\\n                second = second->next;\\n            }\\n\\n\\n            ListNode * curr = second->next;\\n            ListNode * prev = nullptr;\\n\\n            for(int j = 0; j < groupCount; j++)\\n            {\\n                if(curr == nullptr) break;\\n                ListNode* nextNode = curr->next; \\n                curr->next = prev;            \\n                prev = curr;                   \\n                curr = nextNode;   \\n            }\\n\\n            second->next = prev;\\n\\n        }\\n\\n        if(checking == true)\\n        {\\n            if(checkingInt % 2 == 0){\\n\\n\\n                ListNode * first = head;\\n\\n                for(int i = 0; i < checkingInt; i++)\\n                {\\n                    first = first->next;\\n                }\\n\\n                ListNode * second = head;\\n\\n                while(first!=nullptr)\\n                {\\n                    first = first->next;\\n                    second = second->next;\\n                }\\n\\n                ListNode * curr = second->next;\\n                ListNode * prev = nullptr;\\n\\n\\n\\n\\n                \\n\\n                for(int j = 0; j < checkingInt; j++)\\n                {\\n                    if(curr == nullptr) break;\\n                    ListNode* nextNode = curr->next; \\n                    curr->next = prev;            \\n                    prev = curr;                   \\n                    curr = nextNode;   \\n                }\\n                \\n\\n                second->next = prev;\\n            }\\n        }\\n\\n\\n        return dummy->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3953470,
                "title": "java-use-list-to-reverse-even-group-items",
                "content": "# Intuition\\n# Approach\\n- Traverse linked list for # group items and add into a list\\n- if even items in group, reverse items in list\\n- From start of group node, replace values of node using reversed list\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        ListNode curr = head;\\n        int count = 0;\\n        while(curr != null) {\\n            count++;\\n            int i=0;\\n            ListNode start = curr;\\n            List<Integer> nums = new ArrayList<>();\\n            while(i<count && curr != null) {\\n                nums.add(curr.val);\\n                curr = curr.next;\\n                i++;\\n            }\\n            if(i%2 == 0) {\\n                Collections.reverse(nums);\\n                for(int j = 0; j<i; j++) {\\n                    start.val = nums.get(j);\\n                    start = start.next;\\n                }\\n            }\\n        }\\n        return head;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        ListNode curr = head;\\n        int count = 0;\\n        while(curr != null) {\\n            count++;\\n            int i=0;\\n            ListNode start = curr;\\n            List<Integer> nums = new ArrayList<>();\\n            while(i<count && curr != null) {\\n                nums.add(curr.val);\\n                curr = curr.next;\\n                i++;\\n            }\\n            if(i%2 == 0) {\\n                Collections.reverse(nums);\\n                for(int j = 0; j<i; j++) {\\n                    start.val = nums.get(j);\\n                    start = start.next;\\n                }\\n            }\\n        }\\n        return head;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3946091,
                "title": "kotlin-two-pointers",
                "content": "# Intuition\\nI\\'m new here and this problem turned out to be hard for me, so I used the hints and that\\'s what I\\'ve got :)\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * Example:\\n * var li = ListNode(5)\\n * var v = li.`val`\\n * Definition for singly-linked list.\\n * class ListNode(var `val`: Int) {\\n *     var next: ListNode? = null\\n * }\\n */\\nclass Solution {\\n    fun reverseEvenLengthGroups(head: ListNode?): ListNode? {\\n        var prevGroup: ListNode? = null   // pointer to the end of the previous group\\n        var begGroup = head               // pointer to the beginning of the current group\\n        var endGroup = head               // pointer to the end of the current group\\n        var nextGroup = head?.next        // pointer to the next group\\n        var groupCount = 1\\n\\n        while (nextGroup?.next != null) {\\n            groupCount++\\n\\n            // depends on whether the previous group was even or not\\n            prevGroup = if (groupCount % 2 == 0) endGroup else begGroup\\n            begGroup = nextGroup\\n            endGroup = begGroup\\n\\n            // traverse through a group\\n            var groupLength = 1\\n            while (groupLength < groupCount && endGroup?.next != null) {\\n                endGroup = endGroup.next\\n                groupLength++\\n            }\\n            nextGroup = endGroup?.next\\n\\n            // reverse the group if the group length is even\\n            if (groupLength % 2 == 0) {\\n                reverseList(begGroup, prevGroup, nextGroup)\\n\\n                // fix the connections\\n                prevGroup!!.next = endGroup\\n                if (begGroup != null) {\\n                    begGroup!!.next = nextGroup\\n                }\\n            }\\n        }\\n\\n        return head\\n    }\\n\\n    fun reverseList(currNode: ListNode?, prevNode: ListNode?, nextGroup: ListNode?) {\\n        var curr = currNode\\n        var prev = prevNode\\n\\n        while (curr != nextGroup) {\\n            val nextNode = curr?.next\\n            curr!!.next = prev\\n            prev = curr\\n            curr = nextNode\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\n/**\\n * Example:\\n * var li = ListNode(5)\\n * var v = li.`val`\\n * Definition for singly-linked list.\\n * class ListNode(var `val`: Int) {\\n *     var next: ListNode? = null\\n * }\\n */\\nclass Solution {\\n    fun reverseEvenLengthGroups(head: ListNode?): ListNode? {\\n        var prevGroup: ListNode? = null   // pointer to the end of the previous group\\n        var begGroup = head               // pointer to the beginning of the current group\\n        var endGroup = head               // pointer to the end of the current group\\n        var nextGroup = head?.next        // pointer to the next group\\n        var groupCount = 1\\n\\n        while (nextGroup?.next != null) {\\n            groupCount++\\n\\n            // depends on whether the previous group was even or not\\n            prevGroup = if (groupCount % 2 == 0) endGroup else begGroup\\n            begGroup = nextGroup\\n            endGroup = begGroup\\n\\n            // traverse through a group\\n            var groupLength = 1\\n            while (groupLength < groupCount && endGroup?.next != null) {\\n                endGroup = endGroup.next\\n                groupLength++\\n            }\\n            nextGroup = endGroup?.next\\n\\n            // reverse the group if the group length is even\\n            if (groupLength % 2 == 0) {\\n                reverseList(begGroup, prevGroup, nextGroup)\\n\\n                // fix the connections\\n                prevGroup!!.next = endGroup\\n                if (begGroup != null) {\\n                    begGroup!!.next = nextGroup\\n                }\\n            }\\n        }\\n\\n        return head\\n    }\\n\\n    fun reverseList(currNode: ListNode?, prevNode: ListNode?, nextGroup: ListNode?) {\\n        var curr = currNode\\n        var prev = prevNode\\n\\n        while (curr != nextGroup) {\\n            val nextNode = curr?.next\\n            curr!!.next = prev\\n            prev = curr\\n            curr = nextNode\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3943025,
                "title": "simple-solution-with-recursion-o-n",
                "content": "\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if not head or not head.next:\\n            return head\\n \\n        prev_node, cnt, len_group = head, 1, 1\\n        while prev_node.next:\\n            if cnt == len_group:\\n                last_group = prev_node\\n                if len_group%2:\\n                    node = prev_node.next\\n                    new_head, next_node = self.reverseList(node, len_group, 0)\\n                    if new_head:             \\n                        prev_node.next = new_head\\n                        node.next = next_node\\n                    if not next_node:\\n                        return head             \\n                cnt = 0\\n                len_group += 1\\n            cnt += 1           \\n            prev_node = prev_node.next\\n            \\n        if last_group.next:\\n            node = last_group.next\\n            new_head, _ = self.reverseList(node, len_group, 0)\\n            if new_head:             \\n                last_group.next = new_head\\n                node.next = None\\n        return head  \\n\\n    def reverseList(self, head: Optional[ListNode], k, cnt) -> Optional[ListNode]:\\n        if k == cnt:\\n            return head, head.next\\n        if not head.next and cnt%2:\\n            return head, None\\n        elif not head.next:\\n            return None, None\\n        new_head, next_node = self.reverseList(head.next, k, cnt+1)\\n        if new_head:\\n            head.next.next = head\\n        return new_head, next_node\\n```",
                "solutionTags": [
                    "Python3",
                    "Linked List",
                    "Recursion"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if not head or not head.next:\\n            return head\\n \\n        prev_node, cnt, len_group = head, 1, 1\\n        while prev_node.next:\\n            if cnt == len_group:\\n                last_group = prev_node\\n                if len_group%2:\\n                    node = prev_node.next\\n                    new_head, next_node = self.reverseList(node, len_group, 0)\\n                    if new_head:             \\n                        prev_node.next = new_head\\n                        node.next = next_node\\n                    if not next_node:\\n                        return head             \\n                cnt = 0\\n                len_group += 1\\n            cnt += 1           \\n            prev_node = prev_node.next\\n            \\n        if last_group.next:\\n            node = last_group.next\\n            new_head, _ = self.reverseList(node, len_group, 0)\\n            if new_head:             \\n                last_group.next = new_head\\n                node.next = None\\n        return head  \\n\\n    def reverseList(self, head: Optional[ListNode], k, cnt) -> Optional[ListNode]:\\n        if k == cnt:\\n            return head, head.next\\n        if not head.next and cnt%2:\\n            return head, None\\n        elif not head.next:\\n            return None, None\\n        new_head, next_node = self.reverseList(head.next, k, cnt+1)\\n        if new_head:\\n            head.next.next = head\\n        return new_head, next_node\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3938887,
                "title": "java-solution-o-n-time-and-in-place",
                "content": "\\n```\\nclass Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        ListNode cur = head;\\n        ListNode pre = head;\\n        int distance = 1;\\n        int remain = 0;\\n        while (cur != null) {\\n            remain++;\\n            cur = cur.next;\\n        }\\n        cur = head;\\n\\n        while (cur != null && cur.next != null) {\\n            if ((remain >= distance && distance % 2 == 1) || (remain < distance && remain % 2 == 1)) { // keep\\n                for (int i = 0; i < distance && cur.next != null; i++) {\\n                    pre = cur;\\n                    cur = cur.next;\\n                }\\n            } else { // reverse\\n                for (int i = 0; i < distance - 1 && cur.next != null; i++) {\\n                    ListNode newCur = cur.next;\\n                    cur.next = newCur.next;\\n                    newCur.next = pre.next;\\n                    pre.next = newCur;\\n                }\\n                if (cur.next != null) {\\n                    pre = cur;\\n                    cur = cur.next;\\n                }\\n            }\\n            remain -= distance;\\n            distance++;\\n        }\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        ListNode cur = head;\\n        ListNode pre = head;\\n        int distance = 1;\\n        int remain = 0;\\n        while (cur != null) {\\n            remain++;\\n            cur = cur.next;\\n        }\\n        cur = head;\\n\\n        while (cur != null && cur.next != null) {\\n            if ((remain >= distance && distance % 2 == 1) || (remain < distance && remain % 2 == 1)) { // keep\\n                for (int i = 0; i < distance && cur.next != null; i++) {\\n                    pre = cur;\\n                    cur = cur.next;\\n                }\\n            } else { // reverse\\n                for (int i = 0; i < distance - 1 && cur.next != null; i++) {\\n                    ListNode newCur = cur.next;\\n                    cur.next = newCur.next;\\n                    newCur.next = pre.next;\\n                    pre.next = newCur;\\n                }\\n                if (cur.next != null) {\\n                    pre = cur;\\n                    cur = cur.next;\\n                }\\n            }\\n            remain -= distance;\\n            distance++;\\n        }\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3937333,
                "title": "java-easiest-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        ListNode temp=head;\\n        int num=1;\\n        while(temp!=null){\\n            int count=0;\\n            ListNode start=temp;\\n            Stack st=new Stack();\\n            while(count!=num && temp!=null){\\n                st.push(temp.val);\\n                temp=temp.next;\\n                count++;\\n            }\\n            if(count%2==0){\\n                while(temp!=start){\\n                    start.val=(int) st.pop();\\n                    start=start.next;\\n                }\\n            }\\n            num++;\\n        }\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        ListNode temp=head;\\n        int num=1;\\n        while(temp!=null){\\n            int count=0;\\n            ListNode start=temp;\\n            Stack st=new Stack();\\n            while(count!=num && temp!=null){\\n                st.push(temp.val);\\n                temp=temp.next;\\n                count++;\\n            }\\n            if(count%2==0){\\n                while(temp!=start){\\n                    start.val=(int) st.pop();\\n                    start=start.next;\\n                }\\n            }\\n            num++;\\n        }\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3924897,
                "title": "python-simple-solution-not-reverse-linked-list-in-place",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf you wanna do it in place, it is a hard problem.\\nOn the other hand, if you store the node in a list and rebuild linked list after doing the reverse, it is a medium problem.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        l = []\\n        while head:\\n            l.append(head)\\n            head = head.next\\n        n = len(l)\\n        start, end, cur = 0, 1, 1\\n        while end <= n:\\n            if cur%2 == 0:\\n                #reverse\\n                l[start:end] = l[start:end][::-1]\\n            start += cur\\n            cur += 1\\n            end += cur\\n        if (n-start)%2 == 0: l[start:n] = l[start:n][::-1]\\n\\n        node = dummy = ListNode()\\n        for n in l:\\n            node.next = n\\n            node = node.next\\n        node.next = None\\n        return dummy.next\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        l = []\\n        while head:\\n            l.append(head)\\n            head = head.next\\n        n = len(l)\\n        start, end, cur = 0, 1, 1\\n        while end <= n:\\n            if cur%2 == 0:\\n                #reverse\\n                l[start:end] = l[start:end][::-1]\\n            start += cur\\n            cur += 1\\n            end += cur\\n        if (n-start)%2 == 0: l[start:n] = l[start:n][::-1]\\n\\n        node = dummy = ListNode()\\n        for n in l:\\n            node.next = n\\n            node = node.next\\n        node.next = None\\n        return dummy.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3921501,
                "title": "explained-beats-98-c-recursive-approach-for-multiple-question",
                "content": "# Intuition\\nIs same as, Solve below in order for better understanding. \\n1. https://leetcode.com/problems/swap-nodes-in-pairs/\\n2. https://leetcode.com/problems/reverse-nodes-in-k-group/\\n\\n# Approach\\nWe will use recursive approach to handle dynamic length reversal.\\n\\nTo handling last group case\\n### Observation \\nIt can be happend in both odd/even group case when \\'curr\\' become NULL. Also you can say, last group len will always <= current group.\\n### Requirement\\nReverse the nodes in each group with an even length\\n\\nSo last group may be of any length in both cases.\\nwe can find the length using \\'k\\'. and perform re-reverse/reverse operation corresponding to if/else statement.\\n\\nIn event group case i.e. if condition, if remaining \\'k\\' is odd -> len(last group) is odd. re-reverse needed.\\n\\nIn odd  group case i.e. else condition, if remaining \\'k\\' = odd -> len(last group) is even. reverse needed.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$ for recursive stack\\n\\n# Code\\n```\\nclass Solution {\\n    // for handling last group case only\\n    ListNode* reverse(ListNode* head) {\\n        ListNode* prev = NULL, *curr = head, *next = NULL;\\n\\n        while(curr) {\\n            next = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = next;\\n        }\\n\\n        return prev;\\n    }\\n\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head, int group = 1) {\\n        if(!head) return head;\\n\\n        ListNode *prev = NULL, *curr = head, *next = NULL;\\n        int k = group;\\n\\n        if(k % 2 == 0) {\\n            while(curr && k) {\\n                next = curr->next;\\n                curr->next = prev;\\n                prev = curr;\\n                curr = next;\\n                k--;\\n            }\\n            head->next = reverseEvenLengthGroups(curr, group+1);\\n\\n            // Since curr is NULL and we are in even group, so we need to handling last group\\n            if(k&1) { // if k is odd, len of last group will odd, so we will revert.\\n                return reverse(prev);\\n            }\\n            return prev;\\n\\n        } else {\\n            while(curr && k) {\\n                prev = curr;\\n                curr = curr->next;\\n                k--;\\n            }\\n\\n            prev->next = reverseEvenLengthGroups(curr, group+1);\\n\\n            // Since curr is NULL and we are in odd group, so we need to handling last group\\n            if(k&1) { // if k is odd, len of last group will even, so we will reverse it.\\n                return reverse(head);\\n            }\\n        }\\n\\n        return head;\\n    }\\n};\\n\\n```\\n### Below code just for reference\\n```\\n// In below code the last group case is not handled\\n\\nListNode* reverseEvenLengthGroups(ListNode* head, int group = 1) {\\n    if(!head) return head;\\n\\n    ListNode *prev = NULL, *curr = head, *next = NULL;\\n    int k = group;\\n\\n    if(k % 2 == 0) {\\n        while(curr && k) {\\n            next = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = next;\\n            k--;\\n        }\\n        head->next = reverseEvenLengthGroups(curr, group+1);\\n\\n        return prev;\\n\\n    } else {\\n        while(curr && k) {\\n            prev = curr;\\n            curr = curr->next;\\n            k--;\\n        }\\n        prev->next = reverseEvenLengthGroups(curr, group+1);\\n    }\\n\\n    return head;\\n}\\n```\\n# Please Vote Up",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    // for handling last group case only\\n    ListNode* reverse(ListNode* head) {\\n        ListNode* prev = NULL, *curr = head, *next = NULL;\\n\\n        while(curr) {\\n            next = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = next;\\n        }\\n\\n        return prev;\\n    }\\n\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head, int group = 1) {\\n        if(!head) return head;\\n\\n        ListNode *prev = NULL, *curr = head, *next = NULL;\\n        int k = group;\\n\\n        if(k % 2 == 0) {\\n            while(curr && k) {\\n                next = curr->next;\\n                curr->next = prev;\\n                prev = curr;\\n                curr = next;\\n                k--;\\n            }\\n            head->next = reverseEvenLengthGroups(curr, group+1);\\n\\n            // Since curr is NULL and we are in even group, so we need to handling last group\\n            if(k&1) { // if k is odd, len of last group will odd, so we will revert.\\n                return reverse(prev);\\n            }\\n            return prev;\\n\\n        } else {\\n            while(curr && k) {\\n                prev = curr;\\n                curr = curr->next;\\n                k--;\\n            }\\n\\n            prev->next = reverseEvenLengthGroups(curr, group+1);\\n\\n            // Since curr is NULL and we are in odd group, so we need to handling last group\\n            if(k&1) { // if k is odd, len of last group will even, so we will reverse it.\\n                return reverse(head);\\n            }\\n        }\\n\\n        return head;\\n    }\\n};\\n\\n```\n```\\n// In below code the last group case is not handled\\n\\nListNode* reverseEvenLengthGroups(ListNode* head, int group = 1) {\\n    if(!head) return head;\\n\\n    ListNode *prev = NULL, *curr = head, *next = NULL;\\n    int k = group;\\n\\n    if(k % 2 == 0) {\\n        while(curr && k) {\\n            next = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = next;\\n            k--;\\n        }\\n        head->next = reverseEvenLengthGroups(curr, group+1);\\n\\n        return prev;\\n\\n    } else {\\n        while(curr && k) {\\n            prev = curr;\\n            curr = curr->next;\\n            k--;\\n        }\\n        prev->next = reverseEvenLengthGroups(curr, group+1);\\n    }\\n\\n    return head;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3918520,
                "title": "easy-java-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: 3 ms ( O ( n ) )\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverse(ListNode head){\\n         ListNode curr=head;\\n        ListNode next=null;\\n        ListNode prev=null;\\n         while(curr!=null){\\n            next=curr.next;\\n            curr.next=prev;\\n            prev=curr;\\n            curr=next;\\n        }\\n       \\n        return prev;\\n    }\\n    public ListNode solve(ListNode head,int n){\\n        if(head==null) return null;\\n        ListNode curr=head;\\n        ListNode next=null;\\n        ListNode prev=null;\\n        int c=0;\\n        if(n%2==1){\\n           while(curr!=null&&c<n){\\n               next=curr;\\n                curr=curr.next;\\n                c++;\\n           }\\n           if(c%2==0) return solve(head,n-1);\\n           if(curr!=null) next.next=solve(curr,n+1);\\n           return head;\\n\\n        }\\n        while(curr!=null&&c<n){\\n            next=curr.next;\\n            curr.next=prev;\\n            prev=curr;\\n            curr=next;\\n            c++;\\n        }\\n        if(c%2==1) return reverse(prev);\\n        if(next!=null) head.next=solve(next,n+1);\\n        return prev;\\n\\n    }\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        \\n        return solve(head,1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverse(ListNode head){\\n         ListNode curr=head;\\n        ListNode next=null;\\n        ListNode prev=null;\\n         while(curr!=null){\\n            next=curr.next;\\n            curr.next=prev;\\n            prev=curr;\\n            curr=next;\\n        }\\n       \\n        return prev;\\n    }\\n    public ListNode solve(ListNode head,int n){\\n        if(head==null) return null;\\n        ListNode curr=head;\\n        ListNode next=null;\\n        ListNode prev=null;\\n        int c=0;\\n        if(n%2==1){\\n           while(curr!=null&&c<n){\\n               next=curr;\\n                curr=curr.next;\\n                c++;\\n           }\\n           if(c%2==0) return solve(head,n-1);\\n           if(curr!=null) next.next=solve(curr,n+1);\\n           return head;\\n\\n        }\\n        while(curr!=null&&c<n){\\n            next=curr.next;\\n            curr.next=prev;\\n            prev=curr;\\n            curr=next;\\n            c++;\\n        }\\n        if(c%2==1) return reverse(prev);\\n        if(next!=null) head.next=solve(next,n+1);\\n        return prev;\\n\\n    }\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        \\n        return solve(head,1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3909824,
                "title": "c-linked-list-beats-77-62-of-users-with-c",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n #define null NULL\\nclass Solution {\\npublic:\\n     ListNode* prev=null,*temp,*curr;\\n     int i,n;\\n     void even()\\n     {\\n                 int count=i;\\n                 temp=curr;\\n                 vector<int>vt;\\n                 while(count--&&temp!=null) \\n                 {\\n                     vt.insert(vt.begin(),temp->val);\\n                     temp=temp->next;\\n                 }\\n                 count=i;\\n                 int n=0;\\n                 while(count--&&curr!=null)\\n                {\\n                    curr->val=vt[n++];\\n                    prev=curr;\\n                    curr=curr->next;\\n                   \\n                }\\n\\n     }\\n     void odd()\\n     {\\n                int count=i;\\n                while(count--&&curr!=null)\\n                {\\n                    prev=curr;\\n                    curr=curr->next;\\n                }\\n     }\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n         i=1;\\n         curr=head;\\n        temp=head;\\n        while(temp!=null) \\n        {\\n            n++;\\n            temp=temp->next;\\n        }\\n        while(curr!=null)\\n        {\\n            if(i%2==0)\\n            {\\n                int val=n-((i*(i-1))/2);\\n                 if(val<i)\\n                 {\\n                     if(val%2==0) even();\\n                     else odd();\\n                 }\\n                 else even();\\n            }\\n            else\\n            {\\n                  int val=n-((i*(i-1))/2);\\n                 if(val<i)\\n                 {\\n                     if(val%2!=0) odd();\\n                     else even();\\n                 }\\n                 else odd();\\n            }\\n            i++;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n #define null NULL\\nclass Solution {\\npublic:\\n     ListNode* prev=null,*temp,*curr;\\n     int i,n;\\n     void even()\\n     {\\n                 int count=i;\\n                 temp=curr;\\n                 vector<int>vt;\\n                 while(count--&&temp!=null) \\n                 {\\n                     vt.insert(vt.begin(),temp->val);\\n                     temp=temp->next;\\n                 }\\n                 count=i;\\n                 int n=0;\\n                 while(count--&&curr!=null)\\n                {\\n                    curr->val=vt[n++];\\n                    prev=curr;\\n                    curr=curr->next;\\n                   \\n                }\\n\\n     }\\n     void odd()\\n     {\\n                int count=i;\\n                while(count--&&curr!=null)\\n                {\\n                    prev=curr;\\n                    curr=curr->next;\\n                }\\n     }\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n         i=1;\\n         curr=head;\\n        temp=head;\\n        while(temp!=null) \\n        {\\n            n++;\\n            temp=temp->next;\\n        }\\n        while(curr!=null)\\n        {\\n            if(i%2==0)\\n            {\\n                int val=n-((i*(i-1))/2);\\n                 if(val<i)\\n                 {\\n                     if(val%2==0) even();\\n                     else odd();\\n                 }\\n                 else even();\\n            }\\n            else\\n            {\\n                  int val=n-((i*(i-1))/2);\\n                 if(val<i)\\n                 {\\n                     if(val%2!=0) odd();\\n                     else even();\\n                 }\\n                 else odd();\\n            }\\n            i++;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3887165,
                "title": "very-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        int group = 1;\\n        ListNode node = head;\\n        while(node!=null && node.next!=null){\\n            group++;\\n            int countGps=0;\\n            ListNode temp=node.next;\\n            while(temp!=null && countGps<group ){\\n                temp=temp.next;\\n                countGps++;\\n            }\\n            if(countGps % 2==0){\\n                ListNode present = node.next;\\n                ListNode newEnd = present;\\n                ListNode prev = node;\\n                ListNode next= present.next;\\n                for(int i =0 ; i<countGps ; i++){\\n                    present.next=prev;\\n                    prev=present;\\n                    present=next;\\n                    if(next!=null){\\n                        next=next.next;\\n                    }\\n                   node.next=prev;\\n                   newEnd.next=present;\\n\\n\\n                }\\n                node=newEnd;\\n            }else{\\n                for(int i =0 ; i<countGps ;i++){\\n                    node = node.next;\\n                }\\n            }\\n        }\\n        return head;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        int group = 1;\\n        ListNode node = head;\\n        while(node!=null && node.next!=null){\\n            group++;\\n            int countGps=0;\\n            ListNode temp=node.next;\\n            while(temp!=null && countGps<group ){\\n                temp=temp.next;\\n                countGps++;\\n            }\\n            if(countGps % 2==0){\\n                ListNode present = node.next;\\n                ListNode newEnd = present;\\n                ListNode prev = node;\\n                ListNode next= present.next;\\n                for(int i =0 ; i<countGps ; i++){\\n                    present.next=prev;\\n                    prev=present;\\n                    present=next;\\n                    if(next!=null){\\n                        next=next.next;\\n                    }\\n                   node.next=prev;\\n                   newEnd.next=present;\\n\\n\\n                }\\n                node=newEnd;\\n            }else{\\n                for(int i =0 ; i<countGps ;i++){\\n                    node = node.next;\\n                }\\n            }\\n        }\\n        return head;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3886130,
                "title": "simple-and-fast-java-solution-list-l",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        if(head.next==null || head.next.next==null){\\n            return head;\\n        }\\n\\n        int grup=1;\\n        ListNode node=head;\\n        while(node!=null && node.next!=null){\\n            grup++;\\n            int ct=0;\\n            ListNode temp=node.next;\\n            while(temp!=null && ct<grup){\\n                temp=temp.next;\\n                ct++;\\n            }\\n\\n            if(ct%2==0){\\n                ListNode curr=node.next;\\n                ListNode prev=null;\\n                ListNode nextNode =null;\\n\\n                for(int i=0;i<ct;i++){\\n                    nextNode=curr.next;\\n                    curr.next=prev;\\n                    prev=curr;\\n                    curr=nextNode;\\n                }\\n                ListNode tail=node.next;\\n                tail.next=curr;\\n                node.next=prev;\\n                node=tail;\\n            }\\n            else{\\n                for(int i=0;i<ct;i++){\\n                    node=node.next;\\n                }\\n            }\\n        }\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        if(head.next==null || head.next.next==null){\\n            return head;\\n        }\\n\\n        int grup=1;\\n        ListNode node=head;\\n        while(node!=null && node.next!=null){\\n            grup++;\\n            int ct=0;\\n            ListNode temp=node.next;\\n            while(temp!=null && ct<grup){\\n                temp=temp.next;\\n                ct++;\\n            }\\n\\n            if(ct%2==0){\\n                ListNode curr=node.next;\\n                ListNode prev=null;\\n                ListNode nextNode =null;\\n\\n                for(int i=0;i<ct;i++){\\n                    nextNode=curr.next;\\n                    curr.next=prev;\\n                    prev=curr;\\n                    curr=nextNode;\\n                }\\n                ListNode tail=node.next;\\n                tail.next=curr;\\n                node.next=prev;\\n                node=tail;\\n            }\\n            else{\\n                for(int i=0;i<ct;i++){\\n                    node=node.next;\\n                }\\n            }\\n        }\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3881612,
                "title": "java-in-memory",
                "content": "# Complexity\\n- Time complexity: $$O(N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        \\n        int groupSize = 1; \\n\\n        ListNode dummy = new ListNode(-1);\\n        dummy.next = head;\\n        head = dummy; \\n\\n        while(head!=null && head.next!=null){\\n\\n            ListNode currentGroupStartNode = head.next;  \\n            ListNode temp = head; \\n            int count = 0; \\n            \\n            while(count < groupSize && temp.next!=null){\\n                temp = temp.next; \\n                count++; \\n            }\\n\\n            ListNode currentGroupEndNode = temp;\\n            ListNode nextGroupStartNode = currentGroupEndNode == null ? null : currentGroupEndNode.next; \\n\\n            boolean shouldReverse = count%2==0; \\n            if(shouldReverse){   \\n                head.next = reverse(currentGroupStartNode, nextGroupStartNode, nextGroupStartNode);\\n                head = currentGroupStartNode; \\n            }else{\\n                head = currentGroupEndNode; \\n            }\\n\\n            groupSize++;\\n        }\\n        return dummy.next; \\n    }\\n\\n    ListNode reverse(ListNode startInclusive, ListNode endNodeExclusive, ListNode currentReverse){\\n        ListNode temp = startInclusive; \\n        while(temp != endNodeExclusive){\\n            ListNode tempNext = temp.next;\\n            temp.next = currentReverse;\\n            currentReverse = temp; \\n            temp = tempNext;\\n        }\\n        return currentReverse; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        \\n        int groupSize = 1; \\n\\n        ListNode dummy = new ListNode(-1);\\n        dummy.next = head;\\n        head = dummy; \\n\\n        while(head!=null && head.next!=null){\\n\\n            ListNode currentGroupStartNode = head.next;  \\n            ListNode temp = head; \\n            int count = 0; \\n            \\n            while(count < groupSize && temp.next!=null){\\n                temp = temp.next; \\n                count++; \\n            }\\n\\n            ListNode currentGroupEndNode = temp;\\n            ListNode nextGroupStartNode = currentGroupEndNode == null ? null : currentGroupEndNode.next; \\n\\n            boolean shouldReverse = count%2==0; \\n            if(shouldReverse){   \\n                head.next = reverse(currentGroupStartNode, nextGroupStartNode, nextGroupStartNode);\\n                head = currentGroupStartNode; \\n            }else{\\n                head = currentGroupEndNode; \\n            }\\n\\n            groupSize++;\\n        }\\n        return dummy.next; \\n    }\\n\\n    ListNode reverse(ListNode startInclusive, ListNode endNodeExclusive, ListNode currentReverse){\\n        ListNode temp = startInclusive; \\n        while(temp != endNodeExclusive){\\n            ListNode tempNext = temp.next;\\n            temp.next = currentReverse;\\n            currentReverse = temp; \\n            temp = tempNext;\\n        }\\n        return currentReverse; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3874081,
                "title": "python-simple-solutions-faster-than-98-6-o-n",
                "content": "# Complexity\\n- Time complexity: O(N)\\n- Space complexity: O(1)\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if not head or not head.next:\\n            return head\\n\\n        def get_size(node, last_length):\\n            length = 0\\n            while node:\\n                length+=1\\n                if length==last_length+1:\\n                    return length, node\\n                node = node.next\\n            return length, None\\n\\n        def reverse(node, curr_length):\\n            prev = None\\n            curr = node\\n            while curr_length>0:\\n                curr_length-=1\\n                next = curr.next\\n                curr.next = prev\\n                prev, curr = curr, next\\n\\n            return prev, node\\n\\n\\n        last_length = 1\\n        curr = head\\n        while curr and curr.next:\\n            last_length, last_node = get_size(curr.next, last_length)\\n            if last_length%2==0:\\n                if last_node:\\n                    last_node = last_node.next\\n                sub_head, tail = reverse(curr.next, last_length)\\n                curr.next = sub_head\\n                tail.next = last_node\\n                curr = tail\\n            else:\\n                curr = last_node\\n        return head\\n```",
                "solutionTags": [
                    "Python3",
                    "Linked List",
                    "Iterator"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if not head or not head.next:\\n            return head\\n\\n        def get_size(node, last_length):\\n            length = 0\\n            while node:\\n                length+=1\\n                if length==last_length+1:\\n                    return length, node\\n                node = node.next\\n            return length, None\\n\\n        def reverse(node, curr_length):\\n            prev = None\\n            curr = node\\n            while curr_length>0:\\n                curr_length-=1\\n                next = curr.next\\n                curr.next = prev\\n                prev, curr = curr, next\\n\\n            return prev, node\\n\\n\\n        last_length = 1\\n        curr = head\\n        while curr and curr.next:\\n            last_length, last_node = get_size(curr.next, last_length)\\n            if last_length%2==0:\\n                if last_node:\\n                    last_node = last_node.next\\n                sub_head, tail = reverse(curr.next, last_length)\\n                curr.next = sub_head\\n                tail.next = last_node\\n                curr = tail\\n            else:\\n                curr = last_node\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3870545,
                "title": "java-in-memory-reverse-time-6ms-beats-74-84-users-space-68-45mb-beats-68-54-users",
                "content": "# Intuition\\nUse in-memory reverse.\\n\\n# Approach\\n->Use in-memory reverse approach.\\n->check if current group is last or not, i.e. no. of unprocessed nodes is >= 1 + processed_group_len, is it\\'s NOT last then return -1 from isLastG(); method.\\n->if not last group, then increament \\'gLen\\' by 1 otherwise use lastGLen as \\'gLen\\'\\n->if, \\'gLen\\' is add then do NOT reversing and skip \\'gLen\\' no. of nodes of current odd group.\\n->otherwise, start reversing \"even\" group nodes as follows:-\\n\\n    -NOTE : before reversing current even-group, the first-node of even-group will become the last-node of even-group, post reversing the order by changing the \\'cur.next\\' pointer. Hence, we can take it\\'s reference for backup in \\'evenEnd\\'(variable) so that after reversing the even-group nodes the last node of even-group (i.e. \\'evenEnd\\') can be further connected to next-group first node.\\n\\n    ex : evenEnd.next = next;\\n\\n    -Also, after reversing the even-group nodes \\'prev\\' pointer would become the first-node of the reversed even-group. Hence it also need to be linked to last-node of previous group.\\n\\n    ex : prevGEnd.next = prev;\\n\\n    -Also after each reversing of even-group nodes, we need to keep updating the \\'prevGEnd\\' pointer with \\'evenEnd\\'.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        int gLen = 0;\\n        ListNode cur = head;\\n        ListNode prev = null;\\n        ListNode next = null;\\n        \\n        ListNode prevGEnd = null;\\n        ListNode evenEnd = null;\\n        int count = 0;\\n        int skip = 0;\\n        int isLastG = 0;\\n        boolean isNotLastGroup = false;\\n\\n        while (cur != null) {\\n            isLastG = isLastG(cur, gLen);\\n            isNotLastGroup = isLastG == -1 ? true : false;\\n            if (isNotLastGroup) {\\n                gLen++;\\n            } else if (!isNotLastGroup) {\\n                gLen = isLastG;\\n            }\\n\\n            if ((gLen & 1) == 0) {\\n                evenEnd = cur;\\n\\n                //rev start\\n                count = gLen;\\n                prev = null;\\n                next = null;\\n                while (count-- != 0) {\\n                    next = cur.next;\\n                    cur.next = prev;\\n                    prev = cur;\\n                    cur = next;\\n                }\\n                //rev end                \\n                \\n                prevGEnd.next = prev;\\n                evenEnd.next = next;\\n                prevGEnd = evenEnd;\\n            } else {\\n                skip = gLen;\\n                while (skip-- != 0) {\\n                    prevGEnd = cur;\\n                    cur = cur.next;\\n                }\\n            }\\n        }\\n        return head;        \\n    }\\n\\n    public int isLastG(ListNode cur, int prevGLen) {\\n        int count = 0;\\n        while (cur != null) {\\n            cur = cur.next;\\n            count++;\\n            if (count > (prevGLen+1)) {\\n                count = -1;\\n                break;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        int gLen = 0;\\n        ListNode cur = head;\\n        ListNode prev = null;\\n        ListNode next = null;\\n        \\n        ListNode prevGEnd = null;\\n        ListNode evenEnd = null;\\n        int count = 0;\\n        int skip = 0;\\n        int isLastG = 0;\\n        boolean isNotLastGroup = false;\\n\\n        while (cur != null) {\\n            isLastG = isLastG(cur, gLen);\\n            isNotLastGroup = isLastG == -1 ? true : false;\\n            if (isNotLastGroup) {\\n                gLen++;\\n            } else if (!isNotLastGroup) {\\n                gLen = isLastG;\\n            }\\n\\n            if ((gLen & 1) == 0) {\\n                evenEnd = cur;\\n\\n                //rev start\\n                count = gLen;\\n                prev = null;\\n                next = null;\\n                while (count-- != 0) {\\n                    next = cur.next;\\n                    cur.next = prev;\\n                    prev = cur;\\n                    cur = next;\\n                }\\n                //rev end                \\n                \\n                prevGEnd.next = prev;\\n                evenEnd.next = next;\\n                prevGEnd = evenEnd;\\n            } else {\\n                skip = gLen;\\n                while (skip-- != 0) {\\n                    prevGEnd = cur;\\n                    cur = cur.next;\\n                }\\n            }\\n        }\\n        return head;        \\n    }\\n\\n    public int isLastG(ListNode cur, int prevGLen) {\\n        int count = 0;\\n        while (cur != null) {\\n            cur = cur.next;\\n            count++;\\n            if (count > (prevGLen+1)) {\\n                count = -1;\\n                break;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3837513,
                "title": "using-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public int val;\\n *     public ListNode next;\\n *     public ListNode(int val=0, ListNode next=null) {\\n *         this.val = val;\\n *         this.next = next;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public ListNode ReverseEvenLengthGroups(ListNode head) {\\n        Stack s=new Stack();\\n        int c=1;\\n        var p=head;\\n        while(head!=null){\\n                var t=head;\\n                for(int i=0;i<c;i++){\\n                            if(head!=null){\\n                                s.Push(head.val);\\n                                head=head.next;\\n                            }\\n                        }\\n                    if(s.Count%2==0 ){\\n                        for(int i=0;i<c;i++){\\n                            if(t!=null){\\n                                t.val=(int)s.Pop();\\n                                t=t.next;\\n                            }\\n                        }\\n                    }\\n                s.Clear();\\n                c=c+1;\\n                }\\n              return p;\\n        }\\n    }\\n\\n\\n```",
                "solutionTags": [
                    "C#",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public int val;\\n *     public ListNode next;\\n *     public ListNode(int val=0, ListNode next=null) {\\n *         this.val = val;\\n *         this.next = next;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public ListNode ReverseEvenLengthGroups(ListNode head) {\\n        Stack s=new Stack();\\n        int c=1;\\n        var p=head;\\n        while(head!=null){\\n                var t=head;\\n                for(int i=0;i<c;i++){\\n                            if(head!=null){\\n                                s.Push(head.val);\\n                                head=head.next;\\n                            }\\n                        }\\n                    if(s.Count%2==0 ){\\n                        for(int i=0;i<c;i++){\\n                            if(t!=null){\\n                                t.val=(int)s.Pop();\\n                                t=t.next;\\n                            }\\n                        }\\n                    }\\n                s.Clear();\\n                c=c+1;\\n                }\\n              return p;\\n        }\\n    }\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3824032,
                "title": "800-ms-c-solution",
                "content": "# Intuition\\nThis problem is about traversal, reversal and counting the number of elements in the list. \\n\\n# Approach\\nSplit the problem into groups, meaning either traverse the group without changing it or reverse the group depending on the length of the group.\\n\\nLength of the group ==> group number itself, except the last group which could be length of remaining elements or group number itself. \\n\\nTo compute the length of the last group, we keep a counter \"count\" which returns the number of nodes seen thus far. In addition, we also need to know the number of nodes in the list, via `calcLength()` function. \\n\\n\\nHence, we need two methods: \\n1. `reverseN()` that reverses a list of length N while returning tail of the new list.\\n2. `traverseN()` that traverses the list of N nodes, either stops the traversal at reaching sentinel or if the method has traversed N nodes. Returns the last element of the list.\\n\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    // reverses the list starting at head until head+group \\n    // and connects the reversed list to prev.\\n    ListNode* reverseN(ListNode* head, ListNode* prev, int num_nodes) {\\n        ListNode* cur = head;\\n        int i = 1;\\n        while(cur != NULL && i <= num_nodes) {\\n            ListNode* temp = cur->next;\\n            cur->next = prev;\\n            prev = cur;\\n            cur = temp;\\n            i++;\\n        }\\n        // head->next is pointing to original prev but prev is pointing\\n        // to last node of the current list\\n        // hence, point previous list end node to new list\\'s head\\n        head->next->next = prev;\\n\\n        // point the last node of the new list to first node of the \\n        // next group\\n        head->next = cur;\\n        return head;\\n    }\\n\\n    int calcLength(ListNode* cur) {\\n        int i = 0;\\n        while(cur != NULL) {\\n            i++;\\n            cur = cur->next;\\n        }\\n        return i;\\n    }\\n\\n    ListNode* traverseN(ListNode* cur, int n) {\\n        int i = 1;\\n        while(cur != NULL && i < n) {\\n            cur = cur->next;\\n            i++;\\n        }\\n        return cur;\\n    }\\n\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        int len = calcLength(head);\\n\\n        int count = 0;\\n        int group_num = 0;\\n        int group_len = 0;\\n        ListNode* prev = NULL;\\n        ListNode* cur = head;\\n        while(cur != NULL) {\\n            group_num++;\\n            group_len = min(len-count, group_num);\\n\\n            // reverse an even group\\n            if (group_len%2 == 0) {\\n                cur = reverseN(cur, prev, group_len);\\n                count += group_len;\\n            } else {\\n                cur = traverseN(cur, group_len);\\n                count += group_len;\\n            }\\n\\n            prev = cur;\\n            if (cur != NULL) {\\n                 cur = cur->next;    \\n            } \\n              \\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    // reverses the list starting at head until head+group \\n    // and connects the reversed list to prev.\\n    ListNode* reverseN(ListNode* head, ListNode* prev, int num_nodes) {\\n        ListNode* cur = head;\\n        int i = 1;\\n        while(cur != NULL && i <= num_nodes) {\\n            ListNode* temp = cur->next;\\n            cur->next = prev;\\n            prev = cur;\\n            cur = temp;\\n            i++;\\n        }\\n        // head->next is pointing to original prev but prev is pointing\\n        // to last node of the current list\\n        // hence, point previous list end node to new list\\'s head\\n        head->next->next = prev;\\n\\n        // point the last node of the new list to first node of the \\n        // next group\\n        head->next = cur;\\n        return head;\\n    }\\n\\n    int calcLength(ListNode* cur) {\\n        int i = 0;\\n        while(cur != NULL) {\\n            i++;\\n            cur = cur->next;\\n        }\\n        return i;\\n    }\\n\\n    ListNode* traverseN(ListNode* cur, int n) {\\n        int i = 1;\\n        while(cur != NULL && i < n) {\\n            cur = cur->next;\\n            i++;\\n        }\\n        return cur;\\n    }\\n\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        int len = calcLength(head);\\n\\n        int count = 0;\\n        int group_num = 0;\\n        int group_len = 0;\\n        ListNode* prev = NULL;\\n        ListNode* cur = head;\\n        while(cur != NULL) {\\n            group_num++;\\n            group_len = min(len-count, group_num);\\n\\n            // reverse an even group\\n            if (group_len%2 == 0) {\\n                cur = reverseN(cur, prev, group_len);\\n                count += group_len;\\n            } else {\\n                cur = traverseN(cur, group_len);\\n                count += group_len;\\n            }\\n\\n            prev = cur;\\n            if (cur != NULL) {\\n                 cur = cur->next;    \\n            } \\n              \\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3814320,
                "title": "solution-without-conversion-to-list-python",
                "content": "# Intuition\\ngo through the linked list and if sublist must be reversed, we reverse with sub-while loop\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        dummy = prev = lenHead = head\\n\\n        curr = prev.next\\n        counter = 2\\n        length = 0\\n        while lenHead:\\n            length += 1\\n            lenHead = lenHead.next\\n        total = 1\\n        while curr:\\n            countTemp = counter\\n            print((length - total), counter)\\n            if ((length - total) >= counter and counter % 2 == 0) or ((length - total) < counter and (length - total) % 2 == 0 ):\\n                seqPrev = prev\\n                seqEnd = curr\\n                prev = curr\\n                curr = curr.next\\n                while countTemp - 1 and curr:\\n                    nextNode = curr.next\\n                    curr.next = prev\\n                    prev = curr\\n                    curr = nextNode\\n                    countTemp -= 1\\n                \\n                seqPrev.next = prev\\n                seqEnd.next = curr\\n                prev = seqEnd\\n            else:\\n                while countTemp and curr:\\n                    prev = curr\\n                    curr = curr.next\\n                    countTemp -= 1\\n            total += counter\\n            counter += 1\\n            \\n        \\n        return dummy\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        dummy = prev = lenHead = head\\n\\n        curr = prev.next\\n        counter = 2\\n        length = 0\\n        while lenHead:\\n            length += 1\\n            lenHead = lenHead.next\\n        total = 1\\n        while curr:\\n            countTemp = counter\\n            print((length - total), counter)\\n            if ((length - total) >= counter and counter % 2 == 0) or ((length - total) < counter and (length - total) % 2 == 0 ):\\n                seqPrev = prev\\n                seqEnd = curr\\n                prev = curr\\n                curr = curr.next\\n                while countTemp - 1 and curr:\\n                    nextNode = curr.next\\n                    curr.next = prev\\n                    prev = curr\\n                    curr = nextNode\\n                    countTemp -= 1\\n                \\n                seqPrev.next = prev\\n                seqEnd.next = curr\\n                prev = seqEnd\\n            else:\\n                while countTemp and curr:\\n                    prev = curr\\n                    curr = curr.next\\n                    countTemp -= 1\\n            total += counter\\n            counter += 1\\n            \\n        \\n        return dummy\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3805562,
                "title": "simplest-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution \\n{\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) \\n    {\\n        vector<int> tmp;\\n        ListNode* n = head;\\n        ListNode* h2 = nullptr;\\n        ListNode* n2 = h2;\\n\\n        int i=1;\\n        while(n!=nullptr)\\n        {\\n            for(int j=i; j>0; j--)\\n            {\\n                if(!n)\\n                {\\n                    break;\\n                }\\n                tmp.push_back(n->val);\\n                n=n->next;\\n            }\\n            \\n            if(!(tmp.size()%2))\\n            {\\n                std::reverse(tmp.begin(), tmp.end());\\n            }\\n            \\n            for(int j=0; j<tmp.size(); j++)\\n            {\\n                if(n2)\\n                {\\n                    n2->next = new ListNode(tmp[j]);\\n                    n2 = n2->next;\\n                }\\n                else\\n                {\\n                    n2 = new ListNode(tmp[j]);\\n                    h2 = n2;\\n                }\\n            }\\n            \\n            tmp.clear();\\n            i++;\\n\\n        }\\n\\n        return h2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution \\n{\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) \\n    {\\n        vector<int> tmp;\\n        ListNode* n = head;\\n        ListNode* h2 = nullptr;\\n        ListNode* n2 = h2;\\n\\n        int i=1;\\n        while(n!=nullptr)\\n        {\\n            for(int j=i; j>0; j--)\\n            {\\n                if(!n)\\n                {\\n                    break;\\n                }\\n                tmp.push_back(n->val);\\n                n=n->next;\\n            }\\n            \\n            if(!(tmp.size()%2))\\n            {\\n                std::reverse(tmp.begin(), tmp.end());\\n            }\\n            \\n            for(int j=0; j<tmp.size(); j++)\\n            {\\n                if(n2)\\n                {\\n                    n2->next = new ListNode(tmp[j]);\\n                    n2 = n2->next;\\n                }\\n                else\\n                {\\n                    n2 = new ListNode(tmp[j]);\\n                    h2 = n2;\\n                }\\n            }\\n            \\n            tmp.clear();\\n            i++;\\n\\n        }\\n\\n        return h2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3787693,
                "title": "two-methodes-o-n-tc-and-o-n-sc",
                "content": "# First method: Using math\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem here is the last group, because is the only one that can not matche the number of nodes in it. The others do, for example, group numer 3 has 3 node, groupe number 5 has 5 node...\\nThe group numer 7 if it is the last group, can have 1 node, 2, 3... or even 6 nodes.\\nIf we know the number of groups, and also the number of nodes that it contains, we can handle this problem by reverse all nodes in the even group, and in the final, reverse the last group, if the number of its items is even.\\nBut how can we do that?\\n\\nIf we take a look at the number of the elements in each group:\\n1 | 2 - 3 | 4 - 5 - 6 | ...\\nHow elements we have?\\n1 + 2 + 3 = (3 * (3-1)) // 2 (Gauss\\'s formula)\\n\\nIf we know the lenght of the input, we can know the number of the groups and the nodes in the last group.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI use two functions, one to compute the length of the listNode and the other, the nomber of groups and the number of nodes in the last group.\\nWe can add at that a third fucction that reverse the groups.\\n\\n# Complexity\\n- Time complexity $$O(n)$$:\\n1. Iterate throught the linked list $$O(n)$$;\\n2. Compute the number of group and the number of nodes in the last node $$O(log(n))$$ (using binary search for that);\\n3. Iterate throught the linked list and reverse the groupe. It takes $$O(n + n/2)$$.\\nThe result of all of that: $$O(n)$$.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity $$O(1)$$:\\nWe don\\'t use any extra space.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def getLength(self, head):\\n        count, current = 0, head\\n        while current:\\n            count = count + 1\\n            current = current.next\\n        return count\\n\\n    def getNumGroups(self, num: int) -> List[int]:\\n        if num == 1: return [1, 0]\\n        num_2 = num * 2\\n        start, end = 1, num_2 // 2\\n        while start <= end:\\n            mid = (start + end) // 2\\n            pr = mid * mid\\n            if pr == num_2:\\n                ans = mid\\n                break\\n            elif pr < num_2:\\n                ans = mid\\n                start = mid + 1\\n            else:\\n                end = mid - 1\\n        if ans * (ans + 1) // 2 > num:\\n            # In some cases, the number is begger.\\n            ans = ans - 1\\n        carry = num - ans * (ans + 1) // 2\\n            \\n        return [ans, carry] \\n\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        length = self.getLength(head)\\n        groups_carry = self.getNumGroups(length)\\n\\n        num_groups, carry =  groups_carry[0], groups_carry[1]\\n\\n        count_groups, prev, current = 1, head, head\\n        while count_groups <= num_groups:\\n            count = 1\\n            tail_group = current\\n            while count < count_groups:\\n                tail_group = tail_group.next\\n                count = count + 1\\n\\n            if count_groups % 2:\\n                current = tail_group.next\\n                prev = tail_group\\n            else:\\n                node = current\\n                save_tail_next = tail_group.next\\n                while count > 0:\\n                    save_node_next = node.next\\n                    node.next = save_tail_next\\n                    save_tail_next = node\\n                    node = save_node_next\\n                    count = count - 1\\n                prev.next = tail_group\\n                prev = current\\n                current = node\\n\\n            count_groups = count_groups + 1\\n\\n        # Hindling the last group.\\n        if not carry % 2:\\n            tail = None\\n            while current:\\n                save_current_next = current.next\\n                current.next = tail\\n                tail = current\\n                current = save_current_next\\n            prev.next = tail\\n\\n        return head\\n```\\n# Second methode\\n# Complexity\\n- Time complexity $$O(n)$$:\\nIterate throught the linked list and reverse the nodes if there number is even.\\n- Space complexity $$O(1)$$:\\nWe don\\'t use any extra space.\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        current, prev, num_group = head, None, 1\\n        while current:\\n            count = 1\\n            tail = current\\n            while tail.next and count < num_group:\\n                tail = tail.next\\n                count = count + 1\\n\\n            if not count % 2:\\n                node = current\\n                while count > 1:\\n                    # 1 not 0 because in the first\\n                    # iteration we make tow iterations!\\n                    save_node_next = node.next\\n                    node.next = tail.next\\n                    tail.next = node\\n                    node = save_node_next\\n                    count = count - 1\\n                prev.next = node\\n                prev = current\\n            else:\\n                prev = tail\\n\\n            current = prev.next\\n            num_group = num_group + 1\\n\\n        return head\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def getLength(self, head):\\n        count, current = 0, head\\n        while current:\\n            count = count + 1\\n            current = current.next\\n        return count\\n\\n    def getNumGroups(self, num: int) -> List[int]:\\n        if num == 1: return [1, 0]\\n        num_2 = num * 2\\n        start, end = 1, num_2 // 2\\n        while start <= end:\\n            mid = (start + end) // 2\\n            pr = mid * mid\\n            if pr == num_2:\\n                ans = mid\\n                break\\n            elif pr < num_2:\\n                ans = mid\\n                start = mid + 1\\n            else:\\n                end = mid - 1\\n        if ans * (ans + 1) // 2 > num:\\n            # In some cases, the number is begger.\\n            ans = ans - 1\\n        carry = num - ans * (ans + 1) // 2\\n            \\n        return [ans, carry] \\n\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        length = self.getLength(head)\\n        groups_carry = self.getNumGroups(length)\\n\\n        num_groups, carry =  groups_carry[0], groups_carry[1]\\n\\n        count_groups, prev, current = 1, head, head\\n        while count_groups <= num_groups:\\n            count = 1\\n            tail_group = current\\n            while count < count_groups:\\n                tail_group = tail_group.next\\n                count = count + 1\\n\\n            if count_groups % 2:\\n                current = tail_group.next\\n                prev = tail_group\\n            else:\\n                node = current\\n                save_tail_next = tail_group.next\\n                while count > 0:\\n                    save_node_next = node.next\\n                    node.next = save_tail_next\\n                    save_tail_next = node\\n                    node = save_node_next\\n                    count = count - 1\\n                prev.next = tail_group\\n                prev = current\\n                current = node\\n\\n            count_groups = count_groups + 1\\n\\n        # Hindling the last group.\\n        if not carry % 2:\\n            tail = None\\n            while current:\\n                save_current_next = current.next\\n                current.next = tail\\n                tail = current\\n                current = save_current_next\\n            prev.next = tail\\n\\n        return head\\n```\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        current, prev, num_group = head, None, 1\\n        while current:\\n            count = 1\\n            tail = current\\n            while tail.next and count < num_group:\\n                tail = tail.next\\n                count = count + 1\\n\\n            if not count % 2:\\n                node = current\\n                while count > 1:\\n                    # 1 not 0 because in the first\\n                    # iteration we make tow iterations!\\n                    save_node_next = node.next\\n                    node.next = tail.next\\n                    tail.next = node\\n                    node = save_node_next\\n                    count = count - 1\\n                prev.next = node\\n                prev = current\\n            else:\\n                prev = tail\\n\\n            current = prev.next\\n            num_group = num_group + 1\\n\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3780551,
                "title": "c-short-code-easy-solution-100-beats-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        if(head->next == NULL) return head;\\n        ListNode* temp = head;\\n        ListNode* rest;\\n        int grp = 1,nodes=1;\\n        do{\\n            \\n            if(nodes==grp || !temp->next){\\n                grp++; \\n               if(nodes%2==0){\\n                   ListNode* forward = rest->next;\\n                   ListNode* Extract = forward->next;\\n                   while((nodes--)>1){\\n                       forward->next = Extract->next;\\n                       Extract->next = rest->next;\\n                       rest->next = Extract;\\n                       Extract = forward->next;\\n                   }\\n                   temp = forward;\\n                 }\\n                 nodes=0;\\n                 rest = temp;\\n            }\\n            nodes++;\\n            temp=temp->next;\\n        }while(temp);\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        if(head->next == NULL) return head;\\n        ListNode* temp = head;\\n        ListNode* rest;\\n        int grp = 1,nodes=1;\\n        do{\\n            \\n            if(nodes==grp || !temp->next){\\n                grp++; \\n               if(nodes%2==0){\\n                   ListNode* forward = rest->next;\\n                   ListNode* Extract = forward->next;\\n                   while((nodes--)>1){\\n                       forward->next = Extract->next;\\n                       Extract->next = rest->next;\\n                       rest->next = Extract;\\n                       Extract = forward->next;\\n                   }\\n                   temp = forward;\\n                 }\\n                 nodes=0;\\n                 rest = temp;\\n            }\\n            nodes++;\\n            temp=temp->next;\\n        }while(temp);\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3778172,
                "title": "java-solution-o-1-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ncomment for explaination.\\n\\n# Complexity\\n- Time complexity:O(len*k)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        if(head.next==null || head.next.next==null)return head;\\n        int len=length(head);\\n        int k=2,curr=0;\\n        int l=1;\\n        ListNode node=head;\\n        ListNode prev=head;\\n        while(node!=null){\\n            while(curr<k && node!=null){\\n                curr++;\\n                node=node.next;\\n            }\\n            ListNode temp=prev.next;\\n            if(curr%2==0){\\n                prev.next=reverse(prev.next,node);\\n            }\\n            prev=(curr%2==0)?temp:node;\\n            node=prev;\\n            l+=curr;\\n            curr=0;\\n            k++;\\n            if(k>len-l)k=len-l;\\n        }\\n        return head;\\n\\n    }\\n    public ListNode reverse(ListNode head,ListNode tail){\\n        if(tail!=null)tail=tail.next;\\n        ListNode end=tail;\\n        while(head!=null){\\n            ListNode next=head.next;\\n            head.next=tail;\\n            if(end==next)break;\\n            tail=head;\\n            head=next;\\n        }\\n        return head;\\n    }\\n    public int length(ListNode head)\\n    {\\n        int len=0;\\n        for(ListNode curr=head;curr!=null;curr=curr.next)len++;\\n        return len;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        if(head.next==null || head.next.next==null)return head;\\n        int len=length(head);\\n        int k=2,curr=0;\\n        int l=1;\\n        ListNode node=head;\\n        ListNode prev=head;\\n        while(node!=null){\\n            while(curr<k && node!=null){\\n                curr++;\\n                node=node.next;\\n            }\\n            ListNode temp=prev.next;\\n            if(curr%2==0){\\n                prev.next=reverse(prev.next,node);\\n            }\\n            prev=(curr%2==0)?temp:node;\\n            node=prev;\\n            l+=curr;\\n            curr=0;\\n            k++;\\n            if(k>len-l)k=len-l;\\n        }\\n        return head;\\n\\n    }\\n    public ListNode reverse(ListNode head,ListNode tail){\\n        if(tail!=null)tail=tail.next;\\n        ListNode end=tail;\\n        while(head!=null){\\n            ListNode next=head.next;\\n            head.next=tail;\\n            if(end==next)break;\\n            tail=head;\\n            head=next;\\n        }\\n        return head;\\n    }\\n    public int length(ListNode head)\\n    {\\n        int len=0;\\n        for(ListNode curr=head;curr!=null;curr=curr.next)len++;\\n        return len;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3772763,
                "title": "simple-java-code-with-tc-o-n-sc-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach \\n\\n1. First, a check is performed to see if the input linked list is either empty or contains only a single node. If so, the function simply returns the head of the list as there is no need to reverse anything.\\n2. A `dummy` node is created and set as the initial `prev` node. The `prev` node is used to keep track of the previous node before the current node (`cur`).\\n3. The function iterates through the linked list until the last node (`cur.next != null`). Within each iteration, it checks if the current group has an even or odd length.\\n4. To determine if the group is even or odd, the function counts the number of available nodes (`availableNode`) in the current group. This is done by traversing the list using a temporary node (`checkNode`) and incrementing `availableNode` until either the end of the list is reached or the count equals the length of the current group (`count`).\\n5. If the group is even (`evenTurn` is `true`), the function reverses the nodes within the group. It uses a counter (`i`) to keep track of the number of nodes processed within the group. The reversal is done by swapping the `next` pointers of the nodes, starting from the second node up to the count (`count - 1`). The `prev` node is updated to maintain the correct connections.\\n6. If the group is odd (`evenTurn` is `false`), the function simply skips the nodes in the current group without making any changes. It advances `prev` and `cur` to the next group by moving `i` nodes ahead.\\n7. After processing the current group, the counters and variables are reset (`i = 1`, `count = count + 1`) to move to the next group.\\n8. Finally, the modified linked list is returned by accessing the `next` pointer of the `dummy` node\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n   public ListNode reverseEvenLengthGroups(ListNode head) {\\n        if (head == null || head.next == null) {\\n            return head;\\n        }\\n\\n        int i = 1;\\n        int count = 1;\\n\\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n        ListNode prev = dummy;\\n        ListNode cur = dummy.next;\\n\\n        while (cur.next != null) {\\n            // Count the number of available nodes in the current group\\n            ListNode checkNode = cur;\\n            int availableNode = 0;\\n            while (checkNode != null && availableNode < count) {\\n                availableNode++;\\n                checkNode = checkNode.next;\\n            }\\n\\n            boolean evenTurn = availableNode % 2 == 0;\\n\\n            if (evenTurn) {\\n                // Reverse the nodes within the even-length group\\n                while (cur.next != null && i < count) {\\n                    ListNode temp = cur.next;\\n                    cur.next = temp.next;\\n                    temp.next = prev.next;\\n                    prev.next = temp;\\n                    i++;\\n                }\\n\\n                if (cur.next != null) {\\n                    ListNode temp = cur.next;\\n                    prev = cur;\\n                    cur = temp;\\n                }\\n            } else {\\n                // Skip nodes in the odd-length group\\n                while (cur.next != null && i <= count) {\\n                    prev = cur;\\n                    cur = cur.next;\\n                    i++;\\n                }\\n            }\\n\\n            i = 1;\\n            count = count + 1;\\n        }\\n\\n        return dummy.next;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n   public ListNode reverseEvenLengthGroups(ListNode head) {\\n        if (head == null || head.next == null) {\\n            return head;\\n        }\\n\\n        int i = 1;\\n        int count = 1;\\n\\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n        ListNode prev = dummy;\\n        ListNode cur = dummy.next;\\n\\n        while (cur.next != null) {\\n            // Count the number of available nodes in the current group\\n            ListNode checkNode = cur;\\n            int availableNode = 0;\\n            while (checkNode != null && availableNode < count) {\\n                availableNode++;\\n                checkNode = checkNode.next;\\n            }\\n\\n            boolean evenTurn = availableNode % 2 == 0;\\n\\n            if (evenTurn) {\\n                // Reverse the nodes within the even-length group\\n                while (cur.next != null && i < count) {\\n                    ListNode temp = cur.next;\\n                    cur.next = temp.next;\\n                    temp.next = prev.next;\\n                    prev.next = temp;\\n                    i++;\\n                }\\n\\n                if (cur.next != null) {\\n                    ListNode temp = cur.next;\\n                    prev = cur;\\n                    cur = temp;\\n                }\\n            } else {\\n                // Skip nodes in the odd-length group\\n                while (cur.next != null && i <= count) {\\n                    prev = cur;\\n                    cur = cur.next;\\n                    i++;\\n                }\\n            }\\n\\n            i = 1;\\n            count = count + 1;\\n        }\\n\\n        return dummy.next;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3772203,
                "title": "python-solution-in-n-time-and-constant-space",
                "content": "# Complexity\\n- Time complexity: \\u0398(n)\\n\\n- Space complexity: \\u0398(1)\\n\\n# Code\\n```\\n# Intuition is you need to reverse everytime you get a even grp LL or lst group is even\\n# So maintain odd and even which remembers the group length of prev LL group.\\n# Initially odd = 1 and even = 2\\n# when you reach an even grp of length == \"even\", you reverse it and update even += 2 and odd += 2\\n# And start counting again\\nclass Solution:\\n    def rev(self, head):\\n        nh = None\\n        while head != None:\\n            store = head.next\\n            head.next = nh\\n            nh = head\\n            head = store\\n        return nh\\n\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        org_h = head\\n        p = head    # points to prev of LL\\n        t = head    # points to the end of the LL to be reversed\\n        c = 0 # to count nodes\\n        s = 0 # when s == 0 it means you have reached LL of even length grp and can rev else not\\n        odd = 1 # initial odd grp length of LL\\n        even = 2 # initial even grp length of LL\\n        while t != None and t.next != None:\\n            c += 1\\n            t = t.next\\n            if (c == even and s == 0) or (c % 2 == 0 and t.next == None):\\n                head = p.next\\n                n = t.next\\n                t.next = None\\n                nh = self.rev(head)\\n                head = p.next\\n                head.next = n\\n                p.next = t\\n                p = head\\n                h = n\\n                t = n\\n                c = 1\\n                s = 1\\n                even += 2\\n                odd += 2\\n            elif c == odd and s == 1:\\n                c = 0\\n                s = 0\\n                p = t\\n        return org_h\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Intuition is you need to reverse everytime you get a even grp LL or lst group is even\\n# So maintain odd and even which remembers the group length of prev LL group.\\n# Initially odd = 1 and even = 2\\n# when you reach an even grp of length == \"even\", you reverse it and update even += 2 and odd += 2\\n# And start counting again\\nclass Solution:\\n    def rev(self, head):\\n        nh = None\\n        while head != None:\\n            store = head.next\\n            head.next = nh\\n            nh = head\\n            head = store\\n        return nh\\n\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        org_h = head\\n        p = head    # points to prev of LL\\n        t = head    # points to the end of the LL to be reversed\\n        c = 0 # to count nodes\\n        s = 0 # when s == 0 it means you have reached LL of even length grp and can rev else not\\n        odd = 1 # initial odd grp length of LL\\n        even = 2 # initial even grp length of LL\\n        while t != None and t.next != None:\\n            c += 1\\n            t = t.next\\n            if (c == even and s == 0) or (c % 2 == 0 and t.next == None):\\n                head = p.next\\n                n = t.next\\n                t.next = None\\n                nh = self.rev(head)\\n                head = p.next\\n                head.next = n\\n                p.next = t\\n                p = head\\n                h = n\\n                t = n\\n                c = 1\\n                s = 1\\n                even += 2\\n                odd += 2\\n            elif c == odd and s == 1:\\n                c = 0\\n                s = 0\\n                p = t\\n        return org_h\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3772200,
                "title": "python-solution-in-n-time-and-constant-space",
                "content": "# Complexity\\n- Time complexity: \\u0398(n)\\n\\n- Space complexity: \\u0398(1)\\n\\n# Code\\n```\\n# Intuition is you need to reverse everytime you get a even grp LL or lst group is even\\n# So maintain odd and even which remembers the group length of prev LL group.\\n# Initially odd = 1 and even = 2\\n# when you reach an even grp of length == \"even\", you reverse it and update even += 2 and odd += 2\\n# And start counting again\\nclass Solution:\\n    def rev(self, head):\\n        nh = None\\n        while head != None:\\n            store = head.next\\n            head.next = nh\\n            nh = head\\n            head = store\\n        return nh\\n\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        org_h = head\\n        p = head    # points to prev of LL\\n        t = head    # points to the end of the LL to be reversed\\n        c = 0 # to count nodes\\n        s = 0 # when s == 0 it means you have reached LL of even length grp and can rev else not\\n        odd = 1 # initial odd grp length of LL\\n        even = 2 # initial even grp length of LL\\n        while t != None and t.next != None:\\n            c += 1\\n            t = t.next\\n            if (c == even and s == 0) or (c % 2 == 0 and t.next == None):\\n                head = p.next\\n                n = t.next\\n                t.next = None\\n                nh = self.rev(head)\\n                head = p.next\\n                head.next = n\\n                p.next = t\\n                p = head\\n                h = n\\n                t = n\\n                c = 1\\n                s = 1\\n                even += 2\\n                odd += 2\\n            elif c == odd and s == 1:\\n                c = 0\\n                s = 0\\n                p = t\\n        return org_h\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Intuition is you need to reverse everytime you get a even grp LL or lst group is even\\n# So maintain odd and even which remembers the group length of prev LL group.\\n# Initially odd = 1 and even = 2\\n# when you reach an even grp of length == \"even\", you reverse it and update even += 2 and odd += 2\\n# And start counting again\\nclass Solution:\\n    def rev(self, head):\\n        nh = None\\n        while head != None:\\n            store = head.next\\n            head.next = nh\\n            nh = head\\n            head = store\\n        return nh\\n\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        org_h = head\\n        p = head    # points to prev of LL\\n        t = head    # points to the end of the LL to be reversed\\n        c = 0 # to count nodes\\n        s = 0 # when s == 0 it means you have reached LL of even length grp and can rev else not\\n        odd = 1 # initial odd grp length of LL\\n        even = 2 # initial even grp length of LL\\n        while t != None and t.next != None:\\n            c += 1\\n            t = t.next\\n            if (c == even and s == 0) or (c % 2 == 0 and t.next == None):\\n                head = p.next\\n                n = t.next\\n                t.next = None\\n                nh = self.rev(head)\\n                head = p.next\\n                head.next = n\\n                p.next = t\\n                p = head\\n                h = n\\n                t = n\\n                c = 1\\n                s = 1\\n                even += 2\\n                odd += 2\\n            elif c == odd and s == 1:\\n                c = 0\\n                s = 0\\n                p = t\\n        return org_h\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3757957,
                "title": "beats-85-o-n-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n       ListNode *connect=head,*ptr=head->next;\\n       int cnt=2;\\n       while(ptr!=NULL){\\n           ListNode *head_maintain=ptr,*prev=NULL;\\n           int i=0;\\n           while(ptr!=NULL&&i<cnt){\\n             prev=ptr;\\n             ptr=ptr->next;\\n             i+=1;\\n             }\\n             if(i%2==0){\\n                ptr=head_maintain;\\n                ListNode *preptr=NULL;\\n                int j=0;\\n                while(j<i){\\n                    ListNode *next=ptr->next;\\n                    ptr->next=preptr;\\n                    preptr=ptr;\\n                    ptr=next;\\n                    j+=1;\\n                }\\n                connect->next=preptr;\\n                connect=head_maintain;\\n            }\\n            else{\\n                connect->next=head_maintain;\\n                connect=prev;\\n            }\\n            cnt+=1;\\n        }\\n       return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n       ListNode *connect=head,*ptr=head->next;\\n       int cnt=2;\\n       while(ptr!=NULL){\\n           ListNode *head_maintain=ptr,*prev=NULL;\\n           int i=0;\\n           while(ptr!=NULL&&i<cnt){\\n             prev=ptr;\\n             ptr=ptr->next;\\n             i+=1;\\n             }\\n             if(i%2==0){\\n                ptr=head_maintain;\\n                ListNode *preptr=NULL;\\n                int j=0;\\n                while(j<i){\\n                    ListNode *next=ptr->next;\\n                    ptr->next=preptr;\\n                    preptr=ptr;\\n                    ptr=next;\\n                    j+=1;\\n                }\\n                connect->next=preptr;\\n                connect=head_maintain;\\n            }\\n            else{\\n                connect->next=head_maintain;\\n                connect=prev;\\n            }\\n            cnt+=1;\\n        }\\n       return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3745102,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nListNode* reverse(ListNode* head){\\n    ListNode* prev = NULL,*curr = head,*nxt = NULL;\\n    while(curr){\\n        nxt = curr -> next;\\n        curr -> next = prev;\\n        prev = curr;\\n        curr = nxt;\\n    }\\n\\n    return prev;\\n}\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        \\n        ListNode* dummy = new ListNode(-1,head);\\n        ListNode* prev = dummy,*tail = head,*newHead = NULL,*curr = head;\\n\\n        int k = 1;\\n        while(curr){\\n            int i = 1;\\n            for( i=1;i<k && tail->next;++i) tail = tail -> next;\\n            if(tail == NULL) return dummy -> next;\\n\\n            newHead = tail -> next;\\n            if(i&1){\\n                 if(curr == NULL) return dummy -> next;\\n                 curr = tail -> next;\\n                 prev = tail;\\n                 tail = curr;\\n            }\\n            else{\\n                  tail -> next = NULL;\\n                  if(curr == NULL) return dummy -> next;\\n                \\n                  ListNode* tmp = reverse(curr);\\n                  curr -> next = newHead;\\n                  prev -> next = tmp;\\n                  tail = curr -> next;\\n                  prev = curr;\\n                  curr = tail;\\n            }\\n\\n            k += 1;\\n        }\\n\\n        return dummy -> next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nListNode* reverse(ListNode* head){\\n    ListNode* prev = NULL,*curr = head,*nxt = NULL;\\n    while(curr){\\n        nxt = curr -> next;\\n        curr -> next = prev;\\n        prev = curr;\\n        curr = nxt;\\n    }\\n\\n    return prev;\\n}\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        \\n        ListNode* dummy = new ListNode(-1,head);\\n        ListNode* prev = dummy,*tail = head,*newHead = NULL,*curr = head;\\n\\n        int k = 1;\\n        while(curr){\\n            int i = 1;\\n            for( i=1;i<k && tail->next;++i) tail = tail -> next;\\n            if(tail == NULL) return dummy -> next;\\n\\n            newHead = tail -> next;\\n            if(i&1){\\n                 if(curr == NULL) return dummy -> next;\\n                 curr = tail -> next;\\n                 prev = tail;\\n                 tail = curr;\\n            }\\n            else{\\n                  tail -> next = NULL;\\n                  if(curr == NULL) return dummy -> next;\\n                \\n                  ListNode* tmp = reverse(curr);\\n                  curr -> next = newHead;\\n                  prev -> next = tmp;\\n                  tail = curr -> next;\\n                  prev = curr;\\n                  curr = tail;\\n            }\\n\\n            k += 1;\\n        }\\n\\n        return dummy -> next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3744777,
                "title": "o-1-memory-space-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe traverse through the list step by step, each step has a length $l$, which is also the length of of the group that we are currently traversing. After traverse through the step, we reverse the list in-place, and then merge it back to the original list. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe are going to solve this problem in-place to obtain O(1) memory space.\\n\\nStep 1: Traverse up-front to check the length of the group (check if it is long enough or if it reaches the end).\\nStep 2: Reverse the particular part of the list with the length we count in step 1.\\nStep 3: Merge: Noted that we need to store a variable $prev$ (the previous node of the first node in the group) and $next$ (the next node of the last node in the group). If we reverse the list, the last node (variable $tmp$) becomes the first node (variable $current$) and vice versa. We point $prev$ to $tmp$, then point $current$ to $next$ and update $prev$. Note that if we do not reverse the list, $prev$ should be updated as $tmp$.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nEven though we have nested while loop here, the time complexity is O(n). The travelling up-front part cost O(n), the reverseList cost O(n). In the next while loop, we move the the entirely new part of the list, so it is O(n) time complexity. \\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nHere, we only store a few variables to deal with in-place reversal, so the space complexity is O(1).\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void reverseList(ListNode *head, int len){\\n        int count = 0;\\n        ListNode *prev = nullptr, *current = head, *next = nullptr;\\n        while(count < len && current){\\n            next = current->next;\\n            current->next = prev;\\n            prev = current;\\n            current = next;\\n            count++;\\n        }\\n    }\\n\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        int l = 1, count;\\n        if(!head->next) return head;\\n        ListNode *current = head, *tmp = head; // for traversing upfront\\n        ListNode *prev = nullptr, *next = nullptr; // for merging the reversed list\\n        // start from the second node\\n        current = head->next;\\n        prev = head;\\n        while(current){\\n            l++;\\n            tmp = current;\\n            count = 1;\\n            while(count < l && tmp->next){\\n                tmp = tmp->next;\\n                count++;\\n            }\\n            next = tmp->next;   \\n            if(count%2 == 0){\\n                reverseList(current, l);\\n                //merge\\n                prev->next = tmp;\\n                current->next = next;\\n                prev = current;\\n            }else{\\n                prev = tmp;\\n            }\\n            current = next;\\n            tmp = current;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void reverseList(ListNode *head, int len){\\n        int count = 0;\\n        ListNode *prev = nullptr, *current = head, *next = nullptr;\\n        while(count < len && current){\\n            next = current->next;\\n            current->next = prev;\\n            prev = current;\\n            current = next;\\n            count++;\\n        }\\n    }\\n\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        int l = 1, count;\\n        if(!head->next) return head;\\n        ListNode *current = head, *tmp = head; // for traversing upfront\\n        ListNode *prev = nullptr, *next = nullptr; // for merging the reversed list\\n        // start from the second node\\n        current = head->next;\\n        prev = head;\\n        while(current){\\n            l++;\\n            tmp = current;\\n            count = 1;\\n            while(count < l && tmp->next){\\n                tmp = tmp->next;\\n                count++;\\n            }\\n            next = tmp->next;   \\n            if(count%2 == 0){\\n                reverseList(current, l);\\n                //merge\\n                prev->next = tmp;\\n                current->next = next;\\n                prev = current;\\n            }else{\\n                prev = tmp;\\n            }\\n            current = next;\\n            tmp = current;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3732665,
                "title": "ok",
                "content": "**time: `O(N)`; space: `O(1)`**\\n\\n![image](https://assets.leetcode.com/users/images/644226f4-b488-46f0-b048-6a4bbca78b5c_1688747083.092001.png)\\n\\nHere\\'s how inversion is made in more detail:\\n\\n![image](https://assets.leetcode.com/users/images/fa7ff2db-fb7a-46de-96ae-660941354af2_1688748747.976289.png)\\n\\nHere `x` marks the borderline between the already inverted and the not-inverted part.\\n\\n```\\nListNode* reverseEvenLengthGroups(ListNode* l) \\n{\\n\\tint n{2};\\n\\tfor(auto b{l}, e{b->next}; e; ++n)\\n\\t{\\n\\t\\tfor( ; b->next!=e; b=b->next); \\n\\t\\tint i{};\\n\\t\\tfor( ; i<n and e; e=e->next, ++i);\\n\\t\\tif(1+i&1) for(auto x{b->next}; x->next!=e; b->next = exchange(x->next, exchange(x->next->next, b->next)));   \\n\\t}\\n\\treturn l;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nListNode* reverseEvenLengthGroups(ListNode* l) \\n{\\n\\tint n{2};\\n\\tfor(auto b{l}, e{b->next}; e; ++n)\\n\\t{\\n\\t\\tfor( ; b->next!=e; b=b->next); \\n\\t\\tint i{};\\n\\t\\tfor( ; i<n and e; e=e->next, ++i);\\n\\t\\tif(1+i&1) for(auto x{b->next}; x->next!=e; b->next = exchange(x->next, exchange(x->next->next, b->next)));   \\n\\t}\\n\\treturn l;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3731160,
                "title": "beats-92-c-iterative-solution-for-beginners",
                "content": "\\n\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n\\n    //make a pair class to return both head and tail from \\n    //reverse function\\n\\n    class Pair{\\n        public:\\n        ListNode* head;\\n        ListNode* tail;\\n    };\\n\\n    //recursive reverse function which returns an object of \\n    //pair class\\n\\n    Pair reverse(ListNode*head){\\n        if(head==NULL || head->next==NULL){\\n            Pair ans;\\n            ans.head=head;\\n            ans.tail=head;\\n            return ans;\\n        }\\n        Pair smallAns=reverse(head->next);\\n        smallAns.tail->next=head;\\n        head->next=NULL;\\n        Pair ans;\\n        ans.head=smallAns.head;\\n        ans.tail=head;\\n        return ans;\\n    }\\npublic:\\n\\n    //maintain dummy nodes and iterate on every group\\n\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        ListNode*dummy=head;ListNode*newHead=head;\\n        ListNode*h1=newHead->next;\\n        ListNode*t1=newHead->next;\\n        int count=0;int group=2;bool free=false;\\n        while(dummy->next!=NULL){\\n            dummy=dummy->next;\\n            count++;\\n\\n        //condition when group is of even length\\n\\n            if((count%2==0 && group%2==0 && count==group)){\\n                t1=dummy;\\n                ListNode*temp=dummy->next;\\n                t1->next=NULL;\\n                Pair ans=reverse(h1);\\n                newHead->next=ans.head;\\n                ans.tail->next=temp;\\n                newHead=ans.tail;\\n                dummy=ans.tail;\\n                count=0;group++;\\n\\n            }\\n\\n        //condition when group is of odd length\\n\\n            if(!free && count==group){\\n                count=0;\\n                group++;\\n                newHead=dummy;\\n                h1=dummy->next;\\n\\n            }\\n        }\\n\\n        //when no group is left\\n\\n        if(count==0)return head;\\n\\n        //when left nodes are even in number \\n        //then we need to reverse them \\n        //(group can be odd also in this case)\\n\\n        if(count%2==0){\\n            Pair ans=reverse(newHead->next);\\n            newHead->next=ans.head;\\n            ans.tail->next=NULL;\\n            return head;\\n        }\\n\\n        //when nodes left are odd in number\\n        //in this case no need to reverse them\\n        //simply return head\\n\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n\\n    //make a pair class to return both head and tail from \\n    //reverse function\\n\\n    class Pair{\\n        public:\\n        ListNode* head;\\n        ListNode* tail;\\n    };\\n\\n    //recursive reverse function which returns an object of \\n    //pair class\\n\\n    Pair reverse(ListNode*head){\\n        if(head==NULL || head->next==NULL){\\n            Pair ans;\\n            ans.head=head;\\n            ans.tail=head;\\n            return ans;\\n        }\\n        Pair smallAns=reverse(head->next);\\n        smallAns.tail->next=head;\\n        head->next=NULL;\\n        Pair ans;\\n        ans.head=smallAns.head;\\n        ans.tail=head;\\n        return ans;\\n    }\\npublic:\\n\\n    //maintain dummy nodes and iterate on every group\\n\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        ListNode*dummy=head;ListNode*newHead=head;\\n        ListNode*h1=newHead->next;\\n        ListNode*t1=newHead->next;\\n        int count=0;int group=2;bool free=false;\\n        while(dummy->next!=NULL){\\n            dummy=dummy->next;\\n            count++;\\n\\n        //condition when group is of even length\\n\\n            if((count%2==0 && group%2==0 && count==group)){\\n                t1=dummy;\\n                ListNode*temp=dummy->next;\\n                t1->next=NULL;\\n                Pair ans=reverse(h1);\\n                newHead->next=ans.head;\\n                ans.tail->next=temp;\\n                newHead=ans.tail;\\n                dummy=ans.tail;\\n                count=0;group++;\\n\\n            }\\n\\n        //condition when group is of odd length\\n\\n            if(!free && count==group){\\n                count=0;\\n                group++;\\n                newHead=dummy;\\n                h1=dummy->next;\\n\\n            }\\n        }\\n\\n        //when no group is left\\n\\n        if(count==0)return head;\\n\\n        //when left nodes are even in number \\n        //then we need to reverse them \\n        //(group can be odd also in this case)\\n\\n        if(count%2==0){\\n            Pair ans=reverse(newHead->next);\\n            newHead->next=ans.head;\\n            ans.tail->next=NULL;\\n            return head;\\n        }\\n\\n        //when nodes left are odd in number\\n        //in this case no need to reverse them\\n        //simply return head\\n\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3729175,
                "title": "python-simple-o-n",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        # To be able to reverse, we need to keep the previous node that we visited\\n        curr, prev = head, None\\n        # starting the counter form 1 and will be incrementing by 1 later in the loop\\n        ctr = 1\\n        # continue until we reach the end of the loop\\n        while curr:\\n            # count the number of nodes in this step where counter is ctr\\n            i = 0\\n            # keep a pointer to the start of the node, in case the number of nodes \\n            start = curr\\n            while curr and i < ctr:\\n                # keep track of previous node in case we need to reverse\\n                next_prev_node = curr\\n                curr = curr.next\\n                i += 1\\n            # if the count of nodes in this iteration are even, then we need to reverse\\n            if not i & 1:\\n                tail = start\\n                curr = start\\n                # to reverse\\n                temp_prev = None\\n                j = 0\\n                # continue the iteration for the number of nodes seen in this step (ctr)\\n                while curr and j < i:\\n                    next_node = curr.next\\n                    curr.next = temp_prev\\n                    temp_prev = curr\\n                    curr = next_node\\n                    j += 1\\n                prev.next = temp_prev\\n                tail.next = curr\\n                # since it is reversed the new previous node will be the tail of current list\\n                prev = tail\\n            else:\\n                # if not reversed the previous node will be the next_prev_node\\n                prev = next_prev_node\\n            ctr += 1\\n        return head\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        # To be able to reverse, we need to keep the previous node that we visited\\n        curr, prev = head, None\\n        # starting the counter form 1 and will be incrementing by 1 later in the loop\\n        ctr = 1\\n        # continue until we reach the end of the loop\\n        while curr:\\n            # count the number of nodes in this step where counter is ctr\\n            i = 0\\n            # keep a pointer to the start of the node, in case the number of nodes \\n            start = curr\\n            while curr and i < ctr:\\n                # keep track of previous node in case we need to reverse\\n                next_prev_node = curr\\n                curr = curr.next\\n                i += 1\\n            # if the count of nodes in this iteration are even, then we need to reverse\\n            if not i & 1:\\n                tail = start\\n                curr = start\\n                # to reverse\\n                temp_prev = None\\n                j = 0\\n                # continue the iteration for the number of nodes seen in this step (ctr)\\n                while curr and j < i:\\n                    next_node = curr.next\\n                    curr.next = temp_prev\\n                    temp_prev = curr\\n                    curr = next_node\\n                    j += 1\\n                prev.next = temp_prev\\n                tail.next = curr\\n                # since it is reversed the new previous node will be the tail of current list\\n                prev = tail\\n            else:\\n                # if not reversed the previous node will be the next_prev_node\\n                prev = next_prev_node\\n            ctr += 1\\n        return head\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3727274,
                "title": "easy-solution-using-intution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst Copy all the elements of linked list. divide each group , whenever a group length is even, reverse it using stack. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI collected all the elements of the linked list using cursor, until cursor is `NULL`. Divide it into groups of increasing sizes (ind + n  gives the start of next group). until ind + n is less than size of vector. If the size of last group is even reverse that part also. \\n\\n# Complexity\\n- Time complexity:O(N2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nUpvote if you like this approach \\uD83D\\uDC4D\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    // reversing the vector from start to end\\n    void rev(vector<int>& v, int start, int end){\\n        stack<int> st; \\n        for(int i=start; i<= end; i++) st.push(v[i]); \\n        for(int i=start; i<= end; i++){v[i] = st.top(); st.pop(); }\\n\\n    }\\n\\n    //Dividing the vector into parts and reversing even sized ones\\n    void modify(vector<int>& v){\\n     // ind stores the starting index of group and n the size of group\\n      int ind = 0, n = 1; \\n      while(ind + n < v.size()){\\n          if(n%2 == 0){\\n              rev(v, ind, ind+n-1); ind += n; n++; \\n          }\\n          else {\\n              ind += n; n++; \\n          }\\n      }\\n     // checking length of last group \\n      if((v.size() - ind)%2 == 0) rev(v, ind, v.size()-1); \\n\\n\\n    }\\n\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        ListNode* cursor = head; vector<int> v; \\n    // Copying the elements of linked list to a vector. \\n        while(cursor){v.push_back(cursor->val); cursor = cursor->next; }\\n        modify(v); \\n        cursor = head; \\n        for(int i=0; i<v.size(); i++){\\n            cursor->val = v[i]; cursor = cursor->next; \\n        }\\n\\n        return head; \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Stack"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    // reversing the vector from start to end\\n    void rev(vector<int>& v, int start, int end){\\n        stack<int> st; \\n        for(int i=start; i<= end; i++) st.push(v[i]); \\n        for(int i=start; i<= end; i++){v[i] = st.top(); st.pop(); }\\n\\n    }\\n\\n    //Dividing the vector into parts and reversing even sized ones\\n    void modify(vector<int>& v){\\n     // ind stores the starting index of group and n the size of group\\n      int ind = 0, n = 1; \\n      while(ind + n < v.size()){\\n          if(n%2 == 0){\\n              rev(v, ind, ind+n-1); ind += n; n++; \\n          }\\n          else {\\n              ind += n; n++; \\n          }\\n      }\\n     // checking length of last group \\n      if((v.size() - ind)%2 == 0) rev(v, ind, v.size()-1); \\n\\n\\n    }\\n\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        ListNode* cursor = head; vector<int> v; \\n    // Copying the elements of linked list to a vector. \\n        while(cursor){v.push_back(cursor->val); cursor = cursor->next; }\\n        modify(v); \\n        cursor = head; \\n        for(int i=0; i<v.size(); i++){\\n            cursor->val = v[i]; cursor = cursor->next; \\n        }\\n\\n        return head; \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3720968,
                "title": "c-program-recursion",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     struct ListNode *next;\\n * };\\n */\\nstruct ListNode *reverseList(struct ListNode *head)\\n{\\n    if (head == NULL || head->next == NULL)\\n    {\\n        return head;\\n    }\\n    struct ListNode *prev = NULL;\\n    struct ListNode *curr = head;\\n    struct ListNode *Next = head->next;\\n    while (curr->next != NULL)\\n    {\\n        curr->next = prev;\\n        prev = curr;\\n        curr = Next;\\n        Next = curr->next;\\n    }\\n    curr->next = prev;\\n    return curr;\\n}\\nint len(struct ListNode *temp)\\n{\\n    int count = 0;\\n    while (temp != NULL)\\n    {\\n        count++;\\n        temp = temp->next;\\n    }\\n    return count;\\n}\\nstruct ListNode *reverseEven(struct ListNode *head, int k)\\n{\\n    if (len(head) < k)\\n    {\\n        if(len(head)%2==0)\\n        {\\n            return reverseList(head);\\n        }\\n        else\\n        {\\n            return head;\\n        }\\n    }\\n    else\\n    {\\n        int i = 0;\\n        if (k % 2 == 0)\\n        {\\n\\n            struct ListNode *prev = NULL;\\n            struct ListNode *curr = head;\\n            struct ListNode *Next = curr->next;\\n            struct ListNode *temp = head;\\n            while (i < k)\\n            {\\n                curr->next = prev;\\n                prev = curr;\\n                curr = Next;\\n                if (Next != NULL)\\n                {\\n\\n                    Next = curr->next;\\n                }\\n                else\\n                {\\n                    break;\\n                }\\n                i++;\\n            }\\n            head->next = reverseEven(curr, k+1);\\n            return prev;\\n        }\\n        else\\n        {\\n            struct ListNode *temp = head;\\n            while(i<k-1\\n            )\\n            {\\n                temp=temp->next;\\n                i++;\\n            }\\n            temp->next=reverseEven(temp->next,k+1);\\n            return head;\\n        }\\n    }\\n}\\nstruct ListNode *reverseEvenLengthGroups(struct ListNode *head)\\n{\\n    return reverseEven(head, 1);\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     struct ListNode *next;\\n * };\\n */\\nstruct ListNode *reverseList(struct ListNode *head)\\n{\\n    if (head == NULL || head->next == NULL)\\n    {\\n        return head;\\n    }\\n    struct ListNode *prev = NULL;\\n    struct ListNode *curr = head;\\n    struct ListNode *Next = head->next;\\n    while (curr->next != NULL)\\n    {\\n        curr->next = prev;\\n        prev = curr;\\n        curr = Next;\\n        Next = curr->next;\\n    }\\n    curr->next = prev;\\n    return curr;\\n}\\nint len(struct ListNode *temp)\\n{\\n    int count = 0;\\n    while (temp != NULL)\\n    {\\n        count++;\\n        temp = temp->next;\\n    }\\n    return count;\\n}\\nstruct ListNode *reverseEven(struct ListNode *head, int k)\\n{\\n    if (len(head) < k)\\n    {\\n        if(len(head)%2==0)\\n        {\\n            return reverseList(head);\\n        }\\n        else\\n        {\\n            return head;\\n        }\\n    }\\n    else\\n    {\\n        int i = 0;\\n        if (k % 2 == 0)\\n        {\\n\\n            struct ListNode *prev = NULL;\\n            struct ListNode *curr = head;\\n            struct ListNode *Next = curr->next;\\n            struct ListNode *temp = head;\\n            while (i < k)\\n            {\\n                curr->next = prev;\\n                prev = curr;\\n                curr = Next;\\n                if (Next != NULL)\\n                {\\n\\n                    Next = curr->next;\\n                }\\n                else\\n                {\\n                    break;\\n                }\\n                i++;\\n            }\\n            head->next = reverseEven(curr, k+1);\\n            return prev;\\n        }\\n        else\\n        {\\n            struct ListNode *temp = head;\\n            while(i<k-1\\n            )\\n            {\\n                temp=temp->next;\\n                i++;\\n            }\\n            temp->next=reverseEven(temp->next,k+1);\\n            return head;\\n        }\\n    }\\n}\\nstruct ListNode *reverseEvenLengthGroups(struct ListNode *head)\\n{\\n    return reverseEven(head, 1);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3696908,
                "title": "beats-97-80-java-solution-linkedlist",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        if(head == null) return head;\\n\\n        int grpSize = 1;\\n        int cnt = 0;\\n\\n        ListNode left = null;\\n        ListNode last = null;\\n        ListNode ptr = head;\\n\\n        while(ptr != null){\\n            cnt++;\\n            if(cnt == grpSize){\\n                if(grpSize% 2 == 0 ){\\n                    ListNode end = ptr.next;\\n                    // reverse the lst;\\n                    ListNode curr = left;\\n                    ListNode next = null;\\n                    ListNode prev = ptr.next;\\n\\n                    while(curr != end){\\n                        next = curr.next;\\n                        curr.next = prev;\\n                        prev = curr;\\n                        curr = next;\\n                    }\\n                    //connect\\n                    last.next = prev;\\n                    ptr = left;\\n                }\\n                last = ptr;\\n                left = ptr.next;\\n                cnt = 0;\\n                grpSize++;\\n            }\\n            ptr = ptr.next;\\n        }\\n\\n        if(cnt > 0 && cnt % 2 == 0) {\\n            // reverse\\n            ListNode cur = left;\\n            ListNode next = null;\\n            ListNode prev = ptr;\\n\\n            while(cur != null) {\\n                next = cur.next;\\n                cur.next = prev;\\n                prev = cur;\\n                cur = next;\\n            }\\n\\n            last.next = prev;\\n        }\\n\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        if(head == null) return head;\\n\\n        int grpSize = 1;\\n        int cnt = 0;\\n\\n        ListNode left = null;\\n        ListNode last = null;\\n        ListNode ptr = head;\\n\\n        while(ptr != null){\\n            cnt++;\\n            if(cnt == grpSize){\\n                if(grpSize% 2 == 0 ){\\n                    ListNode end = ptr.next;\\n                    // reverse the lst;\\n                    ListNode curr = left;\\n                    ListNode next = null;\\n                    ListNode prev = ptr.next;\\n\\n                    while(curr != end){\\n                        next = curr.next;\\n                        curr.next = prev;\\n                        prev = curr;\\n                        curr = next;\\n                    }\\n                    //connect\\n                    last.next = prev;\\n                    ptr = left;\\n                }\\n                last = ptr;\\n                left = ptr.next;\\n                cnt = 0;\\n                grpSize++;\\n            }\\n            ptr = ptr.next;\\n        }\\n\\n        if(cnt > 0 && cnt % 2 == 0) {\\n            // reverse\\n            ListNode cur = left;\\n            ListNode next = null;\\n            ListNode prev = ptr;\\n\\n            while(cur != null) {\\n                next = cur.next;\\n                cur.next = prev;\\n                prev = cur;\\n                cur = next;\\n            }\\n\\n            last.next = prev;\\n        }\\n\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3671444,
                "title": "easy-implementation-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBrute Force\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSimulate the process .\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        int len=0;\\n        ListNode* p=head;\\n        while(p!=NULL){\\n            len++;\\n            p=p->next;\\n        }\\n        int gr=1;\\n        int cov=0;\\n        ListNode* curr=head;\\n        ListNode* prev;\\n        while(curr!=NULL){\\n            if((gr%2==0 && (len-cov)>=gr)|| ((len-cov)%2==0 && (len-cov)<=gr)){\\n                ListNode* a=curr;\\n                ListNode* b=a->next;\\n                ListNode* cur=b->next;\\n                ListNode* end=curr;\\n                int ct=gr;\\n                while(ct-- && end!=NULL){\\n                    end=end->next;\\n                }\\n                while(cur!=NULL && cur!=end){\\n                    b->next=a;\\n                    a=b;\\n                    b=cur;\\n                    cur=cur->next;\\n                }\\n                b->next=a;\\n                curr->next=end;\\n                prev->next=b;\\n                prev=curr;\\n                curr=end;\\n            }else{\\n                int ct=gr;\\n                while(ct-- && curr!=NULL){\\n                    prev=curr;\\n                    curr=curr->next;\\n                }\\n            }\\n            cov+=gr;\\n            gr++;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        int len=0;\\n        ListNode* p=head;\\n        while(p!=NULL){\\n            len++;\\n            p=p->next;\\n        }\\n        int gr=1;\\n        int cov=0;\\n        ListNode* curr=head;\\n        ListNode* prev;\\n        while(curr!=NULL){\\n            if((gr%2==0 && (len-cov)>=gr)|| ((len-cov)%2==0 && (len-cov)<=gr)){\\n                ListNode* a=curr;\\n                ListNode* b=a->next;\\n                ListNode* cur=b->next;\\n                ListNode* end=curr;\\n                int ct=gr;\\n                while(ct-- && end!=NULL){\\n                    end=end->next;\\n                }\\n                while(cur!=NULL && cur!=end){\\n                    b->next=a;\\n                    a=b;\\n                    b=cur;\\n                    cur=cur->next;\\n                }\\n                b->next=a;\\n                curr->next=end;\\n                prev->next=b;\\n                prev=curr;\\n                curr=end;\\n            }else{\\n                int ct=gr;\\n                while(ct-- && curr!=NULL){\\n                    prev=curr;\\n                    curr=curr->next;\\n                }\\n            }\\n            cov+=gr;\\n            gr++;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3668258,
                "title": "i-woke-up-and-wrote-perfect-code",
                "content": "# Intuition\\nI didn\\'t like any of the solutions, so I slept. When I woke up I coded this in one go. I like how clean this is compared to my previous tries at this problem. \\nIt is verry self explanatory to just know when we are entering a odd section and even section. \\nThat is denoted by \\n\\n```\\nnodesRemaining\\n``` \\n\\nIf we enter odd, we just traverse over the section till our head is in even section\\n\\nIf we enter even we just use the reverse trick of reversing a Linked List - II problem to cover it in single pass.\\n\\n```\\nwhile(--count && head ){\\n            if(head->next){\\n                ListNode *fwd = head->next;\\n                ListNode *tmp = fwd->next;\\n                fwd->next = prev->next;\\n                head->next = tmp;\\n                prev->next = fwd;\\n            }\\n        }\\n\\n```\\neg.    lets say we just entered section of even with count 4 and want to reverse A->B->C->D\\n\\n```\\n.... X -> A -> B-> C ->D ->Z ....\\nPrev ->  X\\nHead -> A\\n\\n```\\nthen assign as following:\\n\\n```\\n.... X -> A -> B-> C ->D ->Z ....\\n     P    H    F   T\\n\\nwhere P=> prev, H=> head, F=> forward, T=>tmp\\n\\n```\\nSince, we have a pointer T to the remaining chain we can directly make F point to something else. But to what?\\n\\nIf we make it point to H, then Prev will connect to the wrong stuff for the case where :\\n\\n```\\n.... X -> C -> B-> A ->D ->Z ....\\n     P             H   F  T\\n\\n\\n```\\nSo, we  must make F go the beginning of whatever we reversed till now\\nSo \\n\\n```\\nF-> next = P-> next;\\n\\n```\\nThis was the key observation, \\nNow, we make our head drag its way always to connect with T. You can directly join H to T as H doesnt need to point to F anymore\\n\\n```\\nhead->next = tmp\\n\\n```\\nand subsequently just make P point to F since its the newest addition in the back of reversed string up till now\\n\\n```\\nprev->next = fwd;\\n\\n```\\n\\nKeep doing this till we have Head->next && --count still present as if it is present then it means there is something in front (F) of head which we must move back\\n\\n\\n```\\n.... X -> D -> C-> B -> A ->Z -> NULL\\n     P                  H   F     T\\n\\n\\n```\\n\\nAt the end Head will still be pointing to an element of even section and thats why we move it along to enter the odd section as in below code.\\n\\nWe also Need to help the prev move over the whole section once we have covered so the lines of \\n\\n```\\n prev = head;\\n        if(head->next){\\n            head = head->next;\\n        }\\n        return head;\\n```\\nSo finally we get:\\n\\n\\n```\\n.... X -> C -> B-> A ->D ->Z ....\\n                   P   H\\n                       odd section starts from D\\n\\n\\n```\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n O(2n) = O(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    ListNode *prev;\\n\\n    ListNode* traverseOdd(ListNode *head, int count){\\n        for(int i=0;i<count;i++){\\n            if(head->next != nullptr){\\n                prev = head;\\n                head = head->next;\\n            } else {\\n                return head;\\n            }\\n        }\\n        return head;\\n    }\\n\\n    ListNode* reverseEven(ListNode* head, int count){\\n        \\n        while(--count && head ){\\n            if(head->next){\\n                ListNode *fwd = head->next;\\n                ListNode *tmp = fwd->next;\\n                fwd->next = prev->next;\\n                head->next = tmp;\\n                prev->next = fwd;\\n            }\\n        }\\n        prev = head;\\n        if(head->next){\\n            head = head->next;\\n        }\\n        return head;\\n\\n    }\\n\\n    int countForward(ListNode* tmp, int count) {\\n        int j = 0;\\n        while(tmp && j<count) {\\n            tmp = tmp->next;\\n            j++;\\n        }\\n        return j;\\n\\n    }\\n\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        if(head == nullptr){\\n            return head;\\n        }\\n        ListNode *dummy = new ListNode(0);\\n        dummy = head;\\n        int count = 1;\\n        prev = new ListNode(0);\\n        prev->next = head;\\n        while(head->next){\\n            ListNode* tmp = head;\\n            int nodesRemaining = countForward(tmp, count);\\n            if(nodesRemaining >= count){\\n                if(count%2){\\n                    head = traverseOdd(head, count);\\n                } else {\\n                    head = reverseEven(head, count); \\n                }\\n            } else {\\n                if(nodesRemaining%2){\\n                     head = traverseOdd(head, nodesRemaining);\\n                } else {\\n                    head = reverseEven(head, nodesRemaining); \\n                }\\n            }\\n            \\n        count++;\\n        }\\n        return dummy;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\nnodesRemaining\\n```\n```\\nwhile(--count && head ){\\n            if(head->next){\\n                ListNode *fwd = head->next;\\n                ListNode *tmp = fwd->next;\\n                fwd->next = prev->next;\\n                head->next = tmp;\\n                prev->next = fwd;\\n            }\\n        }\\n\\n```\n```\\n.... X -> A -> B-> C ->D ->Z ....\\nPrev ->  X\\nHead -> A\\n\\n```\n```\\n.... X -> A -> B-> C ->D ->Z ....\\n     P    H    F   T\\n\\nwhere P=> prev, H=> head, F=> forward, T=>tmp\\n\\n```\n```\\n.... X -> C -> B-> A ->D ->Z ....\\n     P             H   F  T\\n\\n\\n```\n```\\nF-> next = P-> next;\\n\\n```\n```\\nhead->next = tmp\\n\\n```\n```\\nprev->next = fwd;\\n\\n```\n```\\n.... X -> D -> C-> B -> A ->Z -> NULL\\n     P                  H   F     T\\n\\n\\n```\n```\\n prev = head;\\n        if(head->next){\\n            head = head->next;\\n        }\\n        return head;\\n```\n```\\n.... X -> C -> B-> A ->D ->Z ....\\n                   P   H\\n                       odd section starts from D\\n\\n\\n```\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    ListNode *prev;\\n\\n    ListNode* traverseOdd(ListNode *head, int count){\\n        for(int i=0;i<count;i++){\\n            if(head->next != nullptr){\\n                prev = head;\\n                head = head->next;\\n            } else {\\n                return head;\\n            }\\n        }\\n        return head;\\n    }\\n\\n    ListNode* reverseEven(ListNode* head, int count){\\n        \\n        while(--count && head ){\\n            if(head->next){\\n                ListNode *fwd = head->next;\\n                ListNode *tmp = fwd->next;\\n                fwd->next = prev->next;\\n                head->next = tmp;\\n                prev->next = fwd;\\n            }\\n        }\\n        prev = head;\\n        if(head->next){\\n            head = head->next;\\n        }\\n        return head;\\n\\n    }\\n\\n    int countForward(ListNode* tmp, int count) {\\n        int j = 0;\\n        while(tmp && j<count) {\\n            tmp = tmp->next;\\n            j++;\\n        }\\n        return j;\\n\\n    }\\n\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        if(head == nullptr){\\n            return head;\\n        }\\n        ListNode *dummy = new ListNode(0);\\n        dummy = head;\\n        int count = 1;\\n        prev = new ListNode(0);\\n        prev->next = head;\\n        while(head->next){\\n            ListNode* tmp = head;\\n            int nodesRemaining = countForward(tmp, count);\\n            if(nodesRemaining >= count){\\n                if(count%2){\\n                    head = traverseOdd(head, count);\\n                } else {\\n                    head = reverseEven(head, count); \\n                }\\n            } else {\\n                if(nodesRemaining%2){\\n                     head = traverseOdd(head, nodesRemaining);\\n                } else {\\n                    head = reverseEven(head, nodesRemaining); \\n                }\\n            }\\n            \\n        count++;\\n        }\\n        return dummy;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3659487,
                "title": "javascript-solution",
                "content": "# Complexity\\n- Time complexity:\\nAmortized O(n), as the check for `isEvenGroup` occurs in the last group, which increases proportionally to n, resulting in a complexity of O(sqrt(n)). However, these calculations can be shared among other groups, thus leading to an amortized complexity of O(1) for `isEvenGroup`\\n\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nvar reverseEvenLengthGroups = function(head) {\\n    if(head?.next?.next == null) {\\n        return head;\\n    }\\n    let fastNode = head;\\n    let slowNode = head;\\n\\n    let firstNode = head;\\n    let nthGroup = 2;\\n    while(slowNode != null && slowNode.next != null) {\\n        fastNode = fastNode?.next?.next\\n        firstNode = slowNode;\\n        slowNode = slowNode.next;\\n        if(fastNode != null && nthGroup % 2 === 0 || fastNode == null && isEvenGroup(slowNode)) {\\n            [fastNode, slowNode] = reverseNodesMutation(firstNode, slowNode, fastNode)\\n        }\\n\\n        nthGroup++\\n        for(let i = 0; i < nthGroup - 2; i++) {\\n            fastNode = fastNode?.next;\\n            slowNode = slowNode?.next;\\n        }\\n    }\\n    return head;\\n};\\n\\nfunction isEvenGroup(slowNode) {\\n    let count = 0;\\n    while(slowNode != null) {\\n        slowNode = slowNode.next;\\n        count++\\n    }\\n    return count % 2 === 0;\\n}\\n\\n// 0 | 1 2 null |\\nfunction reverseNodesMutation(firstNode, slowNode, fastNode) {\\n    const lastNode = fastNode?.next ?? null;\\n    let prevSlowNode = lastNode;\\n    let slowNodePointer = slowNode;\\n    while(slowNodePointer != lastNode) {\\n        const nextSlowNode = slowNodePointer.next;\\n        slowNodePointer.next = prevSlowNode;\\n        prevSlowNode = slowNodePointer\\n        slowNodePointer = nextSlowNode\\n    }\\n    firstNode.next = fastNode ?? prevSlowNode\\n    return [slowNode, fastNode];\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nvar reverseEvenLengthGroups = function(head) {\\n    if(head?.next?.next == null) {\\n        return head;\\n    }\\n    let fastNode = head;\\n    let slowNode = head;\\n\\n    let firstNode = head;\\n    let nthGroup = 2;\\n    while(slowNode != null && slowNode.next != null) {\\n        fastNode = fastNode?.next?.next\\n        firstNode = slowNode;\\n        slowNode = slowNode.next;\\n        if(fastNode != null && nthGroup % 2 === 0 || fastNode == null && isEvenGroup(slowNode)) {\\n            [fastNode, slowNode] = reverseNodesMutation(firstNode, slowNode, fastNode)\\n        }\\n\\n        nthGroup++\\n        for(let i = 0; i < nthGroup - 2; i++) {\\n            fastNode = fastNode?.next;\\n            slowNode = slowNode?.next;\\n        }\\n    }\\n    return head;\\n};\\n\\nfunction isEvenGroup(slowNode) {\\n    let count = 0;\\n    while(slowNode != null) {\\n        slowNode = slowNode.next;\\n        count++\\n    }\\n    return count % 2 === 0;\\n}\\n\\n// 0 | 1 2 null |\\nfunction reverseNodesMutation(firstNode, slowNode, fastNode) {\\n    const lastNode = fastNode?.next ?? null;\\n    let prevSlowNode = lastNode;\\n    let slowNodePointer = slowNode;\\n    while(slowNodePointer != lastNode) {\\n        const nextSlowNode = slowNodePointer.next;\\n        slowNodePointer.next = prevSlowNode;\\n        prevSlowNode = slowNodePointer\\n        slowNodePointer = nextSlowNode\\n    }\\n    firstNode.next = fastNode ?? prevSlowNode\\n    return [slowNode, fastNode];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3653124,
                "title": "python-in-place-reversal-o-n-time-o-1-space",
                "content": "```\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        #count total_length\\n        def count_length(head):\\n            pointer, counter = head, 0\\n            while pointer:\\n                pointer, counter = pointer.next, counter + 1\\n            return counter\\n\\n        #reverse n nodes starting from parent.next\\n        def reverse_n_nodes(parent, n):\\n            prev, current, next_ = parent.next, parent.next.next, parent.next.next.next\\n            tail = prev\\n            for i in range(n - 1):\\n                parent.next = current\\n                current.next = prev\\n                prev, current, next_ = current, next_, next_.next if next_ else None\\n            tail.next = current\\n            return tail\\n            \\n        total_length, length, parent = count_length(head), 1, ListNode(-1, head)\\n\\n        while total_length > 0:\\n            if length % 2 == 1:\\n                # Go to the parent of the next group\\n                for i in range(length):\\n                    parent = parent.next\\n            else:\\n                #Reverse length nodes\\n                parent = reverse_n_nodes(parent, length)\\n            total_length -= length\\n            length = min(length + 1, total_length)\\n        return head\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Linked List"
                ],
                "code": "```\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        #count total_length\\n        def count_length(head):\\n            pointer, counter = head, 0\\n            while pointer:\\n                pointer, counter = pointer.next, counter + 1\\n            return counter\\n\\n        #reverse n nodes starting from parent.next\\n        def reverse_n_nodes(parent, n):\\n            prev, current, next_ = parent.next, parent.next.next, parent.next.next.next\\n            tail = prev\\n            for i in range(n - 1):\\n                parent.next = current\\n                current.next = prev\\n                prev, current, next_ = current, next_, next_.next if next_ else None\\n            tail.next = current\\n            return tail\\n            \\n        total_length, length, parent = count_length(head), 1, ListNode(-1, head)\\n\\n        while total_length > 0:\\n            if length % 2 == 1:\\n                # Go to the parent of the next group\\n                for i in range(length):\\n                    parent = parent.next\\n            else:\\n                #Reverse length nodes\\n                parent = reverse_n_nodes(parent, length)\\n            total_length -= length\\n            length = min(length + 1, total_length)\\n        return head\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3651016,
                "title": "c-reverse-nodes-in-even-length-groups",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\n    ListNode* Reverse(ListNode* p, ListNode* q){\\n        ListNode* prev = nullptr;\\n        ListNode* curr = p;\\n        ListNode* next = nullptr;\\n        \\n        while (curr != nullptr && curr != q) {\\n            next = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = next;\\n        }\\n        curr->next = prev;\\n        prev = curr;\\n        return prev;\\n    }\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        ListNode *ans=head, *p =head->next, *curr = head, *s, *e, *t, *z;\\n        int x = 1, n = 1, a;\\n        while(p){\\n            t = p;\\n            s = p;\\n            x = 1 + x;\\n            a = x;\\n            n=1;\\n            while(a>1 && t->next){\\n                t = t->next;\\n                a--;\\n                n++;\\n            }\\n            e = t;\\n            p = t->next;\\n            if(n%2 == 0){\\n                z = Reverse(s, e);\\n                curr->next = z;\\n                while(curr->next){\\n                    curr = curr->next;\\n                }\\n            }\\n            else{\\n                curr->next = s;\\n                curr = e;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\n    ListNode* Reverse(ListNode* p, ListNode* q){\\n        ListNode* prev = nullptr;\\n        ListNode* curr = p;\\n        ListNode* next = nullptr;\\n        \\n        while (curr != nullptr && curr != q) {\\n            next = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = next;\\n        }\\n        curr->next = prev;\\n        prev = curr;\\n        return prev;\\n    }\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        ListNode *ans=head, *p =head->next, *curr = head, *s, *e, *t, *z;\\n        int x = 1, n = 1, a;\\n        while(p){\\n            t = p;\\n            s = p;\\n            x = 1 + x;\\n            a = x;\\n            n=1;\\n            while(a>1 && t->next){\\n                t = t->next;\\n                a--;\\n                n++;\\n            }\\n            e = t;\\n            p = t->next;\\n            if(n%2 == 0){\\n                z = Reverse(s, e);\\n                curr->next = z;\\n                while(curr->next){\\n                    curr = curr->next;\\n                }\\n            }\\n            else{\\n                curr->next = s;\\n                curr = e;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3649759,
                "title": "kotlin-same-as-all-other-solutions-o-n-o-1-no-negative-marking-for-bad-humour",
                "content": "# Intuition\\nTrack groups with even nodes ( edge case where last group was odd but has only even nodes due to shortage, is also part of this)\\n# Approach\\nTraverse the whole LL from start to end. For each group maintain the following: \\n- Group number\\n- Number of nodes in the group\\n- Pointer to start of current group\\n\\nFor reversing the LL, we need to perform the few extra steps as follows:\\n- The start of LL will be end so store it and return so that p can be updated\\n- start and end are actually subset of a bigger LL so point the end and terminal nodes. \\n- Happy reversing. \\n\\n# Complexity\\n- Time complexity:\\nO(N + N/2)\\n- Space complexity:\\nO(1)\\n# Code\\n```\\n/**\\n * Example:\\n * var li = ListNode(5)\\n * var v = li.`val`\\n * Definition for singly-linked list.\\n * class ListNode(var `val`: Int) {\\n *     var next: ListNode? = null\\n * }\\n */\\nclass Solution {\\n    fun reverseEvenLengthGroups(head: ListNode?): ListNode? {\\n        var group = 1   // Holds the group number\\n        var groupCounter = 0  // Number of nodes in current group\\n        var prevGroupNode = head  // Start of our current group\\n        var p = head\\n        while(p != null){\\n            ++groupCounter\\n            if(groupCounter == group || p!!.next == null){ // End of current group\\n                if(groupCounter % 2 == 0){\\n                    p = swap(prevGroupNode, prevGroupNode!!.next, prevGroupNode!!.next!!.next, p)\\n                }\\n                groupCounter = 0\\n                prevGroupNode = p\\n                ++group\\n            }\\n            p = p!!.next\\n        }\\n        return head\\n    }\\n\\n    // None of these will be [null] to begin with as we will be reversing atleast 2 nodes\\n    // Endnode is required to understand the terminal condition as it will not be null\\n    fun swap( p1: ListNode?, p2: ListNode?, p3: ListNode?, endNode: ListNode?): ListNode? { \\n\\n        // Please forgive me for shadowing some good vals. Kids this is bad coding. Don\\'t follow this at home\\n        var p1 = p1  \\n        var p2 = p2\\n        var p3 = p3\\n\\n        // Preparation\\n        var op = p2 // This will be our new p\\n        p1!!.next = endNode\\n        p2!!.next = endNode!!.next\\n\\n        // Time to move pointers after preparations\\n        p1 = p2\\n        p2 = p3\\n        p3 = p3!!.next\\n\\n        // Happy hunting\\n        while(p1 != endNode){\\n            p2!!.next = p1\\n            p1 = p2\\n            p2 = p3\\n            if(p3 != null)\\n            p3 = p3!!.next\\n        }\\n\\n        // Dinner is ready\\n        return op\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\n/**\\n * Example:\\n * var li = ListNode(5)\\n * var v = li.`val`\\n * Definition for singly-linked list.\\n * class ListNode(var `val`: Int) {\\n *     var next: ListNode? = null\\n * }\\n */\\nclass Solution {\\n    fun reverseEvenLengthGroups(head: ListNode?): ListNode? {\\n        var group = 1   // Holds the group number\\n        var groupCounter = 0  // Number of nodes in current group\\n        var prevGroupNode = head  // Start of our current group\\n        var p = head\\n        while(p != null){\\n            ++groupCounter\\n            if(groupCounter == group || p!!.next == null){ // End of current group\\n                if(groupCounter % 2 == 0){\\n                    p = swap(prevGroupNode, prevGroupNode!!.next, prevGroupNode!!.next!!.next, p)\\n                }\\n                groupCounter = 0\\n                prevGroupNode = p\\n                ++group\\n            }\\n            p = p!!.next\\n        }\\n        return head\\n    }\\n\\n    // None of these will be [null] to begin with as we will be reversing atleast 2 nodes\\n    // Endnode is required to understand the terminal condition as it will not be null\\n    fun swap( p1: ListNode?, p2: ListNode?, p3: ListNode?, endNode: ListNode?): ListNode? { \\n\\n        // Please forgive me for shadowing some good vals. Kids this is bad coding. Don\\'t follow this at home\\n        var p1 = p1  \\n        var p2 = p2\\n        var p3 = p3\\n\\n        // Preparation\\n        var op = p2 // This will be our new p\\n        p1!!.next = endNode\\n        p2!!.next = endNode!!.next\\n\\n        // Time to move pointers after preparations\\n        p1 = p2\\n        p2 = p3\\n        p3 = p3!!.next\\n\\n        // Happy hunting\\n        while(p1 != endNode){\\n            p2!!.next = p1\\n            p1 = p2\\n            p2 = p3\\n            if(p3 != null)\\n            p3 = p3!!.next\\n        }\\n\\n        // Dinner is ready\\n        return op\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3636539,
                "title": "short-clean-c-o-n-constant-space-answer",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind my approach is similar to other solutions but just cleaner code for your reference. Basically it involves 3 steps:\\n1. obtain the actual current group length\\n2. reverse the group if actual length turns to be even length\\n3. reconnect the disconnected group due to reversal. Reset some pointers for the next iteration\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe first 2 steps are intuitive and should be easy to implement. For the 3rd step, it\\'s a little bit tricky to get all details right. In my approach, I have the head and end pointers pointing to the starting and ending node of each group. When the reversal is happening, set the prev pointer to be the next group\\'s first node so that it automatically connects the reversed group to the rest of the linked list. Then, we only need to reconnect the previous part of the linked list by pointing prev->next to the original ending node, which is the starting node of the reveresed group.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n) since we linearly iterate through the list\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1) since fixed number of variables are used\\n# Code\\n```\\nclass Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        ListNode *end = head, *prev = nullptr, *newHead = head;\\n        for (int groupLen = 1; head; ++groupLen, prev = head, head = head->next, end = head) {\\n            int currLen = 1;\\n            while (currLen < groupLen && end->next) {\\n                end = end->next;\\n                ++currLen;\\n            }\\n\\n            if (currLen % 2 == 0) {\\n                reverseList(head, end->next);\\n                prev->next = end;\\n            } else {\\n                head = end;\\n            }\\n        }\\n        return newHead;\\n    }\\n\\nprivate:\\n    void reverseList(ListNode* head, ListNode* end) {\\n        ListNode *prev = end, *next = head;\\n        while (head != end) {\\n            next = head->next;\\n            head->next = prev;\\n            prev = head;\\n            head = next;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        ListNode *end = head, *prev = nullptr, *newHead = head;\\n        for (int groupLen = 1; head; ++groupLen, prev = head, head = head->next, end = head) {\\n            int currLen = 1;\\n            while (currLen < groupLen && end->next) {\\n                end = end->next;\\n                ++currLen;\\n            }\\n\\n            if (currLen % 2 == 0) {\\n                reverseList(head, end->next);\\n                prev->next = end;\\n            } else {\\n                head = end;\\n            }\\n        }\\n        return newHead;\\n    }\\n\\nprivate:\\n    void reverseList(ListNode* head, ListNode* end) {\\n        ListNode *prev = end, *next = head;\\n        while (head != end) {\\n            next = head->next;\\n            head->next = prev;\\n            prev = head;\\n            head = next;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3613934,
                "title": "c-solution-with-explanation",
                "content": "# EXPLANATION\\nWe started from the first node of list.\\nWe kept a count **i** for the **i**th group of list.\\nOur intuition is that we check for **i**th group.\\nIf that group has even length we reverse that set of list or else move formward to the next group.\\nFinally returning the answer.\\n# SOLUTION\\n```\\nclass Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        ListNode *a=head;\\n        int i=1;\\n        while(a){\\n            i++;\\n            int j=0;\\n            ListNode *b=a->next,*c=a;\\n            while(b && j<i){\\n                c=c->next;\\n                j++;\\n                b=b->next;\\n            }\\n            if(j%2==0 && j!=0){\\n                ListNode *x=a->next,*y=NULL,*z=x,*t=a->next;\\n                while(j-->0){\\n                    z=x->next;\\n                    x->next=y;\\n                    y=x;\\n                    x=z;\\n                }\\n                a->next=y;\\n                a=t;\\n                a->next=x;\\n            }\\n            else if(b)\\n                a=c;\\n            else \\n                a=b;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        ListNode *a=head;\\n        int i=1;\\n        while(a){\\n            i++;\\n            int j=0;\\n            ListNode *b=a->next,*c=a;\\n            while(b && j<i){\\n                c=c->next;\\n                j++;\\n                b=b->next;\\n            }\\n            if(j%2==0 && j!=0){\\n                ListNode *x=a->next,*y=NULL,*z=x,*t=a->next;\\n                while(j-->0){\\n                    z=x->next;\\n                    x->next=y;\\n                    y=x;\\n                    x=z;\\n                }\\n                a->next=y;\\n                a=t;\\n                a->next=x;\\n            }\\n            else if(b)\\n                a=c;\\n            else \\n                a=b;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3611498,
                "title": "python-solution",
                "content": "# Intuition\\nUse a similar approach to [reverse nodes in k-group](https://leetcode.com/problems/reverse-nodes-in-k-group/solutions/3071426/c-solution/). Create a helper function to reverse a linked list that keeps track of the next node to the reversal and make sure we link each group (reversed with non-reversed).\\n\\n# Approach\\nKeep track of the groups and the size. Make a reversal function that ties together the next node from the current group being reversed. We also need to keep track of the current size of the list and choose the minimum between the group size and the remaining size.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def size(self, head):\\n        size = 0\\n        while head:\\n            size, head = size + 1, head.next\\n        return size\\n\\n    def reverse(self, head, count):\\n        # previous, current, tail is next node after reversal\\n        prev, current, tail = None, head, None\\n        while current and count > 0:\\n            next = current.next           \\n\\n            tail = next\\n            current.next = prev\\n            prev = current            \\n            current = next\\n            count -= 1\\n        # prev is the new head\\n        # head is the last\\n        # the next to head is tail\\n        head.next = tail\\n        return prev\\n\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        sentinel = ListNode(0, head)\\n        tail, current = sentinel, sentinel.next\\n        size = self.size(head)\\n\\n        group = 1\\n        while current:\\n            group = min(group, size)\\n            if group % 2: # advance\\n                for _ in range(group):\\n                    tail.next = current\\n                    tail = tail.next\\n                    current = current.next\\n            else: # reversal\\n                tail.next = self.reverse(current, group)\\n                tail = current\\n                current = current.next\\n            size -= group\\n            group += 1        \\n        return sentinel.next\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def size(self, head):\\n        size = 0\\n        while head:\\n            size, head = size + 1, head.next\\n        return size\\n\\n    def reverse(self, head, count):\\n        # previous, current, tail is next node after reversal\\n        prev, current, tail = None, head, None\\n        while current and count > 0:\\n            next = current.next           \\n\\n            tail = next\\n            current.next = prev\\n            prev = current            \\n            current = next\\n            count -= 1\\n        # prev is the new head\\n        # head is the last\\n        # the next to head is tail\\n        head.next = tail\\n        return prev\\n\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        sentinel = ListNode(0, head)\\n        tail, current = sentinel, sentinel.next\\n        size = self.size(head)\\n\\n        group = 1\\n        while current:\\n            group = min(group, size)\\n            if group % 2: # advance\\n                for _ in range(group):\\n                    tail.next = current\\n                    tail = tail.next\\n                    current = current.next\\n            else: # reversal\\n                tail.next = self.reverse(current, group)\\n                tail = current\\n                current = current.next\\n            size -= group\\n            group += 1        \\n        return sentinel.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3609344,
                "title": "java-solution-o-n-time-o-1-space",
                "content": "\\n# Code\\n```\\nclass Solution {\\n\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        // pointer before a group\\n        var before = head;\\n\\n        // max nodes in a group (but may be less if the group is the last)\\n        int max = 2; //start with second group right away\\n\\n        while (before.next != null) { // pass through a group\\n            int len = 0;\\n            var curr = before;\\n            \\n            while (curr.next != null && len < max) {   \\n                curr = curr.next;\\n                len++;\\n            }\\n\\n            // group is even && len is even -> reverse\\n            // group is even && len is odd -> last group (odd) -> skip\\n            // group is odd && len is even -> last group (even) -> reverse\\n            // group is odd && len is odd -> reverse\\n            // all boils down to whether len is even or not\\n            if (len % 2 == 0) { // \\n                before = reverse(before, len);\\n            } else {\\n                before = curr;\\n            }\\n            \\n            max++;\\n        }\\n        return head;\\n    }\\n\\n    ListNode reverse(ListNode before, int len) {\\n        var first = before.next; \\n        var curr = first;\\n        ListNode prev = null;\\n        \\n        int count = 0;\\n        while (count < len ) { \\n            // swap pointers\\n            var next = curr.next; \\n            curr.next = prev; \\n            prev = curr; \\n            curr = next; \\n            \\n            count++;\\n        }\\n\\n        // swap node before the current group with last node in the group and  \\n        before.next = prev;\\n        // swap first node in group with first node outside the group\\n        first.next = curr;\\n\\n        return first;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\n\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        // pointer before a group\\n        var before = head;\\n\\n        // max nodes in a group (but may be less if the group is the last)\\n        int max = 2; //start with second group right away\\n\\n        while (before.next != null) { // pass through a group\\n            int len = 0;\\n            var curr = before;\\n            \\n            while (curr.next != null && len < max) {   \\n                curr = curr.next;\\n                len++;\\n            }\\n\\n            // group is even && len is even -> reverse\\n            // group is even && len is odd -> last group (odd) -> skip\\n            // group is odd && len is even -> last group (even) -> reverse\\n            // group is odd && len is odd -> reverse\\n            // all boils down to whether len is even or not\\n            if (len % 2 == 0) { // \\n                before = reverse(before, len);\\n            } else {\\n                before = curr;\\n            }\\n            \\n            max++;\\n        }\\n        return head;\\n    }\\n\\n    ListNode reverse(ListNode before, int len) {\\n        var first = before.next; \\n        var curr = first;\\n        ListNode prev = null;\\n        \\n        int count = 0;\\n        while (count < len ) { \\n            // swap pointers\\n            var next = curr.next; \\n            curr.next = prev; \\n            prev = curr; \\n            curr = next; \\n            \\n            count++;\\n        }\\n\\n        // swap node before the current group with last node in the group and  \\n        before.next = prev;\\n        // swap first node in group with first node outside the group\\n        first.next = curr;\\n\\n        return first;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3598856,
                "title": "6-reverse-nodes-in-even-length-groups",
                "content": "#### Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI immediately thought of using a fast and slow pointers + keeping count of the current number of nodes in the group and the maximum number of nodes in the group. The later was correct, but the former was misguided. The objectives are the position of the last element of the previous group and the last element of the current group, which are needed for reversing. In that sense, it is sliding window, with the one side fixed at the last element of the previous group, while the other is dragged out to the last element of the current group. At each window, we check the oddity of the current number of nodes and reverse if necessary.\\n\\n#### Algorithm\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize the left pointer and max group length.\\n2. Iterate the linked list starting at `head.next` (the first element does not need to be reversed), one window up to the max group length at a time.\\n3. If there are even number of nodes in the window, reverse it. Else, do nothing.\\n4. Return `head` after modification.\\n\\n#### Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$O(n)$: Iterate the linked list less than two times.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$O(n)$: Store only some integers.\\n\\n#### Code\\n\\nThe shorthand reversal in Python is included in comments. While it looks awesome, I think that I should avoid it here as it makes debugging impossible and is certain to confuse my colleagues.\\n```python\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        group_prev = head\\n        curr_max_length = 2\\n\\n        while group_prev.next:\\n            curr = group_prev\\n            count = 0\\n            \\n            for _ in range(curr_max_length):\\n                if not curr.next:\\n                    break\\n                count += 1\\n                curr = curr.next\\n\\n            if count % 2: # Odd, do nothing\\n                group_prev = curr\\n            else:         # Even, reverse\\n                group_next = curr.next\\n                curr = group_prev.next\\n                \\n                for _ in range(count):\\n                    # curr.next, curr, group_next = group_next, curr.next, curr\\n                    curr_next = curr.next\\n                    curr.next = group_next\\n                    group_next = curr\\n                    curr = curr_next\\n                # group_prev.next.next, group_prev.next, group_prev = curr, group_next, group_prev.next\\n                prev_next = group_prev.next\\n                group_prev.next = group_next\\n                group_prev = prev_next\\n            curr_max_length += 1\\n        return head\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        group_prev = head\\n        curr_max_length = 2\\n\\n        while group_prev.next:\\n            curr = group_prev\\n            count = 0\\n            \\n            for _ in range(curr_max_length):\\n                if not curr.next:\\n                    break\\n                count += 1\\n                curr = curr.next\\n\\n            if count % 2: # Odd, do nothing\\n                group_prev = curr\\n            else:         # Even, reverse\\n                group_next = curr.next\\n                curr = group_prev.next\\n                \\n                for _ in range(count):\\n                    # curr.next, curr, group_next = group_next, curr.next, curr\\n                    curr_next = curr.next\\n                    curr.next = group_next\\n                    group_next = curr\\n                    curr = curr_next\\n                # group_prev.next.next, group_prev.next, group_prev = curr, group_next, group_prev.next\\n                prev_next = group_prev.next\\n                group_prev.next = group_next\\n                group_prev = prev_next\\n            curr_max_length += 1\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3585351,
                "title": "python3-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\n        def reverse(node, size):\\n            prev = None\\n            curr = node\\n            fllw = None\\n\\n            for _ in range(size):\\n                fllw = curr.next\\n                curr.next = prev\\n                prev = curr\\n                curr = fllw\\n\\n            return prev\\n\\n        group_starts = []\\n        curr = head\\n        group_size = 1 \\n        while curr:\\n            group_starts.append([group_size, curr])\\n            for _ in range(group_size):\\n                if curr:\\n                    curr = curr.next\\n            group_size += 1\\n        \\n        res = []\\n        count = 0\\n        for start in group_starts:\\n            count += 1\\n            if count == len(group_starts):\\n                # last element\\n                length = 0\\n                curr = start[1]\\n                while curr:\\n                    length += 1\\n                    curr = curr.next\\n                if length % 2 == 0:\\n                    res.append([start[0], reverse(start[1], length)])\\n                else:\\n                    res.append(start)\\n            elif start[0] % 2 == 0:\\n                res.append([start[0], reverse(start[1], start[0])])\\n            else:\\n                res.append(start)\\n\\n        dummy = tail = ListNode()\\n        for pair in res:\\n            size = pair[0]\\n            node = pair[1]\\n            tail.next = node\\n            for _ in range(size):\\n                if tail:\\n                    tail = tail.next\\n        \\n        return dummy.next\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\n        def reverse(node, size):\\n            prev = None\\n            curr = node\\n            fllw = None\\n\\n            for _ in range(size):\\n                fllw = curr.next\\n                curr.next = prev\\n                prev = curr\\n                curr = fllw\\n\\n            return prev\\n\\n        group_starts = []\\n        curr = head\\n        group_size = 1 \\n        while curr:\\n            group_starts.append([group_size, curr])\\n            for _ in range(group_size):\\n                if curr:\\n                    curr = curr.next\\n            group_size += 1\\n        \\n        res = []\\n        count = 0\\n        for start in group_starts:\\n            count += 1\\n            if count == len(group_starts):\\n                # last element\\n                length = 0\\n                curr = start[1]\\n                while curr:\\n                    length += 1\\n                    curr = curr.next\\n                if length % 2 == 0:\\n                    res.append([start[0], reverse(start[1], length)])\\n                else:\\n                    res.append(start)\\n            elif start[0] % 2 == 0:\\n                res.append([start[0], reverse(start[1], start[0])])\\n            else:\\n                res.append(start)\\n\\n        dummy = tail = ListNode()\\n        for pair in res:\\n            size = pair[0]\\n            node = pair[1]\\n            tail.next = node\\n            for _ in range(size):\\n                if tail:\\n                    tail = tail.next\\n        \\n        return dummy.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3579251,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can\\'t determine if the current group working on has enough length while traversing the group, so we must move forward some steps to determine if it has before deciding whether we reverse or not. We\\'ll have a auxilliary function `nextnum` to do this.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDetermine if the number of nodes from the current node equals the group length at every first node of groups.\\n\\nIf it does has the right number of nodes available, and the group number is even, we reverse such number of nodes. if it\\'s odd, just iterate through such number of nodes.\\n\\nIf not, it means that we meet the last group, with possibly 0 members. if the number it contains is not 0 and it is even, just reverse it like above, but with the number of nodes reversed be the number of this group, rather than the group number, as the current group does not have so many nodes as the group number.\\n\\nAbove is the main logic. Let\\'s talk about implementation.\\n\\nThe process of reversing and iterating nodes is similar, so we can use a single segment of code to do the both. In the code segment, we check whether the number of nodes we\\'re reversing is even, if so, just add some reversing specific code, like `cur->next = prev`.\\n\\nThere\\'s one thing to notice, after reversing the nodes, we have to modify `prev`, as after reversing, the node `prev` points to is indeed the start node of the reversed region, not the end node, we should ensure `prev` points to the right node by `prev = end`.\\n\\n\\n# Complexity\\n- Time complexity:O(n) obviously\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1) obviously\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        ListNode *prev(head),*cur(head->next);\\n        int gn(2);\\n        int n;\\n        while ((n = nextnum(cur,gn)) == gn) {\\n            //reverse or just iterate, depending on evenness of gn\\n            traverse(prev,cur,gn);\\n            ++gn;\\n        }\\n        //meets the last group with possibly 0 member\\n        if (n != 0 && !(n & 1)) {\\n            //reverse n nodes from cur\\n            traverse(prev,cur,n);\\n        }\\n        return head;\\n    }\\nprivate:\\n    //auxilliary counting function\\n    int nextnum(ListNode *node,int n) {\\n        int cnt(0);\\n        for (; node && cnt < n; ++cnt) {\\n            node = node->next;\\n        }\\n        return cnt;\\n    }\\n    void traverse(ListNode *&prev,ListNode *&cur,int n) {\\n        //save some ordinary infos in reversing process\\n        auto begprev = prev, end = cur;\\n        for (int i(0); i < n; ++i) {\\n            auto next = cur->next;\\n            //if we are reversing, some extra work is required\\n            if (!(n & 1)) {\\n                cur->next = prev;\\n            }\\n            prev = cur;\\n            cur = next;\\n        }\\n        //if we are reversing, some extra work is required\\n        if (!(n & 1)) {\\n            begprev->next = prev;\\n            end->next = cur;\\n            //adjust prev\\n            prev = end;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        ListNode *prev(head),*cur(head->next);\\n        int gn(2);\\n        int n;\\n        while ((n = nextnum(cur,gn)) == gn) {\\n            //reverse or just iterate, depending on evenness of gn\\n            traverse(prev,cur,gn);\\n            ++gn;\\n        }\\n        //meets the last group with possibly 0 member\\n        if (n != 0 && !(n & 1)) {\\n            //reverse n nodes from cur\\n            traverse(prev,cur,n);\\n        }\\n        return head;\\n    }\\nprivate:\\n    //auxilliary counting function\\n    int nextnum(ListNode *node,int n) {\\n        int cnt(0);\\n        for (; node && cnt < n; ++cnt) {\\n            node = node->next;\\n        }\\n        return cnt;\\n    }\\n    void traverse(ListNode *&prev,ListNode *&cur,int n) {\\n        //save some ordinary infos in reversing process\\n        auto begprev = prev, end = cur;\\n        for (int i(0); i < n; ++i) {\\n            auto next = cur->next;\\n            //if we are reversing, some extra work is required\\n            if (!(n & 1)) {\\n                cur->next = prev;\\n            }\\n            prev = cur;\\n            cur = next;\\n        }\\n        //if we are reversing, some extra work is required\\n        if (!(n & 1)) {\\n            begprev->next = prev;\\n            end->next = cur;\\n            //adjust prev\\n            prev = end;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3572320,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) \\n    {\\n        if(!head || !head->next)\\n        {\\n            return head;\\n        }\\n\\n        int l=2;\\n\\n        ListNode *prev = head;\\n        while(prev->next)\\n        {\\n            int i;\\n            ListNode *node = prev;\\n            for(i=0;i<l;i++)\\n            {\\n                if(!node->next)\\n                {\\n                    break;\\n                }\\n                node = node->next;\\n            }\\n\\n            if(i%2) //odd len\\n            {\\n                prev=node;\\n            }\\n            else\\n            {\\n                ListNode *reverse = node->next;\\n                ListNode *current = prev->next;\\n\\n                ListNode *nextNode = nullptr;\\n                for(int k=0;k<i;k++)\\n                {\\n                    nextNode = current->next;\\n                    current->next = reverse;\\n                    reverse = current;\\n                    current = nextNode; \\n                }\\n                ListNode *prevNext = prev->next;\\n                prev->next = reverse;\\n                prev = prevNext;\\n            }\\n\\n            l++;\\n        }\\n\\n\\n        return head;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) \\n    {\\n        if(!head || !head->next)\\n        {\\n            return head;\\n        }\\n\\n        int l=2;\\n\\n        ListNode *prev = head;\\n        while(prev->next)\\n        {\\n            int i;\\n            ListNode *node = prev;\\n            for(i=0;i<l;i++)\\n            {\\n                if(!node->next)\\n                {\\n                    break;\\n                }\\n                node = node->next;\\n            }\\n\\n            if(i%2) //odd len\\n            {\\n                prev=node;\\n            }\\n            else\\n            {\\n                ListNode *reverse = node->next;\\n                ListNode *current = prev->next;\\n\\n                ListNode *nextNode = nullptr;\\n                for(int k=0;k<i;k++)\\n                {\\n                    nextNode = current->next;\\n                    current->next = reverse;\\n                    reverse = current;\\n                    current = nextNode; \\n                }\\n                ListNode *prevNext = prev->next;\\n                prev->next = reverse;\\n                prev = prevNext;\\n            }\\n\\n            l++;\\n        }\\n\\n\\n        return head;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3552974,
                "title": "java-o-n-solution-using-pointers",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        if(head == null){\\n            return head;\\n        }\\n        if(head.next == null){\\n            return head;\\n        }\\n        if(head.next != null && head.next.next == null){\\n            return head;\\n        }\\n        ListNode dummy = head;\\n        ListNode ptr = head.next;\\n        int k = 2;\\n        while(ptr != null){\\n        ListNode curr = ptr;\\n        ListNode nextHead = curr;\\n        int start = 1;\\n        while(start < k){\\n            ptr = ptr.next;\\n            if(ptr == null){\\n                break;\\n            }\\n            start++;\\n        }\\n        if(ptr != null){\\n        ptr = ptr.next;\\n        }\\n        if(start %2 == 0){\\n        ListNode prev = ptr;\\n        while(start-- > 0){\\n        ListNode forward = curr.next;\\n        curr.next = prev;\\n        prev = curr;\\n        curr = forward;\\n        }\\n        dummy.next = prev;\\n        dummy = nextHead;\\n        }\\n        else{\\n            while(start-- > 0){\\n                dummy = dummy.next;\\n        }\\n        }\\n        k++;\\n        }\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        if(head == null){\\n            return head;\\n        }\\n        if(head.next == null){\\n            return head;\\n        }\\n        if(head.next != null && head.next.next == null){\\n            return head;\\n        }\\n        ListNode dummy = head;\\n        ListNode ptr = head.next;\\n        int k = 2;\\n        while(ptr != null){\\n        ListNode curr = ptr;\\n        ListNode nextHead = curr;\\n        int start = 1;\\n        while(start < k){\\n            ptr = ptr.next;\\n            if(ptr == null){\\n                break;\\n            }\\n            start++;\\n        }\\n        if(ptr != null){\\n        ptr = ptr.next;\\n        }\\n        if(start %2 == 0){\\n        ListNode prev = ptr;\\n        while(start-- > 0){\\n        ListNode forward = curr.next;\\n        curr.next = prev;\\n        prev = curr;\\n        curr = forward;\\n        }\\n        dummy.next = prev;\\n        dummy = nextHead;\\n        }\\n        else{\\n            while(start-- > 0){\\n                dummy = dummy.next;\\n        }\\n        }\\n        k++;\\n        }\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3539547,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution \\n{\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) \\n    {\\n        ListNode *prev,*curr,*nxt,*t1,*t2;\\n        ListNode *dummy=new ListNode();\\n\\n        int i,k;\\n        k=1;\\n\\n        dummy->next=head;\\n        prev=NULL;\\n        curr=head;\\n        t1=dummy;\\n        t2=head;\\n\\n        while(curr!=NULL)\\n        {\\n            ListNode *temp;\\n            temp=curr;\\n\\n            for(i=0;temp!=NULL && i<k;i++)\\n            {\\n                temp=temp->next;\\n            }\\n\\n            if(temp==NULL)\\n            {\\n                k=i;\\n            }\\n\\n            for(i=0;curr!=NULL && k%2==0 && i<k;i++)\\n            {\\n                nxt=curr->next;\\n                curr->next=prev;\\n                prev=curr;\\n                curr=nxt;\\n            }\\n\\n            for(i=0;curr!=NULL && k%2==1 && i<k;i++)\\n            {\\n                nxt=curr->next;\\n                prev=curr;\\n                curr=nxt;\\n            }\\n\\n            if(k%2==0)\\n            {\\n                if(t1!=NULL)\\n                {\\n\\n                t1->next=prev;\\n                }\\n                if(t2!=NULL)\\n                {\\n\\n                t2->next=curr;\\n                }\\n                prev=t2;\\n            }\\n\\n            t1=prev;\\n            t2=curr;\\n            k++;\\n        }\\n\\n        return dummy->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution \\n{\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) \\n    {\\n        ListNode *prev,*curr,*nxt,*t1,*t2;\\n        ListNode *dummy=new ListNode();\\n\\n        int i,k;\\n        k=1;\\n\\n        dummy->next=head;\\n        prev=NULL;\\n        curr=head;\\n        t1=dummy;\\n        t2=head;\\n\\n        while(curr!=NULL)\\n        {\\n            ListNode *temp;\\n            temp=curr;\\n\\n            for(i=0;temp!=NULL && i<k;i++)\\n            {\\n                temp=temp->next;\\n            }\\n\\n            if(temp==NULL)\\n            {\\n                k=i;\\n            }\\n\\n            for(i=0;curr!=NULL && k%2==0 && i<k;i++)\\n            {\\n                nxt=curr->next;\\n                curr->next=prev;\\n                prev=curr;\\n                curr=nxt;\\n            }\\n\\n            for(i=0;curr!=NULL && k%2==1 && i<k;i++)\\n            {\\n                nxt=curr->next;\\n                prev=curr;\\n                curr=nxt;\\n            }\\n\\n            if(k%2==0)\\n            {\\n                if(t1!=NULL)\\n                {\\n\\n                t1->next=prev;\\n                }\\n                if(t2!=NULL)\\n                {\\n\\n                t2->next=curr;\\n                }\\n                prev=t2;\\n            }\\n\\n            t1=prev;\\n            t2=curr;\\n            k++;\\n        }\\n\\n        return dummy->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3531254,
                "title": "c-language",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     struct ListNode *next;\\n * };\\n */\\n\\nstruct ListNode* reverseList(struct ListNode* head)\\n{\\n    if (!head)\\n        return head;\\n    struct ListNode* prev = NULL;\\n    while (head)\\n    {\\n        struct ListNode* temp = head->next;\\n        head->next = prev;\\n        prev = head;\\n        head = temp;\\n    }\\n    return prev;\\n}\\n\\nstruct ListNode* reverseEvenLengthGroups(struct ListNode* head){\\n    struct ListNode* dummy = malloc(sizeof(struct ListNode));\\n    dummy->next = head;\\n\\n    struct ListNode* prev = dummy;\\n\\n    for (int len = 1; len < 1e5 && head; len++)\\n    {\\n        struct ListNode* tail = head;\\n        struct ListNode* nextHead;\\n\\n        int j = 1;\\n        while (j < len && tail && tail->next)\\n        {\\n            tail = tail->next;\\n            j++;\\n        }\\n\\n        nextHead = tail->next;\\n\\n        if ((j % 2) == 0)\\n        {\\n            tail->next = NULL;\\n            prev->next = reverseList(head);\\n            prev = head;\\n            head->next = nextHead;\\n            head = nextHead;\\n        }\\n        else\\n        {\\n            prev = tail;\\n            head = nextHead;\\n        }\\n    }\\n    return dummy->next;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     struct ListNode *next;\\n * };\\n */\\n\\nstruct ListNode* reverseList(struct ListNode* head)\\n{\\n    if (!head)\\n        return head;\\n    struct ListNode* prev = NULL;\\n    while (head)\\n    {\\n        struct ListNode* temp = head->next;\\n        head->next = prev;\\n        prev = head;\\n        head = temp;\\n    }\\n    return prev;\\n}\\n\\nstruct ListNode* reverseEvenLengthGroups(struct ListNode* head){\\n    struct ListNode* dummy = malloc(sizeof(struct ListNode));\\n    dummy->next = head;\\n\\n    struct ListNode* prev = dummy;\\n\\n    for (int len = 1; len < 1e5 && head; len++)\\n    {\\n        struct ListNode* tail = head;\\n        struct ListNode* nextHead;\\n\\n        int j = 1;\\n        while (j < len && tail && tail->next)\\n        {\\n            tail = tail->next;\\n            j++;\\n        }\\n\\n        nextHead = tail->next;\\n\\n        if ((j % 2) == 0)\\n        {\\n            tail->next = NULL;\\n            prev->next = reverseList(head);\\n            prev = head;\\n            head->next = nextHead;\\n            head = nextHead;\\n        }\\n        else\\n        {\\n            prev = tail;\\n            head = nextHead;\\n        }\\n    }\\n    return dummy->next;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3530903,
                "title": "reverseevenlengthgroups-solved-recursively-through-the-reversekgroup-solution-code-runtime-87",
                "content": "# Intuition\\nI solved this problem after the reverseKGroup, so I thought i could use the same algorithm, using some little tweaks.\\n# Approach\\nI can use the reverseKGroup called with an initial k=1, then using a recursive call with an incremented k.\\nI can choose to reverse only the groups which have an even k, since i know that\\'s the length they will have.\\nThe only thing to fix was to check the length of the last group (recognised by the fact that the \"tail\" of the current list is None or not), since it can be \"not complete\", to choose if I have to reverse it or not.\\n\\n# Code\\n```# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        return self.reverseKGroup(head, 1)\\n\\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        \\n        #Base cases\\n        if (head is None) or (head.next is None):\\n            return head\\n            \\n        #Subdivision of the groups\\n        node = head\\n        for i in range(k-1):\\n            node = node.next\\n            if node.next is None:\\n                break\\n        \\n        #Recursive call\\n        app = self.reverseKGroup(node.next, k+1)\\n        node.next = app\\n\\n        #Dont reverse if it\\'s not the final group and k isn\\'t even\\n        if app is not None and (k%2) != 0:\\n            return head\\n\\n        #Counting the length of the last group to decide to reverse\\n        i = 0\\n        if app is None:\\n            node = head\\n            while node:\\n                node = node.next\\n                i += 1\\n            if (i%2) != 0:\\n                return head\\n        \\n        #Reverse the group\\n        curr = app\\n        while head is not app:\\n            node = head.next\\n            head.next = curr\\n            curr = head\\n            head = node\\n\\n        return curr\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        return self.reverseKGroup(head, 1)\\n\\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        \\n        #Base cases\\n        if (head is None) or (head.next is None):\\n            return head\\n            \\n        #Subdivision of the groups\\n        node = head\\n        for i in range(k-1):\\n            node = node.next\\n            if node.next is None:\\n                break\\n        \\n        #Recursive call\\n        app = self.reverseKGroup(node.next, k+1)\\n        node.next = app\\n\\n        #Dont reverse if it\\'s not the final group and k isn\\'t even\\n        if app is not None and (k%2) != 0:\\n            return head\\n\\n        #Counting the length of the last group to decide to reverse\\n        i = 0\\n        if app is None:\\n            node = head\\n            while node:\\n                node = node.next\\n                i += 1\\n            if (i%2) != 0:\\n                return head\\n        \\n        #Reverse the group\\n        curr = app\\n        while head is not app:\\n            node = head.next\\n            head.next = curr\\n            curr = head\\n            head = node\\n\\n        return curr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3529183,
                "title": "java-easy-codes-time-complexity-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        \\n           ListNode temp = head;\\n         int num=1;\\n    \\n    while(temp!=null)\\n    {\\n        int count=0;\\n        ListNode start = temp;\\n        Stack a = new Stack();\\n        \\n        while(count!=num && temp!=null)\\n        {\\n            a.push(temp.val);\\n            temp=temp.next;\\n            count++;       \\n        }\\n        if(count%2==0)\\n        {\\n            while(temp!=start)\\n            {\\n              start.val=(int) a.pop();\\n             start=start.next;  \\n                }\\n            \\n        } \\n        num++;\\n    }\\n    \\n    return head;\\n    \\n}\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        \\n           ListNode temp = head;\\n         int num=1;\\n    \\n    while(temp!=null)\\n    {\\n        int count=0;\\n        ListNode start = temp;\\n        Stack a = new Stack();\\n        \\n        while(count!=num && temp!=null)\\n        {\\n            a.push(temp.val);\\n            temp=temp.next;\\n            count++;       \\n        }\\n        if(count%2==0)\\n        {\\n            while(temp!=start)\\n            {\\n              start.val=(int) a.pop();\\n             start=start.next;  \\n                }\\n            \\n        } \\n        num++;\\n    }\\n    \\n    return head;\\n    \\n}\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3526126,
                "title": "very-easy-solution-c-using-stack",
                "content": "```\\n  \\n```class Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        \\n        if(head==NULL || head->next==NULL)return head;\\n        \\n        ListNode* temp=head,*hd=head;\\n        int i=1;\\n        \\n        \\n        while(temp!=NULL){\\n           \\n           hd=temp;\\n            \\n           stack<int> st;\\n           int j=0;\\n            \\n            while(j<i && temp!=NULL){\\n               \\n                st.push(temp->val);\\n                \\n                j++;\\n                temp=temp->next;\\n            }\\n            \\n            if(st.size()%2==0){\\n                \\n                while(!st.empty()){\\n                    \\n                    hd->val=st.top();\\n                    st.pop();\\n                    hd=hd->next;\\n                }\\n            }\\n            i++;\\n        }\\n        return head;\\n    }\\n};",
                "solutionTags": [],
                "code": "```\\n  \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3516336,
                "title": "c-2-traversals-well-commented",
                "content": "# Approach\\nDo the first traversal to store the starting nodes from which we have to reverse and also store the length of the group to be reversed in a vector of pair. Now do the second traversal to actually reverse the groups based on the pointers which you saved in vector. For the last group if the length is smaller than it should be, we have to manually reverse the last group by storing the pointer of the node previous to the last group\\'s starting node and reverse the last group after the previous pointer by simply applying the logic to reverse a linked list.\\n\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        //to store the pointer of the starting node\\n        //of the group and the length of the group\\n        vector<pair<ListNode*,int>> vec;\\n        ListNode* tmp = head;\\n        //k is length of 1st group and it will increase like \\n        // 1, 2, 3 ...\\n        int k = 1;\\n        while(tmp!=NULL)\\n        {\\n            int cnt = 0;\\n            ListNode* tmp1 = tmp;\\n            while(cnt<k && tmp!=NULL)\\n            {\\n                cnt++;\\n                tmp = tmp->next;\\n            }\\n            if(cnt%2==0)\\n            {\\n                vec.push_back({tmp1,cnt});\\n            }\\n            k++;\\n        }\\n        //this is for last group if length is smaller than needed\\n        int flg = 0;\\n        ListNode* lastPtr1 = NULL;\\n        ListNode* lastPtr2 = NULL;\\n        if(vec.size()>1 && vec[vec.size()-1].second<=vec[vec.size()-2].second)\\n        {\\n            flg = 1;\\n            lastPtr1 = vec[vec.size()-1].first;\\n        }\\n        //............\\n\\n        tmp = head;\\n        int ptr = 0;\\n        while(ptr<vec.size() && tmp!=NULL)\\n        {\\n            if(tmp->next==vec[ptr].first)\\n            {\\n                int cnt = vec[ptr].second;\\n                ListNode* first = tmp->next;\\n                ListNode* prev = NULL;\\n                ListNode* cur = first;\\n                int tcnt = 0;\\n                while(cur!=NULL && tcnt<cnt)\\n                {\\n                    tcnt++;\\n                    ListNode* tm = cur->next;\\n                    cur->next = prev;\\n                    prev = cur;\\n                    cur = tm;\\n                    if(tcnt==cnt-1)\\n                    {\\n                        ListNode* tmp2 = cur->next;\\n                        \\n                        cur->next = prev;\\n                        first->next = tmp2;\\n                        //here we are storing the \\n                        //previous pointer of the \\n                        //last group\\'s first node to \\n                        // reverse it at last.\\n                        if(first->next==lastPtr1 && flg)\\n                        {\\n                            lastPtr2 = first;\\n                        }\\n                        //........\\n\\n                        tmp->next = cur;\\n                        tmp = tmp2;\\n                        break;\\n                    }\\n                }\\n                ptr++;\\n            }\\n            else\\n            {\\n                tmp = tmp->next;\\n            }\\n        }\\n\\n        //this is the code to reverse the last group if \\n        // it was not reversed in the above part.\\n        if(lastPtr2!=NULL)\\n        {\\n            ListNode* prev = NULL;\\n            ListNode* cur = lastPtr2->next;\\n            while(cur!=NULL)\\n            {\\n                ListNode* tm = cur->next;\\n                cur->next = prev;\\n                prev = cur;\\n                cur = tm;\\n            }\\n            lastPtr2->next = prev;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        //to store the pointer of the starting node\\n        //of the group and the length of the group\\n        vector<pair<ListNode*,int>> vec;\\n        ListNode* tmp = head;\\n        //k is length of 1st group and it will increase like \\n        // 1, 2, 3 ...\\n        int k = 1;\\n        while(tmp!=NULL)\\n        {\\n            int cnt = 0;\\n            ListNode* tmp1 = tmp;\\n            while(cnt<k && tmp!=NULL)\\n            {\\n                cnt++;\\n                tmp = tmp->next;\\n            }\\n            if(cnt%2==0)\\n            {\\n                vec.push_back({tmp1,cnt});\\n            }\\n            k++;\\n        }\\n        //this is for last group if length is smaller than needed\\n        int flg = 0;\\n        ListNode* lastPtr1 = NULL;\\n        ListNode* lastPtr2 = NULL;\\n        if(vec.size()>1 && vec[vec.size()-1].second<=vec[vec.size()-2].second)\\n        {\\n            flg = 1;\\n            lastPtr1 = vec[vec.size()-1].first;\\n        }\\n        //............\\n\\n        tmp = head;\\n        int ptr = 0;\\n        while(ptr<vec.size() && tmp!=NULL)\\n        {\\n            if(tmp->next==vec[ptr].first)\\n            {\\n                int cnt = vec[ptr].second;\\n                ListNode* first = tmp->next;\\n                ListNode* prev = NULL;\\n                ListNode* cur = first;\\n                int tcnt = 0;\\n                while(cur!=NULL && tcnt<cnt)\\n                {\\n                    tcnt++;\\n                    ListNode* tm = cur->next;\\n                    cur->next = prev;\\n                    prev = cur;\\n                    cur = tm;\\n                    if(tcnt==cnt-1)\\n                    {\\n                        ListNode* tmp2 = cur->next;\\n                        \\n                        cur->next = prev;\\n                        first->next = tmp2;\\n                        //here we are storing the \\n                        //previous pointer of the \\n                        //last group\\'s first node to \\n                        // reverse it at last.\\n                        if(first->next==lastPtr1 && flg)\\n                        {\\n                            lastPtr2 = first;\\n                        }\\n                        //........\\n\\n                        tmp->next = cur;\\n                        tmp = tmp2;\\n                        break;\\n                    }\\n                }\\n                ptr++;\\n            }\\n            else\\n            {\\n                tmp = tmp->next;\\n            }\\n        }\\n\\n        //this is the code to reverse the last group if \\n        // it was not reversed in the above part.\\n        if(lastPtr2!=NULL)\\n        {\\n            ListNode* prev = NULL;\\n            ListNode* cur = lastPtr2->next;\\n            while(cur!=NULL)\\n            {\\n                ListNode* tm = cur->next;\\n                cur->next = prev;\\n                prev = cur;\\n                cur = tm;\\n            }\\n            lastPtr2->next = prev;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3443879,
                "title": "long-but-understandable-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nListNode* reverselast(ListNode* head){\\n    ListNode* prev=nullptr;\\n    ListNode* curr=head;\\n    ListNode* right=curr->next;\\n    while(curr!=nullptr){\\nright=curr->next;\\ncurr->next=prev;\\nprev=curr;\\ncurr=right;\\n    }\\n    return prev;\\n}\\nint cnt(ListNode* head){\\n    ListNode* temp=head;\\n    int i=0;\\n    while(temp!=nullptr){\\n        i++;\\n        temp=temp->next;\\n    }\\n    return i;\\n}\\nListNode* reverse(ListNode* head,int i){\\n    if(head==nullptr){\\n        return nullptr;\\n    }\\n\\n\\n    int count=cnt(head);\\n    //yecode last ke liye\\nif(count<i){\\n    if(count%2==0){\\nreturn reverselast(head);\\n    }\\n    else{\\n        return head;\\n    }\\n}\\n////////\\nif(i%2==0){\\nint j=0;\\nListNode* prev=NULL;\\nListNode* curr=head;\\nListNode* right=curr->next;\\nwhile(j<i){\\n    right=curr->next;\\n    curr->next=prev;\\n    prev=curr;\\n    curr=right;\\n    j++;\\n}\\nif(right!=nullptr){\\n    int x=i+1;\\n    ListNode* rightkaans=reverse(right,x);\\n    head->next=rightkaans;\\n}\\nreturn prev;}\\nelse{\\n    int k=0;\\n    ListNode* temp=head;\\n    ListNode* follow=head;\\n    while(k<i){\\n        follow=temp;\\ntemp=temp->next;\\nk++;\\n    }\\n    if(temp!=nullptr){\\n         ListNode* ans=reverse(temp,++i);\\n         follow->next=ans;\\n    }\\n    return head;\\n}\\nreturn nullptr;\\n}\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        int i=1;\\n        return reverse(head, i);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nListNode* reverselast(ListNode* head){\\n    ListNode* prev=nullptr;\\n    ListNode* curr=head;\\n    ListNode* right=curr->next;\\n    while(curr!=nullptr){\\nright=curr->next;\\ncurr->next=prev;\\nprev=curr;\\ncurr=right;\\n    }\\n    return prev;\\n}\\nint cnt(ListNode* head){\\n    ListNode* temp=head;\\n    int i=0;\\n    while(temp!=nullptr){\\n        i++;\\n        temp=temp->next;\\n    }\\n    return i;\\n}\\nListNode* reverse(ListNode* head,int i){\\n    if(head==nullptr){\\n        return nullptr;\\n    }\\n\\n\\n    int count=cnt(head);\\n    //yecode last ke liye\\nif(count<i){\\n    if(count%2==0){\\nreturn reverselast(head);\\n    }\\n    else{\\n        return head;\\n    }\\n}\\n////////\\nif(i%2==0){\\nint j=0;\\nListNode* prev=NULL;\\nListNode* curr=head;\\nListNode* right=curr->next;\\nwhile(j<i){\\n    right=curr->next;\\n    curr->next=prev;\\n    prev=curr;\\n    curr=right;\\n    j++;\\n}\\nif(right!=nullptr){\\n    int x=i+1;\\n    ListNode* rightkaans=reverse(right,x);\\n    head->next=rightkaans;\\n}\\nreturn prev;}\\nelse{\\n    int k=0;\\n    ListNode* temp=head;\\n    ListNode* follow=head;\\n    while(k<i){\\n        follow=temp;\\ntemp=temp->next;\\nk++;\\n    }\\n    if(temp!=nullptr){\\n         ListNode* ans=reverse(temp,++i);\\n         follow->next=ans;\\n    }\\n    return head;\\n}\\nreturn nullptr;\\n}\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        int i=1;\\n        return reverse(head, i);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3439964,
                "title": "using-stack-and-loop-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        ListNode* reverse_head = head;\\n        ListNode* start_index = NULL;\\n        int counter = 1;\\n        while(head!=NULL){\\n            stack<int> st;\\n            for(int i =0; i < counter; i++){\\n                if(head == NULL) break;\\n                if(i==0) start_index = head;\\n                st.push(head->val); \\n                head = head->next;\\n            }\\n            if(st.size() % 2==0){\\n                head = start_index;\\n                while(!st.empty()){\\n                    head -> val = st.top();\\n                    st.pop();\\n                    head = head->next;\\n                }\\n            }\\n            counter++;\\n        }\\n        return reverse_head;\\n    }\\n};\\n```\\n\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        ListNode* reverse_head = head;\\n        ListNode* start_index = NULL;\\n        int flag = 0, counter = 1;\\n        while(head!=NULL){\\n            stack<int> st;\\n            for(int i =0; i < counter; i++){\\n                if(head == NULL) break;\\n                if(i==0) start_index = head;\\n                st.push(head->val); \\n                if(flag == 1){\\n                    if(i==counter-1) flag = 0;\\n                }\\n                else if(flag == 0){\\n                    if(i==counter-1) flag = 1;\\n                }\\n                head = head->next;\\n            }\\n            if(st.size() % 2==0){\\n                head = start_index;\\n                while(!st.empty()){\\n                    head -> val = st.top();\\n                    st.pop();\\n                    head = head->next;\\n                }\\n            }\\n            counter++;\\n        }\\n        return reverse_head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        ListNode* reverse_head = head;\\n        ListNode* start_index = NULL;\\n        int counter = 1;\\n        while(head!=NULL){\\n            stack<int> st;\\n            for(int i =0; i < counter; i++){\\n                if(head == NULL) break;\\n                if(i==0) start_index = head;\\n                st.push(head->val); \\n                head = head->next;\\n            }\\n            if(st.size() % 2==0){\\n                head = start_index;\\n                while(!st.empty()){\\n                    head -> val = st.top();\\n                    st.pop();\\n                    head = head->next;\\n                }\\n            }\\n            counter++;\\n        }\\n        return reverse_head;\\n    }\\n};\\n```\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        ListNode* reverse_head = head;\\n        ListNode* start_index = NULL;\\n        int flag = 0, counter = 1;\\n        while(head!=NULL){\\n            stack<int> st;\\n            for(int i =0; i < counter; i++){\\n                if(head == NULL) break;\\n                if(i==0) start_index = head;\\n                st.push(head->val); \\n                if(flag == 1){\\n                    if(i==counter-1) flag = 0;\\n                }\\n                else if(flag == 0){\\n                    if(i==counter-1) flag = 1;\\n                }\\n                head = head->next;\\n            }\\n            if(st.size() % 2==0){\\n                head = start_index;\\n                while(!st.empty()){\\n                    head -> val = st.top();\\n                    st.pop();\\n                    head = head->next;\\n                }\\n            }\\n            counter++;\\n        }\\n        return reverse_head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421371,
                "title": "c-three-pointer-solution-clean-code-explanation-o-1-memory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nTo solve this problem, I decided to use three pointers, `prev` for the node before the first one in the current group, `start` for the first node in the group and `end` for the node after the last one in the group, or `nullptr` if the last one has no `node->next`.\\n\\nWe can track the `end_pos` and the `start_pos` to decide if the size of the group is even or not by moving the pointers and getting their new position. If it is, reverse the nodes in the group and move to the next group.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nThe function `move_to` tries to move the pointer to the position `target` from `position` and writes the actual position after moving to `position`. If a `nullptr` is encountered, the position will be 1 above the last non-null node.\\n\\nOn every iteration, we move the pointer `prev` to position `target` which increases by `length` every time; `length` also increases by one. Pointers `start` and `end` will be calculated using `prev` for the next group since their vaules can be inaccurate after `reverse`.\\n\\nThe function `reverse` reverses the range `(start, end)` and returns the pointer to the new start of the range. On each iteration, copy the next node `node->next` to a temp variable and set `node->next` to `prev`. Initialize `prev` with `end` so that the list stays connected and set it to the current node at the end of the loop.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    ListNode* move_to(ListNode* node, int &position, int target) {\\n        for (; position < target; ++position) {\\n            if (node == nullptr) {\\n                return node;\\n            }\\n            node = node->next;\\n        }\\n        return node;\\n    }\\n    \\n    ListNode* reverse(ListNode *start, ListNode *end, int size) {\\n        ListNode *prev = end;\\n        ListNode *node = start;\\n        for (int i = 0; i < size; ++i) {\\n            ListNode *temp = node->next;\\n            node->next = prev;\\n            prev = node;\\n            node = temp;\\n        }\\n        return prev;\\n    }\\n\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        auto prev = head;\\n        auto start = head;\\n        auto end = head;\\n     \\n        int prev_pos = 0;\\n        int start_pos = 0;\\n        int end_pos = 1;   \\n\\n        for (int length = 2, target = 0; start != nullptr; target += length, length++) {\\n\\n            if ((end_pos - start_pos) % 2 == 0) {\\n                prev->next = reverse(start, end, end_pos - start_pos);\\n            }\\n            \\n            int position = prev_pos;\\n            prev = move_to(prev, position, target);\\n            prev_pos = position;\\n\\n            start = move_to(prev, position, position + 1);\\n            start_pos = position;\\n\\n            end = move_to(start, position, position + length);\\n            end_pos = position;\\n        }\\n        \\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    ListNode* move_to(ListNode* node, int &position, int target) {\\n        for (; position < target; ++position) {\\n            if (node == nullptr) {\\n                return node;\\n            }\\n            node = node->next;\\n        }\\n        return node;\\n    }\\n    \\n    ListNode* reverse(ListNode *start, ListNode *end, int size) {\\n        ListNode *prev = end;\\n        ListNode *node = start;\\n        for (int i = 0; i < size; ++i) {\\n            ListNode *temp = node->next;\\n            node->next = prev;\\n            prev = node;\\n            node = temp;\\n        }\\n        return prev;\\n    }\\n\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        auto prev = head;\\n        auto start = head;\\n        auto end = head;\\n     \\n        int prev_pos = 0;\\n        int start_pos = 0;\\n        int end_pos = 1;   \\n\\n        for (int length = 2, target = 0; start != nullptr; target += length, length++) {\\n\\n            if ((end_pos - start_pos) % 2 == 0) {\\n                prev->next = reverse(start, end, end_pos - start_pos);\\n            }\\n            \\n            int position = prev_pos;\\n            prev = move_to(prev, position, target);\\n            prev_pos = position;\\n\\n            start = move_to(prev, position, position + 1);\\n            start_pos = position;\\n\\n            end = move_to(start, position, position + length);\\n            end_pos = position;\\n        }\\n        \\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3412965,
                "title": "really-a-very-weird-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n\\n        vector<vector<ListNode*>>v;\\n        \\n        int c = 1;\\n        ListNode* t = head;\\n        vector<ListNode*>a;\\n        int grp = 1;\\n\\n        while(t){\\n            a.push_back(t);\\n            t = t->next;\\n\\n            if(a.size()==grp){\\n\\n                a[a.size()-1]->next = NULL;\\n                v.push_back(a);\\n                a.clear();\\n                grp++;\\n\\n            }\\n\\n        }\\n\\n        if(a.size()>0)v.push_back(a);\\n        vector<ListNode*>temp;\\n\\n        for(auto i : v){\\n\\n            vector<ListNode*>k = i;\\n\\n            if(k.size()%2==0){\\n                reverse(k.begin(),k.end());\\n            \\n            }\\n\\n            for(auto j : k)temp.push_back(j);\\n        }\\n        int i = 1;\\n        while(i<temp.size()){\\n\\n            temp[i-1]->next = temp[i];\\n            i++;\\n        }\\n        temp[temp.size()-1]->next = NULL;\\n        return temp[0];\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n\\n        vector<vector<ListNode*>>v;\\n        \\n        int c = 1;\\n        ListNode* t = head;\\n        vector<ListNode*>a;\\n        int grp = 1;\\n\\n        while(t){\\n            a.push_back(t);\\n            t = t->next;\\n\\n            if(a.size()==grp){\\n\\n                a[a.size()-1]->next = NULL;\\n                v.push_back(a);\\n                a.clear();\\n                grp++;\\n\\n            }\\n\\n        }\\n\\n        if(a.size()>0)v.push_back(a);\\n        vector<ListNode*>temp;\\n\\n        for(auto i : v){\\n\\n            vector<ListNode*>k = i;\\n\\n            if(k.size()%2==0){\\n                reverse(k.begin(),k.end());\\n            \\n            }\\n\\n            for(auto j : k)temp.push_back(j);\\n        }\\n        int i = 1;\\n        while(i<temp.size()){\\n\\n            temp[i-1]->next = temp[i];\\n            i++;\\n        }\\n        temp[temp.size()-1]->next = NULL;\\n        return temp[0];\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3406451,
                "title": "beats-90-full-explained-cpp-code-pls-upvote",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nthis is a very good q consist of reversing linked list and in a group of k\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->The first while loop is used to count the total number of nodes in the linked list. This is done by iterating through each node of the list and incrementing the cnt variable for each node.\\n\\nThe next while loop is used to process the linked list in groups of even length. The cnt variable is used to keep track of the remaining nodes to be processed. The size variable is used to keep track of the size of the current group, which is initially set to 1.\\n\\nInside this while loop, if cnt is less than size, then size is set to cnt. This is because if the remaining number of nodes is less than the size of the current group, then the group size should be reduced accordingly.\\n\\nNext, if the group size t is even, then the group is reversed. A new pointer prev is set to the current node, and another pointer curr is set to the next node. Then the prev and curr pointers are swapped, and the next pointer is updated to point to the next node after curr. This process is repeated t-1 times to reverse the even-sized group. Finally, the tail of the previous group is updated to point to the head of the reversed group, and the tail of the reversed group is updated to point to the next node after the reversed group\\'s tail. The temp pointer is then updated to point to the next node after the reversed group\\'s tail.\\n\\nIf the group size t is odd, then the current node is skipped, and the tail pointer is set to the current node. Then the tail pointer is updated by iterating t-1 times to point to the node before the next group\\'s head. The temp pointer is then updated to point to the next node after the current group\\'s tail.\\n\\nFinally, the size variable is incremented, and the while loop continues until all nodes in the linked list are processed.\\n\\nThe function then returns the new head of the modified linked list.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        ios_base::sync_with_stdio(false);\\n        ListNode* temp=head;\\n        int cnt=0;\\n        while(temp){\\n            cnt++;\\n            temp=temp->next;\\n        }\\n              temp=head;\\n              ListNode* tail=head;\\n        int size=1;\\n        while(cnt){\\n            if(cnt<size) size=cnt;\\n            cnt-=size;\\n                int t=size;\\n                if(t%2==0){\\n                    t--;\\n                  ListNode* prev=temp;\\n                  ListNode* curr=temp->next;\\n                  prev->next=NULL;\\n                  ListNode* next=curr;\\n                  while(t--){\\n                      next=curr->next;\\n                        curr->next=prev;\\n                         prev=curr;\\n                         curr=next;\\n                  }\\n                  tail->next=prev;\\n                  tail=temp;\\n                  temp->next=curr;\\n                  temp=curr;\\n                }\\n                else{\\n                    tail=temp;\\n                    temp=temp->next;\\n                    t--;\\n                    while(t--){\\n                        tail=temp;\\n                        temp=temp->next;\\n                    }\\n                }\\n                  size++;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        ios_base::sync_with_stdio(false);\\n        ListNode* temp=head;\\n        int cnt=0;\\n        while(temp){\\n            cnt++;\\n            temp=temp->next;\\n        }\\n              temp=head;\\n              ListNode* tail=head;\\n        int size=1;\\n        while(cnt){\\n            if(cnt<size) size=cnt;\\n            cnt-=size;\\n                int t=size;\\n                if(t%2==0){\\n                    t--;\\n                  ListNode* prev=temp;\\n                  ListNode* curr=temp->next;\\n                  prev->next=NULL;\\n                  ListNode* next=curr;\\n                  while(t--){\\n                      next=curr->next;\\n                        curr->next=prev;\\n                         prev=curr;\\n                         curr=next;\\n                  }\\n                  tail->next=prev;\\n                  tail=temp;\\n                  temp->next=curr;\\n                  temp=curr;\\n                }\\n                else{\\n                    tail=temp;\\n                    temp=temp->next;\\n                    t--;\\n                    while(t--){\\n                        tail=temp;\\n                        temp=temp->next;\\n                    }\\n                }\\n                  size++;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3401470,
                "title": "c-vector",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        vector<vector<int>> v;\\n        ListNode* h = head;\\n        int k=0;\\n        while(h!=NULL)\\n        {\\n            k++;\\n            int count=0;\\n            ListNode* h1 = h;\\n            vector<int> v1;\\n            while(h1!=NULL)\\n            {\\n                \\n                count++;\\n                if(count==k)\\n                    break;\\n                else\\n                    v1.push_back(h1->val);\\n                h1=h1->next;\\n            }\\n            v.push_back(v1);\\n            h=h1;\\n\\n        }\\n        for(int i=0;i<v.size();i++)\\n        {\\n            if(v[i].size()%2==0)\\n            {\\n                reverse(v[i].begin(),v[i].end());\\n            }\\n        }\\n        ListNode* h1 = new ListNode(0);\\n        ListNode* ans = h1;\\n        for(int i=0;i<v.size();i++)\\n        {\\n            for(int j=0;j<v[i].size();j++)\\n            {\\n                h1->next=new ListNode(v[i][j]);\\n                h1=h1->next;\\n            }\\n        }\\n        return ans->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        vector<vector<int>> v;\\n        ListNode* h = head;\\n        int k=0;\\n        while(h!=NULL)\\n        {\\n            k++;\\n            int count=0;\\n            ListNode* h1 = h;\\n            vector<int> v1;\\n            while(h1!=NULL)\\n            {\\n                \\n                count++;\\n                if(count==k)\\n                    break;\\n                else\\n                    v1.push_back(h1->val);\\n                h1=h1->next;\\n            }\\n            v.push_back(v1);\\n            h=h1;\\n\\n        }\\n        for(int i=0;i<v.size();i++)\\n        {\\n            if(v[i].size()%2==0)\\n            {\\n                reverse(v[i].begin(),v[i].end());\\n            }\\n        }\\n        ListNode* h1 = new ListNode(0);\\n        ListNode* ans = h1;\\n        for(int i=0;i<v.size();i++)\\n        {\\n            for(int j=0;j<v[i].size();j++)\\n            {\\n                h1->next=new ListNode(v[i][j]);\\n                h1=h1->next;\\n            }\\n        }\\n        return ans->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3401055,
                "title": "java-easy-solution",
                "content": "# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    ListNode curr = null;\\n\\n    public ListNode reverse(ListNode head,int m){\\n        ListNode c = head;\\n        ListNode next = head;\\n        ListNode p = null;\\n        ListNode n = null;\\n        while(m > 0 && c!=null){\\n            n = c.next;\\n            c.next = p;\\n            p = c;\\n            c = n;\\n            m--;\\n        }\\n        curr = c;\\n        return p;\\n    }\\n    public int length(ListNode head){\\n        int count = 0;\\n        while(head != null){\\n            head = head.next;\\n            count++;\\n        }\\n        return count;\\n    }\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        ListNode res = head;\\n        ListNode run = head;\\n        int len = length(head);\\n        int n = 0;\\n        int i = 1;\\n        while(n < len){\\n            int min = Math.min(i,len - n);\\n            if(min%2 == 1){\\n                for(int j = 0;j<min && head != null;j++){\\n                    run = head;\\n                    head = head.next;\\n                }\\n            }\\n            else{\\n                ListNode temp = reverse(head,min);\\n                run.next = temp;\\n                head.next = curr;\\n                run = head;\\n                head = curr;\\n            }\\n            i++;\\n            n += min;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    ListNode curr = null;\\n\\n    public ListNode reverse(ListNode head,int m){\\n        ListNode c = head;\\n        ListNode next = head;\\n        ListNode p = null;\\n        ListNode n = null;\\n        while(m > 0 && c!=null){\\n            n = c.next;\\n            c.next = p;\\n            p = c;\\n            c = n;\\n            m--;\\n        }\\n        curr = c;\\n        return p;\\n    }\\n    public int length(ListNode head){\\n        int count = 0;\\n        while(head != null){\\n            head = head.next;\\n            count++;\\n        }\\n        return count;\\n    }\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        ListNode res = head;\\n        ListNode run = head;\\n        int len = length(head);\\n        int n = 0;\\n        int i = 1;\\n        while(n < len){\\n            int min = Math.min(i,len - n);\\n            if(min%2 == 1){\\n                for(int j = 0;j<min && head != null;j++){\\n                    run = head;\\n                    head = head.next;\\n                }\\n            }\\n            else{\\n                ListNode temp = reverse(head,min);\\n                run.next = temp;\\n                head.next = curr;\\n                run = head;\\n                head = curr;\\n            }\\n            i++;\\n            n += min;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3386218,
                "title": "python-simple-solution",
                "content": "```\\ndef reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\tlst, cur, node, n, k = [], [], head, head, 1\\n\\twhile(node):\\n\\t\\tcur.append(node.val)\\n\\t\\tnode = node.next\\n\\t\\tif len(cur)==k or not node:\\n\\t\\t\\tif len(cur)%2==0:\\n\\t\\t\\t\\tcur = cur[::-1]\\n\\t\\t\\tlst.extend(cur)\\n\\t\\t\\tcur, k = [], k+1\\n\\tfor i in range(len(lst)):\\n\\t\\tn.val = lst[i]\\n\\t\\tn = n.next\\n\\treturn head\\n```",
                "solutionTags": [],
                "code": "```\\ndef reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\tlst, cur, node, n, k = [], [], head, head, 1\\n\\twhile(node):\\n\\t\\tcur.append(node.val)\\n\\t\\tnode = node.next\\n\\t\\tif len(cur)==k or not node:\\n\\t\\t\\tif len(cur)%2==0:\\n\\t\\t\\t\\tcur = cur[::-1]\\n\\t\\t\\tlst.extend(cur)\\n\\t\\t\\tcur, k = [], k+1\\n\\tfor i in range(len(lst)):\\n\\t\\tn.val = lst[i]\\n\\t\\tn = n.next\\n\\treturn head\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3370953,
                "title": "o-n-time-o-1-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        current_node = head\\n        current_tail = None\\n        group_size = 1\\n        while(current_node):\\n            group_start, group_tail, next_node = Solution.consume_group(group_size, current_node)\\n            if current_tail:\\n                current_tail.next = group_start\\n                current_tail = group_tail\\n            else:\\n                current_tail = group_tail\\n            \\n            current_node = next_node\\n            group_size += 1\\n\\n        return head\\n\\n    @staticmethod\\n    def consume_group(group_size, head):\\n        \"\"\"\\n\\n        :param group_size: will try to consume that many nodes\\n        :param head: the first_node in the group\\n        :return: the start of the group, the tail of the group, next_node\\n        \"\"\"\\n        if group_size == 0 or not head:\\n            return None, None, None\\n\\n        count = 0\\n\\n        current = head\\n\\n        if group_size % 2 == 0:\\n            group_tail = None\\n            group = None\\n            while current and count < group_size :\\n                next_node = current.next\\n                current.next = group\\n                if not group:\\n                    group_tail = current\\n\\n                group = current\\n                current = next_node\\n                count += 1\\n\\n            if count < group_size and count % 2 == 1:\\n                return Solution.reverse_linked_list(group)\\n            else:\\n                return group, group_tail, current\\n\\n        else:\\n            prev = None\\n            group = head\\n            while current and count < group_size:\\n                if prev:\\n                    prev.next = current\\n\\n                prev = current\\n\\n                current = current.next\\n                count += 1\\n\\n            if count < group_size and count % 2 == 0:\\n                # reverse linked list\\n                return Solution.reverse_linked_list(group)\\n            else:\\n                return group, prev, current\\n\\n\\n\\n    @staticmethod\\n    def reverse_linked_list(head):\\n        result = None\\n        tail = None\\n        while(head):\\n            next_node = head.next\\n            head.next = result\\n            if not result:\\n                tail = head\\n\\n            result = head\\n            head = next_node\\n\\n        return result, tail, head\\n\\n\\n\\n\\n\\n\\n            \\n            \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        current_node = head\\n        current_tail = None\\n        group_size = 1\\n        while(current_node):\\n            group_start, group_tail, next_node = Solution.consume_group(group_size, current_node)\\n            if current_tail:\\n                current_tail.next = group_start\\n                current_tail = group_tail\\n            else:\\n                current_tail = group_tail\\n            \\n            current_node = next_node\\n            group_size += 1\\n\\n        return head\\n\\n    @staticmethod\\n    def consume_group(group_size, head):\\n        \"\"\"\\n\\n        :param group_size: will try to consume that many nodes\\n        :param head: the first_node in the group\\n        :return: the start of the group, the tail of the group, next_node\\n        \"\"\"\\n        if group_size == 0 or not head:\\n            return None, None, None\\n\\n        count = 0\\n\\n        current = head\\n\\n        if group_size % 2 == 0:\\n            group_tail = None\\n            group = None\\n            while current and count < group_size :\\n                next_node = current.next\\n                current.next = group\\n                if not group:\\n                    group_tail = current\\n\\n                group = current\\n                current = next_node\\n                count += 1\\n\\n            if count < group_size and count % 2 == 1:\\n                return Solution.reverse_linked_list(group)\\n            else:\\n                return group, group_tail, current\\n\\n        else:\\n            prev = None\\n            group = head\\n            while current and count < group_size:\\n                if prev:\\n                    prev.next = current\\n\\n                prev = current\\n\\n                current = current.next\\n                count += 1\\n\\n            if count < group_size and count % 2 == 0:\\n                # reverse linked list\\n                return Solution.reverse_linked_list(group)\\n            else:\\n                return group, prev, current\\n\\n\\n\\n    @staticmethod\\n    def reverse_linked_list(head):\\n        result = None\\n        tail = None\\n        while(head):\\n            next_node = head.next\\n            head.next = result\\n            if not result:\\n                tail = head\\n\\n            result = head\\n            head = next_node\\n\\n        return result, tail, head\\n\\n\\n\\n\\n\\n\\n            \\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3358401,
                "title": "simplest-c-solution",
                "content": "# Intuition-\\nfirst reverse k node than call for reversing k+1 node so on.\\n\\n# Approach\\nkeep track of last group ..if length even than only reverse\\n\\n# Complexity\\n- Time complexity:\\n time complexity  O(n) only once traversing in linkedlist-->\\n\\n- Space complexity:\\n!--  space complexity O(\\u221An) --\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n ListNode* reverseK(ListNode* head,int k) {\\n     if(head==NULL or head->next==NULL )return head;\\n     ListNode *temp=head;\\n         int i=1;\\n         while(temp!=NULL and i<k){temp=temp->next;i++; }\\n         if(temp==NULL)\\n         {   i--;\\n             if(i%2==0)\\n             {\\n                 ListNode *curr=head,*next=NULL,*pre=NULL;\\n                 i=0;\\n                while(curr!=NULL)\\n                {\\n                  next=curr->next;\\n                   curr->next=pre;\\n                    pre=curr;curr=next;i++;\\n                }\\n                return pre;\\n             }\\n             return head;\\n         }\\n        // cout<<endl;\\n     if(k%2)\\n     {\\n          if(temp->next!=NULL) temp->next=reverseK(temp->next,k+1);\\n           return head;\\n     }\\n     ListNode *curr=head,*next=NULL,*pre=NULL;\\n      i=0;\\n     while(curr!=NULL and i<k)\\n     {\\n        next=curr->next;\\n        curr->next=pre;\\n        pre=curr;curr=next;i++;\\n     }\\n     if(curr)head->next=reverseK(next,k+1);\\n     return pre;\\n    }\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        return reverseK(head,1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n ListNode* reverseK(ListNode* head,int k) {\\n     if(head==NULL or head->next==NULL )return head;\\n     ListNode *temp=head;\\n         int i=1;\\n         while(temp!=NULL and i<k){temp=temp->next;i++; }\\n         if(temp==NULL)\\n         {   i--;\\n             if(i%2==0)\\n             {\\n                 ListNode *curr=head,*next=NULL,*pre=NULL;\\n                 i=0;\\n                while(curr!=NULL)\\n                {\\n                  next=curr->next;\\n                   curr->next=pre;\\n                    pre=curr;curr=next;i++;\\n                }\\n                return pre;\\n             }\\n             return head;\\n         }\\n        // cout<<endl;\\n     if(k%2)\\n     {\\n          if(temp->next!=NULL) temp->next=reverseK(temp->next,k+1);\\n           return head;\\n     }\\n     ListNode *curr=head,*next=NULL,*pre=NULL;\\n      i=0;\\n     while(curr!=NULL and i<k)\\n     {\\n        next=curr->next;\\n        curr->next=pre;\\n        pre=curr;curr=next;i++;\\n     }\\n     if(curr)head->next=reverseK(next,k+1);\\n     return pre;\\n    }\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        return reverseK(head,1);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3355200,
                "title": "c-solution",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    ListNode* reverseList(ListNode* head) \\n    {\\n        ListNode* pre=NULL;\\n        ListNode* cur=head;\\n        while(cur!=NULL)\\n        {\\n            ListNode* nex=cur->next;\\n            cur->next=pre;\\n            pre=cur;\\n            cur=nex;\\n        }\\n        head=pre;\\n        return head;\\n    }\\n    ListNode* reverseEvenLengthGroups(ListNode* head) \\n    {\\n        int k=1;\\n        ListNode* temp=head;\\n        ListNode* prev=NULL;\\n        while(temp)\\n        {\\n            if(k%2==0)\\n            {\\n                ListNode* n=temp; // previous head\\n                ListNode* t=n;    //\\n                int cnt=0, f=0;\\n                for(int x=1; x<k; x++)\\n                {\\n                    t=t->next;\\n                    cnt++;\\n                    if(!t && cnt%2) return head;\\n                    if(!t)\\n                    {\\n                        f=1;break;\\n                    }\\n                }\\n                if(f)\\n                {\\n                    prev->next=NULL;\\n                    ListNode* l=reverseList(n);\\n                    prev->next=l;\\n                    return head;\\n                }\\n                ListNode* nex=t->next;\\n                t->next=NULL;\\n                prev->next=NULL;\\n                ListNode* l=reverseList(n);\\n                n->next=nex;\\n                temp=n;\\n                prev->next=l;\\n            }\\n            else\\n            {\\n                int cnt=1, f=0;\\n                ListNode* n=temp;\\n                for(int x=1; x<k; x++)\\n                {\\n                    temp=temp->next;\\n                    cnt++;\\n                    if(!temp)\\n                    {\\n                        f=1;\\n                        break;\\n                    }\\n                }\\n                if(f && cnt%2)\\n                {\\n                    prev->next=NULL;\\n                    ListNode* l=reverseList(n);\\n                    prev->next=l;\\n                }\\n            }\\n            k++;\\n            prev=temp;\\n            if(temp)temp=temp->next;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    ListNode* reverseList(ListNode* head) \\n    {\\n        ListNode* pre=NULL;\\n        ListNode* cur=head;\\n        while(cur!=NULL)\\n        {\\n            ListNode* nex=cur->next;\\n            cur->next=pre;\\n            pre=cur;\\n            cur=nex;\\n        }\\n        head=pre;\\n        return head;\\n    }\\n    ListNode* reverseEvenLengthGroups(ListNode* head) \\n    {\\n        int k=1;\\n        ListNode* temp=head;\\n        ListNode* prev=NULL;\\n        while(temp)\\n        {\\n            if(k%2==0)\\n            {\\n                ListNode* n=temp; // previous head\\n                ListNode* t=n;    //\\n                int cnt=0, f=0;\\n                for(int x=1; x<k; x++)\\n                {\\n                    t=t->next;\\n                    cnt++;\\n                    if(!t && cnt%2) return head;\\n                    if(!t)\\n                    {\\n                        f=1;break;\\n                    }\\n                }\\n                if(f)\\n                {\\n                    prev->next=NULL;\\n                    ListNode* l=reverseList(n);\\n                    prev->next=l;\\n                    return head;\\n                }\\n                ListNode* nex=t->next;\\n                t->next=NULL;\\n                prev->next=NULL;\\n                ListNode* l=reverseList(n);\\n                n->next=nex;\\n                temp=n;\\n                prev->next=l;\\n            }\\n            else\\n            {\\n                int cnt=1, f=0;\\n                ListNode* n=temp;\\n                for(int x=1; x<k; x++)\\n                {\\n                    temp=temp->next;\\n                    cnt++;\\n                    if(!temp)\\n                    {\\n                        f=1;\\n                        break;\\n                    }\\n                }\\n                if(f && cnt%2)\\n                {\\n                    prev->next=NULL;\\n                    ListNode* l=reverseList(n);\\n                    prev->next=l;\\n                }\\n            }\\n            k++;\\n            prev=temp;\\n            if(temp)temp=temp->next;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3337342,
                "title": "c-beats-99-in-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCreate a position integer and a pointer, then keep on reversing the substrings when needed.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void reverseList(struct ListNode*& first, struct ListNode*& last) {\\n    if (first == nullptr || last == nullptr || first == last) {\\n        return;\\n    }\\n\\n    struct ListNode* prev = nullptr;\\n    struct ListNode* curr = first;\\n    struct ListNode* next = nullptr;\\n\\n    while (curr != last) {\\n        next = curr->next;\\n        curr->next = prev;\\n        prev = curr;\\n        curr = next;\\n    }\\n\\n    curr->next = prev;\\n    }\\n\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        int pos=0, len=1; //len is length to achieve\\n        struct ListNode* first, *last, *curr;\\n        curr = head;\\n        while(curr){\\n            pos++;\\n            if(pos==int(len*(len+1)/2)){\\n                if(len%2==0){\\n                    last=curr;\\n                    curr = curr->next;\\n                    \\n                    // cout<<\"the value of last is \"<<last->val<<endl;\\n            \\n                    // reverse starts\\n                    reverseList(first->next, last);\\n                    first->next->next = curr;\\n                    first->next = last;\\n                    // reverse ends\\n                    for(int i=0;i<len;i++) first = first->next;\\n                    // cout<<\"the value of len is \"<<len<<endl;\\n                  \\n                    len++;\\n                    }\\n                else{ len++; if(len%2==0) first=curr; curr = curr->next; }\\n            }\\n            else{ curr=curr->next;}            \\n        }\\n\\n        // the loop has ended, last values are remaining\\n        cout<<\"the value of first is \"<<first->val<<endl;\\n        // if(len%2!=0)\\n        // first = first->next;\\n        if(first)\\n        cout<<\"the value of first is \"<<first->val<<endl;\\n\\n        \\n        len = pos-int(len*(len-1)/2);\\n        if(len>0 && len%2==0){\\n            last = first;\\n            for(int i=0;i<len;i++) last = last->next;\\n            // cout<<\"the value of last is \"<<last->val<<endl;\\n\\n            // reverse starts\\n            reverseList(first->next, last);\\n            first->next->next = curr;\\n            first->next = last;\\n            // reverse ends\\n        }\\n\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void reverseList(struct ListNode*& first, struct ListNode*& last) {\\n    if (first == nullptr || last == nullptr || first == last) {\\n        return;\\n    }\\n\\n    struct ListNode* prev = nullptr;\\n    struct ListNode* curr = first;\\n    struct ListNode* next = nullptr;\\n\\n    while (curr != last) {\\n        next = curr->next;\\n        curr->next = prev;\\n        prev = curr;\\n        curr = next;\\n    }\\n\\n    curr->next = prev;\\n    }\\n\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        int pos=0, len=1; //len is length to achieve\\n        struct ListNode* first, *last, *curr;\\n        curr = head;\\n        while(curr){\\n            pos++;\\n            if(pos==int(len*(len+1)/2)){\\n                if(len%2==0){\\n                    last=curr;\\n                    curr = curr->next;\\n                    \\n                    // cout<<\"the value of last is \"<<last->val<<endl;\\n            \\n                    // reverse starts\\n                    reverseList(first->next, last);\\n                    first->next->next = curr;\\n                    first->next = last;\\n                    // reverse ends\\n                    for(int i=0;i<len;i++) first = first->next;\\n                    // cout<<\"the value of len is \"<<len<<endl;\\n                  \\n                    len++;\\n                    }\\n                else{ len++; if(len%2==0) first=curr; curr = curr->next; }\\n            }\\n            else{ curr=curr->next;}            \\n        }\\n\\n        // the loop has ended, last values are remaining\\n        cout<<\"the value of first is \"<<first->val<<endl;\\n        // if(len%2!=0)\\n        // first = first->next;\\n        if(first)\\n        cout<<\"the value of first is \"<<first->val<<endl;\\n\\n        \\n        len = pos-int(len*(len-1)/2);\\n        if(len>0 && len%2==0){\\n            last = first;\\n            for(int i=0;i<len;i++) last = last->next;\\n            // cout<<\"the value of last is \"<<last->val<<endl;\\n\\n            // reverse starts\\n            reverseList(first->next, last);\\n            first->next->next = curr;\\n            first->next = last;\\n            // reverse ends\\n        }\\n\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3337219,
                "title": "java-solution-with-map-and-deque",
                "content": "```\\n public static ListNode reverseEvenLengthGroups(ListNode head) {\\n        ListNode temp = head;\\n        Map<Integer, Deque<ListNode>> map = new LinkedHashMap<>();\\n        int counter=1;\\n        while (temp!=null){\\n            for (int i = 0; i < counter; i++) {\\n                if(temp==null)\\n                    break;\\n                map.computeIfAbsent(counter,e->new ArrayDeque<>()).addLast(temp);\\n                temp=temp.next;\\n            }\\n            counter++;\\n        }\\n        temp=null;\\n        for (int i = 1; i <counter;  i++) {\\n            if(map.get(i).size()%2!=0 ){\\n                if(temp!=null)\\n                    temp.next=map.get(i).getFirst();\\n                temp= map.get(i).getLast();\\n            }\\n            else if(map.get(i).size()%2==0){\\n                int indexCounter=map.get(i).size();\\n                for (int j = 0; j <indexCounter; j++) {\\n                    temp.next=map.get(i).getLast();\\n                    temp=map.get(i).removeLast();\\n                }\\n            }\\n        }\\n        temp.next=null;\\n        return head;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Queue"
                ],
                "code": "```\\n public static ListNode reverseEvenLengthGroups(ListNode head) {\\n        ListNode temp = head;\\n        Map<Integer, Deque<ListNode>> map = new LinkedHashMap<>();\\n        int counter=1;\\n        while (temp!=null){\\n            for (int i = 0; i < counter; i++) {\\n                if(temp==null)\\n                    break;\\n                map.computeIfAbsent(counter,e->new ArrayDeque<>()).addLast(temp);\\n                temp=temp.next;\\n            }\\n            counter++;\\n        }\\n        temp=null;\\n        for (int i = 1; i <counter;  i++) {\\n            if(map.get(i).size()%2!=0 ){\\n                if(temp!=null)\\n                    temp.next=map.get(i).getFirst();\\n                temp= map.get(i).getLast();\\n            }\\n            else if(map.get(i).size()%2==0){\\n                int indexCounter=map.get(i).size();\\n                for (int j = 0; j <indexCounter; j++) {\\n                    temp.next=map.get(i).getLast();\\n                    temp=map.get(i).removeLast();\\n                }\\n            }\\n        }\\n        temp.next=null;\\n        return head;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3331872,
                "title": "simple-and-fast-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n   Leetcode K-Reversal for better understanding\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverse(ListNode *s,ListNode *e){\\n        ListNode *prev=NULL,*curr=s,*nex=s->next;\\n        while(prev!=e){\\n            curr->next=prev;\\n            prev=curr;\\n            curr=nex;\\n            if(nex){\\n                nex=nex->next;\\n            }\\n        }\\n        return prev;\\n    }\\n \\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        if(head==NULL || head->next==NULL){\\n            return head;\\n        }\\n        ListNode *dummy=new ListNode(-1);\\n        dummy->next=head;\\n        ListNode *prev=dummy;\\n        for(int i=1;head!=NULL && 1e5;i++){\\n            ListNode *temp=head;\\n            ListNode *nexthead;\\n            int j=1;\\n            while(j<i && temp && temp->next){\\n                temp=temp->next;\\n                j++;\\n            }\\n            nexthead=temp->next;\\n            if((j%2)==0){\\n                 reverse(head,temp);\\n                 prev->next=temp;\\n                 prev=head;\\n                 head->next=nexthead;\\n                 head=nexthead;\\n            }\\n            else{\\n                prev=temp;\\n                head=nexthead;\\n            }\\n        }\\n       return dummy->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Iterator"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverse(ListNode *s,ListNode *e){\\n        ListNode *prev=NULL,*curr=s,*nex=s->next;\\n        while(prev!=e){\\n            curr->next=prev;\\n            prev=curr;\\n            curr=nex;\\n            if(nex){\\n                nex=nex->next;\\n            }\\n        }\\n        return prev;\\n    }\\n \\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        if(head==NULL || head->next==NULL){\\n            return head;\\n        }\\n        ListNode *dummy=new ListNode(-1);\\n        dummy->next=head;\\n        ListNode *prev=dummy;\\n        for(int i=1;head!=NULL && 1e5;i++){\\n            ListNode *temp=head;\\n            ListNode *nexthead;\\n            int j=1;\\n            while(j<i && temp && temp->next){\\n                temp=temp->next;\\n                j++;\\n            }\\n            nexthead=temp->next;\\n            if((j%2)==0){\\n                 reverse(head,temp);\\n                 prev->next=temp;\\n                 prev=head;\\n                 head->next=nexthead;\\n                 head=nexthead;\\n            }\\n            else{\\n                prev=temp;\\n                head=nexthead;\\n            }\\n        }\\n       return dummy->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3324768,
                "title": "simple-using-recursion-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    ListNode* reverse(ListNode* start,ListNode* end){\\n        ListNode* prev=NULL;\\n        //ListNode* curr=head;\\n        ListNode* next=start;\\n        while(start!=end){\\n            next=start->next;\\n            start->next=prev;\\n            prev=start;\\n            start=next;\\n        }\\n        return prev;\\n    }\\n    ListNode* reverseeven(ListNode* head,int len){\\n        if(head==NULL || head->next==NULL){\\n            return head;\\n        }\\n        int count=0;\\n        ListNode* start=head;\\n        ListNode* end=head;\\n        while(start!=NULL && count<len){\\n            end=start;\\n            start=start->next;\\n            count++;\\n        }\\n        if(count%2==0){\\n            ListNode* temp=reverse(head,start);\\n            head->next=reverseeven(start,len+1);\\n            return temp;\\n        }\\n        end->next=reverseeven(start,len+1);\\n        return head;\\n    }\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        return reverseeven(head,1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    ListNode* reverse(ListNode* start,ListNode* end){\\n        ListNode* prev=NULL;\\n        //ListNode* curr=head;\\n        ListNode* next=start;\\n        while(start!=end){\\n            next=start->next;\\n            start->next=prev;\\n            prev=start;\\n            start=next;\\n        }\\n        return prev;\\n    }\\n    ListNode* reverseeven(ListNode* head,int len){\\n        if(head==NULL || head->next==NULL){\\n            return head;\\n        }\\n        int count=0;\\n        ListNode* start=head;\\n        ListNode* end=head;\\n        while(start!=NULL && count<len){\\n            end=start;\\n            start=start->next;\\n            count++;\\n        }\\n        if(count%2==0){\\n            ListNode* temp=reverse(head,start);\\n            head->next=reverseeven(start,len+1);\\n            return temp;\\n        }\\n        end->next=reverseeven(start,len+1);\\n        return head;\\n    }\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        return reverseeven(head,1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3322065,
                "title": "swift-hashmap-approach",
                "content": "# Swift | HashMap\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    func reverseEvenLengthGroups(_ head: ListNode?) -> ListNode? {\\n        if head == nil || head!.next == nil {\\n            return head \\n        }\\n\\n        var dict = [Int: [ListNode?]]()\\n        var prev: ListNode? = nil\\n        var dummy = head\\n        var currentGroup = 1\\n        \\n        while dummy != nil {\\n            for _ in 1...currentGroup {\\n                prev = dummy\\n                dict[currentGroup, default: []].append(dummy)\\n                dummy = dummy?.next\\n                if dummy == nil { break }\\n            }\\n\\n            prev?.next = nil\\n            var count = dict[currentGroup]!.count\\n\\n            if count.isMultiple(of: 2) {\\n                var head = reverseList(dict[currentGroup]!.first!)\\n                dict[currentGroup]!.swapAt(0, count-1)\\n                dict[currentGroup-1]?.last!!.next = head\\n            } else {\\n                dict[currentGroup-1]?.last!!.next = dict[currentGroup]!.first!\\n            }\\n\\n            currentGroup += 1\\n        }\\n       \\n        return head\\n    }\\n\\n    func reverseList(_ head: ListNode?) -> ListNode? {\\n        var dummy = head\\n        var prev: ListNode? = nil\\n\\n        while dummy != nil {\\n            var nextNode = dummy?.next\\n            dummy?.next = prev\\n            prev = dummy\\n            dummy = nextNode\\n        }\\n        return prev\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func reverseEvenLengthGroups(_ head: ListNode?) -> ListNode? {\\n        if head == nil || head!.next == nil {\\n            return head \\n        }\\n\\n        var dict = [Int: [ListNode?]]()\\n        var prev: ListNode? = nil\\n        var dummy = head\\n        var currentGroup = 1\\n        \\n        while dummy != nil {\\n            for _ in 1...currentGroup {\\n                prev = dummy\\n                dict[currentGroup, default: []].append(dummy)\\n                dummy = dummy?.next\\n                if dummy == nil { break }\\n            }\\n\\n            prev?.next = nil\\n            var count = dict[currentGroup]!.count\\n\\n            if count.isMultiple(of: 2) {\\n                var head = reverseList(dict[currentGroup]!.first!)\\n                dict[currentGroup]!.swapAt(0, count-1)\\n                dict[currentGroup-1]?.last!!.next = head\\n            } else {\\n                dict[currentGroup-1]?.last!!.next = dict[currentGroup]!.first!\\n            }\\n\\n            currentGroup += 1\\n        }\\n       \\n        return head\\n    }\\n\\n    func reverseList(_ head: ListNode?) -> ListNode? {\\n        var dummy = head\\n        var prev: ListNode? = nil\\n\\n        while dummy != nil {\\n            var nextNode = dummy?.next\\n            dummy?.next = prev\\n            prev = dummy\\n            dummy = nextNode\\n        }\\n        return prev\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1769960,
                "content": [
                    {
                        "username": "calm27",
                        "content": "it is hard problem. \\ni spent probably 3 hours to find a solution, and hard prob i did before: reverse in k-group was way much easier. \\nso, it can\\'t be mid. "
                    },
                    {
                        "username": "stefan1096",
                        "content": "[@N1ghtstalker2022](/N1ghtstalker2022) \\nLeetcode should change easy medium hard to five stars for difficulty,This would be 4/5.Average mediums are 3/5."
                    },
                    {
                        "username": "N1ghtstalker2022",
                        "content": "Almost same. Cause me several hours..."
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "I will highly recommend using pen and paper to draw a diagram and some sequences of the examples to figure out the algorithm. Most of the linked list questions require visualization which is very easy to get using pen and paper."
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "This problem deserves a Hard category.\\nReason being, despite the list group is even, if the no. of nodes are odd, then there is no need to reverse the list."
                    },
                    {
                        "username": "2_NEMONE",
                        "content": "This should be hard for sure."
                    },
                    {
                        "username": "layyy",
                        "content": "try implementing \"reverse nodes in k-group\" before this "
                    },
                    {
                        "username": "bollineniyokesh",
                        "content": "Make this \"HARD\" ! "
                    },
                    {
                        "username": "anasansari_777",
                        "content": "Reverse Linked List II could be used here.\\n"
                    },
                    {
                        "username": "steven520142",
                        "content": "If you wanna do it in place, it is a hard problem.\\nOn the other hand, if you store the node in a list and rebuild linked list after doing the reverse, it is a medium problem."
                    },
                    {
                        "username": "anthonyche",
                        "content": "I know this one is a HARD problem just from reading the descriptions, it is ridiculous to put it in a medium category."
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "this must be hard sum"
                    }
                ]
            },
            {
                "id": 1960006,
                "content": [
                    {
                        "username": "calm27",
                        "content": "it is hard problem. \\ni spent probably 3 hours to find a solution, and hard prob i did before: reverse in k-group was way much easier. \\nso, it can\\'t be mid. "
                    },
                    {
                        "username": "stefan1096",
                        "content": "[@N1ghtstalker2022](/N1ghtstalker2022) \\nLeetcode should change easy medium hard to five stars for difficulty,This would be 4/5.Average mediums are 3/5."
                    },
                    {
                        "username": "N1ghtstalker2022",
                        "content": "Almost same. Cause me several hours..."
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "I will highly recommend using pen and paper to draw a diagram and some sequences of the examples to figure out the algorithm. Most of the linked list questions require visualization which is very easy to get using pen and paper."
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "This problem deserves a Hard category.\\nReason being, despite the list group is even, if the no. of nodes are odd, then there is no need to reverse the list."
                    },
                    {
                        "username": "2_NEMONE",
                        "content": "This should be hard for sure."
                    },
                    {
                        "username": "layyy",
                        "content": "try implementing \"reverse nodes in k-group\" before this "
                    },
                    {
                        "username": "bollineniyokesh",
                        "content": "Make this \"HARD\" ! "
                    },
                    {
                        "username": "anasansari_777",
                        "content": "Reverse Linked List II could be used here.\\n"
                    },
                    {
                        "username": "steven520142",
                        "content": "If you wanna do it in place, it is a hard problem.\\nOn the other hand, if you store the node in a list and rebuild linked list after doing the reverse, it is a medium problem."
                    },
                    {
                        "username": "anthonyche",
                        "content": "I know this one is a HARD problem just from reading the descriptions, it is ridiculous to put it in a medium category."
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "this must be hard sum"
                    }
                ]
            },
            {
                "id": 1794919,
                "content": [
                    {
                        "username": "calm27",
                        "content": "it is hard problem. \\ni spent probably 3 hours to find a solution, and hard prob i did before: reverse in k-group was way much easier. \\nso, it can\\'t be mid. "
                    },
                    {
                        "username": "stefan1096",
                        "content": "[@N1ghtstalker2022](/N1ghtstalker2022) \\nLeetcode should change easy medium hard to five stars for difficulty,This would be 4/5.Average mediums are 3/5."
                    },
                    {
                        "username": "N1ghtstalker2022",
                        "content": "Almost same. Cause me several hours..."
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "I will highly recommend using pen and paper to draw a diagram and some sequences of the examples to figure out the algorithm. Most of the linked list questions require visualization which is very easy to get using pen and paper."
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "This problem deserves a Hard category.\\nReason being, despite the list group is even, if the no. of nodes are odd, then there is no need to reverse the list."
                    },
                    {
                        "username": "2_NEMONE",
                        "content": "This should be hard for sure."
                    },
                    {
                        "username": "layyy",
                        "content": "try implementing \"reverse nodes in k-group\" before this "
                    },
                    {
                        "username": "bollineniyokesh",
                        "content": "Make this \"HARD\" ! "
                    },
                    {
                        "username": "anasansari_777",
                        "content": "Reverse Linked List II could be used here.\\n"
                    },
                    {
                        "username": "steven520142",
                        "content": "If you wanna do it in place, it is a hard problem.\\nOn the other hand, if you store the node in a list and rebuild linked list after doing the reverse, it is a medium problem."
                    },
                    {
                        "username": "anthonyche",
                        "content": "I know this one is a HARD problem just from reading the descriptions, it is ridiculous to put it in a medium category."
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "this must be hard sum"
                    }
                ]
            },
            {
                "id": 1761796,
                "content": [
                    {
                        "username": "calm27",
                        "content": "it is hard problem. \\ni spent probably 3 hours to find a solution, and hard prob i did before: reverse in k-group was way much easier. \\nso, it can\\'t be mid. "
                    },
                    {
                        "username": "stefan1096",
                        "content": "[@N1ghtstalker2022](/N1ghtstalker2022) \\nLeetcode should change easy medium hard to five stars for difficulty,This would be 4/5.Average mediums are 3/5."
                    },
                    {
                        "username": "N1ghtstalker2022",
                        "content": "Almost same. Cause me several hours..."
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "I will highly recommend using pen and paper to draw a diagram and some sequences of the examples to figure out the algorithm. Most of the linked list questions require visualization which is very easy to get using pen and paper."
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "This problem deserves a Hard category.\\nReason being, despite the list group is even, if the no. of nodes are odd, then there is no need to reverse the list."
                    },
                    {
                        "username": "2_NEMONE",
                        "content": "This should be hard for sure."
                    },
                    {
                        "username": "layyy",
                        "content": "try implementing \"reverse nodes in k-group\" before this "
                    },
                    {
                        "username": "bollineniyokesh",
                        "content": "Make this \"HARD\" ! "
                    },
                    {
                        "username": "anasansari_777",
                        "content": "Reverse Linked List II could be used here.\\n"
                    },
                    {
                        "username": "steven520142",
                        "content": "If you wanna do it in place, it is a hard problem.\\nOn the other hand, if you store the node in a list and rebuild linked list after doing the reverse, it is a medium problem."
                    },
                    {
                        "username": "anthonyche",
                        "content": "I know this one is a HARD problem just from reading the descriptions, it is ridiculous to put it in a medium category."
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "this must be hard sum"
                    }
                ]
            },
            {
                "id": 1898418,
                "content": [
                    {
                        "username": "calm27",
                        "content": "it is hard problem. \\ni spent probably 3 hours to find a solution, and hard prob i did before: reverse in k-group was way much easier. \\nso, it can\\'t be mid. "
                    },
                    {
                        "username": "stefan1096",
                        "content": "[@N1ghtstalker2022](/N1ghtstalker2022) \\nLeetcode should change easy medium hard to five stars for difficulty,This would be 4/5.Average mediums are 3/5."
                    },
                    {
                        "username": "N1ghtstalker2022",
                        "content": "Almost same. Cause me several hours..."
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "I will highly recommend using pen and paper to draw a diagram and some sequences of the examples to figure out the algorithm. Most of the linked list questions require visualization which is very easy to get using pen and paper."
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "This problem deserves a Hard category.\\nReason being, despite the list group is even, if the no. of nodes are odd, then there is no need to reverse the list."
                    },
                    {
                        "username": "2_NEMONE",
                        "content": "This should be hard for sure."
                    },
                    {
                        "username": "layyy",
                        "content": "try implementing \"reverse nodes in k-group\" before this "
                    },
                    {
                        "username": "bollineniyokesh",
                        "content": "Make this \"HARD\" ! "
                    },
                    {
                        "username": "anasansari_777",
                        "content": "Reverse Linked List II could be used here.\\n"
                    },
                    {
                        "username": "steven520142",
                        "content": "If you wanna do it in place, it is a hard problem.\\nOn the other hand, if you store the node in a list and rebuild linked list after doing the reverse, it is a medium problem."
                    },
                    {
                        "username": "anthonyche",
                        "content": "I know this one is a HARD problem just from reading the descriptions, it is ridiculous to put it in a medium category."
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "this must be hard sum"
                    }
                ]
            },
            {
                "id": 1771113,
                "content": [
                    {
                        "username": "calm27",
                        "content": "it is hard problem. \\ni spent probably 3 hours to find a solution, and hard prob i did before: reverse in k-group was way much easier. \\nso, it can\\'t be mid. "
                    },
                    {
                        "username": "stefan1096",
                        "content": "[@N1ghtstalker2022](/N1ghtstalker2022) \\nLeetcode should change easy medium hard to five stars for difficulty,This would be 4/5.Average mediums are 3/5."
                    },
                    {
                        "username": "N1ghtstalker2022",
                        "content": "Almost same. Cause me several hours..."
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "I will highly recommend using pen and paper to draw a diagram and some sequences of the examples to figure out the algorithm. Most of the linked list questions require visualization which is very easy to get using pen and paper."
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "This problem deserves a Hard category.\\nReason being, despite the list group is even, if the no. of nodes are odd, then there is no need to reverse the list."
                    },
                    {
                        "username": "2_NEMONE",
                        "content": "This should be hard for sure."
                    },
                    {
                        "username": "layyy",
                        "content": "try implementing \"reverse nodes in k-group\" before this "
                    },
                    {
                        "username": "bollineniyokesh",
                        "content": "Make this \"HARD\" ! "
                    },
                    {
                        "username": "anasansari_777",
                        "content": "Reverse Linked List II could be used here.\\n"
                    },
                    {
                        "username": "steven520142",
                        "content": "If you wanna do it in place, it is a hard problem.\\nOn the other hand, if you store the node in a list and rebuild linked list after doing the reverse, it is a medium problem."
                    },
                    {
                        "username": "anthonyche",
                        "content": "I know this one is a HARD problem just from reading the descriptions, it is ridiculous to put it in a medium category."
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "this must be hard sum"
                    }
                ]
            },
            {
                "id": 2054286,
                "content": [
                    {
                        "username": "calm27",
                        "content": "it is hard problem. \\ni spent probably 3 hours to find a solution, and hard prob i did before: reverse in k-group was way much easier. \\nso, it can\\'t be mid. "
                    },
                    {
                        "username": "stefan1096",
                        "content": "[@N1ghtstalker2022](/N1ghtstalker2022) \\nLeetcode should change easy medium hard to five stars for difficulty,This would be 4/5.Average mediums are 3/5."
                    },
                    {
                        "username": "N1ghtstalker2022",
                        "content": "Almost same. Cause me several hours..."
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "I will highly recommend using pen and paper to draw a diagram and some sequences of the examples to figure out the algorithm. Most of the linked list questions require visualization which is very easy to get using pen and paper."
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "This problem deserves a Hard category.\\nReason being, despite the list group is even, if the no. of nodes are odd, then there is no need to reverse the list."
                    },
                    {
                        "username": "2_NEMONE",
                        "content": "This should be hard for sure."
                    },
                    {
                        "username": "layyy",
                        "content": "try implementing \"reverse nodes in k-group\" before this "
                    },
                    {
                        "username": "bollineniyokesh",
                        "content": "Make this \"HARD\" ! "
                    },
                    {
                        "username": "anasansari_777",
                        "content": "Reverse Linked List II could be used here.\\n"
                    },
                    {
                        "username": "steven520142",
                        "content": "If you wanna do it in place, it is a hard problem.\\nOn the other hand, if you store the node in a list and rebuild linked list after doing the reverse, it is a medium problem."
                    },
                    {
                        "username": "anthonyche",
                        "content": "I know this one is a HARD problem just from reading the descriptions, it is ridiculous to put it in a medium category."
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "this must be hard sum"
                    }
                ]
            },
            {
                "id": 2018696,
                "content": [
                    {
                        "username": "calm27",
                        "content": "it is hard problem. \\ni spent probably 3 hours to find a solution, and hard prob i did before: reverse in k-group was way much easier. \\nso, it can\\'t be mid. "
                    },
                    {
                        "username": "stefan1096",
                        "content": "[@N1ghtstalker2022](/N1ghtstalker2022) \\nLeetcode should change easy medium hard to five stars for difficulty,This would be 4/5.Average mediums are 3/5."
                    },
                    {
                        "username": "N1ghtstalker2022",
                        "content": "Almost same. Cause me several hours..."
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "I will highly recommend using pen and paper to draw a diagram and some sequences of the examples to figure out the algorithm. Most of the linked list questions require visualization which is very easy to get using pen and paper."
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "This problem deserves a Hard category.\\nReason being, despite the list group is even, if the no. of nodes are odd, then there is no need to reverse the list."
                    },
                    {
                        "username": "2_NEMONE",
                        "content": "This should be hard for sure."
                    },
                    {
                        "username": "layyy",
                        "content": "try implementing \"reverse nodes in k-group\" before this "
                    },
                    {
                        "username": "bollineniyokesh",
                        "content": "Make this \"HARD\" ! "
                    },
                    {
                        "username": "anasansari_777",
                        "content": "Reverse Linked List II could be used here.\\n"
                    },
                    {
                        "username": "steven520142",
                        "content": "If you wanna do it in place, it is a hard problem.\\nOn the other hand, if you store the node in a list and rebuild linked list after doing the reverse, it is a medium problem."
                    },
                    {
                        "username": "anthonyche",
                        "content": "I know this one is a HARD problem just from reading the descriptions, it is ridiculous to put it in a medium category."
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "this must be hard sum"
                    }
                ]
            },
            {
                "id": 1860681,
                "content": [
                    {
                        "username": "calm27",
                        "content": "it is hard problem. \\ni spent probably 3 hours to find a solution, and hard prob i did before: reverse in k-group was way much easier. \\nso, it can\\'t be mid. "
                    },
                    {
                        "username": "stefan1096",
                        "content": "[@N1ghtstalker2022](/N1ghtstalker2022) \\nLeetcode should change easy medium hard to five stars for difficulty,This would be 4/5.Average mediums are 3/5."
                    },
                    {
                        "username": "N1ghtstalker2022",
                        "content": "Almost same. Cause me several hours..."
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "I will highly recommend using pen and paper to draw a diagram and some sequences of the examples to figure out the algorithm. Most of the linked list questions require visualization which is very easy to get using pen and paper."
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "This problem deserves a Hard category.\\nReason being, despite the list group is even, if the no. of nodes are odd, then there is no need to reverse the list."
                    },
                    {
                        "username": "2_NEMONE",
                        "content": "This should be hard for sure."
                    },
                    {
                        "username": "layyy",
                        "content": "try implementing \"reverse nodes in k-group\" before this "
                    },
                    {
                        "username": "bollineniyokesh",
                        "content": "Make this \"HARD\" ! "
                    },
                    {
                        "username": "anasansari_777",
                        "content": "Reverse Linked List II could be used here.\\n"
                    },
                    {
                        "username": "steven520142",
                        "content": "If you wanna do it in place, it is a hard problem.\\nOn the other hand, if you store the node in a list and rebuild linked list after doing the reverse, it is a medium problem."
                    },
                    {
                        "username": "anthonyche",
                        "content": "I know this one is a HARD problem just from reading the descriptions, it is ridiculous to put it in a medium category."
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "this must be hard sum"
                    }
                ]
            },
            {
                "id": 2062205,
                "content": [
                    {
                        "username": "calm27",
                        "content": "it is hard problem. \\ni spent probably 3 hours to find a solution, and hard prob i did before: reverse in k-group was way much easier. \\nso, it can\\'t be mid. "
                    },
                    {
                        "username": "stefan1096",
                        "content": "[@N1ghtstalker2022](/N1ghtstalker2022) \\nLeetcode should change easy medium hard to five stars for difficulty,This would be 4/5.Average mediums are 3/5."
                    },
                    {
                        "username": "N1ghtstalker2022",
                        "content": "Almost same. Cause me several hours..."
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "I will highly recommend using pen and paper to draw a diagram and some sequences of the examples to figure out the algorithm. Most of the linked list questions require visualization which is very easy to get using pen and paper."
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "This problem deserves a Hard category.\\nReason being, despite the list group is even, if the no. of nodes are odd, then there is no need to reverse the list."
                    },
                    {
                        "username": "2_NEMONE",
                        "content": "This should be hard for sure."
                    },
                    {
                        "username": "layyy",
                        "content": "try implementing \"reverse nodes in k-group\" before this "
                    },
                    {
                        "username": "bollineniyokesh",
                        "content": "Make this \"HARD\" ! "
                    },
                    {
                        "username": "anasansari_777",
                        "content": "Reverse Linked List II could be used here.\\n"
                    },
                    {
                        "username": "steven520142",
                        "content": "If you wanna do it in place, it is a hard problem.\\nOn the other hand, if you store the node in a list and rebuild linked list after doing the reverse, it is a medium problem."
                    },
                    {
                        "username": "anthonyche",
                        "content": "I know this one is a HARD problem just from reading the descriptions, it is ridiculous to put it in a medium category."
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "this must be hard sum"
                    }
                ]
            },
            {
                "id": 1769960,
                "content": [
                    {
                        "username": "calm27",
                        "content": "it is hard problem. \\ni spent probably 3 hours to find a solution, and hard prob i did before: reverse in k-group was way much easier. \\nso, it can\\'t be mid. "
                    },
                    {
                        "username": "stefan1096",
                        "content": "[@N1ghtstalker2022](/N1ghtstalker2022) \\nLeetcode should change easy medium hard to five stars for difficulty,This would be 4/5.Average mediums are 3/5."
                    },
                    {
                        "username": "N1ghtstalker2022",
                        "content": "Almost same. Cause me several hours..."
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "I will highly recommend using pen and paper to draw a diagram and some sequences of the examples to figure out the algorithm. Most of the linked list questions require visualization which is very easy to get using pen and paper."
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "This problem deserves a Hard category.\\nReason being, despite the list group is even, if the no. of nodes are odd, then there is no need to reverse the list."
                    },
                    {
                        "username": "2_NEMONE",
                        "content": "This should be hard for sure."
                    },
                    {
                        "username": "layyy",
                        "content": "try implementing \"reverse nodes in k-group\" before this "
                    },
                    {
                        "username": "bollineniyokesh",
                        "content": "Make this \"HARD\" ! "
                    },
                    {
                        "username": "anasansari_777",
                        "content": "Reverse Linked List II could be used here.\\n"
                    },
                    {
                        "username": "steven520142",
                        "content": "If you wanna do it in place, it is a hard problem.\\nOn the other hand, if you store the node in a list and rebuild linked list after doing the reverse, it is a medium problem."
                    },
                    {
                        "username": "anthonyche",
                        "content": "I know this one is a HARD problem just from reading the descriptions, it is ridiculous to put it in a medium category."
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "this must be hard sum"
                    }
                ]
            },
            {
                "id": 1960006,
                "content": [
                    {
                        "username": "calm27",
                        "content": "it is hard problem. \\ni spent probably 3 hours to find a solution, and hard prob i did before: reverse in k-group was way much easier. \\nso, it can\\'t be mid. "
                    },
                    {
                        "username": "stefan1096",
                        "content": "[@N1ghtstalker2022](/N1ghtstalker2022) \\nLeetcode should change easy medium hard to five stars for difficulty,This would be 4/5.Average mediums are 3/5."
                    },
                    {
                        "username": "N1ghtstalker2022",
                        "content": "Almost same. Cause me several hours..."
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "I will highly recommend using pen and paper to draw a diagram and some sequences of the examples to figure out the algorithm. Most of the linked list questions require visualization which is very easy to get using pen and paper."
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "This problem deserves a Hard category.\\nReason being, despite the list group is even, if the no. of nodes are odd, then there is no need to reverse the list."
                    },
                    {
                        "username": "2_NEMONE",
                        "content": "This should be hard for sure."
                    },
                    {
                        "username": "layyy",
                        "content": "try implementing \"reverse nodes in k-group\" before this "
                    },
                    {
                        "username": "bollineniyokesh",
                        "content": "Make this \"HARD\" ! "
                    },
                    {
                        "username": "anasansari_777",
                        "content": "Reverse Linked List II could be used here.\\n"
                    },
                    {
                        "username": "steven520142",
                        "content": "If you wanna do it in place, it is a hard problem.\\nOn the other hand, if you store the node in a list and rebuild linked list after doing the reverse, it is a medium problem."
                    },
                    {
                        "username": "anthonyche",
                        "content": "I know this one is a HARD problem just from reading the descriptions, it is ridiculous to put it in a medium category."
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "this must be hard sum"
                    }
                ]
            },
            {
                "id": 1794919,
                "content": [
                    {
                        "username": "calm27",
                        "content": "it is hard problem. \\ni spent probably 3 hours to find a solution, and hard prob i did before: reverse in k-group was way much easier. \\nso, it can\\'t be mid. "
                    },
                    {
                        "username": "stefan1096",
                        "content": "[@N1ghtstalker2022](/N1ghtstalker2022) \\nLeetcode should change easy medium hard to five stars for difficulty,This would be 4/5.Average mediums are 3/5."
                    },
                    {
                        "username": "N1ghtstalker2022",
                        "content": "Almost same. Cause me several hours..."
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "I will highly recommend using pen and paper to draw a diagram and some sequences of the examples to figure out the algorithm. Most of the linked list questions require visualization which is very easy to get using pen and paper."
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "This problem deserves a Hard category.\\nReason being, despite the list group is even, if the no. of nodes are odd, then there is no need to reverse the list."
                    },
                    {
                        "username": "2_NEMONE",
                        "content": "This should be hard for sure."
                    },
                    {
                        "username": "layyy",
                        "content": "try implementing \"reverse nodes in k-group\" before this "
                    },
                    {
                        "username": "bollineniyokesh",
                        "content": "Make this \"HARD\" ! "
                    },
                    {
                        "username": "anasansari_777",
                        "content": "Reverse Linked List II could be used here.\\n"
                    },
                    {
                        "username": "steven520142",
                        "content": "If you wanna do it in place, it is a hard problem.\\nOn the other hand, if you store the node in a list and rebuild linked list after doing the reverse, it is a medium problem."
                    },
                    {
                        "username": "anthonyche",
                        "content": "I know this one is a HARD problem just from reading the descriptions, it is ridiculous to put it in a medium category."
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "this must be hard sum"
                    }
                ]
            },
            {
                "id": 1761796,
                "content": [
                    {
                        "username": "calm27",
                        "content": "it is hard problem. \\ni spent probably 3 hours to find a solution, and hard prob i did before: reverse in k-group was way much easier. \\nso, it can\\'t be mid. "
                    },
                    {
                        "username": "stefan1096",
                        "content": "[@N1ghtstalker2022](/N1ghtstalker2022) \\nLeetcode should change easy medium hard to five stars for difficulty,This would be 4/5.Average mediums are 3/5."
                    },
                    {
                        "username": "N1ghtstalker2022",
                        "content": "Almost same. Cause me several hours..."
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "I will highly recommend using pen and paper to draw a diagram and some sequences of the examples to figure out the algorithm. Most of the linked list questions require visualization which is very easy to get using pen and paper."
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "This problem deserves a Hard category.\\nReason being, despite the list group is even, if the no. of nodes are odd, then there is no need to reverse the list."
                    },
                    {
                        "username": "2_NEMONE",
                        "content": "This should be hard for sure."
                    },
                    {
                        "username": "layyy",
                        "content": "try implementing \"reverse nodes in k-group\" before this "
                    },
                    {
                        "username": "bollineniyokesh",
                        "content": "Make this \"HARD\" ! "
                    },
                    {
                        "username": "anasansari_777",
                        "content": "Reverse Linked List II could be used here.\\n"
                    },
                    {
                        "username": "steven520142",
                        "content": "If you wanna do it in place, it is a hard problem.\\nOn the other hand, if you store the node in a list and rebuild linked list after doing the reverse, it is a medium problem."
                    },
                    {
                        "username": "anthonyche",
                        "content": "I know this one is a HARD problem just from reading the descriptions, it is ridiculous to put it in a medium category."
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "this must be hard sum"
                    }
                ]
            },
            {
                "id": 1898418,
                "content": [
                    {
                        "username": "calm27",
                        "content": "it is hard problem. \\ni spent probably 3 hours to find a solution, and hard prob i did before: reverse in k-group was way much easier. \\nso, it can\\'t be mid. "
                    },
                    {
                        "username": "stefan1096",
                        "content": "[@N1ghtstalker2022](/N1ghtstalker2022) \\nLeetcode should change easy medium hard to five stars for difficulty,This would be 4/5.Average mediums are 3/5."
                    },
                    {
                        "username": "N1ghtstalker2022",
                        "content": "Almost same. Cause me several hours..."
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "I will highly recommend using pen and paper to draw a diagram and some sequences of the examples to figure out the algorithm. Most of the linked list questions require visualization which is very easy to get using pen and paper."
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "This problem deserves a Hard category.\\nReason being, despite the list group is even, if the no. of nodes are odd, then there is no need to reverse the list."
                    },
                    {
                        "username": "2_NEMONE",
                        "content": "This should be hard for sure."
                    },
                    {
                        "username": "layyy",
                        "content": "try implementing \"reverse nodes in k-group\" before this "
                    },
                    {
                        "username": "bollineniyokesh",
                        "content": "Make this \"HARD\" ! "
                    },
                    {
                        "username": "anasansari_777",
                        "content": "Reverse Linked List II could be used here.\\n"
                    },
                    {
                        "username": "steven520142",
                        "content": "If you wanna do it in place, it is a hard problem.\\nOn the other hand, if you store the node in a list and rebuild linked list after doing the reverse, it is a medium problem."
                    },
                    {
                        "username": "anthonyche",
                        "content": "I know this one is a HARD problem just from reading the descriptions, it is ridiculous to put it in a medium category."
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "this must be hard sum"
                    }
                ]
            },
            {
                "id": 1771113,
                "content": [
                    {
                        "username": "calm27",
                        "content": "it is hard problem. \\ni spent probably 3 hours to find a solution, and hard prob i did before: reverse in k-group was way much easier. \\nso, it can\\'t be mid. "
                    },
                    {
                        "username": "stefan1096",
                        "content": "[@N1ghtstalker2022](/N1ghtstalker2022) \\nLeetcode should change easy medium hard to five stars for difficulty,This would be 4/5.Average mediums are 3/5."
                    },
                    {
                        "username": "N1ghtstalker2022",
                        "content": "Almost same. Cause me several hours..."
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "I will highly recommend using pen and paper to draw a diagram and some sequences of the examples to figure out the algorithm. Most of the linked list questions require visualization which is very easy to get using pen and paper."
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "This problem deserves a Hard category.\\nReason being, despite the list group is even, if the no. of nodes are odd, then there is no need to reverse the list."
                    },
                    {
                        "username": "2_NEMONE",
                        "content": "This should be hard for sure."
                    },
                    {
                        "username": "layyy",
                        "content": "try implementing \"reverse nodes in k-group\" before this "
                    },
                    {
                        "username": "bollineniyokesh",
                        "content": "Make this \"HARD\" ! "
                    },
                    {
                        "username": "anasansari_777",
                        "content": "Reverse Linked List II could be used here.\\n"
                    },
                    {
                        "username": "steven520142",
                        "content": "If you wanna do it in place, it is a hard problem.\\nOn the other hand, if you store the node in a list and rebuild linked list after doing the reverse, it is a medium problem."
                    },
                    {
                        "username": "anthonyche",
                        "content": "I know this one is a HARD problem just from reading the descriptions, it is ridiculous to put it in a medium category."
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "this must be hard sum"
                    }
                ]
            },
            {
                "id": 2054286,
                "content": [
                    {
                        "username": "calm27",
                        "content": "it is hard problem. \\ni spent probably 3 hours to find a solution, and hard prob i did before: reverse in k-group was way much easier. \\nso, it can\\'t be mid. "
                    },
                    {
                        "username": "stefan1096",
                        "content": "[@N1ghtstalker2022](/N1ghtstalker2022) \\nLeetcode should change easy medium hard to five stars for difficulty,This would be 4/5.Average mediums are 3/5."
                    },
                    {
                        "username": "N1ghtstalker2022",
                        "content": "Almost same. Cause me several hours..."
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "I will highly recommend using pen and paper to draw a diagram and some sequences of the examples to figure out the algorithm. Most of the linked list questions require visualization which is very easy to get using pen and paper."
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "This problem deserves a Hard category.\\nReason being, despite the list group is even, if the no. of nodes are odd, then there is no need to reverse the list."
                    },
                    {
                        "username": "2_NEMONE",
                        "content": "This should be hard for sure."
                    },
                    {
                        "username": "layyy",
                        "content": "try implementing \"reverse nodes in k-group\" before this "
                    },
                    {
                        "username": "bollineniyokesh",
                        "content": "Make this \"HARD\" ! "
                    },
                    {
                        "username": "anasansari_777",
                        "content": "Reverse Linked List II could be used here.\\n"
                    },
                    {
                        "username": "steven520142",
                        "content": "If you wanna do it in place, it is a hard problem.\\nOn the other hand, if you store the node in a list and rebuild linked list after doing the reverse, it is a medium problem."
                    },
                    {
                        "username": "anthonyche",
                        "content": "I know this one is a HARD problem just from reading the descriptions, it is ridiculous to put it in a medium category."
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "this must be hard sum"
                    }
                ]
            },
            {
                "id": 2018696,
                "content": [
                    {
                        "username": "calm27",
                        "content": "it is hard problem. \\ni spent probably 3 hours to find a solution, and hard prob i did before: reverse in k-group was way much easier. \\nso, it can\\'t be mid. "
                    },
                    {
                        "username": "stefan1096",
                        "content": "[@N1ghtstalker2022](/N1ghtstalker2022) \\nLeetcode should change easy medium hard to five stars for difficulty,This would be 4/5.Average mediums are 3/5."
                    },
                    {
                        "username": "N1ghtstalker2022",
                        "content": "Almost same. Cause me several hours..."
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "I will highly recommend using pen and paper to draw a diagram and some sequences of the examples to figure out the algorithm. Most of the linked list questions require visualization which is very easy to get using pen and paper."
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "This problem deserves a Hard category.\\nReason being, despite the list group is even, if the no. of nodes are odd, then there is no need to reverse the list."
                    },
                    {
                        "username": "2_NEMONE",
                        "content": "This should be hard for sure."
                    },
                    {
                        "username": "layyy",
                        "content": "try implementing \"reverse nodes in k-group\" before this "
                    },
                    {
                        "username": "bollineniyokesh",
                        "content": "Make this \"HARD\" ! "
                    },
                    {
                        "username": "anasansari_777",
                        "content": "Reverse Linked List II could be used here.\\n"
                    },
                    {
                        "username": "steven520142",
                        "content": "If you wanna do it in place, it is a hard problem.\\nOn the other hand, if you store the node in a list and rebuild linked list after doing the reverse, it is a medium problem."
                    },
                    {
                        "username": "anthonyche",
                        "content": "I know this one is a HARD problem just from reading the descriptions, it is ridiculous to put it in a medium category."
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "this must be hard sum"
                    }
                ]
            },
            {
                "id": 1860681,
                "content": [
                    {
                        "username": "calm27",
                        "content": "it is hard problem. \\ni spent probably 3 hours to find a solution, and hard prob i did before: reverse in k-group was way much easier. \\nso, it can\\'t be mid. "
                    },
                    {
                        "username": "stefan1096",
                        "content": "[@N1ghtstalker2022](/N1ghtstalker2022) \\nLeetcode should change easy medium hard to five stars for difficulty,This would be 4/5.Average mediums are 3/5."
                    },
                    {
                        "username": "N1ghtstalker2022",
                        "content": "Almost same. Cause me several hours..."
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "I will highly recommend using pen and paper to draw a diagram and some sequences of the examples to figure out the algorithm. Most of the linked list questions require visualization which is very easy to get using pen and paper."
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "This problem deserves a Hard category.\\nReason being, despite the list group is even, if the no. of nodes are odd, then there is no need to reverse the list."
                    },
                    {
                        "username": "2_NEMONE",
                        "content": "This should be hard for sure."
                    },
                    {
                        "username": "layyy",
                        "content": "try implementing \"reverse nodes in k-group\" before this "
                    },
                    {
                        "username": "bollineniyokesh",
                        "content": "Make this \"HARD\" ! "
                    },
                    {
                        "username": "anasansari_777",
                        "content": "Reverse Linked List II could be used here.\\n"
                    },
                    {
                        "username": "steven520142",
                        "content": "If you wanna do it in place, it is a hard problem.\\nOn the other hand, if you store the node in a list and rebuild linked list after doing the reverse, it is a medium problem."
                    },
                    {
                        "username": "anthonyche",
                        "content": "I know this one is a HARD problem just from reading the descriptions, it is ridiculous to put it in a medium category."
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "this must be hard sum"
                    }
                ]
            },
            {
                "id": 2062205,
                "content": [
                    {
                        "username": "calm27",
                        "content": "it is hard problem. \\ni spent probably 3 hours to find a solution, and hard prob i did before: reverse in k-group was way much easier. \\nso, it can\\'t be mid. "
                    },
                    {
                        "username": "stefan1096",
                        "content": "[@N1ghtstalker2022](/N1ghtstalker2022) \\nLeetcode should change easy medium hard to five stars for difficulty,This would be 4/5.Average mediums are 3/5."
                    },
                    {
                        "username": "N1ghtstalker2022",
                        "content": "Almost same. Cause me several hours..."
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "I will highly recommend using pen and paper to draw a diagram and some sequences of the examples to figure out the algorithm. Most of the linked list questions require visualization which is very easy to get using pen and paper."
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "This problem deserves a Hard category.\\nReason being, despite the list group is even, if the no. of nodes are odd, then there is no need to reverse the list."
                    },
                    {
                        "username": "2_NEMONE",
                        "content": "This should be hard for sure."
                    },
                    {
                        "username": "layyy",
                        "content": "try implementing \"reverse nodes in k-group\" before this "
                    },
                    {
                        "username": "bollineniyokesh",
                        "content": "Make this \"HARD\" ! "
                    },
                    {
                        "username": "anasansari_777",
                        "content": "Reverse Linked List II could be used here.\\n"
                    },
                    {
                        "username": "steven520142",
                        "content": "If you wanna do it in place, it is a hard problem.\\nOn the other hand, if you store the node in a list and rebuild linked list after doing the reverse, it is a medium problem."
                    },
                    {
                        "username": "anthonyche",
                        "content": "I know this one is a HARD problem just from reading the descriptions, it is ridiculous to put it in a medium category."
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "this must be hard sum"
                    }
                ]
            }
        ]
    },
    {
        "title": "Decode the Slanted Ciphertext",
        "question_content": "<p>A string <code>originalText</code> is encoded using a <strong>slanted transposition cipher</strong> to a string <code>encodedText</code> with the help of a matrix having a <strong>fixed number of rows</strong> <code>rows</code>.</p>\n\n<p><code>originalText</code> is placed first in a top-left to bottom-right manner.</p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/11/07/exa11.png\" style=\"width: 300px; height: 185px;\" />\n<p>The blue cells are filled first, followed by the red cells, then the yellow cells, and so on, until we reach the end of <code>originalText</code>. The arrow indicates the order in which the cells are filled. All empty cells are filled with <code>&#39; &#39;</code>. The number of columns is chosen such that the rightmost column will <strong>not be empty</strong> after filling in <code>originalText</code>.</p>\n\n<p><code>encodedText</code> is then formed by appending all characters of the matrix in a row-wise fashion.</p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/11/07/exa12.png\" style=\"width: 300px; height: 200px;\" />\n<p>The characters in the blue cells are appended first to <code>encodedText</code>, then the red cells, and so on, and finally the yellow cells. The arrow indicates the order in which the cells are accessed.</p>\n\n<p>For example, if <code>originalText = &quot;cipher&quot;</code> and <code>rows = 3</code>, then we encode it in the following manner:</p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/10/25/desc2.png\" style=\"width: 281px; height: 211px;\" />\n<p>The blue arrows depict how <code>originalText</code> is placed in the matrix, and the red arrows denote the order in which <code>encodedText</code> is formed. In the above example, <code>encodedText = &quot;ch ie pr&quot;</code>.</p>\n\n<p>Given the encoded string <code>encodedText</code> and number of rows <code>rows</code>, return <em>the original string</em> <code>originalText</code>.</p>\n\n<p><strong>Note:</strong> <code>originalText</code> <strong>does not</strong> have any trailing spaces <code>&#39; &#39;</code>. The test cases are generated such that there is only one possible <code>originalText</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> encodedText = &quot;ch   ie   pr&quot;, rows = 3\n<strong>Output:</strong> &quot;cipher&quot;\n<strong>Explanation:</strong> This is the same example described in the problem description.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/10/26/exam1.png\" style=\"width: 250px; height: 168px;\" />\n<pre>\n<strong>Input:</strong> encodedText = &quot;iveo    eed   l te   olc&quot;, rows = 4\n<strong>Output:</strong> &quot;i love leetcode&quot;\n<strong>Explanation:</strong> The figure above denotes the matrix that was used to encode originalText. \nThe blue arrows show how we can find originalText from encodedText.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/10/26/eg2.png\" style=\"width: 300px; height: 51px;\" />\n<pre>\n<strong>Input:</strong> encodedText = &quot;coding&quot;, rows = 1\n<strong>Output:</strong> &quot;coding&quot;\n<strong>Explanation:</strong> Since there is only 1 row, both originalText and encodedText are the same.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= encodedText.length &lt;= 10<sup>6</sup></code></li>\n\t<li><code>encodedText</code> consists of lowercase English letters and <code>&#39; &#39;</code> only.</li>\n\t<li><code>encodedText</code> is a valid encoding of some <code>originalText</code> that <strong>does not</strong> have trailing spaces.</li>\n\t<li><code>1 &lt;= rows &lt;= 1000</code></li>\n\t<li>The testcases are generated such that there is <strong>only one</strong> possible <code>originalText</code>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 1576914,
                "title": "jump-columns-1",
                "content": "Knowing `rows`, we can find out `cols`. Knowing `cols`, we can jump to the next letter (`cols + 1`).\\n\\nExample: `\"ch   ie   pr\"`, rows = 3, columns = 12 / 3 = 4.\\n0: [0, 5, 10] `\"cip\"`\\n1: [1, 6, 11] `\"her\"`\\n2: [2, 7] `\"  \"` <- we will trim this.\\n3: [3, 8] `\"  \"` <- we will trim this.\\n\\n**Java**\\n```java\\npublic String decodeCiphertext(String encodedText, int rows) {\\n    int sz = encodedText.length(), cols = sz / rows;\\n    StringBuilder sb = new StringBuilder();\\n    for (int i = 0; i < cols; ++i)\\n        for (int j = i; j < sz; j += cols + 1)\\n            sb.append(encodedText.charAt(j));\\n    return sb.toString().stripTrailing();\\n}\\n```\\n**Python 3**\\n```python\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        cols, res = len(encodedText) // rows, \"\"\\n        for i in range(cols):\\n            for j in range(i, len(encodedText), cols + 1):\\n                res += encodedText[j]\\n        return res.rstrip()\\n```\\n**C++**\\n```cpp\\nstring decodeCiphertext(string encodedText, int rows) {\\n    int sz = encodedText.size(), cols = sz / rows;\\n    string res;\\n    for (int i = 0; i < cols; ++i)\\n        for (int j = i; j < sz; j += cols + 1)\\n            res += encodedText[j];\\n    while (!res.empty() && isspace(res.back()))\\n        res.pop_back();\\n    return res;\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "C"
                ],
                "code": "```java\\npublic String decodeCiphertext(String encodedText, int rows) {\\n    int sz = encodedText.length(), cols = sz / rows;\\n    StringBuilder sb = new StringBuilder();\\n    for (int i = 0; i < cols; ++i)\\n        for (int j = i; j < sz; j += cols + 1)\\n            sb.append(encodedText.charAt(j));\\n    return sb.toString().stripTrailing();\\n}\\n```\n```python\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        cols, res = len(encodedText) // rows, \"\"\\n        for i in range(cols):\\n            for j in range(i, len(encodedText), cols + 1):\\n                res += encodedText[j]\\n        return res.rstrip()\\n```\n```cpp\\nstring decodeCiphertext(string encodedText, int rows) {\\n    int sz = encodedText.size(), cols = sz / rows;\\n    string res;\\n    for (int i = 0; i < cols; ++i)\\n        for (int j = i; j < sz; j += cols + 1)\\n            res += encodedText[j];\\n    while (!res.empty() && isspace(res.back()))\\n        res.pop_back();\\n    return res;\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1577049,
                "title": "java-c-python-soluiton-with-explanation",
                "content": "# **Observations**\\n1. `s.length() = rows * cols`\\n2. `s[i]` and `s[i+cols+1]` are adjacent characters in original text.\\nFor example,\\n`\"cipher\"` to `\"ch   ie   pr\"`, `cols = 3`\\n`s[0] = \\'c\\'`\\n`s[4] = \\'i\\'`\\n`s[8] = \\'p\\'`\\n<br>\\n\\n# **Explanation**\\nFor every character in the first row in the matrix,\\nfind it\\'s adjacent characters in diagonal position in the matrix.\\nRead all these chara one by one,\\nreturn the trimmed result string.\\n<br>\\n\\n# **Complexity**\\nTime `O(n)`\\nSpace `O(n)`\\n<br>\\n\\n**Java**\\n```java\\n    public String decodeCiphertext(String s, int rows) {\\n        int n = s.length(), cols = n / rows;\\n        StringBuilder res = new StringBuilder(10);\\n        for (int i = 0; i < cols; ++i)\\n            for (int j = i; j < n; j += cols + 1)\\n                res.append(s.charAt(j));\\n        while (res.length()  > 0 && res.charAt(res.length() - 1) == \\' \\')\\n            res.setLength(res.length() - 1);\\n        return res.toString();\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    string decodeCiphertext(string s, int rows) {\\n        int n = s.size(), cols = n / rows;\\n        string res;\\n        for (int i = 0; i < cols; ++i)\\n            for (int j = i; j < n; j += cols + 1)\\n                res += s[j];\\n        while (res.back() == \\' \\')\\n            res.pop_back();\\n        return res;\\n    }\\n```\\n\\n**Python**\\n```py\\n    def decodeCiphertext(self, s, n):\\n        m = len(s) / n\\n        res = []\\n        for i in xrange(m):\\n            while i < len(s):\\n                res.append(s[i])\\n                i += m + 1\\n        return \\'\\'.join(res).rstrip()\\n```\\n",
                "solutionTags": [],
                "code": "```java\\n    public String decodeCiphertext(String s, int rows) {\\n        int n = s.length(), cols = n / rows;\\n        StringBuilder res = new StringBuilder(10);\\n        for (int i = 0; i < cols; ++i)\\n            for (int j = i; j < n; j += cols + 1)\\n                res.append(s.charAt(j));\\n        while (res.length()  > 0 && res.charAt(res.length() - 1) == \\' \\')\\n            res.setLength(res.length() - 1);\\n        return res.toString();\\n    }\\n```\n```cpp\\n    string decodeCiphertext(string s, int rows) {\\n        int n = s.size(), cols = n / rows;\\n        string res;\\n        for (int i = 0; i < cols; ++i)\\n            for (int j = i; j < n; j += cols + 1)\\n                res += s[j];\\n        while (res.back() == \\' \\')\\n            res.pop_back();\\n        return res;\\n    }\\n```\n```py\\n    def decodeCiphertext(self, s, n):\\n        m = len(s) / n\\n        res = []\\n        for i in xrange(m):\\n            while i < len(s):\\n                res.append(s[i])\\n                i += m + 1\\n        return \\'\\'.join(res).rstrip()\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1576943,
                "title": "c-concise-commented-code-idea-explained",
                "content": "\\n\\n**Idea**\\n* Since the encoded text contains all the characters of the matrix, we can determine the number of columns of the matrix and then form the matrix.\\n* Once the matrix is ready, we need to traverse it diagonally to obtain the original text. After taking some examples it becomes clear that when a boundary is hit, the pointer for row resets to 0, and the pointer for column is subtracted by the *currentrow minus 1*. \\n\\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        int n = encodedText.size();\\n        \\n        // Determining the number of columns\\n        int cols = n / rows;\\n        vector<vector<char>> mat(rows, vector<char>(cols, \\' \\'));\\n        int i = 0, j = 0;\\n        int k = 0;\\n        \\n        \\n        string ans = \"\";\\n        \\n        // Filling the matrix using encodedText\\n        // Row wise\\n        for(int i = 0; i < rows; i++) {\\n            for(int j = 0; j < cols; j++) {\\n                mat[i][j] = encodedText[k++];\\n            }\\n        }\\n        \\n        // Only the upper triangular part of the matrix will\\n        // contain characters of the originalText\\n        // so, this loop traverses that area\\n        for(int k = 0; k < n - (rows * (rows - 1)) / 2; k++) {\\n            // i, j are the two pointers for tracking rows and columns\\n            ans.push_back(mat[i++][j++]);\\n            \\n            // If any boundary is hit, then column pointer is subtracted \\n            // by row_pointer - 1\\n            // and row pointer is reset to 0\\n            if(i == rows || j == cols) {\\n                j -= (i - 1);\\n                i = 0;\\n            }\\n        }\\n        \\n        // Removing all trailing spaces\\n        while(ans.back() == \\' \\')\\n            ans.pop_back();\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n**Complexity Analysis**\\n*Space Complexity: O(n), where n is the size of encodedText*\\n*Time Complexity: O(n), where n is the size of encodedText*",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        int n = encodedText.size();\\n        \\n        // Determining the number of columns\\n        int cols = n / rows;\\n        vector<vector<char>> mat(rows, vector<char>(cols, \\' \\'));\\n        int i = 0, j = 0;\\n        int k = 0;\\n        \\n        \\n        string ans = \"\";\\n        \\n        // Filling the matrix using encodedText\\n        // Row wise\\n        for(int i = 0; i < rows; i++) {\\n            for(int j = 0; j < cols; j++) {\\n                mat[i][j] = encodedText[k++];\\n            }\\n        }\\n        \\n        // Only the upper triangular part of the matrix will\\n        // contain characters of the originalText\\n        // so, this loop traverses that area\\n        for(int k = 0; k < n - (rows * (rows - 1)) / 2; k++) {\\n            // i, j are the two pointers for tracking rows and columns\\n            ans.push_back(mat[i++][j++]);\\n            \\n            // If any boundary is hit, then column pointer is subtracted \\n            // by row_pointer - 1\\n            // and row pointer is reset to 0\\n            if(i == rows || j == cols) {\\n                j -= (i - 1);\\n                i = 0;\\n            }\\n        }\\n        \\n        // Removing all trailing spaces\\n        while(ans.back() == \\' \\')\\n            ans.pop_back();\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1577269,
                "title": "detailed-explanation-with-clean-code-diagonal-traversal",
                "content": "<br/>\\n\\n>  You can solve this problem using the diagram given in sample testcase\\n\\n<br/>\\n<img src=\"https://assets.leetcode.com/uploads/2021/10/26/exam1.png\" height=\"200px\" />\\n\\n<br/>\\n\\nIf you are just confused about the diagonal traversal, you can see the last part of this blog :)\\n\\n**Steps:**\\n\\n* cols = encodedText.size() / rows\\n* Fill all the characters in a 2D vector of size rows * cols (including spaces)\\n* Add all the diagonals to answer string\\n* Remove trailing zeros\\n\\nFor the example shown in above image when you traverse diagonally, you will get these substrings\\n```\\n\"i lo\" \\n\"ve l\"\\n\"eetc\"\\n\"ode\"\\n\"  \"\\n\" \"\\n```\\nAnd when you keep adding these character by character, you will have original text as\\n`\"i love leetcode  \"`\\nthen you can remove the trailing spaces\\n<br/>\\n\\n```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encoded, int rows) {\\n        \\n        int n = encoded.size();\\n        int cols = n / rows;\\n        vector<vector<char>> arr(rows, vector<char>(cols));\\n        int k = 0;\\n        \\n\\t\\t// filling the vector\\n        for(int i = 0; i < rows; i++) {\\n            for(int j = 0; j < cols; j++) {\\n                arr[i][j] = encoded[k++];\\n            }\\n        }\\n        \\n        string original = \"\";\\n        \\n\\t\\t// diagonal traversal as shown in image \\n        for(int col = 0; col < cols; col++) {\\n            int r = 0;\\n            int c = col;\\n            while(c < cols and r < rows) {\\n                original += arr[r++][c++];\\n            }\\n        }\\n        \\n\\t\\t// removing trailing zeros\\n        while(original.back() == \\' \\') original.pop_back();\\n        \\n        return original;\\n    }\\n};\\n```\\n\\n<br/>\\n\\n**If you are confused about how to traverse diagonally:**\\n\\n<p>Traversing diagonals in a matrix simply means going from `row = 0; row < rows` and `col = 0; col < cols\\n` by doing `row++, col++` at each stage\\n<br/>\\n\\n**Diagonal traversal for matrix of size (4 * 6) (Shown in image) will be as follows:**\\n\\n```\\n(0, 0) -> (1, 1) -> (2, 2) -> (3, 3)\\n(0, 1) -> (1, 2) -> (2, 3) -> (3, 4)\\n(0, 2) -> (1, 3) -> (2, 4) -> (3, 5)\\n(0, 3) -> (1, 4) -> (2, 5)\\n(0, 4) -> (1, 5)\\n(0, 5)\\n```\\n\\n</p>\\n\\n**Time complexity = Space complexity = O(n) = O(rows * cols)**\\n\\n<br/>",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n\"i lo\" \\n\"ve l\"\\n\"eetc\"\\n\"ode\"\\n\"  \"\\n\" \"\\n```\n```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encoded, int rows) {\\n        \\n        int n = encoded.size();\\n        int cols = n / rows;\\n        vector<vector<char>> arr(rows, vector<char>(cols));\\n        int k = 0;\\n        \\n\\t\\t// filling the vector\\n        for(int i = 0; i < rows; i++) {\\n            for(int j = 0; j < cols; j++) {\\n                arr[i][j] = encoded[k++];\\n            }\\n        }\\n        \\n        string original = \"\";\\n        \\n\\t\\t// diagonal traversal as shown in image \\n        for(int col = 0; col < cols; col++) {\\n            int r = 0;\\n            int c = col;\\n            while(c < cols and r < rows) {\\n                original += arr[r++][c++];\\n            }\\n        }\\n        \\n\\t\\t// removing trailing zeros\\n        while(original.back() == \\' \\') original.pop_back();\\n        \\n        return original;\\n    }\\n};\\n```\n```\\n(0, 0) -> (1, 1) -> (2, 2) -> (3, 3)\\n(0, 1) -> (1, 2) -> (2, 3) -> (3, 4)\\n(0, 2) -> (1, 3) -> (2, 4) -> (3, 5)\\n(0, 3) -> (1, 4) -> (2, 5)\\n(0, 4) -> (1, 5)\\n(0, 5)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1577075,
                "title": "python-build-the-cipher-matrix",
                "content": "This solution works as the problem states \"the rightmost column will not be empty after filling in `originalText`\". But then just wonder why it not avoid corner cases as `len(originalText) == 0`. Anyway, testcase like `\"a    \", 4` is treated as invalid case.\\n```\\ndef decodeCiphertext(s, r):\\n\\tk = len(s) // r\\n\\tmat = [s[i*k+i:i*k+k] for i in range(r)]\\n\\tmat[-1] += \" \"  # handle trailing characters for rows in mat[:-1]\\n\\treturn \"\".join(map(\"\".join, zip(*mat))).rstrip()\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef decodeCiphertext(s, r):\\n\\tk = len(s) // r\\n\\tmat = [s[i*k+i:i*k+k] for i in range(r)]\\n\\tmat[-1] += \" \"  # handle trailing characters for rows in mat[:-1]\\n\\treturn \"\".join(map(\"\".join, zip(*mat))).rstrip()\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2455783,
                "title": "c-easy-understanding-comments-images",
                "content": "![image](https://assets.leetcode.com/users/images/490d4bba-7328-4e7f-b735-38f2bf6e03b9_1661026373.273487.png)\\n![image](https://assets.leetcode.com/users/images/823894aa-6fac-44e2-9cf6-185e8c27e290_1661026380.454058.png)\\n![image](https://assets.leetcode.com/users/images/02554695-2d77-4b9e-aee3-0e0dc62a9893_1661026913.1704528.png)\\n\\n\\n\\tCODE\\n\\n\\t\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tstring decodeCiphertext(string e, int rows) {\\n\\t\\t\\tint size=e.size();\\n\\t\\t\\tint col=size/rows;\\n\\t\\t\\tstring ans;\\n\\t\\t\\tfor(int i=0;i<col;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor(int j=i;j<size;j+=col+1)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tans+=e[j];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\twhile (isspace(ans.back()))\\n\\t\\t\\t{\\n\\t\\t\\t\\tans.pop_back();\\n\\t\\t\\t}\\n\\t\\t\\t\\treturn ans;\\n\\t\\t\\t}\\n\\t\\t};\\n\\t\\t\\n\\t\\t\\n\\t\\t\\nComplexity Analysis\\nSpace Complexity: O(n), where n is the size of encodedText\\nTime Complexity: O(n), where n is the size of encodedText",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tstring decodeCiphertext(string e, int rows) {\\n\\t\\t\\tint size=e.size();\\n\\t\\t\\tint col=size/rows;\\n\\t\\t\\tstring ans;\\n\\t\\t\\tfor(int i=0;i<col;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor(int j=i;j<size;j+=col+1)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tans+=e[j];\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1594638,
                "title": "intuition-explained-simple-simulation-c-clean-code",
                "content": "# **Approach 1:** \\n**Intuition :**\\n\\n* Idea here is to just do what we are asked to perform. That is **simulate** decoding steps. \\n* First, we need to make `cipher` matrix using `encodedText`. \\n* Then, for each column in first row, we traverse diagonally and add those characters to `decodedText` string.\\n* In the end, since trailing spaces are not allowed, so we remove it from `decodedString`. \\n* We can have two cases. \\n\\t* One when `rows = 1`. In this case, we `decodedText` is same as `encodedText`.\\n\\t* And other when `rows > 1`. In this, we need to perform above simulation. \\n\\n* Lets understand through simple example : \\n\\n\\t\\tCase 1 : if rows == 1\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t  Ex: \"c o d i n g\"\\n            \\n\\t\\t\\t-> In this case we do not need to decode text. We can simply return encodedText directly. \\n\\t\\t\\t-> This is because all characters are in first row.\\n\\t\\t\\n\\t\\tCase 2: if rows > 1\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\tEx: encodedText = \"ch   ie   pr\" , rows = 3\\n\\t\\t\\t\\n\\t\\t\\tcipher matrix : \\n\\t\\t\\t\\t  \"c h _ _\\n\\t\\t\\t       _ i e _  \\n\\t\\t\\t\\t   _ _ p r\"\\n           \\n\\t\\t   -> Note : Here, just for sake of explanation, I have take space(\" \") as underscore(_).\\n\\t\\t   \\n            i. k = 0 => {(0,0) : \\'c\\'}, {(1,1) : \\'i\\'}, {(2,2) : \\'p\\'} \\n            ii. k = 1 => {(0,1) : \\'h\\'}, {(1,2) : \\'e\\'}, {(2,3) : \\'r\\'}\\n\\t\\t\\tiii. k = 2 => {(0,2) : \\'_\\'}, {(1,3) : \\'_\\'}\\n\\t\\t\\t\\n\\t\\t\\tThus, decodedString with trailing spaces = \"cipher_ _\". \\n\\t\\t\\tWe need to remove these trailing spaces, and then return resultant string.\\n        \\n\\t\\t\\t\\n# Code :\\n\\n```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        \\n        if(rows == 1) {\\n            return encodedText;\\n        }\\n        \\n        int cols = encodedText.size() / rows;\\n        \\n        vector<vector<char>> cipher(rows, vector<char>(cols));\\n        \\n        int k = 0;\\n        for(int i=0; i<rows; i++) {\\n            for(int j=0; j<cols; j++) {\\n                cipher[i][j] = encodedText[k++];\\n            }\\n        }\\n        \\n\\t\\t// Just added to print cipher \\n        // for(auto& r : cipher) {\\n        //     for(auto& c : r) {\\n        //         cout << c << \" \";\\n        //     }\\n        //     cout << endl;\\n        // }\\n        \\n        string decodedText = \"\";\\n\\t\\t\\n\\t\\t// Traverse diagonally for each column\\n        for(int k=0; k<cols; k++) {\\n            int i=0, j=k;\\n            while(i<rows && j<cols) {\\n                decodedText.push_back(cipher[i++][j++]);\\n            }\\n        }\\n        \\n        // Remove trailing spaces\\n        while(decodedText.back() == \\' \\') {\\n            decodedText.pop_back();\\n        }\\n        \\n        return decodedText;\\n    }\\n};\\n```\\n\\n**Complexity :**\\n\\n* Time : `O(N + N)`, create `cipher` matrix, and build `decodedText` string.\\n\\t* N is size of `encodedText` string\\n\\n* Space : `O(N)`, for `cipher` matrix for simulation.\\n-------------------------------------------------------\\n------------------------------------------------------\\n# **Approach 2:** \\n\\n**Intuition :**\\n\\n* We can optimize it further, by skipping `cipher` matrix part. We can directly get using `encodedText.` \\n\\n* Idea here is to move `(col+1)` steps each time in `encodedText`, to get next diagonal element. \\n* Since, if we are some coordinate `[i,j]`, then next diagonal element i.e `[i+1, j+1]`. \\n* Now, this is at a distance `(cols + 1)` from `[i,j]`. \\n* So we can directly move by this distance to get next character of `decodedText`\\n\\n# Code : \\n\\n```\\nstring decodeCiphertext(string encodedText, int rows) {\\n        \\n\\tint n = encodedText.size();\\n\\tint cols = n / rows;\\n\\n\\tstring decodedText = \"\";\\n\\n\\tfor(int i=0; i < cols; i++) {\\n\\t\\t// Move by distance (col+1) to get next character\\n\\t\\tfor(int j=i; j<n; j += (cols+1)) {\\n\\t\\t\\tdecodedText += encodedText[j];\\n\\t\\t}\\n\\t}\\n\\n\\twhile(decodedText.back() == \\' \\') decodedText.pop_back();\\n\\n\\treturn decodedText;\\n}\\n```\\n\\n***If you find this helpful, do give it a like :)***",
                "solutionTags": [
                    "C",
                    "String",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        \\n        if(rows == 1) {\\n            return encodedText;\\n        }\\n        \\n        int cols = encodedText.size() / rows;\\n        \\n        vector<vector<char>> cipher(rows, vector<char>(cols));\\n        \\n        int k = 0;\\n        for(int i=0; i<rows; i++) {\\n            for(int j=0; j<cols; j++) {\\n                cipher[i][j] = encodedText[k++];\\n            }\\n        }\\n        \\n\\t\\t// Just added to print cipher \\n        // for(auto& r : cipher) {\\n        //     for(auto& c : r) {\\n        //         cout << c << \" \";\\n        //     }\\n        //     cout << endl;\\n        // }\\n        \\n        string decodedText = \"\";\\n\\t\\t\\n\\t\\t// Traverse diagonally for each column\\n        for(int k=0; k<cols; k++) {\\n            int i=0, j=k;\\n            while(i<rows && j<cols) {\\n                decodedText.push_back(cipher[i++][j++]);\\n            }\\n        }\\n        \\n        // Remove trailing spaces\\n        while(decodedText.back() == \\' \\') {\\n            decodedText.pop_back();\\n        }\\n        \\n        return decodedText;\\n    }\\n};\\n```\n```\\nstring decodeCiphertext(string encodedText, int rows) {\\n        \\n\\tint n = encodedText.size();\\n\\tint cols = n / rows;\\n\\n\\tstring decodedText = \"\";\\n\\n\\tfor(int i=0; i < cols; i++) {\\n\\t\\t// Move by distance (col+1) to get next character\\n\\t\\tfor(int j=i; j<n; j += (cols+1)) {\\n\\t\\t\\tdecodedText += encodedText[j];\\n\\t\\t}\\n\\t}\\n\\n\\twhile(decodedText.back() == \\' \\') decodedText.pop_back();\\n\\n\\treturn decodedText;\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1580595,
                "title": "c-straight-forward",
                "content": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string text, int rows) {\\n        int cols = text.length()/rows;\\n        \\n        char** array = new char*[rows];\\n        for(int i = 0; i < rows; i++)\\n            array[i] = new char[cols];\\n        \\n        int index = 0;\\n        for(int i = 0; i < rows; i++) {\\n            for(int j = 0; j < cols; j++) \\n                array[i][j] = text[index++];\\n        }\\n        \\n        string ans = \"\";\\n        for(int i = 0; i < cols; i++) {\\n            int r = 0, c = i;\\n            while(r < rows && c < cols) \\n                ans += array[r++][c++];\\n        }\\n        \\n        if(ans.size() == 0) \\n            return ans;\\n        \\n        while(ans[ans.size()-1] == \\' \\') \\n            ans.pop_back();\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string text, int rows) {\\n        int cols = text.length()/rows;\\n        \\n        char** array = new char*[rows];\\n        for(int i = 0; i < rows; i++)\\n            array[i] = new char[cols];\\n        \\n        int index = 0;\\n        for(int i = 0; i < rows; i++) {\\n            for(int j = 0; j < cols; j++) \\n                array[i][j] = text[index++];\\n        }\\n        \\n        string ans = \"\";\\n        for(int i = 0; i < cols; i++) {\\n            int r = 0, c = i;\\n            while(r < rows && c < cols) \\n                ans += array[r++][c++];\\n        }\\n        \\n        if(ans.size() == 0) \\n            return ans;\\n        \\n        while(ans[ans.size()-1] == \\' \\') \\n            ans.pop_back();\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1576999,
                "title": "javascript-string-builder",
                "content": "```javascript\\nvar decodeCiphertext = function(encodedText, rows) {\\n    const numColumns = encodedText.length / rows;\\n    const stringBuilder = [];\\n    let nextCol = 1;\\n    let row = 0;\\n    let col = 0;\\n    let index = 0\\n    while (index < encodedText.length) {\\n        stringBuilder.push(encodedText[index]);\\n        if (row === rows - 1 || col === numColumns - 1) {\\n            row = 0;\\n            col = nextCol;\\n            nextCol++;\\n        } else {\\n            row++;\\n            col++;\\n        }\\n        index = calcIndex(row, col, numColumns);\\n    }\\n    while (stringBuilder[stringBuilder.length - 1] === \\' \\') {\\n        stringBuilder.pop();\\n    }\\n    return stringBuilder.join(\\'\\');\\n};\\n\\nfunction calcIndex(row, col, numColumns) {\\n    return row * numColumns + col;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "String"
                ],
                "code": "```javascript\\nvar decodeCiphertext = function(encodedText, rows) {\\n    const numColumns = encodedText.length / rows;\\n    const stringBuilder = [];\\n    let nextCol = 1;\\n    let row = 0;\\n    let col = 0;\\n    let index = 0\\n    while (index < encodedText.length) {\\n        stringBuilder.push(encodedText[index]);\\n        if (row === rows - 1 || col === numColumns - 1) {\\n            row = 0;\\n            col = nextCol;\\n            nextCol++;\\n        } else {\\n            row++;\\n            col++;\\n        }\\n        index = calcIndex(row, col, numColumns);\\n    }\\n    while (stringBuilder[stringBuilder.length - 1] === \\' \\') {\\n        stringBuilder.pop();\\n    }\\n    return stringBuilder.join(\\'\\');\\n};\\n\\nfunction calcIndex(row, col, numColumns) {\\n    return row * numColumns + col;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1576924,
                "title": "c-simulation",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n## Solution 1. Simulation\\n\\nSimply traverse the string diagonally. Position `(x, y)` corresponds to `s[y * col + x]`.\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/decode-the-slanted-ciphertext/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(N)\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string s, int row) {\\n        int col = s.size() / row;\\n        string ans;\\n        for (int i = 0; i < col; ++i) { // start from each column\\n            for (int x = i, y = 0; x < col && y < row; ++x, ++y) ans += s[y * col + x]; // traverse the string diagonally\\n        }\\n        while (ans.size() && ans.back() == \\' \\') ans.pop_back();\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/problems/decode-the-slanted-ciphertext/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(N)\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string s, int row) {\\n        int col = s.size() / row;\\n        string ans;\\n        for (int i = 0; i < col; ++i) { // start from each column\\n            for (int x = i, y = 0; x < col && y < row; ++x, ++y) ans += s[y * col + x]; // traverse the string diagonally\\n        }\\n        while (ans.size() && ans.back() == \\' \\') ans.pop_back();\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1688232,
                "title": "simple-and-easy-explained-every-steps",
                "content": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        if(encodedText == \"\")return encodedText;    // base cases\\n        if(rows == 1) return encodedText;           // if rows = 1 simply return\\n        \\n        \\n// create a mat matix where we store our encodedText lineraly row by row as shown in example\\n        // mat\\'s row = rows\\n        // mat\\'s col = encodedText.size() / rows\\n        \\n        vector<vector<char>> mat(rows, vector<char>(encodedText.size() / rows, \\' \\'));\\n        int k = 0;\\n        for(int i = 0; i < mat.size(); i++){\\n            for(int j = 0; j < mat[i].size(); j++){\\n                mat[i][j] = encodedText[k];\\n                k += 1;\\n            }\\n        }\\n        \\n        \\n        \\n        string ret = \"\";\\n        int i = 0;\\n        int col = mat[0].size();\\n        \\n    // now traversing diagonally in mat matix to store answer in ret\\n        while(i != col){\\n            int temp_i = 0;\\n            int temp_j = i;\\n            while(temp_i < rows && temp_j < col){\\n                ret += mat[temp_i][temp_j];\\n                temp_i += 1;\\n                temp_j += 1;\\n            }\\n            i += 1;\\n        }\\n        \\n// erasing tralling space as there are the possibilities that we might find tralling spaces while traversing diagonally \\n        \\n        int last = ret.size() - 1;\\n        while(ret[last] == \\' \\'){\\n            ret.erase(ret.begin() + last);\\n            last -= 1;\\n        }\\n        \\n        return ret;  //returning the decoded string\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        if(encodedText == \"\")return encodedText;    // base cases\\n        if(rows == 1) return encodedText;           // if rows = 1 simply return\\n        \\n        \\n// create a mat matix where we store our encodedText lineraly row by row as shown in example\\n        // mat\\'s row = rows\\n        // mat\\'s col = encodedText.size() / rows\\n        \\n        vector<vector<char>> mat(rows, vector<char>(encodedText.size() / rows, \\' \\'));\\n        int k = 0;\\n        for(int i = 0; i < mat.size(); i++){\\n            for(int j = 0; j < mat[i].size(); j++){\\n                mat[i][j] = encodedText[k];\\n                k += 1;\\n            }\\n        }\\n        \\n        \\n        \\n        string ret = \"\";\\n        int i = 0;\\n        int col = mat[0].size();\\n        \\n    // now traversing diagonally in mat matix to store answer in ret\\n        while(i != col){\\n            int temp_i = 0;\\n            int temp_j = i;\\n            while(temp_i < rows && temp_j < col){\\n                ret += mat[temp_i][temp_j];\\n                temp_i += 1;\\n                temp_j += 1;\\n            }\\n            i += 1;\\n        }\\n        \\n// erasing tralling space as there are the possibilities that we might find tralling spaces while traversing diagonally \\n        \\n        int last = ret.size() - 1;\\n        while(ret[last] == \\' \\'){\\n            ret.erase(ret.begin() + last);\\n            last -= 1;\\n        }\\n        \\n        return ret;  //returning the decoded string\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1588641,
                "title": "simple-python-solution-using-matrix-and-performing-operations-as-given-in-question-brute-force",
                "content": "![image](https://assets.leetcode.com/users/images/f4dad618-812b-4567-acfb-b02c4394eb06_1637437871.282986.png)\\n```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        #print(len(encodedText),rows,len(encodedText)//rows)\\n        if len(encodedText)==0:\\n            return \"\"\\n        ans =\\'\\'\\n        x =[]\\n        c = len(encodedText)//rows\\n        for i in range(0,len(encodedText),c):\\n            x.append(list(encodedText[i:i+c]))\\n        #print(x)\\n        for i in range(c):\\n            k = i\\n            p=\\'\\'\\n            for j in range(rows):\\n                try:\\n                    p = p+x[j][k]\\n                except:\\n                    pass\\n                k = k+1\\n            ans = ans+p\\n        return ans.rstrip()\\n```\\n#  Upvote if useful",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        #print(len(encodedText),rows,len(encodedText)//rows)\\n        if len(encodedText)==0:\\n            return \"\"\\n        ans =\\'\\'\\n        x =[]\\n        c = len(encodedText)//rows\\n        for i in range(0,len(encodedText),c):\\n            x.append(list(encodedText[i:i+c]))\\n        #print(x)\\n        for i in range(c):\\n            k = i\\n            p=\\'\\'\\n            for j in range(rows):\\n                try:\\n                    p = p+x[j][k]\\n                except:\\n                    pass\\n                k = k+1\\n            ans = ans+p\\n        return ans.rstrip()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1578294,
                "title": "java-o-n-solution",
                "content": "```\\nclass Solution {\\n    public String decodeCiphertext(String encodedText, int rows) {\\n        StringBuilder sb = new StringBuilder();\\n        \\n        char[] chars = encodedText.toCharArray();\\n        \\n        int cols = chars.length / rows;\\n        \\n        int i = 0;\\n        int j = 0;\\n        //use this variable to reset j\\'s value.\\n        int counter = 0;\\n        \\n        while (j < cols) {\\n            while (i < rows && j < cols) {\\n                int arrayIndex = i * cols + j;\\n                sb.append(chars[arrayIndex]);\\n                i++;\\n                j++;\\n            }\\n            counter++;\\n            \\n            i = 0;\\n            j = counter;\\n        }\\n        \\n        return removeSpaces(sb).toString();\\n    }\\n    \\n    private StringBuilder removeSpaces(StringBuilder sb) {\\n        if (sb.length() < 1) return sb;\\n        \\n        while(sb.charAt(sb.length() - 1) == \\' \\') {\\n            sb.deleteCharAt(sb.length() - 1);\\n        }\\n        \\n        return sb;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String decodeCiphertext(String encodedText, int rows) {\\n        StringBuilder sb = new StringBuilder();\\n        \\n        char[] chars = encodedText.toCharArray();\\n        \\n        int cols = chars.length / rows;\\n        \\n        int i = 0;\\n        int j = 0;\\n        //use this variable to reset j\\'s value.\\n        int counter = 0;\\n        \\n        while (j < cols) {\\n            while (i < rows && j < cols) {\\n                int arrayIndex = i * cols + j;\\n                sb.append(chars[arrayIndex]);\\n                i++;\\n                j++;\\n            }\\n            counter++;\\n            \\n            i = 0;\\n            j = counter;\\n        }\\n        \\n        return removeSpaces(sb).toString();\\n    }\\n    \\n    private StringBuilder removeSpaces(StringBuilder sb) {\\n        if (sb.length() < 1) return sb;\\n        \\n        while(sb.charAt(sb.length() - 1) == \\' \\') {\\n            sb.deleteCharAt(sb.length() - 1);\\n        }\\n        \\n        return sb;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1577027,
                "title": "java-fast-and-also-memory-efficient",
                "content": "```\\n int column = encodedText.length() / rows;\\n        char[][] array = new char[rows][column];\\n\\n        int counter = 0;\\n        for (int i = 0; i < rows; i++) {\\n            for (int j = 0; j < column; j++) {\\n                array[i][j] = encodedText.charAt(counter);\\n                counter++;\\n            }\\n        }\\n\\n        StringBuilder builder = new StringBuilder();\\n\\n        for (int i = 0; i < column; i++) {\\n            int cnt = i;\\n            for (int j = 0; j < rows; j++) {\\n                if (cnt < column)\\n                    builder.append(array[j][cnt++]);\\n            }\\n        }\\n\\n        String result = builder.toString();\\n\\n        return result.stripTrailing();\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n int column = encodedText.length() / rows;\\n        char[][] array = new char[rows][column];\\n\\n        int counter = 0;\\n        for (int i = 0; i < rows; i++) {\\n            for (int j = 0; j < column; j++) {\\n                array[i][j] = encodedText.charAt(counter);\\n                counter++;\\n            }\\n        }\\n\\n        StringBuilder builder = new StringBuilder();\\n\\n        for (int i = 0; i < column; i++) {\\n            int cnt = i;\\n            for (int j = 0; j < rows; j++) {\\n                if (cnt < column)\\n                    builder.append(array[j][cnt++]);\\n            }\\n        }\\n\\n        String result = builder.toString();\\n\\n        return result.stripTrailing();\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1576933,
                "title": "java-bruteforce-concise-solution",
                "content": "`\\n\\njAVA BRUTE FORCE SOLUTION\\n\\n    public String decodeCiphertext(String str, int rows) {\\n        \\n        if(rows==1) return str;\\n        int num=0;\\n        \\n        int i=0,len=str.length();\\n        int j=0;\\n        int temp=len/rows+1;\\n        if(len%rows!=0) temp++;\\n        \\n        char arr[][]=new char[rows][temp];\\n        while(i<len){\\n            int c=Math.min(temp,len-i);\\n            if(c!=temp){\\n                for(int k=0;k<c;k++){\\n                    arr[j][k]=str.charAt(i+k);\\n                }\\n            }\\n            else{\\n                arr[j++]=str.substring(i,i+temp).toCharArray();\\n            }\\n            \\n            i+=temp;\\n        }\\n        StringBuilder sb=new StringBuilder();\\n        for(i=0;i<temp;i++){\\n            for(j=0;j<rows;j++){\\n                sb.append(arr[j][i]);\\n            }\\n        }\\n        str=sb.toString();\\n        i=str.length()-1;\\n        while(i>=0 && (str.charAt(i)==\\'\\\\u0000\\' || str.charAt(i)==\\' \\')) i--;\\n        return str.substring(0,i+1);\\n    }\\n\\t\\n\\tAPPROACH 2\\n\\t  public String decodeCiphertext(String encodedText, int rows) {\\n        int l = (encodedText.length() % rows == 0) ? encodedText.length()/rows : encodedText.length()/rows + 1;\\n        StringBuilder sb = new StringBuilder();\\n        for (int j = 0; j < l; j++) {     \\n            for (int i = 0; i < rows; i++) {\\n                if (i + j + i * l < encodedText.length())\\n                    sb.append(encodedText.charAt(i + j + i * l));\\n            }\\n        }\\n        return sb.toString().stripTrailing();\\n    }\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "`\\n\\njAVA BRUTE FORCE SOLUTION\\n\\n    public String decodeCiphertext(String str, int rows) {\\n        \\n        if(rows==1) return str;\\n        int num=0;\\n        \\n        int i=0,len=str.length();\\n        int j=0;\\n        int temp=len/rows+1;\\n        if(len%rows!=0) temp++;\\n        \\n        char arr[][]=new char[rows][temp];\\n        while(i<len){\\n            int c=Math.min(temp,len-i);\\n            if(c!=temp){\\n                for(int k=0;k<c;k++){\\n                    arr[j][k]=str.charAt(i+k);\\n                }\\n            }\\n            else{\\n                arr[j++]=str.substring(i,i+temp).toCharArray();\\n            }\\n            \\n            i+=temp;\\n        }\\n        StringBuilder sb=new StringBuilder();\\n        for(i=0;i<temp;i++){\\n            for(j=0;j<rows;j++){\\n                sb.append(arr[j][i]);\\n            }\\n        }\\n        str=sb.toString();\\n        i=str.length()-1;\\n        while(i>=0 && (str.charAt(i)==\\'\\\\u0000\\' || str.charAt(i)==\\' \\')) i--;\\n        return str.substring(0,i+1);\\n    }\\n\\t\\n\\tAPPROACH 2\\n\\t  public String decodeCiphertext(String encodedText, int rows) {\\n        int l = (encodedText.length() % rows == 0) ? encodedText.length()/rows : encodedText.length()/rows + 1;\\n        StringBuilder sb = new StringBuilder();\\n        for (int j = 0; j < l; j++) {     \\n            for (int i = 0; i < rows; i++) {\\n                if (i + j + i * l < encodedText.length())\\n                    sb.append(encodedText.charAt(i + j + i * l));\\n            }\\n        }\\n        return sb.toString().stripTrailing();\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3735249,
                "title": "c-o-1-space-o-n-time-10-lines-easy-approach",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string eT, int rows) {\\n        int n=eT.size();\\n        int col=n/rows;\\n        string s=\"\";\\n        for(int i=0;i<col;i++){\\n            int j=i;\\n            while(j<n){\\n                s+=eT[j];\\n                j=j+col+1;\\n            }\\n        }\\n        while(isspace(s.back())){\\n            s.pop_back();\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string eT, int rows) {\\n        int n=eT.size();\\n        int col=n/rows;\\n        string s=\"\";\\n        for(int i=0;i<col;i++){\\n            int j=i;\\n            while(j<n){\\n                s+=eT[j];\\n                j=j+col+1;\\n            }\\n        }\\n        while(isspace(s.back())){\\n            s.pop_back();\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3645156,
                "title": "beats-90-easy-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nfor encoded text length times traverse diagonally and add it to the result. remove all the trail spaces and return. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ntraverse no of columns times and add characters diagonally (2d array as 1d array method) until it crosses limits. and remove trailing spaces. \\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nPlease upvote if you find it helpful \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        if(encodedText == \"\")  return encodedText; \\n        int columns = ceil(encodedText.length()/rows);\\n        string ans = \"\"; \\n        for(int i=0; i<columns; i++){\\n            int r = 0, c = i; \\n            while(c < columns && r<rows){ ans += encodedText[r*columns + c]; r++; c++;}\\n        }\\n        int len = ans.length(); \\n        while(ans[len-1] == \\' \\') len--;\\n        ans = ans.substr(0, len); \\n\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        if(encodedText == \"\")  return encodedText; \\n        int columns = ceil(encodedText.length()/rows);\\n        string ans = \"\"; \\n        for(int i=0; i<columns; i++){\\n            int r = 0, c = i; \\n            while(c < columns && r<rows){ ans += encodedText[r*columns + c]; r++; c++;}\\n        }\\n        int len = ans.length(); \\n        while(ans[len-1] == \\' \\') len--;\\n        ans = ans.substr(0, len); \\n\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3404765,
                "title": "python3-solution-time-99-33-space-100",
                "content": "![Capture d\\u2019\\xE9cran (96).png](https://assets.leetcode.com/users/images/3e9f8a31-b0d3-4995-ae49-64d20c8c39d1_1681219407.2042663.png)\\n\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def decodeCiphertext(self, encoded_text: str, rows: int) -> str:\\n        if rows == 1:\\n            return encoded_text\\n\\n        N = len(encoded_text)\\n        cols = N // rows\\n        i, j, k = 0, 0, 0\\n        original_text = []\\n\\n        while k < N:\\n            original_text.append(encoded_text[k])\\n            i += 1\\n            if i == rows:\\n                i = 0\\n                j += 1\\n            k = i*(cols + 1) + j\\n\\n        return \\'\\'.join(original_text).rstrip()\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def decodeCiphertext(self, encoded_text: str, rows: int) -> str:\\n        if rows == 1:\\n            return encoded_text\\n\\n        N = len(encoded_text)\\n        cols = N // rows\\n        i, j, k = 0, 0, 0\\n        original_text = []\\n\\n        while k < N:\\n            original_text.append(encoded_text[k])\\n            i += 1\\n            if i == rows:\\n                i = 0\\n                j += 1\\n            k = i*(cols + 1) + j\\n\\n        return \\'\\'.join(original_text).rstrip()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3102251,
                "title": "easy-c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        int m = rows;\\n        int n = (encodedText.length()/rows);\\n        vector<vector<char>> vc(m,vector<char>(n));\\n        int ind = 0;\\n        for(int i=0;i<rows;i++){\\n            for(int j=0;j<n;j++){\\n                vc[i][j]=encodedText[j+ind];\\n            }\\n            ind+=n;\\n        } \\n        string ans = \"\";\\n        for(int j=0;j<n;j++){\\n            int starti = 0;\\n            int startj = j;\\n            while(starti<m && startj<n){\\n                ans+=vc[starti][startj];\\n                starti++;\\n                startj++;\\n            }\\n        }\\n        while(ans.back()==\\' \\') ans.pop_back();\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        int m = rows;\\n        int n = (encodedText.length()/rows);\\n        vector<vector<char>> vc(m,vector<char>(n));\\n        int ind = 0;\\n        for(int i=0;i<rows;i++){\\n            for(int j=0;j<n;j++){\\n                vc[i][j]=encodedText[j+ind];\\n            }\\n            ind+=n;\\n        } \\n        string ans = \"\";\\n        for(int j=0;j<n;j++){\\n            int starti = 0;\\n            int startj = j;\\n            while(starti<m && startj<n){\\n                ans+=vc[starti][startj];\\n                starti++;\\n                startj++;\\n            }\\n        }\\n        while(ans.back()==\\' \\') ans.pop_back();\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2943766,
                "title": "c-2d-index-conversion",
                "content": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string s, int r) {\\n        int c = s.size() / r;\\n        string ans = \"\";\\n        for (int i = 0; i < c; ++i)\\n            ans += findDiagonal(0, i, s, c, r);\\n        while (!ans.empty() && ans.back() == \\' \\') ans.pop_back();\\n        return ans;\\n    }\\n    string findDiagonal(int i, int y, string& s, int& c, int& r){\\n        int nextInd = i * c + y;\\n        if (nextInd >= s.size()) return \"\";\\n        return s[nextInd] + findDiagonal(i + 1, y + 1, s, c, r);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string s, int r) {\\n        int c = s.size() / r;\\n        string ans = \"\";\\n        for (int i = 0; i < c; ++i)\\n            ans += findDiagonal(0, i, s, c, r);\\n        while (!ans.empty() && ans.back() == \\' \\') ans.pop_back();\\n        return ans;\\n    }\\n    string findDiagonal(int i, int y, string& s, int& c, int& r){\\n        int nextInd = i * c + y;\\n        if (nextInd >= s.size()) return \"\";\\n        return s[nextInd] + findDiagonal(i + 1, y + 1, s, c, r);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2724209,
                "title": "c-easy-short",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n   string decodeCiphertext(string e, int rows) {\\n\\t\\tint size=e.size();\\n\\t\\tint col=size/rows;\\n\\t\\tstring ans;\\n\\t\\tfor(int i=0;i<col;i++)\\n\\t\\t{\\n\\t\\t\\tfor(int j=i;j<size;j+=col+1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tans+=e[j];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\twhile (isspace(ans.back()))\\n\\t\\t{\\n\\t\\t\\tans.pop_back();\\n\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   string decodeCiphertext(string e, int rows) {\\n\\t\\tint size=e.size();\\n\\t\\tint col=size/rows;\\n\\t\\tstring ans;\\n\\t\\tfor(int i=0;i<col;i++)\\n\\t\\t{\\n\\t\\t\\tfor(int j=i;j<size;j+=col+1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tans+=e[j];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\twhile (isspace(ans.back()))\\n\\t\\t{\\n\\t\\t\\tans.pop_back();\\n\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2396405,
                "title": "memory-limit-exceeded",
                "content": "If your answer is in string ans.\\ndon\\'t do ans = ans + char\\n\\nThis causes MLE!",
                "solutionTags": [
                    "C"
                ],
                "code": "If your answer is in string ans.\\ndon\\'t do ans = ans + char\\n\\nThis causes MLE!",
                "codeTag": "Unknown"
            },
            {
                "id": 2034993,
                "title": "javascript-solution-simulation",
                "content": "```\\nvar decodeCiphertext = function(encodedText, rows) {\\n    const n = encodedText.length;\\n    const cols = n / rows;\\n    let res = \"\";\\n    \\n    for (let i = 0; i < cols; ++i) {\\n        let str = \"\";\\n        \\n        let row = 0;\\n        let col = i % cols;\\n        \\n        while (row < rows && col < cols) {\\n            const idx = (row * cols) + col;\\n            \\n            str += encodedText.charAt(idx);\\n            \\n            row += 1;\\n            col += 1;\\n        }\\n        \\n        res += str;\\n    }\\n\\n    return res.trimEnd();\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Simulation"
                ],
                "code": "```\\nvar decodeCiphertext = function(encodedText, rows) {\\n    const n = encodedText.length;\\n    const cols = n / rows;\\n    let res = \"\";\\n    \\n    for (let i = 0; i < cols; ++i) {\\n        let str = \"\";\\n        \\n        let row = 0;\\n        let col = i % cols;\\n        \\n        while (row < rows && col < cols) {\\n            const idx = (row * cols) + col;\\n            \\n            str += encodedText.charAt(idx);\\n            \\n            row += 1;\\n            col += 1;\\n        }\\n        \\n        res += str;\\n    }\\n\\n    return res.trimEnd();\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1813633,
                "title": "c-solution-with-simple-explanation-diagonal-traversal",
                "content": "Idea: - Its given in Question that matrix would be filled up till last coloumn and we will always be starting from (0,0) ,and we are given encrypted string and rows . we will find no of cols then  firstly we will construct a 2D matrix and fill our encypted string just as shown in question\\'s pic . Then we will traverse it diagonally and construct our orignal string . In the last step we will remove extra spaces at end of orignal string\\n\\n\\n**Step 1 :** To find no of cols , its basically length of encypted string / rows .(because we know from question that filling would start from (0,0) and go uptill last col for sure )\\n\\n**Step 2 :**  Now we will fill our encypted string in that matrix . Will fill first row then move to second row and continue this uptill last row\\n\\n**Step 3 :** -  Now all we need to do is traverse diagonally and start building up our orignal string .lets see this step in detail . eg we need to traverse  matrix of row=4 , col=6 (example of I love leetcoding matrix given in question)\\n\\n(0,0)  -> (1,1) -> (2,2) -> (3,3)\\n(0,1)  -> (1,2) -> (2,3) -> (3,4)\\n(0,2)  -> (1,3) -> (2,4) -> (3,5)\\n(0,3)  -> (1,4) -> (2,5)\\n(0,4)  -> (1,5)\\n(0,5)\\n\\nHere we clearly see we need to do 6 iteration (or we can say no of iteration=no of cols), and in every iteration ith index will start from 0 and go at max till no of rows -1 , jth index starts 0 in first iteration , from 1 in second iteration and will go at max till col-1 . Now we just need to write that in code \\n\\n\\n\\n```\\nstring decodeCiphertext(string encodedText, int rows) \\n    {\\n      int n=encodedText.size();\\n\\t  \\n\\t  // finding no of cols (Step 1)\\n\\t  \\n      int col=n/rows;\\n      \\n      // creating 2D matrix  (Step 2)\\n\\t  \\n      vector<vector<char>>matrix(rows,vector<char>(col));\\n      \\n      int index=0;\\n\\t  \\n\\t  // Filling 2D matrix (Step 2)\\n\\t  \\n      for(int i=0;i<rows;i++)\\n      {\\n        for(int j=0;j<col;j++)\\n        {\\n          matrix[i][j]=encodedText[index++];\\n        }\\n      }\\n      \\n\\t  \\n\\t  // Traversing diagonally (Step 3)\\n\\t  \\n      string ans=\"\";\\n\\t  \\n      for(int j = 0; j < col; j++) \\n      {\\n            int r = 0;\\n            int c = j;\\n            while(c < col and r < rows) \\n            {\\n                ans += matrix[r++][c++];\\n            }\\n      }\\n      \\n     \\n\\t // Last Step (Removing extra spaces from our orignal string)\\n\\t \\n     while (!ans.empty() && ans.back() == \\' \\') \\n     {\\n            ans.pop_back();\\n     }\\n      \\n      return ans;\\n      \\n\\n      \\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nstring decodeCiphertext(string encodedText, int rows) \\n    {\\n      int n=encodedText.size();\\n\\t  \\n\\t  // finding no of cols (Step 1)\\n\\t  \\n      int col=n/rows;\\n      \\n      // creating 2D matrix  (Step 2)\\n\\t  \\n      vector<vector<char>>matrix(rows,vector<char>(col));\\n      \\n      int index=0;\\n\\t  \\n\\t  // Filling 2D matrix (Step 2)\\n\\t  \\n      for(int i=0;i<rows;i++)\\n      {\\n        for(int j=0;j<col;j++)\\n        {\\n          matrix[i][j]=encodedText[index++];\\n        }\\n      }\\n      \\n\\t  \\n\\t  // Traversing diagonally (Step 3)\\n\\t  \\n      string ans=\"\";\\n\\t  \\n      for(int j = 0; j < col; j++) \\n      {\\n            int r = 0;\\n            int c = j;\\n            while(c < col and r < rows) \\n            {\\n                ans += matrix[r++][c++];\\n            }\\n      }\\n      \\n     \\n\\t // Last Step (Removing extra spaces from our orignal string)\\n\\t \\n     while (!ans.empty() && ans.back() == \\' \\') \\n     {\\n            ans.pop_back();\\n     }\\n      \\n      return ans;\\n      \\n\\n      \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1776864,
                "title": "js-simple-solution-easy-to-understand",
                "content": "```\\nvar decodeCiphertext = function(encodedText, rows) {\\n    if(encodedText.length == 0)\\n        return \"\"\\n    var mat= [];\\n    var n=(encodedText.length/rows);\\n    var temp = [];\\n    for(var i=0, c=1; i<encodedText.length; i++, c++)\\n        {\\n            temp.push(encodedText[i]);\\n            if(c == n)\\n                {\\n                    mat.push(temp);\\n                    c=0;\\n                    temp = [];\\n                }\\n        }\\n    var output = \"\";\\n    for(var i=0; i<mat[0].length; i++)\\n        {\\n            var r=0, c=i;\\n            while(r<mat.length && c<mat[0].length)\\n                {\\n                    output+=mat[r++][c++];\\n                }\\n        }\\n    return output.trimEnd();\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar decodeCiphertext = function(encodedText, rows) {\\n    if(encodedText.length == 0)\\n        return \"\"\\n    var mat= [];\\n    var n=(encodedText.length/rows);\\n    var temp = [];\\n    for(var i=0, c=1; i<encodedText.length; i++, c++)\\n        {\\n            temp.push(encodedText[i]);\\n            if(c == n)\\n                {\\n                    mat.push(temp);\\n                    c=0;\\n                    temp = [];\\n                }\\n        }\\n    var output = \"\";\\n    for(var i=0; i<mat[0].length; i++)\\n        {\\n            var r=0, c=i;\\n            while(r<mat.length && c<mat[0].length)\\n                {\\n                    output+=mat[r++][c++];\\n                }\\n        }\\n    return output.trimEnd();\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1753881,
                "title": "python",
                "content": "```\\nclass Solution:\\n    def decodeCiphertext(self, s: str, rows: int) -> str:\\n        if not s: return \"\"\\n        n=len(s)\\n        cols=n//rows\\n        arr=[\" \"]*n\\n        for i in range(rows):\\n            for j in range(cols):\\n                if i>j: continue\\n                arr[i+rows*(j-i)]=s[i*cols+j]\\n        i=n-1\\n        while i>=0 and arr[i]==\" \":\\n            i-=1\\n        return \\'\\'.join(arr[:i+1])\\n            \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def decodeCiphertext(self, s: str, rows: int) -> str:\\n        if not s: return \"\"\\n        n=len(s)\\n        cols=n//rows\\n        arr=[\" \"]*n\\n        for i in range(rows):\\n            for j in range(cols):\\n                if i>j: continue\\n                arr[i+rows*(j-i)]=s[i*cols+j]\\n        i=n-1\\n        while i>=0 and arr[i]==\" \":\\n            i-=1\\n        return \\'\\'.join(arr[:i+1])\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1682589,
                "title": "easy-cpp-col-1-jumps",
                "content": "```\\ncommented for better explanation , tried best to deliver the concept of code\\n```\\n```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string s, int rows) \\n    {\\n        // to find the col of the table we are doing this \\n        int sz = s.size();\\n        int col = sz/rows;\\n        // we move till col and add the chars using col+1 jumps on full string \\n        string ans;\\n        for(int i=0;i<col;i++)\\n        {\\n            for(int j=i;j<sz;j+=col+1)\\n            {\\n                ans+=s[j];\\n               \\n            }\\n        }\\n        // at last we will left with some spaces , to clear we make this \\n        // to return our result correct \\n        while(!ans.empty() and ans.back()==\\' \\')\\n        {\\n            ans.pop_back();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\ncommented for better explanation , tried best to deliver the concept of code\\n```\n```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string s, int rows) \\n    {\\n        // to find the col of the table we are doing this \\n        int sz = s.size();\\n        int col = sz/rows;\\n        // we move till col and add the chars using col+1 jumps on full string \\n        string ans;\\n        for(int i=0;i<col;i++)\\n        {\\n            for(int j=i;j<sz;j+=col+1)\\n            {\\n                ans+=s[j];\\n               \\n            }\\n        }\\n        // at last we will left with some spaces , to clear we make this \\n        // to return our result correct \\n        while(!ans.empty() and ans.back()==\\' \\')\\n        {\\n            ans.pop_back();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1627031,
                "title": "python3-260ms-runtime-faster-than-96-and-uses-91-less-memory",
                "content": "`Execution Result`\\n\\n```\\nRuntime: 260 ms, faster than 96.14% of Python3 online submissions for Decode the Slanted Ciphertext.\\nMemory Usage: 26.8 MB, less than 91.49% of Python3 online submissions for Decode the Slanted Ciphertext.\\n```\\n\\n`Code`\\n```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        op = \\'\\'\\n        total_cols = int(   len(encodedText) / rows )\\n        row = 0\\n        col = 0\\n        while True:\\n            try:\\n                calc = (row*total_cols)+row+col\\n                char = encodedText[calc]\\n            except IndexError:\\n                break\\n            op += char\\n            row+=1\\n            if row == rows:\\n                row = 0\\n                col+=1\\n        return op.rstrip()\\n```\\n\\n`Tests`\\n```\\nprint(Solution().decodeCiphertext(encodedText = \"ch   ie   pr\", rows = 3))\\nprint(Solution().decodeCiphertext(encodedText = \"iveo    eed   l te   olc\", rows = 4))\\nprint(Solution().decodeCiphertext(encodedText = \"coding\", rows = 1))\\nprint(Solution().decodeCiphertext(encodedText = \" b  ac\", rows = 2))\\nprint(Solution().decodeCiphertext(\"wmihfwf bddhzaizuzhbuoovyyjstardqceaqzafdzihjbj ywly amkeemr jmvsfaavbpgiafgxzciwmrrtasthc hqfrtwoizoilw\", 2)  )\\nN = pow(10, 6)\\nimport random, string\\nprint(Solution().decodeCiphertext(encodedText = \\'\\'.join(random.choices(string.ascii_lowercase + \\' \\', k=N)), rows = pow(10, 3)))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nRuntime: 260 ms, faster than 96.14% of Python3 online submissions for Decode the Slanted Ciphertext.\\nMemory Usage: 26.8 MB, less than 91.49% of Python3 online submissions for Decode the Slanted Ciphertext.\\n```\n```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        op = \\'\\'\\n        total_cols = int(   len(encodedText) / rows )\\n        row = 0\\n        col = 0\\n        while True:\\n            try:\\n                calc = (row*total_cols)+row+col\\n                char = encodedText[calc]\\n            except IndexError:\\n                break\\n            op += char\\n            row+=1\\n            if row == rows:\\n                row = 0\\n                col+=1\\n        return op.rstrip()\\n```\n```\\nprint(Solution().decodeCiphertext(encodedText = \"ch   ie   pr\", rows = 3))\\nprint(Solution().decodeCiphertext(encodedText = \"iveo    eed   l te   olc\", rows = 4))\\nprint(Solution().decodeCiphertext(encodedText = \"coding\", rows = 1))\\nprint(Solution().decodeCiphertext(encodedText = \" b  ac\", rows = 2))\\nprint(Solution().decodeCiphertext(\"wmihfwf bddhzaizuzhbuoovyyjstardqceaqzafdzihjbj ywly amkeemr jmvsfaavbpgiafgxzciwmrrtasthc hqfrtwoizoilw\", 2)  )\\nN = pow(10, 6)\\nimport random, string\\nprint(Solution().decodeCiphertext(encodedText = \\'\\'.join(random.choices(string.ascii_lowercase + \\' \\', k=N)), rows = pow(10, 3)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1606713,
                "title": "simple-and-very-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        int n = encodedText.size();\\n        int col = n/rows;  //bcs n = rows*cols(always) -> observation\\n        string res;\\n        for(int i=0;i<col;i++){\\n            for(int j=i; j<n; j+=(col+1)) //we can observe that to travel diagonallly we have to increamnt by (col+1)\\n                res += (encodedText[j]);\\n        }\\n        while(res.back() == \\' \\') res.pop_back();\\n        \\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        int n = encodedText.size();\\n        int col = n/rows;  //bcs n = rows*cols(always) -> observation\\n        string res;\\n        for(int i=0;i<col;i++){\\n            for(int j=i; j<n; j+=(col+1)) //we can observe that to travel diagonallly we have to increamnt by (col+1)\\n                res += (encodedText[j]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1592079,
                "title": "golang-solution-with-explanation",
                "content": "The main idea of this solution is to find the number of columns. The solution comes together pretty quickly after that.\\n\\nTo explain my thinking to how I found the number of columns we have to take a matrix. We should know the number rows and columns in that matrix. For example:\\n\\n`[a][d][g][ ]`\\n`[ ][b][e][h]`\\n`[ ][ ][c][f]`\\n\\nWe have a matrix with 3 rows and 4 columns, and 12 items. `3 * 4 = 12`, so if we are given a matrix of size 12 and 3 rows, we can do `12 / 3 = 4` to get the number of columns. Since we know that the number of values in the matrix can be shown using `len(encodedText)` and the problem gives us the number of rows, we can do `len(encodedText) / rows = cols`.\\n\\nThen all we have to do is add all the letters in a particular order.\\n\\nNote that `res` is not a `string` because that will output a TLE.\\n\\n``` go\\nfunc decodeCiphertext(encodedText string, rows int) string {\\n    n := len(encodedText)\\n    cols := n / rows\\n    res := []string{}\\n    \\n    for i := 0; i < cols; i++ {\\n        for j := i; j < n; j += cols + 1 {\\n            res = append(res, string(encodedText[j]))\\n        }\\n    }\\n    \\n    return strings.TrimRight(strings.Join(res, \"\"), \" \")\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "``` go\\nfunc decodeCiphertext(encodedText string, rows int) string {\\n    n := len(encodedText)\\n    cols := n / rows\\n    res := []string{}\\n    \\n    for i := 0; i < cols; i++ {\\n        for j := i; j < n; j += cols + 1 {\\n            res = append(res, string(encodedText[j]))\\n        }\\n    }\\n    \\n    return strings.TrimRight(strings.Join(res, \"\"), \" \")\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1584499,
                "title": "python3-solution-time-o-n-space-o-1",
                "content": "Python3 Solution\\n\\n```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        cols = len(encodedText)//rows\\n        total_index = cols*rows\\n        final_str = \"\"\\n        for i in range(cols):\\n            cur_ind = i\\n            \\n            while cur_ind < total_index:\\n                final_str += encodedText[cur_ind]\\n                cur_ind += cols+1\\n                \\n\\n            \\n        return final_str.rstrip()\\n```\\n\\nTime Complexity: O(n)\\nSpace Complexity: O(1)",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        cols = len(encodedText)//rows\\n        total_index = cols*rows\\n        final_str = \"\"\\n        for i in range(cols):\\n            cur_ind = i\\n            \\n            while cur_ind < total_index:\\n                final_str += encodedText[cur_ind]\\n                cur_ind += cols+1\\n                \\n\\n            \\n        return final_str.rstrip()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1580159,
                "title": "c-o-n-solution",
                "content": "**Example:**\\n```\\n// \\'_\\' - space\\n// encodedText = \"c h _ _ _ i e _ _ _ p r\",  encodedLength = 12, rows = 3, \\n// columns = encodedText.Length/rows = 4\\n// encodedText[0] = c\\n// encodedText[5] = i\\n// encodedText[10] = p\\n// encodedText[1] = h\\n// encodedText[6] = e\\n// encodedText[11] = r\\n// encodedText[2] = _  \\n// encodedText[7] = _\\n// encodedText[3] = _\\nHere we can see pattern - 0, 5, 10, 1, 6, 11, ...\\n```\\n\\n**Solution with array:**\\n\\n```\\n\\tpublic string DecodeCiphertext(string encodedText, int rows) {\\n        if (rows == 1 || encodedText.Length == 0)\\n            return encodedText;\\n        \\n        int columns = encodedText.Length / rows;\\n        int offset = columns+1; \\n        var decodedArr = new char[encodedText.Length];\\n        var decodedIndex = 0;\\n        var lastLetterIndex = 0;\\n        for (int start=0; start<columns; start++) \\n        {\\n            for (int index = start; index < encodedText.Length; index += offset) \\n            {\\n                decodedArr[decodedIndex] = encodedText[index];\\n                if (Char.IsLower(decodedArr[decodedIndex]))\\n                    lastLetterIndex = decodedIndex;\\n                decodedIndex++;\\n            }\\n        }\\n        return new string(decodedArr, 0, lastLetterIndex+1); // remove all trailing spaces\\n    }\\n```\\n\\n**Solution with StringBuilder:**\\n```\\n\\tpublic string DecodeCiphertext(string encodedText, int rows) {\\n        if (rows == 1 || encodedText.Length == 0)\\n            return encodedText;\\n        \\n        var sb = new StringBuilder(encodedText.Length);\\n        int columns = encodedText.Length / rows;\\n        int offset = columns+1;\\n        for (int start=0; start<columns; start++) \\n            for (int index = start; index < encodedText.Length; index += offset) \\n                sb.Append(encodedText[index]);\\n        \\n        return sb.ToString().TrimEnd();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n// \\'_\\' - space\\n// encodedText = \"c h _ _ _ i e _ _ _ p r\",  encodedLength = 12, rows = 3, \\n// columns = encodedText.Length/rows = 4\\n// encodedText[0] = c\\n// encodedText[5] = i\\n// encodedText[10] = p\\n// encodedText[1] = h\\n// encodedText[6] = e\\n// encodedText[11] = r\\n// encodedText[2] = _  \\n// encodedText[7] = _\\n// encodedText[3] = _\\nHere we can see pattern - 0, 5, 10, 1, 6, 11, ...\\n```\n```\\n\\tpublic string DecodeCiphertext(string encodedText, int rows) {\\n        if (rows == 1 || encodedText.Length == 0)\\n            return encodedText;\\n        \\n        int columns = encodedText.Length / rows;\\n        int offset = columns+1; \\n        var decodedArr = new char[encodedText.Length];\\n        var decodedIndex = 0;\\n        var lastLetterIndex = 0;\\n        for (int start=0; start<columns; start++) \\n        {\\n            for (int index = start; index < encodedText.Length; index += offset) \\n            {\\n                decodedArr[decodedIndex] = encodedText[index];\\n                if (Char.IsLower(decodedArr[decodedIndex]))\\n                    lastLetterIndex = decodedIndex;\\n                decodedIndex++;\\n            }\\n        }\\n        return new string(decodedArr, 0, lastLetterIndex+1); // remove all trailing spaces\\n    }\\n```\n```\\n\\tpublic string DecodeCiphertext(string encodedText, int rows) {\\n        if (rows == 1 || encodedText.Length == 0)\\n            return encodedText;\\n        \\n        var sb = new StringBuilder(encodedText.Length);\\n        int columns = encodedText.Length / rows;\\n        int offset = columns+1;\\n        for (int start=0; start<columns; start++) \\n            for (int index = start; index < encodedText.Length; index += offset) \\n                sb.Append(encodedText[index]);\\n        \\n        return sb.ToString().TrimEnd();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1580075,
                "title": "c-diagonal-traversal-o-n-time-space",
                "content": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        string res = \"\";\\n        int n = encodedText.size();\\n        int cols = n / rows;\\n        vector<vector<char>> v(rows, vector<char>(cols));\\n        for(int i=0; i<rows; i++){\\n            for(int j=0; j<cols; j++){\\n                v[i][j] = encodedText[i*cols + j];\\n            }\\n        }\\n        for(int g=0; g<cols; g++){\\n            for(int i=0, j=i+g; i<rows && j<cols; i++, j++){\\n                res += v[i][j];\\n            }\\n        }\\n        int l = res.length();\\n        while(l > 0 && res[l-1] == \\' \\'){\\n            res.pop_back();\\n            l--;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        string res = \"\";\\n        int n = encodedText.size();\\n        int cols = n / rows;\\n        vector<vector<char>> v(rows, vector<char>(cols));\\n        for(int i=0; i<rows; i++){\\n            for(int j=0; j<cols; j++){\\n                v[i][j] = encodedText[i*cols + j];\\n            }\\n        }\\n        for(int g=0; g<cols; g++){\\n            for(int i=0, j=i+g; i<rows && j<cols; i++, j++){\\n                res += v[i][j];\\n            }\\n        }\\n        int l = res.length();\\n        while(l > 0 && res[l-1] == \\' \\'){\\n            res.pop_back();\\n            l--;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1579817,
                "title": "python-simple-solution",
                "content": "```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        n = len(encodedText)\\n        res = []\\n        cols = n // rows\\n        \\n        for i in range(cols):\\n            for j in range(i, n, cols+1):\\n                res.append(encodedText[j])  # it is observed that skipping cols+1 from a given pos gives the required char\\n                \\n        return \\'\\'.join(res).rstrip(\\' \\')  # removes trailing spaces from right\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        n = len(encodedText)\\n        res = []\\n        cols = n // rows\\n        \\n        for i in range(cols):\\n            for j in range(i, n, cols+1):\\n                res.append(encodedText[j])  # it is observed that skipping cols+1 from a given pos gives the required char\\n                \\n        return \\'\\'.join(res).rstrip(\\' \\')  # removes trailing spaces from right\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1578286,
                "title": "python-2-approaches",
                "content": "Python O(n**2) / O(n) - matrix construction\\n```\\nclass Solution:\\n    def generate_matrix(self, s, rows, cols, N):\\n        i = 0\\n        m = [[None] * cols for _ in range(rows)]\\n        for r in range(rows):\\n            for c in range(cols):\\n                m[r][c] = s[i]\\n                i += 1\\n                if i >= N: return m\\n                \\n    def decipher_by_matrix(self, m, rows, cols, N):\\n        i = 0        \\n        result = []\\n        \\n        for c in range(cols):\\n            ci, ri = c, 0\\n            if i >= N: return result  \\n            while ci < cols and ri < rows and i < N:\\n                result.append(m[ri][ci])\\n                ri += 1\\n                ci += 1\\n                i += 1\\n                \\n        return result  \\n    \\n    def decodeCiphertext(self, s: str, rows: int) -> str:\\n        N = len(s)        \\n        cols = N // rows\\n        \\n        m = self.generate_matrix(s, rows, cols, N)                \\n        result = self.decipher_by_matrix(m, rows, cols, N)\\n                                    \\n        return \\'\\'.join(result).rstrip()\\n```\\n\\nPython O(n)/O(1)\\n```\\nclass Solution:\\n    def decodeCiphertext(self, s, rows):\\n        cols, N, result = len(s) // rows, len(s), []\\n        for col in range(cols):\\n            for move in range(col, N, cols + 1):\\n                result.append(s[move])                \\n        return \\'\\'.join(result).rstrip()\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def generate_matrix(self, s, rows, cols, N):\\n        i = 0\\n        m = [[None] * cols for _ in range(rows)]\\n        for r in range(rows):\\n            for c in range(cols):\\n                m[r][c] = s[i]\\n                i += 1\\n                if i >= N: return m\\n                \\n    def decipher_by_matrix(self, m, rows, cols, N):\\n        i = 0        \\n        result = []\\n        \\n        for c in range(cols):\\n            ci, ri = c, 0\\n            if i >= N: return result  \\n            while ci < cols and ri < rows and i < N:\\n                result.append(m[ri][ci])\\n                ri += 1\\n                ci += 1\\n                i += 1\\n                \\n        return result  \\n    \\n    def decodeCiphertext(self, s: str, rows: int) -> str:\\n        N = len(s)        \\n        cols = N // rows\\n        \\n        m = self.generate_matrix(s, rows, cols, N)                \\n        result = self.decipher_by_matrix(m, rows, cols, N)\\n                                    \\n        return \\'\\'.join(result).rstrip()\\n```\n```\\nclass Solution:\\n    def decodeCiphertext(self, s, rows):\\n        cols, N, result = len(s) // rows, len(s), []\\n        for col in range(cols):\\n            for move in range(col, N, cols + 1):\\n                result.append(s[move])                \\n        return \\'\\'.join(result).rstrip()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1578283,
                "title": "python-solution-with-explanation-approach",
                "content": "First we need to understand the format in which the encrypted answer is given. We get it in the length of (math.ceil(len(encodedText)/rows)).\\nNow just start 2 for loops. One for the ith element and the other for the row. \\nIf we visualize it becomes,\\nFIrst word first letter, Second Word second letter, Third word third letter till end\\nThen the next time it\\'s First word second letter, second word third letter and so on.\\n\\n\\n\\n```\\ndef decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        n = (math.ceil(len(encodedText)/rows))\\n        if rows==1:\\n            return encodedText\\n        if n==0:\\n            return \"\"\\n        out = [(encodedText[i:i+n]) for i in range(0, len(encodedText), n)]\\n        res = \"\"\\n        for i in range(n):\\n            for j in range(0,rows):\\n                try:\\n                    if j+i<=n:\\n                        res += out[j][j+i]\\n                    else:\\n                        return res\\n                except:\\n                    return res.rstrip()\\n\\t```\\n\\t\\n\\tNot the best explaination but I learning how to explain my approach to others. Do ask if any doubt.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        n = (math.ceil(len(encodedText)/rows))\\n        if rows==1:\\n            return encodedText\\n        if n==0:\\n            return \"\"\\n        out = [(encodedText[i:i+n]) for i in range(0, len(encodedText), n)]\\n        res = \"\"\\n        for i in range(n):\\n            for j in range(0,rows):\\n                try:\\n                    if j+i<=n:\\n                        res += out[j][j+i]\\n                    else:\\n                        return res\\n                except:\\n                    return res.rstrip()\\n\\t```",
                "codeTag": "Python3"
            },
            {
                "id": 1577063,
                "title": "python3-simulation",
                "content": "Please check out this [commit](https://github.com/gaosanyong/leetcode/commit/8d693371fa97ea3b0717d02448c77201b15e5d12) for solutions of weekly 267.\\n```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        cols = len(encodedText)//rows\\n        ans = []\\n        for offset in range(cols): \\n            i, j = 0, offset\\n            while i*cols+j < len(encodedText): \\n                ans.append(encodedText[i*cols+j])\\n                i, j = i+1, j+1\\n        return \"\".join(ans).rstrip()\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        cols = len(encodedText)//rows\\n        ans = []\\n        for offset in range(cols): \\n            i, j = 0, offset\\n            while i*cols+j < len(encodedText): \\n                ans.append(encodedText[i*cols+j])\\n                i, j = i+1, j+1\\n        return \"\".join(ans).rstrip()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1576987,
                "title": "c-2075-decode-the-slanted-ciphertext",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        int cols = encodedText.size() / rows; \\n        string ans; \\n        for (int offset = 0; offset < cols; ++offset) \\n            for (int i = 0, j = offset;  i*cols+j < encodedText.size(); ++i, ++j) \\n                ans.push_back(encodedText[i*cols+j]); \\n        return ans.substr(0, 1+ans.find_last_not_of(\\' \\')); \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        int cols = encodedText.size() / rows; \\n        string ans; \\n        for (int offset = 0; offset < cols; ++offset) \\n            for (int i = 0, j = offset;  i*cols+j < encodedText.size(); ++i, ++j) \\n                ans.push_back(encodedText[i*cols+j]); \\n        return ans.substr(0, 1+ans.find_last_not_of(\\' \\')); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1576961,
                "title": "c-easy-simple-iterate",
                "content": "1) Just create matrix from given encoded text.\\n2) Iterate Diagonally\\n\\nNote : the number of column is **ceil value of (size of given string / given rows)**\\n```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string s, int r) {\\n        int c = s.size()/r + (s.size()%r!=0);\\n        vector<vector<char>>vc(r,vector<char>(c));\\n        int row = -1 , col = -1;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(i%c==0)\\n            {\\n                row++;\\n                col=0;\\n            }\\n            vc[row][col++] = s[i];\\n        }\\n        \\n//         for(int i=0;i<r;i++)\\n//         {\\n//             for(int j=0;j<c;j++)\\n//             {\\n//                 cout<<vc[i][j];\\n    \\n//             }\\n//             cout<<endl;\\n//         }\\n        string ans = \"\";\\n        int column=0;\\n        while(column<c)\\n        {\\n            int crRow = 0;\\n            int crCol = column;\\n            while(crRow<r and crCol<c)\\n            {\\n                ans+=vc[crRow++][crCol++];\\n            }\\n            column++;\\n        }\\n        while(ans.back()==\\' \\')\\n            ans.pop_back();\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string s, int r) {\\n        int c = s.size()/r + (s.size()%r!=0);\\n        vector<vector<char>>vc(r,vector<char>(c));\\n        int row = -1 , col = -1;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(i%c==0)\\n            {\\n                row++;\\n                col=0;\\n            }\\n            vc[row][col++] = s[i];\\n        }\\n        \\n//         for(int i=0;i<r;i++)\\n//         {\\n//             for(int j=0;j<c;j++)\\n//             {\\n//                 cout<<vc[i][j];\\n    \\n//             }\\n//             cout<<endl;\\n//         }\\n        string ans = \"\";\\n        int column=0;\\n        while(column<c)\\n        {\\n            int crRow = 0;\\n            int crCol = column;\\n            while(crRow<r and crCol<c)\\n            {\\n                ans+=vc[crRow++][crCol++];\\n            }\\n            column++;\\n        }\\n        while(ans.back()==\\' \\')\\n            ans.pop_back();\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1576940,
                "title": "simple-python-solution",
                "content": "```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        cols = len(encodedText)//rows\\n        \\n        ans = \"\"\\n        \\n        # Iterate over each index of first row\\n        for i in range(cols):\\n            # Keep adding letters with an interval of (cols+1) (diagonally) till you reach the end of the matrix\\n            for j in range(i, rows*cols, cols+1):\\n                ans += encodedText[j]\\n        \\n        # Remove the trailing spaces\\n        return ans.rstrip()\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        cols = len(encodedText)//rows\\n        \\n        ans = \"\"\\n        \\n        # Iterate over each index of first row\\n        for i in range(cols):\\n            # Keep adding letters with an interval of (cols+1) (diagonally) till you reach the end of the matrix\\n            for j in range(i, rows*cols, cols+1):\\n                ans += encodedText[j]\\n        \\n        # Remove the trailing spaces\\n        return ans.rstrip()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1576938,
                "title": "c-straightforward-solution",
                "content": "\\n\\nGet col number with `encodedText.size() / rows` and then re-construct the answer with the rules.\\n\\n```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        int cols = encodedText.size() / rows;\\n        string ans;\\n        for(int i = 0; i < cols; i++) {\\n            for(int j = 0; j < rows; j++) {\\n                int idx = j * cols + j + i;\\n                if(idx >= encodedText.size()) break;\\n                ans += encodedText[idx];\\n            }\\n        }\\n        while(ans.back() == \\' \\' && ans.size())ans.pop_back();\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        int cols = encodedText.size() / rows;\\n        string ans;\\n        for(int i = 0; i < cols; i++) {\\n            for(int j = 0; j < rows; j++) {\\n                int idx = j * cols + j + i;\\n                if(idx >= encodedText.size()) break;\\n                ans += encodedText[idx];\\n            }\\n        }\\n        while(ans.back() == \\' \\' && ans.size())ans.pop_back();\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1576915,
                "title": "java-iterate-diagonally",
                "content": "```\\nclass Solution {\\n    public String decodeCiphertext(String str, int rows) {\\n\\n        //first find column size!!\\n    \\tint cols=str.length()/rows;\\n    \\tStringBuilder res=new StringBuilder(),new_res=new StringBuilder();;\\n    \\tfor(int i=0;i<cols;i++) {\\n        \\n            //iterating diagonally!!\\n            for(int j=i;j<str.length();j+=cols+1)\\n    \\t\\t\\tres.append(str.charAt(j));\\n    \\t}\\n        \\n        //removing last spaces!!!\\n        int fg=0;\\n        for(int i=res.length()-1;i>=0;i--) {\\n            \\n            if(fg==0&&res.charAt(i)==\\' \\')\\n                continue;\\n            fg=1;\\n            new_res.append(res.charAt(i));\\n        }\\n        return new_res.reverse().toString();\\n    }\\n}\\n````",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String decodeCiphertext(String str, int rows) {\\n\\n        //first find column size!!\\n    \\tint cols=str.length()/rows;\\n    \\tStringBuilder res=new StringBuilder(),new_res=new StringBuilder();;\\n    \\tfor(int i=0;i<cols;i++) {\\n        \\n            //iterating diagonally!!\\n            for(int j=i;j<str.length();j+=cols+1)\\n    \\t\\t\\tres.append(str.charAt(j));\\n    \\t}\\n        \\n        //removing last spaces!!!\\n        int fg=0;\\n        for(int i=res.length()-1;i>=0;i--) {\\n            \\n            if(fg==0&&res.charAt(i)==\\' \\')\\n                continue;\\n            fg=1;\\n            new_res.append(res.charAt(i));\\n        }\\n        return new_res.reverse().toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4063729,
                "title": "simple-simulation-python",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        c=ceil(len(encodedText)/rows)\\n        ans=\"\"\\n        for i in range(c):\\n            j=0\\n            while(i+j<len(encodedText)):\\n                ans+=encodedText[i+j]\\n                j+=c+1\\n        i=len(ans)-1\\n        while(i>=0):\\n            if(ans[i]==\\' \\'):\\n                i-=1\\n            else: break\\n\\n        return ans[:i+1]\\n```",
                "solutionTags": [
                    "Python3",
                    "String",
                    "Simulation"
                ],
                "code": "```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        c=ceil(len(encodedText)/rows)\\n        ans=\"\"\\n        for i in range(c):\\n            j=0\\n            while(i+j<len(encodedText)):\\n                ans+=encodedText[i+j]\\n                j+=c+1\\n        i=len(ans)-1\\n        while(i>=0):\\n            if(ans[i]==\\' \\'):\\n                i-=1\\n            else: break\\n\\n        return ans[:i+1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3872331,
                "title": "step-by-step-beginner-s-friendly-explanation",
                "content": "# Complexity\\n- Time complexity: $$O(n^2)$$ \\n\\n- Space complexity: $$O(n^2)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n\\n     //step 1 : find no. of columns needed in the matrix\\n     int cols = encodedText.length()/rows;\\n     string ans = \"\"; \\n     int k = 0, i = 0, j = 0, nxtCol = 1;\\n\\n     //step 2 : form the matrix from the given string\\n     vector<vector<char>> grid(rows,vector<char>(cols,\\' \\'));\\n      for(int i=0; i<rows; i++){\\n           for(int j=0; j<cols; j++){\\n                 grid[i][j] = encodedText[k++];\\n           }\\n       }\\n\\n      //step 3 : form the decoded string by traversing the matrix diagonally\\n       k = 0;\\n       while(nxtCol <= cols)\\n       {\\n           if(i >= rows || j >= cols) //always keep i and j as valid index\\n           {\\n               i = 0;\\n               j = nxtCol;\\n               nxtCol++;\\n           }\\n          if(j < cols) ans += grid[i][j];\\n          i++;\\n          j++;\\n       }\\n\\n      //step 4 : remove leading spaces, if any\\n       while(!ans.empty() && ans.back() == \\' \\')\\n        ans.pop_back();\\n\\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n\\n     //step 1 : find no. of columns needed in the matrix\\n     int cols = encodedText.length()/rows;\\n     string ans = \"\"; \\n     int k = 0, i = 0, j = 0, nxtCol = 1;\\n\\n     //step 2 : form the matrix from the given string\\n     vector<vector<char>> grid(rows,vector<char>(cols,\\' \\'));\\n      for(int i=0; i<rows; i++){\\n           for(int j=0; j<cols; j++){\\n                 grid[i][j] = encodedText[k++];\\n           }\\n       }\\n\\n      //step 3 : form the decoded string by traversing the matrix diagonally\\n       k = 0;\\n       while(nxtCol <= cols)\\n       {\\n           if(i >= rows || j >= cols) //always keep i and j as valid index\\n           {\\n               i = 0;\\n               j = nxtCol;\\n               nxtCol++;\\n           }\\n          if(j < cols) ans += grid[i][j];\\n          i++;\\n          j++;\\n       }\\n\\n      //step 4 : remove leading spaces, if any\\n       while(!ans.empty() && ans.back() == \\' \\')\\n        ans.pop_back();\\n\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3584778,
                "title": "just-construct-matrix-and-traverse-diagonally",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        int n=encodedText.size();\\n        int c=n/rows;\\n        vector<vector<char>>m(rows,vector<char>(c));\\n        int k=0;\\n        for(int i=0;i<rows;i++){\\n            for(int j=0;j<c;j++){\\n                m[i][j]=encodedText[k++];\\n            }\\n        }\\n        string ans;\\n        for(int k=0;k<c;k++){\\n                int j=k;\\n                int i=0;\\n                while(i<rows && j<c){\\n                    ans+=m[i][j];\\n                    i++;\\n                    j++;\\n                }\\n            }\\n        bool f=true;\\n        string s;\\n        for(int i=ans.size()-1;i>=0;i--){\\n            if(f && ans[i]==\\' \\'){\\n               \\n            }\\n            else{\\n                f=false;\\n                s+=ans[i];\\n            }\\n        }\\n        reverse(s.begin(),s.end());\\n        return s;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        int n=encodedText.size();\\n        int c=n/rows;\\n        vector<vector<char>>m(rows,vector<char>(c));\\n        int k=0;\\n        for(int i=0;i<rows;i++){\\n            for(int j=0;j<c;j++){\\n                m[i][j]=encodedText[k++];\\n            }\\n        }\\n        string ans;\\n        for(int k=0;k<c;k++){\\n                int j=k;\\n                int i=0;\\n                while(i<rows && j<c){\\n                    ans+=m[i][j];\\n                    i++;\\n                    j++;\\n                }\\n            }\\n        bool f=true;\\n        string s;\\n        for(int i=ans.size()-1;i>=0;i--){\\n            if(f && ans[i]==\\' \\'){\\n               \\n            }\\n            else{\\n                f=false;\\n                s+=ans[i];\\n            }\\n        }\\n        reverse(s.begin(),s.end());\\n        return s;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3516695,
                "title": "c-easy-solution-simulation-diagonal-traversal",
                "content": "# Intuition\\n**Columns = encodedText.size/rows** . Now make the grid as given in example and do diagonal traversal from every column.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string eT, int rows) {\\n        int n = eT.size();\\n        if(n==0)\\n        return \"\";\\n        int cols = n/rows;\\n        vector<vector<char>> grid(rows,vector<char>(cols));\\n        int ptr = 0;\\n        int col = 0;\\n        int row = 0;\\n        while(ptr<n)\\n        {\\n            grid[row][col] = eT[ptr];\\n            ptr++;\\n            col = (col+1)%cols;\\n            if(col==0)\\n            row++;\\n        }\\n        string ans = \"\";\\n        for(int j=0;j<cols;j++)\\n        {\\n            int c = j;\\n            int r = 0;\\n            while(c<cols && r<rows)\\n            {\\n                ans+=grid[r][c];\\n                c++;\\n                r++;\\n            }\\n        }\\n        while(ans[ans.size()-1]==\\' \\')\\n        ans.pop_back();\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string eT, int rows) {\\n        int n = eT.size();\\n        if(n==0)\\n        return \"\";\\n        int cols = n/rows;\\n        vector<vector<char>> grid(rows,vector<char>(cols));\\n        int ptr = 0;\\n        int col = 0;\\n        int row = 0;\\n        while(ptr<n)\\n        {\\n            grid[row][col] = eT[ptr];\\n            ptr++;\\n            col = (col+1)%cols;\\n            if(col==0)\\n            row++;\\n        }\\n        string ans = \"\";\\n        for(int j=0;j<cols;j++)\\n        {\\n            int c = j;\\n            int r = 0;\\n            while(c<cols && r<rows)\\n            {\\n                ans+=grid[r][c];\\n                c++;\\n                r++;\\n            }\\n        }\\n        while(ans[ans.size()-1]==\\' \\')\\n        ans.pop_back();\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3470468,
                "title": "simulation-easy-c-solution",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) \\n    {\\n        if(rows==1) return encodedText;\\n        int cols=encodedText.size()/rows;\\n        vector<vector<char>> v(rows, vector<char> (cols,\\' \\'));\\n        int i=0, done=0;\\n        for(int x=0; x<rows; x++)\\n        {\\n            for(int y=0; y<cols; y++)\\n            {\\n                v[x][y]=encodedText[i++];\\n                if(i==encodedText.size()) \\n                {\\n                    done=1;\\n                    break;\\n                }\\n            }\\n            if(done) break;\\n        }\\n        string ans=\"\";\\n        int r=0, c=0, col=0;\\n        while(col<cols)\\n        {\\n            ans+=v[r][c];\\n            r++, c++;\\n            if(r==rows || c==cols)\\n            {\\n                r=0; col++;\\n                c=col;\\n            }\\n        }\\n        int j=ans.size()-1;\\n        while(j>=0 && ans[j]==\\' \\') j--;\\n        ans=ans.substr(0,j+1);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Simulation"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) \\n    {\\n        if(rows==1) return encodedText;\\n        int cols=encodedText.size()/rows;\\n        vector<vector<char>> v(rows, vector<char> (cols,\\' \\'));\\n        int i=0, done=0;\\n        for(int x=0; x<rows; x++)\\n        {\\n            for(int y=0; y<cols; y++)\\n            {\\n                v[x][y]=encodedText[i++];\\n                if(i==encodedText.size()) \\n                {\\n                    done=1;\\n                    break;\\n                }\\n            }\\n            if(done) break;\\n        }\\n        string ans=\"\";\\n        int r=0, c=0, col=0;\\n        while(col<cols)\\n        {\\n            ans+=v[r][c];\\n            r++, c++;\\n            if(r==rows || c==cols)\\n            {\\n                r=0; col++;\\n                c=col;\\n            }\\n        }\\n        int j=ans.size()-1;\\n        while(j>=0 && ans[j]==\\' \\') j--;\\n        ans=ans.substr(0,j+1);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3416162,
                "title": "c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        int n = encodedText.size();\\n        int cols = n / rows;\\n        string ans = \"\";\\n        for(int i = 0; i < cols; i++) {\\n            for(int j = i; j < n; j += cols + 1) {\\n                ans += encodedText[j];\\n            }\\n        }\\n        while(ans.back() == \\' \\') ans.pop_back();\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        int n = encodedText.size();\\n        int cols = n / rows;\\n        string ans = \"\";\\n        for(int i = 0; i < cols; i++) {\\n            for(int j = i; j < n; j += cols + 1) {\\n                ans += encodedText[j];\\n            }\\n        }\\n        while(ans.back() == \\' \\') ans.pop_back();\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3382410,
                "title": "python-solution-with-explanation",
                "content": "### simulation\\n\\n```python\\n\\'\\'\\'\\ntraverse string diagonally, \\nif the index of row or columns is out of bound,\\nback to the fisrt row.\\ntc is O(n), sc is O(n)\\n\\'\\'\\'\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        if rows == 1: return encodedText\\n        numCol = len(encodedText) // rows\\n        ans = []  \\n        mapping = lambda r, c: numCol * r + c\\n        for curCol in range(numCol):\\n            r, c = 0, curCol\\n            while mapping(r, c) < rows * numCol:\\n                ans.append(encodedText[mapping(r, c)])\\n                r += 1\\n                c += 1\\n        return \\'\\'.join(ans).rstrip()\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\n\\'\\'\\'\\ntraverse string diagonally, \\nif the index of row or columns is out of bound,\\nback to the fisrt row.\\ntc is O(n), sc is O(n)\\n\\'\\'\\'\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        if rows == 1: return encodedText\\n        numCol = len(encodedText) // rows\\n        ans = []  \\n        mapping = lambda r, c: numCol * r + c\\n        for curCol in range(numCol):\\n            r, c = 0, curCol\\n            while mapping(r, c) < rows * numCol:\\n                ans.append(encodedText[mapping(r, c)])\\n                r += 1\\n                c += 1\\n        return \\'\\'.join(ans).rstrip()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3365847,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        int n = encodedText.size() ;\\n        int cols = n/rows ;\\n        vector<vector<char>>mat(rows, vector<char>(cols)) ;\\n        for(int i = 0; i < n; i++){\\n            mat[i/cols][i%cols] = encodedText[i] ;\\n        }\\n        string ret ;\\n        for(int i = 0; i < cols; i++){\\n            int r = 0, c = i ;\\n            while(r < rows && c < cols){\\n                ret.push_back(mat[r][c] ) ;\\n                r++ ;\\n                c++ ;\\n            }\\n        }\\n        while(ret.size() && ret.back() == \\' \\')\\n            ret.pop_back() ;\\n        return ret ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        int n = encodedText.size() ;\\n        int cols = n/rows ;\\n        vector<vector<char>>mat(rows, vector<char>(cols)) ;\\n        for(int i = 0; i < n; i++){\\n            mat[i/cols][i%cols] = encodedText[i] ;\\n        }\\n        string ret ;\\n        for(int i = 0; i < cols; i++){\\n            int r = 0, c = i ;\\n            while(r < rows && c < cols){\\n                ret.push_back(mat[r][c] ) ;\\n                r++ ;\\n                c++ ;\\n            }\\n        }\\n        while(ret.size() && ret.back() == \\' \\')\\n            ret.pop_back() ;\\n        return ret ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3325766,
                "title": "c-stright-forward",
                "content": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string et, int rows) {\\n        cout << et.size() << \" \" << rows;\\n        string res = \"\";\\n        int col = et.size() / rows;\\n        int idx = 0;\\n        string space = \"\";\\n        // cout << col << \" \" << rows << \" \";\\n        while(idx < col - rows + 2) {\\n            for(int i = 0; i < rows && idx + i + i * col < et.size(); i++) {\\n                if(et[idx + i + i * col] == \\' \\')\\n                    space += \\' \\';\\n                else {\\n                    res += (space + et[idx + i + i * col]);                    \\n                    space = \"\";\\n                }\\n\\n            }\\n            idx++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string et, int rows) {\\n        cout << et.size() << \" \" << rows;\\n        string res = \"\";\\n        int col = et.size() / rows;\\n        int idx = 0;\\n        string space = \"\";\\n        // cout << col << \" \" << rows << \" \";\\n        while(idx < col - rows + 2) {\\n            for(int i = 0; i < rows && idx + i + i * col < et.size(); i++) {\\n                if(et[idx + i + i * col] == \\' \\')\\n                    space += \\' \\';\\n                else {\\n                    res += (space + et[idx + i + i * col]);                    \\n                    space = \"\";\\n                }\\n\\n            }\\n            idx++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3324281,
                "title": "2-solutions-beginner-friendly-c",
                "content": "***Please do upvote \\u2B06\\uFE0F my solution to keep me motivated :)***\\n***Doubts?? I am super active at the comments section. \\uD83D\\uDE00***\\n\\n\\n\\n## Brute Force \\n**Tc - O(m*n)**\\n\\n```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        int n = encodedText.size();\\n        int cols = n/rows;\\n        vector<vector<char>> mat(rows,vector<char>(cols,\\' \\'));\\n        int i=0;\\n        for(int r=0;r<rows;r++) {\\n            for(int c=0;c<cols;c++) {\\n                if(i<n) {\\n                    mat[r][c] = encodedText[i++];\\n                }\\n            }\\n        }\\n\\n        for(int r=0;r<rows;r++) {\\n            for(int c=0;c<cols;c++) {\\n                cout<<mat[r][c]<<\" \";\\n            }\\n            cout<<endl;\\n        }\\n\\n        string originalText = \"\";\\n        int r=0;\\n        for(int c=0;c<cols;c++) {\\n            int tc = c;\\n                while(r!=rows && tc!=cols) {\\n                originalText += mat[r][tc];\\n                r++;\\n                tc++;\\n            }\\n            r = 0;\\n        }\\n        while(originalText.back()==\\' \\') {\\n            originalText.pop_back();\\n        }\\n        return originalText;\\n    }\\n};\\n``` \\n## Optimised Solution\\n**Tc - O(n)**\\n\\n```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        int n = encodedText.size();\\n        int cols = n/rows;\\n        string originalText = \"\";\\n        for(int i=0;i<cols;i++) {\\n            for(int j=i;j<n;j+=cols+1) {\\n                originalText += encodedText[j];\\n            }\\n        }\\n\\n        while(originalText.back()==\\' \\') {\\n            originalText.pop_back();\\n        }\\n        return originalText;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        int n = encodedText.size();\\n        int cols = n/rows;\\n        vector<vector<char>> mat(rows,vector<char>(cols,\\' \\'));\\n        int i=0;\\n        for(int r=0;r<rows;r++) {\\n            for(int c=0;c<cols;c++) {\\n                if(i<n) {\\n                    mat[r][c] = encodedText[i++];\\n                }\\n            }\\n        }\\n\\n        for(int r=0;r<rows;r++) {\\n            for(int c=0;c<cols;c++) {\\n                cout<<mat[r][c]<<\" \";\\n            }\\n            cout<<endl;\\n        }\\n\\n        string originalText = \"\";\\n        int r=0;\\n        for(int c=0;c<cols;c++) {\\n            int tc = c;\\n                while(r!=rows && tc!=cols) {\\n                originalText += mat[r][tc];\\n                r++;\\n                tc++;\\n            }\\n            r = 0;\\n        }\\n        while(originalText.back()==\\' \\') {\\n            originalText.pop_back();\\n        }\\n        return originalText;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        int n = encodedText.size();\\n        int cols = n/rows;\\n        string originalText = \"\";\\n        for(int i=0;i<cols;i++) {\\n            for(int j=i;j<n;j+=cols+1) {\\n                originalText += encodedText[j];\\n            }\\n        }\\n\\n        while(originalText.back()==\\' \\') {\\n            originalText.pop_back();\\n        }\\n        return originalText;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3269614,
                "title": "easy-c-solution-string-and-index-manipulation",
                "content": "```\\n    string decodeCiphertext(string text, int rows) {\\n        \\n        string ans = \"\";\\n        int n = text.size();\\n        int fac = n/rows;\\n        \\n        for(int i = 0;i<fac;i++){\\n            int temp = i;\\n            while(temp<n){\\n                ans+=text[temp];\\n                temp+=(fac+1);\\n            }\\n        }\\n        \\n        while(!ans.empty() and ans.back()==\\' \\'){\\n            ans.pop_back();\\n        }\\n        \\n        return ans;\\n        \\n    }\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\n    string decodeCiphertext(string text, int rows) {\\n        \\n        string ans = \"\";\\n        int n = text.size();\\n        int fac = n/rows;\\n        \\n        for(int i = 0;i<fac;i++){\\n            int temp = i;\\n            while(temp<n){\\n                ans+=text[temp];\\n                temp+=(fac+1);\\n            }\\n        }\\n        \\n        while(!ans.empty() and ans.back()==\\' \\'){\\n            ans.pop_back();\\n        }\\n        \\n        return ans;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3260455,
                "title": "javascript-100-runtime",
                "content": "```\\nconst decodeCiphertext = (text, rows) => {\\n  if (rows == 1 || text.length < rows) return text;\\n\\n  const reg = new RegExp(`.{1,${text.length / rows}}`, \"g\");\\n  rows = text.match(reg);\\n\\n  let res = \"\";\\n  for (let i = 0; i < rows[0].length; i++) {\\n    for (let j = 0, k = i; j < rows.length; j++, k++) {\\n      if (k > rows[0].length - 1) return res.replace(/\\\\s+$/, \"\");\\n      res += rows[j][k];\\n    }\\n  }\\n\\n  return res.replace(/\\\\s+$/, \"\");\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst decodeCiphertext = (text, rows) => {\\n  if (rows == 1 || text.length < rows) return text;\\n\\n  const reg = new RegExp(`.{1,${text.length / rows}}`, \"g\");\\n  rows = text.match(reg);\\n\\n  let res = \"\";\\n  for (let i = 0; i < rows[0].length; i++) {\\n    for (let j = 0, k = i; j < rows.length; j++, k++) {\\n      if (k > rows[0].length - 1) return res.replace(/\\\\s+$/, \"\");\\n      res += rows[j][k];\\n    }\\n  }\\n\\n  return res.replace(/\\\\s+$/, \"\");\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3199343,
                "title": "python-solution",
                "content": "```\\ndef decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        str_len = len(encodedText)\\n        print(str_len)\\n        m = rows\\n        n = str_len // m\\n        def read(i, remain, arr):\\n            if remain > 0:\\n                print(encodedText[i])\\n                arr.append(encodedText[i])\\n                next_i = i + n + 1\\n                read(next_i, remain - 1, arr)\\n        remain = m\\n        res_arr = []\\n        for i in range(n):\\n            if i <= n - m:\\n                read(i, remain, res_arr)\\n            else:\\n                new_remain = n - i\\n                read(i, new_remain, res_arr)\\n        res_str1 = \"\".join(res_arr)\\n        res_str2 = res_str1.rstrip()\\n        return res_str2\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        str_len = len(encodedText)\\n        print(str_len)\\n        m = rows\\n        n = str_len // m\\n        def read(i, remain, arr):\\n            if remain > 0:\\n                print(encodedText[i])\\n                arr.append(encodedText[i])\\n                next_i = i + n + 1\\n                read(next_i, remain - 1, arr)\\n        remain = m\\n        res_arr = []\\n        for i in range(n):\\n            if i <= n - m:\\n                read(i, remain, res_arr)\\n            else:\\n                new_remain = n - i\\n                read(i, new_remain, res_arr)\\n        res_str1 = \"\".join(res_arr)\\n        res_str2 = res_str1.rstrip()\\n        return res_str2\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3196538,
                "title": "scala-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nobject Solution {\\n    def decodeCiphertext(encodedText: String, rows: Int): String = {\\n        if(encodedText.length < 1) return encodedText\\n        val rowlength = encodedText.length / rows\\n        val ts = encodedText.sliding(rowlength, rowlength)\\n        val res = (0 until rows).foldLeft(new Array[String](rows))((ans, i) =>{\\n            val t = ts.next()\\n            ans(i) = t.drop(i) + (\" \" * rows)\\n            ans\\n        })\\n        (for{j<- 0 until rowlength\\n            i <- 0 until rows} yield res(i)(j)).mkString.reverse.dropWhile(_ == \\' \\').reverse\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def decodeCiphertext(encodedText: String, rows: Int): String = {\\n        if(encodedText.length < 1) return encodedText\\n        val rowlength = encodedText.length / rows\\n        val ts = encodedText.sliding(rowlength, rowlength)\\n        val res = (0 until rows).foldLeft(new Array[String](rows))((ans, i) =>{\\n            val t = ts.next()\\n            ans(i) = t.drop(i) + (\" \" * rows)\\n            ans\\n        })\\n        (for{j<- 0 until rowlength\\n            i <- 0 until rows} yield res(i)(j)).mkString.reverse.dropWhile(_ == \\' \\').reverse\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3186887,
                "title": "beats-100-runtime-memory-typescript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe first if statement checks if the encodedText is empty and returns an empty string if it is.\\n\\nNext, charIdx and nextColumnIdx are initialized to 0 and 1 respectively. The charIdx variable represents the index of the character in the encoded text that we are currently processing. The nextColumnIdx variable is used to keep track of the next column index when we have finished decoding the current column.\\n\\nThe number of columns is calculated based on the encoded text\\'s length and the number of rows used for encoding. If the length of the encoded text is not a multiple of the number of rows, the function returns the original encoded text.\\n\\nA result variable is initialized as an empty string, which will hold the decoded text.\\n\\nThe while loop decodes the text one character at a time, starting from the first character in the first row. We add the current character to the result string and then move to the next character in the same column by adding the number of columns to the current index and moving to the next row.\\n\\nIf we have reached the last column, we break out of the loop as we have finished decoding the text. If we have not reached the last column, we continue decoding by moving to the next column.\\n\\nIf we have reached the end of the rows, we move to the next column and start decoding from the first row of the next column.\\n\\nFinally, we return the result string with any trailing spaces removed.\\n\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction decodeCiphertext(encodedText: string, rows: number): string {\\n    if (encodedText.length == 0) return \"\"\\n    let charIdx: number = 0;\\n    let nextColumnIdx: number = 1\\n    const columns = encodedText.length / rows\\n    if (encodedText.length !== rows * columns)\\n        return encodedText\\n    let result: string = \"\"\\n    while (true) {\\n        result += encodedText[charIdx]\\n        // break when reached last column\\n        if (charIdx === columns - 1) break;\\n        // move one row below, one column right\\n        charIdx = charIdx + columns + 1;\\n        // move up to first row if passed the row limit\\n        if (charIdx > columns * rows - 1) {\\n            charIdx = nextColumnIdx\\n            nextColumnIdx++\\n        }\\n    }\\n    return result.trimEnd()\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction decodeCiphertext(encodedText: string, rows: number): string {\\n    if (encodedText.length == 0) return \"\"\\n    let charIdx: number = 0;\\n    let nextColumnIdx: number = 1\\n    const columns = encodedText.length / rows\\n    if (encodedText.length !== rows * columns)\\n        return encodedText\\n    let result: string = \"\"\\n    while (true) {\\n        result += encodedText[charIdx]\\n        // break when reached last column\\n        if (charIdx === columns - 1) break;\\n        // move one row below, one column right\\n        charIdx = charIdx + columns + 1;\\n        // move up to first row if passed the row limit\\n        if (charIdx > columns * rows - 1) {\\n            charIdx = nextColumnIdx\\n            nextColumnIdx++\\n        }\\n    }\\n    return result.trimEnd()\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3181434,
                "title": "c-easy-undestanding-one-traversal",
                "content": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string s, int rows) {\\n        int n=s.size(),k=0;\\n        vector<string>v(rows);\\n        for(int i=0;i<rows;i++)\\n            for(int j=0;j<n/rows;j++)\\n                v[i].push_back(s[k++]);\\n        s=\"\";\\n        for(int k=0;k<n/rows;k++)\\n            for(int i=0,j=k;i<rows && j<n/rows;i++,j++)\\n                    s+=v[i][j];\\n        n=s.size()-1;\\n        while(n>=0 && s[n]==\\' \\')\\n            n--;\\n        return s.substr(0,n+1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string s, int rows) {\\n        int n=s.size(),k=0;\\n        vector<string>v(rows);\\n        for(int i=0;i<rows;i++)\\n            for(int j=0;j<n/rows;j++)\\n                v[i].push_back(s[k++]);\\n        s=\"\";\\n        for(int k=0;k<n/rows;k++)\\n            for(int i=0,j=k;i<rows && j<n/rows;i++,j++)\\n                    s+=v[i][j];\\n        n=s.size()-1;\\n        while(n>=0 && s[n]==\\' \\')\\n            n--;\\n        return s.substr(0,n+1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3086658,
                "title": "c-easy-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string str, int rows) {\\n        int l = str.size();\\n        int m = l / rows;\\n        \\n        string ans;\\n        for(int i = 0; i < m; i++) {\\n            int j = i;\\n            while(j < l) {\\n                ans += str[j];\\n                j += m + 1;\\n            }\\n        }\\n\\n        for(int i = ans.size() - 1; i >= 0 and ans[i] == \\' \\'; i--)\\n            ans.pop_back();\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string str, int rows) {\\n        int l = str.size();\\n        int m = l / rows;\\n        \\n        string ans;\\n        for(int i = 0; i < m; i++) {\\n            int j = i;\\n            while(j < l) {\\n                ans += str[j];\\n                j += m + 1;\\n            }\\n        }\\n\\n        for(int i = ans.size() - 1; i >= 0 and ans[i] == \\' \\'; i--)\\n            ans.pop_back();\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3085408,
                "title": "c-simple-solution-beats-100",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string enctext, int rows) {\\n        if(rows==1) return enctext;\\n        int len = enctext.length();\\n        int col = len/rows;\\n        string ans;\\n        int count = 0;\\n        for(char c : enctext) if(c!=\\' \\') count++;\\n        for(int i=0;i<len;i++){\\n            int j = i;\\n            while(j<len){\\n                if(count==0) break;\\n                if(enctext[j]!=\\' \\') count--;\\n                ans+=enctext[j];\\n                j+=col+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string enctext, int rows) {\\n        if(rows==1) return enctext;\\n        int len = enctext.length();\\n        int col = len/rows;\\n        string ans;\\n        int count = 0;\\n        for(char c : enctext) if(c!=\\' \\') count++;\\n        for(int i=0;i<len;i++){\\n            int j = i;\\n            while(j<len){\\n                if(count==0) break;\\n                if(enctext[j]!=\\' \\') count--;\\n                ans+=enctext[j];\\n                j+=col+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3072911,
                "title": "python-simulation-simple-solution-o-mn",
                "content": "# Code\\n```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        cols = len(encodedText)//rows\\n        matrix = [[0]*cols for _ in range(rows)]\\n        for i in range(rows):\\n            for j in range(cols):\\n                matrix[i][j] = encodedText[i*cols + j]\\n        i,j = 0,0\\n        res = []\\n        while 0<=i<rows and 0<=j<cols:\\n            res.append(matrix[i][j])\\n            i = (i+1)%rows\\n            j += 1\\n            j = j-(rows-1)*(i==0)\\n        return \"\".join(res).rstrip()\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        cols = len(encodedText)//rows\\n        matrix = [[0]*cols for _ in range(rows)]\\n        for i in range(rows):\\n            for j in range(cols):\\n                matrix[i][j] = encodedText[i*cols + j]\\n        i,j = 0,0\\n        res = []\\n        while 0<=i<rows and 0<=j<cols:\\n            res.append(matrix[i][j])\\n            i = (i+1)%rows\\n            j += 1\\n            j = j-(rows-1)*(i==0)\\n        return \"\".join(res).rstrip()\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3047748,
                "title": "simple-java-o-n-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public String decodeCiphertext(String encodedText, int rows) {\\n        int count = 0;\\n        for (char c : encodedText.toCharArray()) if (c != \\' \\') count++;\\n        int col = encodedText.length() / rows;\\n        StringBuilder sb = new StringBuilder();\\n        int r = 0, c = 0;\\n        while (count > 0) {\\n            int index = col * r + c;\\n            if (encodedText.charAt(index) != \\' \\') count--;\\n            sb.append(encodedText.charAt(index));\\n            r++;\\n            c++;\\n            if (r == rows) {\\n                r = 0;\\n                c -= rows - 1;\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String decodeCiphertext(String encodedText, int rows) {\\n        int count = 0;\\n        for (char c : encodedText.toCharArray()) if (c != \\' \\') count++;\\n        int col = encodedText.length() / rows;\\n        StringBuilder sb = new StringBuilder();\\n        int r = 0, c = 0;\\n        while (count > 0) {\\n            int index = col * r + c;\\n            if (encodedText.charAt(index) != \\' \\') count--;\\n            sb.append(encodedText.charAt(index));\\n            r++;\\n            c++;\\n            if (r == rows) {\\n                r = 0;\\n                c -= rows - 1;\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2989033,
                "title": "rust-translating-x-y-coors-to-a-1d-index",
                "content": "# Intuition and Approach\\nThis is a fairly simple diagonal traversal solution. The examples paint things pretty clearly such that we may just follow the arrows to a satisfactory solution. Basically we want a simple loop over a 2 dimensional cipher like this:\\n\\n`cipher[j][i+j] for i in 0..columns for j in 0..rows if i + j < columns`\\n\\nInstead of building the cipher as a matrix, we may index into our string directly by simply translating matrix indices to an integer. This is a straight forward translation:\\n\\n```\\n[y][x] == num_columns * y + x \\n# or in a more complete, algorithmic form\\n[encoded_text[j * columns + j + i] for i in range(columns) for j in range(rows) if i + j < columns]\\n```\\n\\n# Complexity\\n- Time complexity:\\n`O(n)`\\n\\n- Space complexity:\\n`O(n)`\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn decode_ciphertext(encoded_text: String, rows: i32) -> String {\\n        let len = encoded_text.len() / (rows as usize);\\n        let encoded_text = encoded_text.chars().collect::<Vec<char>>();\\n        let mut output = String::from(\"\");\\n        for i in 0..len {\\n            let mut x = i;\\n            let mut y = 0;\\n            while y < rows as usize && x < len {\\n                output.push(encoded_text[len * y + x]);\\n                y += 1;\\n                x += 1;\\n            }\\n        }\\n\\n        String::from(output.trim_end())\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\n[y][x] == num_columns * y + x \\n# or in a more complete, algorithmic form\\n[encoded_text[j * columns + j + i] for i in range(columns) for j in range(rows) if i + j < columns]\\n```\n```\\nimpl Solution {\\n    pub fn decode_ciphertext(encoded_text: String, rows: i32) -> String {\\n        let len = encoded_text.len() / (rows as usize);\\n        let encoded_text = encoded_text.chars().collect::<Vec<char>>();\\n        let mut output = String::from(\"\");\\n        for i in 0..len {\\n            let mut x = i;\\n            let mut y = 0;\\n            while y < rows as usize && x < len {\\n                output.push(encoded_text[len * y + x]);\\n                y += 1;\\n                x += 1;\\n            }\\n        }\\n\\n        String::from(output.trim_end())\\n    }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2980186,
                "title": "c-o-1-space-o-endodedstring-size-time-optimized-explained",
                "content": "# Intuition\\nMy main objective was not to construct the matrix, for that i tried to somehow map the useful indexes of the matrix to the ```endodedString``` index\\n\\n# Approach\\nEverytime we move one row down in the matrix we leave ```cols``` number of characters behind, I used to the same to comeup with the solution.\\n\\n# Complexity\\n- Time complexity: O(```embededText.size()```)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1) , if we do not consider the output, else O(```outputLength```)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        int cur=0,n=encodedText.size(),cols=n/rows;\\n\\n        string res=\"\";\\n        for(int j=0;j<cols;j++){\\n            int x=0,y=j;\\n            while(x<rows && y<cols){\\n                res+=encodedText[(x*cols)+y];\\n                x++,y++;\\n            }\\n        }\\n\\n        int idx=-1;\\n        for(int i=0;i<res.size();i++){\\n            if(res[i]!=\\' \\'){\\n                idx=i;\\n            }\\n        }\\n\\n        return res.substr(0,idx+1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```endodedString```\n```cols```\n```embededText.size()```\n```outputLength```\n```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        int cur=0,n=encodedText.size(),cols=n/rows;\\n\\n        string res=\"\";\\n        for(int j=0;j<cols;j++){\\n            int x=0,y=j;\\n            while(x<rows && y<cols){\\n                res+=encodedText[(x*cols)+y];\\n                x++,y++;\\n            }\\n        }\\n\\n        int idx=-1;\\n        for(int i=0;i<res.size();i++){\\n            if(res[i]!=\\' \\'){\\n                idx=i;\\n            }\\n        }\\n\\n        return res.substr(0,idx+1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2894756,
                "title": "beginner-friendly-python-easy-to-understand-and-fast-approach",
                "content": "```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        cols = len(encodedText)//rows\\n        arr = [[\\'\\' for i in range(cols)] for j in range(rows)]\\n        ith = 0\\n        for i in range(rows):\\n            for j in range(cols):\\n                arr[i][j] = encodedText[ith]\\n                ith += 1\\n        wrapup = \\'\\'\\n        for i in range(cols):\\n            cntr = i\\n            for j in range(rows):\\n                try:\\n                    wrapup += arr[j][cntr]\\n                except:\\n                    return wrapup.rstrip()\\n                cntr += 1\\n        return wrapup.rstrip()\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        cols = len(encodedText)//rows\\n        arr = [[\\'\\' for i in range(cols)] for j in range(rows)]\\n        ith = 0\\n        for i in range(rows):\\n            for j in range(cols):\\n                arr[i][j] = encodedText[ith]\\n                ith += 1\\n        wrapup = \\'\\'\\n        for i in range(cols):\\n            cntr = i\\n            for j in range(rows):\\n                try:\\n                    wrapup += arr[j][cntr]\\n                except:\\n                    return wrapup.rstrip()\\n                cntr += 1\\n        return wrapup.rstrip()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2883787,
                "title": "python3-one-liner-explained-with-extended-version",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nOne liners are not really readable which is bad, but using list comprehensions/generators in python is likely to be quicker than extended loop.\\n\\nBelow you can find three versions, which gradually become more complex and shorter. The last version calls the join operator immediately over the generator of characters which might be the fastest and most efficient regarding memory.\\n\\nBUT: It is utterly unreadable and Python is not exactly the right language to worry about memory efficiency. I just wanted to share my approach, maybe it helps somebody.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe start at a column (outer loop) of the first row and then traverse diagonal downwards (step: column + 1 for diagonal).\\n\\nThis gives us the characters in the right order.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO((N*M)/2) where N is the amount of rows and M is the amount of columns.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1) if we omit solution space in the last function.\\n\\n# Code\\n```\\nclass Solution:\\n    def decodeCiphertext_extended(self, encodedText: str, rows: int) -> str:\\n        column = len(encodedText)//rows\\n        solution = []\\n        for cx in range(column):\\n            for strx in range(cx, len(encodedText), len(encodedText)//rows+1):\\n                solution.append(encodedText[strx])\\n        return \"\".join(solution).rstrip()\\n    \\n    def decodeCiphertext_mixed(self, encodedText: str, rows: int) -> str:\\n        text = [encodedText[strx] for cx in range(len(encodedText)//rows+1) for strx in range(cx, len(encodedText), len(encodedText)//rows+1)]\\n        return \"\".join(text).rstrip()\\n    \\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        return \"\".join(encodedText[strx] for cx in range(len(encodedText)//rows+1) for strx in range(cx, len(encodedText), len(encodedText)//rows+1)).rstrip()\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def decodeCiphertext_extended(self, encodedText: str, rows: int) -> str:\\n        column = len(encodedText)//rows\\n        solution = []\\n        for cx in range(column):\\n            for strx in range(cx, len(encodedText), len(encodedText)//rows+1):\\n                solution.append(encodedText[strx])\\n        return \"\".join(solution).rstrip()\\n    \\n    def decodeCiphertext_mixed(self, encodedText: str, rows: int) -> str:\\n        text = [encodedText[strx] for cx in range(len(encodedText)//rows+1) for strx in range(cx, len(encodedText), len(encodedText)//rows+1)]\\n        return \"\".join(text).rstrip()\\n    \\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        return \"\".join(encodedText[strx] for cx in range(len(encodedText)//rows+1) for strx in range(cx, len(encodedText), len(encodedText)//rows+1)).rstrip()\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2849828,
                "title": "python-simple-iterative-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        cols = len(encodedText)//rows\\n        \\n        res = \"\"\\n        \\n        for i in range(cols):\\n            idx = i\\n            for j in range(rows):\\n                if idx >= len(encodedText):\\n                    break\\n                    \\n                res += encodedText[idx]\\n                idx += (cols+1)\\n                \\n        i = len(res)-1       \\n        while i >= 0:\\n            if res[i] !=  \" \":\\n                break\\n            i -= 1\\n                \\n        return res[:i+1]\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        cols = len(encodedText)//rows\\n        \\n        res = \"\"\\n        \\n        for i in range(cols):\\n            idx = i\\n            for j in range(rows):\\n                if idx >= len(encodedText):\\n                    break\\n                    \\n                res += encodedText[idx]\\n                idx += (cols+1)\\n                \\n        i = len(res)-1       \\n        while i >= 0:\\n            if res[i] !=  \" \":\\n                break\\n            i -= 1\\n                \\n        return res[:i+1]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2838084,
                "title": "rust",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn decode_ciphertext(encoded_text: String, rows: i32) -> String {\\n        if rows == 1 {\\n            return encoded_text;\\n        }\\n        let col_count = encoded_text.len() as i32 / rows;\\n        let mut new_vec = vec![vec![]; rows as usize];\\n        let mut res: Vec<char> = Vec::new();\\n        let _ =\\n            encoded_text\\n                .chars()\\n                .into_iter()\\n                .fold((0, 0), |(mut tmp_row, mut tmp_col), item| {\\n                    if tmp_col >= col_count {\\n                        tmp_col = 0;\\n                        tmp_row += 1;\\n                    }\\n                    new_vec[tmp_row].push(item);\\n                    tmp_col += 1;\\n\\n                    (tmp_row, tmp_col)\\n                });\\n\\n        for i in 0..col_count {\\n            for (j, _) in new_vec.iter().enumerate().take(rows as usize) {\\n                let y = i as i32 + j as i32;\\n                if y >= col_count {\\n                    break;\\n                }\\n                res.push(new_vec[j][y as usize]);\\n            }\\n        }\\n\\n        res.iter().collect::<String>().trim_end().to_owned()\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn decode_ciphertext(encoded_text: String, rows: i32) -> String {\\n        if rows == 1 {\\n            return encoded_text;\\n        }\\n        let col_count = encoded_text.len() as i32 / rows;\\n        let mut new_vec = vec![vec![]; rows as usize];\\n        let mut res: Vec<char> = Vec::new();\\n        let _ =\\n            encoded_text\\n                .chars()\\n                .into_iter()\\n                .fold((0, 0), |(mut tmp_row, mut tmp_col), item| {\\n                    if tmp_col >= col_count {\\n                        tmp_col = 0;\\n                        tmp_row += 1;\\n                    }\\n                    new_vec[tmp_row].push(item);\\n                    tmp_col += 1;\\n\\n                    (tmp_row, tmp_col)\\n                });\\n\\n        for i in 0..col_count {\\n            for (j, _) in new_vec.iter().enumerate().take(rows as usize) {\\n                let y = i as i32 + j as i32;\\n                if y >= col_count {\\n                    break;\\n                }\\n                res.push(new_vec[j][y as usize]);\\n            }\\n        }\\n\\n        res.iter().collect::<String>().trim_end().to_owned()\\n    }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2803981,
                "title": "decode-the-slanted-ciphertext-c-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string text, int r) {\\n        int c=text.length()/r;\\n        \\n        vector<vector<char>> grid(r, vector<char>(c, \\' \\'));\\n        \\n        int i=0, j=0;\\n        for(int k=0; k<text.length(); k++){\\n            grid[i][j++]=text[k];\\n            if((k+1)%c==0){\\n                i++;\\n                j=0;\\n            }            \\n        }\\n        \\n        int x=0;\\n        i=0; j=x;\\n        string ans=\"\";\\n        \\n        while(i<r && j<c){\\n            ans+=grid[i++][j++];\\n            if(i==r || j==c){\\n                i=0;\\n                j=++x;\\n            }\\n        }\\n        \\n        while(ans.back()==\\' \\') ans.pop_back();\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string text, int r) {\\n        int c=text.length()/r;\\n        \\n        vector<vector<char>> grid(r, vector<char>(c, \\' \\'));\\n        \\n        int i=0, j=0;\\n        for(int k=0; k<text.length(); k++){\\n            grid[i][j++]=text[k];\\n            if((k+1)%c==0){\\n                i++;\\n                j=0;\\n            }            \\n        }\\n        \\n        int x=0;\\n        i=0; j=x;\\n        string ans=\"\";\\n        \\n        while(i<r && j<c){\\n            ans+=grid[i++][j++];\\n            if(i==r || j==c){\\n                i=0;\\n                j=++x;\\n            }\\n        }\\n        \\n        while(ans.back()==\\' \\') ans.pop_back();\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2724208,
                "title": "c-easy-short",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n   string decodeCiphertext(string e, int rows) {\\n\\t\\tint size=e.size();\\n\\t\\tint col=size/rows;\\n\\t\\tstring ans;\\n\\t\\tfor(int i=0;i<col;i++)\\n\\t\\t{\\n\\t\\t\\tfor(int j=i;j<size;j+=col+1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tans+=e[j];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\twhile (isspace(ans.back()))\\n\\t\\t{\\n\\t\\t\\tans.pop_back();\\n\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   string decodeCiphertext(string e, int rows) {\\n\\t\\tint size=e.size();\\n\\t\\tint col=size/rows;\\n\\t\\tstring ans;\\n\\t\\tfor(int i=0;i<col;i++)\\n\\t\\t{\\n\\t\\t\\tfor(int j=i;j<size;j+=col+1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tans+=e[j];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\twhile (isspace(ans.back()))\\n\\t\\t{\\n\\t\\t\\tans.pop_back();\\n\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2721989,
                "title": "c-sol-run-97-mem-96-simple-solution-commented",
                "content": "```\\nclass Solution {\\npublic:\\n    int find_next(int &r,int &c,int rows,int cols) { // Function to find and set next r and c in matrix\\n        if(r!=rows-1) { // If not last row, traverse diagonally\\n            r++;c++;\\n        }\\n        else { // If last row reset to top row of matrix and set column respectively\\n            r=0;c=c-(rows-2); \\n        }\\n        return r*cols+c; // Finding index in the given string\\n    }\\n    string decodeCiphertext(string encodedText, int rows) {\\n        int r=0,c=0,index=0;\\n        string ans=\"\";\\n        int cols=encodedText.length()/rows;\\n        while(index<encodedText.length()) {\\n            ans+=encodedText[index];\\n            index=find_next(r,c,rows,cols);\\n        }\\n        while(ans.back()==\\' \\') ans.pop_back(); // Removing trailing spaces in the answer\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int find_next(int &r,int &c,int rows,int cols) { // Function to find and set next r and c in matrix\\n        if(r!=rows-1) { // If not last row, traverse diagonally\\n            r++;c++;\\n        }\\n        else { // If last row reset to top row of matrix and set column respectively\\n            r=0;c=c-(rows-2); \\n        }\\n        return r*cols+c; // Finding index in the given string\\n    }\\n    string decodeCiphertext(string encodedText, int rows) {\\n        int r=0,c=0,index=0;\\n        string ans=\"\";\\n        int cols=encodedText.length()/rows;\\n        while(index<encodedText.length()) {\\n            ans+=encodedText[index];\\n            index=find_next(r,c,rows,cols);\\n        }\\n        while(ans.back()==\\' \\') ans.pop_back(); // Removing trailing spaces in the answer\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2721766,
                "title": "python-solution-matrix",
                "content": "# Algorithm\\nThe solution makes use of a matrix. From the problem statement we are given the following:\\n1. encodedText\\n2. Number of rows\\n\\nFrom the above, we can calculate the number of columns.\\n**Number of columns (cols) = length of the text / number of rows**\\n\\nSteps for matrix creation:\\n1. Create an **index** to iterate over the encodedText, **row** and **col** to iterate through the matrix.\\n2. For each cell in the matrix insert the character from the text\\n\\n# Example\\nMatrix created from \\nencodedText = \"ch   ie   pr\" => ***(length = 12)***\\nrows = 3\\ncols = 4  => ***(12 / 3)***\\n\\n[[\\'c\\', \\'h\\', \\' \\', \\' \\'], \\n [\\' \\', \\'i\\', \\'e\\', \\' \\'], \\n [\\' \\', \\' \\', \\'p\\', \\'r\\']]\\n \\n Iterate though the cols. For each column increment though the row.\\n \\n#  Code\\n```\\n\\t\\tmatrix = []\\n        cols = len(encodedText) // rows\\n        index = 0\\n        for row in range(rows):\\n            temp = []\\n            for col in range(cols):\\n                char = encodedText[index]\\n                temp.append(char)\\n                index += 1\\n            matrix.append(temp)\\n        result = \"\"\\n        \\n        col = 0 # Keeping track of the start after completion of the inner for loop\\n        for _ in range(cols):\\n            r_index, c_index = 0, _\\n            while r_index < rows and c_index < cols:\\n                result += matrix[r_index][c_index]\\n                r_index += 1\\n                c_index += 1\\n            col += 1\\n        return result.rstrip()\\n```",
                "solutionTags": [
                    "Python3",
                    "Matrix"
                ],
                "code": "```\\n\\t\\tmatrix = []\\n        cols = len(encodedText) // rows\\n        index = 0\\n        for row in range(rows):\\n            temp = []\\n            for col in range(cols):\\n                char = encodedText[index]\\n                temp.append(char)\\n                index += 1\\n            matrix.append(temp)\\n        result = \"\"\\n        \\n        col = 0 # Keeping track of the start after completion of the inner for loop\\n        for _ in range(cols):\\n            r_index, c_index = 0, _\\n            while r_index < rows and c_index < cols:\\n                result += matrix[r_index][c_index]\\n                r_index += 1\\n                c_index += 1\\n            col += 1\\n        return result.rstrip()\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2690629,
                "title": "python-easy-way",
                "content": "# Code\\n```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        if rows == 1:\\n            return encodedText\\n        \\n        col = int(len(encodedText) / rows)\\n        lines = [[\\' \\' for _ in range(col)] for _ in range(rows)]\\n        for idx, c in enumerate(encodedText):\\n            lines[idx // col][(idx % col)] = c\\n        \\n        originalText = \"\"\\n\\n        for c in range(col):\\n            begin = c\\n            i = 0\\n            for r in range(rows):\\n                if c+i >= col:\\n                    break\\n\\n                originalText += lines[r][c+i]\\n                i += 1\\n        \\n\\n        return originalText.rstrip()\\n                \\n                \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        if rows == 1:\\n            return encodedText\\n        \\n        col = int(len(encodedText) / rows)\\n        lines = [[\\' \\' for _ in range(col)] for _ in range(rows)]\\n        for idx, c in enumerate(encodedText):\\n            lines[idx // col][(idx % col)] = c\\n        \\n        originalText = \"\"\\n\\n        for c in range(col):\\n            begin = c\\n            i = 0\\n            for r in range(rows):\\n                if c+i >= col:\\n                    break\\n\\n                originalText += lines[r][c+i]\\n                i += 1\\n        \\n\\n        return originalText.rstrip()\\n                \\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2652361,
                "title": "easy-c-clean-easy-code",
                "content": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        if(rows == 1)\\n            return encodedText;\\n        int l = encodedText.length();\\n        int col = l/rows;\\n        vector<vector<char>> mat(rows, vector<char> (col));\\n        int val = 0;\\n        for(int i = 0 ; i < rows; i++)\\n        {\\n            for(int j = 0 ; j < col ;j++)\\n            {\\n                mat[i][j] = encodedText[val];\\n                val++;\\n            }\\n        }\\n        string ans = \"\";\\n        for(int i = 0; i < col; i++)\\n        {\\n            int row = 0;\\n            int c = i;\\n            while(c < col and row < rows)\\n                ans += mat[row++][c++];\\n        }\\n        while(ans.back() == \\' \\')\\n            ans.pop_back();\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        if(rows == 1)\\n            return encodedText;\\n        int l = encodedText.length();\\n        int col = l/rows;\\n        vector<vector<char>> mat(rows, vector<char> (col));\\n        int val = 0;\\n        for(int i = 0 ; i < rows; i++)\\n        {\\n            for(int j = 0 ; j < col ;j++)\\n            {\\n                mat[i][j] = encodedText[val];\\n                val++;\\n            }\\n        }\\n        string ans = \"\";\\n        for(int i = 0; i < col; i++)\\n        {\\n            int row = 0;\\n            int c = i;\\n            while(c < col and row < rows)\\n                ans += mat[row++][c++];\\n        }\\n        while(ans.back() == \\' \\')\\n            ans.pop_back();\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2647509,
                "title": "cpp-solution-easy-o-n-2",
                "content": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        int n = encodedText.size();\\n        int cols = n / rows;\\n        vector<vector<char>> arr(rows, vector<char>(cols));\\n        int k = 0;\\n        \\n\\t\\t// filling the vector\\n        for(int i = 0; i < rows; i++) {\\n            for(int j = 0; j < cols; j++) {\\n                arr[i][j] = encodedText[k++];\\n            }\\n        }\\n        \\n        string original = \"\";\\n        \\n\\t\\t// diagonal traversal as shown in image \\n        for(int col = 0; col < cols; col++) {\\n            int r = 0;\\n            int c = col;\\n            while(c < cols and r < rows) {\\n                original += arr[r++][c++];\\n            }\\n        }\\n        \\n\\t\\t// removing trailing zeros\\n        while(original.back() == \\' \\') original.pop_back();\\n        \\n        return original;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        int n = encodedText.size();\\n        int cols = n / rows;\\n        vector<vector<char>> arr(rows, vector<char>(cols));\\n        int k = 0;\\n        \\n\\t\\t// filling the vector\\n        for(int i = 0; i < rows; i++) {\\n            for(int j = 0; j < cols; j++) {\\n                arr[i][j] = encodedText[k++];\\n            }\\n        }\\n        \\n        string original = \"\";\\n        \\n\\t\\t// diagonal traversal as shown in image \\n        for(int col = 0; col < cols; col++) {\\n            int r = 0;\\n            int c = col;\\n            while(c < cols and r < rows) {\\n                original += arr[r++][c++];\\n            }\\n        }\\n        \\n\\t\\t// removing trailing zeros\\n        while(original.back() == \\' \\') original.pop_back();\\n        \\n        return original;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2619486,
                "title": "java-o-n-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public String decodeCiphertext(String encodedText, int rows) {\\n        int len = encodedText.length();\\n        int cols = (len % rows == 0) ? len / rows : (len / rows + 1);\\n\\n        StringBuilder sb = new StringBuilder();\\n        int i = 0;\\n        int count = 0;\\n        \\n        while (i * cols + (i + count) < len) {\\n            sb.append(encodedText.charAt(i * cols + (i + count)));\\n            count += (i + 1) / rows;\\n            i = (i + 1) % rows;\\n        }\\n        return sb.toString().stripTrailing();\\n    }\\n    // Time complexity: O(N)\\n    // Space complexity: O(1)\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String decodeCiphertext(String encodedText, int rows) {\\n        int len = encodedText.length();\\n        int cols = (len % rows == 0) ? len / rows : (len / rows + 1);\\n\\n        StringBuilder sb = new StringBuilder();\\n        int i = 0;\\n        int count = 0;\\n        \\n        while (i * cols + (i + count) < len) {\\n            sb.append(encodedText.charAt(i * cols + (i + count)));\\n            count += (i + 1) / rows;\\n            i = (i + 1) % rows;\\n        }\\n        return sb.toString().stripTrailing();\\n    }\\n    // Time complexity: O(N)\\n    // Space complexity: O(1)\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2616890,
                "title": "c-easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string e, int rows) {\\n        \\n        int c=e.length()/rows;\\n        string ans; \\n        \\n        for(int j=0;j<c;j++)\\n        {  \\n            int rh=0;\\n            int ch=j;\\n            for(int i=0;i<rows;i++)\\n            {\\n                 int z=rh*c+ ch;\\n                ans.push_back(e[z]);\\n                  rh++;\\n                  ch++;\\n                \\n                if(rh>=rows ||ch>=c)\\n                    break;\\n            }       \\n        }   \\n            \\n        for(int i=ans.length()-1;i>=0;i--)\\n        {\\n            if(ans[i]==\\' \\')\\n               ans.pop_back();\\n            else\\n                break;\\n        }\\n                return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string e, int rows) {\\n        \\n        int c=e.length()/rows;\\n        string ans; \\n        \\n        for(int j=0;j<c;j++)\\n        {  \\n            int rh=0;\\n            int ch=j;\\n            for(int i=0;i<rows;i++)\\n            {\\n                 int z=rh*c+ ch;\\n                ans.push_back(e[z]);\\n                  rh++;\\n                  ch++;\\n                \\n                if(rh>=rows ||ch>=c)\\n                    break;\\n            }       \\n        }   \\n            \\n        for(int i=ans.length()-1;i>=0;i--)\\n        {\\n            if(ans[i]==\\' \\')\\n               ans.pop_back();\\n            else\\n                break;\\n        }\\n                return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2604545,
                "title": "python-simple-solution",
                "content": "```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        numRows, numCols, res = rows, len(encodedText) // rows, []\\n        for first in range(numCols):\\n            res.append(encodedText[first])\\n            for second in range(first + numCols + 1, numRows * numCols, numCols + 1):\\n                res.append(encodedText[second])\\n        return \\'\\'.join(res).rstrip()\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        numRows, numCols, res = rows, len(encodedText) // rows, []\\n        for first in range(numCols):\\n            res.append(encodedText[first])\\n            for second in range(first + numCols + 1, numRows * numCols, numCols + 1):\\n                res.append(encodedText[second])\\n        return \\'\\'.join(res).rstrip()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2603496,
                "title": "javascript",
                "content": "```\\nfunction decodeCiphertext(encodedText: string, rows: number): string {\\n    let colunm = encodedText.length / rows;\\n    let output = \\'\\';\\n    for (var i = 0; i < colunm; i++) {\\n        output += encodedText[i];\\n        let j = i + colunm + 1;\\n        while(j < encodedText.length) {\\n            output += encodedText[j];\\n            j = j + colunm +1;\\n        }\\n    }\\n    return output.replace(/\\\\s*$/, \\'\\');\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nfunction decodeCiphertext(encodedText: string, rows: number): string {\\n    let colunm = encodedText.length / rows;\\n    let output = \\'\\';\\n    for (var i = 0; i < colunm; i++) {\\n        output += encodedText[i];\\n        let j = i + colunm + 1;\\n        while(j < encodedText.length) {\\n            output += encodedText[j];\\n            j = j + colunm +1;\\n        }\\n    }\\n    return output.replace(/\\\\s*$/, \\'\\');\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2550611,
                "title": "java-two-pointer-approach-optimized-code",
                "content": "```\\nclass Solution {\\n    public String decodeCiphertext(String encodedText, int rows) {\\n        int n = encodedText.length()/rows ;\\n        int m = encodedText.length() ;\\n        StringBuffer originalText = new StringBuffer() ;\\n        \\n        for (int i = 0; i < n; i++) {\\n            originalText.append(encodedText.charAt(i)) ;\\n            for (int j = i+n+1; j < m; j += n+1)\\n                originalText.append(encodedText.charAt(j)) ;\\n        }\\n        int lastIndex = originalText.length()-1 ;\\n        \\n        for (int k = lastIndex; k >= 0; k--)\\n            if (originalText.charAt(k) == \\' \\') lastIndex-- ;\\n            else break ;\\n        \\n        String result = originalText.toString() ;\\n        return result.substring(0, lastIndex+1) ;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public String decodeCiphertext(String encodedText, int rows) {\\n        int n = encodedText.length()/rows ;\\n        int m = encodedText.length() ;\\n        StringBuffer originalText = new StringBuffer() ;\\n        \\n        for (int i = 0; i < n; i++) {\\n            originalText.append(encodedText.charAt(i)) ;\\n            for (int j = i+n+1; j < m; j += n+1)\\n                originalText.append(encodedText.charAt(j)) ;\\n        }\\n        int lastIndex = originalText.length()-1 ;\\n        \\n        for (int k = lastIndex; k >= 0; k--)\\n            if (originalText.charAt(k) == \\' \\') lastIndex-- ;\\n            else break ;\\n        \\n        String result = originalText.toString() ;\\n        return result.substring(0, lastIndex+1) ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2510951,
                "title": "python-solution-simple-explanation",
                "content": "res=\"\"\\n\\n        \\n        #find the number of columns for the matrix\\n        col=int(len(encodedText)/rows)\\n        lst= [[0]*col for i in range(rows)] \\n        \\n        \\n        #create matrix and put the characters of the string to its correct location\\n        for i in range(rows):\\n            lst[i]= encodedText[i*col:(i*col)+col]\\n            \\n        \\n        \\n        # retrive the matrix to get original string    \\n        for i in range(col):\\n            for j in range(rows):\\n                if i+j > col-1:\\n                    break\\n                else:\\n                    res=res+lst[j][j+i]\\n\\t\\t\\t\\t\\t\\n\\t\\t#return the decoded string with right trailing space removed\\t\\t\\t\\n        return res.rstrip()",
                "solutionTags": [
                    "String"
                ],
                "code": "res=\"\"\\n\\n        \\n        #find the number of columns for the matrix\\n        col=int(len(encodedText)/rows)\\n        lst= [[0]*col for i in range(rows)] \\n        \\n        \\n        #create matrix and put the characters of the string to its correct location\\n        for i in range(rows):\\n            lst[i]= encodedText[i*col:(i*col)+col]\\n            \\n        \\n        \\n        # retrive the matrix to get original string    \\n        for i in range(col):\\n            for j in range(rows):\\n                if i+j > col-1:\\n                    break\\n                else:\\n                    res=res+lst[j][j+i]\\n\\t\\t\\t\\t\\t\\n\\t\\t#return the decoded string with right trailing space removed\\t\\t\\t\\n        return res.rstrip()",
                "codeTag": "Unknown"
            },
            {
                "id": 2493684,
                "title": "c-solution-simulation",
                "content": "### C++:\\n```\\nclass Solution {\\n    void removeTrailingSpaces(string& str)\\n    {\\n        int end = str.size()-1;\\n\\n        for (int i = str.size()-1; i >= 0; i--)\\n        {\\n            if (str[i] != \\' \\')\\n                break;\\n            else\\n                end--;\\n        }\\n        \\n        str.erase(str.begin()+end+1,str.end());\\n    }\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        \\n        if (encodedText.empty())\\n            return \"\";\\n        \\n        int columns = encodedText.size() / rows;\\n        \\n        vector<vector<char>> matrix(rows, vector<char>(columns));\\n        \\n        int encodedIndex = 0;\\n        for (int i = 0; i < rows; i++)\\n        {\\n            for (int j = 0; j < columns; j++)\\n            {\\n                if (encodedIndex < encodedText.size())\\n                    matrix[i][j] = encodedText[encodedIndex++];\\n            }\\n        }\\n        \\n        string res;\\n        int i = 0, j = 0;\\n        int orgJ = 0;\\n        \\n        while (true)\\n        {\\n            res.push_back(matrix[i][j]);\\n            \\n            if (i+1 == rows or j+1 == columns)\\n            {\\n                if (orgJ == columns-1)\\n                    break;\\n                \\n                i = 0;\\n                j = ++orgJ;\\n            }\\n            else\\n            {\\n                i++;\\n                j++;\\n            }\\n            \\n        }\\n        \\n        removeTrailingSpaces(res);\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    void removeTrailingSpaces(string& str)\\n    {\\n        int end = str.size()-1;\\n\\n        for (int i = str.size()-1; i >= 0; i--)\\n        {\\n            if (str[i] != \\' \\')\\n                break;\\n            else\\n                end--;\\n        }\\n        \\n        str.erase(str.begin()+end+1,str.end());\\n    }\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        \\n        if (encodedText.empty())\\n            return \"\";\\n        \\n        int columns = encodedText.size() / rows;\\n        \\n        vector<vector<char>> matrix(rows, vector<char>(columns));\\n        \\n        int encodedIndex = 0;\\n        for (int i = 0; i < rows; i++)\\n        {\\n            for (int j = 0; j < columns; j++)\\n            {\\n                if (encodedIndex < encodedText.size())\\n                    matrix[i][j] = encodedText[encodedIndex++];\\n            }\\n        }\\n        \\n        string res;\\n        int i = 0, j = 0;\\n        int orgJ = 0;\\n        \\n        while (true)\\n        {\\n            res.push_back(matrix[i][j]);\\n            \\n            if (i+1 == rows or j+1 == columns)\\n            {\\n                if (orgJ == columns-1)\\n                    break;\\n                \\n                i = 0;\\n                j = ++orgJ;\\n            }\\n            else\\n            {\\n                i++;\\n                j++;\\n            }\\n            \\n        }\\n        \\n        removeTrailingSpaces(res);\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2490448,
                "title": "python-3-straightforward",
                "content": "\\tclass Solution:\\n\\t\\tdef decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n\\t\\t\\tres=[]\\n\\t\\t\\tsize=len(encodedText)//rows\\n\\t\\t\\tfor i in range(size):\\n\\t\\t\\t\\tfor k in range(i,len(encodedText),size+1):\\n\\t\\t\\t\\t\\tres.append(encodedText[k])\\n\\t\\t\\treturn \\'\\'.join(res).rstrip()",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n\\t\\t\\tres=[]\\n\\t\\t\\tsize=len(encodedText)//rows\\n\\t\\t\\tfor i in range(size):\\n\\t\\t\\t\\tfor k in range(i,len(encodedText),size+1):\\n\\t\\t\\t\\t\\tres.append(encodedText[k])\\n\\t\\t\\treturn \\'\\'.join(res).rstrip()",
                "codeTag": "Java"
            },
            {
                "id": 2484168,
                "title": "leap-numberofcolumns-1",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tstring decodeCiphertext(string str, int rows) {\\n\\t\\t\\tint c=str.length()/rows;\\n\\t\\t\\tstring res=\"\";\\n\\t\\t\\tfor(int i=0;i<c;i++){\\n\\t\\t\\t\\tfor(int j=i;j<str.length();j+=c+1){\\n\\t\\t\\t\\t\\tres+=str[j];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tint n=res.length()-1;\\n\\t\\t\\twhile(n>=0&&res[n]==\\' \\') n--;\\n\\t\\t\\tres=res.substr(0,n+1);\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C",
                    "Matrix"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tstring decodeCiphertext(string str, int rows) {\\n\\t\\t\\tint c=str.length()/rows;\\n\\t\\t\\tstring res=\"\";\\n\\t\\t\\tfor(int i=0;i<c;i++){\\n\\t\\t\\t\\tfor(int j=i;j<str.length();j+=c+1){\\n\\t\\t\\t\\t\\tres+=str[j];\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2449161,
                "title": "java-easy-implementation",
                "content": "```\\n   class Solution {\\n        public String decodeCiphertext(String encodedText, int rows) {\\n\\n            int col = encodedText.length() / rows;\\n            char[][] mat = new char[rows][col];\\n            for (char[] c : mat) Arrays.fill(c, \\' \\');\\n            \\n            int r = 0, c = 0;\\n            for (int i = 0; i < encodedText.length(); i++) {\\n                if (c >= col) {\\n                    c = 0;\\n                    ++r;\\n                }\\n                \\n                mat[r][c++] = encodedText.charAt(i);\\n            }\\n\\n            StringBuilder sb = new StringBuilder();\\n            int p, q;\\n            int ind = 0;\\n            while (ind < col) {\\n                p = 0;\\n                q = ind;\\n\\n                // keep mv diagonally down\\n                while (p < rows && q < col) sb.append(mat[p++][q++]);\\n                ind++;\\n            }\\n\\n            return sb.toString().replaceFirst(\"\\\\\\\\s++$\", \"\");\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n   class Solution {\\n        public String decodeCiphertext(String encodedText, int rows) {\\n\\n            int col = encodedText.length() / rows;\\n            char[][] mat = new char[rows][col];\\n            for (char[] c : mat) Arrays.fill(c, \\' \\');\\n            \\n            int r = 0, c = 0;\\n            for (int i = 0; i < encodedText.length(); i++) {\\n                if (c >= col) {\\n                    c = 0;\\n                    ++r;\\n                }\\n                \\n                mat[r][c++] = encodedText.charAt(i);\\n            }\\n\\n            StringBuilder sb = new StringBuilder();\\n            int p, q;\\n            int ind = 0;\\n            while (ind < col) {\\n                p = 0;\\n                q = ind;\\n\\n                // keep mv diagonally down\\n                while (p < rows && q < col) sb.append(mat[p++][q++]);\\n                ind++;\\n            }\\n\\n            return sb.toString().replaceFirst(\"\\\\\\\\s++$\", \"\");\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2366242,
                "title": "python-simple-solution-and-a-bonus-one-liner-solution",
                "content": "- Simple solution:\\n```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        n = len(encodedText)\\n        cols = n // rows\\n        step = cols + 1\\n        res = \"\"\\n        \\n        for i in range(cols):\\n            for j in range(i, n, step):\\n                res += encodedText[j]\\n            \\n        return res.rstrip()\\n```\\n\\n- Looking at the previous solution, we can see that it can be transformed into a one-liner:\\n```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n         return \"\".join(encodedText[j] for i in range(len(encodedText) // rows) for j in range(i, len(encodedText), len(encodedText) // rows + 1)).rstrip()\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        n = len(encodedText)\\n        cols = n // rows\\n        step = cols + 1\\n        res = \"\"\\n        \\n        for i in range(cols):\\n            for j in range(i, n, step):\\n                res += encodedText[j]\\n            \\n        return res.rstrip()\\n```\n```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n         return \"\".join(encodedText[j] for i in range(len(encodedText) // rows) for j in range(i, len(encodedText), len(encodedText) // rows + 1)).rstrip()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2336258,
                "title": "simple",
                "content": "![image](https://assets.leetcode.com/users/images/c2fdab4a-2b0d-4d75-8362-e67029591305_1658843882.4257522.png)\\n\\nDeletion of trailing spaces:\\n\\n<br>\\n\\n![image](https://assets.leetcode.com/users/images/edf9dee2-654a-4ece-9656-8fd61f219ef1_1658850236.0707505.png)\\n\\n<br>\\n\\n```\\nstring decodeCiphertext(string e, int r)\\n{\\n\\tstring out{};\\n\\tfor(int j{}, w(size(e)/r); j<w; ++j)\\n\\t\\tfor(int i{}; i<min(r,w-j); out.push_back(e[i*(w+1)+j]));\\t\\t\\t\\n\\treturn {begin(out), begin(out)+1+out.find_last_not_of(\\' \\')};\\n}\\n```\\n||\\n```\\nstring decodeCiphertext(string e, int r)\\n{\\n\\tstring out;\\n\\tint w(size(e)/r), end{};\\n\\tfor(int j{}; j<w; ++j)\\n\\t\\tfor(int i{}; i<min(r,w-j); ++i)\\n\\t\\t{\\n\\t\\t\\tint x=i*(w+1)+j;\\n\\t\\t\\tout.push_back(e[x]);\\n\\t\\t\\tif(e[x]!=\\' \\') end=size(out);\\n\\t\\t}\\n\\treturn {begin(out), begin(out)+end};\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nstring decodeCiphertext(string e, int r)\\n{\\n\\tstring out{};\\n\\tfor(int j{}, w(size(e)/r); j<w; ++j)\\n\\t\\tfor(int i{}; i<min(r,w-j); out.push_back(e[i*(w+1)+j]));\\t\\t\\t\\n\\treturn {begin(out), begin(out)+1+out.find_last_not_of(\\' \\')};\\n}\\n```\n```\\nstring decodeCiphertext(string e, int r)\\n{\\n\\tstring out;\\n\\tint w(size(e)/r), end{};\\n\\tfor(int j{}; j<w; ++j)\\n\\t\\tfor(int i{}; i<min(r,w-j); ++i)\\n\\t\\t{\\n\\t\\t\\tint x=i*(w+1)+j;\\n\\t\\t\\tout.push_back(e[x]);\\n\\t\\t\\tif(e[x]!=\\' \\') end=size(out);\\n\\t\\t}\\n\\treturn {begin(out), begin(out)+end};\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2251018,
                "title": "simple-python-solution-7-lines-of-code-only",
                "content": "1. Notice that the next letter is always ```cols+1``` away from the current letter.\\n2. Once we reach the end of ```encodedText```, we continue from the next column in the first row.\\n\\n```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        cols = len(encodedText)//rows\\n        results = []\\n        for i in range(cols):\\n            while i < len(encodedText):\\n                results.append(encodedText[i])\\n                i += cols + 1\\n            \\n        return \\'\\'.join(results).rstrip()\\n```",
                "solutionTags": [],
                "code": "```cols+1```\n```encodedText```\n```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        cols = len(encodedText)//rows\\n        results = []\\n        for i in range(cols):\\n            while i < len(encodedText):\\n                results.append(encodedText[i])\\n                i += cols + 1\\n            \\n        return \\'\\'.join(results).rstrip()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2226175,
                "title": "iterative-solution-no-extra-space-c",
                "content": "Please upvote if you like my solution .\\n```\\nclass Solution {\\npublic:\\n    \\n    string decodeCiphertext(string eT, int r) {\\n        int len = eT.length();\\n        if(len == 0) return eT;\\n        if(r == 1) return eT;\\n        string ans;\\n        int c = len/r;\\n        int i=0,u=0;\\n        while(i != c-1){\\n            int l = ans.length()-1;\\n            ans += eT[i];\\n            i += c+1;\\n            if(i>=len) i = ++u;\\n        }\\n        ans += eT[i];\\n        while(ans[ans.size() - 1] == \\' \\')  ans.pop_back();\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    string decodeCiphertext(string eT, int r) {\\n        int len = eT.length();\\n        if(len == 0) return eT;\\n        if(r == 1) return eT;\\n        string ans;\\n        int c = len/r;\\n        int i=0,u=0;\\n        while(i != c-1){\\n            int l = ans.length()-1;\\n            ans += eT[i];\\n            i += c+1;\\n            if(i>=len) i = ++u;\\n        }\\n        ans += eT[i];\\n        while(ans[ans.size() - 1] == \\' \\')  ans.pop_back();\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2190758,
                "title": "python-compute-the-index-one-pass-easy-to-understand",
                "content": "The logic is to find the number of columns based on the length of encodedText. The floor or integer divison is helpful here. \\n\\nI compute the index of row and column of imaginary matrix (no need to build the matrix). Then compute the corresponding index in the encodedText. We traverse the diagonal to reach end of current diagonal. That means the r (row_index) has reached to last row (rows - 1). Then increase the curr_diag (current diagnoal index) and continue from the top row again with the col starting at curr_diag. \\n\\n\\t\\n\\tdef decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        if rows==1:\\n            return encodedText\\n        \\n        num_col = len(encodedText) // rows\\n        ans = []\\n        r, c, curr_diag = 0, 0, 0\\n        \\n        while curr_diag < num_col:\\n            idx = r * num_col + c\\n            # we reached the right top position in the matrix\\n            if idx >= len(encodedText):\\n                break\\n            ans.append(encodedText[idx])\\n            if r == rows - 1:\\n                curr_diag += 1\\n                r = 0\\n                c = curr_diag\\n            else:\\n                r += 1\\n                c += 1\\n        \\n        return \\'\\'.join(ans).rstrip()\\n    \\nI thinkg the time complexity is linear O(N) where N is the len(encodedText) and Space complexity is O(M) where M is the length of the decoded message since I have to create the string in the end. Otherwise, during the computation, I only have few pointers and I need O(1) space for them.\\t\\n\\nPlease share your suggestions on how to improve the solution.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "The logic is to find the number of columns based on the length of encodedText. The floor or integer divison is helpful here. \\n\\nI compute the index of row and column of imaginary matrix (no need to build the matrix). Then compute the corresponding index in the encodedText. We traverse the diagonal to reach end of current diagonal. That means the r (row_index) has reached to last row (rows - 1). Then increase the curr_diag (current diagnoal index) and continue from the top row again with the col starting at curr_diag. \\n\\n\\t\\n\\tdef decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        if rows==1:\\n            return encodedText\\n        \\n        num_col = len(encodedText) // rows\\n        ans = []\\n        r, c, curr_diag = 0, 0, 0\\n        \\n        while curr_diag < num_col:\\n            idx = r * num_col + c\\n            # we reached the right top position in the matrix\\n            if idx >= len(encodedText):\\n                break\\n            ans.append(encodedText[idx])\\n            if r == rows - 1:\\n                curr_diag += 1\\n                r = 0\\n                c = curr_diag\\n            else:\\n                r += 1\\n                c += 1\\n        \\n        return \\'\\'.join(ans).rstrip()\\n    \\nI thinkg the time complexity is linear O(N) where N is the len(encodedText) and Space complexity is O(M) where M is the length of the decoded message since I have to create the string in the end. Otherwise, during the computation, I only have few pointers and I need O(1) space for them.\\t\\n\\nPlease share your suggestions on how to improve the solution.",
                "codeTag": "Python3"
            },
            {
                "id": 2159521,
                "title": "step-by-step-approach-easyy-intuitive-thinking",
                "content": "```\\n string decodeCiphertext(string encode, int rows) {\\n        \\n        if(encode.empty())  //if encode kuch hai hi nahi\\n            return \"\";\\n        \\n        int k=0,cols=encode.size()/rows;    //  cols= total_size/rows  (SIMPLE)\\n        vector<vector<char>> arr(rows,vector<char> (cols,\\' \\'));\\n        \\n        //step 1 Fill the code in the matrix\\n        \\n        for(int i=0;i<rows;i++)\\n           for(int j=0;j<cols;j++)\\n                arr[i][j]=encode[k++];\\n         \\n        //Step 2 Decode the code through diagonal traversal\\n        \\n        string ans=\"\";\\n        for(int k=0;k<cols;k++)\\n        {\\n            int i=0,j=k;\\n            while(i<rows and j<cols)\\n                ans+=arr[i++][j++];\\n        }\\n        \\n        //Step 3 Removing trailing whitespaces from answer\\n        int idx=ans.size()-1;\\n        while(ans[idx]==\\' \\')\\n            idx--;\\n        \\n        return ans.substr(0,idx+1);\\n    }",
                "solutionTags": [],
                "code": "```\\n string decodeCiphertext(string encode, int rows) {\\n        \\n        if(encode.empty())  //if encode kuch hai hi nahi\\n            return \"\";\\n        \\n        int k=0,cols=encode.size()/rows;    //  cols= total_size/rows  (SIMPLE)\\n        vector<vector<char>> arr(rows,vector<char> (cols,\\' \\'));\\n        \\n        //step 1 Fill the code in the matrix\\n        \\n        for(int i=0;i<rows;i++)\\n           for(int j=0;j<cols;j++)\\n                arr[i][j]=encode[k++];\\n         \\n        //Step 2 Decode the code through diagonal traversal\\n        \\n        string ans=\"\";\\n        for(int k=0;k<cols;k++)\\n        {\\n            int i=0,j=k;\\n            while(i<rows and j<cols)\\n                ans+=arr[i++][j++];\\n        }\\n        \\n        //Step 3 Removing trailing whitespaces from answer\\n        int idx=ans.size()-1;\\n        while(ans[idx]==\\' \\')\\n            idx--;\\n        \\n        return ans.substr(0,idx+1);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2065097,
                "title": "c-code",
                "content": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n       string res; \\n       if (!rows ||!encodedText.size()) return res;\\n       int col = encodedText.size()/rows;    \\n       int step = 0, x = 0, y = 0;\\n       while(step < col) { \\n            res += encodedText[y*col+x];             \\n            x++; y++; \\n            if (y >= rows || x >= col) { y = 0; x = ++step; }   \\n       } \\n       while(res.back()==\\' \\') res.resize(res.size()-1); \\n       return res; \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n       string res; \\n       if (!rows ||!encodedText.size()) return res;\\n       int col = encodedText.size()/rows;    \\n       int step = 0, x = 0, y = 0;\\n       while(step < col) { \\n            res += encodedText[y*col+x];             \\n            x++; y++; \\n            if (y >= rows || x >= col) { y = 0; x = ++step; }   \\n       } \\n       while(res.back()==\\' \\') res.resize(res.size()-1); \\n       return res; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2045726,
                "title": "python-solution-clean-code",
                "content": "```\\nclass Solution:\\n\\tdef decodeCiphertext(self, e: str, r: int) -> str:\\n        n = len(e)\\n        it = (n // r) + 1\\n        ans = \"\"\\n        if r == 1:\\n            return e\\n        for i in range(it - 1):\\n            ans += e[i:n:it]\\n        return ans.rstrip(\" \")\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n\\tdef decodeCiphertext(self, e: str, r: int) -> str:\\n        n = len(e)\\n        it = (n // r) + 1\\n        ans = \"\"\\n        if r == 1:\\n            return e\\n        for i in range(it - 1):\\n            ans += e[i:n:it]\\n        return ans.rstrip(\" \")\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2031681,
                "title": "calculate-columns-and-jump-column-1-java",
                "content": "```\\nclass Solution {\\n    public String decodeCiphertext(String encodedText, int rows) {\\n        if(rows==1||encodedText.length()==0){\\n            return encodedText;\\n        }\\n        int col=encodedText.length()/rows;\\n        StringBuilder ans=new StringBuilder();\\n        for(int i=0;i<col;i++){\\n            int k=i;\\n            for(int j=0;j<rows&&k<encodedText.length();j++){\\n            ans.append(encodedText.charAt(k));\\n            k+=col+1;\\n            }\\n        }\\n        \\n        int j=ans.length()-1;\\n        while(ans.charAt(j)==\\' \\'){\\n                j--;\\n        }\\n        return ans.substring(0,j+1);\\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public String decodeCiphertext(String encodedText, int rows) {\\n        if(rows==1||encodedText.length()==0){\\n            return encodedText;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1976128,
                "title": "python-solution-by-building-the-grid",
                "content": "```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        n = len(encodedText)\\n        ans = [\"\"] * n\\n        cols = n//rows\\n        \\n        grid = [[\" \"] * cols for _ in range(rows)]\\n        k = 0\\n        for i, j in product(range(rows), range(cols)):\\n            grid[i][j] = encodedText[k]\\n            k += 1\\n        i, j = 0, 0\\n        l = 0\\n        t = 0\\n        while i < rows and j < cols:\\n            ans[l] = grid[i][j]\\n            i += 1\\n            j += 1\\n            l += 1\\n            if i >= rows:\\n                t += 1\\n                i = 0\\n                j = t\\n            if j >= cols:\\n                break\\n        \\n        finalAns = (\\'\\'.join(ans)).rstrip()\\n        return finalAns\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        n = len(encodedText)\\n        ans = [\"\"] * n\\n        cols = n//rows\\n        \\n        grid = [[\" \"] * cols for _ in range(rows)]\\n        k = 0\\n        for i, j in product(range(rows), range(cols)):\\n            grid[i][j] = encodedText[k]\\n            k += 1\\n        i, j = 0, 0\\n        l = 0\\n        t = 0\\n        while i < rows and j < cols:\\n            ans[l] = grid[i][j]\\n            i += 1\\n            j += 1\\n            l += 1\\n            if i >= rows:\\n                t += 1\\n                i = 0\\n                j = t\\n            if j >= cols:\\n                break\\n        \\n        finalAns = (\\'\\'.join(ans)).rstrip()\\n        return finalAns\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1951361,
                "title": "python-solution-with-anti-diag-property",
                "content": "Important property of 2D matrix:\\n1. a constant value for the **sum** of diag element index: **i+j**\\n2. a constant value for the **difference** of anti_diag element index: **i-j**\\nNote that all of cells are empty in lower-triangle, so we will consider **j-i** only\\n\\n```\\nclass Solution:\\n    def decodeCiphertext(self, txt: str, r: int) -> str:\\n        c = len(txt)//r\\n        res = [[] for _ in range(max(r,c))]\\n        for k in range(len(txt)):\\n            i, j = k//c, k%c\\n            res[j-i].append(txt[k])\\n        res = [\\'\\'.join(l) for l in res]\\n        return \\'\\'.join(res).rstrip()\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def decodeCiphertext(self, txt: str, r: int) -> str:\\n        c = len(txt)//r\\n        res = [[] for _ in range(max(r,c))]\\n        for k in range(len(txt)):\\n            i, j = k//c, k%c\\n            res[j-i].append(txt[k])\\n        res = [\\'\\'.join(l) for l in res]\\n        return \\'\\'.join(res).rstrip()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1951081,
                "title": "python-short-and-fast-faster-than-95-easy-to-understand",
                "content": "![image](https://assets.leetcode.com/users/images/65d90c3c-bea1-4128-990a-3d8e6119ed1c_1650056602.9725244.png)\\n\\'v\\' is the number of slanted lines needed in the cipher table. The algorithm basically is to read along a sloping line and jump a gap and turn to the next one.\\n```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        n = len(encodedText)\\n        l = n//rows\\n        v= l-(rows-1)\\n        ans = \\'\\'\\n        r,i=0,0\\n        while r<v+1:\\n            if i<n:\\n                ans+=encodedText[i]\\n                i+=(l+1)\\n            else:\\n                r+=1;i=r\\n        return ans.rstrip()\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        n = len(encodedText)\\n        l = n//rows\\n        v= l-(rows-1)\\n        ans = \\'\\'\\n        r,i=0,0\\n        while r<v+1:\\n            if i<n:\\n                ans+=encodedText[i]\\n                i+=(l+1)\\n            else:\\n                r+=1;i=r\\n        return ans.rstrip()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1946110,
                "title": "c-95-faster-no-extra-space-no-matrix",
                "content": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        if(rows == 1) return encodedText;\\n        if(encodedText.size()<=1) return encodedText;\\n        string s;\\n        int size = encodedText.length();\\n        int len = size/rows;\\n        for(int i = 0 ; i < len ; i++){\\n            for(int j = 0; j < min(len-i , rows) ; j++){\\n                s += encodedText[i+(len+1)*j];\\n            }\\n        }\\n\\t\\t// to remove extra spaces in the back\\n        size = s.length();\\n        while(s[size-1] == \\' \\')size--;\\n        s = s.substr(0,size);\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        if(rows == 1) return encodedText;\\n        if(encodedText.size()<=1) return encodedText;\\n        string s;\\n        int size = encodedText.length();\\n        int len = size/rows;\\n        for(int i = 0 ; i < len ; i++){\\n            for(int j = 0; j < min(len-i , rows) ; j++){\\n                s += encodedText[i+(len+1)*j];\\n            }\\n        }\\n\\t\\t// to remove extra spaces in the back\\n        size = s.length();\\n        while(s[size-1] == \\' \\')size--;\\n        s = s.substr(0,size);\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1944085,
                "title": "easy-solution-by-preparing-and-traversing-matrix-in-c",
                "content": "```\\npublic class Solution {\\n    public string DecodeCiphertext(string str, int row) {\\n        if(row == 1) return str;\\n        \\n        int k = 0;\\n        int col = str.Length/row;\\n        char[][] matrix = new char[row][];\\n        for(int i =0;i<row;++i)\\n        {\\n            matrix[i] = new char[col];\\n        }\\n        \\n        for(int i = 0; i<row;++i)\\n        {\\n            for(int j = 0; j<col;j++)\\n            {\\n                matrix[i][j] = str[k++];\\n            }\\n        }\\n        \\n        var sb = new StringBuilder();\\n        for(int i = 0; i<col;++i)\\n        {\\n            for(int j = 0; j<row && i+j < col;j++)\\n            {\\n                var ch = matrix[j][i+j];\\n                sb.Append(ch);\\n            }\\n        }\\n        \\n        return sb.ToString().TrimEnd(\\' \\');\\n    }\\n}",
                "solutionTags": [
                    "Matrix"
                ],
                "code": "class Solution {\\n    public string DecodeCiphertext(string str, int row) {\\n        if(row == 1) return str;\\n        \\n        int k = 0;\\n        int col = str.Length/row;\\n        char[][] matrix = new char[row][];\\n        for(int i =0;i<row;++i)\\n        {\\n            matrix[i] = new char[col];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1930015,
                "title": "c-easy-to-understand-simple-logic-diagonal-traversal",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    void solve(string encodedText,string& ans,int row,int m)\\n    {\\n        \\n       for(int j=0;j<m;j++)\\n       {\\n           int r=0;\\n           int c=j;\\n           while(r<row && c<m)\\n           {\\n               ans+=encodedText[r*m+c];\\n               r++;\\n               c++;\\n           }\\n       }\\n    }\\n    string decodeCiphertext(string encodedText, int rows) {\\n        string ans=\"\";\\n        int n=encodedText.length();\\n        int m=n/rows; //no of column\\n      \\n        \\n        solve(encodedText,ans,rows,m);\\n        \\n        while(ans.length()>=1 && ans[ans.length()-1]==\\' \\') //if trailing spaces \\' \\'\\n            ans.pop_back();\\n        \\n        return ans;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    void solve(string encodedText,string& ans,int row,int m)\\n    {\\n        \\n       for(int j=0;j<m;j++)\\n       {\\n           int r=0;\\n           int c=j;\\n           while(r<row && c<m)\\n           {\\n               ans+=encodedText[r*m+c];\\n               r++;\\n               c++;\\n           }\\n       }\\n    }\\n    string decodeCiphertext(string encodedText, int rows) {\\n        string ans=\"\";\\n        int n=encodedText.length();\\n        int m=n/rows; //no of column\\n      \\n        \\n        solve(encodedText,ans,rows,m);\\n        \\n        while(ans.length()>=1 && ans[ans.length()-1]==\\' \\') //if trailing spaces \\' \\'\\n            ans.pop_back();\\n        \\n        return ans;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1879453,
                "title": "java-simple-two-approach",
                "content": "1st\\n```\\nclass Solution {\\n    public String decodeCiphertext(String encodedText, int rows) {\\n        char[][] ch = new char[rows][encodedText.length()/rows];\\n        int index = 0;\\n        for(int i=0;i<ch.length;i++){\\n            for(int j=0;j<ch[0].length;j++){\\n                ch[i][j]= encodedText.charAt(index++);\\n            }\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        for(int gap =0;gap<ch[0].length;gap++){\\n            for(int i=0,j=gap;i<rows && j<encodedText.length()/rows;i++,j++){\\n                sb.append(ch[i][j]);\\n            }\\n        }\\n        while(sb.length()>0 && sb.charAt(sb.length()-1) == \\' \\'){\\n            sb.deleteCharAt(sb.length()-1);\\n        }\\n        return sb.toString();\\n    }\\n}\\n```\\n\\n\\n2nd \\n```\\nclass Solution {\\n    public String decodeCiphertext(String encodedText, int rows) {\\n        if(rows == 1 || encodedText.length() == 0){\\n            return encodedText;\\n        }\\n        int cur = 0;\\n        int start = 0;\\n        int inc = encodedText.length()/rows + 1;\\n        StringBuilder sb = new StringBuilder();\\n        while(start<inc){\\n            sb.append(encodedText.charAt(cur));\\n            cur+=inc;\\n            if(cur>=encodedText.length()){\\n                cur = ++start;\\n            }\\n        }\\n        while(sb.length()>0 && sb.charAt(sb.length()-1) == \\' \\'){\\n            sb.deleteCharAt(sb.length()-1);\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String decodeCiphertext(String encodedText, int rows) {\\n        char[][] ch = new char[rows][encodedText.length()/rows];\\n        int index = 0;\\n        for(int i=0;i<ch.length;i++){\\n            for(int j=0;j<ch[0].length;j++){\\n                ch[i][j]= encodedText.charAt(index++);\\n            }\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        for(int gap =0;gap<ch[0].length;gap++){\\n            for(int i=0,j=gap;i<rows && j<encodedText.length()/rows;i++,j++){\\n                sb.append(ch[i][j]);\\n            }\\n        }\\n        while(sb.length()>0 && sb.charAt(sb.length()-1) == \\' \\'){\\n            sb.deleteCharAt(sb.length()-1);\\n        }\\n        return sb.toString();\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public String decodeCiphertext(String encodedText, int rows) {\\n        if(rows == 1 || encodedText.length() == 0){\\n            return encodedText;\\n        }\\n        int cur = 0;\\n        int start = 0;\\n        int inc = encodedText.length()/rows + 1;\\n        StringBuilder sb = new StringBuilder();\\n        while(start<inc){\\n            sb.append(encodedText.charAt(cur));\\n            cur+=inc;\\n            if(cur>=encodedText.length()){\\n                cur = ++start;\\n            }\\n        }\\n        while(sb.length()>0 && sb.charAt(sb.length()-1) == \\' \\'){\\n            sb.deleteCharAt(sb.length()-1);\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1842300,
                "title": "python3-simple-to-understand",
                "content": "```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        res=[]\\n        cols=len(encodedText)//rows\\n        for j in range(cols):\\n            idx=j\\n            while idx<len(encodedText):\\n                res.append(encodedText[idx])\\n                idx+=cols+1\\n        return \\'\\'.join(res).rstrip()\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        res=[]\\n        cols=len(encodedText)//rows\\n        for j in range(cols):\\n            idx=j\\n            while idx<len(encodedText):\\n                res.append(encodedText[idx])\\n                idx+=cols+1\\n        return \\'\\'.join(res).rstrip()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1798577,
                "title": "c-code",
                "content": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int row) {\\n        string str = \"\";\\n        if(encodedText==\"\")\\n            return str;\\n        if(row == 1)\\n            return encodedText;\\n        int col = encodedText.size()/row;\\n        \\n        vector<char>mat[row];\\n       \\n        for(int k = 0;k<encodedText.size();k++){\\n            int x = floor(k/col);\\n            mat[x].push_back(encodedText[k]);\\n        }\\n        \\n        string res = \"\";\\n        for(int i = 0;i<= mat[0].size();i++){\\n            int j = 0,k = i;\\n            while(j<row && k<col){\\n                res.push_back(mat[j][k]);\\n                j++;\\n                k++;\\n            }\\n        }\\n        int j = res.size()-1;\\n        while(res[j] == \\' \\')\\n            j--;\\n        res = res.substr(0,j+1);\\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int row) {\\n        string str = \"\";\\n        if(encodedText==\"\")\\n            return str;\\n        if(row == 1)\\n            return encodedText;\\n        int col = encodedText.size()/row;\\n        \\n        vector<char>mat[row];\\n       \\n        for(int k = 0;k<encodedText.size();k++){\\n            int x = floor(k/col);\\n            mat[x].push_back(encodedText[k]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1779780,
                "title": "java-recursive",
                "content": "```\\nclass Solution {\\n    private static int ROWS, COLS;\\n    public String decodeCiphertext(String encodedText, int rows) {\\n        ROWS = rows;\\n        COLS = encodedText.length()/rows;\\n        \\n        StringBuilder res = new StringBuilder();\\n        \\n        for(int c = 0; c < COLS; c++){\\n            diag(encodedText, 0, c, res);\\n        }\\n        int l = res.length()-1;\\n        while(l>=0){\\n            if(res.charAt(l)!=\\' \\') break;\\n            l--;\\n        }\\n        res.setLength(l+1);\\n        return res.toString();\\n    }\\n    \\n    private void diag(String enc, int r, int c, StringBuilder res){\\n        \\n        if(r>=ROWS || c>=COLS) return;\\n        \\n        int pos = r*COLS + c;\\n        \\n        res.append(enc.charAt(pos));\\n        diag(enc, ++r, ++c, res);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private static int ROWS, COLS;\\n    public String decodeCiphertext(String encodedText, int rows) {\\n        ROWS = rows;\\n        COLS = encodedText.length()/rows;\\n        \\n        StringBuilder res = new StringBuilder();\\n        \\n        for(int c = 0; c < COLS; c++){\\n            diag(encodedText, 0, c, res);\\n        }\\n        int l = res.length()-1;\\n        while(l>=0){\\n            if(res.charAt(l)!=\\' \\') break;\\n            l--;\\n        }\\n        res.setLength(l+1);\\n        return res.toString();\\n    }\\n    \\n    private void diag(String enc, int r, int c, StringBuilder res){\\n        \\n        if(r>=ROWS || c>=COLS) return;\\n        \\n        int pos = r*COLS + c;\\n        \\n        res.append(enc.charAt(pos));\\n        diag(enc, ++r, ++c, res);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1757057,
                "title": "simple",
                "content": "```\\nclass Solution {\\n    public String decodeCiphertext(String encodedText, int rows) {\\n        if(encodedText.length() == 0 || rows < 2) return encodedText;\\n        \\n        int cols = encodedText.length() / rows;\\n        Map<Integer, Integer> map = new HashMap();\\n        \\n        int row = 0;\\n        for(int x = 1; x <= rows; x++) {\\n            map.put(x, row);\\n            row = 1 + row + cols;\\n        }\\n        \\n        final StringBuilder sb = new StringBuilder();\\n        while(map.size() > 0) {\\n            for(int key = 1 ; key <= rows ; key++) {\\n                if(map.containsKey(key)) {\\n                    int idx = map.get(key);\\n                    if(idx < encodedText.length()) sb.append(encodedText.charAt(idx));\\n\\n                    if((idx + 1) % cols== 0) {\\n                        map.remove(key);\\n                    } else {\\n                        map.put(key, idx + 1);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        while(sb.charAt(sb.length() -1) == \\' \\') {\\n            sb.deleteCharAt(sb.length() -1);\\n        }\\n        \\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String decodeCiphertext(String encodedText, int rows) {\\n        if(encodedText.length() == 0 || rows < 2) return encodedText;\\n        \\n        int cols = encodedText.length() / rows;\\n        Map<Integer, Integer> map = new HashMap();\\n        \\n        int row = 0;\\n        for(int x = 1; x <= rows; x++) {\\n            map.put(x, row);\\n            row = 1 + row + cols;\\n        }\\n        \\n        final StringBuilder sb = new StringBuilder();\\n        while(map.size() > 0) {\\n            for(int key = 1 ; key <= rows ; key++) {\\n                if(map.containsKey(key)) {\\n                    int idx = map.get(key);\\n                    if(idx < encodedText.length()) sb.append(encodedText.charAt(idx));\\n\\n                    if((idx + 1) % cols== 0) {\\n                        map.remove(key);\\n                    } else {\\n                        map.put(key, idx + 1);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        while(sb.charAt(sb.length() -1) == \\' \\') {\\n            sb.deleteCharAt(sb.length() -1);\\n        }\\n        \\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1740992,
                "title": "time-memory-o-n-construct-matrix-and-read-diagonally",
                "content": "### Idea\\n\\nConstruct a matrix for decoding, and read the matrix diagonally from `[0, 0]`.\\n\\n### Complexity\\n\\nTime: `O(n)`\\nSpace: `O(n)`\\nwhere `n = encodedText.length`\\n\\n```typescript\\nfunction decodeCiphertext(encodedText: string, rows: number): string {\\n    const m = rows\\n    const n = encodedText.length / m\\n    const mat = [...Array(m)].map(() => [])\\n    for (let i=0; i<encodedText.length; i+=1) {\\n        mat[Math.floor(i / n)].push(encodedText[i])\\n    }\\n    let text = \"\"\\n    for (let x=0; x<=mat[0].length; x+=1) {\\n        for (let i=0; i<Math.min(m, n-x); i+=1) {\\n            text += mat[i][x+i]\\n        }\\n    }\\n    return text.trimEnd()\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```typescript\\nfunction decodeCiphertext(encodedText: string, rows: number): string {\\n    const m = rows\\n    const n = encodedText.length / m\\n    const mat = [...Array(m)].map(() => [])\\n    for (let i=0; i<encodedText.length; i+=1) {\\n        mat[Math.floor(i / n)].push(encodedText[i])\\n    }\\n    let text = \"\"\\n    for (let x=0; x<=mat[0].length; x+=1) {\\n        for (let i=0; i<Math.min(m, n-x); i+=1) {\\n            text += mat[i][x+i]\\n        }\\n    }\\n    return text.trimEnd()\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1736145,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public String decodeCiphertext(String encodedText, int rows) {\\n        int encodedLength =  encodedText.length();\\n        \\n        int cols = encodedLength/rows;\\n        \\n       StringBuilder res= new StringBuilder();\\n        \\n        \\n        for(int j=0; j<cols; j++) {\\n            int k = j;\\n            for(int i=0; i<rows; i++) {\\n                if(cols*i+k < encodedLength) {\\n                  res.append(encodedText.charAt(cols*i+k));\\n                  k++;\\n                }\\n            }\\n        }\\n        \\n        return res.toString().stripTrailing();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String decodeCiphertext(String encodedText, int rows) {\\n        int encodedLength =  encodedText.length();\\n        \\n        int cols = encodedLength/rows;\\n        \\n       StringBuilder res= new StringBuilder();\\n        \\n        \\n        for(int j=0; j<cols; j++) {\\n            int k = j;\\n            for(int i=0; i<rows; i++) {\\n                if(cols*i+k < encodedLength) {\\n                  res.append(encodedText.charAt(cols*i+k));\\n                  k++;\\n                }\\n            }\\n        }\\n        \\n        return res.toString().stripTrailing();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1726703,
                "title": "2075-decode-the-slanted-ciphertext-beats-98",
                "content": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        \\n        if(encodedText.length()==0)\\n            return \"\";\\n        string ans=\"\";\\n        \\n        int i=0;\\n        int j=0;\\n        int cols=encodedText.length()/rows;\\n        int k=0;\\n        while(i<rows && j<cols && k<cols)\\n        {\\n            ans+=encodedText[i++*cols+k++]; \\n            if(i==rows)\\n            {\\n                j++;\\n                k=j;\\n                i=0;\\n            }\\n        }\\n        \\n        while(ans[ans.length()-1]==\\' \\')\\n            ans.pop_back();\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        \\n        if(encodedText.length()==0)\\n            return \"\";\\n        string ans=\"\";\\n        \\n        int i=0;\\n        int j=0;\\n        int cols=encodedText.length()/rows;\\n        int k=0;\\n        while(i<rows && j<cols && k<cols)\\n        {\\n            ans+=encodedText[i++*cols+k++]; \\n            if(i==rows)\\n            {\\n                j++;\\n                k=j;\\n                i=0;\\n            }\\n        }\\n        \\n        while(ans[ans.length()-1]==\\' \\')\\n            ans.pop_back();\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1700561,
                "title": "simple-diagonal-traversal",
                "content": "```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        m, n = rows, len(encodedText) // rows\\n        op = \"\"\\n        for i in range(n):\\n            for j in range(m):\\n                if i + j < n:\\n                    op += encodedText[(n + 1) * j + i]\\n        return op.rstrip()\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        m, n = rows, len(encodedText) // rows\\n        op = \"\"\\n        for i in range(n):\\n            for j in range(m):\\n                if i + j < n:\\n                    op += encodedText[(n + 1) * j + i]\\n        return op.rstrip()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1682307,
                "title": "javascript-code",
                "content": "```\\n/**\\n * @param {string} encodedText\\n * @param {number} rows\\n * @return {string}\\n */\\nvar decodeCiphertext = function(encodedText, rows) {\\n    if(encodedText == \"\"){\\n        return \"\";\\n    }\\n    var result = [];\\n    var output = \"\";\\n    var data = encodedText.split(\\'\\');\\n    var col = Math.floor(data.length /rows);\\n    \\n    for(let i = 0; i< data.length; i++){\\n        if(i%col == 0){\\n            result.push([]);\\n        }\\n        result[parseInt(i/col)].push(data[i]);\\n    }\\n    \\n    for(let colum = 0; colum < result[0].length; colum++){\\n        let rowNum = 0;\\n        let colNum = colum;\\n        output = output + result[rowNum][colum];\\n        \\n        while(rowNum + 1 <= result.length - 1 && colNum + 1 <= result[0].length - 1){\\n            output = output + result[rowNum + 1][colNum + 1];\\n            rowNum++;\\n            colNum++;\\n        }\\n    }\\n    return output.trimEnd();\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} encodedText\\n * @param {number} rows\\n * @return {string}\\n */\\nvar decodeCiphertext = function(encodedText, rows) {\\n    if(encodedText == \"\"){\\n        return \"\";\\n    }\\n    var result = [];\\n    var output = \"\";\\n    var data = encodedText.split(\\'\\');\\n    var col = Math.floor(data.length /rows);\\n    \\n    for(let i = 0; i< data.length; i++){\\n        if(i%col == 0){\\n            result.push([]);\\n        }\\n        result[parseInt(i/col)].push(data[i]);\\n    }\\n    \\n    for(let colum = 0; colum < result[0].length; colum++){\\n        let rowNum = 0;\\n        let colNum = colum;\\n        output = output + result[rowNum][colum];\\n        \\n        while(rowNum + 1 <= result.length - 1 && colNum + 1 <= result[0].length - 1){\\n            output = output + result[rowNum + 1][colNum + 1];\\n            rowNum++;\\n            colNum++;\\n        }\\n    }\\n    return output.trimEnd();\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1669760,
                "title": "dfs-java",
                "content": "```\\n\\n        StringBuilder sb;\\n    public String decodeCiphertext(String encodedText, int rows) {\\n        \\n        if(rows==1) return encodedText ; \\n        \\n        //1000 \\n        \\n        //constructing the grid  O(n*n)\\n        \\n        //traversing and creating the string O(n*n)\\n        \\n        int col = encodedText.length()/rows; \\n        \\n        \\n        char[][] grid = new char[rows][col];\\n        \\n        int k = 0 ; \\n        \\n        for(int i=0 ;i<rows ; i++){\\n            \\n            for(int j=0 ; j<col ; j++){\\n                \\n                grid[i][j] = encodedText.charAt(k); \\n                \\n                k++;\\n                \\n            }\\n        }\\n        \\n        \\n        sb = new StringBuilder(); \\n        \\n        for(int i=0 ; i<col ; i++){\\n            \\n            dfs(0,i,grid);\\n            \\n        }\\n         \\n        \\n       String regex = \"\\\\\\\\s+$\";\\n        \\n       return sb.toString().replaceAll(regex,\"\");\\n    }\\n    \\n    void dfs(int i , int j, char[][] grid){\\n        \\n        if(i<0 || i>grid.length-1 || j<0 || j>grid[0].length-1) return ;\\n        \\n        sb.append(grid[i][j]);\\n        \\n        dfs(i+1,j+1,grid);\\n        \\n        return ;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\n        StringBuilder sb;\\n    public String decodeCiphertext(String encodedText, int rows) {\\n        \\n        if(rows==1) return encodedText ; \\n        \\n        //1000 \\n        \\n        //constructing the grid  O(n*n)\\n        \\n        //traversing and creating the string O(n*n)\\n        \\n        int col = encodedText.length()/rows; \\n        \\n        \\n        char[][] grid = new char[rows][col];\\n        \\n        int k = 0 ; \\n        \\n        for(int i=0 ;i<rows ; i++){\\n            \\n            for(int j=0 ; j<col ; j++){\\n                \\n                grid[i][j] = encodedText.charAt(k); \\n                \\n                k++;\\n                \\n            }\\n        }\\n        \\n        \\n        sb = new StringBuilder(); \\n        \\n        for(int i=0 ; i<col ; i++){\\n            \\n            dfs(0,i,grid);\\n            \\n        }\\n         \\n        \\n       String regex = \"\\\\\\\\s+$\";\\n        \\n       return sb.toString().replaceAll(regex,\"\");\\n    }\\n    \\n    void dfs(int i , int j, char[][] grid){\\n        \\n        if(i<0 || i>grid.length-1 || j<0 || j>grid[0].length-1) return ;\\n        \\n        sb.append(grid[i][j]);\\n        \\n        dfs(i+1,j+1,grid);\\n        \\n        return ;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1661876,
                "title": "bfs-c-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n\\t/*\\n\\t\\t1. Add the starting index of each appendable characters from each row in a queue.\\n\\t\\t\\n\\t\\t2. Now extract the element, add it into the answer string and push the next character \\n\\t\\tfrom the same row in the queue.\\n\\t\\t\\n\\t\\t3. Do it for the length of the encodedText. Later, trim the ending spaces from the answer string.\\n\\t*/\\n    string decodeCiphertext(string encodedText, int rows) {\\n        int n = encodedText.size();\\n        int cols = n / rows;\\n        queue<int> bfs;\\n        string ans = \"\";\\n        \\n        int i = 1, pointer = 0;\\n        while(i <= rows) {\\n            bfs.push(pointer);\\n            pointer += cols;\\n            pointer += 1;\\n            i++;\\n        }\\n        \\n        for(int i=0; i<n; i++) {\\n            int t = bfs.front();\\n            bfs.pop();\\n            if(t<0 || t>=n) continue;            \\n            ans += encodedText[t++];\\n            bfs.push(t);\\n        }\\n        \\n        int j;\\n        for(j=ans.size()-1; j>=0; j--) {            \\n            if(ans[j] >= \\'a\\' && ans[j] <=\\'z\\') break;\\n        }\\n        \\n        ans.erase(ans.begin()+j+1, ans.end());\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\t/*\\n\\t\\t1. Add the starting index of each appendable characters from each row in a queue.\\n\\t\\t\\n\\t\\t2. Now extract the element, add it into the answer string and push the next character \\n\\t\\tfrom the same row in the queue.\\n\\t\\t\\n\\t\\t3. Do it for the length of the encodedText. Later, trim the ending spaces from the answer string.\\n\\t*/\\n    string decodeCiphertext(string encodedText, int rows) {\\n        int n = encodedText.size();\\n        int cols = n / rows;\\n        queue<int> bfs;\\n        string ans = \"\";\\n        \\n        int i = 1, pointer = 0;\\n        while(i <= rows) {\\n            bfs.push(pointer);\\n            pointer += cols;\\n            pointer += 1;\\n            i++;\\n        }\\n        \\n        for(int i=0; i<n; i++) {\\n            int t = bfs.front();\\n            bfs.pop();\\n            if(t<0 || t>=n) continue;            \\n            ans += encodedText[t++];\\n            bfs.push(t);\\n        }\\n        \\n        int j;\\n        for(j=ans.size()-1; j>=0; j--) {            \\n            if(ans[j] >= \\'a\\' && ans[j] <=\\'z\\') break;\\n        }\\n        \\n        ans.erase(ans.begin()+j+1, ans.end());\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1659037,
                "title": "c-accepted-solution-explained-on-basis-of-hint-s",
                "content": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        int encodeSize = encodedText.size();\\n\\t\\t// HINT 1 - Get Column , using rows and encodedText\\n        int columns = encodeSize/rows;\\n        vector<vector<char>> mat;\\n        int counter = 0;\\n        vector<char> v;\\n\\t\\t// HINT 2 -- Place in matrix\\n        for(int i=0;i<encodeSize;i++)\\n        {\\n\\n            counter++;\\n            v.push_back(encodedText[i]);\\n            if(counter==columns)\\n            {\\n                counter = 0;\\n                mat.push_back(v);\\n                v.clear();\\n            }\\n        }\\n        string ans;\\n        int colCounter = 0;\\n\\t\\t// HINT 3 - Traverse to get originalText\\n        for(int i=0;i<columns;i++)\\n        {\\n            int rowCounter = 0;\\n            for(int j=0;j<rows && j+colCounter<columns;j++)\\n            {\\n                ans.push_back(mat[rowCounter][j+colCounter]);\\n                rowCounter++;\\n            }\\n            colCounter++;\\n        }\\n\\t\\t//Remove extra spaces at last. Can alternatively use pop_back() also\\n        int lastCharCounter = 0;\\n        for(int i=0;i<ans.size();i++)\\n        {\\n            if(ans[i]!=\\' \\')\\n                lastCharCounter = i;\\n        }\\n        return ans.substr(0,lastCharCounter+1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        int encodeSize = encodedText.size();\\n\\t\\t// HINT 1 - Get Column , using rows and encodedText\\n        int columns = encodeSize/rows;\\n        vector<vector<char>> mat;\\n        int counter = 0;\\n        vector<char> v;\\n\\t\\t// HINT 2 -- Place in matrix\\n        for(int i=0;i<encodeSize;i++)\\n        {\\n\\n            counter++;\\n            v.push_back(encodedText[i]);\\n            if(counter==columns)\\n            {\\n                counter = 0;\\n                mat.push_back(v);\\n                v.clear();\\n            }\\n        }\\n        string ans;\\n        int colCounter = 0;\\n\\t\\t// HINT 3 - Traverse to get originalText\\n        for(int i=0;i<columns;i++)\\n        {\\n            int rowCounter = 0;\\n            for(int j=0;j<rows && j+colCounter<columns;j++)\\n            {\\n                ans.push_back(mat[rowCounter][j+colCounter]);\\n                rowCounter++;\\n            }\\n            colCounter++;\\n        }\\n\\t\\t//Remove extra spaces at last. Can alternatively use pop_back() also\\n        int lastCharCounter = 0;\\n        for(int i=0;i<ans.size();i++)\\n        {\\n            if(ans[i]!=\\' \\')\\n                lastCharCounter = i;\\n        }\\n        return ans.substr(0,lastCharCounter+1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1653689,
                "title": "js-simple-solution-string-array-string-builder",
                "content": "```\\n\\t/**\\n * @param {string} encodedText\\n * @param {number} rows\\n * @return {string}\\n */\\nvar decodeCiphertext = function(encodedText, rows) {\\n    const cols = Math.round(encodedText.length / rows);\\n    const matrix = new Array(rows).fill(null).map(item => []);\\n    let c = 0;\\n    for (let i = 0; i < rows; i++) {\\n        for (let j = 0; j < cols; j++) {\\n            const char = encodedText.charAt(c++); \\n            matrix[i][j] = char;\\n        }\\n    }\\n    let result = \\'\\';\\n    for (let i = 0; i < cols; i++) {\\n        for (let j = 0; j < rows; j++) {\\n            if (matrix[j][i + j]) result += matrix[j][i + j]\\n        }\\n    }\\n    return result.trimRight();\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\t/**\\n * @param {string} encodedText\\n * @param {number} rows\\n * @return {string}\\n */\\nvar decodeCiphertext = function(encodedText, rows) {\\n    const cols = Math.round(encodedText.length / rows);\\n    const matrix = new Array(rows).fill(null).map(item => []);\\n    let c = 0;\\n    for (let i = 0; i < rows; i++) {\\n        for (let j = 0; j < cols; j++) {\\n            const char = encodedText.charAt(c++); \\n            matrix[i][j] = char;\\n        }\\n    }\\n    let result = \\'\\';\\n    for (let i = 0; i < cols; i++) {\\n        for (let j = 0; j < rows; j++) {\\n            if (matrix[j][i + j]) result += matrix[j][i + j]\\n        }\\n    }\\n    return result.trimRight();\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1650044,
                "title": "o-n-c-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int n) {\\n        int m=encodedText.length()/n;\\n        string s=\"\";\\n        for(int j=0;j<m;j++){\\n            for(int i=0;i+j<m && i<n;i++){\\n                s+= encodedText[i*m+i+j];\\n            }\\n        }\\n        while(s.size() && s.back()==\\' \\') s.pop_back();\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int n) {\\n        int m=encodedText.length()/n;\\n        string s=\"\";\\n        for(int j=0;j<m;j++){\\n            for(int i=0;i+j<m && i<n;i++){\\n                s+= encodedText[i*m+i+j];\\n            }\\n        }\\n        while(s.size() && s.back()==\\' \\') s.pop_back();\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1649232,
                "title": "simple-python-solution",
                "content": "```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        if len(encodedText) == 0: return \"\"\\n        \\n        m, n, ls = rows, len(encodedText) // rows, []    \\n        matrix = [encodedText[n * i: n * (i + 1)] for i in range(m)]\\n\\n        i, j, idx = 0, 0, 0\\n        while True:\\n            ls.append(matrix[i][j])\\n            if i == 0 and j == n - 1: break\\n            if i == m - 1 or j == n - 1:\\n                idx += 1\\n                i, j = 0, idx\\n            else:\\n                i += 1\\n                j += 1\\n        \\n        while ls[-1] == \\' \\': ls.pop()\\n\\n        return \\'\\'.join(ls)",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        if len(encodedText) == 0: return \"\"\\n        \\n        m, n, ls = rows, len(encodedText) // rows, []    \\n        matrix = [encodedText[n * i: n * (i + 1)] for i in range(m)]\\n\\n        i, j, idx = 0, 0, 0\\n        while True:\\n            ls.append(matrix[i][j])\\n            if i == 0 and j == n - 1: break\\n            if i == m - 1 or j == n - 1:\\n                idx += 1\\n                i, j = 0, idx\\n            else:\\n                i += 1\\n                j += 1\\n        \\n        while ls[-1] == \\' \\': ls.pop()\\n\\n        return \\'\\'.join(ls)",
                "codeTag": "Java"
            },
            {
                "id": 1646892,
                "title": "python-o-n-by-diagonal-decode-w-visualization",
                "content": "Python O(n) by diagonal decode.\\n\\n![image](https://assets.leetcode.com/users/images/5c422b5a-921a-4c3b-8c2b-83a3264fd292_1640454409.9887652.png)\\n\\n\\n---\\n**Hint** and **Algorithm**:\\n\\nStep_1.\\nGet the codec matrix **heigh** and **width**, \\nwhere height is given = rows, and \\nwidth = len(encode string) // rows \\n\\nStep_2.\\nDecode order is blue axis, then red axis, then yellow axis, ..., and so on \\n\\nStep_3.\\nThose characters belong to same axis has the index **offset (width+1)** in **encode string** by observation\\n\\nTake blue axis for example\\n```\\nindex on codec matrix :(0, 0) -> (1, 1)  -> (2, 2)   -> ...\\nindex in encode text:  s[ 0 ] -> s[w+1]  -> s[2w+2 ] -> ...\\n```\\n\\nStep_4.\\nDecode each diagonal axis one by one to generate plain text.\\nPaintext on blue axis = join ( s[ 0 ], s[ 0 + w + 1 ], s[ 0 + 2w + 2 ], ... )\\n\\nPaintext on red axis = join ( s[ 1 ], s[ 1 + w + 1], s[ 1 + 2w + 2 ], ... )\\n\\nPaintext on yellow axis = join ( s[ 2 ], s[ 2 + w + 1], s[ 2 + 2w + 2 ], ... )\\n...and so on till we reach last column\\n\\nStep_5.\\nFinally, **remember to remove redundant whitespaces** on the tail.\\n\\n---\\n\\n**Implementation** by diagonal decode:\\n\\n```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n\\n        if rows == 1:\\n            # Quick response on simple case\\n            return encodedText\\n        \\n        # get the codec matrix dimension\\n        h = rows\\n        w = len(encodedText) // h\\n        \\n        # Concatenate diagonal string level by level\\n        # Remeber to remove redundant whitespaces on the tail\\n        return \"\".join( encodedText[diag_level::w+1]for diag_level in range(w)).rstrip()\\n```",
                "solutionTags": [
                    "Python",
                    "Math",
                    "String"
                ],
                "code": "```\\nindex on codec matrix :(0, 0) -> (1, 1)  -> (2, 2)   -> ...\\nindex in encode text:  s[ 0 ] -> s[w+1]  -> s[2w+2 ] -> ...\\n```\n```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n\\n        if rows == 1:\\n            # Quick response on simple case\\n            return encodedText\\n        \\n        # get the codec matrix dimension\\n        h = rows\\n        w = len(encodedText) // h\\n        \\n        # Concatenate diagonal string level by level\\n        # Remeber to remove redundant whitespaces on the tail\\n        return \"\".join( encodedText[diag_level::w+1]for diag_level in range(w)).rstrip()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1637753,
                "title": "simple-logical-solution",
                "content": "\\n\\n\\nstring decodeCiphertext(string encodedText, int rows) \\n\\n{\\n        \\n\\t\\t\\n\\t\\tint n = encodedText.length();\\n        int cols = n/rows;\\n        \\n        string ans = \"\";\\n        for(int i=0; i<cols; i=i+1){\\n            //if(encodedText[i] == \\' \\')\\n               //break;\\n            for(int j=i; j<n; j=j+cols+1)\\n               ans += encodedText[j];\\n        }\\n        while(ans.back()==\\' \\')\\n            ans.pop_back();\\n        return ans;\\n    }",
                "solutionTags": [
                    "String"
                ],
                "code": "\\n\\n\\nstring decodeCiphertext(string encodedText, int rows) \\n\\n{\\n        \\n\\t\\t\\n\\t\\tint n = encodedText.length();\\n        int cols = n/rows;\\n        \\n        string ans = \"\";\\n        for(int i=0; i<cols; i=i+1){\\n            //if(encodedText[i] == \\' \\')\\n               //break;\\n            for(int j=i; j<n; j=j+cols+1)\\n               ans += encodedText[j];\\n        }\\n        while(ans.back()==\\' \\')\\n            ans.pop_back();\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1625315,
                "title": "cpp-solution",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string s, int rows) {\\n        if(s==\"\" || rows==1)return s; //BASE CASE\\n       vector<vector<char>>arr(rows,vector<char>(s.size()/rows,\\' \\')); //CREATING MATRIX;\\n        int ind=0;\\n        for(int i=0;i<arr.size();i++) //FILLING MATRIX WITH CHARACTERS;\\n        {\\n            for(int j=0;j<arr[0].size();j++)\\n            {\\n                if(ind<s.size())\\n                {\\n                    arr[i][j]=s[ind++];\\n                }\\n            }\\n        }\\n        s=\"\";\\n        for(int i=0;i<arr[0].size();i++) //TRAVERSING MATRIX ACCORDING TO QUESTION;\\n        {\\n            int j=0,t=i;\\n            while(j<arr.size()&&t<arr[0].size())\\n            {\\n                s+=arr[j][t];\\n                j++;\\n                t++;\\n            }\\n        }\\n        while(s[s.size()-1]==\\' \\')s.pop_back(); //REMOVE TRAILING SPACES;\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string s, int rows) {\\n        if(s==\"\" || rows==1)return s; //BASE CASE\\n       vector<vector<char>>arr(rows,vector<char>(s.size()/rows,\\' \\')); //CREATING MATRIX;\\n        int ind=0;\\n        for(int i=0;i<arr.size();i++) //FILLING MATRIX WITH CHARACTERS;\\n        {\\n            for(int j=0;j<arr[0].size();j++)\\n            {\\n                if(ind<s.size())\\n                {\\n                    arr[i][j]=s[ind++];\\n                }\\n            }\\n        }\\n        s=\"\";\\n        for(int i=0;i<arr[0].size();i++) //TRAVERSING MATRIX ACCORDING TO QUESTION;\\n        {\\n            int j=0,t=i;\\n            while(j<arr.size()&&t<arr[0].size())\\n            {\\n                s+=arr[j][t];\\n                j++;\\n                t++;\\n            }\\n        }\\n        while(s[s.size()-1]==\\' \\')s.pop_back(); //REMOVE TRAILING SPACES;\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1622063,
                "title": "c-solution",
                "content": "Matrix Rebuilding\\n```\\npublic class Solution {\\n    public string DecodeCiphertext(string e, int rows) {\\n        if (rows == 1 || string.IsNullOrEmpty(e)) return e;\\n        \\n        int l = e.Length, cols = l / rows;\\n        char[,] m = new char[rows, cols];\\n        int k = 0;\\n        for (int i = 0; i < rows; ++i) {\\n            for (int j = 0; j < cols; ++j) {\\n                m[i, j] = e[k++];\\n            }\\n        }\\n        \\n        StringBuilder r = new StringBuilder();\\n        for (int i = 0; i < m.GetLength(1); ++i) {\\n            int row = 0, col = i;\\n            while (row < rows && col < cols) r.Append(m[row++, col++]);\\n        }\\n        \\n        while (r[r.Length - 1] == \\' \\') r.Length--;\\n        \\n        return r.ToString();\\n    }\\n}\\n```\\n\\nColumn Index Hopping\\n```\\npublic class Solution {\\n    public string DecodeCiphertext(string et, int rows) {\\n        int l = et.Length, cols = et.Length / rows;\\n        \\n        StringBuilder r = new StringBuilder();\\n        for (int i = 0; i < cols; ++i) { \\n            for (int j = i; j < et.Length; j += cols + 1) { // + 1 for the leading space \\n                r.Append(et[j]);\\n            }\\n        }\\n        \\n        return r.ToString().TrimEnd();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public string DecodeCiphertext(string e, int rows) {\\n        if (rows == 1 || string.IsNullOrEmpty(e)) return e;\\n        \\n        int l = e.Length, cols = l / rows;\\n        char[,] m = new char[rows, cols];\\n        int k = 0;\\n        for (int i = 0; i < rows; ++i) {\\n            for (int j = 0; j < cols; ++j) {\\n                m[i, j] = e[k++];\\n            }\\n        }\\n        \\n        StringBuilder r = new StringBuilder();\\n        for (int i = 0; i < m.GetLength(1); ++i) {\\n            int row = 0, col = i;\\n            while (row < rows && col < cols) r.Append(m[row++, col++]);\\n        }\\n        \\n        while (r[r.Length - 1] == \\' \\') r.Length--;\\n        \\n        return r.ToString();\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public string DecodeCiphertext(string et, int rows) {\\n        int l = et.Length, cols = et.Length / rows;\\n        \\n        StringBuilder r = new StringBuilder();\\n        for (int i = 0; i < cols; ++i) { \\n            for (int j = i; j < et.Length; j += cols + 1) { // + 1 for the leading space \\n                r.Append(et[j]);\\n            }\\n        }\\n        \\n        return r.ToString().TrimEnd();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1604184,
                "title": "javascript-time-o-m-n-space-o-1",
                "content": "```\\n/**\\n * @param {string} encodedText\\n * @param {number} rows\\n * @return {string}\\n */\\nvar decodeCiphertext = function(encodedText, rows) {\\n    const len = encodedText.length\\n    const cols = len / rows\\n    function getCh(i, j) {\\n        const index = i * cols + j\\n        return encodedText[index]\\n    }\\n    \\n    \\n    const chs = []\\n    for (let j = 0; j < cols; j++) {\\n        for (let i = 0; i < rows && j + i < cols; i++) {\\n            const ch = getCh(i, i + j)\\n            chs.push(ch)\\n        }\\n    }\\n    \\n    \\n    let result = chs.join(\\'\\')\\n    result = result.trimEnd()\\n    return result\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {string} encodedText\\n * @param {number} rows\\n * @return {string}\\n */\\nvar decodeCiphertext = function(encodedText, rows) {\\n    const len = encodedText.length\\n    const cols = len / rows\\n    function getCh(i, j) {\\n        const index = i * cols + j\\n        return encodedText[index]\\n    }\\n    \\n    \\n    const chs = []\\n    for (let j = 0; j < cols; j++) {\\n        for (let i = 0; i < rows && j + i < cols; i++) {\\n            const ch = getCh(i, i + j)\\n            chs.push(ch)\\n        }\\n    }\\n    \\n    \\n    let result = chs.join(\\'\\')\\n    result = result.trimEnd()\\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1588867,
                "title": "c-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string str, int r) {\\n        int c = str.size() / r; \\n        string ret; \\n        for(int i = 0;i<c;i++) {\\n            for(int j = 0;j<r&&i+j<c;j++) {\\n                ret.push_back(str[j*c + i + j]);\\n            }\\n        }\\n        ret.erase(ret.find_last_not_of(\\' \\')+1);\\n        return ret; \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string str, int r) {\\n        int c = str.size() / r; \\n        string ret; \\n        for(int i = 0;i<c;i++) {\\n            for(int j = 0;j<r&&i+j<c;j++) {\\n                ret.push_back(str[j*c + i + j]);\\n            }\\n        }\\n        ret.erase(ret.find_last_not_of(\\' \\')+1);\\n        return ret; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1588272,
                "title": "easy-java-solution",
                "content": "class Solution {\\n    \\n\\tpublic String decodeCiphertext(String encodedText, int rows) {\\n        \\n        int l=encodedText.length();\\n        \\n        int x,c=l/rows;\\n        \\n        if(l==0)\\n            return \"\";\\n        \\n        int j=0;\\n        StringBuilder d= new StringBuilder();\\n        while(j<c){\\n            int y=j;\\n            x=0;\\n            while(y<l){\\n                d=d.append(encodedText.charAt(y));\\n                y=y+c+1;\\n            }\\n            j++;\\n        }\\n        \\n        String t=d.toString();\\n        \\n        int y=t.length();\\n        \\n      while(y>=0 && t.charAt(y-1)==\\' \\')\\n          y--;\\n        \\n        if(y==-1)\\n            return \"\";\\n        \\n        return t.substring(0,y);\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    \\n\\tpublic String decodeCiphertext(String encodedText, int rows) {\\n        \\n        int l=encodedText.length();\\n        \\n        int x,c=l/rows;\\n        \\n        if(l==0)\\n            return \"\";\\n        \\n        int j=0;\\n        StringBuilder d= new StringBuilder();\\n        while(j<c){\\n            int y=j;\\n            x=0;\\n            while(y<l){\\n                d=d.append(encodedText.charAt(y));\\n                y=y+c+1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1588186,
                "title": "2075-decode-the-slanted-ciphertext",
                "content": "---\\n\\n- Contest - https://leetcode.com/contest/weekly-contest-267/\\n  - Q1 Answer\\n    - https://leetcode.com/problems/time-needed-to-buy-tickets/discuss/1578174/2073.-Time-Needed-to-Buy-Tickets\\n  - Q2 Answer\\n    - https://leetcode.com/problems/reverse-nodes-in-even-length-groups/discuss/1580446/2074.-Reverse-Nodes-in-Even-Length-Groups\\n  - Q3 Answer\\n    - below\\n      - https://leetcode.com/problems/decode-the-slanted-ciphertext/discuss/1588186/2075.-Decode-the-Slanted-Ciphertext\\n\\n---\\n\\n- Code from my contest, worked out on paper for 15 mins, and 4 mins of coding, 1 min of submission. Passed on 1st submit.\\n  - See Q3 at https://leetcode.com/contest/weekly-contest-267/ranking/72/\\n\\n---\\n\\nHope it is simple to understand.\\n\\n---\\n\\n```\\nvar decodeCiphertext = function (encodedText, rows) {\\n    let n = encodedText.length;\\n\\n    let ans = \\'\\';\\n    let cols = Math.round(n / rows);\\n    for (let i = 0; i < cols; i++) {\\n        for (let j = i; j < n; j += cols + 1) {\\n            ans += encodedText[j];\\n        }\\n    }\\n    return ans.trimRight();\\n};\\n```\\n\\n---\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar decodeCiphertext = function (encodedText, rows) {\\n    let n = encodedText.length;\\n\\n    let ans = \\'\\';\\n    let cols = Math.round(n / rows);\\n    for (let i = 0; i < cols; i++) {\\n        for (let j = i; j < n; j += cols + 1) {\\n            ans += encodedText[j];\\n        }\\n    }\\n    return ans.trimRight();\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1588102,
                "title": "pick-characters-columns-1-distant-apart",
                "content": "```\\n// time: O(n) || space : O(1)\\n\\npublic String decodeCiphertext(String encodedText, int rows) {\\n\\tint textLen = encodedText.length();\\n\\tint cols = textLen / rows;\\n\\n\\tStringBuffer decodedStrBuf = new StringBuffer();\\n\\tfor(int i = 0; i < cols; i++) {\\n\\t\\tfor(int j = i; j < textLen; j += (cols + 1)) {\\n\\t\\t\\tdecodedStrBuf.append(encodedText.charAt(j));\\n\\t\\t}\\n\\t}\\n\\n\\treturn decodedStrBuf.toString().stripTrailing();\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// time: O(n) || space : O(1)\\n\\npublic String decodeCiphertext(String encodedText, int rows) {\\n\\tint textLen = encodedText.length();\\n\\tint cols = textLen / rows;\\n\\n\\tStringBuffer decodedStrBuf = new StringBuffer();\\n\\tfor(int i = 0; i < cols; i++) {\\n\\t\\tfor(int j = i; j < textLen; j += (cols + 1)) {\\n\\t\\t\\tdecodedStrBuf.append(encodedText.charAt(j));\\n\\t\\t}\\n\\t}\\n\\n\\treturn decodedStrBuf.toString().stripTrailing();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1587671,
                "title": "go-solution-with-explanation",
                "content": "1. we can get the column of the matrix: `len(encodedText)/rows`\\n2. we can locate the character in every `blow arrows` if we know where the first character is (0, y). Actually, we know it, they are all in the first `column` character of encodedText. For example, in `example 1`, it\\'s `ch`, in `example 2`, it\\'s `iveo`.\\n3. the latest column must have character, so the second place`(rows-2, column-1)` from last in last column `column-1` may have character. However, the third place`(rows-3, column-1)` from last in last column `column-1` must have no character, actually, the blue arrows including the `(rows-3, column-1)`  must have no character. That is, there are most `column-rows+2` characters in the first line. \\n\\n```go\\nfunc decodeCiphertext(encodedText string, rows int) string {\\n\\tif rows == 1 {\\n\\t\\treturn encodedText\\n\\t}\\n\\tcolumn := len(encodedText) / rows\\n\\tans := \"\"\\n\\tvar index int\\n\\tfor round := 0; round <= column-rows+1; round++ {\\n\\t\\toriginIndex := round\\n\\t\\tfor i := 0; i < rows; i++ {\\n\\t\\t\\tindex = originIndex + i*column + i\\n\\t\\t\\tif index >= len(encodedText) {\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t\\tans += string(encodedText[index])\\n\\t\\t}\\n\\t}\\n\\treturn strings.TrimRight(ans, \" \")\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc decodeCiphertext(encodedText string, rows int) string {\\n\\tif rows == 1 {\\n\\t\\treturn encodedText\\n\\t}\\n\\tcolumn := len(encodedText) / rows\\n\\tans := \"\"\\n\\tvar index int\\n\\tfor round := 0; round <= column-rows+1; round++ {\\n\\t\\toriginIndex := round\\n\\t\\tfor i := 0; i < rows; i++ {\\n\\t\\t\\tindex = originIndex + i*column + i\\n\\t\\t\\tif index >= len(encodedText) {\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t\\tans += string(encodedText[index])\\n\\t\\t}\\n\\t}\\n\\treturn strings.TrimRight(ans, \" \")\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1587467,
                "title": "clarifying-the-question",
                "content": "Just want to clarify what the question requires, so others can know exactly what the question is asking for. It took me 3 wrong submissions to figure it out. \\n1. The word starts at where the blue blocks are as shown in the instruction  (I thought that it starts at the bottom left corner.)\\n2. Any group of slanted blocks that contain nothing but spaces should be retained if they are not at the very end.  (I thought those should be removed)\\n3. There is no trailing space but leading space is allowed (instruction mentioned this but I missed it).\\n\\nHope it help someone.",
                "solutionTags": [],
                "code": "Just want to clarify what the question requires, so others can know exactly what the question is asking for. It took me 3 wrong submissions to figure it out. \\n1. The word starts at where the blue blocks are as shown in the instruction  (I thought that it starts at the bottom left corner.)\\n2. Any group of slanted blocks that contain nothing but spaces should be retained if they are not at the very end.  (I thought those should be removed)\\n3. There is no trailing space but leading space is allowed (instruction mentioned this but I missed it).\\n\\nHope it help someone.",
                "codeTag": "Unknown"
            },
            {
                "id": 1583890,
                "title": "java",
                "content": "```\\nclass Solution {\\n    public String decodeCiphertext(String encodedText, int rows) {\\n        int len = encodedText.length();\\n        if(len==0) return encodedText;\\n        int cols = len/rows;\\n        StringBuilder sb = new StringBuilder();\\n        for(int i=0; i<cols; i++){\\n            for(int row=0; row<rows; row++){\\n                int idx = cols*row+i+row;\\n                if(idx<len)\\n                    sb.append(encodedText.charAt(idx));\\n                else break;\\n            }\\n        }\\n        return sb.toString().stripTrailing();\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public String decodeCiphertext(String encodedText, int rows) {\\n        int len = encodedText.length();\\n        if(len==0) return encodedText;\\n        int cols = len/rows;\\n        StringBuilder sb = new StringBuilder();\\n        for(int i=0; i<cols; i++){\\n            for(int row=0; row<rows; row++){\\n                int idx = cols*row+i+row;\\n                if(idx<len)\\n                    sb.append(encodedText.charAt(idx));\\n                else break;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1583724,
                "title": "after-finding-the-columns-read-off-the-matrix",
                "content": "```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        if not encodedText: return \\'\\'\\n        \\n        C=len(encodedText)//rows\\n        matrix=[]\\n        for i in range(0,len(encodedText),C):\\n            matrix.append(encodedText[i:i+C])\\n        \\n        output=\\'\\'\\n        \\n        for i in range(C):\\n            k=0\\n            while k<rows and i+k<C:\\n                output+=matrix[k][i+k]\\n                k+=1\\n        \\n        return output.rstrip()\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        if not encodedText: return \\'\\'\\n        \\n        C=len(encodedText)//rows\\n        matrix=[]\\n        for i in range(0,len(encodedText),C):\\n            matrix.append(encodedText[i:i+C])\\n        \\n        output=\\'\\'\\n        \\n        for i in range(C):\\n            k=0\\n            while k<rows and i+k<C:\\n                output+=matrix[k][i+k]\\n                k+=1\\n        \\n        return output.rstrip()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1583477,
                "title": "giving-heap-overflow-working-fine-on-my-compiler",
                "content": "This code is giving heap overflow please help me find my mistake.\\n\\n\\n class Solution {\\npublic:\\n    string trim(string& line)\\n{\\n     for(int i=line.size()-1;i>=0;--i){\\n         if(line[i]>=\\'a\\' and line[i] <= \\'z\\'){\\n            return line.substr(0,i+1);\\n         }\\n     }\\n    return line;\\n}\\n    \\n    string decodeCiphertext(string encodedText, int rows) {\\n        int size = encodedText.size();\\n        int col = ceil(size/(rows*1.0));\\n        vector<string> parts;\\n        for(int i=0;i<encodedText.size();i+=col){\\n            parts.push_back(encodedText.substr(i,col));\\n        }\\n        string original;\\n        for(int i=0;i<col;++i){\\n            int temp_col = i;\\n            for(int j=0;j<rows;++j,++temp_col){\\n                original+=parts[j][temp_col];\\n            }\\n        }\\n        \\n        return trim(original);\\n    }\\n};\\n",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "class Solution {\\npublic:\\n    string trim(string& line)\\n{\\n     for(int i=line.size()-1;i>=0;--i){\\n         if(line[i]>=\\'a\\' and line[i] <= \\'z\\'){\\n            return line.substr(0,i+1);\\n         }",
                "codeTag": "Java"
            },
            {
                "id": 1583160,
                "title": "java-easy-intuitive-solution",
                "content": "```\\nclass Solution {\\n    public String decodeCiphertext(String encodedText, int rows) {\\n        // if(rows==0||encodedText.length()==0)return \"\";\\n        int len=encodedText.length();\\n        int cols=len/rows;\\n        char mat[][]=new char[rows][cols];\\n        int idx=len-1;int r=rows-1,c=cols-1,nr=0,nc=0;\\n        // System.out.println(rows+\"  \"+cols+\"  \"+len);\\n        while(idx>=0){\\n            if(c==0){\\n                nr=r-1;\\n                nc=cols-1;\\n            }else{\\n                nr=r;\\n                nc=c-1;\\n            }\\n            char ch=encodedText.charAt(idx--);\\n            // System.out.println(ch);\\n            // if(ch==\\' \\'){\\n            // mat[r][c]=\\'.\\';    \\n            // }else{\\n                mat[r][c]=ch;\\n            // }\\n            r=nr;\\n            c=nc;\\n            \\n        }\\n        // for(int i=0;i<rows;i++){\\n        //     for(int j=0;j<cols;j++){\\n        //         System.out.print(\" \"+mat[i][j]+\" \");\\n        //     }\\n        //     System.out.println();\\n        // }\\n        StringBuilder sb=new StringBuilder();\\n        for(int d=0;d<Math.max(rows,cols);d++){\\n            for(int i=0,j=i+d;j<cols&&i<rows;i++,j++){\\n                sb.append(mat[i][j]);\\n            }\\n            \\n        }\\n        System.out.println(sb);\\n        int i=sb.length()-1;\\n        String s=sb.toString();\\n        while(i>=0&&s.charAt(i)==\\' \\'){\\n            i--;\\n        }\\n        return s.substring(0,i+1);\\n\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String decodeCiphertext(String encodedText, int rows) {\\n        // if(rows==0||encodedText.length()==0)return \"\";\\n        int len=encodedText.length();\\n        int cols=len/rows;\\n        char mat[][]=new char[rows][cols];\\n        int idx=len-1;int r=rows-1,c=cols-1,nr=0,nc=0;\\n        // System.out.println(rows+\"  \"+cols+\"  \"+len);\\n        while(idx>=0){\\n            if(c==0){\\n                nr=r-1;\\n                nc=cols-1;\\n            }else{\\n                nr=r;\\n                nc=c-1;\\n            }\\n            char ch=encodedText.charAt(idx--);\\n            // System.out.println(ch);\\n            // if(ch==\\' \\'){\\n            // mat[r][c]=\\'.\\';    \\n            // }else{\\n                mat[r][c]=ch;\\n            // }\\n            r=nr;\\n            c=nc;\\n            \\n        }\\n        // for(int i=0;i<rows;i++){\\n        //     for(int j=0;j<cols;j++){\\n        //         System.out.print(\" \"+mat[i][j]+\" \");\\n        //     }\\n        //     System.out.println();\\n        // }\\n        StringBuilder sb=new StringBuilder();\\n        for(int d=0;d<Math.max(rows,cols);d++){\\n            for(int i=0,j=i+d;j<cols&&i<rows;i++,j++){\\n                sb.append(mat[i][j]);\\n            }\\n            \\n        }\\n        System.out.println(sb);\\n        int i=sb.length()-1;\\n        String s=sb.toString();\\n        while(i>=0&&s.charAt(i)==\\' \\'){\\n            i--;\\n        }\\n        return s.substring(0,i+1);\\n\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1581454,
                "title": "java-straightforward-solution-with-two-pointers",
                "content": "```\\nclass Solution {\\n    public String decodeCiphertext(String encodedText, int rows) {\\n        int n = encodedText.length()/rows, m = rows, i = 0, j = 0;\\n        StringBuilder sb = new StringBuilder();\\n        while(i<m && j<n){\\n            int runI = 0, runJ = j++;\\n            while(runI < m && runJ < n){\\n                sb.append(encodedText.charAt(runI++ * n + runJ++));\\n            }\\n        }\\n        return trimFromLast(sb.toString());\\n    }\\n    public String trimFromLast(String str){\\n        int i = str.length()-1;\\n        while(i>=0){\\n            if(Character.isAlphabetic(str.charAt(i--)))\\n                return str.substring(0,i+2);\\n        }\\n        return \"\";\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String decodeCiphertext(String encodedText, int rows) {\\n        int n = encodedText.length()/rows, m = rows, i = 0, j = 0;\\n        StringBuilder sb = new StringBuilder();\\n        while(i<m && j<n){\\n            int runI = 0, runJ = j++;\\n            while(runI < m && runJ < n){\\n                sb.append(encodedText.charAt(runI++ * n + runJ++));\\n            }\\n        }\\n        return trimFromLast(sb.toString());\\n    }\\n    public String trimFromLast(String str){\\n        int i = str.length()-1;\\n        while(i>=0){\\n            if(Character.isAlphabetic(str.charAt(i--)))\\n                return str.substring(0,i+2);\\n        }\\n        return \"\";\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1581290,
                "title": "c-observation-beginner-level",
                "content": "jumping columns \\n\\'\\'\\'\\n\\n        string decodeCiphertext(string encodedText, int rows) {\\n        int n = encodedText.size();\\n        string str = \"\";\\n        \\n        //exceptional case of str = \"\" \\n        if(n == 0) return str;\\n       \\n        int col = n/rows ;\\n       // col times\\n        for(int i = 0; i<col; i++){\\n            \\n         //((row*col)/ col+1)\\n            for(int j = i; j< n; j+= col + 1){\\n                \\n              str +=   encodedText[j];\\n            }\\n        }\\n        // removes end spaces \\n        while(str[str.size()-1] == \\' \\') str.pop_back();\\n        return str;\\n        \\n    }\\n\\t\\n\\t\\'\\'\\'",
                "solutionTags": [
                    "C"
                ],
                "code": "jumping columns \\n\\'\\'\\'\\n\\n        string decodeCiphertext(string encodedText, int rows) {\\n        int n = encodedText.size();\\n        string str = \"\";\\n        \\n        //exceptional case of str = \"\" \\n        if(n == 0) return str;\\n       \\n        int col = n/rows ;\\n       // col times\\n        for(int i = 0; i<col; i++){\\n            \\n         //((row*col)/ col+1)\\n            for(int j = i; j< n; j+= col + 1){\\n                \\n              str +=   encodedText[j];\\n            }\\n        }\\n        // removes end spaces \\n        while(str[str.size()-1] == \\' \\') str.pop_back();\\n        return str;\\n        \\n    }\\n\\t\\n\\t\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 1581065,
                "title": "java-tiny-solution-in-place",
                "content": "```\\n    public String decodeCiphertext(String encodedText, int rows) {\\n        int cols = encodedText.length() / rows;        \\n        StringBuilder sb = new StringBuilder();\\n        for(int jj=0;jj<cols;jj++){\\n            for(int i=0,j=jj; i<rows && j<cols; i++,j++){\\n                sb.append(encodedText.charAt(i*cols+j));\\n            }\\n        }\\n        return sb.toString().stripTrailing();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public String decodeCiphertext(String encodedText, int rows) {\\n        int cols = encodedText.length() / rows;        \\n        StringBuilder sb = new StringBuilder();\\n        for(int jj=0;jj<cols;jj++){\\n            for(int i=0,j=jj; i<rows && j<cols; i++,j++){\\n                sb.append(encodedText.charAt(i*cols+j));\\n            }\\n        }\\n        return sb.toString().stripTrailing();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1580811,
                "title": "optimized-for-time-10ms",
                "content": "```\\nclass Solution {\\n    public String decodeCiphertext(String encodedText, int rows) {\\n        if (encodedText.length() <= 1) {\\n            return encodedText;\\n        }\\n        \\n        int n = encodedText.length() / rows;\\n        char[][] cipher = new char[rows][n];\\n        for (int i=0; i < rows; i++) {\\n            int start = i * n;\\n            cipher[i] = encodedText.substring(start, start + n).toCharArray();\\n        }\\n        \\n        int numColumnsToProcess = n-rows+1;\\n        char[] val = new char[encodedText.length() - (rows * (rows - 1))];\\n        int count=0;\\n        for(int i = 0; i<numColumnsToProcess; i++) {\\n            for(int j = 0; j<rows; j++) {\\n                val[count++] = cipher[j][i+j];\\n            }\\n        }\\n        \\n        StringBuilder extraBuilder = new StringBuilder();\\n        for(int j=0; j<rows-1; j++) {\\n            extraBuilder.append(cipher[j][numColumnsToProcess+j]);\\n        }\\n        \\n        String extra = extraBuilder.toString();  \\n        if (extra.trim().isEmpty()) {\\n            return new String(val);\\n        } \\n        \\n        int length = extraBuilder.length() - 1;\\n        while (length > 0 && extraBuilder.charAt(length) == \\' \\') {\\n            length--;\\n        }\\n        extraBuilder.setLength(length + 1);        \\n              \\n        \\n        return new String(val) + extraBuilder.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String decodeCiphertext(String encodedText, int rows) {\\n        if (encodedText.length() <= 1) {\\n            return encodedText;\\n        }\\n        \\n        int n = encodedText.length() / rows;\\n        char[][] cipher = new char[rows][n];\\n        for (int i=0; i < rows; i++) {\\n            int start = i * n;\\n            cipher[i] = encodedText.substring(start, start + n).toCharArray();\\n        }\\n        \\n        int numColumnsToProcess = n-rows+1;\\n        char[] val = new char[encodedText.length() - (rows * (rows - 1))];\\n        int count=0;\\n        for(int i = 0; i<numColumnsToProcess; i++) {\\n            for(int j = 0; j<rows; j++) {\\n                val[count++] = cipher[j][i+j];\\n            }\\n        }\\n        \\n        StringBuilder extraBuilder = new StringBuilder();\\n        for(int j=0; j<rows-1; j++) {\\n            extraBuilder.append(cipher[j][numColumnsToProcess+j]);\\n        }\\n        \\n        String extra = extraBuilder.toString();  \\n        if (extra.trim().isEmpty()) {\\n            return new String(val);\\n        } \\n        \\n        int length = extraBuilder.length() - 1;\\n        while (length > 0 && extraBuilder.charAt(length) == \\' \\') {\\n            length--;\\n        }\\n        extraBuilder.setLength(length + 1);        \\n              \\n        \\n        return new String(val) + extraBuilder.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1580534,
                "title": "c-easy-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        int n=encodedText.size();\\n        int col=n/rows;\\n        string ans=\"\";\\n        for(int i=0;i<col;i++) // We have to just move column number of times in original string //\\n        {\\n            for(int j=i;j<n;j+=col+1)    // We get the next character at every column+1 ahead //\\n              ans+=encodedText[j];\\n        }\\n        while(ans.back()==\\' \\') ans.pop_back();   // Remove the spaces at the end //\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        int n=encodedText.size();\\n        int col=n/rows;\\n        string ans=\"\";\\n        for(int i=0;i<col;i++) // We have to just move column number of times in original string //\\n        {\\n            for(int j=i;j<n;j+=col+1)    // We get the next character at every column+1 ahead //\\n              ans+=encodedText[j];\\n        }\\n        while(ans.back()==\\' \\') ans.pop_back();   // Remove the spaces at the end //\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1579425,
                "title": "simple-c-solution",
                "content": "```\\npublic class Solution\\n{\\n    public string DecodeCiphertext(string encodedText, int rows)\\n    {\\n        int col = encodedText.Length / rows;\\n        char[] orginal = new char[encodedText.Length];\\n        int startc = 0;\\n        int c = 0;\\n        int length = 0;\\n        for (int i = 0; i < orginal.Length; i++)\\n        {\\n            int r = i % rows;\\n            if (r == 0)\\n                c = startc++;\\n            else\\n                c++;\\n            if (c >= col)\\n                break;\\n            orginal[i] = encodedText[r * col + c];\\n            length++;\\n        }\\n        return new string(orginal, 0, length).TrimEnd();\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution\\n{\\n    public string DecodeCiphertext(string encodedText, int rows)\\n    {\\n        int col = encodedText.Length / rows;\\n        char[] orginal = new char[encodedText.Length];\\n        int startc = 0;\\n        int c = 0;\\n        int length = 0;\\n        for (int i = 0; i < orginal.Length; i++)\\n        {\\n            int r = i % rows;\\n            if (r == 0)\\n                c = startc++;\\n            else\\n                c++;\\n            if (c >= col)\\n                break;\\n            orginal[i] = encodedText[r * col + c];\\n            length++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1579310,
                "title": "cut-the-string-and-zip-longest-100-speed-100-memory",
                "content": "![image](https://assets.leetcode.com/users/images/58be7acc-e1a6-456c-8883-4bd064907f04_1636965633.6376953.png)\\n```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        if rows == 1:\\n            return encodedText\\n        cols = len(encodedText) // rows\\n        matrix = [encodedText[i * cols + i: (i + 1) * cols] for i in range(rows)]\\n        return \"\".join(\"\".join(c)\\n                       for c in zip_longest(*matrix, fillvalue=\" \")).rstrip(\" \")\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        if rows == 1:\\n            return encodedText\\n        cols = len(encodedText) // rows\\n        matrix = [encodedText[i * cols + i: (i + 1) * cols] for i in range(rows)]\\n        return \"\".join(\"\".join(c)\\n                       for c in zip_longest(*matrix, fillvalue=\" \")).rstrip(\" \")\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1579257,
                "title": "c-easy-to-understand",
                "content": "```\\npublic class Solution {\\n      public string DecodeCiphertext(string encodedText, int rows)\\n        {\\n            if(rows == 1)\\n            {\\n                return encodedText;\\n            }\\n\\n            int cols = encodedText.Length / rows;\\n            char[,] matrix = new char[rows, cols];\\n            int it = 0;\\n            StringBuilder sb = new();\\n\\n            for (int i = 0; i < matrix.GetLength(0); i++)\\n            {\\n                for (int j = 0; j < matrix.GetLength(1); j++)\\n                {\\n                    matrix[i, j] = encodedText[it++];\\n                }\\n            }\\n\\n\\n            for (int i = 0; i < matrix.GetLength(1); i++)\\n            {\\n                int sI = 0, sJ = i;\\n\\n                while (sI < matrix.GetLength(0) && sJ < matrix.GetLength(1))\\n                {\\n                    sb.Append(matrix[sI, sJ]);\\n                    sI++; sJ++;\\n                }\\n            }\\n\\n            string res = sb.ToString().TrimEnd();\\n\\n            return res;\\n        }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n      public string DecodeCiphertext(string encodedText, int rows)\\n        {\\n            if(rows == 1)\\n            {\\n                return encodedText;\\n            }\\n\\n            int cols = encodedText.Length / rows;\\n            char[,] matrix = new char[rows, cols];\\n            int it = 0;\\n            StringBuilder sb = new();\\n\\n            for (int i = 0; i < matrix.GetLength(0); i++)\\n            {\\n                for (int j = 0; j < matrix.GetLength(1); j++)\\n                {\\n                    matrix[i, j] = encodedText[it++];\\n                }\\n            }\\n\\n\\n            for (int i = 0; i < matrix.GetLength(1); i++)\\n            {\\n                int sI = 0, sJ = i;\\n\\n                while (sI < matrix.GetLength(0) && sJ < matrix.GetLength(1))\\n                {\\n                    sb.Append(matrix[sI, sJ]);\\n                    sI++; sJ++;\\n                }\\n            }\\n\\n            string res = sb.ToString().TrimEnd();\\n\\n            return res;\\n        }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1579218,
                "title": "java-solution-o-n-5-lines",
                "content": "```\\nclass Solution {\\n    public String decodeCiphertext(String encodedText, int rows) {\\n        StringBuilder sb=new StringBuilder();\\n        for(int i=0, cols=encodedText.length()/rows; i<cols; i++)\\n            for(int j=i; j<encodedText.length(); j+=(cols+1))\\n                sb.append(encodedText.charAt(j));\\n        return sb.toString().stripTrailing();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String decodeCiphertext(String encodedText, int rows) {\\n        StringBuilder sb=new StringBuilder();\\n        for(int i=0, cols=encodedText.length()/rows; i<cols; i++)\\n            for(int j=i; j<encodedText.length(); j+=(cols+1))\\n                sb.append(encodedText.charAt(j));\\n        return sb.toString().stripTrailing();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1578849,
                "title": "javascript-matrix-diagonal-traverse-180ms",
                "content": "```\\n///////////////////////////////////////////// Template //////////////////////////////////////////////////////////////////////////////\\nconst initialize2DArrayNew = (n, m) => { let data = []; for (let i = 0; i < n; i++) { let tmp = Array(m).fill(0); data.push(tmp); } return data; };\\nconst diagonal_traverse_topLeft_to_bottomRight = (g) => {\\n    let n = g.length;\\n    let m = g[0].length;\\n    let top = [];\\n    for (let j = 0; j < m; j++) { // first row as starting point\\n        let tmp = [];\\n        let share = 0; // shared increase control\\n        while (share < n && j + share < m) { // read Diagonally\\n            tmp.push(g[share][j + share]); // row++ col++\\n            share++;\\n        }\\n         if (tmp.length > 0) top.push(tmp);\\n    }\\n    return top;\\n};\\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\nconst decodeCiphertext = (s, n) => {\\n    let sn = s.length;\\n    if (n == 1) return s;\\n    let m = sn / n;\\n    let g = initialize2DArrayNew(n, m);\\n    let idx = 0;\\n    for (let i = 0; i < n; i++) { // read string into matrix\\n        for (let j = 0; j < m; j++) {\\n            g[i][j] = s[idx];\\n            idx++;\\n        }\\n    }\\n    let res = \"\";\\n    let d = diagonal_traverse_topLeft_to_bottomRight(g); // get each diagonal traverse(d[i] array) from first row as starting point\\n    let start = 0; end = d.length - 1; // start: first diagonal starting point idx in d,  end: last diagonal starting point idx in d\\n    for (let i = d.length - 1; i >= start; i--) { // get end idx\\n        if (hasChar(d[i])) {\\n            end = i;\\n            break;\\n        }\\n    }\\n    for (let i = start; i <= end; i++) { // append ans from d[start] and d[end]\\n        if (i == end && start != end) { // d[end] last diagonal should ignore empty string in the end\\n            let curEnd = d[i].length - 1;\\n            for (let j = curEnd; j >= 0; j--) {\\n                let c = d[i][j];\\n                if (c != \\' \\') {\\n                    curEnd = j; // get the end index of d[end] last diagonal\\n                    break;\\n                }\\n            }\\n            for (let j = 0; j <= curEnd; j++)  res += d[i][j]; // append chars for last diagonal\\n        } else {\\n            for (const c of d[i]) res += c; // append all chars for all other diagonals\\n        }\\n    }\\n    return res;\\n};\\n\\nconst hasChar = (a) => {\\n    for (const c of a) {\\n        if (c != \\' \\') return true;\\n    }\\n    return false;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Matrix"
                ],
                "code": "```\\n///////////////////////////////////////////// Template //////////////////////////////////////////////////////////////////////////////\\nconst initialize2DArrayNew = (n, m) => { let data = []; for (let i = 0; i < n; i++) { let tmp = Array(m).fill(0); data.push(tmp); } return data; };\\nconst diagonal_traverse_topLeft_to_bottomRight = (g) => {\\n    let n = g.length;\\n    let m = g[0].length;\\n    let top = [];\\n    for (let j = 0; j < m; j++) { // first row as starting point\\n        let tmp = [];\\n        let share = 0; // shared increase control\\n        while (share < n && j + share < m) { // read Diagonally\\n            tmp.push(g[share][j + share]); // row++ col++\\n            share++;\\n        }\\n         if (tmp.length > 0) top.push(tmp);\\n    }\\n    return top;\\n};\\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\nconst decodeCiphertext = (s, n) => {\\n    let sn = s.length;\\n    if (n == 1) return s;\\n    let m = sn / n;\\n    let g = initialize2DArrayNew(n, m);\\n    let idx = 0;\\n    for (let i = 0; i < n; i++) { // read string into matrix\\n        for (let j = 0; j < m; j++) {\\n            g[i][j] = s[idx];\\n            idx++;\\n        }\\n    }\\n    let res = \"\";\\n    let d = diagonal_traverse_topLeft_to_bottomRight(g); // get each diagonal traverse(d[i] array) from first row as starting point\\n    let start = 0; end = d.length - 1; // start: first diagonal starting point idx in d,  end: last diagonal starting point idx in d\\n    for (let i = d.length - 1; i >= start; i--) { // get end idx\\n        if (hasChar(d[i])) {\\n            end = i;\\n            break;\\n        }\\n    }\\n    for (let i = start; i <= end; i++) { // append ans from d[start] and d[end]\\n        if (i == end && start != end) { // d[end] last diagonal should ignore empty string in the end\\n            let curEnd = d[i].length - 1;\\n            for (let j = curEnd; j >= 0; j--) {\\n                let c = d[i][j];\\n                if (c != \\' \\') {\\n                    curEnd = j; // get the end index of d[end] last diagonal\\n                    break;\\n                }\\n            }\\n            for (let j = 0; j <= curEnd; j++)  res += d[i][j]; // append chars for last diagonal\\n        } else {\\n            for (const c of d[i]) res += c; // append all chars for all other diagonals\\n        }\\n    }\\n    return res;\\n};\\n\\nconst hasChar = (a) => {\\n    for (const c of a) {\\n        if (c != \\' \\') return true;\\n    }\\n    return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1578764,
                "title": "from-tle-to-100",
                "content": "At first, I got TLE 37/39. And that case only has 1 row.\\n```\\nclass Solution(object):\\n    def decodeCiphertext(self, es, rows):\\n        \"\"\"\\n        :type encodedText: str\\n        :type rows: int\\n        :rtype: str\\n        \"\"\"\\n        mn=len(es)\\n        m=mn/rows\\n        mat=[]\\n        if m==0:\\n            return \"\"\\n        res=\"\"\\n        for j in range(m-rows+1):\\n            for i in range(rows):\\n                res+=es[i*m+i+j]\\n        j=m-rows+1\\n        for i in range(rows-1):\\n            res+=es[i*m+i+j]\\n        return res.rstrip()\\n```\\nThen I add one more condition for this case. It is 100%. \\n```\\nclass Solution(object):\\n    def decodeCiphertext(self, es, rows):\\n        \"\"\"\\n        :type encodedText: str\\n        :type rows: int\\n        :rtype: str\\n        \"\"\"\\n        mn=len(es)\\n        m=mn/rows\\n        mat=[]\\n        if m==0:\\n            return \"\"\\n        if rows==1:\\n            return es\\n        #print mat\\n        res=\"\"\\n        for j in range(m-rows+1):\\n            for i in range(rows):\\n                res+=es[i*m+i+j]\\n        j=m-rows+1\\n        for i in range(rows-1):\\n            res+=es[i*m+i+j]\\n        return res.rstrip()\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def decodeCiphertext(self, es, rows):\\n        \"\"\"\\n        :type encodedText: str\\n        :type rows: int\\n        :rtype: str\\n        \"\"\"\\n        mn=len(es)\\n        m=mn/rows\\n        mat=[]\\n        if m==0:\\n            return \"\"\\n        res=\"\"\\n        for j in range(m-rows+1):\\n            for i in range(rows):\\n                res+=es[i*m+i+j]\\n        j=m-rows+1\\n        for i in range(rows-1):\\n            res+=es[i*m+i+j]\\n        return res.rstrip()\\n```\n```\\nclass Solution(object):\\n    def decodeCiphertext(self, es, rows):\\n        \"\"\"\\n        :type encodedText: str\\n        :type rows: int\\n        :rtype: str\\n        \"\"\"\\n        mn=len(es)\\n        m=mn/rows\\n        mat=[]\\n        if m==0:\\n            return \"\"\\n        if rows==1:\\n            return es\\n        #print mat\\n        res=\"\"\\n        for j in range(m-rows+1):\\n            for i in range(rows):\\n                res+=es[i*m+i+j]\\n        j=m-rows+1\\n        for i in range(rows-1):\\n            res+=es[i*m+i+j]\\n        return res.rstrip()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1578623,
                "title": "c-python3-worst-solution",
                "content": "C++\\n```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        int N = encodedText.size();\\n        int cols = N/rows;\\n        string re = \"\";\\n        for(int j=0;j<cols;++j){\\n            for(int k=j;k<=N;k+=cols+1 ){\\n                if(k==N){//optimizer: Return as soon as hitting the invalid index of encodedText\\n                    while(re.back()==\\' \\')\\n                        re.pop_back();\\n                    return re;\\n                }\\n                re += encodedText[k];\\n            }\\n        }\\n        return re;//In case never hitting the invalid index of encodedText.\\n    }\\n};\\n```\\n\\nPython 3\\n```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        N = len(encodedText)\\n        cols = N//rows\\n        re = \"\"\\n        for j in range(cols):\\n            for k in range(j,N+1,cols+1):\\n                if(k==N): #Return as soon as hitting the invalid index of encodedText\\n                   return re.rstrip(\" \")\\n                re += encodedText[k];\\n        return re #In case never hitting the invalid index of encodedText.\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        int N = encodedText.size();\\n        int cols = N/rows;\\n        string re = \"\";\\n        for(int j=0;j<cols;++j){\\n            for(int k=j;k<=N;k+=cols+1 ){\\n                if(k==N){//optimizer: Return as soon as hitting the invalid index of encodedText\\n                    while(re.back()==\\' \\')\\n                        re.pop_back();\\n                    return re;\\n                }\\n                re += encodedText[k];\\n            }\\n        }\\n        return re;//In case never hitting the invalid index of encodedText.\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        N = len(encodedText)\\n        cols = N//rows\\n        re = \"\"\\n        for j in range(cols):\\n            for k in range(j,N+1,cols+1):\\n                if(k==N): #Return as soon as hitting the invalid index of encodedText\\n                   return re.rstrip(\" \")\\n                re += encodedText[k];\\n        return re #In case never hitting the invalid index of encodedText.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1578508,
                "title": "python-3-simple-traversing-solution-better-time-and-memory-than-83-of-submission",
                "content": "\\n```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        nrows = rows\\n        decoded_str = \"\"\\n        ncols = int(len(encodedText)/nrows)\\n        ## the total number of slanted lines will be equal to the number of columns. so we print each slanted line, indexed by j, using the first loop below.\\n\\t\\tfor j in range(ncols):\\n\\t\\t\\t## the \"first\" slanted lines will have a length equal to the number of rows but the slanted line near the end of string will have a length lower than the number of rows\\n\\t\\t\\t## because you will hit the final column, and it prevents you from having a slanted line with length of number of rows. the value i, shows the indices of rows that contribute\\n\\t\\t\\t## to the current slanted line ( indexed by j) before.\\n            for i in range(0,min(ncols-j, nrows)):\\n\\t\\t\\t\\t\\t\\t# addressing the value of encodedTextMatrix[i,j] without actually construcing the matrix from encodedText. you can replace this line with\\n\\t\\t\\t\\t\\t\\t# decoded_str += encodedTextMatrix[i,j] if you prefer to first reconstruct the encodedTextMatrix matrix to keep things nice and clean\\n                        decoded_str += encodedText[i*ncols+i+j]\\n        return decoded_str.rstrip(\" \")\\n                \\n```\\ntime complexity is O(n^2) as we add all elements from the original matrix (including the trailing spaces) and then will remove them. \\na simple modification can turn the algorithm to O(n) though. simply check if all of non-space characters are already added to decoded_str and in that case just stop.\\n```\\nfrom collections import defaultdict\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        nrows = rows\\n        decoded_str = \"\"\\n\\t\\t## keep track of characters from encodedText that were added to our to-be-returned result string (decoded_str)\\n        used_chars = defaultdict(int)\\n\\t\\t## length of non-space characters in encodedText\\n        all_chars = len([encodedText[i] for i in range(len(encodedText)) if encodedText[i]!=\" \"])\\n        ncols = int(len(encodedText)/nrows)\\n        for j in range(ncols):\\n\\t\\t\\t# check if all non-space characters from encodedText are already added to decoded_str\\n            if len(used_chars) == all_chars:\\n                break       \\n            for i in range(0,min(ncols-j, nrows)):\\n                        ind = i*ncols+i+j\\n\\t\\t\\t\\t\\t\\t## if current chracter is not space, add it to used_chars\\n                        if encodedText[ind] != \" \":\\n                            used_chars[ind] = 1\\n                        decoded_str += encodedText[ind]\\n\\t\\t# we may still have a few (less than n) spaced at the end of string but it doesn\\'t affect time complexity and can get stripped simply. \\n\\t\\t#the reason is that you can\\'t break from the inner loop in a nested loops in python! and doing that would make the code a bit ugly\\n        return decoded_str.rstrip(\" \")\\n                \\n```\\ntime complexity O(n)",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        nrows = rows\\n        decoded_str = \"\"\\n        ncols = int(len(encodedText)/nrows)\\n        ## the total number of slanted lines will be equal to the number of columns. so we print each slanted line, indexed by j, using the first loop below.\\n\\t\\tfor j in range(ncols):\\n\\t\\t\\t## the \"first\" slanted lines will have a length equal to the number of rows but the slanted line near the end of string will have a length lower than the number of rows\\n\\t\\t\\t## because you will hit the final column, and it prevents you from having a slanted line with length of number of rows. the value i, shows the indices of rows that contribute\\n\\t\\t\\t## to the current slanted line ( indexed by j) before.\\n            for i in range(0,min(ncols-j, nrows)):\\n\\t\\t\\t\\t\\t\\t# addressing the value of encodedTextMatrix[i,j] without actually construcing the matrix from encodedText. you can replace this line with\\n\\t\\t\\t\\t\\t\\t# decoded_str += encodedTextMatrix[i,j] if you prefer to first reconstruct the encodedTextMatrix matrix to keep things nice and clean\\n                        decoded_str += encodedText[i*ncols+i+j]\\n        return decoded_str.rstrip(\" \")\\n                \\n```\n```\\nfrom collections import defaultdict\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        nrows = rows\\n        decoded_str = \"\"\\n\\t\\t## keep track of characters from encodedText that were added to our to-be-returned result string (decoded_str)\\n        used_chars = defaultdict(int)\\n\\t\\t## length of non-space characters in encodedText\\n        all_chars = len([encodedText[i] for i in range(len(encodedText)) if encodedText[i]!=\" \"])\\n        ncols = int(len(encodedText)/nrows)\\n        for j in range(ncols):\\n\\t\\t\\t# check if all non-space characters from encodedText are already added to decoded_str\\n            if len(used_chars) == all_chars:\\n                break       \\n            for i in range(0,min(ncols-j, nrows)):\\n                        ind = i*ncols+i+j\\n\\t\\t\\t\\t\\t\\t## if current chracter is not space, add it to used_chars\\n                        if encodedText[ind] != \" \":\\n                            used_chars[ind] = 1\\n                        decoded_str += encodedText[ind]\\n\\t\\t# we may still have a few (less than n) spaced at the end of string but it doesn\\'t affect time complexity and can get stripped simply. \\n\\t\\t#the reason is that you can\\'t break from the inner loop in a nested loops in python! and doing that would make the code a bit ugly\\n        return decoded_str.rstrip(\" \")\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1578401,
                "title": "detailed-explanation-pictures-included-time-complexity-o-n-c",
                "content": "Lets take an Example of \\n\"iveo    eed   l te   olc\", rows = 4\\n![image](https://assets.leetcode.com/users/images/0e48373f-3ed3-436a-bdb7-15bb3da81f00_1636918352.7840478.png)\\n\\nFor the final answer , we can assume ,\\nour final matrix will look like \\n\\n![image](https://assets.leetcode.com/users/images/700fb0e5-ccc7-40d1-a66b-1de51d4345a2_1636918445.377144.png)\\n\\n( all the element at 0,0 will be appended , same for 0,1 )\\nSo for the (0,0) we\\'ll have \\n![image](https://assets.leetcode.com/users/images/2d640e3c-dfad-4ac8-b982-eb4faa804904_1636919025.3151329.png)\\nto->\\n\\n![image](https://assets.leetcode.com/users/images/4cef7439-0431-4828-a09b-50e4efa7d105_1636919300.2266514.png)\\n\\nand for (0,1)\\nwe have \\n![image](https://assets.leetcode.com/users/images/72e759aa-b918-4a08-9a0f-97831722ddb1_1636919551.0411148.png)\\nand so on .\\nWith little manupulation , we can omit the 2D array and it can we solved with 1D ,\\nbecause \\nall the (0,0) cells can we appended at index 0 in 1D array , \\nall the (0,1) cells can we appended at index 1 in 1D array              \\nall the (0,2) cells can we appended at index 2 in 1D array\\nand so on . \\n\\n```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        if(rows ==1){\\n            return encodedText;\\n        }\\n        if(encodedText.size()==0){\\n            return \"\";\\n        }\\n        int cols = encodedText.size()/rows;\\n        vector<string>temp(cols,\"\");\\n \\n        int c = -1;\\n        for(int i = 0;i<encodedText.size();i++){\\n            if(i%cols == 0){\\n                c++;\\n            }\\n            \\n            if((i%cols)-c >=0)\\n            temp[(i%cols)-c] += encodedText[i];\\n        }\\n        string ans = \"\";\\n        for(auto x: temp){\\n            ans = ans+x;\\n        }\\n        int n = ans.size()-1;\\n        c = 0;\\n        while(ans[n]==\\' \\'){\\n            n--;\\n            c++;\\n        }\\n        ans = ans.substr(0,ans.size()-c);\\n        return ans;\\n    }\\n};\\n```\\nTime complexity O(n) : n-> size of encodedText . \\nHope , it helps :)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        if(rows ==1){\\n            return encodedText;\\n        }\\n        if(encodedText.size()==0){\\n            return \"\";\\n        }\\n        int cols = encodedText.size()/rows;\\n        vector<string>temp(cols,\"\");\\n \\n        int c = -1;\\n        for(int i = 0;i<encodedText.size();i++){\\n            if(i%cols == 0){\\n                c++;\\n            }\\n            \\n            if((i%cols)-c >=0)\\n            temp[(i%cols)-c] += encodedText[i];\\n        }\\n        string ans = \"\";\\n        for(auto x: temp){\\n            ans = ans+x;\\n        }\\n        int n = ans.size()-1;\\n        c = 0;\\n        while(ans[n]==\\' \\'){\\n            n--;\\n            c++;\\n        }\\n        ans = ans.substr(0,ans.size()-c);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1578400,
                "title": "golang-solution",
                "content": "```\\nfunc decodeCiphertext(encodedText string, rows int) string {\\n    cols := len(encodedText)/rows\\n    var sb strings.Builder\\n    for i:=0;i<cols;i++ {\\n        for j:=i;j<len(encodedText);j+=cols+1 {\\n            sb.WriteByte(encodedText[j])\\n        }\\n    }\\n    return strings.TrimRight(sb.String(), \" \")\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc decodeCiphertext(encodedText string, rows int) string {\\n    cols := len(encodedText)/rows\\n    var sb strings.Builder\\n    for i:=0;i<cols;i++ {\\n        for j:=i;j<len(encodedText);j+=cols+1 {\\n            sb.WriteByte(encodedText[j])\\n        }\\n    }\\n    return strings.TrimRight(sb.String(), \" \")\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1578265,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public String decodeCiphertext(String encodedText, int rows) {\\n        int n = encodedText.length();\\n        int cols = n/rows,index=0;\\n        char[][] array = new char[rows][cols];\\n        for(int i=0;i<rows;i++){\\n            for(int j=0;j<cols;j++){\\n                array[i][j]=encodedText.charAt(index++);\\n            }\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        for(int i=0;i<cols;i++){\\n            int start=0,end=i;\\n            StringBuilder curr = new StringBuilder();\\n            while(start<rows && end<cols){\\n                curr.append(array[start][end]);\\n                start++;end++;\\n            }\\n            sb.append(curr);\\n        }\\n        int len = sb.length();\\n        int i=len-1;\\n        for(;i>=0&&sb.charAt(i)==\\' \\';i--);\\n        return sb.toString().substring(0,i+1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String decodeCiphertext(String encodedText, int rows) {\\n        int n = encodedText.length();\\n        int cols = n/rows,index=0;\\n        char[][] array = new char[rows][cols];\\n        for(int i=0;i<rows;i++){\\n            for(int j=0;j<cols;j++){\\n                array[i][j]=encodedText.charAt(index++);\\n            }\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        for(int i=0;i<cols;i++){\\n            int start=0,end=i;\\n            StringBuilder curr = new StringBuilder();\\n            while(start<rows && end<cols){\\n                curr.append(array[start][end]);\\n                start++;end++;\\n            }\\n            sb.append(curr);\\n        }\\n        int len = sb.length();\\n        int i=len-1;\\n        for(;i>=0&&sb.charAt(i)==\\' \\';i--);\\n        return sb.toString().substring(0,i+1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1578209,
                "title": "c-o-n-solution",
                "content": "```\\nstring decodeCiphertext(string str, int rows) {\\n        if(rows==1)\\n            return str;\\n        string res;\\n        int n=rows, m=str.size()/rows, i=0,j=0,x,y;\\n        \\n        while(j<m) {\\n            \\n            x=i; y=j;\\n            while(x<n && y<m) {\\n                res.push_back(str[x*m + y]);\\n                ++x;\\n                ++y;\\n            }\\n            ++j;\\n        }        \\n        while(res.size() && res.back()==\\' \\')\\n            res.pop_back();\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nstring decodeCiphertext(string str, int rows) {\\n        if(rows==1)\\n            return str;\\n        string res;\\n        int n=rows, m=str.size()/rows, i=0,j=0,x,y;\\n        \\n        while(j<m) {\\n            \\n            x=i; y=j;\\n            while(x<n && y<m) {\\n                res.push_back(str[x*m + y]);\\n                ++x;\\n                ++y;\\n            }\\n            ++j;\\n        }        \\n        while(res.size() && res.back()==\\' \\')\\n            res.pop_back();\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1578132,
                "title": "java-solution-with-clean-code",
                "content": "```\\n    public String decodeCiphertext(String encodedText, int rows) {\\n        if (rows == 1) {\\n            return encodedText;\\n        }\\n\\n        int columns = encodedText.length() / rows;\\n\\n        char[][] matrix = new char[rows][columns];\\n        for (int i = 0; i < rows; i++) {\\n            matrix[i] = encodedText.substring(i * columns, (i + 1) * columns).toCharArray();\\n        }\\n\\n        StringBuilder result = new StringBuilder();\\n\\n        for (int i = 0; i < columns; i++) {\\n            int counter = i;\\n            for (int j = 0; j < rows; j++) {\\n                if (counter < columns) {\\n                    result.append(matrix[j][counter++]);\\n                }\\n            }\\n        }\\n\\n        return result.toString().replaceAll(\"\\\\\\\\s+$\", \"\");\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public String decodeCiphertext(String encodedText, int rows) {\\n        if (rows == 1) {\\n            return encodedText;\\n        }\\n\\n        int columns = encodedText.length() / rows;\\n\\n        char[][] matrix = new char[rows][columns];\\n        for (int i = 0; i < rows; i++) {\\n            matrix[i] = encodedText.substring(i * columns, (i + 1) * columns).toCharArray();\\n        }\\n\\n        StringBuilder result = new StringBuilder();\\n\\n        for (int i = 0; i < columns; i++) {\\n            int counter = i;\\n            for (int j = 0; j < rows; j++) {\\n                if (counter < columns) {\\n                    result.append(matrix[j][counter++]);\\n                }\\n            }\\n        }\\n\\n        return result.toString().replaceAll(\"\\\\\\\\s+$\", \"\");\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1578068,
                "title": "c-easy-solution-beginner-friendly",
                "content": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        string last_string=\"\",ans=\"\",anss=\"\";\\n        if (encodedText.length()==0) \\n            return \"\";\\n        int col= encodedText.size()/rows;\\n        if (col==0 || rows==1) return encodedText;\\n        char mat[rows][col];\\n        // to keep track of the visited diagonals\\n        vector<vector<int>> visited(rows, vector<int>(col, 0));\\n        int k=0;\\n        for (int i=0;i<rows;i++){\\n            for (int j=0;j<col;j++){\\n                mat[i][j]=encodedText[k];\\n                k++;\\n            }\\n        }\\n        // once we visit a diagonal mark all the elements as in visited matrix 1 to ensure we dont visit same diagonal to reuce time complexity\\n        for (int i=0;i<rows;i++){\\n            for (int j=0;j<col;j++){\\n                int a=i,b=j;\\n                if (visited[a][b]==0){\\n                   while (a< rows && b < col){\\n                         ans+=mat[a][b];\\n                         visited[a][b]=1;\\n                         a++;\\n                         b++;\\n                    }\\n                }\\n            }\\n        }\\n        int i=ans.length()-1;\\n        // to erase trailing spaces in answer\\n        while (ans[i]==\\' \\'){\\n            ans.pop_back();\\n            i--;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        string last_string=\"\",ans=\"\",anss=\"\";\\n        if (encodedText.length()==0) \\n            return \"\";\\n        int col= encodedText.size()/rows;\\n        if (col==0 || rows==1) return encodedText;\\n        char mat[rows][col];\\n        // to keep track of the visited diagonals\\n        vector<vector<int>> visited(rows, vector<int>(col, 0));\\n        int k=0;\\n        for (int i=0;i<rows;i++){\\n            for (int j=0;j<col;j++){\\n                mat[i][j]=encodedText[k];\\n                k++;\\n            }",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1738999,
                "content": [
                    {
                        "username": "ranjeet43",
                        "content": "Approach 1:\\nIntuition :\\n\\nIdea here is to just do what we are asked to perform. That is simulate decoding steps.\\n\\nFirst, we need to make cipher matrix using encodedText.\\n\\nThen, for each column in first row, we traverse diagonally and add those characters to decodedText string.\\n\\nIn the end, since trailing spaces are not allowed, so we remove it from decodedString.\\n\\nWe can have two cases.\\n\\nOne when rows = 1. In this case, we decodedText is same as encodedText.\\nAnd other when rows > 1. In this, we need to perform above simulation.\\nLets understand through simple example :\\n\\n  Case 1 : if rows == 1\\n  \\t\\t\\t\\t\\n    Ex: \"c o d i n g\"\\n      \\n  \\t-> In this case we do not need to decode text. We can simply return encodedText directly. \\n  \\t-> This is because all characters are in first row.\\n  \\n  Case 2: if rows > 1\\n  \\t\\t\\t\\t\\n  \\tEx: encodedText = \"ch   ie   pr\" , rows = 3\\n  \\t\\n  \\tcipher matrix : \\n  \\t\\t  \"c h _ _\\n  \\t       _ i e _  \\n  \\t\\t   _ _ p r\"\\n     \\n     -> Note : Here, just for sake of explanation, I have take space(\" \") as underscore(_).\\n     \\n      i. k = 0 => {(0,0) : \\'c\\'}, {(1,1) : \\'i\\'}, {(2,2) : \\'p\\'} \\n      ii. k = 1 => {(0,1) : \\'h\\'}, {(1,2) : \\'e\\'}, {(2,3) : \\'r\\'}\\n  \\tiii. k = 2 => {(0,2) : \\'_\\'}, {(1,3) : \\'_\\'}\\n  \\t\\n  \\tThus, decodedString with trailing spaces = \"cipher_ _\". \\n  \\tWe need to remove these trailing spaces, and then return resultant string.\\n  \\n  \\t"
                    }
                ]
            }
        ]
    },
    {
        "title": "Process Restricted Friend Requests",
        "question_content": "<p>You are given an integer <code>n</code> indicating the number of people in a network. Each person is labeled from <code>0</code> to <code>n - 1</code>.</p>\n\n<p>You are also given a <strong>0-indexed</strong> 2D integer array <code>restrictions</code>, where <code>restrictions[i] = [x<sub>i</sub>, y<sub>i</sub>]</code> means that person <code>x<sub>i</sub></code> and person <code>y<sub>i</sub></code> <strong>cannot </strong>become <strong>friends</strong>,<strong> </strong>either <strong>directly</strong> or <strong>indirectly</strong> through other people.</p>\n\n<p>Initially, no one is friends with each other. You are given a list of friend requests as a <strong>0-indexed</strong> 2D integer array <code>requests</code>, where <code>requests[j] = [u<sub>j</sub>, v<sub>j</sub>]</code> is a friend request between person <code>u<sub>j</sub></code> and person <code>v<sub>j</sub></code>.</p>\n\n<p>A friend request is <strong>successful </strong>if <code>u<sub>j</sub></code> and <code>v<sub>j</sub></code> can be <strong>friends</strong>. Each friend request is processed in the given order (i.e., <code>requests[j]</code> occurs before <code>requests[j + 1]</code>), and upon a successful request, <code>u<sub>j</sub></code> and <code>v<sub>j</sub></code> <strong>become direct friends</strong> for all future friend requests.</p>\n\n<p>Return <em>a <strong>boolean array</strong> </em><code>result</code>,<em> where each </em><code>result[j]</code><em> is </em><code>true</code><em> if the </em><code>j<sup>th</sup></code><em> friend request is <strong>successful</strong> or </em><code>false</code><em> if it is not</em>.</p>\n\n<p><strong>Note:</strong> If <code>u<sub>j</sub></code> and <code>v<sub>j</sub></code> are already direct friends, the request is still <strong>successful</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 3, restrictions = [[0,1]], requests = [[0,2],[2,1]]\n<strong>Output:</strong> [true,false]\n<strong>Explanation:\n</strong>Request 0: Person 0 and person 2 can be friends, so they become direct friends. \nRequest 1: Person 2 and person 1 cannot be friends since person 0 and person 1 would be indirect friends (1--2--0).\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 3, restrictions = [[0,1]], requests = [[1,2],[0,2]]\n<strong>Output:</strong> [true,false]\n<strong>Explanation:\n</strong>Request 0: Person 1 and person 2 can be friends, so they become direct friends.\nRequest 1: Person 0 and person 2 cannot be friends since person 0 and person 1 would be indirect friends (0--2--1).\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 5, restrictions = [[0,1],[1,2],[2,3]], requests = [[0,4],[1,2],[3,1],[3,4]]\n<strong>Output:</strong> [true,false,true,false]\n<strong>Explanation:\n</strong>Request 0: Person 0 and person 4 can be friends, so they become direct friends.\nRequest 1: Person 1 and person 2 cannot be friends since they are directly restricted.\nRequest 2: Person 3 and person 1 can be friends, so they become direct friends.\nRequest 3: Person 3 and person 4 cannot be friends since person 0 and person 1 would be indirect friends (0--4--3--1).\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n &lt;= 1000</code></li>\n\t<li><code>0 &lt;= restrictions.length &lt;= 1000</code></li>\n\t<li><code>restrictions[i].length == 2</code></li>\n\t<li><code>0 &lt;= x<sub>i</sub>, y<sub>i</sub> &lt;= n - 1</code></li>\n\t<li><code>x<sub>i</sub> != y<sub>i</sub></code></li>\n\t<li><code>1 &lt;= requests.length &lt;= 1000</code></li>\n\t<li><code>requests[j].length == 2</code></li>\n\t<li><code>0 &lt;= u<sub>j</sub>, v<sub>j</sub> &lt;= n - 1</code></li>\n\t<li><code>u<sub>j</sub> != v<sub>j</sub></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 1576935,
                "title": "c-union-find",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n## Solution 1. Union Find\\n\\nGiven the constraints, a solution with `O(R * B)` is acceptable -- for each request, check if it obeys all the bans.\\n\\nFor the check, we can do it in `O(1)` time using UnionFind. For each prior valid requests, we connect the two friends. For a new request, we just need to check if the leaders of the two parties are in any of those bans.\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/process-restricted-friend-requests/\\n// Author: github.com/lzl124631x\\n// Time: O(R * B) where `R`/`B` is the length of `requests`/`bans`\\n// Space: O(N)\\nclass UnionFind {\\n    vector<int> id;\\npublic:\\n    UnionFind(int n) : id(n) {\\n        iota(begin(id), end(id), 0);\\n    }\\n    void connect(int a, int b) {\\n        id[find(a)] = find(b);\\n    }\\n    int find(int a) {\\n        return id[a] == a ? a : (id[a] = find(id[a]));\\n    }\\n    int connected(int a, int b) {\\n        return find(a) == find(b);\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& bans, vector<vector<int>>& requests) {\\n        vector<bool> ans;\\n        UnionFind uf(n);\\n        for (auto &r : requests) {\\n            int p = uf.find(r[0]), q = uf.find(r[1]); // the leaders of the two parties\\n            bool valid = true;\\n            if (!uf.connected(p, q)) { // Only need to check the bans if the two parties are not already connected\\n                for (auto &b : bans) {\\n                    int x = uf.find(b[0]), y = uf.find(b[1]); // the leaders of the two banned parties\\n                    if ((x == p && y == q) || (x == q && y == p)) {\\n                        valid = false;\\n                        break;\\n                    }\\n                }\\n            }\\n            ans.push_back(valid);\\n            if (valid) uf.connect(p, q); // connect two parties if request is valid\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/problems/process-restricted-friend-requests/\\n// Author: github.com/lzl124631x\\n// Time: O(R * B) where `R`/`B` is the length of `requests`/`bans`\\n// Space: O(N)\\nclass UnionFind {\\n    vector<int> id;\\npublic:\\n    UnionFind(int n) : id(n) {\\n        iota(begin(id), end(id), 0);\\n    }\\n    void connect(int a, int b) {\\n        id[find(a)] = find(b);\\n    }\\n    int find(int a) {\\n        return id[a] == a ? a : (id[a] = find(id[a]));\\n    }\\n    int connected(int a, int b) {\\n        return find(a) == find(b);\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& bans, vector<vector<int>>& requests) {\\n        vector<bool> ans;\\n        UnionFind uf(n);\\n        for (auto &r : requests) {\\n            int p = uf.find(r[0]), q = uf.find(r[1]); // the leaders of the two parties\\n            bool valid = true;\\n            if (!uf.connected(p, q)) { // Only need to check the bans if the two parties are not already connected\\n                for (auto &b : bans) {\\n                    int x = uf.find(b[0]), y = uf.find(b[1]); // the leaders of the two banned parties\\n                    if ((x == p && y == q) || (x == q && y == p)) {\\n                        valid = false;\\n                        break;\\n                    }\\n                }\\n            }\\n            ans.push_back(valid);\\n            if (valid) uf.connect(p, q); // connect two parties if request is valid\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1576913,
                "title": "python-usual-union-find-explained",
                "content": "The idea is that given problem constraints, we can allow to use union find. The idea is to traverse `x, y in requests` and check if we can make these persons friends or not. We can make them if we do not have restrictions: we go through all restrictions and check that we do not have restriction for two given connected components.\\n\\n#### Complexity\\nIt is `O(n * m * log(n))` for time and `O(n)` for space, where `m = len(requests)`.\\n\\n```python\\nclass DSU:\\n    def __init__(self, N):\\n        self.p = list(range(N))\\n\\n    def find(self, x):\\n        if self.p[x] != x:\\n            self.p[x] = self.find(self.p[x])\\n        return self.p[x]\\n\\n    def union(self, x, y):\\n        xr = self.find(x)\\n        yr = self.find(y)\\n        self.p[xr] = yr\\n\\nclass Solution:\\n    def friendRequests(self, n, restr, requests):\\n        dsu, ans = DSU(n), []\\n        for x, y in requests:\\n            x_p, y_p = dsu.find(x), dsu.find(y)\\n            bad = True\\n            for a, b in restr:\\n                a_p, b_p = dsu.find(a), dsu.find(b)\\n                if set([a_p, b_p]) == set([x_p, y_p]):\\n                    bad = False\\n                    break\\n                    \\n            ans += [bad]\\n            if bad: dsu.union(x, y)\\n                \\n        return ans\\n```\\n\\nIf you have any questoins, feel free to ask. If you like the solution and explanation, please **upvote!**",
                "solutionTags": [
                    "Union Find"
                ],
                "code": "```python\\nclass DSU:\\n    def __init__(self, N):\\n        self.p = list(range(N))\\n\\n    def find(self, x):\\n        if self.p[x] != x:\\n            self.p[x] = self.find(self.p[x])\\n        return self.p[x]\\n\\n    def union(self, x, y):\\n        xr = self.find(x)\\n        yr = self.find(y)\\n        self.p[xr] = yr\\n\\nclass Solution:\\n    def friendRequests(self, n, restr, requests):\\n        dsu, ans = DSU(n), []\\n        for x, y in requests:\\n            x_p, y_p = dsu.find(x), dsu.find(y)\\n            bad = True\\n            for a, b in restr:\\n                a_p, b_p = dsu.find(a), dsu.find(b)\\n                if set([a_p, b_p]) == set([x_p, y_p]):\\n                    bad = False\\n                    break\\n                    \\n            ans += [bad]\\n            if bad: dsu.union(x, y)\\n                \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1576912,
                "title": "c-union-find-simple-straightforward-idea-explained",
                "content": "\\n\\nThis problem is generous in terms of constraints and we can leverage that to come up with an easily understandable solution!\\n\\n**Union Find**\\nA Union Find data structure, also known as the Disjoint Set data structure, stores a collection of disjoint (non overlapping) sets. It mainly has two operations:\\n* Union(x, y): It unifies the two arguments into a single set\\n* Find(x): It finds the root or the parent of the set which the argument belongs to.\\n\\nThis data structure is perfect for our current problem as we can group all the friends in disjoint sets and make use of the operations to efficiently do so. I also employ something known as path compression which makes the complexity of both *union* and *find* operations to be amortized O(1). You can learn more about Union Find on Hackerearth and GFG. In fact, I have prepared my template from these sites. \\n\\n**Idea**\\nNow that it is clear we are going to use Union Find here, let us proceed to discussing about how exactly are we planning to do so. \\nThe idea is simple and straightforward. We maintain a Union Find data structure which stores all the friends. When we encounter a new friend request, we *accept* it but not really! What I mean is we temporarily accept to check whether it causes any violation of the restrictions or not. \\nHow do we do so? \\nBy making a copy of our Union Find data structure and unifying the participants of the request in the copy. Then we traverse the list of restrictions and individually check if we are violating any. This is done by checking that the roots/parents of the members of the restriction are same or not. If they are, then they belong to the same friend group which is a violation. If we face no violations, then we can *accept* this friend request in our original data structure as well.\\n\\nThat\\'s it!\\n\\nThe code might look big, but that is only because of the template. \\n\\n**C++**\\n```\\nclass UnionFind {\\npublic:\\n    vector<int> parent;\\n\\n    UnionFind(int n) {\\n        parent.resize(n + 1, -1);\\n    }\\n\\n    int find(int x) {\\n        int root = x;\\n        while (parent[root] >= 0) {\\n            root = parent[root];\\n        }\\n\\n        // Path Compression\\n        while (parent[x] >= 0) {\\n            int next = parent[x];\\n            parent[x] = root;\\n            x = next;\\n        }\\n\\n        return root;\\n    }\\n\\n    void unionz(int x, int y) {\\n        int root1 = find(x);\\n        int root2 = find(y);\\n\\n        if (root1 == root2)\\n            return;\\n\\n        if (parent[root1] < parent[root2]) {\\n            parent[root1] += parent[root2];\\n            parent[root2] = root1;\\n        } else {\\n            parent[root2] += parent[root1];\\n            parent[root1] = root2;\\n        }\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        int m = requests.size();\\n        vector<bool> ans(m, 0);\\n        \\n        UnionFind UF(n);\\n        \\n        for(int i = 0; i < m; i++) {\\n            UnionFind temp = UF;\\n            temp.unionz(requests[i][0], requests[i][1]);\\n            bool flag = true;\\n            for(vector<int>& v : restrictions) {\\n                if(temp.find(v[0]) == temp.find(v[1])) {\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            \\n            if(flag) {\\n                ans[i] = true;\\n                UF.unionz(requests[i][0], requests[i][1]);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n**Complexity Analysis**\\n*Space Complexity (Auxiliary): O(n)*\\n*Time Complexity: O(m * n)*",
                "solutionTags": [
                    "Union Find"
                ],
                "code": "```\\nclass UnionFind {\\npublic:\\n    vector<int> parent;\\n\\n    UnionFind(int n) {\\n        parent.resize(n + 1, -1);\\n    }\\n\\n    int find(int x) {\\n        int root = x;\\n        while (parent[root] >= 0) {\\n            root = parent[root];\\n        }\\n\\n        // Path Compression\\n        while (parent[x] >= 0) {\\n            int next = parent[x];\\n            parent[x] = root;\\n            x = next;\\n        }\\n\\n        return root;\\n    }\\n\\n    void unionz(int x, int y) {\\n        int root1 = find(x);\\n        int root2 = find(y);\\n\\n        if (root1 == root2)\\n            return;\\n\\n        if (parent[root1] < parent[root2]) {\\n            parent[root1] += parent[root2];\\n            parent[root2] = root1;\\n        } else {\\n            parent[root2] += parent[root1];\\n            parent[root1] = root2;\\n        }\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        int m = requests.size();\\n        vector<bool> ans(m, 0);\\n        \\n        UnionFind UF(n);\\n        \\n        for(int i = 0; i < m; i++) {\\n            UnionFind temp = UF;\\n            temp.unionz(requests[i][0], requests[i][1]);\\n            bool flag = true;\\n            for(vector<int>& v : restrictions) {\\n                if(temp.find(v[0]) == temp.find(v[1])) {\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            \\n            if(flag) {\\n                ans[i] = true;\\n                UF.unionz(requests[i][0], requests[i][1]);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1576992,
                "title": "python-union-friends",
                "content": "# **Explanation**\\nUse union-found to union friends.\\nFor each request, check if doesn\\'t obey any restrictions.\\n<br>\\n\\n# **Complexity**\\nUnion-find operation with rank and path comression,has amotized `O(1)`\\nTime `O(requests * restrictions)`\\nSpace `O(n)`\\n<br>\\n\\n**Python**\\n```py\\n    def friendRequests(self, n, restrictions, requests):\\n        uf = {i: i for i in xrange(n)}\\n        res = []\\n\\n        def find(i):\\n            if i != uf[i]:\\n                uf[i] = find(uf[i])\\n            return uf[i]\\n\\n        for i, j in requests:\\n            success = True\\n            pi, pj = find(i), find(j)\\n            if pi != pj:\\n                for x, y in restrictions:\\n                    px, py = find(x), find(y)\\n                    if (px, py) == (pi, pj) or (px, py) == (pj, pi):\\n                        success = False\\n                        break\\n            if success:\\n                uf[pj] = pi\\n            res.append(success)\\n        return res\\n```\\n",
                "solutionTags": [],
                "code": "```py\\n    def friendRequests(self, n, restrictions, requests):\\n        uf = {i: i for i in xrange(n)}\\n        res = []\\n\\n        def find(i):\\n            if i != uf[i]:\\n                uf[i] = find(uf[i])\\n            return uf[i]\\n\\n        for i, j in requests:\\n            success = True\\n            pi, pj = find(i), find(j)\\n            if pi != pj:\\n                for x, y in restrictions:\\n                    px, py = find(x), find(y)\\n                    if (px, py) == (pi, pj) or (px, py) == (pj, pi):\\n                        success = False\\n                        break\\n            if success:\\n                uf[pj] = pi\\n            res.append(success)\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1577293,
                "title": "python-union-find-beat-100-by-updating-restrictions",
                "content": "```\\nclass Solution:\\n    def friendRequests(self, n: int, restrictions: List[List[int]], requests: List[List[int]]) -> List[bool]:\\n        parents = [i for i in range(n)]\\n        ranks = [0] * n\\n        forbidden = collections.defaultdict(set)\\n        for i, j in restrictions:\\n            forbidden[i].add(j)\\n            forbidden[j].add(i)\\n        \\n        def find(i):\\n            if i != parents[i]:\\n                parents[i] = find(parents[i])\\n            return parents[i]\\n        \\n        def union(p1, p2):\\n            if ranks[p1] > ranks[p2]:\\n                parents[p2] = p1\\n            elif ranks[p1] < ranks[p2]:\\n                parents[p1] = p2\\n                p1, p2 = p2, p1\\n            else:\\n                ranks[p1] += 1\\n                parents[p2] = p1\\n                \\n            forbidden[p1] |= forbidden[p2]\\n            for i in forbidden[p2]:\\n                forbidden[i].remove(p2)\\n                forbidden[i].add(p1)\\n            del forbidden[p2]\\n        \\n        ans = []\\n        for i, j in requests:\\n            p1 = find(i)\\n            p2 = find(j)\\n            if p1 == p2:\\n                ans.append(True)         \\n            elif p2 in forbidden[p1]:\\n                ans.append(False)\\n            else:\\n                union(p1, p2)\\n                ans.append(True)\\n\\n        return ans\\n                    \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def friendRequests(self, n: int, restrictions: List[List[int]], requests: List[List[int]]) -> List[bool]:\\n        parents = [i for i in range(n)]\\n        ranks = [0] * n\\n        forbidden = collections.defaultdict(set)\\n        for i, j in restrictions:\\n            forbidden[i].add(j)\\n            forbidden[j].add(i)\\n        \\n        def find(i):\\n            if i != parents[i]:\\n                parents[i] = find(parents[i])\\n            return parents[i]\\n        \\n        def union(p1, p2):\\n            if ranks[p1] > ranks[p2]:\\n                parents[p2] = p1\\n            elif ranks[p1] < ranks[p2]:\\n                parents[p1] = p2\\n                p1, p2 = p2, p1\\n            else:\\n                ranks[p1] += 1\\n                parents[p2] = p1\\n                \\n            forbidden[p1] |= forbidden[p2]\\n            for i in forbidden[p2]:\\n                forbidden[i].remove(p2)\\n                forbidden[i].add(p1)\\n            del forbidden[p2]\\n        \\n        ans = []\\n        for i, j in requests:\\n            p1 = find(i)\\n            p2 = find(j)\\n            if p1 == p2:\\n                ans.append(True)         \\n            elif p2 in forbidden[p1]:\\n                ans.append(False)\\n            else:\\n                union(p1, p2)\\n                ans.append(True)\\n\\n        return ans\\n                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1578306,
                "title": "java-clean-and-commented-code-with-explanation-union-find-algorithm",
                "content": "**PREREQUISITE: UNION-FIND ALGORITHM**\\n\\nThis problem is pretty straightforwad. Basically they are saying that two people can be friends if they have no restrictions or any of their mutual friends have no restriction.\\n\\nThe simplest way to solve this would be to use the union-find technique to link all the persons with mutual friends to one common ancestor. Now for every request we simply check that whether those ancestors have any restrictions or not. If they do they can\\'t be friends or else they can be.\\n\\n**EDIT - There is a nice optimization that could be done inside findParent, check @chinghsuanwei0206\\'s comment for explanation.**\\n\\nHere is the code for the same,\\n\\n```\\nclass Solution {\\n    \\n    //Classic Union-Find Algorithm to find Common Ancestor\\n    private int findParent(int[] parent, int index) {\\n        if(parent[index] == index) return index;\\n        return findParent(parent, parent[index]);\\n    }\\n   \\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        int resLength = restrictions.length, reqLength = requests.length;\\n        boolean[] result = new boolean[reqLength];\\n        int[] parent = new int[n];\\n        \\n        //Initially ith person\\'s parent is i itself\\n        for(int i = 0; i < n; i++) parent[i] = i;\\n        \\n\\n        for(int i = 0; i < reqLength; i++) {\\n            //finding the parents of the first person and second person of ith request\\n            int firstParent = findParent(parent, requests[i][0]);\\n            int secondParent = findParent(parent, requests[i][1]);\\n            \\n            //if they have same parents i.e. mutual friends they can be friends\\n            if(firstParent == secondParent) {\\n                result[i] = true;\\n                continue;\\n            }\\n            \\n            //iterating through the restrictions array to find whether the parents of first ans second person have a conflict \\n            boolean flag = true;\\n            for(int j = 0; j < resLength; j++) {\\n                //finding parents of the restriction persons\\n                int firstRestriction = findParent(parent, restrictions[j][0]);\\n                int secondRestriction = findParent(parent, restrictions[j][1]);\\n                \\n                //if any of the parents are matching i.e. if the parents of first and second person have a mutual conflict they can\\'t be friend\\n                if((firstRestriction == firstParent && secondRestriction == secondParent) || (secondRestriction == firstParent && firstRestriction == secondParent)) {\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            \\n            if(flag) {\\n                result[i] = true;\\n                parent[firstParent] = secondParent; //setting the common ancestor -> classic union find technique\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    //Classic Union-Find Algorithm to find Common Ancestor\\n    private int findParent(int[] parent, int index) {\\n        if(parent[index] == index) return index;\\n        return findParent(parent, parent[index]);\\n    }\\n   \\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        int resLength = restrictions.length, reqLength = requests.length;\\n        boolean[] result = new boolean[reqLength];\\n        int[] parent = new int[n];\\n        \\n        //Initially ith person\\'s parent is i itself\\n        for(int i = 0; i < n; i++) parent[i] = i;\\n        \\n\\n        for(int i = 0; i < reqLength; i++) {\\n            //finding the parents of the first person and second person of ith request\\n            int firstParent = findParent(parent, requests[i][0]);\\n            int secondParent = findParent(parent, requests[i][1]);\\n            \\n            //if they have same parents i.e. mutual friends they can be friends\\n            if(firstParent == secondParent) {\\n                result[i] = true;\\n                continue;\\n            }\\n            \\n            //iterating through the restrictions array to find whether the parents of first ans second person have a conflict \\n            boolean flag = true;\\n            for(int j = 0; j < resLength; j++) {\\n                //finding parents of the restriction persons\\n                int firstRestriction = findParent(parent, restrictions[j][0]);\\n                int secondRestriction = findParent(parent, restrictions[j][1]);\\n                \\n                //if any of the parents are matching i.e. if the parents of first and second person have a mutual conflict they can\\'t be friend\\n                if((firstRestriction == firstParent && secondRestriction == secondParent) || (secondRestriction == firstParent && firstRestriction == secondParent)) {\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            \\n            if(flag) {\\n                result[i] = true;\\n                parent[firstParent] = secondParent; //setting the common ancestor -> classic union find technique\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1577308,
                "title": "union-find",
                "content": "I thought there is some clever way to track enemies, and wasted a lot of time. Should have looked at constraints closelly - `1000` is not a big number for a `n * m` solution. \\n\\nSo we join frieds using union-find. But before we do, we scan through all `restrictions`, to make sure that sets of friends that we are joining do not include any restricted pair.\\n\\n**C++**\\n```cpp\\nint find(vector<int> &ds, int i) {\\n    return ds[i] < 0 ? i : ds[i] = find(ds, ds[i]);\\n}\\nvector<bool> friendRequests(int n, vector<vector<int>>& enemies, vector<vector<int>>& requests) {\\n    vector<bool> res;\\n    vector<int> ds(n, -1);\\n    for (auto &req : requests) {\\n        int i = find(ds, req[0]), j = find(ds, req[1]);\\n        bool friends = i == j;\\n        if (!friends) {\\n            friends = true;\\n            for (int k = 0; friends && k < enemies.size(); ++k) {\\n                int x = find(ds, enemies[k][0]), y = find(ds, enemies[k][1]);\\n                friends = (x != i || y != j) && (x != j || y != i);\\n            }\\n            if (friends)\\n                ds[j] = i;\\n        }\\n        res.push_back(friends);\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint find(vector<int> &ds, int i) {\\n    return ds[i] < 0 ? i : ds[i] = find(ds, ds[i]);\\n}\\nvector<bool> friendRequests(int n, vector<vector<int>>& enemies, vector<vector<int>>& requests) {\\n    vector<bool> res;\\n    vector<int> ds(n, -1);\\n    for (auto &req : requests) {\\n        int i = find(ds, req[0]), j = find(ds, req[1]);\\n        bool friends = i == j;\\n        if (!friends) {\\n            friends = true;\\n            for (int k = 0; friends && k < enemies.size(); ++k) {\\n                int x = find(ds, enemies[k][0]), y = find(ds, enemies[k][1]);\\n                friends = (x != i || y != j) && (x != j || y != i);\\n            }\\n            if (friends)\\n                ds[j] = i;\\n        }\\n        res.push_back(friends);\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1577236,
                "title": "c-bitset-union-find-50ms",
                "content": "This problem is the perfect one to use bitset. since # is less than 1000.\\nwe have 2 bitset array \\nvector<bitset<1000>> hate;\\nvector<bitset<1000>> g;\\nrepresent a group\\'s member, and a group\\'s members\\'s hate-list(can not be friend with).\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> parent;\\n    vector<bitset<1000>> hate;\\n    vector<bitset<1000>> g;\\n    int findp(int p) {\\n        return (parent[p] == p) ? p : parent[p]=findp(parent[p]);\\n    }\\n    bool tryun(int a, int b) {\\n        int pa = findp(a);\\n        int pb = findp(b);\\n        if (pa == pb) return true;\\n        if ((hate[pa] & g[pb]).any()) return false;\\n        g[pa] |= g[pb];\\n        hate[pa] |= hate[pb];\\n        parent[pb] = pa;\\n        return true;\\n    }\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        parent.resize(n);\\n        hate.resize(n);\\n        g.resize(n);\\n        for (int i = 0; i < n; i++) { parent[i] = i; g[i][i] = 1;} \\n        for (auto& r : restrictions)  { hate[r[0]][r[1]] = 1; hate[r[1]][r[0]] = 1;}\\n        vector<bool> ans;\\n        for (auto& r : requests) ans.push_back(tryun(r[0], r[1]));\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> parent;\\n    vector<bitset<1000>> hate;\\n    vector<bitset<1000>> g;\\n    int findp(int p) {\\n        return (parent[p] == p) ? p : parent[p]=findp(parent[p]);\\n    }\\n    bool tryun(int a, int b) {\\n        int pa = findp(a);\\n        int pb = findp(b);\\n        if (pa == pb) return true;\\n        if ((hate[pa] & g[pb]).any()) return false;\\n        g[pa] |= g[pb];\\n        hate[pa] |= hate[pb];\\n        parent[pb] = pa;\\n        return true;\\n    }\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        parent.resize(n);\\n        hate.resize(n);\\n        g.resize(n);\\n        for (int i = 0; i < n; i++) { parent[i] = i; g[i][i] = 1;} \\n        for (auto& r : restrictions)  { hate[r[0]][r[1]] = 1; hate[r[1]][r[0]] = 1;}\\n        vector<bool> ans;\\n        for (auto& r : requests) ans.push_back(tryun(r[0], r[1]));\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1598078,
                "title": "intuition-explained-straight-forward-dsu-c-clean-code",
                "content": "# Code: \\n\\n```\\n// Standard DSU Class\\nclass DSU {\\n    vector<int> parent, size;\\npublic: \\n    \\n    DSU(int n) {\\n        for(int i=0; i<=n; i++) {\\n            parent.push_back(i);\\n            size.push_back(1);\\n        }\\n    }\\n    \\n    int findParent(int num) {\\n        if(parent[num] == num) return num;\\n        return parent[num] = findParent(parent[num]);\\n    }\\n    \\n\\t// Directly getting parents of u and v\\n\\t// To avoid finding parent multiple times\\n    void unionBySize(int parU, int parV) {\\n        \\n        if(size[parU] < size[parV]) {\\n            size[parV] += size[parU];\\n            parent[parU] = parV;\\n        }\\n        else {\\n            size[parU] += size[parV];\\n            parent[parV] = parU;\\n        }\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        \\n        DSU dsu(n);\\n        \\n        vector<bool> successful;\\n        \\n        for(auto& request : requests) {\\n            \\n            int u = request[0], v = request[1];\\n            \\n            int parU = dsu.findParent(u), parV = dsu.findParent(v);\\n            \\n            bool flag = true;\\n            \\n            if(parU != parV) {\\n                \\n\\t\\t\\t\\t// Check if current friend requested is restricted or not.\\n                for(auto& restriction : restrictions) {\\n                    int restricted_U = restriction[0], restricted_V = restriction[1];\\n                    \\n                    int restricted_parU = dsu.findParent(restricted_U);\\n                    int restricted_parV = dsu.findParent(restricted_V);\\n                    \\n                    if((parU == restricted_parU && parV == restricted_parV) || (parU == restricted_parV && parV == restricted_parU)) {\\n                        flag = false;\\n                        break;\\n                    }\\n                }\\n                \\n\\t\\t\\t\\t// Union u and v by passing parents\\n\\t\\t\\t\\t// Since it is already calculated above\\n                if(flag) {\\n                    dsu.unionBySize(parU, parV);\\n                }\\n            }\\n            \\n            successful.push_back(flag);\\n        }\\n        \\n        return successful;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Union Find"
                ],
                "code": "```\\n// Standard DSU Class\\nclass DSU {\\n    vector<int> parent, size;\\npublic: \\n    \\n    DSU(int n) {\\n        for(int i=0; i<=n; i++) {\\n            parent.push_back(i);\\n            size.push_back(1);\\n        }\\n    }\\n    \\n    int findParent(int num) {\\n        if(parent[num] == num) return num;\\n        return parent[num] = findParent(parent[num]);\\n    }\\n    \\n\\t// Directly getting parents of u and v\\n\\t// To avoid finding parent multiple times\\n    void unionBySize(int parU, int parV) {\\n        \\n        if(size[parU] < size[parV]) {\\n            size[parV] += size[parU];\\n            parent[parU] = parV;\\n        }\\n        else {\\n            size[parU] += size[parV];\\n            parent[parV] = parU;\\n        }\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        \\n        DSU dsu(n);\\n        \\n        vector<bool> successful;\\n        \\n        for(auto& request : requests) {\\n            \\n            int u = request[0], v = request[1];\\n            \\n            int parU = dsu.findParent(u), parV = dsu.findParent(v);\\n            \\n            bool flag = true;\\n            \\n            if(parU != parV) {\\n                \\n\\t\\t\\t\\t// Check if current friend requested is restricted or not.\\n                for(auto& restriction : restrictions) {\\n                    int restricted_U = restriction[0], restricted_V = restriction[1];\\n                    \\n                    int restricted_parU = dsu.findParent(restricted_U);\\n                    int restricted_parV = dsu.findParent(restricted_V);\\n                    \\n                    if((parU == restricted_parU && parV == restricted_parV) || (parU == restricted_parV && parV == restricted_parU)) {\\n                        flag = false;\\n                        break;\\n                    }\\n                }\\n                \\n\\t\\t\\t\\t// Union u and v by passing parents\\n\\t\\t\\t\\t// Since it is already calculated above\\n                if(flag) {\\n                    dsu.unionBySize(parU, parV);\\n                }\\n            }\\n            \\n            successful.push_back(flag);\\n        }\\n        \\n        return successful;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1578485,
                "title": "java-beats-98-with-comments-and-complexity-analysis",
                "content": "time complexity:\\nnumber of persons: n\\nnumber of restrictions: m\\nnumber of requests: k\\n\\ninitialize friends and enemies: O(n + m)\\nCollaping find: O(n)\\nmerge enemies set: O(m)\\n\\nin total: n + m + k * (n + m) = O (k * (n + m))\\n\\n\\nSpace: O(n + m)\\n\\n```\\nclass Solution {\\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        boolean[] res = new boolean[requests.length];\\n        \\n        Set<Integer>[] enemies = new Set[n];\\n        int[] friends = new int[n];\\n        \\n        for (int i = 0; i < n; i++) {\\n            friends[i] = i;\\n            enemies[i] = new HashSet<>();\\n        }\\n        \\n        for (int i = 0; i < restrictions.length; i++) {\\n            //add person A to person B\\'s enmey circle.\\n            //add person B to person A\\'s enemy circle.\\n            enemies[restrictions[i][0]].add(restrictions[i][1]);\\n            enemies[restrictions[i][1]].add(restrictions[i][0]);\\n        }\\n        \\n        for (int i = 0; i < requests.length; i++) {\\n            int personA = findRootFriend(friends, requests[i][0]);\\n            int personB = findRootFriend(friends, requests[i][1]);\\n            Set<Integer> personAEnemies = enemies[personA];\\n            Set<Integer> personBEnemies = enemies[personB]; \\n            \\n            if (personA == personB) {\\n                res[i] = true;\\n            } else if (!personAEnemies.contains(personB) && !personBEnemies.contains(personA)) {\\n                //can merge. update personB\\'s root to be person A\\n                friends[personB] = personA;\\n                \\n                // add all B\\'s enemies to A\\'s enemyies\\n                personAEnemies.addAll(personBEnemies);\\n                \\n                // inform all B\\'s enemies that A is a new enemy\\n                for (int k : personBEnemies) {\\n                    enemies[k].add(personA);\\n                }\\n                \\n                res[i] = true;\\n            } else {\\n                res[i] = false;\\n            }\\n        } \\n        \\n        return res;\\n    }\\n    \\n    private int findRootFriend(int[] friends, int i) {\\n        if (friends[i] == i) {\\n            return i;\\n        }\\n        \\n        return findRootFriend(friends, friends[i]);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        boolean[] res = new boolean[requests.length];\\n        \\n        Set<Integer>[] enemies = new Set[n];\\n        int[] friends = new int[n];\\n        \\n        for (int i = 0; i < n; i++) {\\n            friends[i] = i;\\n            enemies[i] = new HashSet<>();\\n        }\\n        \\n        for (int i = 0; i < restrictions.length; i++) {\\n            //add person A to person B\\'s enmey circle.\\n            //add person B to person A\\'s enemy circle.\\n            enemies[restrictions[i][0]].add(restrictions[i][1]);\\n            enemies[restrictions[i][1]].add(restrictions[i][0]);\\n        }\\n        \\n        for (int i = 0; i < requests.length; i++) {\\n            int personA = findRootFriend(friends, requests[i][0]);\\n            int personB = findRootFriend(friends, requests[i][1]);\\n            Set<Integer> personAEnemies = enemies[personA];\\n            Set<Integer> personBEnemies = enemies[personB]; \\n            \\n            if (personA == personB) {\\n                res[i] = true;\\n            } else if (!personAEnemies.contains(personB) && !personBEnemies.contains(personA)) {\\n                //can merge. update personB\\'s root to be person A\\n                friends[personB] = personA;\\n                \\n                // add all B\\'s enemies to A\\'s enemyies\\n                personAEnemies.addAll(personBEnemies);\\n                \\n                // inform all B\\'s enemies that A is a new enemy\\n                for (int k : personBEnemies) {\\n                    enemies[k].add(personA);\\n                }\\n                \\n                res[i] = true;\\n            } else {\\n                res[i] = false;\\n            }\\n        } \\n        \\n        return res;\\n    }\\n    \\n    private int findRootFriend(int[] friends, int i) {\\n        if (friends[i] == i) {\\n            return i;\\n        }\\n        \\n        return findRootFriend(friends, friends[i]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1576960,
                "title": "java-union-find",
                "content": "```\\nclass Solution {\\n    public boolean[] friendRequests(int n, int[][] re, int[][] requests) {\\n        UnionFind uf = new UnionFind();\\n        boolean[] res = new boolean[requests.length];\\n        Arrays.fill(res,true);\\n        for(int i = 0; i < requests.length; i++){\\n            int[] r =requests[i];\\n            int a = r[0], b = r[1];\\n            int a1 = uf.find(a), b1 = uf.find(b);\\n            for(int[] t: re){\\n                int t1 = uf.find(t[0]), t2 = uf.find(t[1]);\\n                if(t1 == a1 && b1 == t2 || a1 == t2 && b1 == t1){\\n                    res[i] = false;\\n                    break;\\n                }\\n            }\\n            if(res[i]) uf.union(a,b);\\n        }\\n        return res;\\n    }\\n    \\n}\\n\\nclass UnionFind{\\n    Map<Integer, Integer> map = new HashMap<>();\\n    int find(int n){\\n        map.putIfAbsent(n,n);\\n        while(n != map.get(n)){\\n            map.put(n, map.get(map.get(n)));\\n            n = map.get(n);\\n        }\\n        return n;\\n    }\\n    void union(int a, int b){\\n        map.put(find(a), find(b));\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean[] friendRequests(int n, int[][] re, int[][] requests) {\\n        UnionFind uf = new UnionFind();\\n        boolean[] res = new boolean[requests.length];\\n        Arrays.fill(res,true);\\n        for(int i = 0; i < requests.length; i++){\\n            int[] r =requests[i];\\n            int a = r[0], b = r[1];\\n            int a1 = uf.find(a), b1 = uf.find(b);\\n            for(int[] t: re){\\n                int t1 = uf.find(t[0]), t2 = uf.find(t[1]);\\n                if(t1 == a1 && b1 == t2 || a1 == t2 && b1 == t1){\\n                    res[i] = false;\\n                    break;\\n                }\\n            }\\n            if(res[i]) uf.union(a,b);\\n        }\\n        return res;\\n    }\\n    \\n}\\n\\nclass UnionFind{\\n    Map<Integer, Integer> map = new HashMap<>();\\n    int find(int n){\\n        map.putIfAbsent(n,n);\\n        while(n != map.get(n)){\\n            map.put(n, map.get(map.get(n)));\\n            n = map.get(n);\\n        }\\n        return n;\\n    }\\n    void union(int a, int b){\\n        map.put(find(a), find(b));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2458609,
                "title": "c-simple-c-code-90-time-union-find",
                "content": "\\n# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\nclass Solution {\\n    vector<int> parents;\\n    int find_set(int v)\\n    {\\n        if(v == parents[v])\\n            return v;\\n        return parents[v] = find_set(parents[v]);\\n    }\\n    void union_set(int a, int b)\\n    {\\n        a = find_set(a);\\n        b = find_set(b);\\n        if(a == b)\\n            return;\\n        if(a != b)\\n            parents[b] = a;\\n        return;\\n    }\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        for(int i = 0; i < n; i++)\\n            parents.push_back(i);\\n        vector<bool> ans;\\n        for(vector<int> &req : requests)\\n        {\\n            int v = 1;\\n            int a = find_set(req[0]);\\n            int b = find_set(req[1]);\\n            for(vector<int> &res : restrictions)\\n            {\\n                int r1 = find_set(res[0]);\\n                int r2 = find_set(res[1]);\\n                if((a == r1 && b == r2) || (b == r1 && a == r2))\\n                {\\n                    v = 0;\\n                    break;\\n                }\\n            }\\n            ans.push_back(v);\\n            if(v)\\n            {\\n                union_set(a,b);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    vector<int> parents;\\n    int find_set(int v)\\n    {\\n        if(v == parents[v])\\n            return v;\\n        return parents[v] = find_set(parents[v]);\\n    }\\n    void union_set(int a, int b)\\n    {\\n        a = find_set(a);\\n        b = find_set(b);\\n        if(a == b)\\n            return;\\n        if(a != b)\\n            parents[b] = a;\\n        return;\\n    }\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        for(int i = 0; i < n; i++)\\n            parents.push_back(i);\\n        vector<bool> ans;\\n        for(vector<int> &req : requests)\\n        {\\n            int v = 1;\\n            int a = find_set(req[0]);\\n            int b = find_set(req[1]);\\n            for(vector<int> &res : restrictions)\\n            {\\n                int r1 = find_set(res[0]);\\n                int r2 = find_set(res[1]);\\n                if((a == r1 && b == r2) || (b == r1 && a == r2))\\n                {\\n                    v = 0;\\n                    break;\\n                }\\n            }\\n            ans.push_back(v);\\n            if(v)\\n            {\\n                union_set(a,b);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1620457,
                "title": "python-union-find-beats-98-runtime-and-34-space",
                "content": "I think it is easy for everyone to see this problem requires union find. \\nThe key point is about how to detect if the friend request is restricted or not. \\nWe can of course iterate through all restricted ones and check, but that will be too expensive. \\nHere I have maintained a map called `excluded`, which is `{people => { set of restricted peoples } }`.\\nThis map is updated whenever a successful union happens.\\nWe use `DisjointSet` to keep the information of friend circles, like everyone would do.\\n\\nSo the algorithm has only 3 conditions for people1 trying to make friend with people2:\\n1. people1 and people2 are already in the same group (directly or indirectly), that is just fine. `res = True`\\n2. people2 is in people1\\'s excluding list, then they cannot be friends. `res = False`\\n3. people1 and people2 are not in the same friend circle, and they are not mutually excluded, then we just merge their friend circles. The merge happens by updating the excluded map (more details in the next paragraph) and DisjointSet. `res = True`\\n\\nThe excluded map update is straight forward, it does 2 things to update:\\n1. Merge names from people2\\'s list to people1\\'s list. Because people1 and people2 are in the same group now, and the excluded people should be merged.\\n2. For every people excluded by people2, they also exclude people2, and we need them to exclude people1 as well\\n\\nHere is the code:\\n```python\\nclass DisjointSet:\\n    def __init__(self, n):\\n        self.parent = list(range(n))\\n    def find(self, x):\\n        if self.parent[x] != x:\\n            self.parent[x] = self.find(self.parent[x])\\n        return self.parent[x]\\n\\nclass Solution:\\n    def friendRequests(self, n: int, restrictions: List[List[int]], requests: List[List[int]]) -> List[bool]:\\n        from collections import defaultdict\\n        excluded = defaultdict(set)\\n        for people1, people2 in restrictions: # exclusion is mutual\\n            excluded[people1].add(people2) \\n            excluded[people2].add(people1)\\n\\t\\t\\t\\n        def update_exclusion(from_p, to_p): # update exclusion map\\n            targets = excluded.pop(from_p, [])\\n            for people in targets: # people being excluded by people2 should now also exclude people1\\n                excluded[people].remove(from_p)\\n                excluded[people].add(to_p)\\n            excluded[to_p].update(targets) # people1 should exclude people that are excluded by people2\\n\\t\\t\\t\\n        res = []\\n        disjoint_set = DisjointSet(n)\\n        for people1, people2 in requests:\\n            circle1 = disjoint_set.find(people1)\\n            circle2 = disjoint_set.find(people2)\\n            if circle1 == circle2: \\n                res.append(True)\\n            elif circle2 in excluded[circle1]:\\n                res.append(False)\\n            else:\\n                update_exclusion(circle2, circle1)\\n                disjoint_set.parent[circle2] = circle1\\n                res.append(True)\\n        return res\\n                \\n```",
                "solutionTags": [
                    "Union Find"
                ],
                "code": "```python\\nclass DisjointSet:\\n    def __init__(self, n):\\n        self.parent = list(range(n))\\n    def find(self, x):\\n        if self.parent[x] != x:\\n            self.parent[x] = self.find(self.parent[x])\\n        return self.parent[x]\\n\\nclass Solution:\\n    def friendRequests(self, n: int, restrictions: List[List[int]], requests: List[List[int]]) -> List[bool]:\\n        from collections import defaultdict\\n        excluded = defaultdict(set)\\n        for people1, people2 in restrictions: # exclusion is mutual\\n            excluded[people1].add(people2) \\n            excluded[people2].add(people1)\\n\\t\\t\\t\\n        def update_exclusion(from_p, to_p): # update exclusion map\\n            targets = excluded.pop(from_p, [])\\n            for people in targets: # people being excluded by people2 should now also exclude people1\\n                excluded[people].remove(from_p)\\n                excluded[people].add(to_p)\\n            excluded[to_p].update(targets) # people1 should exclude people that are excluded by people2\\n\\t\\t\\t\\n        res = []\\n        disjoint_set = DisjointSet(n)\\n        for people1, people2 in requests:\\n            circle1 = disjoint_set.find(people1)\\n            circle2 = disjoint_set.find(people2)\\n            if circle1 == circle2: \\n                res.append(True)\\n            elif circle2 in excluded[circle1]:\\n                res.append(False)\\n            else:\\n                update_exclusion(circle2, circle1)\\n                disjoint_set.parent[circle2] = circle1\\n                res.append(True)\\n        return res\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1582784,
                "title": "python-unionfind-easy-to-understand-with-explanation",
                "content": "```\\nclass UnionFindSet(object):\\n    def __init__(self, n):\\n        self.data = range(n)\\n\\n    def find(self, x):\\n        while x <> self.data[x]:\\n            x = self.data[x]\\n        return x\\n\\n    def union(self, x, y):\\n        self.data[self.find(x)] = self.find(y)\\n\\n    def speedup(self):\\n        for i in range(len(self.data)):\\n            self.data[i] = self.find(i)\\n\\n\\nclass Solution(object):\\n    def friendRequests(self, n, restrictions, requests):\\n        uf = UnionFindSet(n)\\n        ret = [True] * len(requests)\\n        for k, [x, y] in enumerate(requests):  # Process Requests Sequentially\\n            xh = uf.find(x)  # backup the head of x for undo\\n            uf.union(x, y)  # link [x, y] and verify if any restriction triggers\\n            for [i, j] in restrictions:\\n                if uf.find(i) == uf.find(j):\\n                    ret[k] = False\\n                    break\\n            if not ret[k]:  # if any restriction triggers, undo\\n                uf.data[xh] = xh\\n            else:\\n                uf.speedup()\\n        return ret\\n```\\n**If you have any questoins, feel free to ask. If you like the solution and explanation, please upvote!**",
                "solutionTags": [
                    "Python",
                    "Union Find"
                ],
                "code": "```\\nclass UnionFindSet(object):\\n    def __init__(self, n):\\n        self.data = range(n)\\n\\n    def find(self, x):\\n        while x <> self.data[x]:\\n            x = self.data[x]\\n        return x\\n\\n    def union(self, x, y):\\n        self.data[self.find(x)] = self.find(y)\\n\\n    def speedup(self):\\n        for i in range(len(self.data)):\\n            self.data[i] = self.find(i)\\n\\n\\nclass Solution(object):\\n    def friendRequests(self, n, restrictions, requests):\\n        uf = UnionFindSet(n)\\n        ret = [True] * len(requests)\\n        for k, [x, y] in enumerate(requests):  # Process Requests Sequentially\\n            xh = uf.find(x)  # backup the head of x for undo\\n            uf.union(x, y)  # link [x, y] and verify if any restriction triggers\\n            for [i, j] in restrictions:\\n                if uf.find(i) == uf.find(j):\\n                    ret[k] = False\\n                    break\\n            if not ret[k]:  # if any restriction triggers, undo\\n                uf.data[xh] = xh\\n            else:\\n                uf.speedup()\\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1580219,
                "title": "c-dsu-2-approaches",
                "content": "# **Approach 1**\\n```\\nclass DSU {\\nprivate: \\n\\tvector<int> parent, size, rank; \\n \\n\\tpublic:\\n    DSU(int n) {\\n\\t\\tfor(int i=0; i<n; i++) {\\n\\t\\t\\tparent.push_back(i); \\n\\t\\t\\tsize.push_back(1); \\n\\t\\t\\trank.push_back(0); \\n\\t\\t}\\n\\t}\\n \\n \\npublic: \\n\\tint findPar(int node) {\\n\\t\\tif(parent[node] == node) {\\n\\t\\t\\treturn node; \\n\\t\\t}\\n\\t\\treturn parent[node] = findPar(parent[node]); \\n\\t}\\n \\npublic:\\n\\tvoid unionSize(int u, int v) {\\n\\t\\tint pu = findPar(u); \\n\\t\\tint pv = findPar(v); \\n\\t\\tif(pu == pv) {\\n\\t\\t\\treturn; \\n\\t\\t}\\n\\t\\tif(size[pu] < size[pv]) {\\n\\t\\t\\tparent[pu] = pv; \\n\\t\\t\\tsize[pv] += size[pu]; \\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tparent[pv] = pu; \\n\\t\\t\\tsize[pu] += size[pv]; \\n\\t\\t}\\n\\t}\\npublic:\\n\\tvoid unionRank(int u, int v) {\\n\\t\\tint pu = findPar(u); \\n\\t\\tint pv = findPar(v); \\n\\t\\tif(pu == pv) {\\n\\t\\t\\treturn; \\n\\t\\t}\\n\\t\\tif(rank[pu] < rank[pv]) {\\n\\t\\t\\tparent[pu] = pv; \\n\\t\\t}\\n\\t\\telse if(rank[pv] < rank[pu]){\\n\\t\\t\\tparent[pv] = pu; \\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tparent[pu] = pv;\\n\\t\\t\\trank[pv]++; \\n\\t\\t}\\n\\t}\\n};\\n\\nclass Solution {\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        DSU dsu(n);\\n        vector<bool> ans;\\n        \\n        for(auto it: requests){\\n            int x = it[0];\\n            int y = it[1];\\n            \\n            DSU temp = dsu;\\n            \\n            temp.unionRank(x, y);\\n            \\n            bool flag = true;\\n            for(auto itr: restrictions){\\n                int x1 = itr[0];\\n                int y1 = itr[1];\\n                \\n                if(temp.findPar(x1)==temp.findPar(y1)){\\n                    flag=false; \\n                    break;\\n                }\\n            }\\n            \\n            if(flag==true){\\n                ans.push_back(true);\\n                dsu.unionRank(x, y);\\n            }\\n            else{\\n                ans.push_back(false);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n# **Approach 2**\\n**(with better space complexity)**\\n\\n```\\nclass DSU {\\nprivate: \\n\\tvector<int> parent, size, rank; \\n \\n\\tpublic:\\n    DSU(int n) {\\n\\t\\tfor(int i=0; i<n; i++) {\\n\\t\\t\\tparent.push_back(i); \\n\\t\\t\\tsize.push_back(1); \\n\\t\\t\\trank.push_back(0); \\n\\t\\t}\\n\\t}\\n \\n \\npublic: \\n\\tint findPar(int node) {\\n\\t\\tif(parent[node] == node) {\\n\\t\\t\\treturn node; \\n\\t\\t}\\n\\t\\treturn parent[node] = findPar(parent[node]); \\n\\t}\\n \\npublic:\\n\\tvoid unionSize(int u, int v) {\\n\\t\\tint pu = findPar(u); \\n\\t\\tint pv = findPar(v); \\n\\t\\tif(pu == pv) {\\n\\t\\t\\treturn; \\n\\t\\t}\\n\\t\\tif(size[pu] < size[pv]) {\\n\\t\\t\\tparent[pu] = pv; \\n\\t\\t\\tsize[pv] += size[pu]; \\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tparent[pv] = pu; \\n\\t\\t\\tsize[pu] += size[pv]; \\n\\t\\t}\\n\\t}\\npublic:\\n\\tvoid unionRank(int u, int v) {\\n\\t\\tint pu = findPar(u); \\n\\t\\tint pv = findPar(v); \\n\\t\\tif(pu == pv) {\\n\\t\\t\\treturn; \\n\\t\\t}\\n\\t\\tif(rank[pu] < rank[pv]) {\\n\\t\\t\\tparent[pu] = pv; \\n\\t\\t}\\n\\t\\telse if(rank[pv] < rank[pu]){\\n\\t\\t\\tparent[pv] = pu; \\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tparent[pu] = pv;\\n\\t\\t\\trank[pv]++; \\n\\t\\t}\\n\\t}\\n};\\n\\nclass Solution {\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        DSU dsu(n);\\n        vector<bool> ans;\\n        \\n        for(auto &it: requests){\\n            int x = it[0];\\n            int y = it[1];\\n            int px = dsu.findPar(x);\\n            int py = dsu.findPar(y);\\n            \\n            bool flag=true;\\n            if(px!=py){\\n                for(auto &itr: restrictions){\\n                    int pu = dsu.findPar(itr[0]);\\n                    int pv = dsu.findPar(itr[1]);\\n                    \\n                    if((pu==px && pv==py) || pu==py && pv==px){\\n                        flag=false;\\n                        break;\\n                    }\\n                }\\n            }\\n            if(flag==false){\\n                ans.push_back(false);\\n            }\\n            else{\\n                ans.push_back(true);\\n                dsu.unionRank(x, y);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass DSU {\\nprivate: \\n\\tvector<int> parent, size, rank; \\n \\n\\tpublic:\\n    DSU(int n) {\\n\\t\\tfor(int i=0; i<n; i++) {\\n\\t\\t\\tparent.push_back(i); \\n\\t\\t\\tsize.push_back(1); \\n\\t\\t\\trank.push_back(0); \\n\\t\\t}\\n\\t}\\n \\n \\npublic: \\n\\tint findPar(int node) {\\n\\t\\tif(parent[node] == node) {\\n\\t\\t\\treturn node; \\n\\t\\t}\\n\\t\\treturn parent[node] = findPar(parent[node]); \\n\\t}\\n \\npublic:\\n\\tvoid unionSize(int u, int v) {\\n\\t\\tint pu = findPar(u); \\n\\t\\tint pv = findPar(v); \\n\\t\\tif(pu == pv) {\\n\\t\\t\\treturn; \\n\\t\\t}\\n\\t\\tif(size[pu] < size[pv]) {\\n\\t\\t\\tparent[pu] = pv; \\n\\t\\t\\tsize[pv] += size[pu]; \\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tparent[pv] = pu; \\n\\t\\t\\tsize[pu] += size[pv]; \\n\\t\\t}\\n\\t}\\npublic:\\n\\tvoid unionRank(int u, int v) {\\n\\t\\tint pu = findPar(u); \\n\\t\\tint pv = findPar(v); \\n\\t\\tif(pu == pv) {\\n\\t\\t\\treturn; \\n\\t\\t}\\n\\t\\tif(rank[pu] < rank[pv]) {\\n\\t\\t\\tparent[pu] = pv; \\n\\t\\t}\\n\\t\\telse if(rank[pv] < rank[pu]){\\n\\t\\t\\tparent[pv] = pu; \\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tparent[pu] = pv;\\n\\t\\t\\trank[pv]++; \\n\\t\\t}\\n\\t}\\n};\\n\\nclass Solution {\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        DSU dsu(n);\\n        vector<bool> ans;\\n        \\n        for(auto it: requests){\\n            int x = it[0];\\n            int y = it[1];\\n            \\n            DSU temp = dsu;\\n            \\n            temp.unionRank(x, y);\\n            \\n            bool flag = true;\\n            for(auto itr: restrictions){\\n                int x1 = itr[0];\\n                int y1 = itr[1];\\n                \\n                if(temp.findPar(x1)==temp.findPar(y1)){\\n                    flag=false; \\n                    break;\\n                }\\n            }\\n            \\n            if(flag==true){\\n                ans.push_back(true);\\n                dsu.unionRank(x, y);\\n            }\\n            else{\\n                ans.push_back(false);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass DSU {\\nprivate: \\n\\tvector<int> parent, size, rank; \\n \\n\\tpublic:\\n    DSU(int n) {\\n\\t\\tfor(int i=0; i<n; i++) {\\n\\t\\t\\tparent.push_back(i); \\n\\t\\t\\tsize.push_back(1); \\n\\t\\t\\trank.push_back(0); \\n\\t\\t}\\n\\t}\\n \\n \\npublic: \\n\\tint findPar(int node) {\\n\\t\\tif(parent[node] == node) {\\n\\t\\t\\treturn node; \\n\\t\\t}\\n\\t\\treturn parent[node] = findPar(parent[node]); \\n\\t}\\n \\npublic:\\n\\tvoid unionSize(int u, int v) {\\n\\t\\tint pu = findPar(u); \\n\\t\\tint pv = findPar(v); \\n\\t\\tif(pu == pv) {\\n\\t\\t\\treturn; \\n\\t\\t}\\n\\t\\tif(size[pu] < size[pv]) {\\n\\t\\t\\tparent[pu] = pv; \\n\\t\\t\\tsize[pv] += size[pu]; \\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tparent[pv] = pu; \\n\\t\\t\\tsize[pu] += size[pv]; \\n\\t\\t}\\n\\t}\\npublic:\\n\\tvoid unionRank(int u, int v) {\\n\\t\\tint pu = findPar(u); \\n\\t\\tint pv = findPar(v); \\n\\t\\tif(pu == pv) {\\n\\t\\t\\treturn; \\n\\t\\t}\\n\\t\\tif(rank[pu] < rank[pv]) {\\n\\t\\t\\tparent[pu] = pv; \\n\\t\\t}\\n\\t\\telse if(rank[pv] < rank[pu]){\\n\\t\\t\\tparent[pv] = pu; \\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tparent[pu] = pv;\\n\\t\\t\\trank[pv]++; \\n\\t\\t}\\n\\t}\\n};\\n\\nclass Solution {\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        DSU dsu(n);\\n        vector<bool> ans;\\n        \\n        for(auto &it: requests){\\n            int x = it[0];\\n            int y = it[1];\\n            int px = dsu.findPar(x);\\n            int py = dsu.findPar(y);\\n            \\n            bool flag=true;\\n            if(px!=py){\\n                for(auto &itr: restrictions){\\n                    int pu = dsu.findPar(itr[0]);\\n                    int pv = dsu.findPar(itr[1]);\\n                    \\n                    if((pu==px && pv==py) || pu==py && pv==px){\\n                        flag=false;\\n                        break;\\n                    }\\n                }\\n            }\\n            if(flag==false){\\n                ans.push_back(false);\\n            }\\n            else{\\n                ans.push_back(true);\\n                dsu.unionRank(x, y);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1576909,
                "title": "c-make-friends",
                "content": "**Hint/Thought Process**\\n- If x is a friend of y, and y is a friend of z, then x will be a friend of z. So, we can say, friends will form a connected component.\\n\\t- => Hint for using disjoint set union.\\n\\n**Algorithm**\\n- We process requests sequentially.\\n\\t- Let\\'s say we are processing request[ i ] = [u,v]\\n\\t\\n\\t- Then, from previous requests, we know u & v will be part of some components.\\n\\t- Let say u\\'s component contains: [u1,u2,u3,..., ux] and v\\'s component contains: [v1,v2,v3,...,vy]\\n\\t\\t- Now, after processing the current request, every pair (u_i, v_j) will be friends, for all i<=x and j<=y\\n\\t\\t- Thus, if any of such pairs is restricted, i.e. (u_i, v_j) can\\'t be friends \\n\\t\\t\\t- => We can\\'t process the current request i.\\n\\t- Hence, we iterate over the Restrictions array for every request and check if any of the restriction is violated.\\n\\t\\t- If no restriction is violated, we can process the current request.\\n\\t\\t- Otherwise, we can\\'t process the current request.\\n\\n\\n**Time Complexity**\\n- Let N = requests.size(), M = restrictions.size(), n = # people\\n- O(N*M)\\n\\n**Code**\\n```\\nint find(vector<int> &ds, int i) {\\n    return ds[i] < 0 ? i : ds[i] = find(ds, ds[i]);\\n}\\n\\nbool Union(vector<int> &ds, int i, int j){\\n\\t i = find(ds, i), j = find(ds, j);\\n\\t if(i==j) return false;\\n\\t if(abs(ds[i]) < abs(ds[j])) swap(i,j); \\n\\t ds[i]+=ds[j]; \\n\\t ds[j]=i;\\n\\t return true;\\n}\\n\\nclass Solution {\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        vector<bool> res;\\n        vector<int> ds(n, -1);\\n        for(auto &r : requests){\\n            int u = find(ds,r[0]), v = find(ds,r[1]), can = 1;\\n\\t\\t\\t\\n            for(auto &rt : restrictions){\\n                int u1 = find(ds,rt[0]), v1 = find(ds, rt[1]);\\n                if((u1==u && v1 == v) || (u1==v && v1==u)){ \\n                    //restricted pair will be connected!! => Do not process the request\\n                    can = 0;\\n                    break;\\n                }\\n            }\\n            if(can) Union(ds,u,v);\\n            res.push_back(can);   \\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nint find(vector<int> &ds, int i) {\\n    return ds[i] < 0 ? i : ds[i] = find(ds, ds[i]);\\n}\\n\\nbool Union(vector<int> &ds, int i, int j){\\n\\t i = find(ds, i), j = find(ds, j);\\n\\t if(i==j) return false;\\n\\t if(abs(ds[i]) < abs(ds[j])) swap(i,j); \\n\\t ds[i]+=ds[j]; \\n\\t ds[j]=i;\\n\\t return true;\\n}\\n\\nclass Solution {\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        vector<bool> res;\\n        vector<int> ds(n, -1);\\n        for(auto &r : requests){\\n            int u = find(ds,r[0]), v = find(ds,r[1]), can = 1;\\n\\t\\t\\t\\n            for(auto &rt : restrictions){\\n                int u1 = find(ds,rt[0]), v1 = find(ds, rt[1]);\\n                if((u1==u && v1 == v) || (u1==v && v1==u)){ \\n                    //restricted pair will be connected!! => Do not process the request\\n                    can = 0;\\n                    break;\\n                }\\n            }\\n            if(can) Union(ds,u,v);\\n            res.push_back(can);   \\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3852910,
                "title": "easy-to-follow-java-code-12-ms-time-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe runtime of the code is O(n * m). where n is the number of restrictions (restrictions.length) and m is the number of queries (requests.length).\\n\\nThe first loop in the DisjoinSet class takes O(n) time to initialize the parent and rank arrays. The second loop takes O(n) time to add each restriction to the appropriate set. The notRestricted() method takes O(1) time to check if two roots are restricted from being in the same set.\\n\\nThe union() method takes O(1) time to find the roots of the two nodes being unioned. If the two roots are not restricted from being in the same set, then the union() method takes O(1) time to union the two sets. If the two roots are restricted from being in the same set, then the union() method takes O(n) time to update the restrictions of the two sets.\\n\\nThe friendRequests() method takes O(m) time to iterate through the queries and call the union() method for each query.\\n\\nTherefore, the overall runtime of the code is O(n * m).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n//Idea and code from \\n// https://leetcode.com/problems/process-restricted-friend-requests/solutions/3814592/union-find-disjoint-sets-solution-faster-than-90-java/\\n\\nclass DisjoinSet {\\n    private final int [] parent;\\n    private final int [] rank;\\n    private final List<Set<Integer>> restrictions;\\n\\n    DisjoinSet(int size, int[][] restrictions){\\n        this.parent = new int [size];\\n        this.rank = new int [size];     \\n        this.restrictions = new ArrayList<>(size);\\n\\n        for(int i =0; i <size; i++) {\\n            this.parent[i] = i;\\n            this.rank[i] = 1;\\n            this.restrictions.add(new HashSet<>());\\n        }\\n\\n        for (int [] restriction: restrictions){\\n            this.restrictions.get(restriction[0]).add(restriction[1]);\\n            this.restrictions.get(restriction[1]).add(restriction[0]);\\n        }\\n    }\\n\\n    private int find(int node){\\n        int root=node;\\n        while(parent[root]!=root){\\n            root=parent[root];\\n        }\\n\\n        while (parent[node]!=root){\\n            int next = parent[node];\\n            parent[node]=root;\\n            node = next;\\n        }\\n        return root;\\n    }\\n\\n    public boolean union (int n1, int n2){\\n        int p1 = find(n1);\\n        int p2 = find(n2);\\n\\n        if (p1==p2){\\n            return true;\\n        }\\n            \\n        if (notRestricted(p1,p2)){\\n            if (rank[p1]>rank[p2]){\\n                rank[p1]+=rank[p2];\\n                parent[p2]=p1;\\n                // Combine the restrictions list\\n                //Add all parent Nodes from other list \\n                for (int node: restrictions.get(p2)){\\n                    restrictions.get(p1).add(find(node) );\\n                }\\n            } else{\\n                rank[p2]+=rank[p1];\\n                parent[p1]= p2;\\n                // Combine the restrictions list\\n                //Add all parent Nodes from other list \\n                for (int node: restrictions.get(p1)){\\n                    restrictions.get(p2).add(find(node) );\\n                }\\n            }\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n        private boolean notRestricted(int root1, int root2) {\\n            if (restrictions.get(root1).contains(root2))\\n                return false;\\n            if (restrictions.get(root2).contains(root1))\\n                return false;\\n        return true;\\n    }\\n}\\n\\nclass Solution {\\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        if (restrictions.length==0){\\n            boolean [] queries = new boolean [requests.length];\\n            Arrays.fill(queries,true);\\n            return queries;\\n        }\\n         DisjoinSet set = new DisjoinSet(n,restrictions);\\n         boolean [] queries = new boolean [requests.length];\\n         for (int i =0; i<requests.length ;i++){\\n            queries[i] = set.union(requests[i][0],requests[i][1] );\\n         }\\n        return queries;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n//Idea and code from \\n// https://leetcode.com/problems/process-restricted-friend-requests/solutions/3814592/union-find-disjoint-sets-solution-faster-than-90-java/\\n\\nclass DisjoinSet {\\n    private final int [] parent;\\n    private final int [] rank;\\n    private final List<Set<Integer>> restrictions;\\n\\n    DisjoinSet(int size, int[][] restrictions){\\n        this.parent = new int [size];\\n        this.rank = new int [size];     \\n        this.restrictions = new ArrayList<>(size);\\n\\n        for(int i =0; i <size; i++) {\\n            this.parent[i] = i;\\n            this.rank[i] = 1;\\n            this.restrictions.add(new HashSet<>());\\n        }\\n\\n        for (int [] restriction: restrictions){\\n            this.restrictions.get(restriction[0]).add(restriction[1]);\\n            this.restrictions.get(restriction[1]).add(restriction[0]);\\n        }\\n    }\\n\\n    private int find(int node){\\n        int root=node;\\n        while(parent[root]!=root){\\n            root=parent[root];\\n        }\\n\\n        while (parent[node]!=root){\\n            int next = parent[node];\\n            parent[node]=root;\\n            node = next;\\n        }\\n        return root;\\n    }\\n\\n    public boolean union (int n1, int n2){\\n        int p1 = find(n1);\\n        int p2 = find(n2);\\n\\n        if (p1==p2){\\n            return true;\\n        }\\n            \\n        if (notRestricted(p1,p2)){\\n            if (rank[p1]>rank[p2]){\\n                rank[p1]+=rank[p2];\\n                parent[p2]=p1;\\n                // Combine the restrictions list\\n                //Add all parent Nodes from other list \\n                for (int node: restrictions.get(p2)){\\n                    restrictions.get(p1).add(find(node) );\\n                }\\n            } else{\\n                rank[p2]+=rank[p1];\\n                parent[p1]= p2;\\n                // Combine the restrictions list\\n                //Add all parent Nodes from other list \\n                for (int node: restrictions.get(p1)){\\n                    restrictions.get(p2).add(find(node) );\\n                }\\n            }\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n        private boolean notRestricted(int root1, int root2) {\\n            if (restrictions.get(root1).contains(root2))\\n                return false;\\n            if (restrictions.get(root2).contains(root1))\\n                return false;\\n        return true;\\n    }\\n}\\n\\nclass Solution {\\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        if (restrictions.length==0){\\n            boolean [] queries = new boolean [requests.length];\\n            Arrays.fill(queries,true);\\n            return queries;\\n        }\\n         DisjoinSet set = new DisjoinSet(n,restrictions);\\n         boolean [] queries = new boolean [requests.length];\\n         for (int i =0; i<requests.length ;i++){\\n            queries[i] = set.union(requests[i][0],requests[i][1] );\\n         }\\n        return queries;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2489402,
                "title": "java-solution-union-find-disjoint-sets-without-rank",
                "content": "```\\nclass Solution {\\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        int[] arr=new int[n];\\n        for(int i=0;i<n;i++){\\n            arr[i]=i;\\n        }\\n        int j=0;\\n        boolean[] ret=new boolean[requests.length];\\n        for(int[] a:requests){\\n            int x=find(a[0],arr);\\n            int y=find(a[1],arr);\\n            boolean flag=true;\\n            for(int i=0;i<restrictions.length;i++){\\n                int l=find(restrictions[i][0],arr);\\n                int r=find(restrictions[i][1],arr);\\n                if(((l==x && r==y) || (l==y && r==x))){\\n                    flag=false;\\n                    break;\\n                }\\n            }\\n            ret[j++]=flag;\\n            if(flag){\\n                union(x,y,arr);\\n            }\\n        }\\n        return ret;\\n    }\\n    private void union(int a,int b,int[] arr){\\n        int x=find(a,arr);\\n        int y=find(b,arr);\\n        if(x==y) return;\\n        arr[y]=x;\\n    }\\n    private int find(int x,int[] arr){\\n        if(arr[x]==x) return x;\\n        return find(arr[x],arr);\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "class Solution {\\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        int[] arr=new int[n];\\n        for(int i=0;i<n;i++){\\n            arr[i]=i;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1941231,
                "title": "javascript-union-find",
                "content": "This solution uses a boilerplate for DSU that can be reused for other problems. Approach is based on other solutions posted on the discussion section. Please let me know if you have improvements or comments on time complexity.\\n\\n**Friend request function:**\\n\\t1. Add nodes 0 to n - 1 to DSU instance\\n\\t2. For each friend request [f1, f2], check each restriction pair [e1, e2]. \\n\\t3. Perform find on each of the four persons (f1, f2, e1, e2). \\n\\t4. If unionFind(f1) = unionFind(e1) and unionFind(f2) = unionFind(e2) OR viceversa, request is not valid.\\n\\n**Time complexity** \\nI believe is O(N + MK). Step 1 takes O(N) where N is number of friends. Steps 2 - 4 take O(MK) where M are number of requests and K are number of restrictions.\\nDSU finds and unions take an amortized time of O(1) because we are using path compression and union by rank.\\n\\n\\n```\\n/*\\nDSU Class Template\\n*/\\nclass DSU {\\n    constructor() {\\n        this.parents = new Map();\\n        this.rank = new Map();\\n    }\\n    \\n    add(x) {\\n        this.parents.set(x, x);\\n        this.rank.set(x, 0);\\n    }\\n    \\n    find(x) {\\n        const parent = this.parents.get(x);\\n        if (parent === x) return x;\\n        const setParent = this.find(parent);\\n        this.parents.set(x, setParent);\\n        return setParent;\\n    }\\n    \\n    union(x, y) {\\n        const xParent = this.find(x), yParent = this.find(y);\\n        const xRank = this.rank.get(xParent), yRank = this.rank.get(yParent);\\n        if (xParent === yParent) return;\\n        if (xRank > yRank) {\\n            this.parents.set(yParent, xParent);\\n        } else if (yRank > xRank) {\\n            this.parents.set(xParent, yParent);\\n        } else {\\n            this.parents.set(xParent, yParent);\\n            this.rank.set(yParent, yRank + 1);\\n        }   \\n    }\\n}\\n\\n/*\\nFriend Requests\\n*/\\nvar friendRequests = function(n, restrictions, requests) {\\n    const dsu = new DSU(), result = [];\\n    for (let i = 0; i < n; i++) dsu.add(i);\\n    \\n    for (let [friend1, friend2] of requests) {\\n        const parent1 = dsu.find(friend1), parent2 = dsu.find(friend2);\\n        let friendshipPossible = true;\\n        for (let [enemy1, enemy2] of restrictions) {\\n            const enemyParent1 = dsu.find(enemy1), enemyParent2 = dsu.find(enemy2);\\n            const condition1 = (enemyParent1 === parent1 && enemyParent2 === parent2);\\n            const condition2 = (enemyParent1 === parent2 && enemyParent2 === parent1);\\n            if (condition1 || condition2) {\\n                friendshipPossible = false;\\n                break;\\n            }\\n        }\\n        if (friendshipPossible) dsu.union(friend1, friend2);\\n        result.push(friendshipPossible);\\n    }\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Union Find"
                ],
                "code": "```\\n/*\\nDSU Class Template\\n*/\\nclass DSU {\\n    constructor() {\\n        this.parents = new Map();\\n        this.rank = new Map();\\n    }\\n    \\n    add(x) {\\n        this.parents.set(x, x);\\n        this.rank.set(x, 0);\\n    }\\n    \\n    find(x) {\\n        const parent = this.parents.get(x);\\n        if (parent === x) return x;\\n        const setParent = this.find(parent);\\n        this.parents.set(x, setParent);\\n        return setParent;\\n    }\\n    \\n    union(x, y) {\\n        const xParent = this.find(x), yParent = this.find(y);\\n        const xRank = this.rank.get(xParent), yRank = this.rank.get(yParent);\\n        if (xParent === yParent) return;\\n        if (xRank > yRank) {\\n            this.parents.set(yParent, xParent);\\n        } else if (yRank > xRank) {\\n            this.parents.set(xParent, yParent);\\n        } else {\\n            this.parents.set(xParent, yParent);\\n            this.rank.set(yParent, yRank + 1);\\n        }   \\n    }\\n}\\n\\n/*\\nFriend Requests\\n*/\\nvar friendRequests = function(n, restrictions, requests) {\\n    const dsu = new DSU(), result = [];\\n    for (let i = 0; i < n; i++) dsu.add(i);\\n    \\n    for (let [friend1, friend2] of requests) {\\n        const parent1 = dsu.find(friend1), parent2 = dsu.find(friend2);\\n        let friendshipPossible = true;\\n        for (let [enemy1, enemy2] of restrictions) {\\n            const enemyParent1 = dsu.find(enemy1), enemyParent2 = dsu.find(enemy2);\\n            const condition1 = (enemyParent1 === parent1 && enemyParent2 === parent2);\\n            const condition2 = (enemyParent1 === parent2 && enemyParent2 === parent1);\\n            if (condition1 || condition2) {\\n                friendshipPossible = false;\\n                break;\\n            }\\n        }\\n        if (friendshipPossible) dsu.union(friend1, friend2);\\n        result.push(friendshipPossible);\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1878809,
                "title": "python-union-find-bitmask-o-m-n",
                "content": "*uni.rep* means friends in one group, *uni.cnf* means this group cannot make friends with these people.\\n```\\nclass UniSet:\\n    def __init__(self, n):\\n        self.uni = list(range(n))\\n        self.rep = [1 << i for i in range(n)]\\n        self.cnf = [0] * n\\n    \\n    def find(self, x):\\n        if self.uni[x] != x: self.uni[x] = self.find(self.uni[x])\\n        return self.uni[x]\\n    \\n    def same(self, x, y):\\n        return self.find(x) == self.find(y)\\n\\n    def check_merge(self, x, y):\\n        x, y = self.find(x), self.find(y)\\n        if self.cnf[x] & self.rep[y] | self.rep[x] & self.cnf[y]: return False\\n        x, y = min(x, y), max(x, y)\\n        self.uni[y] = x\\n        self.rep[x] |= self.rep[y]\\n        self.cnf[x] |= self.cnf[y]\\n        return True\\n\\nclass Solution:\\n    def friendRequests(self, n: int, restrictions: List[List[int]], requests: List[List[int]]) -> List[bool]:\\n        uni = UniSet(n)\\n        for x, y in restrictions:\\n            uni.cnf[x] |= 1 << y\\n            uni.cnf[y] |= 1 << x\\n        return [uni.check_merge(x, y) for x, y in requests]\\n```",
                "solutionTags": [],
                "code": "```\\nclass UniSet:\\n    def __init__(self, n):\\n        self.uni = list(range(n))\\n        self.rep = [1 << i for i in range(n)]\\n        self.cnf = [0] * n\\n    \\n    def find(self, x):\\n        if self.uni[x] != x: self.uni[x] = self.find(self.uni[x])\\n        return self.uni[x]\\n    \\n    def same(self, x, y):\\n        return self.find(x) == self.find(y)\\n\\n    def check_merge(self, x, y):\\n        x, y = self.find(x), self.find(y)\\n        if self.cnf[x] & self.rep[y] | self.rep[x] & self.cnf[y]: return False\\n        x, y = min(x, y), max(x, y)\\n        self.uni[y] = x\\n        self.rep[x] |= self.rep[y]\\n        self.cnf[x] |= self.cnf[y]\\n        return True\\n\\nclass Solution:\\n    def friendRequests(self, n: int, restrictions: List[List[int]], requests: List[List[int]]) -> List[bool]:\\n        uni = UniSet(n)\\n        for x, y in restrictions:\\n            uni.cnf[x] |= 1 << y\\n            uni.cnf[y] |= 1 << x\\n        return [uni.check_merge(x, y) for x, y in requests]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1645066,
                "title": "simple-union-find-in-java",
                "content": "Before using union, go through all restrictions, and make sure they are not in the same group as the two nodes currently being connnected. \\nSay, current request is n1 - n2. \\nAnd there is a restriction s1 - s2 \\nIf s1 is connected to n1 and s2 is connected to n2. \\nWhen n1 and n2 are connected, s1 and s2 get connected indirectly too. \\nTherefore we make sure that there is no pair of restriction that gets connected on accepting the request. \\nIf there is no pair of restriction for the same, then we do union. \\n\\n```\\n\\nclass Solution {\\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        int[] parent = new int[n];\\n        boolean[] ans = new boolean[requests.length];\\n        int[] rank = new int[requests.length];\\n        for (int i = 0; i < n; i++){parent[i] = i;} \\n        \\n        for (int i = 0; i < requests.length; i++){\\n           int t1 = find(parent, requests[i][0]);\\n           int t2 = find(parent, requests[i][1]);\\n           boolean vis = true;\\n            for (int j = 0; j < restrictions.length; j++){\\n               int a1 = find(parent, restrictions[j][0]);\\n               int a2 = find(parent, restrictions[j][1]);\\n               if (a1 == t1 && a2 == t2){\\n                   vis = false; break;\\n               }\\n               else if (a1 == t2 && a2 == t1){\\n                   vis = false; break;\\n               }\\n                else if (a1 == t1 && a2 == t1){\\n                    vis = false; break;\\n                }\\n                else if (a1 == t2 && a2 == t2){vis = false; break;}\\n               \\n           }\\n            if (vis == true){ans[i] = true; union(parent, requests[i][0], requests[i][1]);}\\n            \\n        }\\n        \\n        return ans; \\n        \\n    }\\n    public int find(int[] parents, int i){\\n        if (parents[i] == i) return i; \\n        return find(parents, parents[i]);\\n    }\\n    \\n    public void union(int[] parent, int a1, int a2){\\n        if (find(parent, a1) == find(parent, a2)) return; \\n        int s1 = find(parent, a1); int s2 = find(parent, a2);\\n        parent[s2] = s1; \\n        \\n    }\\n    \\n    \\n    \\n}\\n```",
                "solutionTags": [
                    "Graph"
                ],
                "code": "```\\n\\nclass Solution {\\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        int[] parent = new int[n];\\n        boolean[] ans = new boolean[requests.length];\\n        int[] rank = new int[requests.length];\\n        for (int i = 0; i < n; i++){parent[i] = i;} \\n        \\n        for (int i = 0; i < requests.length; i++){\\n           int t1 = find(parent, requests[i][0]);\\n           int t2 = find(parent, requests[i][1]);\\n           boolean vis = true;\\n            for (int j = 0; j < restrictions.length; j++){\\n               int a1 = find(parent, restrictions[j][0]);\\n               int a2 = find(parent, restrictions[j][1]);\\n               if (a1 == t1 && a2 == t2){\\n                   vis = false; break;\\n               }\\n               else if (a1 == t2 && a2 == t1){\\n                   vis = false; break;\\n               }\\n                else if (a1 == t1 && a2 == t1){\\n                    vis = false; break;\\n                }\\n                else if (a1 == t2 && a2 == t2){vis = false; break;}\\n               \\n           }\\n            if (vis == true){ans[i] = true; union(parent, requests[i][0], requests[i][1]);}\\n            \\n        }\\n        \\n        return ans; \\n        \\n    }\\n    public int find(int[] parents, int i){\\n        if (parents[i] == i) return i; \\n        return find(parents, parents[i]);\\n    }\\n    \\n    public void union(int[] parent, int a1, int a2){\\n        if (find(parent, a1) == find(parent, a2)) return; \\n        int s1 = find(parent, a1); int s2 = find(parent, a2);\\n        parent[s2] = s1; \\n        \\n    }\\n    \\n    \\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1629225,
                "title": "java-union-find-solution-with-comment",
                "content": "```\\nclass Solution {\\n    int[] parent;\\n    boolean[] result;\\n    \\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        parent = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            parent[i] = i;\\n        }\\n        result = new boolean[requests.length];\\n        \\n        for (int i = 0; i < requests.length; i++) {\\n            // personA and personB can become friends if for all restrictions\\n            // person x_i and person y_i are not in the same set as personA and personB\\n            // and vice versa\\n            int personA = requests[i][0];\\n            int personB = requests[i][1];\\n            int personASetRepresentative = find(personA);\\n            int personBSetRepresentative = find(personB);\\n            boolean flag = true;\\n            for (int[] restriction : restrictions) {\\n                int blackListPersonARepresentative = find(restriction[0]);\\n                int blackListPersonBRepresentative = find(restriction[1]);\\n                if (personASetRepresentative == blackListPersonARepresentative && personBSetRepresentative == blackListPersonBRepresentative) {\\n                    flag = false;\\n                }\\n                if (personASetRepresentative == blackListPersonBRepresentative && personBSetRepresentative == blackListPersonARepresentative) {\\n                    flag = false;\\n                }\\n            }\\n            if (flag) {\\n                union(personA, personB);\\n            }\\n            result[i] = flag;\\n        }\\n        return result;\\n    }\\n    \\n    private int find(int node) {\\n        int root = node;\\n        while (parent[root] != root) {\\n            root = parent[root];\\n        }\\n        \\n        //path compression\\n        int curr = node;\\n        while (parent[curr] != root) {\\n            int next = parent[curr];\\n            parent[curr] = root;\\n            curr = next;\\n        }\\n        return root;\\n    }\\n    \\n    private boolean union(int node1, int node2) {\\n        int root1 = find(node1);\\n        int root2 = find(node2);\\n        if (root1 == root2) {\\n            return false;\\n        }\\n        parent[root2] = root1;\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    int[] parent;\\n    boolean[] result;\\n    \\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        parent = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            parent[i] = i;\\n        }\\n        result = new boolean[requests.length];\\n        \\n        for (int i = 0; i < requests.length; i++) {\\n            // personA and personB can become friends if for all restrictions\\n            // person x_i and person y_i are not in the same set as personA and personB\\n            // and vice versa\\n            int personA = requests[i][0];\\n            int personB = requests[i][1];\\n            int personASetRepresentative = find(personA);\\n            int personBSetRepresentative = find(personB);\\n            boolean flag = true;\\n            for (int[] restriction : restrictions) {\\n                int blackListPersonARepresentative = find(restriction[0]);\\n                int blackListPersonBRepresentative = find(restriction[1]);\\n                if (personASetRepresentative == blackListPersonARepresentative && personBSetRepresentative == blackListPersonBRepresentative) {\\n                    flag = false;\\n                }\\n                if (personASetRepresentative == blackListPersonBRepresentative && personBSetRepresentative == blackListPersonARepresentative) {\\n                    flag = false;\\n                }\\n            }\\n            if (flag) {\\n                union(personA, personB);\\n            }\\n            result[i] = flag;\\n        }\\n        return result;\\n    }\\n    \\n    private int find(int node) {\\n        int root = node;\\n        while (parent[root] != root) {\\n            root = parent[root];\\n        }\\n        \\n        //path compression\\n        int curr = node;\\n        while (parent[curr] != root) {\\n            int next = parent[curr];\\n            parent[curr] = root;\\n            curr = next;\\n        }\\n        return root;\\n    }\\n    \\n    private boolean union(int node1, int node2) {\\n        int root1 = find(node1);\\n        int root2 = find(node2);\\n        if (root1 == root2) {\\n            return false;\\n        }\\n        parent[root2] = root1;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1581108,
                "title": "java-dsu-direct-application",
                "content": "\\n```\\nclass Solution {\\n    int[] parent, rank;\\n    \\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        parent = new int[n];\\n        rank = new int[n];\\n        \\n        for(int i = 0; i < n; i++)\\n            parent[i] = i;\\n        \\n        boolean[] ans = new boolean[requests.length]; \\n        \\n        for(int i = 0; i < requests.length; i++) {\\n            int u = requests[i][0];\\n            int v = requests[i][1];\\n            \\n            u = find(u);\\n            v = find(v);\\n            \\n            boolean flag = true;\\n            \\n            for(int j = 0; j < restrictions.length; j++) {\\n                int u_ = restrictions[j][0];\\n                int v_ = restrictions[j][1];\\n                \\n                u_ = find(u_);\\n                v_ = find(v_);\\n                \\n                if((u_ == u && v_ == v) || (u_ == v && v_ == u)) {\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            \\n            if(flag == true)\\n                union(u, v);\\n            \\n            ans[i] = flag;\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    // Time complexity = O(n^2)\\n    // Space complexity = O(n)\\n    \\n    private int find(int x) {\\n        if(parent[x] == x)\\n            return x;\\n        \\n        return parent[x] = find(parent[x]);\\n    }\\n    \\n    private void union(int u, int v) {\\n        u = find(u);\\n        v = find(v);\\n        \\n        if(rank[u] > rank[v])\\n            parent[v] = u;\\n\\n        else if(rank[u] < rank[v])\\n            parent[u] = v;\\n\\n        else {\\n            parent[u] = v;\\n            rank[v]++;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int[] parent, rank;\\n    \\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        parent = new int[n];\\n        rank = new int[n];\\n        \\n        for(int i = 0; i < n; i++)\\n            parent[i] = i;\\n        \\n        boolean[] ans = new boolean[requests.length]; \\n        \\n        for(int i = 0; i < requests.length; i++) {\\n            int u = requests[i][0];\\n            int v = requests[i][1];\\n            \\n            u = find(u);\\n            v = find(v);\\n            \\n            boolean flag = true;\\n            \\n            for(int j = 0; j < restrictions.length; j++) {\\n                int u_ = restrictions[j][0];\\n                int v_ = restrictions[j][1];\\n                \\n                u_ = find(u_);\\n                v_ = find(v_);\\n                \\n                if((u_ == u && v_ == v) || (u_ == v && v_ == u)) {\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            \\n            if(flag == true)\\n                union(u, v);\\n            \\n            ans[i] = flag;\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    // Time complexity = O(n^2)\\n    // Space complexity = O(n)\\n    \\n    private int find(int x) {\\n        if(parent[x] == x)\\n            return x;\\n        \\n        return parent[x] = find(parent[x]);\\n    }\\n    \\n    private void union(int u, int v) {\\n        u = find(u);\\n        v = find(v);\\n        \\n        if(rank[u] > rank[v])\\n            parent[v] = u;\\n\\n        else if(rank[u] < rank[v])\\n            parent[u] = v;\\n\\n        else {\\n            parent[u] = v;\\n            rank[v]++;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1577153,
                "title": "python-272-ms-36-mb-maintain-connected-components-of-the-graph",
                "content": "Maintain two lists of sets ```connected_components``` and ```banned_by_comps``` to store the connected components the restrictions of nodes in each connected component. Maintain a dictionary ```connected_comp_dict``` to map each node to its connected compoent. Update them when a new edge is added.\\n```\\nclass Solution:\\n    def friendRequests(self, n: int, restrictions: List[List[int]], requests: List[List[int]]) -> List[bool]:        \\n        result = [False for _ in requests]\\n        \\n        connected_components = [{i} for i in range(n)]\\n        \\n        connected_comp_dict = {}\\n        for i in range(n):\\n            connected_comp_dict[i] = i\\n        \\n        banned_by_comps = [set() for i in range(n)]\\n        for res in restrictions:\\n            banned_by_comps[res[0]].add(res[1])\\n            banned_by_comps[res[1]].add(res[0])\\n        for i,r in enumerate(requests):\\n            n1, n2 = r[0], r[1]\\n            c1, c2 = connected_comp_dict[n1], connected_comp_dict[n2]\\n            if c1 == c2:\\n                result[i] = True\\n            else:\\n                if not (connected_components[c1].intersection(banned_by_comps[c2]) or connected_components[c2].intersection(banned_by_comps[c1])):\\n                    connected_components[c1].update(connected_components[c2])\\n                    banned_by_comps[c1].update(banned_by_comps[c2])\\n                    for node in connected_components[c2]:\\n                        connected_comp_dict[node] = c1\\n                    result[i] = True\\n                \\n        return result\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Graph",
                    "Ordered Set"
                ],
                "code": "```connected_components```\n```banned_by_comps```\n```connected_comp_dict```\n```\\nclass Solution:\\n    def friendRequests(self, n: int, restrictions: List[List[int]], requests: List[List[int]]) -> List[bool]:        \\n        result = [False for _ in requests]\\n        \\n        connected_components = [{i} for i in range(n)]\\n        \\n        connected_comp_dict = {}\\n        for i in range(n):\\n            connected_comp_dict[i] = i\\n        \\n        banned_by_comps = [set() for i in range(n)]\\n        for res in restrictions:\\n            banned_by_comps[res[0]].add(res[1])\\n            banned_by_comps[res[1]].add(res[0])\\n        for i,r in enumerate(requests):\\n            n1, n2 = r[0], r[1]\\n            c1, c2 = connected_comp_dict[n1], connected_comp_dict[n2]\\n            if c1 == c2:\\n                result[i] = True\\n            else:\\n                if not (connected_components[c1].intersection(banned_by_comps[c2]) or connected_components[c2].intersection(banned_by_comps[c1])):\\n                    connected_components[c1].update(connected_components[c2])\\n                    banned_by_comps[c1].update(banned_by_comps[c2])\\n                    for node in connected_components[c2]:\\n                        connected_comp_dict[node] = c1\\n                    result[i] = True\\n                \\n        return result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1577131,
                "title": "c-union-find-easy-to-understand",
                "content": "#### Algorithm  ( Union Find with modification ) \\n\\n* Process the request first \\n* Store Parent Array in some other temporary data structure.\\n* Merge the vertices/nodes \\n* Check in the requests array if we have violated the conditions\\n* If conditions are violated rollback the requests by updating parent array to the one stored in temporary data structure.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int>parent;\\n    int find(int node)\\n    {\\n        \\n        if(node==parent[node])\\n            return node;\\n        \\n        return parent[node]=find(parent[node]);\\n    }\\n    void merge(int u,int v)\\n    {\\n        int pu=find(u);\\n        int pv=find(v);\\n        parent[pu]=pv;\\n    }\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        \\n        \\n        \\n        int i;\\n        \\n        parent.resize(n);\\n        for(i=0;i<n;i++)\\n            parent[i]=i;\\n        \\n        vector<bool>ans(requests.size());\\n        \\n       for(i=0;i<requests.size();i++)\\n       {\\n           int u=requests[i][0];\\n           int v=requests[i][1];\\n           \\n           \\n           auto temp_copy=parent;\\n           ans[i]=true;\\n           merge(u,v);\\n           for(auto &it:restrictions)\\n           {\\n               \\n               int p=it[0];\\n               int q=it[1];\\n               \\n               if(find(p)==find(q))\\n               {\\n                   ans[i]=false;\\n                   break;\\n                }\\n            }\\n           if(!ans[i])\\n               parent=temp_copy;\\n               \\n       }\\n       \\n        return ans;\\n        \\n    }\\n};\\n\\n```\\n \\n### Pls upvote if you found helpful",
                "solutionTags": [
                    "C++",
                    "C",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>parent;\\n    int find(int node)\\n    {\\n        \\n        if(node==parent[node])\\n            return node;\\n        \\n        return parent[node]=find(parent[node]);\\n    }\\n    void merge(int u,int v)\\n    {\\n        int pu=find(u);\\n        int pv=find(v);\\n        parent[pu]=pv;\\n    }\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        \\n        \\n        \\n        int i;\\n        \\n        parent.resize(n);\\n        for(i=0;i<n;i++)\\n            parent[i]=i;\\n        \\n        vector<bool>ans(requests.size());\\n        \\n       for(i=0;i<requests.size();i++)\\n       {\\n           int u=requests[i][0];\\n           int v=requests[i][1];\\n           \\n           \\n           auto temp_copy=parent;\\n           ans[i]=true;\\n           merge(u,v);\\n           for(auto &it:restrictions)\\n           {\\n               \\n               int p=it[0];\\n               int q=it[1];\\n               \\n               if(find(p)==find(q))\\n               {\\n                   ans[i]=false;\\n                   break;\\n                }\\n            }\\n           if(!ans[i])\\n               parent=temp_copy;\\n               \\n       }\\n       \\n        return ans;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1576985,
                "title": "c-2076-process-restricted-friend-requests",
                "content": "\\n```\\nclass UnionFind {\\npublic: \\n    vector<int> parent, rank; \\n    UnionFind(int n) {\\n        parent.resize(n); \\n        iota(begin(parent), end(parent), 0); \\n        rank.resize(n); \\n        fill(rank.begin(), rank.end(), 1); \\n    } \\n    \\n    int find(int p) {\\n        /* find with path compression */\\n        if (parent[p] != p) \\n            parent[p] = find(parent[p]); \\n        return parent[p]; \\n    }\\n    \\n    bool connect(int p, int q) {\\n        /* union with rank */\\n        int prt = find(p), qrt = find(q); \\n        if (prt == qrt) return false; \\n        if (rank[prt] > rank[qrt]) swap(prt, qrt);\\n        parent[prt] = qrt; \\n        rank[qrt] += rank[prt]; \\n        return true; \\n    }\\n};\\n\\n\\nclass Solution {\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        vector<bool> ans; \\n        UnionFind *uf = new UnionFind(n); \\n        for (auto& request : requests) {\\n            int u = uf->find(request[0]), v = uf->find(request[1]); \\n            bool found = false; \\n            for (auto& restriction : restrictions) {\\n                int x = uf->find(restriction[0]), y = uf->find(restriction[1]); \\n                if ((u == x && v == y) || (u == y && v == x)) {\\n                    found = true; \\n                    break; \\n                }\\n            }\\n            ans.push_back(!found); \\n            if (!found) uf->connect(u, v); \\n        }\\n        delete uf; \\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass UnionFind {\\npublic: \\n    vector<int> parent, rank; \\n    UnionFind(int n) {\\n        parent.resize(n); \\n        iota(begin(parent), end(parent), 0); \\n        rank.resize(n); \\n        fill(rank.begin(), rank.end(), 1); \\n    } \\n    \\n    int find(int p) {\\n        /* find with path compression */\\n        if (parent[p] != p) \\n            parent[p] = find(parent[p]); \\n        return parent[p]; \\n    }\\n    \\n    bool connect(int p, int q) {\\n        /* union with rank */\\n        int prt = find(p), qrt = find(q); \\n        if (prt == qrt) return false; \\n        if (rank[prt] > rank[qrt]) swap(prt, qrt);\\n        parent[prt] = qrt; \\n        rank[qrt] += rank[prt]; \\n        return true; \\n    }\\n};\\n\\n\\nclass Solution {\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        vector<bool> ans; \\n        UnionFind *uf = new UnionFind(n); \\n        for (auto& request : requests) {\\n            int u = uf->find(request[0]), v = uf->find(request[1]); \\n            bool found = false; \\n            for (auto& restriction : restrictions) {\\n                int x = uf->find(restriction[0]), y = uf->find(restriction[1]); \\n                if ((u == x && v == y) || (u == y && v == x)) {\\n                    found = true; \\n                    break; \\n                }\\n            }\\n            ans.push_back(!found); \\n            if (!found) uf->connect(u, v); \\n        }\\n        delete uf; \\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1576965,
                "title": "python3-union-find",
                "content": "Please check out this [commit](https://github.com/gaosanyong/leetcode/commit/8d693371fa97ea3b0717d02448c77201b15e5d12) for solutions of weekly 267.\\n```\\nclass UnionFind:\\n\\n\\tdef __init__(self, n: int):\\n\\t\\tself.parent = list(range(n))\\n\\t\\tself.rank = [1] * n\\n\\n\\tdef find(self, p: int, halving: bool=True) -> int:\\n\\t\\tif p != self.parent[p]:\\n\\t\\t\\tself.parent[p] = self.find(self.parent[p]) \\n\\t\\treturn self.parent[p]\\n\\n\\tdef union(self, p: int, q: int) -> bool:\\n\\t\\tprt, qrt = self.find(p), self.find(q)\\n\\t\\tif prt == qrt: return False \\n\\t\\tif self.rank[prt] > self.rank[qrt]: prt, qrt = qrt, prt \\n\\t\\tself.parent[prt] = qrt\\n\\t\\tself.rank[qrt] += self.rank[prt]\\n\\t\\treturn True\\n\\n\\nclass Solution:\\n    def friendRequests(self, n: int, restrictions: List[List[int]], requests: List[List[int]]) -> List[bool]:\\n        ans = []\\n        uf = UnionFind(n)\\n        for u, v in requests: \\n            uu = uf.find(u)\\n            vv = uf.find(v)\\n            for x, y in restrictions: \\n                xx = uf.find(x)\\n                yy = uf.find(y)\\n                if uu == xx and vv == yy or uu == yy and vv == xx: \\n                    ans.append(False)\\n                    break \\n            else: \\n                ans.append(True)\\n                uf.union(u, v)\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass UnionFind:\\n\\n\\tdef __init__(self, n: int):\\n\\t\\tself.parent = list(range(n))\\n\\t\\tself.rank = [1] * n\\n\\n\\tdef find(self, p: int, halving: bool=True) -> int:\\n\\t\\tif p != self.parent[p]:\\n\\t\\t\\tself.parent[p] = self.find(self.parent[p]) \\n\\t\\treturn self.parent[p]\\n\\n\\tdef union(self, p: int, q: int) -> bool:\\n\\t\\tprt, qrt = self.find(p), self.find(q)\\n\\t\\tif prt == qrt: return False \\n\\t\\tif self.rank[prt] > self.rank[qrt]: prt, qrt = qrt, prt \\n\\t\\tself.parent[prt] = qrt\\n\\t\\tself.rank[qrt] += self.rank[prt]\\n\\t\\treturn True\\n\\n\\nclass Solution:\\n    def friendRequests(self, n: int, restrictions: List[List[int]], requests: List[List[int]]) -> List[bool]:\\n        ans = []\\n        uf = UnionFind(n)\\n        for u, v in requests: \\n            uu = uf.find(u)\\n            vv = uf.find(v)\\n            for x, y in restrictions: \\n                xx = uf.find(x)\\n                yy = uf.find(y)\\n                if uu == xx and vv == yy or uu == yy and vv == xx: \\n                    ans.append(False)\\n                    break \\n            else: \\n                ans.append(True)\\n                uf.union(u, v)\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1576953,
                "title": "java-sets-with-communities-easy-to-understand",
                "content": "**Idea**: Create a list of sets of communities (`List<Set<Integer>> communities`) and check whether can be they joined or not based on restrictions.\\n\\n**Algorithm**: Let\\'s take example from the problem. `n = 3, restrictions = [[0,1]], requests = [[0,2],[2,1]]`. You will firstly create such communities` [ {0}, {1}, {2} ]`. Furthermore, we will maintain restrictions in hashmap for quick access.\\nThen, in each request we check whether we are able to merge these communities together or not. After first iteration (`[0,2]`), we will get `[ {0,2}, {1} ]`. In the second request, we see that `{1}` cannot be inside the set with `0` and `2`, becase `2` has `0` in its community. Please, check the code for additional conditions of comparing the sets with each other.\\n\\n\\n```\\nclass Solution {\\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        boolean[] res = new boolean[requests.length];\\n        List<Integer>[] restricted = new List[n];\\n        for (int i = 0; i < n; i++)\\n            restricted[i] = new ArrayList<Integer>();\\n        \\n        for (int[] r : restrictions) {\\n            restricted[r[0]].add(r[1]);\\n            restricted[r[1]].add(r[0]);\\n        }\\n        \\n        List<HashSet<Integer>> communities = new ArrayList();\\n        for (int i = 0; i < n; i++) {\\n            HashSet<Integer> s = new HashSet<Integer>();\\n            s.add(i);\\n            communities.add(s);\\n        }\\n        \\n        int k = 0;\\n        for (int[] req : requests) {\\n            int x = req[0];\\n            int y = req[1];\\n            int xi = 0, yi = 0; // Indices of sets in which there people belong to\\n            \\n            for (int i = 0; i < communities.size(); i++) {\\n                if (communities.get(i).contains(x)) {\\n                    xi = i;\\n                }\\n                if (communities.get(i).contains(y)) {\\n                    yi = i;\\n                }\\n            }\\n            \\n            if (xi == yi) {  // they are both already in one community\\n                res[k++] = true;\\n                continue;\\n            }\\n            \\n            int flag = -1;\\n            for (int node : communities.get(xi)) {\\n                if (flag >= 0) break;\\n                for (int other : communities.get(yi)) {\\n                    if (restricted[node].contains(other)) {\\n                        flag = 0;\\n                        break;\\n                    } else if (communities.get(xi).contains(other)) {\\n                        flag = 1;\\n                        break;\\n                    }\\n                }\\n            }\\n            if (flag == 0) {\\n                res[k++] = false;\\n            } else {\\n                mergeSets(communities, xi, yi);\\n                res[k++] = true;\\n            }\\n        } \\n        \\n        return res;\\n    }\\n    \\n    public void mergeSets(List<HashSet<Integer>> communities, int xi, int yi) {\\n        HashSet<Integer> a = communities.get(xi);\\n        HashSet<Integer> b = communities.get(yi);\\n        if (xi > yi) {\\n            communities.remove(xi);\\n            communities.remove(yi);\\n        } else {\\n            communities.remove(yi);\\n            communities.remove(xi);\\n        }\\n        for (int val : b) {\\n            a.add(val);\\n        }\\n        communities.add(a);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        boolean[] res = new boolean[requests.length];\\n        List<Integer>[] restricted = new List[n];\\n        for (int i = 0; i < n; i++)\\n            restricted[i] = new ArrayList<Integer>();\\n        \\n        for (int[] r : restrictions) {\\n            restricted[r[0]].add(r[1]);\\n            restricted[r[1]].add(r[0]);\\n        }\\n        \\n        List<HashSet<Integer>> communities = new ArrayList();\\n        for (int i = 0; i < n; i++) {\\n            HashSet<Integer> s = new HashSet<Integer>();\\n            s.add(i);\\n            communities.add(s);\\n        }\\n        \\n        int k = 0;\\n        for (int[] req : requests) {\\n            int x = req[0];\\n            int y = req[1];\\n            int xi = 0, yi = 0; // Indices of sets in which there people belong to\\n            \\n            for (int i = 0; i < communities.size(); i++) {\\n                if (communities.get(i).contains(x)) {\\n                    xi = i;\\n                }\\n                if (communities.get(i).contains(y)) {\\n                    yi = i;\\n                }\\n            }\\n            \\n            if (xi == yi) {  // they are both already in one community\\n                res[k++] = true;\\n                continue;\\n            }\\n            \\n            int flag = -1;\\n            for (int node : communities.get(xi)) {\\n                if (flag >= 0) break;\\n                for (int other : communities.get(yi)) {\\n                    if (restricted[node].contains(other)) {\\n                        flag = 0;\\n                        break;\\n                    } else if (communities.get(xi).contains(other)) {\\n                        flag = 1;\\n                        break;\\n                    }\\n                }\\n            }\\n            if (flag == 0) {\\n                res[k++] = false;\\n            } else {\\n                mergeSets(communities, xi, yi);\\n                res[k++] = true;\\n            }\\n        } \\n        \\n        return res;\\n    }\\n    \\n    public void mergeSets(List<HashSet<Integer>> communities, int xi, int yi) {\\n        HashSet<Integer> a = communities.get(xi);\\n        HashSet<Integer> b = communities.get(yi);\\n        if (xi > yi) {\\n            communities.remove(xi);\\n            communities.remove(yi);\\n        } else {\\n            communities.remove(yi);\\n            communities.remove(xi);\\n        }\\n        for (int val : b) {\\n            a.add(val);\\n        }\\n        communities.add(a);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1576937,
                "title": "javascript-union-find-2-solutions",
                "content": "```javascript\\nvar friendRequests = function(numPeople, restrictions, requests) {\\n    // base union find data structure\\n    const friendships = [...new Array(numPeople).keys()];\\n    // this is equivalent to find in union find\\n    const findRootFriend = (x) => friendships[x] = friendships[x] === x ? x : findRootFriend(friendships[x]);\\n    // this is equivalent to union in union find\\n    const createFriendship = (x, y) => friendships[findRootFriend(x)] = findRootFriend(y);\\n    \\n    const isInSameFriendshipGroup = (person1, person2) => findRootFriend(person1) === findRootFriend(person2);\\n    const findFriendsInGroup = (friend) => {\\n        const friendsInGroup = [];\\n        for (let person = 0; person < numPeople; person++) {\\n            if (isInSameFriendshipGroup(person, friend)) {\\n                friendsInGroup.push(person);\\n            }\\n        }\\n        return friendsInGroup;\\n    }\\n    \\n    const mappedRestrictions = mapRestrictions(numPeople, restrictions);\\n    \\n    return requests.map(([friend1, friend2], i) => {\\n        const friendsOfFriend1 = findFriendsInGroup(friend1);\\n        \\n        for (let person = 0; person < numPeople; person++) {\\n            if (isInSameFriendshipGroup(person, friend2)) {\\n\\n                // check all the friends in friend1\\'s group to see if\\n                // person can be friends with friend of friend1\\n                for (let friendOfFriend1 of friendsOfFriend1) {\\n                    if (mappedRestrictions[person].has(friendOfFriend1)) {\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n        // create the friendship\\n        createFriendship(friend1, friend2);\\n        return true;\\n    })\\n};\\n\\nfunction mapRestrictions(numPeople, restrictions) {\\n    const mappedRestrictions = new Array(numPeople).fill(0).map(() => new Set());\\n    for (const [person1, person2] of restrictions) {\\n        mappedRestrictions[person1].add(person2);\\n        mappedRestrictions[person2].add(person1);\\n    }\\n    return mappedRestrictions;\\n}\\n\\n\\n\\n//////////////////////////////////////////////////////////\\n//////////////////////////////////////////////////////////\\n//////////////////////////////////////////////////////////\\n// Credit to: lee215\\n\\n\\nvar friendRequests = function(numPeople, restrictions, requests) {\\n    // base union find data structure\\n    const friendships = [...new Array(numPeople).keys()];\\n    // this is equivalent to find in union find\\n    const findRootFriend = (x) => friendships[x] = friendships[x] === x ? x : findRootFriend(friendships[x]);\\n    // this is equivalent to union in union find\\n    const createFriendship = (x, y) => friendships[findRootFriend(x)] = findRootFriend(y);\\n    const isInSameFriendshipGroup = (person1, person2) => findRootFriend(person1) === findRootFriend(person2);\\n    \\n    return requests.map(([friend1, friend2], i) => {\\n        if (isInSameFriendshipGroup(friend1, friend2)) return true;\\n        \\n        for (const [person1, person2] of restrictions) {\\n            if ((isInSameFriendshipGroup(person1, friend1) && isInSameFriendshipGroup(person2, friend2)) ||\\n                (isInSameFriendshipGroup(person1, friend2) && isInSameFriendshipGroup(person2, friend1))) {\\n                return false;\\n            }\\n        }\\n        createFriendship(friend1, friend2);\\n        return true;\\n    })\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Union Find"
                ],
                "code": "```javascript\\nvar friendRequests = function(numPeople, restrictions, requests) {\\n    // base union find data structure\\n    const friendships = [...new Array(numPeople).keys()];\\n    // this is equivalent to find in union find\\n    const findRootFriend = (x) => friendships[x] = friendships[x] === x ? x : findRootFriend(friendships[x]);\\n    // this is equivalent to union in union find\\n    const createFriendship = (x, y) => friendships[findRootFriend(x)] = findRootFriend(y);\\n    \\n    const isInSameFriendshipGroup = (person1, person2) => findRootFriend(person1) === findRootFriend(person2);\\n    const findFriendsInGroup = (friend) => {\\n        const friendsInGroup = [];\\n        for (let person = 0; person < numPeople; person++) {\\n            if (isInSameFriendshipGroup(person, friend)) {\\n                friendsInGroup.push(person);\\n            }\\n        }\\n        return friendsInGroup;\\n    }\\n    \\n    const mappedRestrictions = mapRestrictions(numPeople, restrictions);\\n    \\n    return requests.map(([friend1, friend2], i) => {\\n        const friendsOfFriend1 = findFriendsInGroup(friend1);\\n        \\n        for (let person = 0; person < numPeople; person++) {\\n            if (isInSameFriendshipGroup(person, friend2)) {\\n\\n                // check all the friends in friend1\\'s group to see if\\n                // person can be friends with friend of friend1\\n                for (let friendOfFriend1 of friendsOfFriend1) {\\n                    if (mappedRestrictions[person].has(friendOfFriend1)) {\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n        // create the friendship\\n        createFriendship(friend1, friend2);\\n        return true;\\n    })\\n};\\n\\nfunction mapRestrictions(numPeople, restrictions) {\\n    const mappedRestrictions = new Array(numPeople).fill(0).map(() => new Set());\\n    for (const [person1, person2] of restrictions) {\\n        mappedRestrictions[person1].add(person2);\\n        mappedRestrictions[person2].add(person1);\\n    }\\n    return mappedRestrictions;\\n}\\n\\n\\n\\n//////////////////////////////////////////////////////////\\n//////////////////////////////////////////////////////////\\n//////////////////////////////////////////////////////////\\n// Credit to: lee215\\n\\n\\nvar friendRequests = function(numPeople, restrictions, requests) {\\n    // base union find data structure\\n    const friendships = [...new Array(numPeople).keys()];\\n    // this is equivalent to find in union find\\n    const findRootFriend = (x) => friendships[x] = friendships[x] === x ? x : findRootFriend(friendships[x]);\\n    // this is equivalent to union in union find\\n    const createFriendship = (x, y) => friendships[findRootFriend(x)] = findRootFriend(y);\\n    const isInSameFriendshipGroup = (person1, person2) => findRootFriend(person1) === findRootFriend(person2);\\n    \\n    return requests.map(([friend1, friend2], i) => {\\n        if (isInSameFriendshipGroup(friend1, friend2)) return true;\\n        \\n        for (const [person1, person2] of restrictions) {\\n            if ((isInSameFriendshipGroup(person1, friend1) && isInSameFriendshipGroup(person2, friend2)) ||\\n                (isInSameFriendshipGroup(person1, friend2) && isInSameFriendshipGroup(person2, friend1))) {\\n                return false;\\n            }\\n        }\\n        createFriendship(friend1, friend2);\\n        return true;\\n    })\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1576934,
                "title": "c-solution-union-find-and-brute-force",
                "content": "\\n\\n### Idea\\n- Try to make a connection for each request, after making this connection and if one of the restrictions is violated, then the answer is false and recover the union-find array to the previous status.\\n  \\n```\\nclass Solution {\\npublic:\\n    vector<int> arr;\\n    vector<int> vis;\\n    int find(int x) {\\n        if(arr[x] == 0) return arr[x] = x;\\n        if(arr[x] == x) return x;\\n        return arr[x] = find(arr[x]);\\n    }\\n    void combine(int a, int b) {\\n        a = find(a);\\n        b = find(b);\\n        arr[a] = b;\\n    }\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        arr.resize(n + 2);\\n        vector<bool> ans(requests.size());\\n        for(int i = 0; i < requests.size(); i++) {\\n            int a = requests[i][0] + 1, b = requests[i][1] + 1;\\n            auto src = arr;\\n            combine(a, b);\\n            ans[i] = true;\\n            for(auto &r : restrictions) {\\n                int a = r[0] + 1, b = r[1] + 1;\\n                if(find(a) == find(b)) {\\n                    ans[i] = false;\\n                    break;\\n                }\\n            }\\n            if(!ans[i]) arr = src;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> arr;\\n    vector<int> vis;\\n    int find(int x) {\\n        if(arr[x] == 0) return arr[x] = x;\\n        if(arr[x] == x) return x;\\n        return arr[x] = find(arr[x]);\\n    }\\n    void combine(int a, int b) {\\n        a = find(a);\\n        b = find(b);\\n        arr[a] = b;\\n    }\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        arr.resize(n + 2);\\n        vector<bool> ans(requests.size());\\n        for(int i = 0; i < requests.size(); i++) {\\n            int a = requests[i][0] + 1, b = requests[i][1] + 1;\\n            auto src = arr;\\n            combine(a, b);\\n            ans[i] = true;\\n            for(auto &r : restrictions) {\\n                int a = r[0] + 1, b = r[1] + 1;\\n                if(find(a) == find(b)) {\\n                    ans[i] = false;\\n                    break;\\n                }\\n            }\\n            if(!ans[i]) arr = src;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3814592,
                "title": "union-find-disjoint-sets-solution-faster-than-90-java",
                "content": "# Code\\n```\\nclass DisjointSet {\\n    private final int[] root;\\n    private final int[] rank;\\n    private final List<Set<Integer>> restrictions;\\n\\n    DisjointSet(int size, int[][] restrictions) {\\n        root = new int[size];\\n        rank = new int[size];\\n        this.restrictions = new ArrayList<>();\\n        for (int i = 0; i < size; i++) {\\n            root[i] = i;\\n            rank[i] = 1;\\n            this.restrictions.add(new HashSet<>());\\n        }\\n        for (int[] restriction: restrictions) {\\n            this.restrictions.get(restriction[0]).add(restriction[1]);\\n            this.restrictions.get(restriction[1]).add(restriction[0]);\\n        }\\n    }\\n\\n    private int find(int vertex) {\\n        if(root[vertex] == vertex) return vertex;\\n        return root[vertex] = find(root[vertex]);\\n    }\\n\\n    public boolean union(int vertex1, int vertex2) {\\n        int root1 = find(vertex1);\\n        int root2 = find(vertex2);\\n        if(root1 == root2) return true;\\n        if(notRestricted(root1, root2)) {\\n            if(rank[root1] > rank[root2]) {\\n                root[root2] = root1;\\n                restrictions.get(root1).addAll(restrictions.get(root2));\\n                addRoots(root1);\\n            } else if(rank[root2] > rank[root1]) {\\n                root[root1] = root2;\\n                restrictions.get(root2).addAll(restrictions.get(root1));\\n                addRoots(root2);\\n            } else {\\n                root[root2] = root1;\\n                rank[root1]++;\\n                restrictions.get(root1).addAll(restrictions.get(root2));\\n                addRoots(root1);\\n            }\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    private void addRoots(int index) {\\n        Set<Integer> added = new HashSet<>();\\n        for (int node: restrictions.get(index)) \\n            added.add(find(node));\\n        restrictions.get(index).addAll(added);    \\n    }\\n\\n    private boolean notRestricted(int root1, int root2) {\\n        for (int node: restrictions.get(root1)) if(node == root2) return false;\\n        for (int node: restrictions.get(root2)) if(node == root1) return false;\\n        return true;\\n    }\\n}\\n\\nclass Solution {\\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        DisjointSet set = new DisjointSet(n, restrictions);\\n        boolean[] queries = new boolean[requests.length];\\n        for (int i = 0; i < requests.length; i++) \\n            queries[i] = set.union(requests[i][0], requests[i][1]);\\n        return queries;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass DisjointSet {\\n    private final int[] root;\\n    private final int[] rank;\\n    private final List<Set<Integer>> restrictions;\\n\\n    DisjointSet(int size, int[][] restrictions) {\\n        root = new int[size];\\n        rank = new int[size];\\n        this.restrictions = new ArrayList<>();\\n        for (int i = 0; i < size; i++) {\\n            root[i] = i;\\n            rank[i] = 1;\\n            this.restrictions.add(new HashSet<>());\\n        }\\n        for (int[] restriction: restrictions) {\\n            this.restrictions.get(restriction[0]).add(restriction[1]);\\n            this.restrictions.get(restriction[1]).add(restriction[0]);\\n        }\\n    }\\n\\n    private int find(int vertex) {\\n        if(root[vertex] == vertex) return vertex;\\n        return root[vertex] = find(root[vertex]);\\n    }\\n\\n    public boolean union(int vertex1, int vertex2) {\\n        int root1 = find(vertex1);\\n        int root2 = find(vertex2);\\n        if(root1 == root2) return true;\\n        if(notRestricted(root1, root2)) {\\n            if(rank[root1] > rank[root2]) {\\n                root[root2] = root1;\\n                restrictions.get(root1).addAll(restrictions.get(root2));\\n                addRoots(root1);\\n            } else if(rank[root2] > rank[root1]) {\\n                root[root1] = root2;\\n                restrictions.get(root2).addAll(restrictions.get(root1));\\n                addRoots(root2);\\n            } else {\\n                root[root2] = root1;\\n                rank[root1]++;\\n                restrictions.get(root1).addAll(restrictions.get(root2));\\n                addRoots(root1);\\n            }\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    private void addRoots(int index) {\\n        Set<Integer> added = new HashSet<>();\\n        for (int node: restrictions.get(index)) \\n            added.add(find(node));\\n        restrictions.get(index).addAll(added);    \\n    }\\n\\n    private boolean notRestricted(int root1, int root2) {\\n        for (int node: restrictions.get(root1)) if(node == root2) return false;\\n        for (int node: restrictions.get(root2)) if(node == root1) return false;\\n        return true;\\n    }\\n}\\n\\nclass Solution {\\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        DisjointSet set = new DisjointSet(n, restrictions);\\n        boolean[] queries = new boolean[requests.length];\\n        for (int i = 0; i < requests.length; i++) \\n            queries[i] = set.union(requests[i][0], requests[i][1]);\\n        return queries;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2724215,
                "title": "c-easy-short",
                "content": "\\n# Code\\n```\\nclass Solution {\\n  vector<int> parents;\\n    int find_set(int v)\\n    {\\n        if(v == parents[v])\\n            return v;\\n        return parents[v] = find_set(parents[v]);\\n    }\\n    void union_set(int a, int b)\\n    {\\n        a = find_set(a);\\n        b = find_set(b);\\n        if(a == b)\\n            return;\\n        if(a != b)\\n            parents[b] = a;\\n        return;\\n    }\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        for(int i = 0; i < n; i++)\\n            parents.push_back(i);\\n        vector<bool> ans;\\n        for(vector<int> &req : requests)\\n        {\\n            int v = 1;\\n            int a = find_set(req[0]);\\n            int b = find_set(req[1]);\\n            for(vector<int> &res : restrictions)\\n            {\\n                int r1 = find_set(res[0]);\\n                int r2 = find_set(res[1]);\\n                if((a == r1 && b == r2) || (b == r1 && a == r2))\\n                {\\n                    v = 0;\\n                    break;\\n                }\\n            }\\n            ans.push_back(v);\\n            if(v)\\n            {\\n                union_set(a,b);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n  vector<int> parents;\\n    int find_set(int v)\\n    {\\n        if(v == parents[v])\\n            return v;\\n        return parents[v] = find_set(parents[v]);\\n    }\\n    void union_set(int a, int b)\\n    {\\n        a = find_set(a);\\n        b = find_set(b);\\n        if(a == b)\\n            return;\\n        if(a != b)\\n            parents[b] = a;\\n        return;\\n    }\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        for(int i = 0; i < n; i++)\\n            parents.push_back(i);\\n        vector<bool> ans;\\n        for(vector<int> &req : requests)\\n        {\\n            int v = 1;\\n            int a = find_set(req[0]);\\n            int b = find_set(req[1]);\\n            for(vector<int> &res : restrictions)\\n            {\\n                int r1 = find_set(res[0]);\\n                int r2 = find_set(res[1]);\\n                if((a == r1 && b == r2) || (b == r1 && a == r2))\\n                {\\n                    v = 0;\\n                    break;\\n                }\\n            }\\n            ans.push_back(v);\\n            if(v)\\n            {\\n                union_set(a,b);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2214730,
                "title": "c-easy-to-understand-dsu-implementation",
                "content": "```\\nclass dsu {\\n    int *rank, *parent, n;\\n \\npublic:\\n    dsu(int n)\\n    {\\n        rank = new int[n];\\n        parent = new int[n];\\n        this->n = n;\\n        makeSet();\\n    }\\n    void makeSet()\\n    {\\n        for (int i = 0; i < n; i++) {\\n            parent[i] = i;\\n        }\\n    }\\n \\n    int par(int x)\\n    {\\n        if (parent[x] != x) {\\n            parent[x] = par(parent[x]);\\n        }\\n        return parent[x];\\n    }\\n    void unions(int x, int y)\\n    {\\n        int xset = par(x);\\n        int yset = par(y);\\n        if (xset == yset)\\n            return;\\n        if (rank[xset] < rank[yset]) {\\n            parent[xset] = yset;\\n        }\\n        else if (rank[xset] > rank[yset]) {\\n            parent[yset] = xset;\\n        }\\n        else {\\n            parent[yset] = xset;\\n            rank[xset] = rank[xset] + 1;\\n        }\\n    }\\n};\\n \\n\\nclass Solution {\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& res, vector<vector<int>>& req) {\\n        dsu obj(n);\\n        obj.makeSet();\\n        vector<bool> ans;\\n        for(int i = 0; i < req.size();i++){\\n   int x= obj.par(req[i][0]);\\n                int y = obj.par(req[i][1]);\\n            bool b = true;\\n            for(int j = 0; j < res.size();j++){\\n                int x1 = obj.par(res[j][0]);\\n                int y1 = obj.par(res[j][1]);\\n                if((x==x1&&y==y1)||(x==y1&&y==x1)){\\n                    b = false;\\n                    break;\\n                }\\n            }\\n            if(b){\\n                ans.push_back(true);\\n                obj.unions(req[i][0],req[i][1]);\\n            }\\n            else{\\n                ans.push_back(false);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Union Find"
                ],
                "code": "```\\nclass dsu {\\n    int *rank, *parent, n;\\n \\npublic:\\n    dsu(int n)\\n    {\\n        rank = new int[n];\\n        parent = new int[n];\\n        this->n = n;\\n        makeSet();\\n    }\\n    void makeSet()\\n    {\\n        for (int i = 0; i < n; i++) {\\n            parent[i] = i;\\n        }\\n    }\\n \\n    int par(int x)\\n    {\\n        if (parent[x] != x) {\\n            parent[x] = par(parent[x]);\\n        }\\n        return parent[x];\\n    }\\n    void unions(int x, int y)\\n    {\\n        int xset = par(x);\\n        int yset = par(y);\\n        if (xset == yset)\\n            return;\\n        if (rank[xset] < rank[yset]) {\\n            parent[xset] = yset;\\n        }\\n        else if (rank[xset] > rank[yset]) {\\n            parent[yset] = xset;\\n        }\\n        else {\\n            parent[yset] = xset;\\n            rank[xset] = rank[xset] + 1;\\n        }\\n    }\\n};\\n \\n\\nclass Solution {\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& res, vector<vector<int>>& req) {\\n        dsu obj(n);\\n        obj.makeSet();\\n        vector<bool> ans;\\n        for(int i = 0; i < req.size();i++){\\n   int x= obj.par(req[i][0]);\\n                int y = obj.par(req[i][1]);\\n            bool b = true;\\n            for(int j = 0; j < res.size();j++){\\n                int x1 = obj.par(res[j][0]);\\n                int y1 = obj.par(res[j][1]);\\n                if((x==x1&&y==y1)||(x==y1&&y==x1)){\\n                    b = false;\\n                    break;\\n                }\\n            }\\n            if(b){\\n                ans.push_back(true);\\n                obj.unions(req[i][0],req[i][1]);\\n            }\\n            else{\\n                ans.push_back(false);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2184069,
                "title": "better-than-100-of-solns",
                "content": "Plain union find - `323 ms`\\n```\\nclass Solution(object):\\n    def friendRequests(self, n, restrictions, requests):\\n        \"\"\"\\n        :type n: int\\n        :type restrictions: List[List[int]]\\n        :type requests: List[List[int]]\\n        :rtype: List[bool]\\n        \"\"\"\\n        p = {i:i for i in range(n)}\\n        \\n        def find(x):\\n            ox = x\\n            while p[x] != x:\\n                x = p[x]\\n            p[ox] = x\\n            return x\\n        \\n        bl = defaultdict(set)\\n        ans = []\\n        for ri, rj in restrictions:\\n            bl[ri].add(rj)\\n            bl[rj].add(ri)\\n        for ri, rj in requests:\\n            rpi, rpj = find(ri), find(rj)\\n            if rpi == rpj:\\n                ans.append(True)\\n            else:\\n                cc = rpj not in bl[rpi]\\n                if cc:\\n                    p[rpj] = rpi\\n                    bl[rpi] = bl[rpi].union(bl[rpj])\\n                    for i in bl[rpj]:\\n                        bl[i].add(rpi)\\n                ans.append(cc)\\n            \\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Union Find"
                ],
                "code": "```\\nclass Solution(object):\\n    def friendRequests(self, n, restrictions, requests):\\n        \"\"\"\\n        :type n: int\\n        :type restrictions: List[List[int]]\\n        :type requests: List[List[int]]\\n        :rtype: List[bool]\\n        \"\"\"\\n        p = {i:i for i in range(n)}\\n        \\n        def find(x):\\n            ox = x\\n            while p[x] != x:\\n                x = p[x]\\n            p[ox] = x\\n            return x\\n        \\n        bl = defaultdict(set)\\n        ans = []\\n        for ri, rj in restrictions:\\n            bl[ri].add(rj)\\n            bl[rj].add(ri)\\n        for ri, rj in requests:\\n            rpi, rpj = find(ri), find(rj)\\n            if rpi == rpj:\\n                ans.append(True)\\n            else:\\n                cc = rpj not in bl[rpi]\\n                if cc:\\n                    p[rpj] = rpi\\n                    bl[rpi] = bl[rpi].union(bl[rpj])\\n                    for i in bl[rpj]:\\n                        bl[i].add(rpi)\\n                ans.append(cc)\\n            \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2065134,
                "title": "java-solution-with-union-find",
                "content": "```\\nclass Solution {\\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        UnionFind uf = new UnionFind(n);\\n        \\n        boolean[] result = new boolean[requests.length];\\n        Arrays.fill(result, false);\\n        \\n        int i = 0;\\n        for (int[] request: requests) {\\n            int x = request[0];\\n            int y = request[1];\\n            \\n            result[i] = uf.union(x, y, restrictions);\\n            \\n            i += 1;\\n        }\\n        \\n        return result;\\n    }\\n}\\n\\nclass UnionFind {\\n    int[] parents;\\n    int[] ranks;\\n\\n    public UnionFind(int n) {\\n        this.parents = new int[n];\\n        this.ranks = new int[n];\\n\\n        for (int i = 0; i < n; i++) {\\n            this.parents[i] = i;\\n            this.ranks[i] = 1;\\n        }\\n    }\\n\\n    public int find(int x) {\\n        if (parents[x] != x) parents[x] = find(parents[x]);\\n\\n        return parents[x];\\n    }\\n\\n    public boolean union(int x, int y, int[][] restrictions) {\\n        int xRoot = find(x);\\n        int yRoot = find(y);\\n\\n        // Skip union if they already in the same group.\\n        if (xRoot == yRoot) return true;\\n        \\n        for (int[] restriction: restrictions) {\\n            int u = restriction[0];\\n            int v = restriction[1];\\n            int uRoot = find(u);\\n            int vRoot = find(v);\\n            \\n            if ((uRoot == yRoot && vRoot == xRoot) || (uRoot == xRoot && vRoot == yRoot)) {\\n                return false;\\n            }\\n        }\\n\\n        if (ranks[xRoot] < ranks[yRoot]) {\\n            parents[xRoot] = yRoot;\\n        } else {\\n            parents[yRoot] = xRoot;\\n        }\\n\\n        if (ranks[xRoot] == ranks[yRoot]) {\\n            ranks[xRoot]++;\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        UnionFind uf = new UnionFind(n);\\n        \\n        boolean[] result = new boolean[requests.length];\\n        Arrays.fill(result, false);\\n        \\n        int i = 0;\\n        for (int[] request: requests) {\\n            int x = request[0];\\n            int y = request[1];\\n            \\n            result[i] = uf.union(x, y, restrictions);\\n            \\n            i += 1;\\n        }\\n        \\n        return result;\\n    }\\n}\\n\\nclass UnionFind {\\n    int[] parents;\\n    int[] ranks;\\n\\n    public UnionFind(int n) {\\n        this.parents = new int[n];\\n        this.ranks = new int[n];\\n\\n        for (int i = 0; i < n; i++) {\\n            this.parents[i] = i;\\n            this.ranks[i] = 1;\\n        }\\n    }\\n\\n    public int find(int x) {\\n        if (parents[x] != x) parents[x] = find(parents[x]);\\n\\n        return parents[x];\\n    }\\n\\n    public boolean union(int x, int y, int[][] restrictions) {\\n        int xRoot = find(x);\\n        int yRoot = find(y);\\n\\n        // Skip union if they already in the same group.\\n        if (xRoot == yRoot) return true;\\n        \\n        for (int[] restriction: restrictions) {\\n            int u = restriction[0];\\n            int v = restriction[1];\\n            int uRoot = find(u);\\n            int vRoot = find(v);\\n            \\n            if ((uRoot == yRoot && vRoot == xRoot) || (uRoot == xRoot && vRoot == yRoot)) {\\n                return false;\\n            }\\n        }\\n\\n        if (ranks[xRoot] < ranks[yRoot]) {\\n            parents[xRoot] = yRoot;\\n        } else {\\n            parents[yRoot] = xRoot;\\n        }\\n\\n        if (ranks[xRoot] == ranks[yRoot]) {\\n            ranks[xRoot]++;\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2044472,
                "title": "c-union-find-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int find(vector<int> &par,int u)\\n    {\\n        if(u==par[u])\\n            return u;\\n        return par[u]=find(par,par[u]);\\n    }\\n    void merge(vector<int> &par,int u,int v)\\n    {\\n        int pu=find(par,u);\\n        int pv=find(par,v);\\n        \\n        par[pv]=pu;\\n    }\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests)\\n    {\\n        int m=requests.size();\\n        vector<bool> ans(m,true);\\n        vector<int> par(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            par[i]=i;\\n        }\\n        for(int i=0;i<requests.size();i++)\\n        {\\n            int p=find(par,requests[i][0]);\\n            int q=find(par,requests[i][1]);\\n            if(!(find(par,p)==find(par,q)))\\n            {\\n                for(auto &rs:restrictions )\\n                {\\n                    int x=find(par,rs[0]),y=find(par,rs[1]);\\n                    {\\n                        if((x==p&&y==q)||(x==q&&y==p))\\n                        {\\n                            ans[i]=false;\\n                            break;\\n                        }\\n                    }\\n                }\\n                if(ans[i])\\n                {\\n                    merge(par ,p,q);\\n                }\\n            }\\n            \\n        }\\n        return ans;\\n        \\n    }\\n};\\n// if you like the solution plz upvote.",
                "solutionTags": [
                    "C",
                    "Union Find"
                ],
                "code": "class Solution {\\npublic:\\n    int find(vector<int> &par,int u)\\n    {\\n        if(u==par[u])\\n            return u;\\n        return par[u]=find(par,par[u]);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1931426,
                "title": "python-union-find-best-solution",
                "content": "```\\nclass Solution:\\n    def friendRequests(self, n: int, restrictions: List[List[int]], requests: List[List[int]]) -> List[bool]:\\n        uf = {i:i for i in range(n)}\\n        ans = [None] * len(requests)\\n        \\n        def find(i):\\n            if uf[i] != i:\\n                uf[i] = find(uf[i])\\n            return uf[i]\\n        \\n        def union(i, j):\\n            uf[find(i)] = uf[find(j)]\\n        \\n        for i, (p1, p2) in enumerate(requests):\\n            foundSet = set([find(p1), find(p2)])\\n            ans[i] = not any(find(r1) in foundSet and find(r2) in foundSet \\\\\\n                        for (r1, r2) in restrictions)\\n            \\n            if ans[i] == True:\\n                union(p1, p2)\\n    \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def friendRequests(self, n: int, restrictions: List[List[int]], requests: List[List[int]]) -> List[bool]:\\n        uf = {i:i for i in range(n)}\\n        ans = [None] * len(requests)\\n        \\n        def find(i):\\n            if uf[i] != i:\\n                uf[i] = find(uf[i])\\n            return uf[i]\\n        \\n        def union(i, j):\\n            uf[find(i)] = uf[find(j)]\\n        \\n        for i, (p1, p2) in enumerate(requests):\\n            foundSet = set([find(p1), find(p2)])\\n            ans[i] = not any(find(r1) in foundSet and find(r2) in foundSet \\\\\\n                        for (r1, r2) in restrictions)\\n            \\n            if ans[i] == True:\\n                union(p1, p2)\\n    \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1722288,
                "title": "python-union-find-with-detailed-explanation",
                "content": "Use the union find algorithm. The critical part is all about the restrictions. When there are too many people and too many restrictions, it will be time-consuming to check each restriction, before answering a request. We know that union is kind of a hierarchy system, where everyone has a supervisor (better than the usually known \"parent\").\\n\\nIt would good to let the supervisors to handle the restrictions. If A dislike B, let A\\'s supervisor dislike B\\'s supervisor. Since initially everyone supervises oneself, the given restrictions are a good start. We build a Hash map to handle the restrictions. \\n\\nFor a coming request, we only check the two supervisors. If they do not dislike each other, the relation can be built\\nand call union()! During the union process, one supervisor SA retires and the other supervisor SB remains, and also supervises SA. In addition to the union itself, there are two important things to do:\\n1) Go through everyone that SA dislikes, let each dislike SB (, who now supervises SA), instead of SA.\\n2) SB should take all the restrictions that SA are involved in. One can pop SA from the map, since he  does not bother this kind of nonsense any more. \\n\\n```\\nclass Solution:\\n    def friendRequests(self, n: int, restrictions: List[List[int]], requests: List[List[int]]) -> List[bool]:\\n        rst = defaultdict(set)\\n        for a, b in restrictions:\\n            rst[a].add(b)\\n            rst[b].add(a)\\n        del restrictions\\n        ans = []\\n        supervisor = [i for i in range(n)]\\n        def find(x):\\n            if supervisor[x] == x:\\n                return x\\n            else:\\n                supervisor[x] = find(supervisor[x])\\n                return supervisor[x]\\n\\n        def union(x, y):                # the method is more than the conventional union() method\\n            x, y = find(x), find(y)\\n            if x > y:\\n                x, y = y, x\\n            supervisor[y] = x           # \"y\", who was a supervisor, retires. \"x\" becomes his supervisor.\\n            rst[y] = rst.get(y, set())  # persons who \"y\", as well as his group, does not like\\n            for z in rst[y]:            # for each of those persons\\n                rst[z].remove(y)        # stop hating \"y\"\\n                rst[z].add(x)           # hate his supervisor instead\\n            if x not in rst:            # \"x\" consider everyone who \"y\" and his group do not like\\n                rst[x] = set()\\n            rst[x] |= rst.pop(y)\\n            return\\n\\t\\t\\t\\n        for a, b in requests:               # process each request\\n            sa, sb = find(a), find(b)       # approach the two supervisors\\n            if sa == sb:                    # they are the same, meaning that a and b are already friends\\n                ans.append(True)\\n            elif sb in rst.get(sa, set()):  # if the supervisors do not permit\\n                ans.append(False)\\n            else:                           # if the supervisors permit\\n                ans.append(True)\\n                union(a, b)                 # build the relation\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def friendRequests(self, n: int, restrictions: List[List[int]], requests: List[List[int]]) -> List[bool]:\\n        rst = defaultdict(set)\\n        for a, b in restrictions:\\n            rst[a].add(b)\\n            rst[b].add(a)\\n        del restrictions\\n        ans = []\\n        supervisor = [i for i in range(n)]\\n        def find(x):\\n            if supervisor[x] == x:\\n                return x\\n            else:\\n                supervisor[x] = find(supervisor[x])\\n                return supervisor[x]\\n\\n        def union(x, y):                # the method is more than the conventional union() method\\n            x, y = find(x), find(y)\\n            if x > y:\\n                x, y = y, x\\n            supervisor[y] = x           # \"y\", who was a supervisor, retires. \"x\" becomes his supervisor.\\n            rst[y] = rst.get(y, set())  # persons who \"y\", as well as his group, does not like\\n            for z in rst[y]:            # for each of those persons\\n                rst[z].remove(y)        # stop hating \"y\"\\n                rst[z].add(x)           # hate his supervisor instead\\n            if x not in rst:            # \"x\" consider everyone who \"y\" and his group do not like\\n                rst[x] = set()\\n            rst[x] |= rst.pop(y)\\n            return\\n\\t\\t\\t\\n        for a, b in requests:               # process each request\\n            sa, sb = find(a), find(b)       # approach the two supervisors\\n            if sa == sb:                    # they are the same, meaning that a and b are already friends\\n                ans.append(True)\\n            elif sb in rst.get(sa, set()):  # if the supervisors do not permit\\n                ans.append(False)\\n            else:                           # if the supervisors permit\\n                ans.append(True)\\n                union(a, b)                 # build the relation\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1688368,
                "title": "python-unionfind-87-faster-avg-o-e-r-with-explaination",
                "content": "Correct me if I am wrong but the time complexity I think would be O(N + ER) on worst case and O(N+E+R) on average case where E is number of requests and R is number of restrictions. And the space complexity is O(N+R). Basically we will keep track of all the root of restrictions from in each root node in union find. \\n\\nWhen we are adding (x, y) the request we will check if there is restriction between root_of_x and root_of_y. If there are restrictions we will return False.\\n\\nIf nodes can be friends, we will add those nodes by union by rank and keep track of root and child between those root_of_x and root_of_y.\\n\\nSuppose when we did the union root = root_of_x and child = root_of_y, then, we will loop through all the restrictions in root_of_y and try to find their root in the graph and add that root to the restriction of root_of_x. Then we will delete the restriction of root_of_y.\\n\\nThis way when we are doing union, the restrictions will be merged. \\n```\\nclass Solution:\\n    def friendRequests(self, n: int, restrictions: List[List[int]], requests: List[List[int]]) -> List[bool]:\\n        \\n        union_find = UnionFind(n, restrictions)\\n        result = []\\n        for u, v in requests:\\n            if union_find.union(u, v):\\n                result.append(True)\\n            else:\\n                result.append(False)\\n        return result\\n            \\nclass UnionFind:\\n    def __init__(self, n, restricts):\\n        self.root = [i for i in range(n)]\\n        self.rank = [1 for i in range(n)]\\n        self.restrictions = {}\\n        for u, v in restricts:\\n            if u not in self.restrictions:\\n                self.restrictions[u] = set()\\n            if v not in self.restrictions:\\n                self.restrictions[v] = set()\\n            self.restrictions[u].add(v)\\n            self.restrictions[v].add(u)\\n        \\n    def find(self, x):\\n        if self.root[x] != x:\\n            self.root[x] = self.find(self.root[x])\\n        return self.root[x]\\n    def union(self, x, y):\\n        root_x = self.find(x)\\n        root_y = self.find(y)\\n        if (root_x in self.restrictions and root_y in self.restrictions[root_x]) or (root_y in self.restrictions and root_x in self.restrictions[root_y]):\\n            return False\\n        \\n        if root_x != root_y:\\n            root, child = root_y, root_x\\n            if self.rank[root_x] < self.rank[root_y]:\\n                self.root[root_x] = root_y\\n            elif self.rank[root_y] < self.rank[root_x]:\\n                self.root[root_y] = root_x\\n                root, child = root_x, root_y\\n            else:\\n                self.root[root_x] = root_y\\n                self.rank[root_y] += 1\\n            if child in self.restrictions:\\n                for rest in self.restrictions[child]:\\n                    if root not in self.restrictions:\\n                        self.restrictions[root] = set()\\n                    self.restrictions[root].add(self.find(rest))\\n                del self.restrictions[child]\\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Union Find"
                ],
                "code": "```\\nclass Solution:\\n    def friendRequests(self, n: int, restrictions: List[List[int]], requests: List[List[int]]) -> List[bool]:\\n        \\n        union_find = UnionFind(n, restrictions)\\n        result = []\\n        for u, v in requests:\\n            if union_find.union(u, v):\\n                result.append(True)\\n            else:\\n                result.append(False)\\n        return result\\n            \\nclass UnionFind:\\n    def __init__(self, n, restricts):\\n        self.root = [i for i in range(n)]\\n        self.rank = [1 for i in range(n)]\\n        self.restrictions = {}\\n        for u, v in restricts:\\n            if u not in self.restrictions:\\n                self.restrictions[u] = set()\\n            if v not in self.restrictions:\\n                self.restrictions[v] = set()\\n            self.restrictions[u].add(v)\\n            self.restrictions[v].add(u)\\n        \\n    def find(self, x):\\n        if self.root[x] != x:\\n            self.root[x] = self.find(self.root[x])\\n        return self.root[x]\\n    def union(self, x, y):\\n        root_x = self.find(x)\\n        root_y = self.find(y)\\n        if (root_x in self.restrictions and root_y in self.restrictions[root_x]) or (root_y in self.restrictions and root_x in self.restrictions[root_y]):\\n            return False\\n        \\n        if root_x != root_y:\\n            root, child = root_y, root_x\\n            if self.rank[root_x] < self.rank[root_y]:\\n                self.root[root_x] = root_y\\n            elif self.rank[root_y] < self.rank[root_x]:\\n                self.root[root_y] = root_x\\n                root, child = root_x, root_y\\n            else:\\n                self.root[root_x] = root_y\\n                self.rank[root_y] += 1\\n            if child in self.restrictions:\\n                for rest in self.restrictions[child]:\\n                    if root not in self.restrictions:\\n                        self.restrictions[root] = set()\\n                    self.restrictions[root].add(self.find(rest))\\n                del self.restrictions[child]\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1654430,
                "title": "c-dsu-check-in-restriction-before-allowing-them-to-be-friends",
                "content": "```cpp\\nclass DSU {\\npublic:\\n    vector<int> parent, rank;\\n    DSU(int N) {\\n        for (int i = 0; i < N + 5; ++i) {\\n            parent.push_back(i);\\n            rank.push_back(1);\\n        }\\n    }\\n    \\n    int find(int u) {\\n        if (parent[u] == u) return u;\\n        return parent[u] = find(parent[u]);\\n    }\\n    \\n    void merge(int x, int y) {\\n        int rootX = find(x);\\n        int rootY = find(y);\\n        if (rootX == rootY) return ;\\n        if (rank[rootX] >= rank[rootY]) {\\n            parent[rootY] = rootX;\\n            rank[rootX] += rank[rootY];\\n        } else {\\n            parent[rootX] = rootY;\\n            rank[rootY] += rank[rootX];\\n        }\\n    }\\n    \\n    bool isConnected(int x, int y) {\\n        return find(x) == find(y);\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        DSU dsu(n);\\n        vector<bool> res;\\n        for (const auto &req: requests) {\\n            int p1 = dsu.find(req[0]);\\n            int p2 = dsu.find(req[1]);\\n            //If they are friends, then they will always be friends\\n            if(p1 == p2) {\\n                res.push_back(true);\\n                continue;\\n            }\\n            bool flag = true;\\n            for(const auto &rest : restrictions) {\\n                int x1 = dsu.find(rest[0]);\\n                int x2 = dsu.find(rest[1]);\\n\\t\\t\\t\\t//Since in DSU, parents can also be reversed\\n\\t\\t\\t\\t//hence we check for the reverse as well\\n                if(p1 == x1 && p2 == x2 || p1 == x2 && p2 == x1) {\\n                    flag = false;\\n                    break;\\n                } \\n            }\\n            if(flag) {\\n                dsu.merge(req[0], req[1]);\\n            }\\n            res.push_back(flag);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass DSU {\\npublic:\\n    vector<int> parent, rank;\\n    DSU(int N) {\\n        for (int i = 0; i < N + 5; ++i) {\\n            parent.push_back(i);\\n            rank.push_back(1);\\n        }\\n    }\\n    \\n    int find(int u) {\\n        if (parent[u] == u) return u;\\n        return parent[u] = find(parent[u]);\\n    }\\n    \\n    void merge(int x, int y) {\\n        int rootX = find(x);\\n        int rootY = find(y);\\n        if (rootX == rootY) return ;\\n        if (rank[rootX] >= rank[rootY]) {\\n            parent[rootY] = rootX;\\n            rank[rootX] += rank[rootY];\\n        } else {\\n            parent[rootX] = rootY;\\n            rank[rootY] += rank[rootX];\\n        }\\n    }\\n    \\n    bool isConnected(int x, int y) {\\n        return find(x) == find(y);\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        DSU dsu(n);\\n        vector<bool> res;\\n        for (const auto &req: requests) {\\n            int p1 = dsu.find(req[0]);\\n            int p2 = dsu.find(req[1]);\\n            //If they are friends, then they will always be friends\\n            if(p1 == p2) {\\n                res.push_back(true);\\n                continue;\\n            }\\n            bool flag = true;\\n            for(const auto &rest : restrictions) {\\n                int x1 = dsu.find(rest[0]);\\n                int x2 = dsu.find(rest[1]);\\n\\t\\t\\t\\t//Since in DSU, parents can also be reversed\\n\\t\\t\\t\\t//hence we check for the reverse as well\\n                if(p1 == x1 && p2 == x2 || p1 == x2 && p2 == x1) {\\n                    flag = false;\\n                    break;\\n                } \\n            }\\n            if(flag) {\\n                dsu.merge(req[0], req[1]);\\n            }\\n            res.push_back(flag);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1587911,
                "title": "python-unionfind-concise-solution",
                "content": "```\\nclass Solution:\\n    def friendRequests(self, n: int, restrictions: List[List[int]], requests: List[List[int]]) -> List[bool]:\\n        size = [1] * (n + 1)\\n        uf = [i for i in range(n+1)]\\n        \\n        def union(f, s):\\n            root_f, root_s = find(f), find(s)\\n            \\n\\t\\t\\t# loop over restrictions and return False if find any.\\n            for item in restrictions:\\n                cur_root = (find(item[0]), find(item[1]))\\n                if cur_root == (root_f, root_s) or cur_root == (root_s, root_f):\\n                    return False\\n\\t\\t\\t\\t\\t\\n            # does not find any rstriction, union input and return True.\\n            if size[root_f] >= size[root_s]:\\n                uf[root_s] = root_f\\n                size[root_f] += size[root_s]\\n            else:\\n                uf[root_f] = root_s\\n                size[root_s] += size[root_f]\\n            \\n            return True\\n        \\n        def find(node):\\n            while uf[node] != node:\\n                node = uf[node]\\n            \\n            return node\\n        \\n        res = []\\n        for s, t  in requests:\\n            res.append(union(s, t))\\n        \\n        return res\\n            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def friendRequests(self, n: int, restrictions: List[List[int]], requests: List[List[int]]) -> List[bool]:\\n        size = [1] * (n + 1)\\n        uf = [i for i in range(n+1)]\\n        \\n        def union(f, s):\\n            root_f, root_s = find(f), find(s)\\n            \\n\\t\\t\\t# loop over restrictions and return False if find any.\\n            for item in restrictions:\\n                cur_root = (find(item[0]), find(item[1]))\\n                if cur_root == (root_f, root_s) or cur_root == (root_s, root_f):\\n                    return False\\n\\t\\t\\t\\t\\t\\n            # does not find any rstriction, union input and return True.\\n            if size[root_f] >= size[root_s]:\\n                uf[root_s] = root_f\\n                size[root_f] += size[root_s]\\n            else:\\n                uf[root_f] = root_s\\n                size[root_s] += size[root_f]\\n            \\n            return True\\n        \\n        def find(node):\\n            while uf[node] != node:\\n                node = uf[node]\\n            \\n            return node\\n        \\n        res = []\\n        for s, t  in requests:\\n            res.append(union(s, t))\\n        \\n        return res\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1581175,
                "title": "dsu-union-by-size-java",
                "content": "```\\nclass Solution {\\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        Dsu dsu = new Dsu(n);\\n        \\n        boolean[] ans = new boolean[requests.length];\\n        int i=0;\\n        \\n        for(int[]x : requests){\\n            int pu = dsu.findpar(x[0]);\\n            int pv= dsu.findpar(x[1]);\\n            boolean fl = true;\\n            if(pu!=pv){\\n                for(int[] x2:restrictions){\\n                    int pu1 = dsu.findpar(x2[0]);\\n                    int pv1 = dsu.findpar(x2[1]);\\n                    \\n                    if((pu == pu1 && pv == pv1) || (pu == pv1 && pv ==pu1)){\\n                        fl = false;\\n                        break;\\n                    }\\n                }\\n                if(fl){\\n                    dsu.union(pu,pv);\\n                }\\n               \\n            }\\n            ans[i++] = fl;\\n        }\\n        return ans;\\n    }\\n}\\nclass Dsu{\\n    int[] parent = new int[1000];\\n    int[]size = new int[1000];\\n    \\n    Dsu(int n){\\n        \\n        for(int i=0;i<n;i++){\\n            parent[i] = i;\\n            size[i] = 0;\\n        }\\n    }\\n    \\n    public int findpar(int n){\\n        if(parent[n] == n)return n;\\n        return parent[n] = findpar(parent[n]);\\n    }\\n    \\n    public void union(int u ,int v){\\n        int pu = findpar(u);\\n        int pv = findpar(v);\\n        \\n        if(pu==pv)return;\\n        \\n        if(size[pu]<size[pv]){\\n            parent[pu]=pv;\\n            size[pv] += size[pu];\\n        }else{\\n            parent[pv] = pu;\\n            size[pu] += size[pv];\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        Dsu dsu = new Dsu(n);\\n        \\n        boolean[] ans = new boolean[requests.length];\\n        int i=0;\\n        \\n        for(int[]x : requests){\\n            int pu = dsu.findpar(x[0]);\\n            int pv= dsu.findpar(x[1]);\\n            boolean fl = true;\\n            if(pu!=pv){\\n                for(int[] x2:restrictions){\\n                    int pu1 = dsu.findpar(x2[0]);\\n                    int pv1 = dsu.findpar(x2[1]);\\n                    \\n                    if((pu == pu1 && pv == pv1) || (pu == pv1 && pv ==pu1)){\\n                        fl = false;\\n                        break;\\n                    }\\n                }\\n                if(fl){\\n                    dsu.union(pu,pv);\\n                }\\n               \\n            }\\n            ans[i++] = fl;\\n        }\\n        return ans;\\n    }\\n}\\nclass Dsu{\\n    int[] parent = new int[1000];\\n    int[]size = new int[1000];\\n    \\n    Dsu(int n){\\n        \\n        for(int i=0;i<n;i++){\\n            parent[i] = i;\\n            size[i] = 0;\\n        }\\n    }\\n    \\n    public int findpar(int n){\\n        if(parent[n] == n)return n;\\n        return parent[n] = findpar(parent[n]);\\n    }\\n    \\n    public void union(int u ,int v){\\n        int pu = findpar(u);\\n        int pv = findpar(v);\\n        \\n        if(pu==pv)return;\\n        \\n        if(size[pu]<size[pv]){\\n            parent[pu]=pv;\\n            size[pv] += size[pu];\\n        }else{\\n            parent[pv] = pu;\\n            size[pu] += size[pv];\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1580287,
                "title": "java-unin-find-try-to-connect-then-find-violation",
                "content": "This is a regular `union find set` approach, try to connect two persons in each request, then check if the new connection violates the `restrictions` array.\\n```\\nclass Solution {\\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        boolean[] res = new boolean[requests.length];\\n        \\n        int[] friends = new int[n];\\n        \\n        for (int i = 0; i < n; i++) {\\n            friends[i] = i;\\n        }\\n        \\n        for (int i = 0; i < requests.length; i++) {\\n            int rootA = friends[requests[i][0]];\\n            int rootB = friends[requests[i][1]];\\n            \\n            if (rootA == rootB) {\\n                res[i] = true;\\n                continue;\\n            }\\n            \\n            int[] friendsCopy = tryConnect(friends, rootA, rootB);\\n            \\n            if (isValid(friendsCopy, restrictions)) {\\n                res[i] = true;\\n                friends = friendsCopy;\\n            } else {\\n                res[i] = false;\\n            }\\n        } \\n        \\n        return res;\\n    }\\n    \\n    private int[] tryConnect(int[] friends, int rootA, int rootB) {\\n        // try on a cloned array rather than in place\\n\\t\\tint n = friends.length;\\n        int[] friendsCopy = new int[n];\\n        \\n        for (int i = 0; i < n; i++) {\\n            if(friends[i] == rootA) {\\n                friendsCopy[i] = rootB;\\n            } else {\\n                friendsCopy[i] = friends[i];\\n            }\\n        }\\n        \\n        return friendsCopy;\\n    }\\n    \\n    private boolean isValid(int[] friends, int[][] restrictions) {\\n        for (int[] restriction: restrictions) {\\n            int personA = restriction[0];\\n            int personB = restriction[1];\\n            if (friends[personA] == friends[personB]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        boolean[] res = new boolean[requests.length];\\n        \\n        int[] friends = new int[n];\\n        \\n        for (int i = 0; i < n; i++) {\\n            friends[i] = i;\\n        }\\n        \\n        for (int i = 0; i < requests.length; i++) {\\n            int rootA = friends[requests[i][0]];\\n            int rootB = friends[requests[i][1]];\\n            \\n            if (rootA == rootB) {\\n                res[i] = true;\\n                continue;\\n            }\\n            \\n            int[] friendsCopy = tryConnect(friends, rootA, rootB);\\n            \\n            if (isValid(friendsCopy, restrictions)) {\\n                res[i] = true;\\n                friends = friendsCopy;\\n            } else {\\n                res[i] = false;\\n            }\\n        } \\n        \\n        return res;\\n    }\\n    \\n    private int[] tryConnect(int[] friends, int rootA, int rootB) {\\n        // try on a cloned array rather than in place\\n\\t\\tint n = friends.length;\\n        int[] friendsCopy = new int[n];\\n        \\n        for (int i = 0; i < n; i++) {\\n            if(friends[i] == rootA) {\\n                friendsCopy[i] = rootB;\\n            } else {\\n                friendsCopy[i] = friends[i];\\n            }\\n        }\\n        \\n        return friendsCopy;\\n    }\\n    \\n    private boolean isValid(int[] friends, int[][] restrictions) {\\n        for (int[] restriction: restrictions) {\\n            int personA = restriction[0];\\n            int personB = restriction[1];\\n            if (friends[personA] == friends[personB]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1580232,
                "title": "c-dsu-with-comments-easy-to-understand",
                "content": "```\\nclass DSU{\\nprivate:\\n    vector<int> parent,rank;\\n\\npublic:\\n    DSU(int n){\\n        for(int i=0; i<n; i++){\\n            parent.push_back(-1); //can show seg fault if written like this parent[i] = -1;\\n            rank.push_back(0);    // same goes for this\\n        }\\n    }\\n\\n    int find(int i){\\n        if(parent[i]==-1){\\n            return i;\\n        }\\n        return parent[i] = find(parent[i]);\\n    }\\n\\n    void Union(int a, int b){\\n        int s1 = find(a);\\n        int s2 = find(b);\\n\\n        if(s1!=s2){\\n            if(rank[s1] >= rank[s2]){\\n                parent[s2] = s1;\\n                rank[s1] += rank[s2];\\n            }\\n            else{\\n                parent[s1] = s2;\\n                rank[s2] += rank[s1];\\n            }\\n        }\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        DSU d(n);\\n        vector<bool> ans;\\n        \\n        //CONCEPT:- My enemy\\'s enemy is my friend\\n        for(int i=0; i<requests.size(); i++){\\n            DSU t = d;  //copy the previous dsu to check that the current request will be accepted or not\\n            t.Union(requests[i][0],requests[i][1]);\\n            bool flag = false;\\n            \\n            for(auto &it: restrictions){\\n                if(t.find(it[0]) == t.find(it[1])){ //check that would there be any restriction which we had \\n                    flag = true;                    //accepted but not supposed to be accepted\\n                    break;\\n                }\\n            }\\n            \\n            if(flag==false){\\n                d.Union(requests[i][0],requests[i][1]); //request approved -> true/ change in main dsu\\n                ans.push_back(true);\\n            }\\n            else{\\n                ans.push_back(false); //request rejected -> false/ no need to change main dsu\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass DSU{\\nprivate:\\n    vector<int> parent,rank;\\n\\npublic:\\n    DSU(int n){\\n        for(int i=0; i<n; i++){\\n            parent.push_back(-1); //can show seg fault if written like this parent[i] = -1;\\n            rank.push_back(0);    // same goes for this\\n        }\\n    }\\n\\n    int find(int i){\\n        if(parent[i]==-1){\\n            return i;\\n        }\\n        return parent[i] = find(parent[i]);\\n    }\\n\\n    void Union(int a, int b){\\n        int s1 = find(a);\\n        int s2 = find(b);\\n\\n        if(s1!=s2){\\n            if(rank[s1] >= rank[s2]){\\n                parent[s2] = s1;\\n                rank[s1] += rank[s2];\\n            }\\n            else{\\n                parent[s1] = s2;\\n                rank[s2] += rank[s1];\\n            }\\n        }\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        DSU d(n);\\n        vector<bool> ans;\\n        \\n        //CONCEPT:- My enemy\\'s enemy is my friend\\n        for(int i=0; i<requests.size(); i++){\\n            DSU t = d;  //copy the previous dsu to check that the current request will be accepted or not\\n            t.Union(requests[i][0],requests[i][1]);\\n            bool flag = false;\\n            \\n            for(auto &it: restrictions){\\n                if(t.find(it[0]) == t.find(it[1])){ //check that would there be any restriction which we had \\n                    flag = true;                    //accepted but not supposed to be accepted\\n                    break;\\n                }\\n            }\\n            \\n            if(flag==false){\\n                d.Union(requests[i][0],requests[i][1]); //request approved -> true/ change in main dsu\\n                ans.push_back(true);\\n            }\\n            else{\\n                ans.push_back(false); //request rejected -> false/ no need to change main dsu\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1579739,
                "title": "if-anyone-gets-tle-make-sure-to-do-this-optimization",
                "content": "If someone is getting tle ,make sure to iterate using refrence in for each loop.\\n```\\nclass union_find\\n{\\n\\tvector<int>par;\\n\\tvector<int>sz;\\npublic:\\n\\tunion_find(int n){\\n        par.resize(n);\\n        sz.resize(n);\\n        for(int i=0;i<n;i++){\\n        \\tpar[i]=i;\\n        \\tsz[i]=1;\\n        }\\n\\t}\\n\\tint find(int x){\\n\\t\\tif(par[x]==x)\\n\\t\\t\\treturn x;\\n\\t\\treturn par[x]=find(par[x]);\\n\\t}\\n\\tvoid unite(int u,int v){\\n\\t\\tint a=find(u);\\n\\t\\tint b=find(v);\\n\\t\\tif(not (a==b)){\\n\\t\\t\\tif(sz[a]<sz[b]){\\n\\t\\t\\t\\tpar[a]=b;\\n\\t\\t\\t\\tsz[b]+=sz[a];\\n\\t\\t\\t}else {\\n\\t\\t\\t\\tpar[b]=a;\\n\\t\\t\\t\\tsz[a]+=sz[b];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n};\\nclass Solution {\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        union_find un(n);\\n        vector<bool>res;\\n        for(auto &i:requests){  // & (refrence) is making the code faster, without using this i was getting tle on the same code.\\n            int u=un.find(i[0]);\\n            int v=un.find(i[1]);\\n            bool val=true;\\n            if(not (u==v)){\\n                for(auto &j:restrictions){    // & (refrence) is making the code faster\\n                    int x=un.find(j[0]),y=un.find(j[1]);\\n                    if((u==x&&v==y)||(u==y&&v==x)){\\n                        val=false;\\n                        break;\\n                    }\\n                }\\n            }\\n            if(val){\\n                un.unite(u,v);\\n            }\\n            res.push_back(val);\\n        }\\n        return res;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass union_find\\n{\\n\\tvector<int>par;\\n\\tvector<int>sz;\\npublic:\\n\\tunion_find(int n){\\n        par.resize(n);\\n        sz.resize(n);\\n        for(int i=0;i<n;i++){\\n        \\tpar[i]=i;\\n        \\tsz[i]=1;\\n        }\\n\\t}\\n\\tint find(int x){\\n\\t\\tif(par[x]==x)\\n\\t\\t\\treturn x;\\n\\t\\treturn par[x]=find(par[x]);\\n\\t}\\n\\tvoid unite(int u,int v){\\n\\t\\tint a=find(u);\\n\\t\\tint b=find(v);\\n\\t\\tif(not (a==b)){\\n\\t\\t\\tif(sz[a]<sz[b]){\\n\\t\\t\\t\\tpar[a]=b;\\n\\t\\t\\t\\tsz[b]+=sz[a];\\n\\t\\t\\t}else {\\n\\t\\t\\t\\tpar[b]=a;\\n\\t\\t\\t\\tsz[a]+=sz[b];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n};\\nclass Solution {\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        union_find un(n);\\n        vector<bool>res;\\n        for(auto &i:requests){  // & (refrence) is making the code faster, without using this i was getting tle on the same code.\\n            int u=un.find(i[0]);\\n            int v=un.find(i[1]);\\n            bool val=true;\\n            if(not (u==v)){\\n                for(auto &j:restrictions){    // & (refrence) is making the code faster\\n                    int x=un.find(j[0]),y=un.find(j[1]);\\n                    if((u==x&&v==y)||(u==y&&v==x)){\\n                        val=false;\\n                        break;\\n                    }\\n                }\\n            }\\n            if(val){\\n                un.unite(u,v);\\n            }\\n            res.push_back(val);\\n        }\\n        return res;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1577084,
                "title": "python3-concise-union-find",
                "content": "Time - O(len(requests) * len(restrictions) * (log len(requests))\\nSpace - O(len(n)\\n```\\nclass Solution:\\n    def friendRequests(self, n: int, restrictions: List[List[int]], requests: List[List[int]]) -> List[bool]:\\n        parent = [i for i in range(n)] # create parent array\\n        \\n        def findParent(i):\\n            p = parent[i] # iteratively groing through parent table until cell is a parent of itself\\n            while p!=parent[p]: p = parent[p]\\n            return p\\n        \\n        res = []\\n        for l, r in requests:\\n            lParent, rParent = findParent(l), findParent(r) # searching parent for both cells\\n            \\n            parent[lParent] = parent[rParent] = min(lParent, rParent) # applying change request\\n            \\n            blocked = False\\n            for rl, rr in restrictions:\\n                pl, pr = findParent(rl), findParent(rr) # searching the parent for both parts of restriction\\n                \\n                if pl == pr:  # if for any restriction parent is the same, rollback the request and mark as False\\n                    blocked = True\\n                    parent[lParent], parent[rParent] = lParent, rParent\\n                    break\\n            res.append(not blocked)\\n        \\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def friendRequests(self, n: int, restrictions: List[List[int]], requests: List[List[int]]) -> List[bool]:\\n        parent = [i for i in range(n)] # create parent array\\n        \\n        def findParent(i):\\n            p = parent[i] # iteratively groing through parent table until cell is a parent of itself\\n            while p!=parent[p]: p = parent[p]\\n            return p\\n        \\n        res = []\\n        for l, r in requests:\\n            lParent, rParent = findParent(l), findParent(r) # searching parent for both cells\\n            \\n            parent[lParent] = parent[rParent] = min(lParent, rParent) # applying change request\\n            \\n            blocked = False\\n            for rl, rr in restrictions:\\n                pl, pr = findParent(rl), findParent(rr) # searching the parent for both parts of restriction\\n                \\n                if pl == pr:  # if for any restriction parent is the same, rollback the request and mark as False\\n                    blocked = True\\n                    parent[lParent], parent[rParent] = lParent, rParent\\n                    break\\n            res.append(not blocked)\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1577012,
                "title": "why-did-my-c-union-find-solution-get-tle",
                "content": "My solution during the contest is similar to several solutions which got accepted. Is my Union find implementation slow?\\n```\\n//------DSU---------------------//\\n#define ll int\\nclass DSU\\n{\\n    public:\\n    vector <ll> parent,rnk;\\n    DSU(ll n)\\n    {\\n        parent.resize(n+5,0);\\n        rnk.resize(n+5,0);\\n        for(ll i=0;i<n+5;i++)\\n         parent[i]=i;\\n    }\\n    ll find_set(ll v)\\n    {\\n        if(parent[v]==v)\\n         return v;\\n        return parent[v]=find_set(parent[v]); \\n    }\\n    void union_sets(ll a,ll b)\\n    {\\n        a=find_set(a);\\n        b=find_set(b);\\n        if(a!=b)\\n        {\\n            if(rnk[a]<rnk[b])\\n            swap(a,b);\\n            parent[b]=a; \\n            if(rnk[a]==rnk[b])\\n             rnk[a]++; \\n        }\\n    }\\n};\\n//------DSU---------------------//\\nclass Solution {\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        DSU ds(n);\\n        vector <bool> ans;\\n        for(auto u:requests){\\n            int x=u[0],y=u[1];\\n            x=ds.find_set(x);\\n            y=ds.find_set(y);\\n            if(x==y){\\n                ans.push_back(true);\\n                continue;\\n            }\\n            bool flag=true;\\n            for(auto uu:restrictions){\\n                int p=ds.find_set(uu[0]);\\n                int q=ds.find_set(uu[1]);\\n                if((p==x and q==y) or (p==y and q==x)){\\n                    flag=false;\\n                    break;\\n                }\\n            }\\n            ans.push_back(flag);\\n            if(flag){\\n                ds.union_sets(x,y);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\\n\\nEdit: I found why I am getting TLE. I was creating copies of the vectors in restrictions everytime, because I was not iterating by reference.",
                "solutionTags": [],
                "code": "```\\n//------DSU---------------------//\\n#define ll int\\nclass DSU\\n{\\n    public:\\n    vector <ll> parent,rnk;\\n    DSU(ll n)\\n    {\\n        parent.resize(n+5,0);\\n        rnk.resize(n+5,0);\\n        for(ll i=0;i<n+5;i++)\\n         parent[i]=i;\\n    }\\n    ll find_set(ll v)\\n    {\\n        if(parent[v]==v)\\n         return v;\\n        return parent[v]=find_set(parent[v]); \\n    }\\n    void union_sets(ll a,ll b)\\n    {\\n        a=find_set(a);\\n        b=find_set(b);\\n        if(a!=b)\\n        {\\n            if(rnk[a]<rnk[b])\\n            swap(a,b);\\n            parent[b]=a; \\n            if(rnk[a]==rnk[b])\\n             rnk[a]++; \\n        }\\n    }\\n};\\n//------DSU---------------------//\\nclass Solution {\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        DSU ds(n);\\n        vector <bool> ans;\\n        for(auto u:requests){\\n            int x=u[0],y=u[1];\\n            x=ds.find_set(x);\\n            y=ds.find_set(y);\\n            if(x==y){\\n                ans.push_back(true);\\n                continue;\\n            }\\n            bool flag=true;\\n            for(auto uu:restrictions){\\n                int p=ds.find_set(uu[0]);\\n                int q=ds.find_set(uu[1]);\\n                if((p==x and q==y) or (p==y and q==x)){\\n                    flag=false;\\n                    break;\\n                }\\n            }\\n            ans.push_back(flag);\\n            if(flag){\\n                ds.union_sets(x,y);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1576923,
                "title": "java-clean-union-find",
                "content": "```\\nclass Solution {\\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        DSU dsu = new DSU(n, restrictions);\\n        int r = requests.length;\\n        boolean res[] = new boolean[r];\\n        for(int i = 0; i < r; i++) {\\n            int req[] = requests[i];\\n            res[i] = dsu.union(req[0], req[1]);\\n        }\\n        return res;\\n    }\\n    \\n    static class DSU {\\n        \\n        Map<Integer, Set<Integer>> cmpToNodes = new HashMap<>();\\n        int parent[];\\n        int[][] restrictions;\\n        DSU(int n, int[][] restrictions) {\\n            parent = new int[n];\\n            for(int i = 0; i < n; i++) {\\n                Set s = new HashSet<>();\\n                s.add(i);\\n                cmpToNodes.put(i, s);\\n                parent[i] = i;\\n            }\\n            this.restrictions = restrictions;\\n        }\\n        \\n        int find(int u) {\\n            if(u == parent[u]) return u;\\n            return parent[u] = find(parent[u]);\\n        }\\n        \\n        boolean union(int u, int v) {\\n            int pu = find(u);\\n            int pv = find(v);\\n            \\n            if(pu != pv) {\\n                Set<Integer> setU = cmpToNodes.get(pu);\\n                Set<Integer> setV = cmpToNodes.get(pv);\\n                for(int restrict[] : restrictions) {\\n                    int x = restrict[0];\\n                    int y = restrict[1];\\n                    boolean foundX = setU.contains(x) || setV.contains(x);\\n                    boolean foundY = setU.contains(y) || setV.contains(y);\\n                    if(foundX && foundY) return false;\\n                }\\n                setV.addAll(setU);\\n                parent[pu] = parent[pv];\\n            }\\n            return true;\\n        }\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        DSU dsu = new DSU(n, restrictions);\\n        int r = requests.length;\\n        boolean res[] = new boolean[r];\\n        for(int i = 0; i < r; i++) {\\n            int req[] = requests[i];\\n            res[i] = dsu.union(req[0], req[1]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 4024208,
                "title": "96-best-reusable-disjointset-template-bonus-tip-inside",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis problem is pretty straightforwad. Basically they are saying that two people can be friends if they have no restrictions or any of their mutual friends have no restriction.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe simplest way to solve this would be to use the union-find technique to link all the persons with mutual friends to one common ancestor. Now for every request we simply check that whether those ancestors have any restrictions or not. If they do they can\\'t be friends or else they can be.\\n\\nPLEASE UPVOTE IF YOU FIND THIS BLOG ANY DIFF THAN OTHERS!!\\n# Complexity\\n- Time complexity: $$O(n*m)$$ -> n = restrictions.length, m = requests.length\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n            \\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int find(int node, vector<int> &par){\\n        if(par[node] == node){\\n            return node;\\n        }\\n        return par[node] = find(par[node], par);\\n    }\\n    int join(int u, int v, vector<int> &par, vector<int> &si){\\n        int pu = find(u, par);\\n        int pv = find(v, par);\\n\\n        if(pu!=pv){\\n            if(si[pu]>=si[pv]){\\n                par[pv] = pu;\\n                si[pu] += si[pv];\\n            }\\n            else{\\n                par[pu] = pv;\\n                si[pv] += si[pu];\\n            }\\n            return 0;\\n        }\\n        return 1;\\n    }\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        vector<bool> ans;\\n        vector<int> par(n,-1), si(n,1);\\n        for(int i=0; i<n; ++i){\\n            par[i] = i;\\n        }\\n\\n        for(auto &edge:requests){ // putting & changes 1800ms code \\n            int u = edge[0], v = edge[1]; // to 200 ms!!!\\n            int pu = find(u, par), pv = find(v, par);\\n\\n            bool flag = true;\\n\\n            for(auto &ed:restrictions){ // same by putting & here\\n                int uu = ed[0], vv = ed[1];\\n                int puu = find(uu, par), pvv = find(vv, par);\\n                if((puu==pu && pvv==pv) || (puu==pv && pvv==pu)){\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n\\n            if(flag) join(u,v,par,si);\\n            ans.push_back(flag);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int find(int node, vector<int> &par){\\n        if(par[node] == node){\\n            return node;\\n        }\\n        return par[node] = find(par[node], par);\\n    }\\n    int join(int u, int v, vector<int> &par, vector<int> &si){\\n        int pu = find(u, par);\\n        int pv = find(v, par);\\n\\n        if(pu!=pv){\\n            if(si[pu]>=si[pv]){\\n                par[pv] = pu;\\n                si[pu] += si[pv];\\n            }\\n            else{\\n                par[pu] = pv;\\n                si[pv] += si[pu];\\n            }\\n            return 0;\\n        }\\n        return 1;\\n    }\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        vector<bool> ans;\\n        vector<int> par(n,-1), si(n,1);\\n        for(int i=0; i<n; ++i){\\n            par[i] = i;\\n        }\\n\\n        for(auto &edge:requests){ // putting & changes 1800ms code \\n            int u = edge[0], v = edge[1]; // to 200 ms!!!\\n            int pu = find(u, par), pv = find(v, par);\\n\\n            bool flag = true;\\n\\n            for(auto &ed:restrictions){ // same by putting & here\\n                int uu = ed[0], vv = ed[1];\\n                int puu = find(uu, par), pvv = find(vv, par);\\n                if((puu==pu && pvv==pv) || (puu==pv && pvv==pu)){\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n\\n            if(flag) join(u,v,par,si);\\n            ans.push_back(flag);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3969894,
                "title": "simple-dfs-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe need to take care that the restriction edge\\'s node should not belong from the same node \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nfirst we will assign different components to each node \\nas we get a request we will check that do they belong to same component or not, if they belong to different component then we will check that no nodes between these components shoudl lie in restriction edges\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n^2)$$ \\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n^2)$$ \\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    bool dfs(int val, int node,int par, vector<vector<int>>&g,set<pair<int,int>>&st){\\n        if(st.find({val,node})!=st.end() || st.find({node,val})!=st.end()) return 0;\\n        int ans=1;\\n        for(auto i: g[node]) if(i!=par) ans&=dfs(val,i,node,g,st);\\n        return ans;\\n    }\\n\\n    bool check(int u,int v,int a,int b,vector<vector<int>>&g,set<pair<int,int>>&st){\\n        int ans=dfs(u,v,v,g,st);\\n        for(auto i: g[u]){\\n            if(i==a) continue;\\n            ans&=check(i,v,u,v,g,st);\\n        }\\n        return ans;\\n    }\\n\\n    void assign(int node,int par,int col,vector<vector<int>>&g,vector<int>&comp){\\n        comp[node]=col;\\n        for(auto child: g[node]){\\n            if(child!=par) assign(child,node,col,g,comp);\\n        }\\n    }\\n\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        set<pair<int,int>>st;\\n        for(auto i : restrictions) st.insert({i[0],i[1]});\\n        vector<int>comp(n);\\n        for(int i=0;i<n;i++) comp[i]=i;\\n        vector<vector<int>>g(n);\\n        vector<bool>ans;\\n        for(auto i: requests){\\n            int u=i[0],v=i[1];\\n            if(st.find({u,v})!=st.end() || st.find({v,u})!=st.end()){\\n                ans.push_back(false);\\n                continue;\\n            }\\n            if(comp[u]==comp[v]){\\n                ans.push_back(true);\\n                continue;\\n            }\\n\\n            if(check(u,v,u,v,g,st)){\\n                g[u].push_back(v);\\n                g[v].push_back(u);\\n                assign(u,v,comp[v],g,comp);\\n                ans.push_back(true);\\n            }\\n            else ans.push_back(false);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool dfs(int val, int node,int par, vector<vector<int>>&g,set<pair<int,int>>&st){\\n        if(st.find({val,node})!=st.end() || st.find({node,val})!=st.end()) return 0;\\n        int ans=1;\\n        for(auto i: g[node]) if(i!=par) ans&=dfs(val,i,node,g,st);\\n        return ans;\\n    }\\n\\n    bool check(int u,int v,int a,int b,vector<vector<int>>&g,set<pair<int,int>>&st){\\n        int ans=dfs(u,v,v,g,st);\\n        for(auto i: g[u]){\\n            if(i==a) continue;\\n            ans&=check(i,v,u,v,g,st);\\n        }\\n        return ans;\\n    }\\n\\n    void assign(int node,int par,int col,vector<vector<int>>&g,vector<int>&comp){\\n        comp[node]=col;\\n        for(auto child: g[node]){\\n            if(child!=par) assign(child,node,col,g,comp);\\n        }\\n    }\\n\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        set<pair<int,int>>st;\\n        for(auto i : restrictions) st.insert({i[0],i[1]});\\n        vector<int>comp(n);\\n        for(int i=0;i<n;i++) comp[i]=i;\\n        vector<vector<int>>g(n);\\n        vector<bool>ans;\\n        for(auto i: requests){\\n            int u=i[0],v=i[1];\\n            if(st.find({u,v})!=st.end() || st.find({v,u})!=st.end()){\\n                ans.push_back(false);\\n                continue;\\n            }\\n            if(comp[u]==comp[v]){\\n                ans.push_back(true);\\n                continue;\\n            }\\n\\n            if(check(u,v,u,v,g,st)){\\n                g[u].push_back(v);\\n                g[v].push_back(u);\\n                assign(u,v,comp[v],g,comp);\\n                ans.push_back(true);\\n            }\\n            else ans.push_back(false);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3875779,
                "title": "easy-c-solution-using-disjoint-set",
                "content": "Use Disjoint Set and apply brute force .\\n\\n# Code\\n```\\n\\nclass DisjointSet {\\n    vector<int> rank, parent, size;\\npublic:\\n    DisjointSet(int n) {\\n        rank.resize(n + 1, 0);\\n        parent.resize(n + 1);\\n        size.resize(n + 1);\\n        for (int i = 0; i <= n; i++) {\\n            parent[i] = i;\\n            size[i] = 1;\\n        }\\n    }\\n\\n    int findUPar(int node) {\\n        if (node == parent[node])\\n            return node;\\n        return parent[node] = findUPar(parent[node]);\\n    }\\n\\n    void unionByRank(int u, int v) {\\n        int ulp_u = findUPar(u);\\n        int ulp_v = findUPar(v);\\n        if (ulp_u == ulp_v) return;\\n        if (rank[ulp_u] < rank[ulp_v]) {\\n            parent[ulp_u] = ulp_v;\\n        }\\n        else if (rank[ulp_v] < rank[ulp_u]) {\\n            parent[ulp_v] = ulp_u;\\n        }\\n        else {\\n            parent[ulp_v] = ulp_u;\\n            rank[ulp_u]++;\\n        }\\n    }\\n\\n    void unionBySize(int u, int v) {\\n        int ulp_u = findUPar(u);\\n        int ulp_v = findUPar(v);\\n        if (ulp_u == ulp_v) return;\\n        if (size[ulp_u] < size[ulp_v]) {\\n            parent[ulp_u] = ulp_v;\\n            size[ulp_v] += size[ulp_u];\\n        }\\n        else {\\n            parent[ulp_v] = ulp_u;\\n            size[ulp_u] += size[ulp_v];\\n        }\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n\\n    bool is_valid(DisjointSet ds,int n,int u,int v,map<pair<int,int>,bool> &not_join){\\n        ds.unionByRank(u,v);\\n\\n        for(auto it:not_join){\\n            int u1=it.first.first;\\n            int v1=it.first.second;\\n            if(ds.findUPar(u1)==ds.findUPar(v1)){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        \\n        DisjointSet ds(n);\\n        vector<bool> ans;\\n        map<pair<int,int>,bool> not_join;\\n\\n        for(auto it:restrictions){\\n            not_join[{it[0],it[1]}]=true;\\n            not_join[{it[1],it[0]}]=true;\\n        }\\n\\n        for(auto it:requests){\\n\\n            int u=it[0];\\n            int v=it[1];\\n\\n            if(ds.findUPar(u)==ds.findUPar(v)){\\n                ans.push_back(true);\\n                continue;\\n            }\\n            else{\\n\\n                if(is_valid(ds,n,u,v,not_join)){\\n                    ds.unionByRank(u,v);\\n                    ans.push_back(true);\\n                }\\n                else{\\n                    ans.push_back(false);\\n                }\\n\\n            }\\n\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass DisjointSet {\\n    vector<int> rank, parent, size;\\npublic:\\n    DisjointSet(int n) {\\n        rank.resize(n + 1, 0);\\n        parent.resize(n + 1);\\n        size.resize(n + 1);\\n        for (int i = 0; i <= n; i++) {\\n            parent[i] = i;\\n            size[i] = 1;\\n        }\\n    }\\n\\n    int findUPar(int node) {\\n        if (node == parent[node])\\n            return node;\\n        return parent[node] = findUPar(parent[node]);\\n    }\\n\\n    void unionByRank(int u, int v) {\\n        int ulp_u = findUPar(u);\\n        int ulp_v = findUPar(v);\\n        if (ulp_u == ulp_v) return;\\n        if (rank[ulp_u] < rank[ulp_v]) {\\n            parent[ulp_u] = ulp_v;\\n        }\\n        else if (rank[ulp_v] < rank[ulp_u]) {\\n            parent[ulp_v] = ulp_u;\\n        }\\n        else {\\n            parent[ulp_v] = ulp_u;\\n            rank[ulp_u]++;\\n        }\\n    }\\n\\n    void unionBySize(int u, int v) {\\n        int ulp_u = findUPar(u);\\n        int ulp_v = findUPar(v);\\n        if (ulp_u == ulp_v) return;\\n        if (size[ulp_u] < size[ulp_v]) {\\n            parent[ulp_u] = ulp_v;\\n            size[ulp_v] += size[ulp_u];\\n        }\\n        else {\\n            parent[ulp_v] = ulp_u;\\n            size[ulp_u] += size[ulp_v];\\n        }\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n\\n    bool is_valid(DisjointSet ds,int n,int u,int v,map<pair<int,int>,bool> &not_join){\\n        ds.unionByRank(u,v);\\n\\n        for(auto it:not_join){\\n            int u1=it.first.first;\\n            int v1=it.first.second;\\n            if(ds.findUPar(u1)==ds.findUPar(v1)){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        \\n        DisjointSet ds(n);\\n        vector<bool> ans;\\n        map<pair<int,int>,bool> not_join;\\n\\n        for(auto it:restrictions){\\n            not_join[{it[0],it[1]}]=true;\\n            not_join[{it[1],it[0]}]=true;\\n        }\\n\\n        for(auto it:requests){\\n\\n            int u=it[0];\\n            int v=it[1];\\n\\n            if(ds.findUPar(u)==ds.findUPar(v)){\\n                ans.push_back(true);\\n                continue;\\n            }\\n            else{\\n\\n                if(is_valid(ds,n,u,v,not_join)){\\n                    ds.unionByRank(u,v);\\n                    ans.push_back(true);\\n                }\\n                else{\\n                    ans.push_back(false);\\n                }\\n\\n            }\\n\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3855862,
                "title": "union-find",
                "content": "```\\nclass UnionFind{\\n        int n;\\n        vector<int> parent;\\n        vector<int> rank;\\n        vector<unordered_set<int>> rest;\\n       \\n        vector<set<int>>& adj;\\n        public:\\n        UnionFind(int _n, vector<set<int>>& _adj) : n(_n), adj(_adj), parent(vector<int>(n, 0)), rank(vector<int>(n, 1)), rest(vector<unordered_set<int>>(_n))\\n        {\\n            for(int i=0; i<_n; i++)\\n            {\\n                parent[i]=i;\\n                if(!adj[i].empty())\\n                {\\n                    rest[i].emplace(i);\\n                }\\n            }\\n       }\\n        \\n        int find(int v)\\n        {\\n            if(v != parent[v])\\n            {\\n                parent[v] = find(parent[v]);\\n            }\\n            return parent[v];\\n        }\\n        \\n        bool add(int v, int u)\\n        {\\n            \\n            int pv = find(v);\\n            int pu = find(u);\\n            \\n            \\n            if(pv == pu)\\n                return true;\\n            \\n            for(auto itr : rest[pv])\\n            {\\n                for(auto itr1 : rest[pu])\\n                if(adj[itr1].count(itr))\\n                    return false;\\n            }\\n            \\n            auto& rpv = rank[pv];\\n            auto& rpu = rank[pu];\\n            \\n            if(rpv >= rpu)\\n            {\\n                if(rpv == rpu)\\n                    rpv++;\\n                parent[pu] = pv;\\n                rest[pv].insert(rest[pu].begin(), rest[pu].end());\\n            }\\n            else{\\n                parent[pv] = pu;\\n                rest[pu].insert(rest[pv].begin(), rest[pv].end());\\n            }\\n            find(v);find(u);\\n            return true;\\n        }\\n    };\\n\\nclass Solution {\\n    public:\\n    vector<set<int>> adj;\\n    \\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        adj = vector<set<int>>(n);\\n        for(auto r : restrictions)\\n        {\\n            adj[r[0]].emplace(r[1]);\\n            adj[r[1]].emplace(r[0]);\\n        }\\n        UnionFind uf(n, adj);\\n        vector<bool> ans(requests.size(), false);\\n        for(int i=0; i<requests.size(); i++)\\n        {\\n            auto ret = uf.add(requests[i][0], requests[i][1]);\\n            ans[i] = ret;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass UnionFind{\\n        int n;\\n        vector<int> parent;\\n        vector<int> rank;\\n        vector<unordered_set<int>> rest;\\n       \\n        vector<set<int>>& adj;\\n        public:\\n        UnionFind(int _n, vector<set<int>>& _adj) : n(_n), adj(_adj), parent(vector<int>(n, 0)), rank(vector<int>(n, 1)), rest(vector<unordered_set<int>>(_n))\\n        {\\n            for(int i=0; i<_n; i++)\\n            {\\n                parent[i]=i;\\n                if(!adj[i].empty())\\n                {\\n                    rest[i].emplace(i);\\n                }\\n            }\\n       }\\n        \\n        int find(int v)\\n        {\\n            if(v != parent[v])\\n            {\\n                parent[v] = find(parent[v]);\\n            }\\n            return parent[v];\\n        }\\n        \\n        bool add(int v, int u)\\n        {\\n            \\n            int pv = find(v);\\n            int pu = find(u);\\n            \\n            \\n            if(pv == pu)\\n                return true;\\n            \\n            for(auto itr : rest[pv])\\n            {\\n                for(auto itr1 : rest[pu])\\n                if(adj[itr1].count(itr))\\n                    return false;\\n            }\\n            \\n            auto& rpv = rank[pv];\\n            auto& rpu = rank[pu];\\n            \\n            if(rpv >= rpu)\\n            {\\n                if(rpv == rpu)\\n                    rpv++;\\n                parent[pu] = pv;\\n                rest[pv].insert(rest[pu].begin(), rest[pu].end());\\n            }\\n            else{\\n                parent[pv] = pu;\\n                rest[pu].insert(rest[pv].begin(), rest[pv].end());\\n            }\\n            find(v);find(u);\\n            return true;\\n        }\\n    };\\n\\nclass Solution {\\n    public:\\n    vector<set<int>> adj;\\n    \\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        adj = vector<set<int>>(n);\\n        for(auto r : restrictions)\\n        {\\n            adj[r[0]].emplace(r[1]);\\n            adj[r[1]].emplace(r[0]);\\n        }\\n        UnionFind uf(n, adj);\\n        vector<bool> ans(requests.size(), false);\\n        for(int i=0; i<requests.size(); i++)\\n        {\\n            auto ret = uf.add(requests[i][0], requests[i][1]);\\n            ans[i] = ret;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3847389,
                "title": "dsu-with-rollback",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nDSU with rollback\\nbrute force according to me\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ndo union\\ncheck if it violates conditions or not\\nif it is then rollback\\notherwise move on\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n*n*logn)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Code\\n```\\nclass DisjointSet {\\npublic :\\n    vector<int> size, parent;\\n    stack<pair<int, int>> parentHistory, sizeHistory; // {element, currentValue of element}\\n    DisjointSet(int n) {\\n        parent.resize(n + 1);\\n        size.resize(n + 1, 1);\\n        \\n        for(int i = 0 ; i <= n ; i++) {\\n            parent[i] = i;\\n        }\\n    }\\n    // T.C = O(logN) as no path compression is there\\n    int findUltimateParent(int node) {\\n        if(node == parent[node]) {\\n            return node;\\n        }\\n        return findUltimateParent(parent[node]);\\n    }\\n    // T.C = O(logN)\\n    void unionBySize(int node1, int node2) {\\n        int ultimateParent1 = findUltimateParent(node1);\\n        int ultimateParent2 = findUltimateParent(node2);\\n        \\n        if(ultimateParent1 == ultimateParent2) return;\\n        \\n        if(size[ultimateParent1] > size[ultimateParent2]) {\\n            parentHistory.push({ultimateParent2, ultimateParent2});\\n            sizeHistory.push({ultimateParent1, size[ultimateParent1]});\\n            \\n            parent[ultimateParent2] = ultimateParent1;\\n            size[ultimateParent1] += size[ultimateParent2];\\n        }\\n        else{\\n            parentHistory.push({ultimateParent1, ultimateParent1});\\n            sizeHistory.push({ultimateParent2, size[ultimateParent2]});\\n            \\n            parent[ultimateParent1] = ultimateParent2;\\n            size[ultimateParent2] += size[ultimateParent1];\\n        }\\n    }\\n    // T.C = O(1)\\n    void rollback() {\\n        // restore the previous state of size and parent\\n        // if(sizeHistory.size() == 0 || parentHistory.size() == 0) return ;\\n\\n        int node = sizeHistory.top().first;\\n        int previousSize = sizeHistory.top().second;\\n        sizeHistory.pop();\\n        \\n        size[node] = previousSize;\\n        \\n        int targetNode = parentHistory.top().first;\\n        int previousParent = parentHistory.top().second;\\n        parentHistory.pop();\\n        \\n        parent[targetNode] = previousParent;\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        DisjointSet ds(n);\\n        vector<bool> ans(requests.size(), false);\\n\\n        // Traversing requests vector\\n        for(int i = 0 ; i < requests.size() ; i++) {\\n            int node1 = requests[i][0];\\n            int node2 = requests[i][1];\\n\\n            ds.unionBySize(node1, node2);\\n            ans[i] = true;\\n\\n            // Traversing restrictions vector\\n            for(auto it : restrictions) {\\n                if(ds.findUltimateParent(it[0]) == ds.findUltimateParent(it[1])) {\\n                    ds.rollback();\\n                    ans[i] = false;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\nclass DisjointSet {\\npublic :\\n    vector<int> size, parent;\\n    stack<pair<int, int>> parentHistory, sizeHistory; // {element, currentValue of element}\\n    DisjointSet(int n) {\\n        parent.resize(n + 1);\\n        size.resize(n + 1, 1);\\n        \\n        for(int i = 0 ; i <= n ; i++) {\\n            parent[i] = i;\\n        }\\n    }\\n    // T.C = O(logN) as no path compression is there\\n    int findUltimateParent(int node) {\\n        if(node == parent[node]) {\\n            return node;\\n        }\\n        return findUltimateParent(parent[node]);\\n    }\\n    // T.C = O(logN)\\n    void unionBySize(int node1, int node2) {\\n        int ultimateParent1 = findUltimateParent(node1);\\n        int ultimateParent2 = findUltimateParent(node2);\\n        \\n        if(ultimateParent1 == ultimateParent2) return;\\n        \\n        if(size[ultimateParent1] > size[ultimateParent2]) {\\n            parentHistory.push({ultimateParent2, ultimateParent2});\\n            sizeHistory.push({ultimateParent1, size[ultimateParent1]});\\n            \\n            parent[ultimateParent2] = ultimateParent1;\\n            size[ultimateParent1] += size[ultimateParent2];\\n        }\\n        else{\\n            parentHistory.push({ultimateParent1, ultimateParent1});\\n            sizeHistory.push({ultimateParent2, size[ultimateParent2]});\\n            \\n            parent[ultimateParent1] = ultimateParent2;\\n            size[ultimateParent2] += size[ultimateParent1];\\n        }\\n    }\\n    // T.C = O(1)\\n    void rollback() {\\n        // restore the previous state of size and parent\\n        // if(sizeHistory.size() == 0 || parentHistory.size() == 0) return ;\\n\\n        int node = sizeHistory.top().first;\\n        int previousSize = sizeHistory.top().second;\\n        sizeHistory.pop();\\n        \\n        size[node] = previousSize;\\n        \\n        int targetNode = parentHistory.top().first;\\n        int previousParent = parentHistory.top().second;\\n        parentHistory.pop();\\n        \\n        parent[targetNode] = previousParent;\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        DisjointSet ds(n);\\n        vector<bool> ans(requests.size(), false);\\n\\n        // Traversing requests vector\\n        for(int i = 0 ; i < requests.size() ; i++) {\\n            int node1 = requests[i][0];\\n            int node2 = requests[i][1];\\n\\n            ds.unionBySize(node1, node2);\\n            ans[i] = true;\\n\\n            // Traversing restrictions vector\\n            for(auto it : restrictions) {\\n                if(ds.findUltimateParent(it[0]) == ds.findUltimateParent(it[1])) {\\n                    ds.rollback();\\n                    ans[i] = false;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3839807,
                "title": "java-comments-clean-code-simple-explanation",
                "content": "# Intuition\\nMake them friend first, and then check if parent of restriction node belongs to same component or not \\nIf they belong to same component then revert back your ans\\nIf not then mark your answer as true and continue for others.\\n\\n# Code\\n```\\nclass Solution {\\n    class Disjoint{ //basic disjoint class tempelate\\n        int V;\\n        int[] parent,size;\\n\\n        Disjoint(int V){\\n            this.V=V;\\n            parent=new int[V];\\n            size=new int[V];\\n            for(int i=0; i<V; i++){\\n                parent[i]=i;\\n                size[i]=1;\\n            }\\n        }\\n\\n    int findParent(int x){\\n        if(parent[x]==x)\\n        return x;\\n        return findParent(parent[x]);\\n    }\\n\\n    void unionBySize(int x,int y){\\n        int px=findParent(x);\\n        int py=findParent(y);\\n\\n        if(px==py)return ;\\n        if(size[px]<size[py]){\\n            size[py]+=size[px];\\n            parent[px]=py;\\n        }else{\\n             size[px]+=size[py];\\n            parent[py]=px;\\n        }\\n    }\\n\\n\\n    }\\n    public boolean[] friendRequests(int n, int[][] rest , int[][] requests) {\\n        Disjoint ds=new Disjoint(n);\\n        boolean[] ans=new boolean[requests.length];\\n        Arrays.fill(ans,true);\\n\\n        for(int i=0; i<requests.length; i++){\\n            int x=requests[i][0];\\n            int y=requests[i][1];\\n\\n            int opx=ds.findParent(x);// old parent of x\\n            int opy=ds.findParent(y);// old parent of y\\n\\n                 ds.unionBySize(x,y);   // make them friend irrespective of restrictions\\n\\n             if( isRuleVoilated(rest,ds)){// now check if any restriction rule is voilated.\\n                   ds.parent[opx]=opx;  // if rule is violated then restore.\\n                 ds.parent[opy]=opy;    // parent of x and y should point them self showing they were not friend.\\n                 ans[i]=false; // mark ans as false\\n             }\\n\\n          // remember ans is filled with true. So no need to add ans[i]=true;\\n        }\\n        return ans;\\n    }\\n\\n\\n    boolean isRuleVoilated(int[][] res,Disjoint ds){\\n        for(int i=0; i<res.length; i++){\\n            int p1=ds.findParent(res[i][0]);\\n            int p2=ds.findParent(res[i][1]);    // if  parent of both restriction node belongs to same component then notify rule is voilated \\n\\n            if(p1==p2){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\\n# Upvote button is below, don\\'t mind hitting it \\uD83E\\uDD24\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    class Disjoint{ //basic disjoint class tempelate\\n        int V;\\n        int[] parent,size;\\n\\n        Disjoint(int V){\\n            this.V=V;\\n            parent=new int[V];\\n            size=new int[V];\\n            for(int i=0; i<V; i++){\\n                parent[i]=i;\\n                size[i]=1;\\n            }\\n        }\\n\\n    int findParent(int x){\\n        if(parent[x]==x)\\n        return x;\\n        return findParent(parent[x]);\\n    }\\n\\n    void unionBySize(int x,int y){\\n        int px=findParent(x);\\n        int py=findParent(y);\\n\\n        if(px==py)return ;\\n        if(size[px]<size[py]){\\n            size[py]+=size[px];\\n            parent[px]=py;\\n        }else{\\n             size[px]+=size[py];\\n            parent[py]=px;\\n        }\\n    }\\n\\n\\n    }\\n    public boolean[] friendRequests(int n, int[][] rest , int[][] requests) {\\n        Disjoint ds=new Disjoint(n);\\n        boolean[] ans=new boolean[requests.length];\\n        Arrays.fill(ans,true);\\n\\n        for(int i=0; i<requests.length; i++){\\n            int x=requests[i][0];\\n            int y=requests[i][1];\\n\\n            int opx=ds.findParent(x);// old parent of x\\n            int opy=ds.findParent(y);// old parent of y\\n\\n                 ds.unionBySize(x,y);   // make them friend irrespective of restrictions\\n\\n             if( isRuleVoilated(rest,ds)){// now check if any restriction rule is voilated.\\n                   ds.parent[opx]=opx;  // if rule is violated then restore.\\n                 ds.parent[opy]=opy;    // parent of x and y should point them self showing they were not friend.\\n                 ans[i]=false; // mark ans as false\\n             }\\n\\n          // remember ans is filled with true. So no need to add ans[i]=true;\\n        }\\n        return ans;\\n    }\\n\\n\\n    boolean isRuleVoilated(int[][] res,Disjoint ds){\\n        for(int i=0; i<res.length; i++){\\n            int p1=ds.findParent(res[i][0]);\\n            int p2=ds.findParent(res[i][1]);    // if  parent of both restriction node belongs to same component then notify rule is voilated \\n\\n            if(p1==p2){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3768877,
                "title": "clean-code-dsu-commented",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nUse DSU to check if u and v are friend already.If they are friend simply put 1 at that index.If they are not friends then check if by their friendship there will be any contradictions.If it lead to any restriced pair then answer would be false else answer will be true.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n^2log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int sz[1001];\\n    int par[1001];\\n    void makeset()\\n    {\\n        for(int i=0;i<1001;i++)\\n        {\\n            sz[i]=1;\\n            par[i]=i;\\n        }\\n    }\\n    int find(int node)\\n    {\\n        if(par[node]==node)\\n        {\\n            return node;\\n        }\\n        return par[node]=find(par[node]);\\n    }\\n    void merge(int u,int v)\\n    {\\n        u=find(u);\\n        v=find(v);\\n        if(u!=v)\\n        {\\n            if(sz[v]>sz[u])\\n            {\\n                swap(u,v);\\n            }\\n            sz[u]+=sz[v];\\n            par[v]=u;\\n        }\\n    }\\n    vector<bool> friendRequests(int n, vector<vector<int>>& res, vector<vector<int>>& req) {\\n        int rn=res.size();\\n        int rqn=req.size();\\n        makeset();\\n        vector<bool> ans(rqn,0);\\n        for(int i=0;i<rqn;i++)\\n        {\\n            int u=req[i][0];\\n            int v=req[i][1];\\n            int p1=find(u);\\n            int p2=find(v);\\n            if(find(u)==find(v))\\n            {\\n                ans[i]=1;\\n            }\\n            else//need to check for contradictions \\n            {\\n                bool check=1;\\n                for(int j=0;j<rn;j++)\\n                {\\n                    int x=res[j][0];\\n                    int y=res[j][1];\\n                    if((find(x)==p1&&find(y)==p2)||(find(x)==p2&&find(y)==p1))\\n                    {\\n                        check=0;\\n                    }\\n\\n                }\\n                if(check)\\n                {\\n                    merge(u,v);\\n                    ans[i]=1;\\n                }\\n                else\\n                {\\n                    ans[i]=0;\\n                }\\n            }\\n        }\\n        return ans;\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sz[1001];\\n    int par[1001];\\n    void makeset()\\n    {\\n        for(int i=0;i<1001;i++)\\n        {\\n            sz[i]=1;\\n            par[i]=i;\\n        }\\n    }\\n    int find(int node)\\n    {\\n        if(par[node]==node)\\n        {\\n            return node;\\n        }\\n        return par[node]=find(par[node]);\\n    }\\n    void merge(int u,int v)\\n    {\\n        u=find(u);\\n        v=find(v);\\n        if(u!=v)\\n        {\\n            if(sz[v]>sz[u])\\n            {\\n                swap(u,v);\\n            }\\n            sz[u]+=sz[v];\\n            par[v]=u;\\n        }\\n    }\\n    vector<bool> friendRequests(int n, vector<vector<int>>& res, vector<vector<int>>& req) {\\n        int rn=res.size();\\n        int rqn=req.size();\\n        makeset();\\n        vector<bool> ans(rqn,0);\\n        for(int i=0;i<rqn;i++)\\n        {\\n            int u=req[i][0];\\n            int v=req[i][1];\\n            int p1=find(u);\\n            int p2=find(v);\\n            if(find(u)==find(v))\\n            {\\n                ans[i]=1;\\n            }\\n            else//need to check for contradictions \\n            {\\n                bool check=1;\\n                for(int j=0;j<rn;j++)\\n                {\\n                    int x=res[j][0];\\n                    int y=res[j][1];\\n                    if((find(x)==p1&&find(y)==p2)||(find(x)==p2&&find(y)==p1))\\n                    {\\n                        check=0;\\n                    }\\n\\n                }\\n                if(check)\\n                {\\n                    merge(u,v);\\n                    ans[i]=1;\\n                }\\n                else\\n                {\\n                    ans[i]=0;\\n                }\\n            }\\n        }\\n        return ans;\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3759687,
                "title": "my-solution",
                "content": "```\\n/**\\n * Time Complexity: O(n_requests * n_restrictions)\\n * Space Complexity: O(n)\\n * where `n_requests` is the length of the vector `requests`\\n *       `n_restrictions` is the length of the vector `restrictions`\\n */\\nclass Solution {\\n private:\\n  class DisjointSet {\\n   public:\\n    DisjointSet(const int n) : parents_(n), ranks_(n) {\\n      iota(parents_.begin(), parents_.end(), 0);\\n    }\\n    \\n    int find(const int i) {\\n      if (parents_[i] == i) {\\n        return i;\\n      }\\n      \\n      parents_[i] = find(parents_[i]);\\n      return parents_[i];\\n    }\\n    \\n    bool do_union(const int i, const int j) {\\n      const int parent_i = find(i);\\n      const int parent_j = find(j);\\n      if (parent_i == parent_j) {\\n        return false;\\n      }\\n      \\n      if (ranks_[parent_i] < ranks_[parent_j]) {\\n        parents_[parent_i] = parent_j;\\n      } else if (ranks_[parent_i] > ranks_[parent_j]) {\\n        parents_[parent_j] = parent_i;\\n      } else {\\n        parents_[parent_i] = parent_j;\\n        ++ranks_[parent_j];\\n      }\\n      return true;\\n    }\\n    \\n   private:\\n    vector<int> parents_;\\n    vector<int> ranks_;\\n  };\\n  \\n public:\\n  vector<bool> friendRequests(const int n,\\n                              const vector<vector<int>> &restrictions,\\n                              const vector<vector<int>> &requests) {\\n    const int n_requests = static_cast<int>(requests.size());\\n    vector<bool> ret(n_requests);\\n    DisjointSet ds(n);\\n    for (int i_request = 0; i_request < n_requests; ++i_request) {\\n      const vector<int> &request = requests[i_request];\\n      const int request_parent1 = ds.find(request.front());\\n      const int request_parent2 = ds.find(request.back());\\n      if (request_parent1 == request_parent2) {\\n        ret[i_request] = true;\\n        continue;\\n      }\\n      \\n      bool successful = true;\\n      for (const vector<int> &restriction : restrictions) {\\n        const int restrict_parent1 = ds.find(restriction.front());\\n        const int restrict_parent2 = ds.find(restriction.back());\\n        if ((restrict_parent1 == request_parent1 || restrict_parent1 == request_parent2) &&\\n            (restrict_parent2 == request_parent1 || restrict_parent2 == request_parent2)) {\\n          successful = false;\\n          break;\\n        }\\n      }\\n      ret[i_request] = successful;\\n      if (successful) {\\n        ds.do_union(request_parent1, request_parent2);\\n      }\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Time Complexity: O(n_requests * n_restrictions)\\n * Space Complexity: O(n)\\n * where `n_requests` is the length of the vector `requests`\\n *       `n_restrictions` is the length of the vector `restrictions`\\n */\\nclass Solution {\\n private:\\n  class DisjointSet {\\n   public:\\n    DisjointSet(const int n) : parents_(n), ranks_(n) {\\n      iota(parents_.begin(), parents_.end(), 0);\\n    }\\n    \\n    int find(const int i) {\\n      if (parents_[i] == i) {\\n        return i;\\n      }\\n      \\n      parents_[i] = find(parents_[i]);\\n      return parents_[i];\\n    }\\n    \\n    bool do_union(const int i, const int j) {\\n      const int parent_i = find(i);\\n      const int parent_j = find(j);\\n      if (parent_i == parent_j) {\\n        return false;\\n      }\\n      \\n      if (ranks_[parent_i] < ranks_[parent_j]) {\\n        parents_[parent_i] = parent_j;\\n      } else if (ranks_[parent_i] > ranks_[parent_j]) {\\n        parents_[parent_j] = parent_i;\\n      } else {\\n        parents_[parent_i] = parent_j;\\n        ++ranks_[parent_j];\\n      }\\n      return true;\\n    }\\n    \\n   private:\\n    vector<int> parents_;\\n    vector<int> ranks_;\\n  };\\n  \\n public:\\n  vector<bool> friendRequests(const int n,\\n                              const vector<vector<int>> &restrictions,\\n                              const vector<vector<int>> &requests) {\\n    const int n_requests = static_cast<int>(requests.size());\\n    vector<bool> ret(n_requests);\\n    DisjointSet ds(n);\\n    for (int i_request = 0; i_request < n_requests; ++i_request) {\\n      const vector<int> &request = requests[i_request];\\n      const int request_parent1 = ds.find(request.front());\\n      const int request_parent2 = ds.find(request.back());\\n      if (request_parent1 == request_parent2) {\\n        ret[i_request] = true;\\n        continue;\\n      }\\n      \\n      bool successful = true;\\n      for (const vector<int> &restriction : restrictions) {\\n        const int restrict_parent1 = ds.find(restriction.front());\\n        const int restrict_parent2 = ds.find(restriction.back());\\n        if ((restrict_parent1 == request_parent1 || restrict_parent1 == request_parent2) &&\\n            (restrict_parent2 == request_parent1 || restrict_parent2 == request_parent2)) {\\n          successful = false;\\n          break;\\n        }\\n      }\\n      ret[i_request] = successful;\\n      if (successful) {\\n        ds.do_union(request_parent1, request_parent2);\\n      }\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3747564,
                "title": "not-the-best-solution-but-still-something",
                "content": "The key idea is that for every request i process, i will check all the restriction and find the first one that isn\\'t allowed.\\nif i find one, i will restore the disjoint set back to where it was before i united by doing some new object assignment.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    struct union_find{\\n      int n;\\n      vector<int>parent, rank;\\n      vector<int>_parent, _rank;\\n        \\n      union_find (int n) : n(n) {\\n          parent.resize(n);\\n          iota(parent.begin(), parent.end(), 0);\\n          rank.resize(n,1);\\n          _parent = parent;\\n          _rank = rank;\\n      }\\n        \\n      int find(int a){\\n           if(parent[a] == a)return a;\\n           return parent[a] = find(parent[a]);\\n      }\\n        \\n      void unite(int a, int b){\\n           a = find(a), b = find(b);\\n          \\n           if(a == b)return;\\n          \\n           \\n           if(rank[a] < rank[b]){\\n                parent[a] = b;\\n                rank[b] += rank[a];\\n           }\\n           else{\\n                parent[b] = a;\\n                rank[a] += rank[b];\\n           }\\n      }\\n    \\n      void restore(int a, int b, int c, int d, bool check){\\n          \\n          if(!check){\\n              // reject the pull request.\\n              parent[a] = _parent[a]; rank[a] = _rank[a]; parent[b] = _parent[b]; rank[b] = _rank[b];\\n              parent[c] = _parent[c]; rank[c] = _rank[c]; parent[d] = _parent[d]; rank[d] = _rank[d];\\n          }\\n          else{\\n              // accept it if everything looks fine. \\n              _parent[a] = parent[a]; _rank[a] = rank[a]; _parent[b] = parent[b]; _rank[b] = rank[b];\\n              _parent[c] = parent[c]; _rank[c] = rank[c]; _parent[d] = parent[d]; _rank[d] = rank[d];\\n          }\\n          \\n      }\\n        \\n      \\n   };\\n    \\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        // so if each request we process.\\n        // we need to go and check our whole restrictions to go and check all restrictions to make sure everything is still fine else we revert what we did and put false\\n        \\n        union_find solve(n), solve1(n);\\n        vector<bool>answer;\\n        int p_x, p_y, r_x, r_y;\\n        int counter = 0;\\n        bool check;\\n        \\n        for(auto& request : requests) {\\n            check  = true;\\n            solve1 = solve;\\n            p_x = solve.find(request[0]);\\n            p_y = solve.find(request[1]);\\n            \\n            solve.unite(request[0], request[1]);\\n            \\n            for(auto& restriction : restrictions) {\\n                \\n                if(solve.find(restriction[0]) == solve.find(restriction[1])) {\\n                   answer.push_back(false); check = false; break;\\n                }\\n                \\n            }\\n            \\n            if(check){ answer.push_back(true);}\\n            else solve = solve1;    // main code\\n            counter +=1;\\n        }\\n        \\n        \\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    struct union_find{\\n      int n;\\n      vector<int>parent, rank;\\n      vector<int>_parent, _rank;\\n        \\n      union_find (int n) : n(n) {\\n          parent.resize(n);\\n          iota(parent.begin(), parent.end(), 0);\\n          rank.resize(n,1);\\n          _parent = parent;\\n          _rank = rank;\\n      }\\n        \\n      int find(int a){\\n           if(parent[a] == a)return a;\\n           return parent[a] = find(parent[a]);\\n      }\\n        \\n      void unite(int a, int b){\\n           a = find(a), b = find(b);\\n          \\n           if(a == b)return;\\n          \\n           \\n           if(rank[a] < rank[b]){\\n                parent[a] = b;\\n                rank[b] += rank[a];\\n           }\\n           else{\\n                parent[b] = a;\\n                rank[a] += rank[b];\\n           }\\n      }\\n    \\n      void restore(int a, int b, int c, int d, bool check){\\n          \\n          if(!check){\\n              // reject the pull request.\\n              parent[a] = _parent[a]; rank[a] = _rank[a]; parent[b] = _parent[b]; rank[b] = _rank[b];\\n              parent[c] = _parent[c]; rank[c] = _rank[c]; parent[d] = _parent[d]; rank[d] = _rank[d];\\n          }\\n          else{\\n              // accept it if everything looks fine. \\n              _parent[a] = parent[a]; _rank[a] = rank[a]; _parent[b] = parent[b]; _rank[b] = rank[b];\\n              _parent[c] = parent[c]; _rank[c] = rank[c]; _parent[d] = parent[d]; _rank[d] = rank[d];\\n          }\\n          \\n      }\\n        \\n      \\n   };\\n    \\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        // so if each request we process.\\n        // we need to go and check our whole restrictions to go and check all restrictions to make sure everything is still fine else we revert what we did and put false\\n        \\n        union_find solve(n), solve1(n);\\n        vector<bool>answer;\\n        int p_x, p_y, r_x, r_y;\\n        int counter = 0;\\n        bool check;\\n        \\n        for(auto& request : requests) {\\n            check  = true;\\n            solve1 = solve;\\n            p_x = solve.find(request[0]);\\n            p_y = solve.find(request[1]);\\n            \\n            solve.unite(request[0], request[1]);\\n            \\n            for(auto& restriction : restrictions) {\\n                \\n                if(solve.find(restriction[0]) == solve.find(restriction[1])) {\\n                   answer.push_back(false); check = false; break;\\n                }\\n                \\n            }\\n            \\n            if(check){ answer.push_back(true);}\\n            else solve = solve1;    // main code\\n            counter +=1;\\n        }\\n        \\n        \\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3647122,
                "title": "c-union-find-easy-solution",
                "content": "# Approach\\n- Connect those friends whose parents are not in the restricted array where parent represents the leader of a group as we do in Union find.\\n- To check if parents of two nodes are in restricted array, we can simply iterate in the restricted array due to smaller constraints.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> parent,rank;\\n    int findPar(int x)\\n    {\\n        if(parent[x]==x)\\n            return x;\\n        return parent[x] = findPar(parent[x]);\\n    }\\n    void Union(int x,int y)\\n    {\\n        int u = findPar(x);\\n        int v = findPar(y);\\n        if(u==v)\\n            return;\\n        if(rank[u]>=rank[v])\\n        {\\n            rank[u]++;\\n            parent[v] = u;\\n        }\\n        else\\n        {\\n            rank[v]++;\\n            parent[u] = v;\\n        }\\n    }\\n    vector<bool> friendRequests(int n, vector<vector<int>>& rest, vector<vector<int>>& req) {\\n        parent.resize(n);\\n        rank.resize(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            parent[i] = i;\\n            rank[i] = 1;\\n        }\\n        vector<bool> ans;\\n        for(int i=0;i<req.size();i++)\\n        {\\n            int x = req[i][0];\\n            int y = req[i][1];\\n            int u = findPar(x);\\n            int v = findPar(y);\\n            bool flg = true;\\n            if(u!=v)\\n            {\\n                for(auto &j:rest)\\n                {\\n                    int a = findPar(j[0]);\\n                    int b = findPar(j[1]);\\n                    if((u==a && v==b)||(u==b && v==a))\\n                    {\\n                        flg = false;\\n                        break;\\n                    }\\n                }\\n            }\\n            ans.push_back(flg);\\n            if(flg)\\n            {\\n                Union(u,v);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> parent,rank;\\n    int findPar(int x)\\n    {\\n        if(parent[x]==x)\\n            return x;\\n        return parent[x] = findPar(parent[x]);\\n    }\\n    void Union(int x,int y)\\n    {\\n        int u = findPar(x);\\n        int v = findPar(y);\\n        if(u==v)\\n            return;\\n        if(rank[u]>=rank[v])\\n        {\\n            rank[u]++;\\n            parent[v] = u;\\n        }\\n        else\\n        {\\n            rank[v]++;\\n            parent[u] = v;\\n        }\\n    }\\n    vector<bool> friendRequests(int n, vector<vector<int>>& rest, vector<vector<int>>& req) {\\n        parent.resize(n);\\n        rank.resize(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            parent[i] = i;\\n            rank[i] = 1;\\n        }\\n        vector<bool> ans;\\n        for(int i=0;i<req.size();i++)\\n        {\\n            int x = req[i][0];\\n            int y = req[i][1];\\n            int u = findPar(x);\\n            int v = findPar(y);\\n            bool flg = true;\\n            if(u!=v)\\n            {\\n                for(auto &j:rest)\\n                {\\n                    int a = findPar(j[0]);\\n                    int b = findPar(j[1]);\\n                    if((u==a && v==b)||(u==b && v==a))\\n                    {\\n                        flg = false;\\n                        break;\\n                    }\\n                }\\n            }\\n            ans.push_back(flg);\\n            if(flg)\\n            {\\n                Union(u,v);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3629616,
                "title": "c-memory-94-35-union-find",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int find(vector<int>&parent,int node){\\n        if(parent[node]==node){\\n            return node;\\n        }\\n        return parent[node]=find(parent,parent[node]);\\n    }\\n    void _union(vector<int>&parent,int u,int v){\\n        u=find(parent,u);\\n        v=find(parent,v);\\n        if(u!=v){\\n            parent[v]=u;\\n        }\\n    }\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        vector<bool>ans;\\n        vector<int>parent(n);\\n        for(int i=0;i<n;i++){\\n            parent[i]=i;\\n        }\\n        for(int i=0;i<requests.size();i++){\\n            int u=find(parent,requests[i][0]);\\n            int v=find(parent,requests[i][1]);\\n            bool is_valid=true;\\n            if(u!=v){\\n                for(int j=0;j<restrictions.size();j++){\\n                    int x=find(parent,restrictions[j][0]);\\n                    int y=find(parent,restrictions[j][1]);\\n                        if(u==x and v==y or u==y and v==x){\\n                        is_valid=false;\\n                        break;\\n                    }\\n                }\\n            }\\n            if(is_valid){\\n                _union(parent,u,v);\\n            }\\n            ans.push_back(is_valid);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int find(vector<int>&parent,int node){\\n        if(parent[node]==node){\\n            return node;\\n        }\\n        return parent[node]=find(parent,parent[node]);\\n    }\\n    void _union(vector<int>&parent,int u,int v){\\n        u=find(parent,u);\\n        v=find(parent,v);\\n        if(u!=v){\\n            parent[v]=u;\\n        }\\n    }\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        vector<bool>ans;\\n        vector<int>parent(n);\\n        for(int i=0;i<n;i++){\\n            parent[i]=i;\\n        }\\n        for(int i=0;i<requests.size();i++){\\n            int u=find(parent,requests[i][0]);\\n            int v=find(parent,requests[i][1]);\\n            bool is_valid=true;\\n            if(u!=v){\\n                for(int j=0;j<restrictions.size();j++){\\n                    int x=find(parent,restrictions[j][0]);\\n                    int y=find(parent,restrictions[j][1]);\\n                        if(u==x and v==y or u==y and v==x){\\n                        is_valid=false;\\n                        break;\\n                    }\\n                }\\n            }\\n            if(is_valid){\\n                _union(parent,u,v);\\n            }\\n            ans.push_back(is_valid);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3515407,
                "title": "c-concise-union-find",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        vector<bool> res;\\n        vroot.resize(n);\\n        for(int i=0;i<n;i++) vroot[i] = i;\\n        for(auto& req:requests){\\n            int i = req[0], j = req[1], ri = root(i), rj = root(j);\\n            bool isGood = true;\\n            for(auto& v : restrictions){\\n                int x = root(v[0]), y = root(v[1]);\\n                if((x == ri && y == rj) || (x == rj && y==ri)){\\n                    isGood = false;\\n                    break;\\n                }\\n            }\\n            if(isGood) join(ri, rj);\\n            res.push_back(isGood);\\n        }\\n        return res;\\n    }\\n\\n    int root(int i){\\n        if(vroot[i] == i) return i;\\n        return vroot[i] = root(vroot[i]);\\n    }\\n\\n    void join(int i, int j){\\n        vroot[root(i)] = root(j);\\n    }\\n\\n    vector<int> vroot;\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        vector<bool> res;\\n        vroot.resize(n);\\n        for(int i=0;i<n;i++) vroot[i] = i;\\n        for(auto& req:requests){\\n            int i = req[0], j = req[1], ri = root(i), rj = root(j);\\n            bool isGood = true;\\n            for(auto& v : restrictions){\\n                int x = root(v[0]), y = root(v[1]);\\n                if((x == ri && y == rj) || (x == rj && y==ri)){\\n                    isGood = false;\\n                    break;\\n                }\\n            }\\n            if(isGood) join(ri, rj);\\n            res.push_back(isGood);\\n        }\\n        return res;\\n    }\\n\\n    int root(int i){\\n        if(vroot[i] == i) return i;\\n        return vroot[i] = root(vroot[i]);\\n    }\\n\\n    void join(int i, int j){\\n        vroot[root(i)] = root(j);\\n    }\\n\\n    vector<int> vroot;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3502743,
                "title": "union-find-small-trick",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBasic union find data structure to be used. The part to tell if the a restriction would be violated before a connection can be made needs some thinking, which is the hardest part of this problem.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAfter figuring out how to resolve the above problem in the intuition by comparing the bosses/heads of the 2 sets requested to be joint and bosses/heads in every restrictions, it\\'s just a union find problem.\\n\\nUse `for/else` probably for the first time in python\\n\\n# Complexity\\n- Time complexity:\\nAs unionfind\\n\\n- Space complexity:\\nUsed a recursive function so probably not very good\\n\\n# Code\\n```\\nclass UnionFind:\\n    def __init__(self, n):\\n        self.head = [i for i in range(n)]\\n\\n    def connect(self, a, b):\\n        head_a, head_b = self.find(a), self.find(b)\\n\\n        if head_a == head_b:\\n            return\\n\\n        self.head[head_a] = self.find(head_b)\\n        \\n    def find(self, a):\\n        if self.head[a] == a:\\n            return a\\n\\n        self.head[a] = self.find(self.head[a])\\n        return self.head[a]\\n\\nclass Solution:\\n    def friendRequests(self, n: int, restrictions: List[List[int]], requests: List[List[int]]) -> List[bool]:\\n        groups = UnionFind(n)\\n        res = []\\n\\n        for a, b in requests:\\n            boss_a, boss_b = groups.find(a), groups.find(b)\\n\\n            if boss_a == boss_b:\\n                res.append(True)\\n                continue\\n\\n            for c, d in restrictions:\\n                boss_c, boss_d = groups.find(c), groups.find(d)\\n\\n                if (boss_a == boss_c and boss_b == boss_d) or (boss_a == boss_d and boss_b == boss_c):\\n                    res.append(False)\\n                    break\\n            else:\\n                res.append(True)\\n                groups.connect(a, b)\\n        \\n        return res\\n\\n\\n\\n\\n            \\n            \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass UnionFind:\\n    def __init__(self, n):\\n        self.head = [i for i in range(n)]\\n\\n    def connect(self, a, b):\\n        head_a, head_b = self.find(a), self.find(b)\\n\\n        if head_a == head_b:\\n            return\\n\\n        self.head[head_a] = self.find(head_b)\\n        \\n    def find(self, a):\\n        if self.head[a] == a:\\n            return a\\n\\n        self.head[a] = self.find(self.head[a])\\n        return self.head[a]\\n\\nclass Solution:\\n    def friendRequests(self, n: int, restrictions: List[List[int]], requests: List[List[int]]) -> List[bool]:\\n        groups = UnionFind(n)\\n        res = []\\n\\n        for a, b in requests:\\n            boss_a, boss_b = groups.find(a), groups.find(b)\\n\\n            if boss_a == boss_b:\\n                res.append(True)\\n                continue\\n\\n            for c, d in restrictions:\\n                boss_c, boss_d = groups.find(c), groups.find(d)\\n\\n                if (boss_a == boss_c and boss_b == boss_d) or (boss_a == boss_d and boss_b == boss_c):\\n                    res.append(False)\\n                    break\\n            else:\\n                res.append(True)\\n                groups.connect(a, b)\\n        \\n        return res\\n\\n\\n\\n\\n            \\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3485591,
                "title": "c-easy-solution-disjoint-set-optimal-solution",
                "content": "\\n\\n# Code\\n```\\nclass DisjointSet {\\n    vector<int> rank, parent, size;\\npublic:\\n    DisjointSet(int n) {\\n        rank.resize(n + 1, 0);\\n        parent.resize(n + 1);\\n        size.resize(n + 1);\\n        for (int i = 0; i <= n; i++) {\\n            parent[i] = i;\\n            size[i] = 1;\\n        }\\n    }\\n\\n    int findUPar(int node) {\\n        if (node == parent[node])\\n            return node;\\n        return parent[node] = findUPar(parent[node]);\\n    }\\n\\n    void unionByRank(int u, int v) {\\n        int ulp_u = findUPar(u);\\n        int ulp_v = findUPar(v);\\n        if (ulp_u == ulp_v) return;\\n        if (rank[ulp_u] < rank[ulp_v]) {\\n            parent[ulp_u] = ulp_v;\\n        }\\n        else if (rank[ulp_v] < rank[ulp_u]) {\\n            parent[ulp_v] = ulp_u;\\n        }\\n        else {\\n            parent[ulp_v] = ulp_u;\\n            rank[ulp_u]++;\\n        }\\n    }\\n\\n    void unionBySize(int u, int v) {\\n        int ulp_u = findUPar(u);\\n        int ulp_v = findUPar(v);\\n        if (ulp_u == ulp_v) return;\\n        if (size[ulp_u] < size[ulp_v]) {\\n            parent[ulp_u] = ulp_v;\\n            size[ulp_v] += size[ulp_u];\\n        }\\n        else {\\n            parent[ulp_v] = ulp_u;\\n            size[ulp_u] += size[ulp_v];\\n        }\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        int size=requests.size();\\n        DisjointSet ds(n);\\n        vector<bool> ans(size,false);\\n        for(int i=0;i<size;i++){\\n            int u=ds.findUPar(requests[i][0]);\\n            int v=ds.findUPar(requests[i][1]);\\n            bool flag=true;\\n            for(int j=0;j<restrictions.size();j++){\\n                int new_u=ds.findUPar(restrictions[j][0]);\\n                int new_v=ds.findUPar(restrictions[j][1]);\\n                if((new_u==u && new_v==v) || (new_u==v && new_v==u)){\\n                    flag=false;\\n                    break;\\n                }\\n            }\\n            if(flag){\\n                ds.unionByRank(requests[i][0],requests[i][1]);\\n                ans[i]=true;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\nclass DisjointSet {\\n    vector<int> rank, parent, size;\\npublic:\\n    DisjointSet(int n) {\\n        rank.resize(n + 1, 0);\\n        parent.resize(n + 1);\\n        size.resize(n + 1);\\n        for (int i = 0; i <= n; i++) {\\n            parent[i] = i;\\n            size[i] = 1;\\n        }\\n    }\\n\\n    int findUPar(int node) {\\n        if (node == parent[node])\\n            return node;\\n        return parent[node] = findUPar(parent[node]);\\n    }\\n\\n    void unionByRank(int u, int v) {\\n        int ulp_u = findUPar(u);\\n        int ulp_v = findUPar(v);\\n        if (ulp_u == ulp_v) return;\\n        if (rank[ulp_u] < rank[ulp_v]) {\\n            parent[ulp_u] = ulp_v;\\n        }\\n        else if (rank[ulp_v] < rank[ulp_u]) {\\n            parent[ulp_v] = ulp_u;\\n        }\\n        else {\\n            parent[ulp_v] = ulp_u;\\n            rank[ulp_u]++;\\n        }\\n    }\\n\\n    void unionBySize(int u, int v) {\\n        int ulp_u = findUPar(u);\\n        int ulp_v = findUPar(v);\\n        if (ulp_u == ulp_v) return;\\n        if (size[ulp_u] < size[ulp_v]) {\\n            parent[ulp_u] = ulp_v;\\n            size[ulp_v] += size[ulp_u];\\n        }\\n        else {\\n            parent[ulp_v] = ulp_u;\\n            size[ulp_u] += size[ulp_v];\\n        }\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        int size=requests.size();\\n        DisjointSet ds(n);\\n        vector<bool> ans(size,false);\\n        for(int i=0;i<size;i++){\\n            int u=ds.findUPar(requests[i][0]);\\n            int v=ds.findUPar(requests[i][1]);\\n            bool flag=true;\\n            for(int j=0;j<restrictions.size();j++){\\n                int new_u=ds.findUPar(restrictions[j][0]);\\n                int new_v=ds.findUPar(restrictions[j][1]);\\n                if((new_u==u && new_v==v) || (new_u==v && new_v==u)){\\n                    flag=false;\\n                    break;\\n                }\\n            }\\n            if(flag){\\n                ds.unionByRank(requests[i][0],requests[i][1]);\\n                ans[i]=true;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3485588,
                "title": "c-easy-solution-disjoint-set-optimal-solution",
                "content": "\\n\\n# Code\\n```\\nclass DisjointSet {\\n    vector<int> rank, parent, size;\\npublic:\\n    DisjointSet(int n) {\\n        rank.resize(n + 1, 0);\\n        parent.resize(n + 1);\\n        size.resize(n + 1);\\n        for (int i = 0; i <= n; i++) {\\n            parent[i] = i;\\n            size[i] = 1;\\n        }\\n    }\\n\\n    int findUPar(int node) {\\n        if (node == parent[node])\\n            return node;\\n        return parent[node] = findUPar(parent[node]);\\n    }\\n\\n    void unionByRank(int u, int v) {\\n        int ulp_u = findUPar(u);\\n        int ulp_v = findUPar(v);\\n        if (ulp_u == ulp_v) return;\\n        if (rank[ulp_u] < rank[ulp_v]) {\\n            parent[ulp_u] = ulp_v;\\n        }\\n        else if (rank[ulp_v] < rank[ulp_u]) {\\n            parent[ulp_v] = ulp_u;\\n        }\\n        else {\\n            parent[ulp_v] = ulp_u;\\n            rank[ulp_u]++;\\n        }\\n    }\\n\\n    void unionBySize(int u, int v) {\\n        int ulp_u = findUPar(u);\\n        int ulp_v = findUPar(v);\\n        if (ulp_u == ulp_v) return;\\n        if (size[ulp_u] < size[ulp_v]) {\\n            parent[ulp_u] = ulp_v;\\n            size[ulp_v] += size[ulp_u];\\n        }\\n        else {\\n            parent[ulp_v] = ulp_u;\\n            size[ulp_u] += size[ulp_v];\\n        }\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        int size=requests.size();\\n        DisjointSet ds(n);\\n        vector<bool> ans(size,false);\\n        for(int i=0;i<size;i++){\\n            int u=ds.findUPar(requests[i][0]);\\n            int v=ds.findUPar(requests[i][1]);\\n            bool flag=true;\\n            for(int j=0;j<restrictions.size();j++){\\n                int new_u=ds.findUPar(restrictions[j][0]);\\n                int new_v=ds.findUPar(restrictions[j][1]);\\n                if((new_u==u && new_v==v) || (new_u==v && new_v==u)){\\n                    flag=false;\\n                    break;\\n                }\\n            }\\n            if(flag){\\n                ds.unionByRank(requests[i][0],requests[i][1]);\\n                ans[i]=true;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\nclass DisjointSet {\\n    vector<int> rank, parent, size;\\npublic:\\n    DisjointSet(int n) {\\n        rank.resize(n + 1, 0);\\n        parent.resize(n + 1);\\n        size.resize(n + 1);\\n        for (int i = 0; i <= n; i++) {\\n            parent[i] = i;\\n            size[i] = 1;\\n        }\\n    }\\n\\n    int findUPar(int node) {\\n        if (node == parent[node])\\n            return node;\\n        return parent[node] = findUPar(parent[node]);\\n    }\\n\\n    void unionByRank(int u, int v) {\\n        int ulp_u = findUPar(u);\\n        int ulp_v = findUPar(v);\\n        if (ulp_u == ulp_v) return;\\n        if (rank[ulp_u] < rank[ulp_v]) {\\n            parent[ulp_u] = ulp_v;\\n        }\\n        else if (rank[ulp_v] < rank[ulp_u]) {\\n            parent[ulp_v] = ulp_u;\\n        }\\n        else {\\n            parent[ulp_v] = ulp_u;\\n            rank[ulp_u]++;\\n        }\\n    }\\n\\n    void unionBySize(int u, int v) {\\n        int ulp_u = findUPar(u);\\n        int ulp_v = findUPar(v);\\n        if (ulp_u == ulp_v) return;\\n        if (size[ulp_u] < size[ulp_v]) {\\n            parent[ulp_u] = ulp_v;\\n            size[ulp_v] += size[ulp_u];\\n        }\\n        else {\\n            parent[ulp_v] = ulp_u;\\n            size[ulp_u] += size[ulp_v];\\n        }\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        int size=requests.size();\\n        DisjointSet ds(n);\\n        vector<bool> ans(size,false);\\n        for(int i=0;i<size;i++){\\n            int u=ds.findUPar(requests[i][0]);\\n            int v=ds.findUPar(requests[i][1]);\\n            bool flag=true;\\n            for(int j=0;j<restrictions.size();j++){\\n                int new_u=ds.findUPar(restrictions[j][0]);\\n                int new_v=ds.findUPar(restrictions[j][1]);\\n                if((new_u==u && new_v==v) || (new_u==v && new_v==u)){\\n                    flag=false;\\n                    break;\\n                }\\n            }\\n            if(flag){\\n                ds.unionByRank(requests[i][0],requests[i][1]);\\n                ans[i]=true;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3485587,
                "title": "c-easy-solution-disjoint-set-optimal-solution",
                "content": "\\n\\n# Code\\n```\\nclass DisjointSet {\\n    vector<int> rank, parent, size;\\npublic:\\n    DisjointSet(int n) {\\n        rank.resize(n + 1, 0);\\n        parent.resize(n + 1);\\n        size.resize(n + 1);\\n        for (int i = 0; i <= n; i++) {\\n            parent[i] = i;\\n            size[i] = 1;\\n        }\\n    }\\n\\n    int findUPar(int node) {\\n        if (node == parent[node])\\n            return node;\\n        return parent[node] = findUPar(parent[node]);\\n    }\\n\\n    void unionByRank(int u, int v) {\\n        int ulp_u = findUPar(u);\\n        int ulp_v = findUPar(v);\\n        if (ulp_u == ulp_v) return;\\n        if (rank[ulp_u] < rank[ulp_v]) {\\n            parent[ulp_u] = ulp_v;\\n        }\\n        else if (rank[ulp_v] < rank[ulp_u]) {\\n            parent[ulp_v] = ulp_u;\\n        }\\n        else {\\n            parent[ulp_v] = ulp_u;\\n            rank[ulp_u]++;\\n        }\\n    }\\n\\n    void unionBySize(int u, int v) {\\n        int ulp_u = findUPar(u);\\n        int ulp_v = findUPar(v);\\n        if (ulp_u == ulp_v) return;\\n        if (size[ulp_u] < size[ulp_v]) {\\n            parent[ulp_u] = ulp_v;\\n            size[ulp_v] += size[ulp_u];\\n        }\\n        else {\\n            parent[ulp_v] = ulp_u;\\n            size[ulp_u] += size[ulp_v];\\n        }\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        int size=requests.size();\\n        DisjointSet ds(n);\\n        vector<bool> ans(size,false);\\n        for(int i=0;i<size;i++){\\n            int u=ds.findUPar(requests[i][0]);\\n            int v=ds.findUPar(requests[i][1]);\\n            bool flag=true;\\n            for(int j=0;j<restrictions.size();j++){\\n                int new_u=ds.findUPar(restrictions[j][0]);\\n                int new_v=ds.findUPar(restrictions[j][1]);\\n                if((new_u==u && new_v==v) || (new_u==v && new_v==u)){\\n                    flag=false;\\n                    break;\\n                }\\n            }\\n            if(flag){\\n                ds.unionByRank(requests[i][0],requests[i][1]);\\n                ans[i]=true;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\nclass DisjointSet {\\n    vector<int> rank, parent, size;\\npublic:\\n    DisjointSet(int n) {\\n        rank.resize(n + 1, 0);\\n        parent.resize(n + 1);\\n        size.resize(n + 1);\\n        for (int i = 0; i <= n; i++) {\\n            parent[i] = i;\\n            size[i] = 1;\\n        }\\n    }\\n\\n    int findUPar(int node) {\\n        if (node == parent[node])\\n            return node;\\n        return parent[node] = findUPar(parent[node]);\\n    }\\n\\n    void unionByRank(int u, int v) {\\n        int ulp_u = findUPar(u);\\n        int ulp_v = findUPar(v);\\n        if (ulp_u == ulp_v) return;\\n        if (rank[ulp_u] < rank[ulp_v]) {\\n            parent[ulp_u] = ulp_v;\\n        }\\n        else if (rank[ulp_v] < rank[ulp_u]) {\\n            parent[ulp_v] = ulp_u;\\n        }\\n        else {\\n            parent[ulp_v] = ulp_u;\\n            rank[ulp_u]++;\\n        }\\n    }\\n\\n    void unionBySize(int u, int v) {\\n        int ulp_u = findUPar(u);\\n        int ulp_v = findUPar(v);\\n        if (ulp_u == ulp_v) return;\\n        if (size[ulp_u] < size[ulp_v]) {\\n            parent[ulp_u] = ulp_v;\\n            size[ulp_v] += size[ulp_u];\\n        }\\n        else {\\n            parent[ulp_v] = ulp_u;\\n            size[ulp_u] += size[ulp_v];\\n        }\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        int size=requests.size();\\n        DisjointSet ds(n);\\n        vector<bool> ans(size,false);\\n        for(int i=0;i<size;i++){\\n            int u=ds.findUPar(requests[i][0]);\\n            int v=ds.findUPar(requests[i][1]);\\n            bool flag=true;\\n            for(int j=0;j<restrictions.size();j++){\\n                int new_u=ds.findUPar(restrictions[j][0]);\\n                int new_v=ds.findUPar(restrictions[j][1]);\\n                if((new_u==u && new_v==v) || (new_u==v && new_v==u)){\\n                    flag=false;\\n                    break;\\n                }\\n            }\\n            if(flag){\\n                ds.unionByRank(requests[i][0],requests[i][1]);\\n                ans[i]=true;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3476063,
                "title": "clean-code-union-find-with-explanation",
                "content": "# Approach\\nWe can use disjoin set union to keep track of friendships.\\nWe maintain a map of restritions which is updated whenever we do union of two elements.\\nFor every friend request(a,b) we check the following:-\\n- If both persons belong to same group then the request is accepted\\n- If a is in blockList of b **OR** b is in blockList of a then friend request is not accepted\\n- Else, we perform union operation and update the blockedList as well\\n\\n# Complexity\\n- Time complexity: \\nIf we use UF with rank then, worst case would be O(requests * restrictions)\\n\\n- Space complexity:\\nO(requests+restrictions)\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        DSU dsu = new DSU(n, restrictions);\\n        boolean[] ans = new boolean[requests.length];\\n        int i = 0;\\n        for(int req[]: requests) {\\n            if(!dsu.union(req[0], req[1])) {\\n                ans[i] = false;\\n            } else {\\n                ans[i] = true;\\n            }\\n            i++;\\n        } \\n        \\n        return ans;\\n    }\\n}\\n\\nclass DSU {\\n    int parent[];\\n    HashSet<Integer> noMap[];\\n    DSU(int n, int[][] restrictions) {\\n        parent = new int[n];\\n        noMap = new HashSet[n];\\n        for(int i=0;i<n;i++) {\\n            noMap[i] = new HashSet<>();\\n            parent[i] = i;\\n        }\\n\\n        for(int[] res: restrictions) {\\n            noMap[res[0]].add(res[1]);\\n            noMap[res[1]].add(res[0]);\\n        }\\n    }\\n    \\n    int findParent(int x) {\\n        while(x!=parent[x]) {\\n            x = parent[x];\\n            parent[x] = parent[parent[x]];\\n        }\\n        \\n        return x;\\n    }\\n    \\n    boolean union(int x, int y) {\\n        int px = findParent(x);\\n        int py = findParent(y);\\n        \\n        if(px==py) {\\n            return true;\\n        }\\n        if (noMap[px].contains(py) || noMap[py].contains(px)) {\\n            return false;\\n        }\\n\\n        parent[py] = px;\\n        \\n        // update no map => all py\\'s restrictions will be added to px as well\\n        for(int child: noMap[py]) {\\n            noMap[px].add(findParent(child));\\n        }\\n\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        DSU dsu = new DSU(n, restrictions);\\n        boolean[] ans = new boolean[requests.length];\\n        int i = 0;\\n        for(int req[]: requests) {\\n            if(!dsu.union(req[0], req[1])) {\\n                ans[i] = false;\\n            } else {\\n                ans[i] = true;\\n            }\\n            i++;\\n        } \\n        \\n        return ans;\\n    }\\n}\\n\\nclass DSU {\\n    int parent[];\\n    HashSet<Integer> noMap[];\\n    DSU(int n, int[][] restrictions) {\\n        parent = new int[n];\\n        noMap = new HashSet[n];\\n        for(int i=0;i<n;i++) {\\n            noMap[i] = new HashSet<>();\\n            parent[i] = i;\\n        }\\n\\n        for(int[] res: restrictions) {\\n            noMap[res[0]].add(res[1]);\\n            noMap[res[1]].add(res[0]);\\n        }\\n    }\\n    \\n    int findParent(int x) {\\n        while(x!=parent[x]) {\\n            x = parent[x];\\n            parent[x] = parent[parent[x]];\\n        }\\n        \\n        return x;\\n    }\\n    \\n    boolean union(int x, int y) {\\n        int px = findParent(x);\\n        int py = findParent(y);\\n        \\n        if(px==py) {\\n            return true;\\n        }\\n        if (noMap[px].contains(py) || noMap[py].contains(px)) {\\n            return false;\\n        }\\n\\n        parent[py] = px;\\n        \\n        // update no map => all py\\'s restrictions will be added to px as well\\n        for(int child: noMap[py]) {\\n            noMap[px].add(findParent(child));\\n        }\\n\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3469869,
                "title": "intuitive-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int find_set(int v , vector<int> &parent) {\\n        if (v == parent[v])\\n            return v;\\n        return parent[v] = find_set(parent[v] , parent);\\n    }\\n    void make_set(int v , vector<int> &parent  , vector<int> &rank) {\\n        parent[v] = v;\\n        rank[v] = 0;\\n    }\\n\\n    void union_sets(int a, int b , vector<int> &parent , vector<int> &rank) {\\n        a = find_set(a , parent);\\n        b = find_set(b , parent);\\n        if (a != b) {\\n            if (rank[a] < rank[b]){\\n                parent[b] = a;\\n            }\\n            else if(rank[a] > rank[b]){\\n                parent[a] = b;\\n            }\\n            if (rank[a] == rank[b]){\\n                parent[b] = a;\\n                rank[a]++;\\n            }\\n        }\\n    }\\n\\n    vector<bool> friendRequests(int n, vector<vector<int>>& res, vector<vector<int>>& req) {\\n        vector<int> par(n+2);\\n        vector<int> rank(n+2);\\n        vector<bool> ans(req.size() , 0);\\n\\n\\n        for(int i = 1 ; i <= n ; i++){\\n            make_set(i , par , rank);\\n        }\\n\\n        for(int it = 0 ; it < req.size() ; it++){\\n            \\n            vector<int> copypar = par;\\n            vector<int> copyrank = rank;\\n\\n            union_sets(req[it][0] , req[it][1] , par , rank);\\n            bool ok = true;\\n            for(auto i : res){\\n\\n                int a = find_set(i[0], par);\\n                int b = find_set(i[1] , par);\\n\\n                if(a == b){\\n                    ok = false;\\n                    break;\\n                }\\n\\n            }\\n\\n            if(!ok){\\n                par = copypar;\\n                rank = copyrank;\\n            }\\n            else{\\n                ans[it] = 1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int find_set(int v , vector<int> &parent) {\\n        if (v == parent[v])\\n            return v;\\n        return parent[v] = find_set(parent[v] , parent);\\n    }\\n    void make_set(int v , vector<int> &parent  , vector<int> &rank) {\\n        parent[v] = v;\\n        rank[v] = 0;\\n    }\\n\\n    void union_sets(int a, int b , vector<int> &parent , vector<int> &rank) {\\n        a = find_set(a , parent);\\n        b = find_set(b , parent);\\n        if (a != b) {\\n            if (rank[a] < rank[b]){\\n                parent[b] = a;\\n            }\\n            else if(rank[a] > rank[b]){\\n                parent[a] = b;\\n            }\\n            if (rank[a] == rank[b]){\\n                parent[b] = a;\\n                rank[a]++;\\n            }\\n        }\\n    }\\n\\n    vector<bool> friendRequests(int n, vector<vector<int>>& res, vector<vector<int>>& req) {\\n        vector<int> par(n+2);\\n        vector<int> rank(n+2);\\n        vector<bool> ans(req.size() , 0);\\n\\n\\n        for(int i = 1 ; i <= n ; i++){\\n            make_set(i , par , rank);\\n        }\\n\\n        for(int it = 0 ; it < req.size() ; it++){\\n            \\n            vector<int> copypar = par;\\n            vector<int> copyrank = rank;\\n\\n            union_sets(req[it][0] , req[it][1] , par , rank);\\n            bool ok = true;\\n            for(auto i : res){\\n\\n                int a = find_set(i[0], par);\\n                int b = find_set(i[1] , par);\\n\\n                if(a == b){\\n                    ok = false;\\n                    break;\\n                }\\n\\n            }\\n\\n            if(!ok){\\n                par = copypar;\\n                rank = copyrank;\\n            }\\n            else{\\n                ans[it] = 1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3396322,
                "title": "easy-c-dsu-solution",
                "content": "# Code\\n```\\nclass Solution {\\nprivate:\\n    class DSU{\\n        public:\\n            vector<int> parent,size;\\n            DSU(int n){\\n                parent.resize(n);\\n                size.resize(n);\\n                for(int i=0;i<n;i++){\\n                    parent[i]=i;\\n                    size[i]=1;\\n                }\\n            }\\n\\n            int findParent(int u){\\n                if(u==parent[u]) return u;\\n                else return parent[u]=findParent(parent[u]);\\n            }\\n\\n            void Union(int u, int v){\\n                int par_u = findParent(u);\\n                int par_v = findParent(v);\\n                if(par_u==par_v) return;\\n                if(size[par_u]<size[par_v]){\\n                    size[par_v]+=size[par_u];\\n                    parent[par_u]=par_v;\\n                }else{\\n                    size[par_u]+=size[par_v];\\n                    parent[par_v]=par_u;\\n                }\\n            }\\n            \\n            bool check(int &u, int &v, vector<vector<int>>& restrictions){\\n                int par_u = findParent(u);\\n                int par_v = findParent(v);\\n                for(auto &res:restrictions){\\n                    int res_par_u = findParent(res[0]);\\n                    int res_par_v = findParent(res[1]);\\n                    if(par_u==res_par_u and par_v==res_par_v) return false;\\n                    else if(par_u==res_par_v and par_v==res_par_u) return false;\\n                }\\n                Union(u,v);\\n                return true;\\n            }\\n    };\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        DSU dsu(n);\\n        int m = requests.size();\\n        vector<bool> ans(m);\\n        for(int i=0;i<m;i++){\\n            int u = requests[i][0];\\n            int v = requests[i][1];\\n            ans[i] = dsu.check(u,v,restrictions);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    class DSU{\\n        public:\\n            vector<int> parent,size;\\n            DSU(int n){\\n                parent.resize(n);\\n                size.resize(n);\\n                for(int i=0;i<n;i++){\\n                    parent[i]=i;\\n                    size[i]=1;\\n                }\\n            }\\n\\n            int findParent(int u){\\n                if(u==parent[u]) return u;\\n                else return parent[u]=findParent(parent[u]);\\n            }\\n\\n            void Union(int u, int v){\\n                int par_u = findParent(u);\\n                int par_v = findParent(v);\\n                if(par_u==par_v) return;\\n                if(size[par_u]<size[par_v]){\\n                    size[par_v]+=size[par_u];\\n                    parent[par_u]=par_v;\\n                }else{\\n                    size[par_u]+=size[par_v];\\n                    parent[par_v]=par_u;\\n                }\\n            }\\n            \\n            bool check(int &u, int &v, vector<vector<int>>& restrictions){\\n                int par_u = findParent(u);\\n                int par_v = findParent(v);\\n                for(auto &res:restrictions){\\n                    int res_par_u = findParent(res[0]);\\n                    int res_par_v = findParent(res[1]);\\n                    if(par_u==res_par_u and par_v==res_par_v) return false;\\n                    else if(par_u==res_par_v and par_v==res_par_u) return false;\\n                }\\n                Union(u,v);\\n                return true;\\n            }\\n    };\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        DSU dsu(n);\\n        int m = requests.size();\\n        vector<bool> ans(m);\\n        for(int i=0;i<m;i++){\\n            int u = requests[i][0];\\n            int v = requests[i][1];\\n            ans[i] = dsu.check(u,v,restrictions);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3337242,
                "title": "c-union-find",
                "content": "```\\n\\nclass DisjointSet \\n{\\n    vector<int> rank, parent, size; \\npublic: \\n    DisjointSet(int n) {\\n        rank.resize(n+1, 0); \\n        parent.resize(n+1);\\n        size.resize(n+1); \\n        for(int i = 0;i<=n;i++) {\\n            parent[i] = i; \\n            size[i] = 1; \\n        }\\n    }\\n\\n    int findUPar(int node) {\\n        if(node == parent[node])\\n            return node; \\n        return parent[node] = findUPar(parent[node]); \\n    }\\n\\n    void unionByRank(int u, int v) {\\n        int ulp_u = findUPar(u); \\n        int ulp_v = findUPar(v); \\n        if(ulp_u == ulp_v) return; \\n        if(rank[ulp_u] < rank[ulp_v]) {\\n            parent[ulp_u] = ulp_v; \\n        }\\n        else if(rank[ulp_v] < rank[ulp_u]) {\\n            parent[ulp_v] = ulp_u; \\n        }\\n        else {\\n            parent[ulp_v] = ulp_u; \\n            rank[ulp_u]++; \\n        }\\n    }\\n\\n    void unionBySize(int u, int v) {\\n        int ulp_u = findUPar(u); \\n        int ulp_v = findUPar(v); \\n        if(ulp_u == ulp_v) return; \\n        if(size[ulp_u] < size[ulp_v]) {\\n            parent[ulp_u] = ulp_v; \\n            size[ulp_v] += size[ulp_u]; \\n        }\\n        else {\\n            parent[ulp_v] = ulp_u;\\n            size[ulp_u] += size[ulp_v]; \\n        }\\n    }\\n}; \\nclass Solution {\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        DisjointSet ds(n);\\n        vector<bool>ans;\\n        for(auto it:requests)\\n        {\\n            int u=ds.findUPar(it[0]);\\n            int v=ds.findUPar(it[1]);\\n            int flag=0;\\n            for(auto itr:restrictions)\\n            {\\n                int u1=ds.findUPar(itr[0]);\\n                int v1=ds.findUPar(itr[1]);\\n                if((u==u1 and v==v1) or(u==v1 and v==u1)){\\n                    flag=1;\\n                    ans.push_back(false);\\n                    break;\\n                }\\n                \\n            }\\n            if(flag==0){\\n                ans.push_back(true);\\n                ds.unionBySize(u,v);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Union Find"
                ],
                "code": "```\\n\\nclass DisjointSet \\n{\\n    vector<int> rank, parent, size; \\npublic: \\n    DisjointSet(int n) {\\n        rank.resize(n+1, 0); \\n        parent.resize(n+1);\\n        size.resize(n+1); \\n        for(int i = 0;i<=n;i++) {\\n            parent[i] = i; \\n            size[i] = 1; \\n        }\\n    }\\n\\n    int findUPar(int node) {\\n        if(node == parent[node])\\n            return node; \\n        return parent[node] = findUPar(parent[node]); \\n    }\\n\\n    void unionByRank(int u, int v) {\\n        int ulp_u = findUPar(u); \\n        int ulp_v = findUPar(v); \\n        if(ulp_u == ulp_v) return; \\n        if(rank[ulp_u] < rank[ulp_v]) {\\n            parent[ulp_u] = ulp_v; \\n        }\\n        else if(rank[ulp_v] < rank[ulp_u]) {\\n            parent[ulp_v] = ulp_u; \\n        }\\n        else {\\n            parent[ulp_v] = ulp_u; \\n            rank[ulp_u]++; \\n        }\\n    }\\n\\n    void unionBySize(int u, int v) {\\n        int ulp_u = findUPar(u); \\n        int ulp_v = findUPar(v); \\n        if(ulp_u == ulp_v) return; \\n        if(size[ulp_u] < size[ulp_v]) {\\n            parent[ulp_u] = ulp_v; \\n            size[ulp_v] += size[ulp_u]; \\n        }\\n        else {\\n            parent[ulp_v] = ulp_u;\\n            size[ulp_u] += size[ulp_v]; \\n        }\\n    }\\n}; \\nclass Solution {\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        DisjointSet ds(n);\\n        vector<bool>ans;\\n        for(auto it:requests)\\n        {\\n            int u=ds.findUPar(it[0]);\\n            int v=ds.findUPar(it[1]);\\n            int flag=0;\\n            for(auto itr:restrictions)\\n            {\\n                int u1=ds.findUPar(itr[0]);\\n                int v1=ds.findUPar(itr[1]);\\n                if((u==u1 and v==v1) or(u==v1 and v==u1)){\\n                    flag=1;\\n                    ans.push_back(false);\\n                    break;\\n                }\\n                \\n            }\\n            if(flag==0){\\n                ans.push_back(true);\\n                ds.unionBySize(u,v);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3335578,
                "title": "c-unionfind",
                "content": "```\\npublic class Solution {\\n    \\n    \\n    public bool[] FriendRequests(int n, int[][] restrictions, int[][] requests) {\\n        UF uf=new UF(n);\\n        bool[] res=new bool[requests.Length];\\n        \\n        foreach(int[] r in restrictions)\\n            uf.addRestriction(r[0],r[1]);\\n        \\n        for(int i=0;i<requests.Length;i++)\\n        {\\n            res[i]=uf.union(requests[i][0],requests[i][1]);\\n            \\n        }\\n            \\n            \\n        return res;\\n    }\\n}\\n\\n\\n\\npublic class UF{\\n    int[] parent ;\\n    HashSet<int>[] ds;\\n    HashSet<int>[] members;\\n\\n    public UF(int size){\\n        parent=Enumerable.Range(0,size).ToArray();\\n        ds=Enumerable.Range(0,size).Select(x=>new HashSet<int>()).ToArray();\\n        members=Enumerable.Range(0,size).Select(x=>new HashSet<int>(new int[1]{x})).ToArray();\\n        \\n    }\\n    \\n    public int find(int node){\\n        if(parent[node]!=node)\\n            parent[node]=find(parent[node]);\\n        \\n        return parent[node];\\n    }\\n    \\n    \\n    public bool union(int i,int j){\\n        int pi=find(i);\\n        int pj=find(j);\\n        \\n        if(pi==pj)\\n            return true;\\n        \\n        if(ds[pi].Overlaps(members[pj]))\\n            return false;\\n        \\n        if(ds[pj].Overlaps(members[pi]))\\n            return false;\\n\\n        \\n        //Print(pi,ds[pi]);\\n        //Print(pj,ds[pj]);\\n        \\n        parent[pj]=pi;\\n        ds[pi].UnionWith(ds[pj]);\\n        members[pi].UnionWith(members[pj]);\\n        return true;\\n        \\n    }\\n    \\n    public void addRestriction(int i,int j)\\n    {\\n        ds[i].Add(j);\\n        ds[j].Add(i);\\n    }\\n    \\n    public void Print(int pi, HashSet<int> hs)\\n    {\\n        Console.WriteLine($\"pi={pi}  \");\\n        \\n        foreach(int i in hs)\\n            Console.WriteLine($\"{i}  \");\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Union Find"
                ],
                "code": "```\\npublic class Solution {\\n    \\n    \\n    public bool[] FriendRequests(int n, int[][] restrictions, int[][] requests) {\\n        UF uf=new UF(n);\\n        bool[] res=new bool[requests.Length];\\n        \\n        foreach(int[] r in restrictions)\\n            uf.addRestriction(r[0],r[1]);\\n        \\n        for(int i=0;i<requests.Length;i++)\\n        {\\n            res[i]=uf.union(requests[i][0],requests[i][1]);\\n            \\n        }\\n            \\n            \\n        return res;\\n    }\\n}\\n\\n\\n\\npublic class UF{\\n    int[] parent ;\\n    HashSet<int>[] ds;\\n    HashSet<int>[] members;\\n\\n    public UF(int size){\\n        parent=Enumerable.Range(0,size).ToArray();\\n        ds=Enumerable.Range(0,size).Select(x=>new HashSet<int>()).ToArray();\\n        members=Enumerable.Range(0,size).Select(x=>new HashSet<int>(new int[1]{x})).ToArray();\\n        \\n    }\\n    \\n    public int find(int node){\\n        if(parent[node]!=node)\\n            parent[node]=find(parent[node]);\\n        \\n        return parent[node];\\n    }\\n    \\n    \\n    public bool union(int i,int j){\\n        int pi=find(i);\\n        int pj=find(j);\\n        \\n        if(pi==pj)\\n            return true;\\n        \\n        if(ds[pi].Overlaps(members[pj]))\\n            return false;\\n        \\n        if(ds[pj].Overlaps(members[pi]))\\n            return false;\\n\\n        \\n        //Print(pi,ds[pi]);\\n        //Print(pj,ds[pj]);\\n        \\n        parent[pj]=pi;\\n        ds[pi].UnionWith(ds[pj]);\\n        members[pi].UnionWith(members[pj]);\\n        return true;\\n        \\n    }\\n    \\n    public void addRestriction(int i,int j)\\n    {\\n        ds[i].Add(j);\\n        ds[j].Add(i);\\n    }\\n    \\n    public void Print(int pi, HashSet<int> hs)\\n    {\\n        Console.WriteLine($\"pi={pi}  \");\\n        \\n        foreach(int i in hs)\\n            Console.WriteLine($\"{i}  \");\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3287788,
                "title": "through-dsu-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe first idea is to make a list of restricted friends and then to make friends we will make the graph. Now as the graph has to change in each iterations of the friend requests we have to apply the DSU so that we can easily find which can we make friends and which we cannot.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI have used the concept of DSU, so there will be one main friend to which all other will connected and while making the main node/friend we will add all the restricted friend of main node in child node and all of child node to main node so that we can easily check which people can become friends and which cannot.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int ultimateparent(vector<int>& parent,int n){\\n        if(parent[n]==n){\\n            return n;\\n        }\\n        return parent[n]=ultimateparent(parent,parent[n]);\\n    }\\n\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n\\n        map<int,set<int>> mymap;\\n        for(int i=0;i<restrictions.size();i++){\\n            mymap[restrictions[i][0]].insert(restrictions[i][1]);\\n            mymap[restrictions[i][1]].insert(restrictions[i][0]);\\n        }\\n\\n        vector<int> parent(n);\\n        vector<long long>size(n,1);\\n        for(int i=0;i<n;i++){\\n            parent[i]=i;\\n        }\\n\\n        vector<bool> ans(requests.size(),false);\\n        for(int i=0;i<requests.size();i++){\\n            set<int> temp = mymap[ultimateparent(parent,requests[i][0])];\\n            if(temp.find(ultimateparent(parent,requests[i][1]))!=temp.end()){\\n                continue;\\n            }\\n            else{\\n                int par1 = ultimateparent(parent,requests[i][0]);\\n                int par2 = ultimateparent(parent,requests[i][1]);\\n                if(size[par1]>size[par2]){\\n                    for(auto it=mymap[par2].begin();it!=mymap[par2].end();it++){\\n                        mymap[par1].insert(*it);\\n                        mymap[*it].insert(par1);\\n                    }\\n                    size[par1]+=size[par2];\\n                    parent[par2]=par1;\\n                }\\n                else{\\n                    for(auto it=mymap[par1].begin();it!=mymap[par1].end();it++){\\n                        mymap[par2].insert(*it);\\n                        mymap[*it].insert(par2);\\n                    }\\n                    size[par2]+=size[par1];\\n                    parent[par1]=par2;\\n                }\\n                ans[i]=true;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ultimateparent(vector<int>& parent,int n){\\n        if(parent[n]==n){\\n            return n;\\n        }\\n        return parent[n]=ultimateparent(parent,parent[n]);\\n    }\\n\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n\\n        map<int,set<int>> mymap;\\n        for(int i=0;i<restrictions.size();i++){\\n            mymap[restrictions[i][0]].insert(restrictions[i][1]);\\n            mymap[restrictions[i][1]].insert(restrictions[i][0]);\\n        }\\n\\n        vector<int> parent(n);\\n        vector<long long>size(n,1);\\n        for(int i=0;i<n;i++){\\n            parent[i]=i;\\n        }\\n\\n        vector<bool> ans(requests.size(),false);\\n        for(int i=0;i<requests.size();i++){\\n            set<int> temp = mymap[ultimateparent(parent,requests[i][0])];\\n            if(temp.find(ultimateparent(parent,requests[i][1]))!=temp.end()){\\n                continue;\\n            }\\n            else{\\n                int par1 = ultimateparent(parent,requests[i][0]);\\n                int par2 = ultimateparent(parent,requests[i][1]);\\n                if(size[par1]>size[par2]){\\n                    for(auto it=mymap[par2].begin();it!=mymap[par2].end();it++){\\n                        mymap[par1].insert(*it);\\n                        mymap[*it].insert(par1);\\n                    }\\n                    size[par1]+=size[par2];\\n                    parent[par2]=par1;\\n                }\\n                else{\\n                    for(auto it=mymap[par1].begin();it!=mymap[par1].end();it++){\\n                        mymap[par2].insert(*it);\\n                        mymap[*it].insert(par2);\\n                    }\\n                    size[par2]+=size[par1];\\n                    parent[par1]=par2;\\n                }\\n                ans[i]=true;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3192846,
                "title": "easy-java-code-union-and-find",
                "content": "class Solution {\\n    \\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n                boolean[] result = new boolean[requests.length];\\n\\n        if(restrictions==null || requests == null || requests[0].length==0)\\n        return result;\\n        DisjointSet ds = new DisjointSet(n);\\n        int index=0;\\n        boolean friends=false;\\n        for(int[] request : requests)\\n        {   friends=true;\\n            //find the representative of the friend 0\\n            int rep_0 = ds.find(request[0]);\\n              //find the representative of the friend 1\\n            int rep_1 = ds.find(request[1]);\\n\\n            //Now check if these representatives are enimies or not\\n\\n            for(int[] restriction : restrictions)\\n            {   int up1 = ds.find(restriction[0]);\\n                int up2 = ds.find(restriction[1]);\\n                if((rep_0 == up1 && rep_1 == up2) || (rep_0 == up2 &&rep_1 == up1) )\\n                {\\n                    friends=false;\\n                    //If they are inirect or direct enimies ,break\\n                    break;\\n                }\\n                \\n               \\n            }\\n            if(!friends)\\n            {\\n                 \\n                result[index++]=false;\\n\\n            }\\n            else\\n            {\\n                \\n                    result[index++]=true;\\n                    ds.union(request[0],request[1]);\\n            }\\n\\n\\n\\n        }\\n        return result;\\n    }\\n}\\n\\nclass DisjointSet\\n    {\\n         int length;\\n         int[] parent;\\n         int[] size;\\n\\n        public DisjointSet(int length)\\n        {\\n                this.length = length;\\n                parent = new int[length];\\n                size  = new int[length];\\n                for(int i =0 ; i < length;i++)\\n                {\\n                    parent[i]=i;\\n                    size[i]=1;\\n                }\\n        }\\n    \\n\\n    public int find(int cell)\\n    {\\n          if(parent[cell]==cell)\\n          return cell;\\n          parent[cell]=find(parent[cell]);\\n          return parent[cell];\\n    }\\n\\n    public void union(int cell1,int cell2)\\n    {\\n         int repa = find(cell1);\\n         int repb = find(cell2);\\n\\n         if(repa ==  repb)\\n         return ;\\n         if(size[repa] < size[repb])\\n         {\\n                parent[repa] = repb;\\n                size[repb] =+ size[repa];\\n         }\\n         else\\n         {\\n                parent[repb] = repa;\\n                size[repa] =+ size[repb];\\n         }\\n    }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    \\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n                boolean[] result = new boolean[requests.length];\\n\\n        if(restrictions==null || requests == null || requests[0].length==0)\\n        return result;\\n        DisjointSet ds = new DisjointSet(n);\\n        int index=0;\\n        boolean friends=false;\\n        for(int[] request : requests)\\n        {   friends=true;\\n            //find the representative of the friend 0\\n            int rep_0 = ds.find(request[0]);\\n              //find the representative of the friend 1\\n            int rep_1 = ds.find(request[1]);\\n\\n            //Now check if these representatives are enimies or not\\n\\n            for(int[] restriction : restrictions)\\n            {   int up1 = ds.find(restriction[0]);\\n                int up2 = ds.find(restriction[1]);\\n                if((rep_0 == up1 && rep_1 == up2) || (rep_0 == up2 &&rep_1 == up1) )\\n                {\\n                    friends=false;\\n                    //If they are inirect or direct enimies ,break\\n                    break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3179045,
                "title": "c-soln-using-dsu",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int rank[1001];\\n    int parent[1001];\\n\\n    void dsu(int n){\\n        for(int i=0;i<n;i++){\\n            rank[i] = 0;\\n            parent[i] = i;\\n        }\\n    }\\n\\n    int findParent(int x){\\n        if(parent[x] == x)\\n            return x;\\n        return parent[x] = findParent(parent[x]);\\n    }\\n\\n    void Union(int u, int v){\\n        int paru = findParent(u);\\n        int parv = findParent(v);\\n\\n        if(paru == parv)\\n            return;\\n        \\n        int ranku = rank[paru];\\n        int rankv = rank[parv];\\n\\n        if(ranku > rankv){\\n            parent[parv] = paru;\\n        }\\n        else if (rankv > ranku){\\n            parent[paru] = parv;\\n        }\\n        else{\\n            parent[paru] = parv;\\n            rank[parv]++;\\n        }\\n    }\\n\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        dsu(n);\\n        vector<bool>res(requests.size());\\n        for(int i=0;i<requests.size();i++){\\n            int a = requests[i][0];\\n            int b = requests[i][1];\\n\\n            int para = findParent(a);\\n            int parb = findParent(b);\\n            int flag = 0;\\n\\n            for(int j=0;j<restrictions.size();j++){\\n                int tmp1 = findParent(restrictions[j][0]);\\n                int tmp2 = findParent(restrictions[j][1]);\\n\\n                if((para == tmp1 && parb == tmp2) || (para == tmp2 && parb == tmp1)){\\n                    flag = 1;\\n                    break;\\n                }\\n            }\\n\\n            if(flag == 0){\\n                res[i] = true;\\n                Union(a, b);    \\n            }\\n            else\\n                res[i] = false;\\n\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rank[1001];\\n    int parent[1001];\\n\\n    void dsu(int n){\\n        for(int i=0;i<n;i++){\\n            rank[i] = 0;\\n            parent[i] = i;\\n        }\\n    }\\n\\n    int findParent(int x){\\n        if(parent[x] == x)\\n            return x;\\n        return parent[x] = findParent(parent[x]);\\n    }\\n\\n    void Union(int u, int v){\\n        int paru = findParent(u);\\n        int parv = findParent(v);\\n\\n        if(paru == parv)\\n            return;\\n        \\n        int ranku = rank[paru];\\n        int rankv = rank[parv];\\n\\n        if(ranku > rankv){\\n            parent[parv] = paru;\\n        }\\n        else if (rankv > ranku){\\n            parent[paru] = parv;\\n        }\\n        else{\\n            parent[paru] = parv;\\n            rank[parv]++;\\n        }\\n    }\\n\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        dsu(n);\\n        vector<bool>res(requests.size());\\n        for(int i=0;i<requests.size();i++){\\n            int a = requests[i][0];\\n            int b = requests[i][1];\\n\\n            int para = findParent(a);\\n            int parb = findParent(b);\\n            int flag = 0;\\n\\n            for(int j=0;j<restrictions.size();j++){\\n                int tmp1 = findParent(restrictions[j][0]);\\n                int tmp2 = findParent(restrictions[j][1]);\\n\\n                if((para == tmp1 && parb == tmp2) || (para == tmp2 && parb == tmp1)){\\n                    flag = 1;\\n                    break;\\n                }\\n            }\\n\\n            if(flag == 0){\\n                res[i] = true;\\n                Union(a, b);    \\n            }\\n            else\\n                res[i] = false;\\n\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3163172,
                "title": "c-fast-solution-union-find",
                "content": "# Intuition\\nUNION FIND:\\nFor every requests make an edge between the nodes. Then check for each restrictions(by checking the parent of both nodes). If parent of both nodes are same for any restriction, then it is not possible for this request to happen.\\n\\n# Approach\\nFor every requests make an edge between the nodes. Then check for each restrictions(by checking the parent of both nodes). If parent of both nodes are same for any restriction, then it is not possible for this request to happen.\\n\\n# Complexity\\n- Time complexity:\\nO(n*n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nvector<int>parent;\\nvector<int>rank;\\n\\nint find(int a) {\\n\\tif (parent[a] == -1) return a;\\n\\treturn parent[a] = find(parent[a]);\\n}\\n\\nvoid union_set(int a, int b) {\\n\\tint s1 = find(a), s2 = find(b);\\n\\tif (s1 != s2) {\\n\\t\\tif (rank[s1] > rank[s2]) {\\n\\t\\t\\tparent[s2] = s1;\\n\\t\\t\\trank[s1] += rank[s2];\\n\\t\\t} else {\\n\\t\\t\\tparent[s1] = s2;\\n\\t\\t\\trank[s2] += rank[s1];\\n\\t\\t}\\n\\t}\\n}\\n\\nvector<bool> friendRequests(int n, vector<vector<int>>& restrictions,\\n                            vector<vector<int>>& requests) {\\n\\tvector<bool>res;\\n\\tint len1 = restrictions.size(), len2 = requests.size();\\n\\tparent.resize(n, -1); rank.resize(n, 1);\\n\\tfor (int i = 0; i < len2; ++i)\\n\\t{\\n\\t\\tvector<int>dummy = parent;\\n\\t\\tunion_set(requests[i][0], requests[i][1]);\\n\\t\\tbool ans = true;\\n\\t\\tfor (int j = 0; j < len1; ++j)\\n\\t\\t{\\n\\t\\t\\tint s1 = find(restrictions[j][0]), s2 = find(restrictions[j][1]);\\n\\t\\t\\tif (s1 == s2) {\\n\\t\\t\\t\\tans = false;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (ans) res.push_back(true);\\n\\t\\telse {\\n\\t\\t\\tres.push_back(false);\\n\\t\\t\\tparent = dummy;\\n\\t\\t}\\n\\t}\\n\\treturn res;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvector<int>parent;\\nvector<int>rank;\\n\\nint find(int a) {\\n\\tif (parent[a] == -1) return a;\\n\\treturn parent[a] = find(parent[a]);\\n}\\n\\nvoid union_set(int a, int b) {\\n\\tint s1 = find(a), s2 = find(b);\\n\\tif (s1 != s2) {\\n\\t\\tif (rank[s1] > rank[s2]) {\\n\\t\\t\\tparent[s2] = s1;\\n\\t\\t\\trank[s1] += rank[s2];\\n\\t\\t} else {\\n\\t\\t\\tparent[s1] = s2;\\n\\t\\t\\trank[s2] += rank[s1];\\n\\t\\t}\\n\\t}\\n}\\n\\nvector<bool> friendRequests(int n, vector<vector<int>>& restrictions,\\n                            vector<vector<int>>& requests) {\\n\\tvector<bool>res;\\n\\tint len1 = restrictions.size(), len2 = requests.size();\\n\\tparent.resize(n, -1); rank.resize(n, 1);\\n\\tfor (int i = 0; i < len2; ++i)\\n\\t{\\n\\t\\tvector<int>dummy = parent;\\n\\t\\tunion_set(requests[i][0], requests[i][1]);\\n\\t\\tbool ans = true;\\n\\t\\tfor (int j = 0; j < len1; ++j)\\n\\t\\t{\\n\\t\\t\\tint s1 = find(restrictions[j][0]), s2 = find(restrictions[j][1]);\\n\\t\\t\\tif (s1 == s2) {\\n\\t\\t\\t\\tans = false;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (ans) res.push_back(true);\\n\\t\\telse {\\n\\t\\t\\tres.push_back(false);\\n\\t\\t\\tparent = dummy;\\n\\t\\t}\\n\\t}\\n\\treturn res;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3137911,
                "title": "c-dsu",
                "content": "```\\nclass Solution {\\npublic:\\n     int par[10000] ; \\n    int size[10000] ;\\n    void make(int v )\\n    {\\n    par[v]=v ;  \\n        size[v]=1  ;\\n    }\\n    \\n    int find(int v )\\n    {\\n        if(par[v]==v)\\n            return v ; \\n        return par[v]  = find(par[v]) ; \\n    }\\n    \\n    void Union(int u , int w )\\n    {\\n       int a  = find(u) ; \\n        int b = find(w)  ; \\n         if(a!=b)\\n         {\\n             \\n             if(size[a]<size[b])\\n             {\\n                 swap(a, b) ; \\n             }\\n             par[b] =a ; \\n             size[a]+=size[b]  ;\\n         }\\n \\n    }\\n    \\n    \\n    \\n    \\n    \\n    \\n    vector<bool> friendRequests(int n, vector<vector<int>>& res, vector<vector<int>>& req) {\\n       vector<bool> ans ;\\n        \\n        for(int i = 0; i<n; i++ )\\n        {\\n            make(i) ; \\n        }\\n        for(auto it : req )\\n        {\\n            int a = find(it[0]); \\n            int b = find(it[1]) ;\\n            int f=1 ;\\n            for(auto itr : res)\\n            {\\n                int ap = find(itr[0]) ;\\n                int bp = find(itr[1]) ;\\n                \\n                if(ap==a && bp==b || ap==b && bp==a)\\n                {\\n                    f=0;\\n                    break ;\\n                }\\n            }\\n            if(f)\\n                Union(a, b ) ;\\n            ans.push_back(f) ;\\n            \\n        }\\n        return ans; \\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     int par[10000] ; \\n    int size[10000] ;\\n    void make(int v )\\n    {\\n    par[v]=v ;  \\n        size[v]=1  ;\\n    }\\n    \\n    int find(int v )\\n    {\\n        if(par[v]==v)\\n            return v ; \\n        return par[v]  = find(par[v]) ; \\n    }\\n    \\n    void Union(int u , int w )\\n    {\\n       int a  = find(u) ; \\n        int b = find(w)  ; \\n         if(a!=b)\\n         {\\n             \\n             if(size[a]<size[b])\\n             {\\n                 swap(a, b) ; \\n             }\\n             par[b] =a ; \\n             size[a]+=size[b]  ;\\n         }\\n \\n    }\\n    \\n    \\n    \\n    \\n    \\n    \\n    vector<bool> friendRequests(int n, vector<vector<int>>& res, vector<vector<int>>& req) {\\n       vector<bool> ans ;\\n        \\n        for(int i = 0; i<n; i++ )\\n        {\\n            make(i) ; \\n        }\\n        for(auto it : req )\\n        {\\n            int a = find(it[0]); \\n            int b = find(it[1]) ;\\n            int f=1 ;\\n            for(auto itr : res)\\n            {\\n                int ap = find(itr[0]) ;\\n                int bp = find(itr[1]) ;\\n                \\n                if(ap==a && bp==b || ap==b && bp==a)\\n                {\\n                    f=0;\\n                    break ;\\n                }\\n            }\\n            if(f)\\n                Union(a, b ) ;\\n            ans.push_back(f) ;\\n            \\n        }\\n        return ans; \\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3070582,
                "title": "java-solution-beats-100-beginner-friendly-explanation",
                "content": "Intuition:  \\n (First Thought): \\n Let\\'s create a graph of the restricitons and use either bfs or dfs for each possible friend request to validate said request. \\n This would be slow, we would have to create the graph and then traverse it k (number of edges in graph) * n (number of requests) times. \\n Second Approach: \\n Have each individual represet their own set. Maintain a set of there restrictions and a set of their friends. Initially create the set of restrictions, they will be two way so if 0,1 is a restriction then zero should be in 1\\'s restricted set and vice versa. Next we can essentially create a graph of friends by using a union operation. If the union is possible (meaning the one individuals current set of friends does not contain individuals in the requested person\\'s restricted list), then the request is possible. \\n Process: \\n To achieve the union process, we use a find function which returns the head of the set the input individual belongs to. We could use a map for this or we can use an array where the index of the array represents a person (their integer value) and the value at the index represents the location of that individuals head. \\n Once we have the head of both sets we are trying to combine, we loop through the smaller of the two, checking if any of its members are restricted from the larger set. If they are, the union is impossible. If they are not, we union the smaller to the larger and change the location of the smaller set to the larger one. We do this for each request. \\n \\nTakeaway: \\nWe can use union-find algorithim to create a graph based on a given parameter, or ensure to sets can be combined based on that parameter\\n  \\n  Code Below:\\n ``` \\n class Solution { \\n    Set<Integer>[] rSet;  \\n    Set<Integer>[] fSet; \\n    int[] location;\\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        rSet = new Set[n];  \\n        fSet = new Set[n];\\n        location = new int[n]; \\n        boolean[] ans = new boolean[requests.length]; \\n        \\n        for(int i = 0; i<n; i++) { \\n            location[i] = i; \\n            rSet[i] = new HashSet<>();  \\n            fSet[i] = new HashSet<>(); \\n            fSet[i].add(i); \\n            \\n        }   \\n        \\n        for(int[] restriction: restrictions) { \\n            int a = restriction[0];\\n            int b = restriction[1]; \\n            rSet[a].add(b); \\n            rSet[b].add(a);\\n        }  \\n         \\n        for(int i = 0; i<requests.length; i++) {  \\n            int a = requests[i][0] ;\\n            int b = requests[i][1];\\n            ans[i] = union(a,b);\\n        } \\n        \\n        return ans;\\n    } \\n    public boolean union(Integer f1, Integer f2) { \\n        int f1Head = find(f1); \\n        int f2Head = find(f2); \\n        if(f1Head == f2Head) return true; \\n         \\n        int u1, u2; \\n        Set<Integer> f1Friends = fSet[f1Head]; \\n        Set<Integer> f2Friends = fSet[f2Head];\\n        if(f1Friends.size()>f2Friends.size()) { \\n            u1 = f1Head; \\n            u2 = f2Head;\\n        } \\n        else { \\n            u1 = f2Head; \\n            u2 = f1Head;\\n        } \\n        for(Integer friend : fSet[u2]) { \\n            if(rSet[u1].contains(friend)) return false;\\n        } \\n        \\n        fSet[u1].addAll(fSet[u2]); \\n        rSet[u1].addAll(rSet[u2]);  \\n        location[u2] = u1;\\n        \\n        fSet[u2] = null; \\n        rSet[u2] = null; \\n        return true;\\n    } \\n    public int find(int head) { \\n        return location[head] == head ? head : (location[head] = find(location[head]));\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "class Solution { \\n    Set<Integer>[] rSet;  \\n    Set<Integer>[] fSet; \\n    int[] location;\\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        rSet = new Set[n];  \\n        fSet = new Set[n];\\n        location = new int[n]; \\n        boolean[] ans = new boolean[requests.length]; \\n        \\n        for(int i = 0; i<n; i++) { \\n            location[i] = i; \\n            rSet[i] = new HashSet<>();  \\n            fSet[i] = new HashSet<>(); \\n            fSet[i].add(i); \\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3055173,
                "title": "golang-union-find",
                "content": "# Code\\n```\\nfunc unionSet(u, v int, parent []int) {\\n    var parentU int = find(u, parent)\\n    var parentV int = find(v, parent)\\n    if parentU <= parentV {\\n        parent[parentV] = parent[u]\\n    } else {\\n        parent[parentU] = parent[v]\\n    }  \\n}\\nfunc find(u int, parent []int) int {\\n    if parent[u] == u {\\n        return u\\n    }\\n    parent[u] = find(parent[u], parent)\\n    return parent[u]\\n}\\n\\nfunc friendRequests(n int, restrictions [][]int, requests [][]int) []bool {\\n    parent := make([]int, n)\\n    for i:= 0; i < len(parent); i++ {\\n        parent[i] = i\\n    }\\n    ans := []bool{}\\n    for _, request := range requests {\\n        var valid bool = true\\n        var x int = find(request[0], parent)\\n        var y int = find(request[1], parent)\\n        if x != y {\\n            for _, banned := range restrictions {\\n                var u int = find(banned[0], parent)\\n                var v int = find(banned[1], parent)\\n                if (u == x && v == y) || (u == y && v == x) {\\n                    valid = false\\n                    break\\n                } \\n            }\\n        }\\n        ans = append(ans, valid)\\n        if valid {\\n            unionSet(request[0],request[1], parent)\\n        }\\n    }\\n    return ans\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\nfunc unionSet(u, v int, parent []int) {\\n    var parentU int = find(u, parent)\\n    var parentV int = find(v, parent)\\n    if parentU <= parentV {\\n        parent[parentV] = parent[u]\\n    } else {\\n        parent[parentU] = parent[v]\\n    }  \\n}\\nfunc find(u int, parent []int) int {\\n    if parent[u] == u {\\n        return u\\n    }\\n    parent[u] = find(parent[u], parent)\\n    return parent[u]\\n}\\n\\nfunc friendRequests(n int, restrictions [][]int, requests [][]int) []bool {\\n    parent := make([]int, n)\\n    for i:= 0; i < len(parent); i++ {\\n        parent[i] = i\\n    }\\n    ans := []bool{}\\n    for _, request := range requests {\\n        var valid bool = true\\n        var x int = find(request[0], parent)\\n        var y int = find(request[1], parent)\\n        if x != y {\\n            for _, banned := range restrictions {\\n                var u int = find(banned[0], parent)\\n                var v int = find(banned[1], parent)\\n                if (u == x && v == y) || (u == y && v == x) {\\n                    valid = false\\n                    break\\n                } \\n            }\\n        }\\n        ans = append(ans, valid)\\n        if valid {\\n            unionSet(request[0],request[1], parent)\\n        }\\n    }\\n    return ans\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3055140,
                "title": "c-union-find",
                "content": "# Code\\n```\\nclass Solution {\\nprivate:\\n    void unionSet(int u, int v, vector<int> &parent) {\\n        int parentU = find(u, parent);\\n        int parentV = find(v, parent);\\n        if(parentU == parentV) return;\\n        if(parentU <= parentV)\\n            parent[parentV] = parent[u];\\n        else\\n            parent[parentU] = parent[v];\\n    }\\n    int find(int u, vector<int> &parent) {\\n        if(parent[u] == u) return u;\\n        return parent[u] = find(parent[u], parent);\\n    }\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        vector<int> parent(n);\\n        iota(parent.begin(), parent.end(), 0);\\n        vector<bool> ans;\\n        for(vector<int> request: requests) {\\n            bool valid = true;\\n            int x = find(request[0], parent);\\n            int y = find(request[1], parent);\\n            if(x != y) {\\n                for(vector<int> banned: restrictions) {\\n                    int u = find(banned[0], parent);\\n                    int v = find(banned[1], parent);\\n                    if((u == x && v == y) || (u == y && v == x)) {\\n                        valid = false;\\n                        break;\\n                    } \\n                }\\n            }\\n            ans.push_back(valid);\\n            if(valid)\\n                unionSet(request[0],request[1], parent);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    void unionSet(int u, int v, vector<int> &parent) {\\n        int parentU = find(u, parent);\\n        int parentV = find(v, parent);\\n        if(parentU == parentV) return;\\n        if(parentU <= parentV)\\n            parent[parentV] = parent[u];\\n        else\\n            parent[parentU] = parent[v];\\n    }\\n    int find(int u, vector<int> &parent) {\\n        if(parent[u] == u) return u;\\n        return parent[u] = find(parent[u], parent);\\n    }\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        vector<int> parent(n);\\n        iota(parent.begin(), parent.end(), 0);\\n        vector<bool> ans;\\n        for(vector<int> request: requests) {\\n            bool valid = true;\\n            int x = find(request[0], parent);\\n            int y = find(request[1], parent);\\n            if(x != y) {\\n                for(vector<int> banned: restrictions) {\\n                    int u = find(banned[0], parent);\\n                    int v = find(banned[1], parent);\\n                    if((u == x && v == y) || (u == y && v == x)) {\\n                        valid = false;\\n                        break;\\n                    } \\n                }\\n            }\\n            ans.push_back(valid);\\n            if(valid)\\n                unionSet(request[0],request[1], parent);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3038936,
                "title": "python-union-find-solution",
                "content": "```\\ndef friendRequests(self, n: int, rs: List[List[int]], qs: List[List[int]]) -> List[bool]:\\n\\tuf, ans = list(range(n)), []\\n\\n\\tdef find(i):\\n\\t\\tif uf[i]!=i:\\n\\t\\t\\tuf[i] = find(uf[i])\\n\\t\\treturn uf[i]\\n\\n\\tfor i, j in qs:\\n\\t\\ti, j, good = find(i), find(j), True\\n\\t\\tfor x, y in rs:\\n\\t\\t\\tx, y = find(x), find(y)\\n\\t\\t\\tif sorted([i, j])==sorted([x, y]):\\n\\t\\t\\t\\tgood = False\\n\\t\\t\\t\\tbreak\\n\\t\\tif good:\\n\\t\\t\\tuf[j]=i\\n\\t\\tans.append(good)\\n\\n\\treturn ans\\n```",
                "solutionTags": [],
                "code": "```\\ndef friendRequests(self, n: int, rs: List[List[int]], qs: List[List[int]]) -> List[bool]:\\n\\tuf, ans = list(range(n)), []\\n\\n\\tdef find(i):\\n\\t\\tif uf[i]!=i:\\n\\t\\t\\tuf[i] = find(uf[i])\\n\\t\\treturn uf[i]\\n\\n\\tfor i, j in qs:\\n\\t\\ti, j, good = find(i), find(j), True\\n\\t\\tfor x, y in rs:\\n\\t\\t\\tx, y = find(x), find(y)\\n\\t\\t\\tif sorted([i, j])==sorted([x, y]):\\n\\t\\t\\t\\tgood = False\\n\\t\\t\\t\\tbreak\\n\\t\\tif good:\\n\\t\\t\\tuf[j]=i\\n\\t\\tans.append(good)\\n\\n\\treturn ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3025801,
                "title": "java-o-requests-n-beats-100-of-solutions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe friend network is an undirected graph, thus in a connected component all people are friends with each others as every node is reachable from every other node. \\n\\nWhen a request is accepted a new edge is added to the graph. If the request is within a connected component, it is immediately accepted as the two people are already friends. \\n\\nNote that the new edge creates a loop in the connected component, thus if we always discard these redundant edges we obtain a tree. This is useful for complexity as the number of edges is then n - 1, which means that we can optimally scan a connected component.\\n\\nThe only interesting case is then a new edge across connected component. This is equivalent to taking the union of the two trees. Thus, a union find datastructure can optimally merge connected components (the union of two trees is a tree).\\n\\nTo take into account for restrictions, we can just DFS either of the two connected components and check that each forbidden node is not in the other tree.\\n \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo simplify, we don\\'t even need to store the edges of the trees resulting from the requests but just which friends belong to which group. We can also replace the DFS entirely by merging lists at the parent node and as a consequence there is no need for using find() directly but we can just compare parent nodes\\' lists.\\nThe algorithm boils down to union-find where we add a linear scan of the restrictions in the union function\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\ncomplexity of union is $$O(n)$$ for restriction checks plus the complexity of find.\\nComplexity of find is amortized $$O(1)$$.\\n\\nIn total: $$O(requests * n)$$\\n \\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe only operation performed is merging lists or reassigning pointers. Thus it does not grow from the initial $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    int[] parent;\\n    List<Integer>[] friends;\\n    Set<Integer>[] enemies;\\n\\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        parent = new int[n];\\n        friends = new List[n];\\n        enemies = new Set[n];\\n        // init network\\n        for (int i = 0; i < n; ++i) {\\n            parent[i] = i;\\n            friends[i] = new ArrayList<>();\\n            friends[i].add(i);\\n            enemies[i] = new HashSet<>();\\n        }\\n        for (int[] r : restrictions) {\\n            enemies[r[0]].add(r[1]);\\n            enemies[r[1]].add(r[0]);\\n        }\\n        // solve\\n        boolean[] ans = new boolean[requests.length];\\n        for (int i = 0; i < ans.length; ++i) {\\n            ans[i] = union(requests[i][0], requests[i][1]);\\n        }\\n        return ans;\\n    }\\n\\n    private boolean union(int a, int b) {\\n        int pa = find(a), pb = find(b);\\n        if (pa == pb) { //discard direct friendships as they are redundant\\n            return true;\\n        }\\n        int p1, p2;\\n        if (friends[pa].size() < friends[pb].size()) {\\n            p1 = pa;\\n            p2 = pb;\\n        } else {\\n            p2 = pa;\\n            p1 = pb;\\n        }\\n        for (int p1Friend : friends[p1]) {\\n            if (enemies[p2].contains(p1Friend)) {\\n                return false;\\n            }\\n        }\\n        friends[p2].addAll(friends[p1]);\\n        enemies[p2].addAll(enemies[p1]);\\n        parent[p1] = p2;   \\n        // release memory as we don\\'t need to store subtrees\\n        friends[p1] = null;\\n        enemies[p1] = null;\\n        return true;\\n    }\\n\\n    private int find(int x) {\\n        return parent[x] == x ? x : (parent[x] = find(parent[x]));\\n    }\\n\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int[] parent;\\n    List<Integer>[] friends;\\n    Set<Integer>[] enemies;\\n\\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        parent = new int[n];\\n        friends = new List[n];\\n        enemies = new Set[n];\\n        // init network\\n        for (int i = 0; i < n; ++i) {\\n            parent[i] = i;\\n            friends[i] = new ArrayList<>();\\n            friends[i].add(i);\\n            enemies[i] = new HashSet<>();\\n        }\\n        for (int[] r : restrictions) {\\n            enemies[r[0]].add(r[1]);\\n            enemies[r[1]].add(r[0]);\\n        }\\n        // solve\\n        boolean[] ans = new boolean[requests.length];\\n        for (int i = 0; i < ans.length; ++i) {\\n            ans[i] = union(requests[i][0], requests[i][1]);\\n        }\\n        return ans;\\n    }\\n\\n    private boolean union(int a, int b) {\\n        int pa = find(a), pb = find(b);\\n        if (pa == pb) { //discard direct friendships as they are redundant\\n            return true;\\n        }\\n        int p1, p2;\\n        if (friends[pa].size() < friends[pb].size()) {\\n            p1 = pa;\\n            p2 = pb;\\n        } else {\\n            p2 = pa;\\n            p1 = pb;\\n        }\\n        for (int p1Friend : friends[p1]) {\\n            if (enemies[p2].contains(p1Friend)) {\\n                return false;\\n            }\\n        }\\n        friends[p2].addAll(friends[p1]);\\n        enemies[p2].addAll(enemies[p1]);\\n        parent[p1] = p2;   \\n        // release memory as we don\\'t need to store subtrees\\n        friends[p1] = null;\\n        enemies[p1] = null;\\n        return true;\\n    }\\n\\n    private int find(int x) {\\n        return parent[x] == x ? x : (parent[x] = find(parent[x]));\\n    }\\n\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2999938,
                "title": "python-simple-union-find",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def friendRequests(self, n, restrictions, requests):\\n        dict1, result = collections.defaultdict(int), [None]*len(requests)\\n\\n        def find(x):\\n            if x not in dict1:\\n                return x\\n            else:\\n                if x != dict1[x]:\\n                    dict1[x] = find(dict1[x])\\n                return dict1[x]\\n\\n        def union(x,y):\\n            a, b = find(x), find(y)\\n\\n            if a != b:\\n                dict1[b] = a\\n\\n        for i in range(len(requests)):\\n            found_set = set([find(requests[i][0]),find(requests[i][1])])\\n            result[i] = not any(find(a) in found_set and find(b) in found_set for (a,b) in restrictions)\\n\\n            if result[i] == True:\\n                union(requests[i][0],requests[i][1])\\n\\n        return result\\n\\n            \\n\\n                \\n\\n\\n\\n\\n\\n        return result\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def friendRequests(self, n, restrictions, requests):\\n        dict1, result = collections.defaultdict(int), [None]*len(requests)\\n\\n        def find(x):\\n            if x not in dict1:\\n                return x\\n            else:\\n                if x != dict1[x]:\\n                    dict1[x] = find(dict1[x])\\n                return dict1[x]\\n\\n        def union(x,y):\\n            a, b = find(x), find(y)\\n\\n            if a != b:\\n                dict1[b] = a\\n\\n        for i in range(len(requests)):\\n            found_set = set([find(requests[i][0]),find(requests[i][1])])\\n            result[i] = not any(find(a) in found_set and find(b) in found_set for (a,b) in restrictions)\\n\\n            if result[i] == True:\\n                union(requests[i][0],requests[i][1])\\n\\n        return result\\n\\n            \\n\\n                \\n\\n\\n\\n\\n\\n        return result\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2942191,
                "title": "rust-solution",
                "content": "# Intuition\\nApparently we can use union set to solve this problem. \\n\\nThe union set indicates whether a group of people are friends. For each of the requests let\\'s try to join two people into a union. After that, we go through the restrictions and check if any conflict occurs. If so, this request can not be done, otherwise can be.\\n\\n# Algorithm\\n1. initate `p`vector, the ancestor of elements. `for i in n: p[i] = i`\\u3002\\n2. for each request, let\\'s say a and b. \\n    1. If a and b is already in same union set, set the answer `true` and continue.\\n    2. If not, firstly use `pc = p.clone()`to back up `p`.\\n    3. then call function `join(a, b)` to join them into one set.\\n    4. for each restriction, let\\'s say x and y.\\n        1. find `px` and `py` as the ancestors of `x` and `y`.\\n        2. if `px == py`, conflict occurs (because they can not make friends), then we set the corresponding answer to `false`, set `p = pc` and move to next request.\\n    5. If after checking all restrictions, no conflict occurs, and set the answer to `true`.\\n# Complexity\\n- Time complexity:\\n$O(mn)$, where $m$=`restrictions.len()`and $n$=`requests.len()`.\\nWe can get this from two for loops above.\\n\\n- Space complexity:\\n$O(n)$, where  $n$=`requests.len()`.\\nWe only use extra memory to build a vector `p`.\\n# Code\\n```\\nimpl Solution {\\n    fn find(x: usize, p:&mut Vec<usize>) -> usize {\\n        return if p[x] == x {\\n            x\\n        } else {\\n            p[x] = Self::find(p[x], p);\\n            p[x]\\n        }\\n    }\\n\\n    pub fn friend_requests(n: i32, restrictions: Vec<Vec<i32>>, requests: Vec<Vec<i32>>) -> Vec<bool> {\\n        let mut p = vec![0; (n + 1) as usize];\\n        for i  in 1..=n {\\n            p[i as usize] = i as usize;\\n        }\\n        let mut ans = vec![false; requests.len()];\\n        for i in 0..requests.len() {\\n            let (a, b) = (requests[i][0] as usize, requests[i][1] as usize);\\n            // \\u5982\\u679C\\u5DF2\\u7ECF\\u662F\\u670B\\u53CB\\n            let pa = Self::find(a, &mut p);\\n            let pb = Self::find(b, &mut p);\\n            if pa == pb {\\n                ans[i] = true;\\n            } else {\\n                // pc \\u4F5C\\u4E3A\\u5907\\u4EFD\\uFF0C\\u5982\\u679C\\u5931\\u8D25\\u5219\\u56DE\\u9000\\n                let pc = p.clone();\\n                // flag \\u8868\\u793A\\u662F\\u5426\\u53EF\\u884C\\n                let mut flag = true;\\n                p[pa] = pb;\\n                for j in 0..restrictions.len() {\\n                    let (x, y) = (restrictions[j][0] as usize, restrictions[j][1] as usize);\\n                    let px = Self::find(x, &mut p);\\n                    let py = Self::find(y, &mut p);\\n                    if px == py {\\n                        flag = false;\\n                        break;\\n                    }\\n                }\\n                if flag {\\n                    ans[i] = true;\\n                } else {\\n                    p = pc;\\n                }\\n            }\\n        }\\n        ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Union Find"
                ],
                "code": "```\\nimpl Solution {\\n    fn find(x: usize, p:&mut Vec<usize>) -> usize {\\n        return if p[x] == x {\\n            x\\n        } else {\\n            p[x] = Self::find(p[x], p);\\n            p[x]\\n        }\\n    }\\n\\n    pub fn friend_requests(n: i32, restrictions: Vec<Vec<i32>>, requests: Vec<Vec<i32>>) -> Vec<bool> {\\n        let mut p = vec![0; (n + 1) as usize];\\n        for i  in 1..=n {\\n            p[i as usize] = i as usize;\\n        }\\n        let mut ans = vec![false; requests.len()];\\n        for i in 0..requests.len() {\\n            let (a, b) = (requests[i][0] as usize, requests[i][1] as usize);\\n            // \\u5982\\u679C\\u5DF2\\u7ECF\\u662F\\u670B\\u53CB\\n            let pa = Self::find(a, &mut p);\\n            let pb = Self::find(b, &mut p);\\n            if pa == pb {\\n                ans[i] = true;\\n            } else {\\n                // pc \\u4F5C\\u4E3A\\u5907\\u4EFD\\uFF0C\\u5982\\u679C\\u5931\\u8D25\\u5219\\u56DE\\u9000\\n                let pc = p.clone();\\n                // flag \\u8868\\u793A\\u662F\\u5426\\u53EF\\u884C\\n                let mut flag = true;\\n                p[pa] = pb;\\n                for j in 0..restrictions.len() {\\n                    let (x, y) = (restrictions[j][0] as usize, restrictions[j][1] as usize);\\n                    let px = Self::find(x, &mut p);\\n                    let py = Self::find(y, &mut p);\\n                    if px == py {\\n                        flag = false;\\n                        break;\\n                    }\\n                }\\n                if flag {\\n                    ans[i] = true;\\n                } else {\\n                    p = pc;\\n                }\\n            }\\n        }\\n        ans\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2930977,
                "title": "golang-union-find",
                "content": "```\\nfunc friendRequests(n int, restrictions [][]int, requests [][]int) []bool {\\n\\tuff := new(UF)\\n\\tuff.r = make([]int, n)\\n\\tuff.p = make([]int, n)\\n\\tfor i := 0; i < n; i++ { uff.p[i] = i }\\n\\n\\tres := make([]bool, len(requests))\\n\\tfor ri := range requests {\\n\\t\\tuffc := new(UF)\\n\\t\\tuffc.r = make([]int, n)\\n\\t\\tuffc.p = make([]int, n)\\n\\t\\tcopy(uffc.p, uff.p)\\n\\t\\tcopy(uffc.r, uff.r)\\n\\n\\t\\tuff.Union(requests[ri][0], requests[ri][1])\\n\\t\\tf := true\\n\\t\\tfor rri := range restrictions {\\n\\t\\t\\tif uff.Find(restrictions[rri][0]) == uff.Find(restrictions[rri][1]) {\\n\\t\\t\\t\\tf = false\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif !f { uff = uffc }\\n\\t\\tres[ri] = f\\n\\t}\\n\\treturn res\\n}\\n\\ntype UF struct {\\n\\tp, r []int\\n}\\n\\nfunc (uf *UF) Find(e int) int {\\n\\tif uf.p[e] == e { return e }\\n\\tuf.p[e] = uf.Find(uf.p[e])\\n\\treturn uf.p[e]\\n}\\n\\nfunc (uf *UF) Union(e1, e2 int) {\\n\\tr1 := uf.Find(e1)\\n\\tr2 := uf.Find(e2)\\n\\tif r1 == r2 { return }\\n\\n\\tswitch {\\n\\tcase uf.r[r1] < uf.r[r2]: uf.p[r1] = r2\\n\\tcase uf.r[r1] > uf.r[r2]: uf.p[r2] = r1\\n\\tdefault: uf.p[r2] = r1; uf.r[r1]++\\n\\t}\\n\\treturn\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc friendRequests(n int, restrictions [][]int, requests [][]int) []bool {\\n\\tuff := new(UF)\\n\\tuff.r = make([]int, n)\\n\\tuff.p = make([]int, n)\\n\\tfor i := 0; i < n; i++ { uff.p[i] = i }\\n\\n\\tres := make([]bool, len(requests))\\n\\tfor ri := range requests {\\n\\t\\tuffc := new(UF)\\n\\t\\tuffc.r = make([]int, n)\\n\\t\\tuffc.p = make([]int, n)\\n\\t\\tcopy(uffc.p, uff.p)\\n\\t\\tcopy(uffc.r, uff.r)\\n\\n\\t\\tuff.Union(requests[ri][0], requests[ri][1])\\n\\t\\tf := true\\n\\t\\tfor rri := range restrictions {\\n\\t\\t\\tif uff.Find(restrictions[rri][0]) == uff.Find(restrictions[rri][1]) {\\n\\t\\t\\t\\tf = false\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif !f { uff = uffc }\\n\\t\\tres[ri] = f\\n\\t}\\n\\treturn res\\n}\\n\\ntype UF struct {\\n\\tp, r []int\\n}\\n\\nfunc (uf *UF) Find(e int) int {\\n\\tif uf.p[e] == e { return e }\\n\\tuf.p[e] = uf.Find(uf.p[e])\\n\\treturn uf.p[e]\\n}\\n\\nfunc (uf *UF) Union(e1, e2 int) {\\n\\tr1 := uf.Find(e1)\\n\\tr2 := uf.Find(e2)\\n\\tif r1 == r2 { return }\\n\\n\\tswitch {\\n\\tcase uf.r[r1] < uf.r[r2]: uf.p[r1] = r2\\n\\tcase uf.r[r1] > uf.r[r2]: uf.p[r2] = r1\\n\\tdefault: uf.p[r2] = r1; uf.r[r1]++\\n\\t}\\n\\treturn\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2905694,
                "title": "java-extended-dsu-100-faster",
                "content": "Disclaimer: This code works, but the explanation is a work in progress because I don\\'t know the exact run-time complexity, and I\\'m sure the explanation can be more clear. Just putting it out there in case someone finds it useful, and also, I would love it if someone could help me with completing this explanation!\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis solution takes the basic theory behind a general DSU solution and makes it much much faster. I won\\'t explain the general DSU solution, which can be found here: https://leetcode.com/problems/process-restricted-friend-requests/solutions/1578306/java-clean-and-commented-code-with-explanation-union-find-algorithm/. \\n\\nThe main optimization over the original solution is to avoid iterating over all of the restrictions. Instead, you can check a map that contains restrictions, where \\'noMap[i]\\' = (all the people \\'i\\' cannot be friends with). \\n\\nFor simplicity, let\\'s call:\\n1. Node: a person\\n2. Node set: a set of nodes where every node inside the set is a direct or indirect friend of every other node in the set\\n3. Parent: the parent of all the nodes in a node set, or the root of the tree represented by the DSU array.\\n\\nTo understand noMap, let\\'s create a hypothetical map, called noMap\\' with the following properties:\\n1. For node set S with parent A, noMap\\'[A] contains all the parents of all the nodes that cannot join set S without violating a restriction. \\n2. Then for any C and D who want to be friends, if noMap\\'[parentC] contains parentD, we know they cannot be friends. If noMap\\'[parentC] does not contain parentD, we know they can become friends. \\n\\nThis would be nice to have, but would be difficult to keep updated. For example, let\\'s say we have the following parent to child structure:\\nA: [A] // A\\'s parent is A\\nB: [B]\\nC: [C]\\nY: [Y, X] // Y and X\\'s parent is Y\\nH: [H]\\nThen if have a restriction that Y cannot map to A, B, or C noMap\\' would be:\\nA = [Y] // Any node with parent A cannot map to any node with parent Y.\\nB = [Y]\\nC = [Y]\\nY = [A, B, C]\\nH = []\\n\\nIf we have Y become friends with H, and take H as its parent, then our new children structure is \\nA: [A]\\nB: [B]\\nC: [C]\\nH: [H, Y, X]\\nand our new noMap\\':\\nA = [H]\\nB = [H]\\nC = [H]\\nH = [A, B, C]\\nTo do this update on noMap\\', we\\'ll have to:\\n1. Add all restrictions in noMap\\'[Y] to noMap\\'[H].\\n2. Remove Y from noMap\\' (in practice, we we can skip this step because we only ever call noMap\\' with parents of nodes, so moving forward, Y will never be called)\\n3. Update all \\'Y\\' instances in the map to \\'H\\'. In this case, we\\'ll have to update A, B, and C\\'s entries. This is the bottleneck, and is why we want to change noMap\\' to noMap.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSo how do we make noMap provide the same value as noMap\\' without the bottleneck of step 3? We simply modify step 1 to make the steps:\\n1. Add all restrictions in noMap[Y] to noMap[H] as their parents.\\n2. Remove Y from noMap (in practice, we we can skip this step because we only ever call noMap with parents of nodes, so moving forward, Y will never be called)\\nour new noMap: \\nA = [Y]\\nB = [Y]\\nC = [Y]\\nH = [A, B, C]\\nNotice that  noMap[A], noMap[B], and noMap[C] don\\'t have any useful results anymore because Y is no longer a parent (and we only ever compare with parents). However, H does contain the parents because in step 1, we added noMap[Y]\\'s restricted node\\'s parents. \\n\\nFrom before, noMap\\' has the following property: \\nFor any C and D who want to be friends, if noMap\\'[parentC] contains parentD, we know they cannot be friends. If noMap\\'[parentC] does not contain parentD, we know they can become friends. \\n\\nnoMap has the following property:\\nFor any C and D who want to be friends, if noMap[parentC] contians parentD OR noMap[parentD] contains parentC, we know they cannot be friends. If noMap[parentC] does not contain parentD AND noMap[parentD] does not contain parentA, we know C and D can become friends.\\n\\nIf C and D cannot be friends and noMap[parentC] has parentD, then we\\'re done. If noMap[parentC] does not have parentD, then at some point, parentD had found a new parent (let\\'s call it parentE). However, when we joined parentD with parentE, we updated parentE to contain all the restrictions that came with joining with parentD, and we added them in the form of their parents. So noMap[parentE] MUST contain parentC. \\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        Set<Integer>[] noMap = new Set[n];\\n        int[] parents = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            noMap[i] = new HashSet<>();\\n            parents[i] = i;\\n        }\\n        for (int[] r : restrictions) {\\n            noMap[r[0]].add(r[1]);\\n            noMap[r[1]].add(r[0]);\\n        }\\n        boolean[] sol = new boolean[requests.length];\\n        for (int i = 0; i < sol.length; i++) {\\n            int[] request = requests[i];\\n            int parentA = parent(parents, request[0]), parentB = parent(parents, request[1]);\\n            if (parentA == parentB) sol[i] = true;\\n            else if (noMap[parentA].contains(parentB) || noMap[parentB].contains(parentA)) \\n                sol[i] = false;\\n            else {\\n                parents[parentB] = parentA;\\n                for (Integer child : noMap[parentB]) \\n                    noMap[parentA].add(parent(parents, child));\\n                sol[i] = true;\\n            } \\n        }\\n        return sol;\\n    }\\n\\n    private int parent(int[] parents, int a) {\\n        if (parents[a] == a) return a;\\n        else return parents[a] = parent(parents, parents[a]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        Set<Integer>[] noMap = new Set[n];\\n        int[] parents = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            noMap[i] = new HashSet<>();\\n            parents[i] = i;\\n        }\\n        for (int[] r : restrictions) {\\n            noMap[r[0]].add(r[1]);\\n            noMap[r[1]].add(r[0]);\\n        }\\n        boolean[] sol = new boolean[requests.length];\\n        for (int i = 0; i < sol.length; i++) {\\n            int[] request = requests[i];\\n            int parentA = parent(parents, request[0]), parentB = parent(parents, request[1]);\\n            if (parentA == parentB) sol[i] = true;\\n            else if (noMap[parentA].contains(parentB) || noMap[parentB].contains(parentA)) \\n                sol[i] = false;\\n            else {\\n                parents[parentB] = parentA;\\n                for (Integer child : noMap[parentB]) \\n                    noMap[parentA].add(parent(parents, child));\\n                sol[i] = true;\\n            } \\n        }\\n        return sol;\\n    }\\n\\n    private int parent(int[] parents, int a) {\\n        if (parents[a] == a) return a;\\n        else return parents[a] = parent(parents, parents[a]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2808174,
                "title": "python-union-find",
                "content": "```\\nclass UF:\\n    def __init__(self, n):\\n        self.parents = list(range(n))\\n        \\n    def find(self, u):\\n        if u != self.parents[u]:\\n            self.parents[u] = self.find(self.parents[u])\\n        return self.parents[u]\\n    \\n    def union(self, u, v):\\n        x, y = self.find(u), self.find(v)\\n        if x != y:\\n            self.parents[y] = x\\n            return x\\n        return -1\\n\\t\\t\\nclass Solution:\\n    def friendRequests(self, n: int, restrictions: List[List[int]], requests: List[List[int]]) -> List[bool]:\\n        uf, ban, group, ans = UF(n), defaultdict(set), {i: {i} for i in range(n)}, []\\n        for u, v in restrictions:\\n            ban[u].add(v)\\n            ban[v].add(u)\\n        for u, v in requests:\\n            p, q = uf.find(u), uf.find(v)\\n            if p == q:\\n                ans.append(True)\\n                continue\\n            if group[p] & ban[q] or group[q] & ban[p]:\\n                ans.append(False)\\n                continue\\n            p = uf.union(u, v)\\n            group[p] |= group[q]\\n            ban[p] |= ban[q]\\n            ans.append(True)\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Union Find"
                ],
                "code": "```\\nclass UF:\\n    def __init__(self, n):\\n        self.parents = list(range(n))\\n        \\n    def find(self, u):\\n        if u != self.parents[u]:\\n            self.parents[u] = self.find(self.parents[u])\\n        return self.parents[u]\\n    \\n    def union(self, u, v):\\n        x, y = self.find(u), self.find(v)\\n        if x != y:\\n            self.parents[y] = x\\n            return x\\n        return -1\\n\\t\\t\\nclass Solution:\\n    def friendRequests(self, n: int, restrictions: List[List[int]], requests: List[List[int]]) -> List[bool]:\\n        uf, ban, group, ans = UF(n), defaultdict(set), {i: {i} for i in range(n)}, []\\n        for u, v in restrictions:\\n            ban[u].add(v)\\n            ban[v].add(u)\\n        for u, v in requests:\\n            p, q = uf.find(u), uf.find(v)\\n            if p == q:\\n                ans.append(True)\\n                continue\\n            if group[p] & ban[q] or group[q] & ban[p]:\\n                ans.append(False)\\n                continue\\n            p = uf.union(u, v)\\n            group[p] |= group[q]\\n            ban[p] |= ban[q]\\n            ans.append(True)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2729180,
                "title": "c-union-find",
                "content": "\\tclass Solution {\\n\\t\\tprivate:\\n\\t\\tint findPar(vector<int>&parent,int node)\\n\\t\\t{\\n\\t\\t\\tif(node==parent[node])return node;\\n\\t\\t\\treturn parent[node] = findPar(parent,parent[node]);\\n\\t\\t}\\n\\t\\tvoid unite(vector<int>&rank,vector<int>&parent,int u,int v)\\n\\t\\t{\\n\\t\\t\\tu = findPar(parent,u);\\n\\t\\t\\tv = findPar(parent,v);\\n\\t\\t\\tif(rank[u]<rank[v])parent[u] = v;\\n\\t\\t\\telse if(rank[u]>rank[v])parent[v] = u;\\n\\t\\t\\telse \\n\\t\\t\\t{\\n\\t\\t\\t\\tparent[v] = u;\\n\\t\\t\\t\\trank[u]++;\\n\\t\\t\\t}\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\tpublic:\\n\\t\\tvector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n\\t\\t\\tvector<bool>ans;\\n\\t\\t\\tvector<int>parent(n,0),rank(n,0);\\n\\t\\t\\tfor(int i=0;i<n;i++)parent[i] = i;\\n\\t\\t\\tset<pair<int,int>>s;\\n\\t\\t\\tfor(auto i:restrictions)\\n\\t\\t\\t{\\n\\t\\t\\t\\ts.insert({i[0],i[1]});\\n\\t\\t\\t\\ts.insert({i[1],i[0]});\\n\\t\\t\\t}\\n\\t\\t\\tfor(auto i:requests)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint u = i[0];\\n\\t\\t\\t\\tint v = i[1];\\n\\t\\t\\t\\tint x = findPar(parent,u);\\n\\t\\t\\t\\tint y = findPar(parent,v);\\n\\t\\t\\t\\tbool f = true;\\n\\t\\t\\t\\tfor(auto i:s)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint a = findPar(parent,i.first);\\n\\t\\t\\t\\t\\tint b = findPar(parent,i.second);\\n\\t\\t\\t\\t\\tif(a==x && b==y)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tf = false;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(f)unite(rank,parent,u,v);\\n\\t\\t\\t\\tans.push_back(f);\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C",
                    "Union Find"
                ],
                "code": "class Solution {\\n\\t\\tprivate:\\n\\t\\tint findPar(vector<int>&parent,int node)\\n\\t\\t{\\n\\t\\t\\tif(node==parent[node])return node;\\n\\t\\t\\treturn parent[node] = findPar(parent,parent[node]);\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2728066,
                "title": "easy-short-efficient-clean-code",
                "content": "```\\nclass Solution {\\ntypedef long long ll;\\n#define vi(x) vector<x>\\npublic:\\n    class dsu{\\n    public:\\n        vi(ll)par, size;\\n        dsu(ll n){\\n            par.assign(n, 0), size.assign(n, 1);\\n            iota(begin(par), end(par), 0);\\n        }\\n        ll find(ll n){\\n            if(par[n]==n){\\n                return n;\\n            }\\n            return (par[n]=find(par[n]));\\n        }\\n        void merge(ll a, ll b){\\n            a=find(a), b=find(b);\\n            if(a==b){\\n                return;\\n            }\\n            if(size[a]<size[b]){\\n                a+=b, b=a-b, a-=b;\\n            }\\n            par[b]=a;\\n            size[a]+=size[b];\\n        }\\n    };\\n    vector<bool> friendRequests(int n, vector<vector<int>>&r, vector<vector<int>>&q){\\n        dsu f(n);\\n        vi(bool)ans(q.size(), 1);\\n        for(ll i=0;i<q.size();++i){\\n            if(f.find(q[i][0])==f.find(q[i][1])){\\n                continue;\\n            }\\n            for(const auto&e:r){\\n                if((f.find(e[0])==f.find(q[i][0]) && f.find(e[1])==f.find(q[i][1])) || (f.find(e[1])==f.find(q[i][0]) && f.find(e[0])==f.find(q[i][1]))){\\n                    ans[i]=0;\\n                    break;\\n                }\\n            }\\n            if(ans[i]){\\n                f.merge(q[i][0], q[i][1]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\ntypedef long long ll;\\n#define vi(x) vector<x>\\npublic:\\n    class dsu{\\n    public:\\n        vi(ll)par, size;\\n        dsu(ll n){\\n            par.assign(n, 0), size.assign(n, 1);\\n            iota(begin(par), end(par), 0);\\n        }\\n        ll find(ll n){\\n            if(par[n]==n){\\n                return n;\\n            }\\n            return (par[n]=find(par[n]));\\n        }\\n        void merge(ll a, ll b){\\n            a=find(a), b=find(b);\\n            if(a==b){\\n                return;\\n            }\\n            if(size[a]<size[b]){\\n                a+=b, b=a-b, a-=b;\\n            }\\n            par[b]=a;\\n            size[a]+=size[b];\\n        }\\n    };\\n    vector<bool> friendRequests(int n, vector<vector<int>>&r, vector<vector<int>>&q){\\n        dsu f(n);\\n        vi(bool)ans(q.size(), 1);\\n        for(ll i=0;i<q.size();++i){\\n            if(f.find(q[i][0])==f.find(q[i][1])){\\n                continue;\\n            }\\n            for(const auto&e:r){\\n                if((f.find(e[0])==f.find(q[i][0]) && f.find(e[1])==f.find(q[i][1])) || (f.find(e[1])==f.find(q[i][0]) && f.find(e[0])==f.find(q[i][1]))){\\n                    ans[i]=0;\\n                    break;\\n                }\\n            }\\n            if(ans[i]){\\n                f.merge(q[i][0], q[i][1]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2640565,
                "title": "c-simple-fast-comprehensible",
                "content": "Link to the submissions stats:\\nhttps://leetcode.com/submissions/detail/811706085/\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> rep;\\n    vector<int> sz;\\n    \\n    int root(int x){\\n        if(x==rep[x]){return x;}\\n        return rep[x]=root(rep[x]);\\n    }\\n    \\n    vector<bool> friendRequests(int n, vector<vector<int>>& ar, vector<vector<int>>& req) {\\n        set<int> s[n];\\n        set<int> ss[n];\\n        for(auto it:ar){\\n            s[it[0]].insert(it[1]);\\n            s[it[1]].insert(it[0]);\\n        }\\n        for(int i=0;i<n;i++){\\n            s[i].insert(i);\\n            ss[i].insert(i);\\n        }\\n        rep.resize(n);\\n        sz.resize(n);\\n        for(int i=0;i<n;i++){\\n            rep[i]=i;\\n            sz[i]=1;\\n        }\\n        vector<bool> ans;\\n        for(auto it:req){\\n            int a=it[0],b=it[1];\\n            a=root(a);\\n            b=root(b);\\n            if(a==b){\\n                ans.push_back(true);\\n            }\\n            else{\\n                bool ok=1;\\n                for(auto itt:s[b]){\\n                    if(s[a].count(itt) && (ss[a].count(itt) || ss[b].count(itt))){\\n                        ok=0;break;\\n                    }\\n                }\\n                if(sz[a]<sz[b]){\\n                    swap(a,b);\\n                }\\n                if(ok){\\n                    ans.push_back(true);\\n                    rep[b]=a;\\n                    sz[a]+=sz[b];\\n                    for(auto itt:s[b]){\\n                        s[a].insert(itt);\\n                    }\\n                    for(auto itt:ss[b]){\\n                        ss[a].insert(itt);\\n                    }\\n                }\\n                else{\\n                    ans.push_back(false);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rep;\\n    vector<int> sz;\\n    \\n    int root(int x){\\n        if(x==rep[x]){return x;}\\n        return rep[x]=root(rep[x]);\\n    }\\n    \\n    vector<bool> friendRequests(int n, vector<vector<int>>& ar, vector<vector<int>>& req) {\\n        set<int> s[n];\\n        set<int> ss[n];\\n        for(auto it:ar){\\n            s[it[0]].insert(it[1]);\\n            s[it[1]].insert(it[0]);\\n        }\\n        for(int i=0;i<n;i++){\\n            s[i].insert(i);\\n            ss[i].insert(i);\\n        }\\n        rep.resize(n);\\n        sz.resize(n);\\n        for(int i=0;i<n;i++){\\n            rep[i]=i;\\n            sz[i]=1;\\n        }\\n        vector<bool> ans;\\n        for(auto it:req){\\n            int a=it[0],b=it[1];\\n            a=root(a);\\n            b=root(b);\\n            if(a==b){\\n                ans.push_back(true);\\n            }\\n            else{\\n                bool ok=1;\\n                for(auto itt:s[b]){\\n                    if(s[a].count(itt) && (ss[a].count(itt) || ss[b].count(itt))){\\n                        ok=0;break;\\n                    }\\n                }\\n                if(sz[a]<sz[b]){\\n                    swap(a,b);\\n                }\\n                if(ok){\\n                    ans.push_back(true);\\n                    rep[b]=a;\\n                    sz[a]+=sz[b];\\n                    for(auto itt:s[b]){\\n                        s[a].insert(itt);\\n                    }\\n                    for(auto itt:ss[b]){\\n                        ss[a].insert(itt);\\n                    }\\n                }\\n                else{\\n                    ans.push_back(false);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2634438,
                "title": "c-disjoint-union-set-accepted",
                "content": "**IF Helpful Please Like Or Upvoke**\\n```\\nclass DSU{\\n    vector<int> par,rank;\\n    int n;\\n    public:\\n    DSU(int n)\\n    {\\n        this->par.resize(n);\\n        this->rank.resize(n);\\n        this->n=n;\\n        for(int i=0;i<n;i++)\\n            par[i]=i;\\n    }\\n    int find(int x)\\n    {\\n        if(x==par[x])return x;\\n        return par[x]=find(par[x]);\\n    }\\n    void Union(int a, int b)\\n    {\\n        int a_par=find(a);\\n        int b_par=find(b);\\n        if(a_par==b_par)\\n            return;\\n        if(rank[a_par]<rank[b_par])\\n        {\\n            par[a_par]=b_par;\\n        }\\n        else if(rank[b_par]<rank[a_par]){\\n            par[b_par]=a_par;\\n        }\\n        else\\n        {\\n            par[a_par]=b_par;\\n            rank[b_par]+=1;\\n        }\\n    }                       \\n};\\nclass Solution {\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n          DSU dsu(n+1);     \\n        vector<bool> ans;\\n        \\n        for(auto &it: requests){\\n            int x = it[0];\\n            int y = it[1];\\n            \\n            DSU temp = dsu;     // nice updating\\n            \\n            temp.Union(x, y);\\n            \\n            bool flag = true;\\n            for(auto &itr: restrictions){\\n                int x1 = itr[0];\\n                int y1 = itr[1];\\n                \\n                if(temp.find(x1)==temp.find(y1)){\\n                    flag=false; \\n                    break;\\n                }\\n            }\\n            \\n              if(flag){ \\n                dsu.Union(x, y);  // successful accepted\\n                ans.push_back(true);\\n            }\\n            else\\n                ans.push_back(false);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass DSU{\\n    vector<int> par,rank;\\n    int n;\\n    public:\\n    DSU(int n)\\n    {\\n        this->par.resize(n);\\n        this->rank.resize(n);\\n        this->n=n;\\n        for(int i=0;i<n;i++)\\n            par[i]=i;\\n    }\\n    int find(int x)\\n    {\\n        if(x==par[x])return x;\\n        return par[x]=find(par[x]);\\n    }\\n    void Union(int a, int b)\\n    {\\n        int a_par=find(a);\\n        int b_par=find(b);\\n        if(a_par==b_par)\\n            return;\\n        if(rank[a_par]<rank[b_par])\\n        {\\n            par[a_par]=b_par;\\n        }\\n        else if(rank[b_par]<rank[a_par]){\\n            par[b_par]=a_par;\\n        }\\n        else\\n        {\\n            par[a_par]=b_par;\\n            rank[b_par]+=1;\\n        }\\n    }                       \\n};\\nclass Solution {\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n          DSU dsu(n+1);     \\n        vector<bool> ans;\\n        \\n        for(auto &it: requests){\\n            int x = it[0];\\n            int y = it[1];\\n            \\n            DSU temp = dsu;     // nice updating\\n            \\n            temp.Union(x, y);\\n            \\n            bool flag = true;\\n            for(auto &itr: restrictions){\\n                int x1 = itr[0];\\n                int y1 = itr[1];\\n                \\n                if(temp.find(x1)==temp.find(y1)){\\n                    flag=false; \\n                    break;\\n                }\\n            }\\n            \\n              if(flag){ \\n                dsu.Union(x, y);  // successful accepted\\n                ans.push_back(true);\\n            }\\n            else\\n                ans.push_back(false);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2598995,
                "title": "c-union-find",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int>par;\\n    vector<int>rk;\\n    int findpar(int node){\\n        if(node == par[node])\\n            return node;\\n        return par[node] = findpar(par[node]);\\n    }\\n    void unionfun(int u,int v){\\n        u = findpar(u);\\n        v = findpar(v);\\n        if(rk[u] < rk[v])\\n            par[u]=v;\\n        else if(rk[v] < rk[u])\\n            par[v]=u;\\n        else{\\n            rk[u]++;\\n            par[v]=u;\\n        }\\n    }\\n    vector<bool> friendRequests(int n, vector<vector<int>>& a, vector<vector<int>>&b) {\\n        int m = b.size();\\n        rk.resize(n,0);\\n        par.resize(n);\\n        for(int i=0;i<n;i++){\\n            par[i]=i;\\n        }\\n        vector<bool>ans(m,0);\\n        for(int i=0;i<m;i++){\\n            int u = b[i][0];\\n            int v = b[i][1];\\n            vector<int>trk=rk;\\n            vector<int>tpar=par;\\n            unionfun(u,v);\\n            int ok=0;\\n            for(int j=0;j<a.size();j++){\\n                int f = a[j][0];\\n                int s = a[j][1];\\n                int par1=findpar(f);\\n                int par2=findpar(s);\\n                if(par1 == par2){\\n                    ok=1;\\n                    break;\\n                }\\n            }\\n            if(ok == 1){\\n                ans[i]=0;\\n                par = tpar;\\n                rk = trk;\\n            }\\n            else{\\n                ans[i]=1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>par;\\n    vector<int>rk;\\n    int findpar(int node){\\n        if(node == par[node])\\n            return node;\\n        return par[node] = findpar(par[node]);\\n    }\\n    void unionfun(int u,int v){\\n        u = findpar(u);\\n        v = findpar(v);\\n        if(rk[u] < rk[v])\\n            par[u]=v;\\n        else if(rk[v] < rk[u])\\n            par[v]=u;\\n        else{\\n            rk[u]++;\\n            par[v]=u;\\n        }\\n    }\\n    vector<bool> friendRequests(int n, vector<vector<int>>& a, vector<vector<int>>&b) {\\n        int m = b.size();\\n        rk.resize(n,0);\\n        par.resize(n);\\n        for(int i=0;i<n;i++){\\n            par[i]=i;\\n        }\\n        vector<bool>ans(m,0);\\n        for(int i=0;i<m;i++){\\n            int u = b[i][0];\\n            int v = b[i][1];\\n            vector<int>trk=rk;\\n            vector<int>tpar=par;\\n            unionfun(u,v);\\n            int ok=0;\\n            for(int j=0;j<a.size();j++){\\n                int f = a[j][0];\\n                int s = a[j][1];\\n                int par1=findpar(f);\\n                int par2=findpar(s);\\n                if(par1 == par2){\\n                    ok=1;\\n                    break;\\n                }\\n            }\\n            if(ok == 1){\\n                ans[i]=0;\\n                par = tpar;\\n                rk = trk;\\n            }\\n            else{\\n                ans[i]=1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2545532,
                "title": "java-solution-with-explanation",
                "content": "Runtime: O(n*m*l )  n=number of requests, \\n                    m=number of restrictions to search through,\\n                    l=lookup time for Find of a given friend --> Initially, this lookup is constant, but depending on size of friend group can grow to size of log(n) \\nStorage: O(n*p)     n=number of requests,\\n                    p=number of people in network\\nGeneral Explanation: \\n\\nFor this problem, we need to use Union Find. This algorithm works by identifying all nodes within a tree point to a head and then comparing if two nodes have the same head\\nyou can find out if they are part of the same tree. You can then Union the trees by making one root point to the other.\\nMore information on this process can be found here: https://www.youtube.com/watch?v=ayW5B2W9hfo\\n\\nThis algorithm begins by creating an array arr to represent all of the people in the network. These values begin as the their own index indicating that \\neach individual is their own friend. As the algorithm progresses, we perform union Find and point one individual from a friend pair to point to the other\\'s\\nindex. When arr[i]=i you know that you found the head for that friend group.\\n\\nThe alforithm progresses by initializing an empty boolean array for us to fill if we have a successful or failed request. We then iterate through each request \\nto determine if the request is successful.\\n\\nWe take the two individuals we are trying to make a friend request with and find the heads of their respective friend groups using the find method as described\\nabove. We then run throughall of the restrictions and check whether or not the heads of our two groups are restricted from becoming friends. If the heads of the \\ntwo groups we have a request to join are equal to the heads of the two groups restricted from joining, then we add false to our array to return and break from \\nthe current iteration.\\n\\nIf the heads of the groups we have a request to join don\\'t have a restriction preventing them from being merged, then we add true to our array to return and \\nthen merge the two groups using the method described above by moving one index to point to the heads of the other.\\n\\nWe continue with this process through all requests and return the final boolean array produced :)\\n\\n\\nCode: \\n\\n```\\nclass Solution {\\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        int[] arr=new int[n];\\n        for(int i=0;i<n;i++){\\n            arr[i]=i;\\n        }\\n        int j=0;\\n        boolean[] ret=new boolean[requests.length];\\n        for(int[] a:requests){\\n            int x=find(a[0],arr);\\n            int y=find(a[1],arr);\\n            boolean flag=true;\\n            for(int i=0;i<restrictions.length;i++){\\n                int l=find(restrictions[i][0],arr);\\n                int r=find(restrictions[i][1],arr);\\n                if(((l==x && r==y) || (l==y && r==x))){\\n                    flag=false;\\n                    break;\\n                }\\n            }\\n            ret[j++]=flag;\\n            if(flag){\\n                union(x,y,arr);\\n            }\\n        }\\n        return ret;\\n    }\\n    private void union(int a,int b,int[] arr){\\n        int x=find(a,arr);\\n        int y=find(b,arr);\\n        if(x==y) return;\\n        arr[y]=x;\\n    }\\n    private int find(int x,int[] arr){\\n        if(arr[x]==x) return x;\\n        return find(arr[x],arr);\\n    }\\n}\\n\\n\\n\\n//Additional Resoureces\\n//https://leetcode.com/problems/process-restricted-friend-requests/discuss/2489402/Java-Solution-or-Union-Find-or-Disjoint-Sets-or-Without-rank\\n//https://www.youtube.com/watch?v=EVnIVVF-Jfs\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        int[] arr=new int[n];\\n        for(int i=0;i<n;i++){\\n            arr[i]=i;\\n        }\\n        int j=0;\\n        boolean[] ret=new boolean[requests.length];\\n        for(int[] a:requests){\\n            int x=find(a[0],arr);\\n            int y=find(a[1],arr);\\n            boolean flag=true;\\n            for(int i=0;i<restrictions.length;i++){\\n                int l=find(restrictions[i][0],arr);\\n                int r=find(restrictions[i][1],arr);\\n                if(((l==x && r==y) || (l==y && r==x))){\\n                    flag=false;\\n                    break;\\n                }\\n            }\\n            ret[j++]=flag;\\n            if(flag){\\n                union(x,y,arr);\\n            }\\n        }\\n        return ret;\\n    }\\n    private void union(int a,int b,int[] arr){\\n        int x=find(a,arr);\\n        int y=find(b,arr);\\n        if(x==y) return;\\n        arr[y]=x;\\n    }\\n    private int find(int x,int[] arr){\\n        if(arr[x]==x) return x;\\n        return find(arr[x],arr);\\n    }\\n}\\n\\n\\n\\n//Additional Resoureces\\n//https://leetcode.com/problems/process-restricted-friend-requests/discuss/2489402/Java-Solution-or-Union-Find-or-Disjoint-Sets-or-Without-rank\\n//https://www.youtube.com/watch?v=EVnIVVF-Jfs\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2533585,
                "title": "python-solution-no-union-find-beats-70",
                "content": "```\\nclass Solution:\\n    def friendRequests(self, n: int, restrictions: List[List[int]], requests: List[List[int]]) -> List[bool]:\\n        personToGroup, groupToPeople = [0 for _ in range(n)], [set() for _ in range(n)]\\n        for i in range(n):\\n            personToGroup[i] = i\\n            groupToPeople[i].add(i)\\n        personToRestricted = [[] for _ in range(n)]\\n        for restriction in restrictions:\\n            personToRestricted[restriction[0]].append(restriction[1])\\n            personToRestricted[restriction[1]].append(restriction[0])\\n        res, w = [False for _ in range(len(requests))], 0\\n        for request in requests:\\n            grp1, grp2 = personToGroup[request[0]], personToGroup[request[1]]\\n            if grp1 == grp2:\\n                res[w] = True\\n                w += 1\\n                continue\\n            if len(groupToPeople[grp1]) > len(groupToPeople[grp2]):\\n                grp1, grp2 = grp2, grp1\\n            forbidden, group2 = False, groupToPeople[grp2]\\n            for p1 in groupToPeople[grp1]:\\n                for restricted in personToRestricted[p1]:\\n                    if restricted in group2:\\n                        forbidden = True\\n                        break\\n                if forbidden:\\n                    break\\n            res[w] = not forbidden\\n            w += 1\\n            if not forbidden:\\n                for p1 in groupToPeople[grp1]:\\n                    personToGroup[p1] = grp2\\n                    group2.add(p1)\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def friendRequests(self, n: int, restrictions: List[List[int]], requests: List[List[int]]) -> List[bool]:\\n        personToGroup, groupToPeople = [0 for _ in range(n)], [set() for _ in range(n)]\\n        for i in range(n):\\n            personToGroup[i] = i\\n            groupToPeople[i].add(i)\\n        personToRestricted = [[] for _ in range(n)]\\n        for restriction in restrictions:\\n            personToRestricted[restriction[0]].append(restriction[1])\\n            personToRestricted[restriction[1]].append(restriction[0])\\n        res, w = [False for _ in range(len(requests))], 0\\n        for request in requests:\\n            grp1, grp2 = personToGroup[request[0]], personToGroup[request[1]]\\n            if grp1 == grp2:\\n                res[w] = True\\n                w += 1\\n                continue\\n            if len(groupToPeople[grp1]) > len(groupToPeople[grp2]):\\n                grp1, grp2 = grp2, grp1\\n            forbidden, group2 = False, groupToPeople[grp2]\\n            for p1 in groupToPeople[grp1]:\\n                for restricted in personToRestricted[p1]:\\n                    if restricted in group2:\\n                        forbidden = True\\n                        break\\n                if forbidden:\\n                    break\\n            res[w] = not forbidden\\n            w += 1\\n            if not forbidden:\\n                for p1 in groupToPeople[grp1]:\\n                    personToGroup[p1] = grp2\\n                    group2.add(p1)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2513417,
                "title": "proper-union-find",
                "content": "```\\nclass Solution {\\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        boolean[] ans = new boolean[requests.length];\\n        DSU dsu = new DSU(n);\\n        \\n        for(int i=0; i<requests.length; i++) {\\n            int u = requests[i][0], v = requests[i][1];\\n            int up = dsu.find(u), vp = dsu.find(v);\\n            ans[i] = true;\\n            \\n            for(int[] restriction : restrictions) {\\n                int x = restriction[0], y = restriction[1];\\n                int xp = dsu.find(x), yp = dsu.find(y);\\n                \\n                if( (xp == up && yp == vp) || (yp == up && xp == vp) ) {\\n                    ans[i] = false;\\n                    break;\\n                } \\n            }\\n            if( ans[i] )\\n                dsu.union(up, vp);\\n        }\\n        return ans;\\n    }\\n}\\nclass DSU {\\n    private int[] parent, rank;\\n    \\n    public DSU(int n) {\\n        parent = new int[n];\\n        rank = new int[n];\\n        \\n        for(int i=0; i<n; i++)\\n            parent[i] = i;\\n    }\\n    \\n    public int find(int x) {\\n        if( parent[x] != x )\\n            parent[x] = find(parent[x]);\\n        return parent[x];\\n    }\\n    \\n    public boolean union(int x, int y) {\\n        int px = find(x), py = find(y);\\n        \\n        if( px == py ) return false;\\n        \\n        if( rank[py] > rank[px] ) \\n            parent[px] = py;\\n        else if( rank[px] > rank[py] )\\n            parent[py] = px;\\n        else {\\n            parent[py] = px;\\n            rank[px] += 1;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        boolean[] ans = new boolean[requests.length];\\n        DSU dsu = new DSU(n);\\n        \\n        for(int i=0; i<requests.length; i++) {\\n            int u = requests[i][0], v = requests[i][1];\\n            int up = dsu.find(u), vp = dsu.find(v);\\n            ans[i] = true;\\n            \\n            for(int[] restriction : restrictions) {\\n                int x = restriction[0], y = restriction[1];\\n                int xp = dsu.find(x), yp = dsu.find(y);\\n                \\n                if( (xp == up && yp == vp) || (yp == up && xp == vp) ) {\\n                    ans[i] = false;\\n                    break;\\n                } \\n            }\\n            if( ans[i] )\\n                dsu.union(up, vp);\\n        }\\n        return ans;\\n    }\\n}\\nclass DSU {\\n    private int[] parent, rank;\\n    \\n    public DSU(int n) {\\n        parent = new int[n];\\n        rank = new int[n];\\n        \\n        for(int i=0; i<n; i++)\\n            parent[i] = i;\\n    }\\n    \\n    public int find(int x) {\\n        if( parent[x] != x )\\n            parent[x] = find(parent[x]);\\n        return parent[x];\\n    }\\n    \\n    public boolean union(int x, int y) {\\n        int px = find(x), py = find(y);\\n        \\n        if( px == py ) return false;\\n        \\n        if( rank[py] > rank[px] ) \\n            parent[px] = py;\\n        else if( rank[px] > rank[py] )\\n            parent[py] = px;\\n        else {\\n            parent[py] = px;\\n            rank[px] += 1;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2509686,
                "title": "c-elementary-solution-beats-99-8-no-union-find",
                "content": "Given n = number of people = number of restrictions = number of requests, this solution is O(n\\xB2), better than the typical O(n\\xB2log(n)) union-find solution that uses path compression without union by size/rank.\\n\\nhttps://leetcode.com/submissions/detail/788040081/\\nRuntime: 70 ms, faster than 99.79% of C++ online submissions for Process Restricted Friend Requests.\\nMemory Usage: 28.8 MB, less than 29.07% of C++ online submissions for Process Restricted Friend Requests.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        vector<int> p2g(n);\\n        for (int i = 0; i < n; ++i) p2g[i] = i;\\n        \\n        vector<unordered_set<int>> g2p(n);\\n        for (int i = 0; i < n; ++i) g2p[i].insert(i);\\n        \\n        vector<vector<int>> p2r(n);\\n        for (auto &v: restrictions) {\\n            p2r[v[0]].push_back(v[1]);\\n            p2r[v[1]].push_back(v[0]);\\n        }\\n        \\n        vector<bool> result(requests.size());\\n        int w = 0;\\n        for (auto &v: requests) {\\n            int g1 = p2g[v[0]];\\n            int g2 = p2g[v[1]];\\n            if (g1 == g2) {\\n                result[w++] = true;\\n                continue;\\n            }\\n            if (g2p[g1].size() > g2p[g2].size()) {\\n                swap(g1, g2);\\n            }\\n            \\n            bool forbidden = false;\\n            auto &group2 = g2p[g2];\\n            for (int p1: g2p[g1]) {\\n                for (int r: p2r[p1]) {\\n                    if (group2.count(r)) {\\n                        forbidden = true;\\n                        break;\\n                    }\\n                }\\n                if (forbidden) break;\\n            }\\n            result[w++] = !forbidden;\\n            \\n            if (!forbidden) {\\n                for (int p1: g2p[g1]) {\\n                    p2g[p1] = g2;\\n                    group2.insert(p1);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        vector<int> p2g(n);\\n        for (int i = 0; i < n; ++i) p2g[i] = i;\\n        \\n        vector<unordered_set<int>> g2p(n);\\n        for (int i = 0; i < n; ++i) g2p[i].insert(i);\\n        \\n        vector<vector<int>> p2r(n);\\n        for (auto &v: restrictions) {\\n            p2r[v[0]].push_back(v[1]);\\n            p2r[v[1]].push_back(v[0]);\\n        }\\n        \\n        vector<bool> result(requests.size());\\n        int w = 0;\\n        for (auto &v: requests) {\\n            int g1 = p2g[v[0]];\\n            int g2 = p2g[v[1]];\\n            if (g1 == g2) {\\n                result[w++] = true;\\n                continue;\\n            }\\n            if (g2p[g1].size() > g2p[g2].size()) {\\n                swap(g1, g2);\\n            }\\n            \\n            bool forbidden = false;\\n            auto &group2 = g2p[g2];\\n            for (int p1: g2p[g1]) {\\n                for (int r: p2r[p1]) {\\n                    if (group2.count(r)) {\\n                        forbidden = true;\\n                        break;\\n                    }\\n                }\\n                if (forbidden) break;\\n            }\\n            result[w++] = !forbidden;\\n            \\n            if (!forbidden) {\\n                for (int p1: g2p[g1]) {\\n                    p2g[p1] = g2;\\n                    group2.insert(p1);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2503463,
                "title": "c-solution-using-union-find",
                "content": "```\\nclass Solution {\\npublic:\\n    class UnionFind {\\n        vector<int> st;\\n        public:\\n        UnionFind(int n) {\\n            st = vector<int> (n);\\n            for (int i = 0; i < n; i++) {\\n                st[i] = i;\\n            }\\n        }\\n        int find(int v) {\\n            if (v == st[v]) return v;\\n            return st[v] = find(st[v]);\\n        }\\n        void merge(int u, int v) {\\n            int x = find(u);\\n            int y = find(v);\\n            if (x != y) {\\n                st[x] = y;\\n            }\\n        }\\n    };\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        int len = requests.size();\\n        UnionFind uf(n);\\n        vector<bool> sol(len);\\n        for (int i = 0; i < len; i++) {\\n            int u = requests[i][0];\\n            int v = requests[i][1];\\n            int x = uf.find(u);\\n            int y = uf.find(v);\\n            if (x == y) {\\n                sol[i] = true;\\n                continue;\\n            }\\n            bool fri = true;\\n            for (vector<int>& res : restrictions) {\\n                int rep1 = uf.find(res[0]);\\n                int rep2 = uf.find(res[1]);\\n                if (rep1 == x && rep2 == y || rep1 == y && rep2 == x) {\\n                    fri = false;\\n                    break;\\n                }\\n            }\\n            if (fri) {\\n                sol[i] = true;\\n                uf.merge(u, v);\\n            }\\n        }\\n        return sol;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    class UnionFind {\\n        vector<int> st;\\n        public:\\n        UnionFind(int n) {\\n            st = vector<int> (n);\\n            for (int i = 0; i < n; i++) {\\n                st[i] = i;\\n            }\\n        }\\n        int find(int v) {\\n            if (v == st[v]) return v;\\n            return st[v] = find(st[v]);\\n        }\\n        void merge(int u, int v) {\\n            int x = find(u);\\n            int y = find(v);\\n            if (x != y) {\\n                st[x] = y;\\n            }\\n        }\\n    };\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        int len = requests.size();\\n        UnionFind uf(n);\\n        vector<bool> sol(len);\\n        for (int i = 0; i < len; i++) {\\n            int u = requests[i][0];\\n            int v = requests[i][1];\\n            int x = uf.find(u);\\n            int y = uf.find(v);\\n            if (x == y) {\\n                sol[i] = true;\\n                continue;\\n            }\\n            bool fri = true;\\n            for (vector<int>& res : restrictions) {\\n                int rep1 = uf.find(res[0]);\\n                int rep2 = uf.find(res[1]);\\n                if (rep1 == x && rep2 == y || rep1 == y && rep2 == x) {\\n                    fri = false;\\n                    break;\\n                }\\n            }\\n            if (fri) {\\n                sol[i] = true;\\n                uf.merge(u, v);\\n            }\\n        }\\n        return sol;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2348990,
                "title": "java-beats-98-with-comments-and-complexity-analysis",
                "content": "```\\nclass Solution {\\n    \\n    int findParent(int parent[], int id) {\\n        if(parent[id]!=id){\\n            parent[id]=findParent(parent,parent[id]);\\n        }\\n        return parent[id];\\n    }\\n    \\n    void union(int parent[], int rank[], int x, int y) {\\n        if(rank[x]<rank[y]){\\n            parent[x]=y;\\n        } else if(rank[y]<rank[x]){\\n            parent[y]=x;\\n        } else {\\n            parent[y]=x;\\n            rank[x]++;\\n        }\\n    }\\n    \\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n\\n        int[] parent=new int[n];\\n        int[] rank=new int[n];\\n        boolean[] result=new boolean[requests.length];\\n        \\n        for(int i=0;i<n;i++){\\n            parent[i]=i;\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            rank[i]=0;\\n        }\\n        \\n        for(int i=0;i<requests.length;i++){\\n            int firstParent=findParent(parent,requests[i][0]);\\n            int secondParent=findParent(parent,requests[i][1]);\\n            if(firstParent==secondParent){\\n                result[i]=true;\\n                continue;\\n            }\\n            \\n            boolean flag=true;\\n            \\n            for(int j=0;j<restrictions.length;j++){\\n                int firstRest=findParent(parent,restrictions[j][0]);\\n                int secondRest=findParent(parent,restrictions[j][1]);\\n                if((firstRest==firstParent && secondRest==secondParent)||(firstParent==secondRest && secondParent==firstRest)) {\\n                    flag=false;\\n                    break;\\n                }\\n            }\\n            \\n            result[i]=flag;\\n            if(flag){\\n                union(parent,rank,firstParent,secondParent);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    int findParent(int parent[], int id) {\\n        if(parent[id]!=id){\\n            parent[id]=findParent(parent,parent[id]);\\n        }\\n        return parent[id];\\n    }\\n    \\n    void union(int parent[], int rank[], int x, int y) {\\n        if(rank[x]<rank[y]){\\n            parent[x]=y;\\n        } else if(rank[y]<rank[x]){\\n            parent[y]=x;\\n        } else {\\n            parent[y]=x;\\n            rank[x]++;\\n        }\\n    }\\n    \\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n\\n        int[] parent=new int[n];\\n        int[] rank=new int[n];\\n        boolean[] result=new boolean[requests.length];\\n        \\n        for(int i=0;i<n;i++){\\n            parent[i]=i;\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            rank[i]=0;\\n        }\\n        \\n        for(int i=0;i<requests.length;i++){\\n            int firstParent=findParent(parent,requests[i][0]);\\n            int secondParent=findParent(parent,requests[i][1]);\\n            if(firstParent==secondParent){\\n                result[i]=true;\\n                continue;\\n            }\\n            \\n            boolean flag=true;\\n            \\n            for(int j=0;j<restrictions.length;j++){\\n                int firstRest=findParent(parent,restrictions[j][0]);\\n                int secondRest=findParent(parent,restrictions[j][1]);\\n                if((firstRest==firstParent && secondRest==secondParent)||(firstParent==secondRest && secondParent==firstRest)) {\\n                    flag=false;\\n                    break;\\n                }\\n            }\\n            \\n            result[i]=flag;\\n            if(flag){\\n                union(parent,rank,firstParent,secondParent);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2313865,
                "title": "python-o-n-requests-restrictions-union-find",
                "content": "We keep a union-find data structure with history, which contains all the successful friend requests. Then, for each request, we try it by adding it to the union-find, and if there is a restriction conflict, we undo. The modification for history is to store the previous union information, as well as which nodes were processed last (dirty), in order to not compress their paths.\\n\\n\\n```python\\nclass UF:\\n    def __init__(self, n):\\n        self.parent = list(range(n))\\n        self.heights = [0] * n\\n        self.history = []\\n        self.dirty = [False] * n\\n    \\n    def find(self, x):\\n        y = x\\n        while self.parent[y] != y:\\n            y = self.parent[y]\\n            if not self.dirty[y]:\\n                self.parent[x] = y\\n        return y\\n    \\n    def union(self, x, y):\\n        x = self.find(x)\\n        y = self.find(y)\\n        self.history.append((x, y, self.heights[x], self.heights[y]))\\n        self.dirty[x] = True\\n        self.dirty[y] = True\\n        if x == y:\\n            pass\\n        elif self.heights[x] < self.heights[y]:\\n            self.parent[x] = y    \\n        elif self.heights[y] < self.heights[x]:\\n            self.parent[y] = x\\n        else:\\n            self.parent[y] = x\\n            self.heights[x] += 1\\n    \\n    def undo(self):\\n        x, y, h_x, h_y = self.history.pop()\\n        self.parent[x] = x\\n        self.parent[y] = y\\n        self.heights[x] = h_x\\n        self.heights[y] = h_y\\n        self.dirty[x] = False\\n        self.dirty[y] = False\\n        \\n    def clean(self):\\n        x, y, _, _ = self.history.pop()\\n        self.dirty[x] = False\\n        self.dirty[y] = False\\n\\n\\nclass Solution:\\n    def friendRequests(self, n: int, restrictions: List[List[int]], requests: List[List[int]]) -> List[bool]:\\n        uf = UF(n)\\n        ans = [True] * len(requests)\\n        for i, (x, y) in enumerate(requests):\\n            uf.union(x, y)\\n            if any(uf.find(u) == uf.find(v) for u, v in restrictions):\\n                uf.undo()\\n                ans[i] = False\\n            else:\\n                uf.clean()\\n        return ans\\n\\t\\t```",
                "solutionTags": [],
                "code": "```python\\nclass UF:\\n    def __init__(self, n):\\n        self.parent = list(range(n))\\n        self.heights = [0] * n\\n        self.history = []\\n        self.dirty = [False] * n\\n    \\n    def find(self, x):\\n        y = x\\n        while self.parent[y] != y:\\n            y = self.parent[y]\\n            if not self.dirty[y]:\\n                self.parent[x] = y\\n        return y\\n    \\n    def union(self, x, y):\\n        x = self.find(x)\\n        y = self.find(y)\\n        self.history.append((x, y, self.heights[x], self.heights[y]))\\n        self.dirty[x] = True\\n        self.dirty[y] = True\\n        if x == y:\\n            pass\\n        elif self.heights[x] < self.heights[y]:\\n            self.parent[x] = y    \\n        elif self.heights[y] < self.heights[x]:\\n            self.parent[y] = x\\n        else:\\n            self.parent[y] = x\\n            self.heights[x] += 1\\n    \\n    def undo(self):\\n        x, y, h_x, h_y = self.history.pop()\\n        self.parent[x] = x\\n        self.parent[y] = y\\n        self.heights[x] = h_x\\n        self.heights[y] = h_y\\n        self.dirty[x] = False\\n        self.dirty[y] = False\\n        \\n    def clean(self):\\n        x, y, _, _ = self.history.pop()\\n        self.dirty[x] = False\\n        self.dirty[y] = False\\n\\n\\nclass Solution:\\n    def friendRequests(self, n: int, restrictions: List[List[int]], requests: List[List[int]]) -> List[bool]:\\n        uf = UF(n)\\n        ans = [True] * len(requests)\\n        for i, (x, y) in enumerate(requests):\\n            uf.union(x, y)\\n            if any(uf.find(u) == uf.find(v) for u, v in restrictions):\\n                uf.undo()\\n                ans[i] = False\\n            else:\\n                uf.clean()\\n        return ans\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 2262107,
                "title": "python-unionfind-beats-100",
                "content": "```\\nclass UnionFind2076:\\n    def __init__(self, size, restrictions):\\n        self.parent = [i for i in range(size)]\\n        self.restrictions = [0] * size\\n        self.all = [(1<<i) for i in range(size)]\\n        for a, b in restrictions:\\n            self.restrictions[a] |= (1<<b)\\n            self.restrictions[b] |= (1<<a)\\n\\n    def find(self, n):\\n        m = n\\n        while self.parent[m] != m:\\n            m = self.parent[m]\\n        while self.parent[n] != m:\\n            old_parent = self.parent[n]\\n            self.parent[n] = m\\n            n = old_parent\\n        return m\\n\\n    def union(self, m, n):\\n        root_m, root_n = self.find(m), self.find(n)\\n        if root_m == root_n:\\n            return True\\n        if self.restrictions[root_m] & self.all[root_n]:\\n            return False\\n        self.parent[root_m] = root_n\\n        self.all[root_n] |= self.all[root_m]\\n        self.restrictions[root_n] |= self.restrictions[root_m]\\n        return True\\n\\nclass Solution:\\n    #2076\\n    def friendRequests(self, n: int, restrictions, requests):\\n        uf = UnionFind2076(n, restrictions)\\n        res = []\\n        for a,b in requests:\\n            res.append(uf.union(a,b))\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Union Find"
                ],
                "code": "```\\nclass UnionFind2076:\\n    def __init__(self, size, restrictions):\\n        self.parent = [i for i in range(size)]\\n        self.restrictions = [0] * size\\n        self.all = [(1<<i) for i in range(size)]\\n        for a, b in restrictions:\\n            self.restrictions[a] |= (1<<b)\\n            self.restrictions[b] |= (1<<a)\\n\\n    def find(self, n):\\n        m = n\\n        while self.parent[m] != m:\\n            m = self.parent[m]\\n        while self.parent[n] != m:\\n            old_parent = self.parent[n]\\n            self.parent[n] = m\\n            n = old_parent\\n        return m\\n\\n    def union(self, m, n):\\n        root_m, root_n = self.find(m), self.find(n)\\n        if root_m == root_n:\\n            return True\\n        if self.restrictions[root_m] & self.all[root_n]:\\n            return False\\n        self.parent[root_m] = root_n\\n        self.all[root_n] |= self.all[root_m]\\n        self.restrictions[root_n] |= self.restrictions[root_m]\\n        return True\\n\\nclass Solution:\\n    #2076\\n    def friendRequests(self, n: int, restrictions, requests):\\n        uf = UnionFind2076(n, restrictions)\\n        res = []\\n        for a,b in requests:\\n            res.append(uf.union(a,b))\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2239844,
                "title": "dsu",
                "content": "```\\nclass disjoint_set{\\n    vector<int> parent, rank;\\n    public:\\n    disjoint_set(int N){\\n        parent.resize(N);\\n        iota(parent.begin(),parent.end(),0);\\n        rank.assign(N,1);\\n    }\\n    \\n    int findParent(int u){\\n        if(parent[u]==u) return u;\\n        return parent[u]=findParent(parent[u]);\\n    }\\n    \\n    void _union(int u , int v){\\n         u = findParent(u);\\n         v = findParent(v);\\n        \\n        if(rank[u] < rank[v]) parent[u]=v;   \\n        else if(rank[v] < rank[u]) parent[v]=u;\\n        else{\\n            parent[v]=u;\\n            rank[u]++;\\n        }\\n    }\\n    \\n};\\n\\nclass Solution {\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        disjoint_set s(n);\\n        vector<bool> ans;\\n        \\n        for(auto &req:requests){\\n            int u = s.findParent(req[0]) , v = s.findParent(req[1]);\\n            //already connected indirectly, can also connext directly\\n             \\n            if(u==v){\\n                ans.push_back(true);\\n            }else{\\n                bool flag=true;\\n                for(auto &restriction : restrictions){\\n                    int x = s.findParent(restriction[0]), y = s.findParent(restriction[1]);\\n                    if((x==u and y==v) or (x==v and y==u)){\\n                        flag=false;\\n                        break;\\n                    }\\n                }\\n                ans.push_back(flag);\\n                if(flag) s._union(u,v);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass disjoint_set{\\n    vector<int> parent, rank;\\n    public:\\n    disjoint_set(int N){\\n        parent.resize(N);\\n        iota(parent.begin(),parent.end(),0);\\n        rank.assign(N,1);\\n    }\\n    \\n    int findParent(int u){\\n        if(parent[u]==u) return u;\\n        return parent[u]=findParent(parent[u]);\\n    }\\n    \\n    void _union(int u , int v){\\n         u = findParent(u);\\n         v = findParent(v);\\n        \\n        if(rank[u] < rank[v]) parent[u]=v;   \\n        else if(rank[v] < rank[u]) parent[v]=u;\\n        else{\\n            parent[v]=u;\\n            rank[u]++;\\n        }\\n    }\\n    \\n};\\n\\nclass Solution {\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        disjoint_set s(n);\\n        vector<bool> ans;\\n        \\n        for(auto &req:requests){\\n            int u = s.findParent(req[0]) , v = s.findParent(req[1]);\\n            //already connected indirectly, can also connext directly\\n             \\n            if(u==v){\\n                ans.push_back(true);\\n            }else{\\n                bool flag=true;\\n                for(auto &restriction : restrictions){\\n                    int x = s.findParent(restriction[0]), y = s.findParent(restriction[1]);\\n                    if((x==u and y==v) or (x==v and y==u)){\\n                        flag=false;\\n                        break;\\n                    }\\n                }\\n                ans.push_back(flag);\\n                if(flag) s._union(u,v);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2210913,
                "title": "python-union-find",
                "content": "```\\nclass Solution:\\n    def friendRequests(self, n: int, restrictions: List[List[int]], requests: List[List[int]]) -> List[bool]:\\n        def par(i):\\n            while i!=p[i]:\\n                i=p[i]\\n            return i\\n        def union(i,j):\\n            i=par(i)\\n            j=par(j)\\n            p[i]=j\\n        res=[]\\n        p=[i for i in range(n)]\\n        for a,b in requests:\\n            if par(a)==par(b):\\n                res.append(True)\\n                continue\\n            flag=True\\n            for i,j in restrictions:\\n                if (par(i)==par(a) and par(j)==par(b)) or (par(i)==par(b) and par(j)==par(a)):\\n                    flag=False\\n                    break\\n            if flag:\\n                res.append(True)\\n                union(a,b)\\n            else:\\n                res.append(False)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def friendRequests(self, n: int, restrictions: List[List[int]], requests: List[List[int]]) -> List[bool]:\\n        def par(i):\\n            while i!=p[i]:\\n                i=p[i]\\n            return i\\n        def union(i,j):\\n            i=par(i)\\n            j=par(j)\\n            p[i]=j\\n        res=[]\\n        p=[i for i in range(n)]\\n        for a,b in requests:\\n            if par(a)==par(b):\\n                res.append(True)\\n                continue\\n            flag=True\\n            for i,j in restrictions:\\n                if (par(i)==par(a) and par(j)==par(b)) or (par(i)==par(b) and par(j)==par(a)):\\n                    flag=False\\n                    break\\n            if flag:\\n                res.append(True)\\n                union(a,b)\\n            else:\\n                res.append(False)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2176317,
                "title": "java-17ms-with-bitset-100-modular-readable",
                "content": "This bitset solution should work even if the constraint is a bit higher because bitset and/or methods time complexity is O(n/32) or O(n/64). \\n\\n- Starting out, each person has their own group with their own banlist.\\n\\n- Whenever a friend request is successful, we merge these two groups, so that the leader of the group has a full list of members and ban list.\\n\\n- To check if group `A` and `B` can be merged, we `bitset.and()` group A member list with the group B banlist and vice versa.\\nThe resulting numbers must **both** be 0 otherwise we can\\'t merge them.\\n\\n- To merge group `A` and `B`, we use `bitset.or()` to set all the bits.\\n\\nI only submitted it once and scored 17ms at 100% Speed, which is so fast that there is no nearby yellow bars.\\n```Java\\nclass Solution {\\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        Group[] groups = new Group[n];\\n        Arrays.setAll(groups, o -> new Group(o)); // populate member list (themselves)\\n        for (int[] r : restrictions){ // populate banlist\\n            groups[r[0]].ban(r[1]);\\n            groups[r[1]].ban(r[0]);\\n        }\\n\\n        UF uf = new UF(n);\\n        boolean[] ans = new boolean[requests.length];\\n        for (int i = 0; i < requests.length; i++){ // union them.\\n            ans[i] = uf.union(requests[i][0], requests[i][1], groups);\\n        }\\n        return ans;\\n    }\\n\\n    private class Group {\\n        BitSet member = new BitSet();\\n        BitSet blacklist = new BitSet();\\n        Group(int n){\\n            member.set(n);\\n        }\\n\\n        void ban(int n){\\n            blacklist.set(n);\\n        }\\n\\n        void merge(Group other){\\n            member.or(other.member);\\n            blacklist.or(other.blacklist);\\n        }\\n\\n        boolean canFit(Group other){\\n            BitSet oMember = (BitSet)other.member.clone();\\n            oMember.and(blacklist);\\n            return oMember.cardinality()==0; // must be 0\\n        }\\n    }\\n\\n    private class UF {\\n        int[] parent;\\n        int[] rank;\\n        UF (int n){\\n            parent = IntStream.range(0, n).toArray();\\n            rank = new int[n];\\n        }\\n\\n        int find(int x){\\n            return x == parent[x]? x : (parent[x]=find(parent[x]));\\n        }\\n\\n        boolean union(int x, int y, Group[] groups){\\n            int xRoot = find(x);\\n            int yRoot = find(y);\\n            if (xRoot==yRoot)\\n                return true;\\n            if (!groups[xRoot].canFit(groups[yRoot]) || !groups[yRoot].canFit(groups[xRoot]))\\n                return false;\\n            if (rank[xRoot]>rank[yRoot]){\\n                parent[yRoot]=xRoot;\\n                groups[xRoot].merge(groups[yRoot]);\\n            }else{\\n                parent[xRoot]=yRoot;\\n                groups[yRoot].merge(groups[xRoot]);\\n                if (rank[xRoot]==rank[yRoot]){\\n                    rank[yRoot]++;\\n                }\\n            }\\n            return true;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```Java\\nclass Solution {\\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        Group[] groups = new Group[n];\\n        Arrays.setAll(groups, o -> new Group(o)); // populate member list (themselves)\\n        for (int[] r : restrictions){ // populate banlist\\n            groups[r[0]].ban(r[1]);\\n            groups[r[1]].ban(r[0]);\\n        }\\n\\n        UF uf = new UF(n);\\n        boolean[] ans = new boolean[requests.length];\\n        for (int i = 0; i < requests.length; i++){ // union them.\\n            ans[i] = uf.union(requests[i][0], requests[i][1], groups);\\n        }\\n        return ans;\\n    }\\n\\n    private class Group {\\n        BitSet member = new BitSet();\\n        BitSet blacklist = new BitSet();\\n        Group(int n){\\n            member.set(n);\\n        }\\n\\n        void ban(int n){\\n            blacklist.set(n);\\n        }\\n\\n        void merge(Group other){\\n            member.or(other.member);\\n            blacklist.or(other.blacklist);\\n        }\\n\\n        boolean canFit(Group other){\\n            BitSet oMember = (BitSet)other.member.clone();\\n            oMember.and(blacklist);\\n            return oMember.cardinality()==0; // must be 0\\n        }\\n    }\\n\\n    private class UF {\\n        int[] parent;\\n        int[] rank;\\n        UF (int n){\\n            parent = IntStream.range(0, n).toArray();\\n            rank = new int[n];\\n        }\\n\\n        int find(int x){\\n            return x == parent[x]? x : (parent[x]=find(parent[x]));\\n        }\\n\\n        boolean union(int x, int y, Group[] groups){\\n            int xRoot = find(x);\\n            int yRoot = find(y);\\n            if (xRoot==yRoot)\\n                return true;\\n            if (!groups[xRoot].canFit(groups[yRoot]) || !groups[yRoot].canFit(groups[xRoot]))\\n                return false;\\n            if (rank[xRoot]>rank[yRoot]){\\n                parent[yRoot]=xRoot;\\n                groups[xRoot].merge(groups[yRoot]);\\n            }else{\\n                parent[xRoot]=yRoot;\\n                groups[yRoot].merge(groups[xRoot]);\\n                if (rank[xRoot]==rank[yRoot]){\\n                    rank[yRoot]++;\\n                }\\n            }\\n            return true;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2176072,
                "title": "c-easy-to-understand-dsu-implementation",
                "content": "```\\nclass DSU\\n{\\n    public:\\n    int findParent(int node,vector<int>& par)\\n    {\\n        if(par[node]==node)return node;\\n        return par[node]=findParent(par[node],par);\\n    }\\n    void Union(int u,int v,vector<int> &size,vector<int> &par)\\n    {\\n        int pu=findParent(u,par);\\n        int pv=findParent(v,par);\\n        if(pu==pv)return;\\n        if(size[pu]<=size[pv])\\n        {\\n            par[pu]=pv;\\n            size[pv]++;\\n        }\\n        else\\n        {\\n            par[pv]=pu;\\n            size[pu]++;\\n        }\\n    }\\n    bool isConnected(int u,int v,vector<int> &par)\\n    {\\n        int pu=findParent(u,par);\\n        int pv=findParent(v,par);\\n        if(pu==pv)return 1;\\n        return 0;\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& re, vector<vector<int>>& r) {\\n        DSU dsu;\\n        vector<int> parent(n,0),size(n,1);\\n        for(int i=0;i<n;i++)\\n        {\\n            parent[i]=i;\\n        }\\n        vector<bool> ans;\\n        for(int i=0;i<r.size();i++)\\n        {\\n            int x,y;\\n            x=dsu.findParent(r[i][0],parent);\\n            y=dsu.findParent(r[i][1],parent);\\n            bool ok=true;\\n            for(int j=0;j<re.size();j++)\\n            {\\n                int x1,y1;\\n                x1=dsu.findParent(re[j][0],parent);\\n                y1=dsu.findParent(re[j][1],parent);\\n                if((x==x1&&y==y1)||(x==y1&&y==x1))\\n                {\\n                    ok=false;\\n                    break;\\n                }\\n            }\\n            if(ok)\\n            {\\n                dsu.Union(x,y,size,parent);\\n            }\\n            ans.push_back(ok);\\n        }   \\n        return ans;\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [],
                "code": "```\\nclass DSU\\n{\\n    public:\\n    int findParent(int node,vector<int>& par)\\n    {\\n        if(par[node]==node)return node;\\n        return par[node]=findParent(par[node],par);\\n    }\\n    void Union(int u,int v,vector<int> &size,vector<int> &par)\\n    {\\n        int pu=findParent(u,par);\\n        int pv=findParent(v,par);\\n        if(pu==pv)return;\\n        if(size[pu]<=size[pv])\\n        {\\n            par[pu]=pv;\\n            size[pv]++;\\n        }\\n        else\\n        {\\n            par[pv]=pu;\\n            size[pu]++;\\n        }\\n    }\\n    bool isConnected(int u,int v,vector<int> &par)\\n    {\\n        int pu=findParent(u,par);\\n        int pv=findParent(v,par);\\n        if(pu==pv)return 1;\\n        return 0;\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& re, vector<vector<int>>& r) {\\n        DSU dsu;\\n        vector<int> parent(n,0),size(n,1);\\n        for(int i=0;i<n;i++)\\n        {\\n            parent[i]=i;\\n        }\\n        vector<bool> ans;\\n        for(int i=0;i<r.size();i++)\\n        {\\n            int x,y;\\n            x=dsu.findParent(r[i][0],parent);\\n            y=dsu.findParent(r[i][1],parent);\\n            bool ok=true;\\n            for(int j=0;j<re.size();j++)\\n            {\\n                int x1,y1;\\n                x1=dsu.findParent(re[j][0],parent);\\n                y1=dsu.findParent(re[j][1],parent);\\n                if((x==x1&&y==y1)||(x==y1&&y==x1))\\n                {\\n                    ok=false;\\n                    break;\\n                }\\n            }\\n            if(ok)\\n            {\\n                dsu.Union(x,y,size,parent);\\n            }\\n            ans.push_back(ok);\\n        }   \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2133522,
                "title": "c-disjoint-set-union-find-solution-graph",
                "content": "```\\nvector<int> parent,sz;\\n    int find(int x){\\n       if(x==parent[x]) return x;\\n       return find(parent[x]);\\n    }\\n    void make_union(int x,int y){\\n       int a=find(x);\\n       int b=find(y);\\n       if(a!=b){\\n         if(sz[a]<sz[b]){\\n            parent[a]=b;\\n            sz[b]+=sz[a];\\n         }\\n         else{\\n             parent[b]=a;\\n             sz[a]+=sz[b];\\n         }\\n       }\\n    }\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests){\\n       parent.resize(n+1);\\n       sz.resize(n+1);\\n       for(int i=0;i<n;i++) parent[i]=i,sz[i]+=1;\\n       vector<bool> ans(requests.size(),true);\\n       for(int i=0;i<requests.size();i++){\\n          int a=find(requests[i][0]),b=find(requests[i][1]);\\n          make_union(requests[i][0],requests[i][1]);\\n          bool flag=true;\\n          for(int j=0;j<restrictions.size();j++){\\n            if(find(restrictions[j][0])==find(restrictions[j][1])){\\n              flag=false;\\n              break;\\n            }\\n          }\\n          if(!flag){\\n             parent[a]=a,parent[b]=b;\\n             ans[i]=false;\\n          }\\n       }\\n       return ans;\\n    }",
                "solutionTags": [
                    "C",
                    "Union Find"
                ],
                "code": "```\\nvector<int> parent,sz;\\n    int find(int x){\\n       if(x==parent[x]) return x;\\n       return find(parent[x]);\\n    }\\n    void make_union(int x,int y){\\n       int a=find(x);\\n       int b=find(y);\\n       if(a!=b){\\n         if(sz[a]<sz[b]){\\n            parent[a]=b;\\n            sz[b]+=sz[a];\\n         }\\n         else{\\n             parent[b]=a;\\n             sz[a]+=sz[b];\\n         }\\n       }\\n    }\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests){\\n       parent.resize(n+1);\\n       sz.resize(n+1);\\n       for(int i=0;i<n;i++) parent[i]=i,sz[i]+=1;\\n       vector<bool> ans(requests.size(),true);\\n       for(int i=0;i<requests.size();i++){\\n          int a=find(requests[i][0]),b=find(requests[i][1]);\\n          make_union(requests[i][0],requests[i][1]);\\n          bool flag=true;\\n          for(int j=0;j<restrictions.size();j++){\\n            if(find(restrictions[j][0])==find(restrictions[j][1])){\\n              flag=false;\\n              break;\\n            }\\n          }\\n          if(!flag){\\n             parent[a]=a,parent[b]=b;\\n             ans[i]=false;\\n          }\\n       }\\n       return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2128275,
                "title": "simple-c-union-find-bitmask-beat-99",
                "content": "Use Union Find to group friends among 0..n-1 based on \"requests\".\\n\\nSuppose a request (x, y), think about group(x) and group(y) -- the criteria to allow x to be y\\'s friend (or vice versa) is, \\n     group(x) == group(y) ***OR*** \\n\\t everyone in group(x) is not in group(y)\\'s restriction list ***AND*** everyone in group(y) is not in group(x)\\'s restriction list.\\n\\nAll members of group(x) or group(y) can be collected during Union Find, as well as all members of restriction list (exclusive list). Use Bitmask (bitset) to simplify the operations.\\n\\n\\n```\\nclass Solution {\\n        // union find\\n        vector<int> dsu;\\n        void Init(int n) {\\n            dsu.resize(n);\\n            iota(dsu.begin(), dsu.end(), 0);\\n        }\\n\\n        int Find(int i) {\\n            while(dsu[i]!=i) i=dsu[i];\\n            return i;\\n        };\\n        \\n        void Union(int i, int j) {\\n            dsu[i]=dsu[j]=dsu[Find(i)]=Find(j);\\n        };\\n        \\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        Init(n);\\n        \\n        // inclusive list and exclusive list of a group\\n        vector<bitset<2000>> incl(n, 0), excl(n, 0);\\n        for (int i=0; i<n; i++) incl[i][i]=true;\\n        for (auto& e: restrictions) \\n            excl[e[0]][e[1]]= excl[e[1]][e[0]]=true;\\n        \\n        vector<bool> res;\\n        for (auto& e: requests) {\\n            int x=e[0], y=e[1], x_=Find(x), y_=Find(y);\\n            //the matching criteria on group x_ and y_\\n            bool pass = (x_==y_) || (incl[x_] & excl[y_]).none() && (incl[y_] & excl[x_]).none();\\n            res.push_back(pass);\\n            \\n            if (pass && x_!=y_ ) {\\n                Union(x_, y_);\\n                incl[Find(y_)] = incl[x_] | incl[y_];\\n                excl[Find(y_)] = excl[x_] | excl[y_];\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n        // union find\\n        vector<int> dsu;\\n        void Init(int n) {\\n            dsu.resize(n);\\n            iota(dsu.begin(), dsu.end(), 0);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2115026,
                "title": "python3-set-union-based-solution",
                "content": "```\\n\"\"\"https://leetcode.com/problems/process-restricted-friend-requests/\"\"\"\\n\\n\\nclass Solution:\\n    def friendRequests(self, n: int, restrictions: List[List[int]], requests: List[List[int]]) -> List[bool]:\\n        def safe_to_process(x, y):\\n            for c1 in connected[x]:\\n                for c2 in connected[y]:\\n                    if (c1 in banned[c2]) or (c2 in banned[c1]):\\n                        return False\\n            return True\\n\\n        def update(x, y):\\n            new_connection, new_banned = connected[x].union(connected[y]), banned[x].union(banned[y])\\n            for c in new_connection:\\n                connected[c], banned[c] = new_connection, new_banned\\n\\n        connected = [{i} for i in range(n)]\\n        banned = [set() for _ in range(n)]\\n        for u, v in restrictions:\\n            banned[u].add(v)\\n            banned[v].add(u)\\n\\n        ans = []\\n        for (u, v) in requests:\\n            if safe_to_process(u, v):\\n                ans.append(True)\\n                update(u, v)\\n            else:\\n                ans.append(False)\\n\\n        return ans",
                "solutionTags": [],
                "code": "class Solution:\\n    def friendRequests(self, n: int, restrictions: List[List[int]], requests: List[List[int]]) -> List[bool]:\\n        def safe_to_process(x, y):\\n            for c1 in connected[x]:\\n                for c2 in connected[y]:\\n                    if (c1 in banned[c2]) or (c2 in banned[c1]):\\n                        return False\\n            return True\\n\\n        def update(x, y):\\n            new_connection, new_banned = connected[x].union(connected[y]), banned[x].union(banned[y])\\n            for c in new_connection:\\n                connected[c], banned[c] = new_connection, new_banned\\n\\n        connected = [{i}",
                "codeTag": "Java"
            },
            {
                "id": 2102915,
                "title": "c-disjoint-set-union-find",
                "content": "```\\nclass Solution {\\nprivate:\\n    vector<int> prnt, rnk;\\n\\n    int find(int u) {\\n        if(prnt[u] == -1) return u;\\n        return prnt[u] = find(prnt[u]);\\n    }\\n\\n    void merge(int u, int v) {\\n        u = find(u);\\n        v = find(v);\\n        \\n        if(u == v)\\n            return;\\n\\n        if(rnk[u] < rnk[v]) swap(u, v);\\n\\n        rnk[u] += rnk[v];\\n        prnt[v] = u;\\n    }\\n\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        rnk = vector<int>(n, 1);\\n        prnt = vector<int>(n, -1);\\n        \\n        vector<bool> ans(requests.size());\\n        for(int i = 0; i < requests.size(); i++) {\\n            int u = find(requests[i][0]);\\n            int v = find(requests[i][1]);\\n            bool flag = true;\\n            for(auto& it: restrictions) {\\n                int a = find(it[0]);\\n                int b = find(it[1]);\\n                if((u == a && v == b) || (u == b && v == a)) {\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            ans[i] = flag;\\n            if(flag) \\n                merge(u, v);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    vector<int> prnt, rnk;\\n\\n    int find(int u) {\\n        if(prnt[u] == -1) return u;\\n        return prnt[u] = find(prnt[u]);\\n    }\\n\\n    void merge(int u, int v) {\\n        u = find(u);\\n        v = find(v);\\n        \\n        if(u == v)\\n            return;\\n\\n        if(rnk[u] < rnk[v]) swap(u, v);\\n\\n        rnk[u] += rnk[v];\\n        prnt[v] = u;\\n    }\\n\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        rnk = vector<int>(n, 1);\\n        prnt = vector<int>(n, -1);\\n        \\n        vector<bool> ans(requests.size());\\n        for(int i = 0; i < requests.size(); i++) {\\n            int u = find(requests[i][0]);\\n            int v = find(requests[i][1]);\\n            bool flag = true;\\n            for(auto& it: restrictions) {\\n                int a = find(it[0]);\\n                int b = find(it[1]);\\n                if((u == a && v == b) || (u == b && v == a)) {\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            ans[i] = flag;\\n            if(flag) \\n                merge(u, v);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2084595,
                "title": "python-fast-uf-with-hashmap-no-tle-better-than-two-loops",
                "content": "In other posts using UF, two loops are used. it can actually optimzied.\\n\\nFor each request, to avoid the loop of restriction array, we only need to update the new root label\\'s forbidden elements. This avoids the n2 complexity in general cases, in the worst case same as n*n.\\nNote: the old forbidden elements should be updated with their updated new parents also.\\n\\n```\\n def friendRequests(self, n: int, restrictions: List[List[int]], requests: List[List[int]]) -> List[bool]:\\n        p=[i for i in range(n)]\\n        def getp(x):\\n            if x!=p[x]:\\n                p[x]=getp(p[x])\\n            return p[x]\\n        def union(x,y):\\n            px=getp(x)\\n            py=getp(y)\\n            if px<py:\\n                p[py]=px\\n            else:\\n                p[px]=py\\n        def getrest():\\n            fbd=defaultdict(list)\\n            for a,b in restrictions:\\n                pa=getp(a)\\n                pb=getp(b)\\n                if pb not in fbd[pa]:\\n                    fbd[pa].append(pb)\\n                if pa not in fbd[pb]:\\n                    fbd[pb].append(pa)\\n            return fbd\\n        res=[]\\n        forbd=getrest()\\n        for a,b in requests:\\n            pa=getp(a)\\n            pb=getp(b)\\n            if pa in forbd[pb] or pb in forbd[pa]:\\n                res.append(False)\\n            else:\\n                res.append(True)\\n                union(a,b)\\n                ## also need update the forbidden relations\\n                npa=getp(a)\\n                npb=getp(b)\\n                for e in forbd[pa]:\\n                    pe=getp(e)\\n                    if pe not in forbd[npa]:\\n                        forbd[npa].append(pe)\\n                for f in forbd[pb]:\\n                    pf=getp(f)\\n                    if pf not in forbd[npb]:\\n                        forbd[npb].append(pf)\\n                \\n        return res",
                "solutionTags": [],
                "code": "In other posts using UF, two loops are used. it can actually optimzied.\\n\\nFor each request, to avoid the loop of restriction array, we only need to update the new root label\\'s forbidden elements. This avoids the n2 complexity in general cases, in the worst case same as n*n.\\nNote: the old forbidden elements should be updated with their updated new parents also.\\n\\n```\\n def friendRequests(self, n: int, restrictions: List[List[int]], requests: List[List[int]]) -> List[bool]:\\n        p=[i for i in range(n)]\\n        def getp(x):\\n            if x!=p[x]:\\n                p[x]=getp(p[x])\\n            return p[x]\\n        def union(x,y):\\n            px=getp(x)\\n            py=getp(y)\\n            if px<py:\\n                p[py]=px\\n            else:\\n                p[px]=py\\n        def getrest():\\n            fbd=defaultdict(list)\\n            for a,b in restrictions:\\n                pa=getp(a)\\n                pb=getp(b)\\n                if pb not in fbd[pa]:\\n                    fbd[pa].append(pb)\\n                if pa not in fbd[pb]:\\n                    fbd[pb].append(pa)\\n            return fbd\\n        res=[]\\n        forbd=getrest()\\n        for a,b in requests:\\n            pa=getp(a)\\n            pb=getp(b)\\n            if pa in forbd[pb] or pb in forbd[pa]:\\n                res.append(False)\\n            else:\\n                res.append(True)\\n                union(a,b)\\n                ## also need update the forbidden relations\\n                npa=getp(a)\\n                npb=getp(b)\\n                for e in forbd[pa]:\\n                    pe=getp(e)\\n                    if pe not in forbd[npa]:\\n                        forbd[npa].append(pe)\\n                for f in forbd[pb]:\\n                    pf=getp(f)\\n                    if pf not in forbd[npb]:\\n                        forbd[npb].append(pf)\\n                \\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 2037434,
                "title": "c-union-find-solution-o-res-req",
                "content": "Runtime: 276 ms, faster than 82.46% of C++ online submissions for Process Restricted Friend Requests.\\nMemory Usage: 21.7 MB, less than 98.10% of C++ online submissions for Process Restricted Friend Requests.\\n\\n\\n```\\nWe can check if two person are in same friend group using union find by checking if their leaders are same.\\nIf they are not in same friend group already then we can check the leaders of the restricted connections\\nand if the leaders matches exactly with leader of both person then there will be a direct or indirect\\nconnection if we make them friend, and so we can not send friend request. \\nWhen friend request is valid, we unify both person or friends.\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int parents[1001];\\n    \\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        \\n        for(int i=0;i<n;i++)parents[i]=i;\\n    \\n        vector<bool>res;\\n        \\n        int p,q,rp,rq;\\n        for(auto & req: requests)\\n        {\\n            bool valid = true;\\n            \\n            // get the leader of both person friend group\\n            p = find(req[0]);\\n            q = find(req[1]);\\n            \\n            // if the leaders are same then the request is valid\\n            // otherwise we have to check the leaders of the restricted connections\\n            if(p!=q)\\n            {\\n                for(auto & rest : restrictions)\\n                {\\n                    rp = find(rest[0]);\\n                    rq = find(rest[1]);\\n         \\n                    // restricted connection leaders matches exactly with the person leaders\\n                    // so their is a path from both person to the restricted connection nodes                    \\n                    if((p==rp && q==rq) || (p==rq && q==rp))\\n                    {\\n                        valid = false;\\n                        break;\\n                    }\\n                }\\n            }\\n            \\n            // make persons friend by unify them when request is valid\\n            if(valid)parents[p]=q;\\n            \\n            res.push_back(valid);\\n        }\\n        \\n        return res;\\n        \\n    }\\n    \\n    int find(int t)\\n    {\\n        if(parents[t]==t)return t;\\n        return parents[t] = find(parents[t]);\\n    }\\n        \\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\nWe can check if two person are in same friend group using union find by checking if their leaders are same.\\nIf they are not in same friend group already then we can check the leaders of the restricted connections\\nand if the leaders matches exactly with leader of both person then there will be a direct or indirect\\nconnection if we make them friend, and so we can not send friend request. \\nWhen friend request is valid, we unify both person or friends.\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    int parents[1001];\\n    \\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        \\n        for(int i=0;i<n;i++)parents[i]=i;\\n    \\n        vector<bool>res;\\n        \\n        int p,q,rp,rq;\\n        for(auto & req: requests)\\n        {\\n            bool valid = true;\\n            \\n            // get the leader of both person friend group\\n            p = find(req[0]);\\n            q = find(req[1]);\\n            \\n            // if the leaders are same then the request is valid\\n            // otherwise we have to check the leaders of the restricted connections\\n            if(p!=q)\\n            {\\n                for(auto & rest : restrictions)\\n                {\\n                    rp = find(rest[0]);\\n                    rq = find(rest[1]);\\n         \\n                    // restricted connection leaders matches exactly with the person leaders\\n                    // so their is a path from both person to the restricted connection nodes                    \\n                    if((p==rp && q==rq) || (p==rq && q==rp))\\n                    {\\n                        valid = false;\\n                        break;\\n                    }\\n                }\\n            }\\n            \\n            // make persons friend by unify them when request is valid\\n            if(valid)parents[p]=q;\\n            \\n            res.push_back(valid);\\n        }\\n        \\n        return res;\\n        \\n    }\\n    \\n    int find(int t)\\n    {\\n        if(parents[t]==t)return t;\\n        return parents[t] = find(parents[t]);\\n    }\\n        \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2036034,
                "title": "fully-explained-for-beginners-c",
                "content": "whenever there is a relation, hates, dont want to be in same class, frnds or whatsoever. it means a graph ques.\\nvalid for topo sort also.\\n\\ngiven:  in restricted relation, 2 people shouldnt be frnds {a,b} {b,c} \\na and b . frnddhip not allowed\\nb and c. not allowed\\na and c ( allowed) { check eg3. frndhip directly and indirectly gets confusing. even i got confused abt the transitive property}.\\n\\nalso\\na -e -b  this frndship is also not allowed.\\nhence \\nto check for a-e (allowed if  e-b isnt there) and vice versa. so here for request a -e we first had to check if  b  isnt connected to e . directly or through any chain. e--g-t-o-p-b( this should also not be thre). \\nand whts the best way to do it? either use dfs to go through every frndship chain from e.\\nor\\n**** just use union-find /DSU data structure ( 4 alpha complexity).****\\n\\n**acc to constraints accepts N square.\\n**\\n\\nso before every request check that it doesnt violate any restriction. \\nfor( evry f1 , f2 in request )\\n\\t// check for every restriction\\n\\tfor( people{x,y} in restrictions)\\n\\t\\t// parent of x  and parent of y shouldnt be  same by r1 request\\n\\t\\t//  i.e allowed if --> par[x]!= par[f1] and par[y] != par[f2]  or criss cross\\n\\t\\t// else they will be in same grp\\n\\tif all restrictions are held true then form frndship.\\n\\n\\n\\n\\n```\\nclass Solution {\\n     vector<int> parent;\\n     vector<int> rank;\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& b, vector<vector<int>>& r)\\n    {\\n        vector<bool> ans;\\n        //int n = g.size();\\n        parent.resize( n, -1);\\n        // all nodes are parent of themselves inititally, if parent[u] = -k thne u is leader of grp of k nodes\\n        rank.resize( n, 1); // initially no node is connected hence rank is 1 for all\\n        \\n        // edges\\n        for( int i =0 ; i < r.size() ; i ++)\\n           {\\n                int p1 = find(r[i][0]);\\n                int p2 = find(r[i][1]);\\n                // if this req doesnt violate any restriction, then this merger is valid\\n                int allowed =1;\\n                 for( int j =0 ; j < b.size() ; j ++)\\n                 {\\n                     int a = find(b[j][0]);\\n                     int b1 = find(b[j][1]);\\n                     // they shopuld be in diff grp that is theoir parents a/b shouldnt form pair {}\\n                    if( (a==p1 and b1 ==p2 ) or ( a==p2 and b1== p1) )\\n                       // not allowed\\n                       { allowed =0; break;}\\n                 }\\n                 if( allowed)\\n                       {\\n                        addedge(p1,p2);\\n                        ans.push_back( true);     \\n                       }   \\n                else\\n                    ans.push_back( false);     \\n            }\\n        return ans;\\n    }\\n    \\n    // start of template\\n    \\n     void addedge( int i , int j )\\n        {\\n            // add edge if their parents are diff\\n            if( find(i) == find(j))\\n                return; // same parents, also condition for cycle present\\n            else \\n                merge( i , j);\\n        }\\n    int find( int u) // return parent of u \\n    {\\n        if( parent[u] < 0 ) // it is its own parent\\n            return u;\\n        else \\n            return parent[u] = find(parent[u]);\\n    }\\n    void merge( int u , int v )\\n    {\\n        // merge by rank\\n        int a = find(u); // find parent of both of them\\n        int b = find(v);\\n        if( a == b) // both have same parents\\n            return;\\n        int ra= rank[u]; // rank of parent a\\n        int rb = rank[v];\\n        if( ra > rb) // a has more nodes chain in its grp, hence add b in a\\'s grp, to keep parent chain hierachy as sort as possible\\n        {\\n            parent[a] += parent[b]; //add nodes in b to nodes of a\\n            parent[b]=a;\\n        }\\n        else if( ra < rb) // a has more nodes chain in its grp, hence add b in a\\'s grp, to keep parent chain hierachy as sort as possible\\n        {\\n            parent[b] += parent[a]; //add nodes in b to nodes of a\\n            parent[a]=b;\\n        \\n        }\\n        else // both have same rank\\n        {\\n            parent[a] += parent[b]; //add nodes in b to nodes of a\\n            parent[b]=a;\\n            rank[a]++;\\n        }\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Union Find"
                ],
                "code": "class Solution {\\n     vector<int> parent;\\n     vector<int> rank;\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& b, vector<vector<int>>& r)\\n    {\\n        vector<bool> ans;\\n        //int n = g.size();\\n        parent.resize( n, -1);\\n        // all nodes are parent of themselves inititally, if parent[u] = -k thne u is leader of grp of k nodes\\n        rank.resize( n, 1); // initially no node is connected hence rank is 1 for all\\n        \\n        // edges\\n        for( int i =0 ; i < r.size() ; i ++)\\n           {\\n                int p1 = find(r[i][0]);\\n                int p2 = find(r[i][1]);\\n                // if this req doesnt violate any restriction, then this merger is valid\\n                int allowed =1;\\n                 for( int j =0 ; j < b.size() ; j ++)\\n                 {\\n                     int a = find(b[j][0]);\\n                     int b1 = find(b[j][1]);\\n                     // they shopuld be in diff grp that is theoir parents a/b shouldnt form pair {}",
                "codeTag": "Java"
            },
            {
                "id": 2016223,
                "title": "java-union-find-brute-force-on-restrictions",
                "content": "```\\nclass Solution {\\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        UnionFind uf = new UnionFind(n);\\n        boolean[] answer = new boolean[requests.length];\\n        int k = 0;\\n        for(int[] friends: requests)\\n        {\\n            int p1 = uf.Find(friends[0]);\\n            int p2 = uf.Find(friends[1]);\\n            boolean request = true;\\n            if(p1 != p2)\\n            {\\n                for(int[] block: restrictions)\\n                {\\n                    int x = uf.Find(block[0]), y = uf.Find(block[1]);\\n                    if(p1 == x && p2 == y || p1 == y && p2 == x)\\n                    {\\n                        request = false;\\n                        break;\\n                    }    \\n                }\\n            }\\n            \\n            if(request)\\n                uf.Union(p1, p2);\\n            answer[k++] = request;\\n        }\\n        return answer;\\n    }\\n    \\n    class UnionFind {\\n        int[] parent;\\n        \\n        public UnionFind(int len){\\n            parent = new int[len];\\n            for(int i = 0; i < len; i++)\\n                parent[i] = i;\\n        }\\n        \\n        private int Find(int node)\\n        {\\n            if(parent[node] != node)\\n                parent[node] = Find(parent[node]);\\n            \\n            return parent[node];\\n        }\\n        \\n        private void Union(int a, int b)\\n        {\\n            int parentA = Find(a);\\n            int parentB = Find(b);\\n            \\n            parent[parentA] = parentB;\\n        }\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        UnionFind uf = new UnionFind(n);\\n        boolean[] answer = new boolean[requests.length];\\n        int k = 0;\\n        for(int[] friends: requests)\\n        {\\n            int p1 = uf.Find(friends[0]);\\n            int p2 = uf.Find(friends[1]);\\n            boolean request = true;\\n            if(p1 != p2)\\n            {\\n                for(int[] block: restrictions)\\n                {\\n                    int x = uf.Find(block[0]), y = uf.Find(block[1]);\\n                    if(p1 == x && p2 == y || p1 == y && p2 == x)\\n                    {\\n                        request = false;\\n                        break;\\n                    }    \\n                }\\n            }\\n            \\n            if(request)\\n                uf.Union(p1, p2);\\n            answer[k++] = request;\\n        }\\n        return answer;\\n    }\\n    \\n    class UnionFind {\\n        int[] parent;\\n        \\n        public UnionFind(int len){\\n            parent = new int[len];\\n            for(int i = 0; i < len; i++)\\n                parent[i] = i;\\n        }\\n        \\n        private int Find(int node)\\n        {\\n            if(parent[node] != node)\\n                parent[node] = Find(parent[node]);\\n            \\n            return parent[node];\\n        }\\n        \\n        private void Union(int a, int b)\\n        {\\n            int parentA = Find(a);\\n            int parentB = Find(b);\\n            \\n            parent[parentA] = parentB;\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2002671,
                "title": "c-easy-to-understand-union-find-dsu",
                "content": "This solution uses Union-Find (DSU) optimized with union by rank and path compression, if you don\\'t know how to use DSU, i highly recommend to do this problem first to understand it: https://leetcode.com/problems/the-earliest-moment-when-everyone-become-friends/solution/\\n\\n```\\nclass Solution {\\n\\nstruct unionFind{\\n    vector<int> roots;\\n    vector<int> heights;\\n    \\n    unionFind(int sz):roots(sz),heights(sz){\\n        for(int i=0;i<sz;i++){//initializes all subtrees with their own node and height 1\\n            roots[i]=i;\\n            heights[i]=1;\\n        }\\n            \\n    }\\n    \\n    int find(int x){\\n        return (x==roots[x])?x:roots[x]=find(roots[x]); //DSU with path compression\\n    }\\n    \\n    void connect(int a,int b){\\n        int root1=find(a),root2=find(b);\\n        if(root1!=root2){\\n            if(heights[root1]>heights[root2])\\n                roots[root2]=root1;\\n            else if(heights[root1]<heights[root2]) //Union by rank\\n                roots[root1]=root2;\\n            else{\\n                roots[root2]=root1;\\n                heights[root1]++;\\n            }\\n        }\\n    }\\n    \\n    bool isConnected(int a,int b){\\n        return find(a)==find(b); //Function to know if two nodes are connected\\n    }\\n    \\n};\\n    \\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        vector<bool> result(requests.size(),true); //Result array supposing that all requests are valid\\n        unionFind dsu(n),temp(1);//friends graph and a temporary one to know if a request is valid\\n        \\n        for(int i=0;i<requests.size();i++){\\n            int x=requests[i][0],y=requests[i][1]; //person x and person y\\n            \\n            temp=dsu; //makes a temporary DSU to test if x and y can become friends\\n            temp.connect(x,y);//makes friends x and y\\n            \\n            for(vector<int> &a:restrictions){ //explore all restrictions NOTE: USE THE \"&\" SYMBOL TO PASS BY REFERENCE THE ARRAY AND SAVE A LOT OF TIME, OTHERWISE YOU\\'LL GET A TLE, OMG I RECEIVED A TLE FOR THAT TINY THING SO BE CAREFULL PLEASE\\n                if(temp.isConnected(a[0],a[1])){ //check if the not valid friends still disconnected\\n                    result[i]=false;//if they\\'re connected that means that the current request it\\'s invalid\\n                    break;\\n                }\\n            }\\n\\n            if(result[i])//if the request was valid, the temporary array takes place of the original one\\n                dsu=temp;\\n            \\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n\\nstruct unionFind{\\n    vector<int> roots;\\n    vector<int> heights;\\n    \\n    unionFind(int sz):roots(sz),heights(sz){\\n        for(int i=0;i<sz;i++){//initializes all subtrees with their own node and height 1\\n            roots[i]=i;\\n            heights[i]=1;\\n        }\\n            \\n    }\\n    \\n    int find(int x){\\n        return (x==roots[x])?x:roots[x]=find(roots[x]); //DSU with path compression\\n    }\\n    \\n    void connect(int a,int b){\\n        int root1=find(a),root2=find(b);\\n        if(root1!=root2){\\n            if(heights[root1]>heights[root2])\\n                roots[root2]=root1;\\n            else if(heights[root1]<heights[root2]) //Union by rank\\n                roots[root1]=root2;\\n            else{\\n                roots[root2]=root1;\\n                heights[root1]++;\\n            }\\n        }\\n    }\\n    \\n    bool isConnected(int a,int b){\\n        return find(a)==find(b); //Function to know if two nodes are connected\\n    }\\n    \\n};\\n    \\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        vector<bool> result(requests.size(),true); //Result array supposing that all requests are valid\\n        unionFind dsu(n),temp(1);//friends graph and a temporary one to know if a request is valid\\n        \\n        for(int i=0;i<requests.size();i++){\\n            int x=requests[i][0],y=requests[i][1]; //person x and person y\\n            \\n            temp=dsu; //makes a temporary DSU to test if x and y can become friends\\n            temp.connect(x,y);//makes friends x and y\\n            \\n            for(vector<int> &a:restrictions){ //explore all restrictions NOTE: USE THE \"&\" SYMBOL TO PASS BY REFERENCE THE ARRAY AND SAVE A LOT OF TIME, OTHERWISE YOU\\'LL GET A TLE, OMG I RECEIVED A TLE FOR THAT TINY THING SO BE CAREFULL PLEASE\\n                if(temp.isConnected(a[0],a[1])){ //check if the not valid friends still disconnected\\n                    result[i]=false;//if they\\'re connected that means that the current request it\\'s invalid\\n                    break;\\n                }\\n            }\\n\\n            if(result[i])//if the request was valid, the temporary array takes place of the original one\\n                dsu=temp;\\n            \\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1993811,
                "title": "clean-python-with-union",
                "content": "\\tdef friendRequests(self, n, restrictions, requests):\\n        connected = [set([i]) for i in range(n)]\\n        banned = [set() for _ in range(n)]\\n        \\n        for x, y in restrictions:\\n            banned[x].add(y)\\n            banned[y].add(x)\\n        \\n        def isSafe(x, y):\\n            for c1 in connected[x]:\\n                for c2 in connected[y]:\\n                    if (c1 in banned[c2]) or (c2 in banned[c1]):\\n                        return False\\n            return True\\n        \\n        def update(x, y):\\n            newConnection = connected[x].union(connected[y])\\n            newBanned = banned[x].union(banned[y])\\n            for c in newConnection:\\n                connected[c] = newConnection\\n                banned[c] = newBanned     \\n                           \\n        out = []\\n        for i, (x, y) in enumerate(requests):\\n            if isSafe(x, y):\\n                out.append(True)\\n                update(x, y)   \\n            else:\\n                out.append(False)",
                "solutionTags": [],
                "code": "\\tdef friendRequests(self, n, restrictions, requests):\\n        connected = [set([i]) for i in range(n)]\\n        banned = [set() for _ in range(n)]\\n        \\n        for x, y in restrictions:\\n            banned[x].add(y)\\n            banned[y].add(x)\\n        \\n        def isSafe(x, y):\\n            for c1 in connected[x]:\\n                for c2 in connected[y]:\\n                    if (c1 in banned[c2]) or (c2 in banned[c1]):\\n                        return False\\n            return True\\n        \\n        def update(x, y):\\n            newConnection = connected[x].union(connected[y])\\n            newBanned = banned[x].union(banned[y])\\n            for c in newConnection:\\n                connected[c] = newConnection\\n                banned[c] = newBanned     \\n                           \\n        out = []\\n        for i, (x, y) in enumerate(requests):\\n            if isSafe(x, y):\\n                out.append(True)\\n                update(x, y)   \\n            else:\\n                out.append(False)",
                "codeTag": "Python3"
            },
            {
                "id": 1987627,
                "title": "c-solution-with-explanation-union-find-path-compression",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> parent,rank;\\n    vector<bool> friendRequests(int n, vector<vector<int>>& res, vector<vector<int>>& reqs) {\\n         vector<bool> ans;\\n         parent.resize(n,0);\\n         rank.resize(n,0);\\n         for(int i=0; i<n; i++) parent[i]=i;\\n         for(auto req : reqs) {\\n              bool good = true;\\n              int friend1 = find(req[0]) , friend2 = find(req[1]);\\n              if(friend1 != friend2) {\\n                  for(int j=0; j<res.size(); j++) {\\n                       int blocked_user1 = find(res[j][0]) , blocked_user2 = find(res[j][1]);\\n                       // if parent of friends are same as the parent of blocked user then it is restricted\\n                       if((friend1==blocked_user1 && friend2==blocked_user2) || (friend1==blocked_user2 && friend2==blocked_user1)) {\\n                             good = false;\\n                             break;\\n                       }\\n                  }\\n              }\\n              if(good) union_(req[0],req[1]); // if the people\\'s request are restricted already , dont make them friends !\\n              ans.push_back(good);\\n         }\\n        return ans;\\n}\\n    int find(int a) {\\n        if(parent[a]==a) return a;\\n        else return parent[a]=find(parent[a]);\\n    }\\n    void union_(int a,int b) {\\n        if(a==b) return;\\n        a=find(a),b=find(b);\\n        // path compression\\n        if(rank[a]<rank[b]) {\\n             parent[a]=b;\\n        }else if(rank[b]<rank[a]) {\\n             parent[b]=a;\\n        }else {\\n             rank[a]++;\\n             parent[a]=b;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> parent,rank;\\n    vector<bool> friendRequests(int n, vector<vector<int>>& res, vector<vector<int>>& reqs) {\\n         vector<bool> ans;\\n         parent.resize(n,0);\\n         rank.resize(n,0);\\n         for(int i=0; i<n; i++) parent[i]=i;\\n         for(auto req : reqs) {\\n              bool good = true;\\n              int friend1 = find(req[0]) , friend2 = find(req[1]);\\n              if(friend1 != friend2) {\\n                  for(int j=0; j<res.size(); j++) {\\n                       int blocked_user1 = find(res[j][0]) , blocked_user2 = find(res[j][1]);\\n                       // if parent of friends are same as the parent of blocked user then it is restricted\\n                       if((friend1==blocked_user1 && friend2==blocked_user2) || (friend1==blocked_user2 && friend2==blocked_user1)) {\\n                             good = false;\\n                             break;\\n                       }\\n                  }\\n              }\\n              if(good) union_(req[0],req[1]); // if the people\\'s request are restricted already , dont make them friends !\\n              ans.push_back(good);\\n         }\\n        return ans;\\n}\\n    int find(int a) {\\n        if(parent[a]==a) return a;\\n        else return parent[a]=find(parent[a]);\\n    }\\n    void union_(int a,int b) {\\n        if(a==b) return;\\n        a=find(a),b=find(b);\\n        // path compression\\n        if(rank[a]<rank[b]) {\\n             parent[a]=b;\\n        }else if(rank[b]<rank[a]) {\\n             parent[b]=a;\\n        }else {\\n             rank[a]++;\\n             parent[a]=b;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1987362,
                "title": "easy-understandable",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int>parent;\\n  \\n    int find(int node)\\n    {\\n        \\n        if(node==parent[node])\\n            return node;\\n        \\n        return parent[node]=find(parent[node]);\\n    }\\n    void Union(int u,int v)\\n    {\\n        int pu=find(u);\\n        int pv=find(v);\\n        parent[pu]=pv;\\n    }\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        \\n        int i;\\n        \\n        parent.resize(n);\\n        for(i=0;i<n;i++)\\n            parent[i]=i;\\n        \\n        vector<bool>ans(requests.size());\\n        \\n       for(i=0;i<requests.size();i++)\\n       {\\n           int u=requests[i][0];\\n           int v=requests[i][1];\\n           \\n           auto temp_copy = parent;\\n         \\n           ans[i]=true;\\n         \\n           Union(u,v);\\n         \\n           for(auto &it:restrictions)\\n           {\\n               int p=it[0];\\n               int q=it[1];\\n               \\n               if(find(p)==find(q))\\n*                {\\n                   ans[i]=false;\\n                   break;\\n                }\\n            }\\n           if(!ans[i])\\n               parent = temp_copy; \\n       }\\n        return ans; \\n    }\\n};``\\n```",
                "solutionTags": [
                    "C",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>parent;\\n  \\n    int find(int node)\\n    {\\n        \\n        if(node==parent[node])\\n            return node;\\n        \\n        return parent[node]=find(parent[node]);\\n    }\\n    void Union(int u,int v)\\n    {\\n        int pu=find(u);\\n        int pv=find(v);\\n        parent[pu]=pv;\\n    }\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        \\n        int i;\\n        \\n        parent.resize(n);\\n        for(i=0;i<n;i++)\\n            parent[i]=i;\\n        \\n        vector<bool>ans(requests.size());\\n        \\n       for(i=0;i<requests.size();i++)\\n       {\\n           int u=requests[i][0];\\n           int v=requests[i][1];\\n           \\n           auto temp_copy = parent;\\n         \\n           ans[i]=true;\\n         \\n           Union(u,v);\\n         \\n           for(auto &it:restrictions)\\n           {\\n               int p=it[0];\\n               int q=it[1];\\n               \\n               if(find(p)==find(q))\\n*                {\\n                   ans[i]=false;\\n                   break;\\n                }\\n            }\\n           if(!ans[i])\\n               parent = temp_copy; \\n       }\\n        return ans; \\n    }\\n};``\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1949905,
                "title": "easy-c-code-using-dsu",
                "content": "\\n\\n\\n```\\nclass Solution {\\n   vector<int>par,rank;\\n    int find(int u)\\n    {\\n        if(par[u] == u)\\n            return u;\\n        return par[u] = find(par[u]);\\n    }\\n    void union_(int u,int v)\\n    {\\n        int par_u = find(u);\\n        int par_v = find(v);\\n        int rank_u = rank[par_u];\\n        int rank_v = rank[par_v];\\n        if(rank_u < rank_v)\\n        {\\n            par[par_u] = par_v;\\n        }\\n        else if(rank_v < rank_u)\\n        {\\n            par[par_v] = par_u;\\n        }\\n        else\\n        {\\n            par[par_v] = par_u;\\n            rank[u]++;\\n        }\\n    }\\n    bool connect(int u,int v)\\n    {\\n        int par_u = find(u);\\n        int par_v = find(v);\\n        if(par_u == par_v)\\n            return true;\\n        \\n        return false;\\n    }\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        vector<int>graph[n];\\n        par.resize(n);\\n        for(int i=0;i<n;i++)\\n            par[i] = i;\\n        \\n        rank.resize(n,0);\\n        int m = requests.size();\\n        vector<bool>ans(m,false);\\n        for(int i=0;i<m;i++)\\n        {\\n            int uj = requests[i][0];\\n            int vj = requests[i][1];\\n            vector<int>temp_par = par;\\n            vector<int>temp_rank = rank;\\n            bool ok = true;\\n            union_(uj,vj);\\n            for(auto x: restrictions)\\n            {\\n                \\n                int u = x[0];\\n                int v = x[1];\\n               \\n                if(connect(u,v))\\n                {\\n                    ok = false;\\n                    break;\\n                }\\n            }\\n            if(ok)\\n            {\\n                ans[i] = true;\\n            }\\n            else if(ok == false)\\n            {\\n                par = temp_par;\\n                rank = temp_rank;\\n            }\\n        }\\n        return ans;\\n        \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n   vector<int>par,rank;\\n    int find(int u)\\n    {\\n        if(par[u] == u)\\n            return u;\\n        return par[u] = find(par[u]);\\n    }\\n    void union_(int u,int v)\\n    {\\n        int par_u = find(u);\\n        int par_v = find(v);\\n        int rank_u = rank[par_u];\\n        int rank_v = rank[par_v];\\n        if(rank_u < rank_v)\\n        {\\n            par[par_u] = par_v;\\n        }\\n        else if(rank_v < rank_u)\\n        {\\n            par[par_v] = par_u;\\n        }\\n        else\\n        {\\n            par[par_v] = par_u;\\n            rank[u]++;\\n        }\\n    }\\n    bool connect(int u,int v)\\n    {\\n        int par_u = find(u);\\n        int par_v = find(v);\\n        if(par_u == par_v)\\n            return true;\\n        \\n        return false;\\n    }\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        vector<int>graph[n];\\n        par.resize(n);\\n        for(int i=0;i<n;i++)\\n            par[i] = i;\\n        \\n        rank.resize(n,0);\\n        int m = requests.size();\\n        vector<bool>ans(m,false);\\n        for(int i=0;i<m;i++)\\n        {\\n            int uj = requests[i][0];\\n            int vj = requests[i][1];\\n            vector<int>temp_par = par;\\n            vector<int>temp_rank = rank;\\n            bool ok = true;\\n            union_(uj,vj);\\n            for(auto x: restrictions)\\n            {\\n                \\n                int u = x[0];\\n                int v = x[1];\\n               \\n                if(connect(u,v))\\n                {\\n                    ok = false;\\n                    break;\\n                }\\n            }\\n            if(ok)\\n            {\\n                ans[i] = true;\\n            }\\n            else if(ok == false)\\n            {\\n                par = temp_par;\\n                rank = temp_rank;\\n            }\\n        }\\n        return ans;\\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1946123,
                "title": "c-dsu",
                "content": "```\\nclass Solution {\\npublic:\\n     int parent[1000+10],size[1000+10];\\n    void make(int i)\\n    {\\n        parent[i]=i;\\n        size[i]=1;\\n    }\\n    \\n    int find(int i)\\n    {\\n        if(parent[i]==i)\\n            return i;\\n        return parent[i]=find(parent[i]);\\n    }\\n    \\n    void Union(int a,int b)\\n    {\\n        \\n        a=find(a);\\n        b=find(b);\\n        if(a!=b)\\n        {\\n           \\n            if(size[a]<size[b])\\n            {\\n                swap(a,b);\\n            }\\n            parent[b]=a;\\n            size[a]+=size[b];\\n        }\\n        return;\\n    }\\n    vector<bool> friendRequests(int n, vector<vector<int>>& res, vector<vector<int>>& requests) {\\n      \\n        for(int i=0;i<=n;i++)\\n        {\\n            make(i);\\n        }\\n       \\n        vector<bool>ans;\\n        for(auto i : requests)\\n        {\\n            int x=i[1];\\n            int y=i[0];\\n            int xx=find(x);\\n            int yy=find(y);\\n            if(xx!=yy){\\n            int c=0;\\n            for(auto f:res)\\n            {\\n                int a=f[0];\\n                int b=f[1];\\n                a=find(a);\\n                b=find(b);\\n                if((xx==a && yy==b) || (xx==b && yy==a))\\n                {\\n                    c++;\\n                    break;\\n                }\\n                \\n            }\\n            if(c>0)\\n            {\\n                ans.push_back(false);\\n                \\n            }\\n            else{\\n                Union(x,y);\\n                ans.push_back(true);\\n            }\\n            }\\n            else{\\n                ans.push_back(true);\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n     int parent[1000+10],size[1000+10];\\n    void make(int i)\\n    {\\n        parent[i]=i;\\n        size[i]=1;\\n    }\\n    \\n    int find(int i)\\n    {\\n        if(parent[i]==i)\\n            return i;\\n        return parent[i]=find(parent[i]);\\n    }\\n    \\n    void Union(int a,int b)\\n    {\\n        \\n        a=find(a);\\n        b=find(b);\\n        if(a!=b)\\n        {\\n           \\n            if(size[a]<size[b])\\n            {\\n                swap(a,b);\\n            }\\n            parent[b]=a;\\n            size[a]+=size[b];\\n        }\\n        return;\\n    }\\n    vector<bool> friendRequests(int n, vector<vector<int>>& res, vector<vector<int>>& requests) {\\n      \\n        for(int i=0;i<=n;i++)\\n        {\\n            make(i);\\n        }\\n       \\n        vector<bool>ans;\\n        for(auto i : requests)\\n        {\\n            int x=i[1];\\n            int y=i[0];\\n            int xx=find(x);\\n            int yy=find(y);\\n            if(xx!=yy){\\n            int c=0;\\n            for(auto f:res)\\n            {\\n                int a=f[0];\\n                int b=f[1];\\n                a=find(a);\\n                b=find(b);\\n                if((xx==a && yy==b) || (xx==b && yy==a))\\n                {\\n                    c++;\\n                    break;\\n                }\\n                \\n            }\\n            if(c>0)\\n            {\\n                ans.push_back(false);\\n                \\n            }\\n            else{\\n                Union(x,y);\\n                ans.push_back(true);\\n            }\\n            }\\n            else{\\n                ans.push_back(true);\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1930051,
                "title": "simple-solution-in-java-elegant-and-concise-using-union-find",
                "content": "```\\nclass Solution {\\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        // Check for each request whether it can cause conflict or not\\n        UnionFind uf = new UnionFind(n);\\n        \\n        boolean[] res = new boolean[requests.length];\\n        for(int i=0; i<requests.length; i++){\\n            int p1 = uf.findParent(requests[i][0]);\\n            int p2 = uf.findParent(requests[i][1]);\\n            \\n            if(p1 == p2){ res[i] = true; continue; }\\n            \\n            // Check whether the current request will violate any restriction or not\\n            boolean flag = true;\\n            for(int[] restrict : restrictions){\\n                int r1 = uf.findParent(restrict[0]);\\n                int r2 = uf.findParent(restrict[1]);\\n                \\n                if((r1 == p1 && r2 == p2) || (r1 == p2 && r2 == p1)){\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            \\n            if(flag){\\n                res[i] = true;\\n                uf.parent[p1] = p2; // Union\\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n    private class UnionFind{\\n        public int n;\\n        public int[] parent;\\n        \\n        public UnionFind(int n){\\n            this.n = n;\\n            this.parent = new int[n];\\n            for(int i=0; i<n; i++){\\n                parent[i] = i;\\n            }\\n        }\\n        \\n        public int findParent(int user){\\n            while(parent[user] != user){\\n                parent[user] = parent[parent[user]];\\n                user = parent[user];\\n            }\\n            \\n            return user;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        // Check for each request whether it can cause conflict or not\\n        UnionFind uf = new UnionFind(n);\\n        \\n        boolean[] res = new boolean[requests.length];\\n        for(int i=0; i<requests.length; i++){\\n            int p1 = uf.findParent(requests[i][0]);\\n            int p2 = uf.findParent(requests[i][1]);\\n            \\n            if(p1 == p2){ res[i] = true; continue; }\\n            \\n            // Check whether the current request will violate any restriction or not\\n            boolean flag = true;\\n            for(int[] restrict : restrictions){\\n                int r1 = uf.findParent(restrict[0]);\\n                int r2 = uf.findParent(restrict[1]);\\n                \\n                if((r1 == p1 && r2 == p2) || (r1 == p2 && r2 == p1)){\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            \\n            if(flag){\\n                res[i] = true;\\n                uf.parent[p1] = p2; // Union\\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n    private class UnionFind{\\n        public int n;\\n        public int[] parent;\\n        \\n        public UnionFind(int n){\\n            this.n = n;\\n            this.parent = new int[n];\\n            for(int i=0; i<n; i++){\\n                parent[i] = i;\\n            }\\n        }\\n        \\n        public int findParent(int user){\\n            while(parent[user] != user){\\n                parent[user] = parent[parent[user]];\\n                user = parent[user];\\n            }\\n            \\n            return user;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1925760,
                "title": "c-union-find-time-o-restrictions-requests-space-o-n-restrictions",
                "content": "\\n```\\nclass Solution \\n{  \\n    int FindGroup(const int& person, const vector<int>& parent)\\n    {\\n        if(parent[person] == person)\\n        {\\n            return person;\\n        }\\n        return FindGroup(parent[person], parent);\\n    }\\n    \\n    void TransferEnemies(const int& from, const int& to, vector<unordered_set<int>>& enemies)\\n    {\\n        for(const int& enemy : enemies[from])\\n        {\\n            enemies[to].insert(enemy);\\n            enemies[enemy].erase(from);\\n            enemies[enemy].insert(to);\\n        }\\n        enemies[from].clear();\\n    }\\n    \\n    bool ProcessFriendRequest(const int& p1, const int& p2, vector<int>& parent, vector<int>& size, vector<unordered_set<int>>& enemies)\\n    {\\n        int root1 = FindGroup(p1, parent);\\n        int root2 = FindGroup(p2, parent);\\n        if(root1 == root2)\\n            return true;\\n        \\n        if(enemies[root1].find(root2) != enemies[root1].end())\\n        {\\n            //assert(enemies[root2].find(root1) != enemies[root2].end());\\n            return false;\\n        }\\n        \\n        if(size[root1] > size[root2])\\n        {\\n            TransferEnemies(root2, root1, enemies);\\n            parent[root2] = root1;\\n            size[root1] += size[root2];\\n        }\\n        else\\n        {\\n            TransferEnemies(root1, root2, enemies);\\n            parent[root1] = root2;\\n            size[root2] += size[root1];\\n        }\\n        return true;\\n    }\\n\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) \\n    {\\n        vector<unordered_set<int>> enemies(n);\\n        vector<int> parent(n);\\n        vector<int> size(n, 1);\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            parent[i] = i;\\n        }\\n        \\n        for(auto& r : restrictions)\\n        {\\n            enemies[r[0]].insert(r[1]);\\n            enemies[r[1]].insert(r[0]);\\n        }\\n        \\n        vector<bool> result(requests.size());\\n        int i = 0;\\n        for(auto& f : requests)\\n        {\\n            result[i] = ProcessFriendRequest(f[0], f[1], parent, size, enemies);\\n            i++;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{  \\n    int FindGroup(const int& person, const vector<int>& parent)\\n    {\\n        if(parent[person] == person)\\n        {\\n            return person;\\n        }\\n        return FindGroup(parent[person], parent);\\n    }\\n    \\n    void TransferEnemies(const int& from, const int& to, vector<unordered_set<int>>& enemies)\\n    {\\n        for(const int& enemy : enemies[from])\\n        {\\n            enemies[to].insert(enemy);\\n            enemies[enemy].erase(from);\\n            enemies[enemy].insert(to);\\n        }\\n        enemies[from].clear();\\n    }\\n    \\n    bool ProcessFriendRequest(const int& p1, const int& p2, vector<int>& parent, vector<int>& size, vector<unordered_set<int>>& enemies)\\n    {\\n        int root1 = FindGroup(p1, parent);\\n        int root2 = FindGroup(p2, parent);\\n        if(root1 == root2)\\n            return true;\\n        \\n        if(enemies[root1].find(root2) != enemies[root1].end())\\n        {\\n            //assert(enemies[root2].find(root1) != enemies[root2].end());\\n            return false;\\n        }\\n        \\n        if(size[root1] > size[root2])\\n        {\\n            TransferEnemies(root2, root1, enemies);\\n            parent[root2] = root1;\\n            size[root1] += size[root2];\\n        }\\n        else\\n        {\\n            TransferEnemies(root1, root2, enemies);\\n            parent[root1] = root2;\\n            size[root2] += size[root1];\\n        }\\n        return true;\\n    }\\n\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) \\n    {\\n        vector<unordered_set<int>> enemies(n);\\n        vector<int> parent(n);\\n        vector<int> size(n, 1);\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            parent[i] = i;\\n        }\\n        \\n        for(auto& r : restrictions)\\n        {\\n            enemies[r[0]].insert(r[1]);\\n            enemies[r[1]].insert(r[0]);\\n        }\\n        \\n        vector<bool> result(requests.size());\\n        int i = 0;\\n        for(auto& f : requests)\\n        {\\n            result[i] = ProcessFriendRequest(f[0], f[1], parent, size, enemies);\\n            i++;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1922419,
                "title": "c-simple-solution",
                "content": "```\\npublic class Solution \\n{\\n    public bool[] FriendRequests(int n, int[][] restrictions, int[][] requests) \\n    {\\n        List<bool> result = new();\\n        UF uf = new UF(n);\\n        \\n        foreach(var req in requests)\\n        {\\n            int parX = uf.Find(req[0]);\\n            int parY = uf.Find(req[1]);\\n            \\n            bool isRestricted = false;\\n            \\n            foreach(var rest in restrictions)\\n            {\\n                int rX = uf.Find(rest[0]);\\n                int rY = uf.Find(rest[1]);\\n                \\n                if((parX == rX && parY == rY) || (parX==rY && parY == rX))\\n                {\\n                    isRestricted = true;\\n                    break;\\n                }\\n            }\\n            \\n            result.Add(!isRestricted);\\n            \\n            if(!isRestricted)\\n                uf.Union(parX,parY);\\n        }\\n        \\n        return result.ToArray();\\n    }\\n}\\n\\nclass UF\\n{\\n    private int[] rank;\\n    public int[] parent;\\n    \\n    public UF(int n)\\n    {\\n        rank = new int[n];\\n        parent = new int[n];\\n        \\n        for(int i=0;i<n;i++)\\n            parent[i]=i;\\n    }\\n    \\n    public void Union(int x, int y)\\n    {\\n        int px = Find(x);\\n        int py = Find(y);\\n        \\n        if(px==py)\\n            return;\\n        \\n        if(rank[px] < rank[py])\\n        {\\n            parent[px] = py;\\n        }\\n        else if(rank[py] < rank[px])\\n        {\\n            parent[py] = px;\\n        }\\n        else\\n        {\\n            parent[px] = py;\\n            rank[py]++;\\n        }\\n    }\\n    \\n    public int Find(int x)\\n    {\\n        if(parent[x]==x)\\n            return x;\\n        \\n        return Find(parent[x]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution \\n{\\n    public bool[] FriendRequests(int n, int[][] restrictions, int[][] requests) \\n    {\\n        List<bool> result = new();\\n        UF uf = new UF(n);\\n        \\n        foreach(var req in requests)\\n        {\\n            int parX = uf.Find(req[0]);\\n            int parY = uf.Find(req[1]);\\n            \\n            bool isRestricted = false;\\n            \\n            foreach(var rest in restrictions)\\n            {\\n                int rX = uf.Find(rest[0]);\\n                int rY = uf.Find(rest[1]);\\n                \\n                if((parX == rX && parY == rY) || (parX==rY && parY == rX))\\n                {\\n                    isRestricted = true;\\n                    break;\\n                }\\n            }\\n            \\n            result.Add(!isRestricted);\\n            \\n            if(!isRestricted)\\n                uf.Union(parX,parY);\\n        }\\n        \\n        return result.ToArray();\\n    }\\n}\\n\\nclass UF\\n{\\n    private int[] rank;\\n    public int[] parent;\\n    \\n    public UF(int n)\\n    {\\n        rank = new int[n];\\n        parent = new int[n];\\n        \\n        for(int i=0;i<n;i++)\\n            parent[i]=i;\\n    }\\n    \\n    public void Union(int x, int y)\\n    {\\n        int px = Find(x);\\n        int py = Find(y);\\n        \\n        if(px==py)\\n            return;\\n        \\n        if(rank[px] < rank[py])\\n        {\\n            parent[px] = py;\\n        }\\n        else if(rank[py] < rank[px])\\n        {\\n            parent[py] = px;\\n        }\\n        else\\n        {\\n            parent[px] = py;\\n            rank[py]++;\\n        }\\n    }\\n    \\n    public int Find(int x)\\n    {\\n        if(parent[x]==x)\\n            return x;\\n        \\n        return Find(parent[x]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1911931,
                "title": "java",
                "content": "```\\nclass Solution {\\n    \\n    static Set<Integer> EMPTY = Collections.emptySet();\\n    /**            Union Find             **/\\n    class Node {\\n        int parent;\\n    }\\n    \\n    int parent(Node[] nodes, int idx) {\\n        if(nodes[idx].parent != idx) {\\n            nodes[idx].parent = parent(nodes, nodes[idx].parent);\\n        }\\n        return nodes[idx].parent;\\n    }\\n    \\n    void merge(Node[] nodes, int u, int v) {\\n        int uRoot = parent(nodes, u), vRoot = parent(nodes, v);\\n        nodes[uRoot].parent = vRoot;\\n    }\\n    \\n    boolean tryMerge(Map<Integer, Set<Integer>> blacklist, Node[] nodes, int u, int v) {\\n        int uRoot = parent(nodes, u), vRoot = parent(nodes, v);\\n        if(uRoot == vRoot) return true;\\n        if(blacklist.getOrDefault(uRoot, EMPTY).contains(vRoot) || \\n          blacklist.getOrDefault(vRoot, EMPTY).contains(uRoot)) return false;\\n        // merge u and v node, new root is vRoot based on above algo\\n        if(!blacklist.containsKey(vRoot)) blacklist.put(vRoot, new HashSet<>());\\n        for(Integer b: blacklist.getOrDefault(uRoot, EMPTY)) {\\n            blacklist.get(vRoot).add(parent(nodes, b));\\n        }\\n        merge(nodes, u, v);\\n        return true;\\n    }\\n    \\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        int rLen = requests.length;\\n        boolean[] res = new boolean[rLen];\\n        Node[] nodes = new Node[n];\\n        Map<Integer, Set<Integer>> blacklist = new HashMap<>();\\n        for(int i = 0; i < n; i++) {\\n            nodes[i] = new Node();\\n            nodes[i].parent = i;\\n        }\\n        for(int[] restrict: restrictions) {\\n            int u = restrict[0], v = restrict[1];\\n            if(!blacklist.containsKey(u)) blacklist.put(u, new HashSet<>());\\n            if(!blacklist.containsKey(v)) blacklist.put(v, new HashSet<>());\\n            blacklist.get(u).add(v); blacklist.get(v).add(u);\\n        }\\n        for(int i = 0; i < rLen; i++) {\\n            res[i] = tryMerge(blacklist, nodes, requests[i][0], requests[i][1]);\\n        }\\n        return res;\\n    }\\n}\\n\\n// 0: 1\\n// 1: 0, 2\\n// 2: 1, 3\\n// 3: 2\\n// 4: 1\\n\\n// 4 <- 0, 1 <- 3,  \\n// true, false, true, false",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n    static Set<Integer> EMPTY = Collections.emptySet();\\n    /**            Union Find             **/\\n    class Node {\\n        int parent;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1885620,
                "title": "java-simple-union-find",
                "content": "```\\nclass Solution {\\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        boolean[] res = new boolean[requests.length];\\n        UnionFind uf = new UnionFind(n);\\n        int index = 0;\\n        for(int[] r: requests){\\n            int a = uf.find(r[0]);\\n            int b = uf.find(r[1]);\\n            \\n            boolean canConnect = true;\\n            for(int[] restriction: restrictions){\\n                int ra = uf.find(restriction[0]);\\n                int rb = uf.find(restriction[1]);\\n                if(a == ra && b == rb || a == rb && b == ra){\\n                    canConnect = false;\\n                    break;\\n                }\\n            }\\n            res[index++] = canConnect;\\n            if(canConnect){\\n                uf.connect(a, b);\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    class UnionFind{\\n        int[] parent;\\n        public UnionFind(int n){\\n            parent = new int[n];\\n            for(int i = 0; i < n; i++){\\n                parent[i] = i;\\n            }\\n        } \\n        public void connect(int xp, int yp){\\n            parent[xp] = yp;\\n        }        \\n        public int find(int x){\\n            while(x != parent[x]){\\n                parent[x] = parent[parent[x]];\\n                x = parent[x];\\n            }\\n            return x;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        boolean[] res = new boolean[requests.length];\\n        UnionFind uf = new UnionFind(n);\\n        int index = 0;\\n        for(int[] r: requests){\\n            int a = uf.find(r[0]);\\n            int b = uf.find(r[1]);\\n            \\n            boolean canConnect = true;\\n            for(int[] restriction: restrictions){\\n                int ra = uf.find(restriction[0]);\\n                int rb = uf.find(restriction[1]);\\n                if(a == ra && b == rb || a == rb && b == ra){\\n                    canConnect = false;\\n                    break;\\n                }\\n            }\\n            res[index++] = canConnect;\\n            if(canConnect){\\n                uf.connect(a, b);\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    class UnionFind{\\n        int[] parent;\\n        public UnionFind(int n){\\n            parent = new int[n];\\n            for(int i = 0; i < n; i++){\\n                parent[i] = i;\\n            }\\n        } \\n        public void connect(int xp, int yp){\\n            parent[xp] = yp;\\n        }        \\n        public int find(int x){\\n            while(x != parent[x]){\\n                parent[x] = parent[parent[x]];\\n                x = parent[x];\\n            }\\n            return x;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1877365,
                "title": "java-quick-find-of-union-find",
                "content": "```\\nclass Solution {\\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        \\n        Map<Integer,Set<Integer>> cant = new HashMap<>();//map of restrictions\\n        int[] union = new int[n];\\n        for(int i=0; i<n; i++){\\n            union[i]=i;\\n            cant.put(i,new HashSet<>());\\n        }\\n        for(int[] res: restrictions){\\n            cant.get(res[0]).add(res[1]);\\n            cant.get(res[1]).add(res[0]);\\n        }\\n    \\n        boolean[] result = new boolean[requests.length];\\n        top:\\n        for(int i=0; i<requests.length; i++){\\n            int x = union[requests[i][0]], y = union[requests[i][1]];\\n\\t\\t\\t//check if this union would cause som direct or indirection restricted connections\\n            Set<Integer> common = new HashSet<>();\\n            for(int j=0; j<n; j++){\\n                if(union[j] == x || union[j] == y){\\n                    if(common.contains(j))continue top;//ignore request if indirectly restricted\\n                    if(!cant.get(j).isEmpty())common.addAll(cant.get(j));\\n                }\\n            }\\n            //union current request\\n            for(int j=0; j<n; j++)\\n                if(union[j] == x || union[j] == y)union[j]=x;\\n            result[i] = true;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        \\n        Map<Integer,Set<Integer>> cant = new HashMap<>();//map of restrictions\\n        int[] union = new int[n];\\n        for(int i=0; i<n; i++){\\n            union[i]=i;\\n            cant.put(i,new HashSet<>());\\n        }\\n        for(int[] res: restrictions){\\n            cant.get(res[0]).add(res[1]);\\n            cant.get(res[1]).add(res[0]);\\n        }\\n    \\n        boolean[] result = new boolean[requests.length];\\n        top:\\n        for(int i=0; i<requests.length; i++){\\n            int x = union[requests[i][0]], y = union[requests[i][1]];\\n\\t\\t\\t//check if this union would cause som direct or indirection restricted connections\\n            Set<Integer> common = new HashSet<>();\\n            for(int j=0; j<n; j++){\\n                if(union[j] == x || union[j] == y){\\n                    if(common.contains(j))continue top;//ignore request if indirectly restricted\\n                    if(!cant.get(j).isEmpty())common.addAll(cant.get(j));\\n                }\\n            }\\n            //union current request\\n            for(int j=0; j<n; j++)\\n                if(union[j] == x || union[j] == y)union[j]=x;\\n            result[i] = true;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1870677,
                "title": "c-solution-union-find",
                "content": "```\\nclass Solution {\\npublic:\\n    class DSU{\\n    private:\\n        vector<int> parent, size, rank;\\n    \\n    public:\\n        DSU(int n)\\n        {\\n            for(int i=0; i<n; i++)\\n            {\\n                parent.push_back(i);\\n                size.push_back(1);                \\n                rank.push_back(1);                \\n            }\\n        }\\n    public:\\n        int findParent(int node)\\n        {\\n            if(node == parent[node]) return node;\\n            return findParent(parent[node]);\\n        }\\n    public:\\n        void Union_by_size(int u, int v)\\n        {\\n            int parent_of_u = findParent(u);\\n            int parent_of_v = findParent(v);\\n\\n            if(parent_of_u == parent_of_v)\\n            {\\n                return;\\n            }\\n\\n            if(size[parent_of_u] < size[parent_of_v])\\n            {\\n                parent[parent_of_u] = parent_of_v;\\n                size[parent_of_v] += size[parent_of_u];\\n                \\n            }\\n            else\\n            {\\n                parent[parent_of_v] = parent_of_u;\\n                size[parent_of_u] += size[parent_of_v];\\n            }\\n        }\\n    public:\\n        void Union_by_rank(int u, int v)\\n        {\\n            int parent_of_u = findParent(u);\\n            int parent_of_v = findParent(v);\\n\\n            if(parent_of_u == parent_of_v)\\n            {\\n                return;\\n            }\\n            if(rank[parent_of_u]==rank[parent_of_v])\\n            {\\n                parent[parent_of_u] = parent_of_v;\\n                rank[parent_of_v]++;\\n            }\\n            else if(rank[parent_of_u] < rank[parent_of_v])\\n            {\\n                parent[parent_of_u] = parent_of_v;\\n            }\\n            else{\\n                parent[parent_of_v] = parent_of_u;\\n            }\\n        }\\n    public:\\n        bool is_connected(int u, int v)\\n        {\\n            return findParent(u)==findParent(v);\\n        }\\n};\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        DSU fr(n);\\n        vector<bool> ans;\\n        for(auto &i : requests)\\n        {\\n            int u = i[0];\\n            int v = i[1];\\n            bool aa = true;\\n            for(auto &j : restrictions)\\n            {\\n                if(fr.is_connected(u,j[0]) && fr.is_connected(v,j[1]))\\n                {\\n                    aa = false;\\n                    break;\\n                }\\n                else if(fr.is_connected(u,j[1]) && fr.is_connected(v,j[0]))\\n                {\\n                    aa = false;\\n                    break;\\n                }\\n            }\\n            \\n            ans.push_back(aa);\\n            if(aa==true)\\n            {\\n                fr.Union_by_size(u,v);\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    class DSU{\\n    private:\\n        vector<int> parent, size, rank;\\n    \\n    public:\\n        DSU(int n)\\n        {\\n            for(int i=0; i<n; i++)\\n            {\\n                parent.push_back(i);\\n                size.push_back(1);                \\n                rank.push_back(1);                \\n            }\\n        }\\n    public:\\n        int findParent(int node)\\n        {\\n            if(node == parent[node]) return node;\\n            return findParent(parent[node]);\\n        }\\n    public:\\n        void Union_by_size(int u, int v)\\n        {\\n            int parent_of_u = findParent(u);\\n            int parent_of_v = findParent(v);\\n\\n            if(parent_of_u == parent_of_v)\\n            {\\n                return;\\n            }\\n\\n            if(size[parent_of_u] < size[parent_of_v])\\n            {\\n                parent[parent_of_u] = parent_of_v;\\n                size[parent_of_v] += size[parent_of_u];\\n                \\n            }\\n            else\\n            {\\n                parent[parent_of_v] = parent_of_u;\\n                size[parent_of_u] += size[parent_of_v];\\n            }\\n        }\\n    public:\\n        void Union_by_rank(int u, int v)\\n        {\\n            int parent_of_u = findParent(u);\\n            int parent_of_v = findParent(v);\\n\\n            if(parent_of_u == parent_of_v)\\n            {\\n                return;\\n            }\\n            if(rank[parent_of_u]==rank[parent_of_v])\\n            {\\n                parent[parent_of_u] = parent_of_v;\\n                rank[parent_of_v]++;\\n            }\\n            else if(rank[parent_of_u] < rank[parent_of_v])\\n            {\\n                parent[parent_of_u] = parent_of_v;\\n            }\\n            else{\\n                parent[parent_of_v] = parent_of_u;\\n            }\\n        }\\n    public:\\n        bool is_connected(int u, int v)\\n        {\\n            return findParent(u)==findParent(v);\\n        }\\n};\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        DSU fr(n);\\n        vector<bool> ans;\\n        for(auto &i : requests)\\n        {\\n            int u = i[0];\\n            int v = i[1];\\n            bool aa = true;\\n            for(auto &j : restrictions)\\n            {\\n                if(fr.is_connected(u,j[0]) && fr.is_connected(v,j[1]))\\n                {\\n                    aa = false;\\n                    break;\\n                }\\n                else if(fr.is_connected(u,j[1]) && fr.is_connected(v,j[0]))\\n                {\\n                    aa = false;\\n                    break;\\n                }\\n            }\\n            \\n            ans.push_back(aa);\\n            if(aa==true)\\n            {\\n                fr.Union_by_size(u,v);\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1864662,
                "title": "python-union-find",
                "content": "```\\nclass UnionFind:\\n    def __init__(self,n,restrictions):\\n        self.arr=[i for i in range(n)]\\n        self.restrictions=restrictions\\n    def union (self,a,b):\\n        node1=self.find(a)\\n        node2=self.find(b)\\n        for item in self.restrictions:\\n            x=self.find(item[0])\\n            y=self.find(item[1])\\n            if x==node1 and  y==node2 :\\n                return 0\\n            if y==node1 and  x==node2 :\\n                return 0\\n        self.arr[node1]=self.arr[node2]\\n        return 1\\n    def find(self,a):\\n        temp=a\\n        while(a!=self.arr[a]):\\n            a=self.arr[a]\\n        while(temp!=a):\\n            b=self.arr[temp]\\n            self.arr[temp]=a\\n            temp=b\\n        return a\\nclass Solution(object):\\n    def friendRequests(self, n, restrictions, requests):\\n        uf=UnionFind(n,restrictions)\\n        ans=[]\\n        for item in requests:\\n            ans.append(uf.union(item[0],item[1]))\\n        return ans\\n",
                "solutionTags": [
                    "Python",
                    "Union Find"
                ],
                "code": "```\\nclass UnionFind:\\n    def __init__(self,n,restrictions):\\n        self.arr=[i for i in range(n)]\\n        self.restrictions=restrictions\\n    def union (self,a,b):\\n        node1=self.find(a)\\n        node2=self.find(b)\\n        for item in self.restrictions:\\n            x=self.find(item[0])\\n            y=self.find(item[1])\\n            if x==node1 and  y==node2 :\\n                return 0\\n            if y==node1 and  x==node2 :\\n                return 0\\n        self.arr[node1]=self.arr[node2]\\n        return 1\\n    def find(self,a):\\n        temp=a\\n        while(a!=self.arr[a]):\\n            a=self.arr[a]\\n        while(temp!=a):\\n            b=self.arr[temp]\\n            self.arr[temp]=a\\n            temp=b\\n        return a\\nclass Solution(object):\\n    def friendRequests(self, n, restrictions, requests):\\n        uf=UnionFind(n,restrictions)\\n        ans=[]\\n        for item in requests:\\n            ans.append(uf.union(item[0],item[1]))\\n        return ans\\n",
                "codeTag": "Java"
            },
            {
                "id": 1860277,
                "title": "c-union-find",
                "content": "```\\nclass dsu {\\npublic:\\n\\tvector<int> parent;\\n\\tunordered_map<int, int> size;\\n\\tdsu(int n) {\\n\\t\\tparent.resize(n);\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tparent[i] = i;\\n\\t\\t\\tsize[i]++;\\n\\t\\t}\\n\\t}\\n\\n\\n\\tint findParent(int u) {\\n\\t\\tif (parent[u] == u) return u;\\n\\t\\treturn parent[u] = findParent(parent[u]);\\n\\t}\\n\\n\\tvoid _union(int u, int v) {\\n\\t\\tu = findParent(u);\\n\\t\\tv = findParent(v);\\n\\t\\tif (u != v) {\\n\\t\\t\\tif (size[u] < size[v]) swap(u, v);\\n\\t\\t\\tparent[v] = u;\\n\\t\\t\\tsize[u] += size[v];\\n\\t\\t}\\n\\t}\\n\\n\\tbool areConnected(int u, int v) {\\n\\t\\treturn findParent(u) == findParent(v);\\n\\t}\\n};\\n\\n\\nclass Solution {\\npublic:\\n\\tvector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n\\n\\t\\tvector<bool> ans;\\n\\t\\tdsu uf(n);\\n\\n\\t\\tfor (auto &request : requests)  {\\n\\t\\t\\tint ui = request[0]; int vi = request[1];\\n\\t\\t\\tbool curAns = true;\\n\\t\\t\\tfor (auto &restriction : restrictions) {\\n\\t\\t\\t\\t\\n\\n\\t\\t\\t\\tif (uf.areConnected(ui, restriction[0]) && uf.areConnected(vi, restriction[1])) {\\n\\t\\t\\t\\t\\tcurAns = false;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\telse if (uf.areConnected(ui, restriction[1]) && uf.areConnected(vi, restriction[0])) {\\n\\t\\t\\t\\t\\tcurAns = false;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tans.push_back(curAns);\\n\\t\\t\\tif (curAns) {\\n\\t\\t\\t\\tuf._union(ui, vi);\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass dsu {\\npublic:\\n\\tvector<int> parent;\\n\\tunordered_map<int, int> size;\\n\\tdsu(int n) {\\n\\t\\tparent.resize(n);\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tparent[i] = i;\\n\\t\\t\\tsize[i]++;\\n\\t\\t}\\n\\t}\\n\\n\\n\\tint findParent(int u) {\\n\\t\\tif (parent[u] == u) return u;\\n\\t\\treturn parent[u] = findParent(parent[u]);\\n\\t}\\n\\n\\tvoid _union(int u, int v) {\\n\\t\\tu = findParent(u);\\n\\t\\tv = findParent(v);\\n\\t\\tif (u != v) {\\n\\t\\t\\tif (size[u] < size[v]) swap(u, v);\\n\\t\\t\\tparent[v] = u;\\n\\t\\t\\tsize[u] += size[v];\\n\\t\\t}\\n\\t}\\n\\n\\tbool areConnected(int u, int v) {\\n\\t\\treturn findParent(u) == findParent(v);\\n\\t}\\n};\\n\\n\\nclass Solution {\\npublic:\\n\\tvector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n\\n\\t\\tvector<bool> ans;\\n\\t\\tdsu uf(n);\\n\\n\\t\\tfor (auto &request : requests)  {\\n\\t\\t\\tint ui = request[0]; int vi = request[1];\\n\\t\\t\\tbool curAns = true;\\n\\t\\t\\tfor (auto &restriction : restrictions) {\\n\\t\\t\\t\\t\\n\\n\\t\\t\\t\\tif (uf.areConnected(ui, restriction[0]) && uf.areConnected(vi, restriction[1])) {\\n\\t\\t\\t\\t\\tcurAns = false;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\telse if (uf.areConnected(ui, restriction[1]) && uf.areConnected(vi, restriction[0])) {\\n\\t\\t\\t\\t\\tcurAns = false;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tans.push_back(curAns);\\n\\t\\t\\tif (curAns) {\\n\\t\\t\\t\\tuf._union(ui, vi);\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1857058,
                "title": "java-union-find-with-looping-through-restrictions",
                "content": "\\n\\n```\\n\\n\\nclass Solution {\\n    // union find, \\n    // if 2 are directly in restriction, we cannot union them\\n    // then we check if after union these 2, 2 restricted would be unioned\\n    // do we need to check all restrictions for each union?\\n    \\n    int[] parents;\\n    int[] sizes;\\n    int[][] restrictions;\\n    \\n    // find with path compression\\n    private int find(int x) {\\n        while(parents[x] != x) {\\n            parents[x] = parents[parents[x]];\\n            x = parents[x];\\n        }\\n        \\n        return x;\\n    }\\n    \\n    // union with tree balance by size and restrictions\\n    private boolean union(int x, int y) {\\n        int parentX = find(x);\\n        int parentY = find(y);\\n        \\n        if(parentX == parentY) return true;\\n        \\n        for(int[] restrict: restrictions) {\\n            int r1 = restrict[0];\\n            int r2 = restrict[1];\\n            int parentR1 = find(r1);\\n            int parentR2 = find(r2);\\n            if(parentR1 == parentX && parentR2 == parentY) return false;    \\n            if(parentR2 == parentX && parentR1 == parentY) return false;\\n        }\\n        \\n        if(sizes[parentX] < sizes[parentY]) {\\n            parents[parentX] = parentY;\\n            sizes[parentY] += sizes[parentX];\\n        } else {\\n            parents[parentY] = parentX;\\n            sizes[parentX] += parentY;\\n        }\\n        \\n        return true;\\n    }\\n\\n    \\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        boolean[] res = new boolean[requests.length];\\n        parents = new int[n];\\n        for(int i = 0; i < n; i++) {\\n            parents[i] = i;\\n        }\\n        sizes = new int[n];\\n        Arrays.fill(sizes, 1);\\n        this.restrictions = restrictions;\\n        \\n\\n        for(int i = 0; i < requests.length; i++) {\\n            int[] cur = requests[i];\\n            res[i] = union(cur[0], cur[1]);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\n\\nclass Solution {\\n    // union find, \\n    // if 2 are directly in restriction, we cannot union them\\n    // then we check if after union these 2, 2 restricted would be unioned\\n    // do we need to check all restrictions for each union?\\n    \\n    int[] parents;\\n    int[] sizes;\\n    int[][] restrictions;\\n    \\n    // find with path compression\\n    private int find(int x) {\\n        while(parents[x] != x) {\\n            parents[x] = parents[parents[x]];\\n            x = parents[x];\\n        }\\n        \\n        return x;\\n    }\\n    \\n    // union with tree balance by size and restrictions\\n    private boolean union(int x, int y) {\\n        int parentX = find(x);\\n        int parentY = find(y);\\n        \\n        if(parentX == parentY) return true;\\n        \\n        for(int[] restrict: restrictions) {\\n            int r1 = restrict[0];\\n            int r2 = restrict[1];\\n            int parentR1 = find(r1);\\n            int parentR2 = find(r2);\\n            if(parentR1 == parentX && parentR2 == parentY) return false;    \\n            if(parentR2 == parentX && parentR1 == parentY) return false;\\n        }\\n        \\n        if(sizes[parentX] < sizes[parentY]) {\\n            parents[parentX] = parentY;\\n            sizes[parentY] += sizes[parentX];\\n        } else {\\n            parents[parentY] = parentX;\\n            sizes[parentX] += parentY;\\n        }\\n        \\n        return true;\\n    }\\n\\n    \\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        boolean[] res = new boolean[requests.length];\\n        parents = new int[n];\\n        for(int i = 0; i < n; i++) {\\n            parents[i] = i;\\n        }\\n        sizes = new int[n];\\n        Arrays.fill(sizes, 1);\\n        this.restrictions = restrictions;\\n        \\n\\n        for(int i = 0; i < requests.length; i++) {\\n            int[] cur = requests[i];\\n            res[i] = union(cur[0], cur[1]);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1815506,
                "title": "python3-union-find-with-nodes-set",
                "content": "```\\nclass UF:\\n    def __init__(self,n,withSize = False):\\n        self.p = [i for i in range(n)]\\n        self.withSize = withSize\\n        if withSize:\\n            self.size = [set([i]) for i in range(n)]\\n        else:\\n            self.size = []\\n    def find(self,x):\\n        if x!=self.p[x]:\\n            self.p[x] = self.find(self.p[x])\\n        return self.p[x]\\n    def union(self,x,y):\\n        p1,p2 = self.find(x), self.find(y)\\n        if p1 != p2 :\\n            self.p[p2] = p1\\n            if self.withSize:\\n                self.size[p1] = self.size[p1].union(self.size[p2])\\n        \\nclass Solution:\\n    def friendRequests(self, n: int, rest: List[List[int]], requests: List[List[int]]) -> List[bool]:\\n        eq = UF(n,True)\\n        iq = set()\\n        ans = []\\n        for u,v in requests:\\n            p1,p2 = eq.find(u), eq.find(v)\\n            nodes1 = eq.size[p1]\\n            nodes2 = eq.size[p2]\\n            for x,y in rest:\\n                if (x in nodes1 and y in nodes2) or (x in nodes2 and y in nodes1):\\n                    ans.append(False)\\n                    break\\n            else:\\n                ans.append(True)\\n                eq.union(u,v)\\n        return ans\\n            \\n```",
                "solutionTags": [
                    "Union Find"
                ],
                "code": "```\\nclass UF:\\n    def __init__(self,n,withSize = False):\\n        self.p = [i for i in range(n)]\\n        self.withSize = withSize\\n        if withSize:\\n            self.size = [set([i]) for i in range(n)]\\n        else:\\n            self.size = []\\n    def find(self,x):\\n        if x!=self.p[x]:\\n            self.p[x] = self.find(self.p[x])\\n        return self.p[x]\\n    def union(self,x,y):\\n        p1,p2 = self.find(x), self.find(y)\\n        if p1 != p2 :\\n            self.p[p2] = p1\\n            if self.withSize:\\n                self.size[p1] = self.size[p1].union(self.size[p2])\\n        \\nclass Solution:\\n    def friendRequests(self, n: int, rest: List[List[int]], requests: List[List[int]]) -> List[bool]:\\n        eq = UF(n,True)\\n        iq = set()\\n        ans = []\\n        for u,v in requests:\\n            p1,p2 = eq.find(u), eq.find(v)\\n            nodes1 = eq.size[p1]\\n            nodes2 = eq.size[p2]\\n            for x,y in rest:\\n                if (x in nodes1 and y in nodes2) or (x in nodes2 and y in nodes1):\\n                    ans.append(False)\\n                    break\\n            else:\\n                ans.append(True)\\n                eq.union(u,v)\\n        return ans\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1809912,
                "title": "c-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n    int find(vector<int>& root,int i){\\n        if(root[i] == i){\\n            return i;\\n        }\\n        return root[i]=find(root,root[i]);\\n    }\\n    void Union(vector<int>& root,vector<int>& rank,int p1,int p2){\\n        int root1=find(root,p1);\\n        int root2=find(root,p2);\\n        if(root1 != root2){\\n            if(rank[root1]>=rank[root2]){\\n                root[root2]=root1;\\n                if(rank[root1] == rank[root2]){\\n                    rank[root1]++;\\n                }\\n            }\\n            else{\\n                root[root1]=root2;\\n            }\\n        }\\n    }\\n    void putAndDelete(unordered_set<int> sets[],vector<int>& root,int p1,int p2,int n){\\n        //cout<<\"hereee\"<<endl;\\n        while(sets[p2].size()>0){\\n            //cout<<p1<<\" \"<<*sets[p2].begin()<<endl;\\n            sets[p1].insert(find(root,*sets[p2].begin()));\\n            sets[p2].erase(sets[p2].begin());\\n        }\\n        /*\\n        for(int j=0;j<n;j++){\\n                cout<<\"set \"<<j<<endl;\\n                for(auto itr : sets[j]){\\n                    cout<<itr<<\" \";\\n                }\\n                cout<<endl;\\n            }\\n            */\\n    }\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        vector<int> root(n,0);\\n        vector<int> rank(n,0);\\n        for(int i=0;i<n;i++){\\n            root[i]=i;\\n            rank[i]=1;\\n        }\\n        unordered_set<int> sets[n];\\n        for(auto restriction : restrictions){\\n            sets[restriction[0]].insert(restriction[1]);\\n            sets[restriction[1]].insert(restriction[0]);\\n        }\\n        vector<bool> result(requests.size(),false);\\n        for(int i=0;i<requests.size();i++){\\n            int possibleFriend1=requests[i][0];\\n            int possibleFriend2=requests[i][1];\\n            int find1=find(root,possibleFriend1);\\n            int find2=find(root,possibleFriend2);\\n            //cout<<find1<<\" \"<<find2<<\" \"<<possibleFriend1<<\" \"<<possibleFriend2<<\" \"<<i<<\" once\"<<endl;\\n            if(sets[find1].find(find2) == sets[find1].end() && sets[find2].find(find1) == sets[find2].end()){\\n                result[i]=true;\\n                Union(root,rank,possibleFriend1,possibleFriend2);\\n                int newfind=find(root,possibleFriend1);\\n                //cout<<\" \"<<newfind<<endl;\\n                if(newfind != find1){\\n                    putAndDelete(sets,root,newfind,find1,n);\\n                }\\n                if(newfind != find2){\\n                    putAndDelete(sets,root,newfind,find2,n);\\n                }\\n            }\\n            /*for(int j=0;j<n;j++){\\n                cout<<\"set \"<<j<<endl;\\n                for(auto itr : sets[j]){\\n                    cout<<itr<<\" \";\\n                }\\n                cout<<endl;\\n            }*/\\n        }\\n        return result;\\n    }\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n    int find(vector<int>& root,int i){\\n        if(root[i] == i){\\n            return i;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1795662,
                "title": "java-union-find",
                "content": "```\\nclass Solution {\\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        int[] parents = new int[n];\\n        boolean[] res = new boolean[requests.length];\\n        Arrays.fill(parents, -1);\\n        \\n        for (int i = 0; i < requests.length; i++) {\\n            int[] req = requests[i];\\n            int p1 = find(parents, req[0]);\\n            int p2 = find(parents, req[1]);\\n            if (p1 == p2) {\\n                res[i] = true;\\n                continue;\\n            }\\n            \\n            boolean canBeFriends = true;\\n            for (int[] rest: restrictions) {\\n                int r1 = find(parents, rest[0]);\\n                int r2 = find(parents, rest[1]);\\n                if ((r1 == p1 && r2 == p2) || (r1 == p2 && r2 == p1)) {\\n                    canBeFriends = false;\\n                    break;\\n                }\\n            }\\n            if (canBeFriends) {\\n                res[i] = true;\\n                parents[p1] = p2;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n    int find(int[] parents, int index) {\\n        if (parents[index] == -1)\\n            return index;\\n        return parents[index] = find(parents, parents[index]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        int[] parents = new int[n];\\n        boolean[] res = new boolean[requests.length];\\n        Arrays.fill(parents, -1);\\n        \\n        for (int i = 0; i < requests.length; i++) {\\n            int[] req = requests[i];\\n            int p1 = find(parents, req[0]);\\n            int p2 = find(parents, req[1]);\\n            if (p1 == p2) {\\n                res[i] = true;\\n                continue;\\n            }\\n            \\n            boolean canBeFriends = true;\\n            for (int[] rest: restrictions) {\\n                int r1 = find(parents, rest[0]);\\n                int r2 = find(parents, rest[1]);\\n                if ((r1 == p1 && r2 == p2) || (r1 == p2 && r2 == p1)) {\\n                    canBeFriends = false;\\n                    break;\\n                }\\n            }\\n            if (canBeFriends) {\\n                res[i] = true;\\n                parents[p1] = p2;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n    int find(int[] parents, int index) {\\n        if (parents[index] == -1)\\n            return index;\\n        return parents[index] = find(parents, parents[index]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1787856,
                "title": "java-straightforward-unionfind-with-path-compression-and-union-by-rank",
                "content": "Implement path compression and union by rank to achieve O(\\u03B1(n)) time complexity for the find operation, which is practically constant.\\n```\\nclass Solution {\\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        UnionFind uf = new UnionFind(n);\\n        boolean[] result = new boolean[requests.length];\\n        \\n        for (int i = 0; i < requests.length; i++) {\\n            int[] request = requests[i];\\n            int a = request[0];\\n            int b = request[1];\\n            int aParent = uf.find(a);\\n            int bParent = uf.find(b);\\n            \\n            if (isValid(restrictions, uf, aParent, bParent)) {\\n                uf.union(a, b);\\n                result[i] = true;\\n                continue;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n    public boolean isValid(int[][] restrictions, UnionFind uf, int aParent, int bParent) {\\n        for (int[] restriction : restrictions) {\\n            int x = restriction[0];\\n            int y = restriction[1];\\n            int xParent = uf.find(x);\\n            int yParent = uf.find(y);\\n            if ((aParent == xParent && bParent == yParent) || \\n                (aParent == yParent && bParent == xParent)) return false;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    class UnionFind {\\n        int[] parent;\\n        int[] rank;\\n        \\n        public UnionFind(int n) {\\n            this.parent = new int[n];\\n            this.rank = new int[n];\\n            for (int i = 0; i < n; i++) {\\n                parent[i] = i;\\n            }\\n        }\\n        \\n        public void union(int a, int b) {\\n            int aParent = find(a);\\n            int bParent = find(b);\\n            \\n            if (aParent == bParent) return;\\n            \\n            if (rank[aParent] > rank[bParent]) {\\n                parent[bParent] = aParent;\\n            } else if (rank[bParent] > rank[aParent]) {\\n                parent[aParent] = bParent;\\n            } else {\\n                parent[aParent] = bParent;\\n                rank[aParent] += 1;\\n            }\\n        }\\n        \\n        public int find(int a) {\\n            if (parent[a] == a) return a;\\n            parent[a] = find(parent[a]);\\n            return parent[a];\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        UnionFind uf = new UnionFind(n);\\n        boolean[] result = new boolean[requests.length];\\n        \\n        for (int i = 0; i < requests.length; i++) {\\n            int[] request = requests[i];\\n            int a = request[0];\\n            int b = request[1];\\n            int aParent = uf.find(a);\\n            int bParent = uf.find(b);\\n            \\n            if (isValid(restrictions, uf, aParent, bParent)) {\\n                uf.union(a, b);\\n                result[i] = true;\\n                continue;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n    public boolean isValid(int[][] restrictions, UnionFind uf, int aParent, int bParent) {\\n        for (int[] restriction : restrictions) {\\n            int x = restriction[0];\\n            int y = restriction[1];\\n            int xParent = uf.find(x);\\n            int yParent = uf.find(y);\\n            if ((aParent == xParent && bParent == yParent) || \\n                (aParent == yParent && bParent == xParent)) return false;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    class UnionFind {\\n        int[] parent;\\n        int[] rank;\\n        \\n        public UnionFind(int n) {\\n            this.parent = new int[n];\\n            this.rank = new int[n];\\n            for (int i = 0; i < n; i++) {\\n                parent[i] = i;\\n            }\\n        }\\n        \\n        public void union(int a, int b) {\\n            int aParent = find(a);\\n            int bParent = find(b);\\n            \\n            if (aParent == bParent) return;\\n            \\n            if (rank[aParent] > rank[bParent]) {\\n                parent[bParent] = aParent;\\n            } else if (rank[bParent] > rank[aParent]) {\\n                parent[aParent] = bParent;\\n            } else {\\n                parent[aParent] = bParent;\\n                rank[aParent] += 1;\\n            }\\n        }\\n        \\n        public int find(int a) {\\n            if (parent[a] == a) return a;\\n            parent[a] = find(parent[a]);\\n            return parent[a];\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1778948,
                "title": "c-optimised-union-find-w-explanation",
                "content": "The idea is so simple, for each friend request, go through all restrictions and verify we don\\'t allow any enemies to become friends directly or indirectly. The code is slow going around 1000ms runtime, but accepted.\\nThe optimisation in usual union find is memoizing parent, which here cannot be done completely since I use the same find function to check the restricitons, so partial memoization is done. As in memoized only when the call is not for checking any restrictions.\\n\\n```\\nvector<int> parent;\\nint find(int x,bool flag)\\n{\\n\\tif(parent[x]==-1)\\n\\t\\treturn x;\\n\\telse if(flag)\\n\\t\\treturn parent[x]=find(parent[x],flag);\\n\\telse return find(parent[x],flag);\\n}\\n\\nbool uni(int x,int y,vector<vector<int>>& restrictions)\\n{\\n\\tint xp=find(x,true),yp=find(y,true);\\n\\tif(xp==yp)\\n\\t\\treturn true;\\n\\telse\\n\\t{\\n\\t\\tparent[yp]=xp;\\n\\t\\tbool ret=true;\\n\\t\\tfor(auto& x:restrictions)\\n\\t\\t\\tif(find(x[0],false)==find(x[1],false))\\n\\t\\t\\t{\\n\\t\\t\\t\\tret=false;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\tif(!ret)\\n\\t\\t\\tparent[yp]=-1;\\n\\t\\treturn ret;                \\n\\t}\\n}\\nvector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests)\\n{\\n\\tvector<bool> ret;\\n\\tparent.resize(n,-1);\\n\\tfor(auto& x:requests)\\n\\t\\tret.push_back(uni(x[0],x[1],restrictions));\\n\\treturn ret;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Union Find"
                ],
                "code": "```\\nvector<int> parent;\\nint find(int x,bool flag)\\n{\\n\\tif(parent[x]==-1)\\n\\t\\treturn x;\\n\\telse if(flag)\\n\\t\\treturn parent[x]=find(parent[x],flag);\\n\\telse return find(parent[x],flag);\\n}\\n\\nbool uni(int x,int y,vector<vector<int>>& restrictions)\\n{\\n\\tint xp=find(x,true),yp=find(y,true);\\n\\tif(xp==yp)\\n\\t\\treturn true;\\n\\telse\\n\\t{\\n\\t\\tparent[yp]=xp;\\n\\t\\tbool ret=true;\\n\\t\\tfor(auto& x:restrictions)\\n\\t\\t\\tif(find(x[0],false)==find(x[1],false))\\n\\t\\t\\t{\\n\\t\\t\\t\\tret=false;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\tif(!ret)\\n\\t\\t\\tparent[yp]=-1;\\n\\t\\treturn ret;                \\n\\t}\\n}\\nvector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests)\\n{\\n\\tvector<bool> ret;\\n\\tparent.resize(n,-1);\\n\\tfor(auto& x:requests)\\n\\t\\tret.push_back(uni(x[0],x[1],restrictions));\\n\\treturn ret;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1714115,
                "title": "java-union-find-with-path-compression-solution",
                "content": "\\tclass Solution {\\n\\t\\tclass UnionFind {\\n\\t\\t\\tint[] size;\\n\\t\\t\\tint[] representative;\\n\\t\\t\\tpublic UnionFind(int n) {\\n\\t\\t\\t\\tsize = new int[n];\\n\\t\\t\\t\\trepresentative = new int[n];\\n\\t\\t\\t\\tfor(int i = 0; i < n; ++i) {\\n\\t\\t\\t\\t\\tsize[i] = 1;\\n\\t\\t\\t\\t\\trepresentative[i] = i;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tpublic int find(int x) {\\n\\t\\t\\t\\tif(representative[x] != x) {\\n\\t\\t\\t\\t\\trepresentative[x] = find(representative[x]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn representative[x];\\n\\t\\t\\t}\\n\\n\\t\\t\\tpublic void union(int x, int y) {\\n\\t\\t\\t\\tint pX = find(x);\\n\\t\\t\\t\\tint pY = find(y);\\n\\n\\t\\t\\t\\tif(pX == pY) {\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tif (size[pX] >= size[pY]) {\\n\\t\\t\\t\\t\\t\\tsize[pX] += size[pY];\\n\\t\\t\\t\\t\\t\\trepresentative[pY] = pX;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tsize[pY] += size[pX];\\n\\t\\t\\t\\t\\t\\trepresentative[pX] = pY;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tpublic boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n\\t\\t\\tUnionFind uF = new UnionFind(n);\\n\\t\\t\\tboolean[] results = new boolean[requests.length];\\n\\t\\t\\tint index = 0;\\n\\t\\t\\tboolean canConnect = false;\\n\\t\\t\\tfor(int[] request: requests) {\\n\\t\\t\\t\\tint x = uF.find(request[0]);\\n\\t\\t\\t\\tint y = uF.find(request[1]);\\n\\t\\t\\t\\tif(x != y) {\\n\\t\\t\\t\\t\\tfor(int[] res: restrictions) {\\n\\t\\t\\t\\t\\t\\tint pX = uF.find(res[0]);\\n\\t\\t\\t\\t\\t\\tint pY = uF.find(res[1]);\\n\\t\\t\\t\\t\\t\\tif(pX == x && pY == y || pY == x && pX == y) {\\n\\t\\t\\t\\t\\t\\t\\tcanConnect = true;\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif (!canConnect) {\\n\\t\\t\\t\\t\\t\\tuF.union(x, y);\\n\\t\\t\\t\\t\\t\\tresults[index++] = true;      \\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tresults[index++] = false;\\n\\t\\t\\t\\t\\t\\tcanConnect = false;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tresults[index++] = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn results;\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "class Solution {\\n\\t\\tclass UnionFind {\\n\\t\\t\\tint[] size;\\n\\t\\t\\tint[] representative;\\n\\t\\t\\tpublic UnionFind(int n) {\\n\\t\\t\\t\\tsize = new int[n];\\n\\t\\t\\t\\trepresentative = new int[n];\\n\\t\\t\\t\\tfor(int i = 0; i < n; ++i) {\\n\\t\\t\\t\\t\\tsize[i] = 1;\\n\\t\\t\\t\\t\\trepresentative[i] = i;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1677608,
                "title": "python-union-find-to-union-friends-hashset-to-check-restriction",
                "content": "```python\\n    def friendRequests(self, n: int, restrs: List[List[int]], requests: List[List[int]]) -> List[bool]:\\n        def find(x):\\n            if parent[x] != x:\\n                return find(parent[x])\\n            return x\\n        \\n        def union(x, y):\\n            rx, ry = find(x), find(y)\\n            if rx == ry:\\n                return True\\n            \\n            if len(constr[rx].intersection(unions[ry])) > 0:\\n                return False\\n            \\n            if rank[rx] >= rank[ry]:\\n                parent[ry] = rx\\n                unions[rx] |= unions[ry]\\n                unions[ry] = set()\\n                constr[rx] |= constr[ry]\\n                constr[ry] = set()\\n            else:\\n                parent[rx] = ry\\n                unions[ry] |= unions[rx]\\n                unions[rx] = set()\\n                constr[ry] |= constr[rx]\\n                constr[rx] = set()\\n            \\n            if rank[rx] == rank[ry]:\\n                rank[rx] += 1\\n                \\n            return True\\n        \\n        parent = list(range(n))\\n        rank = [0] * n\\n        unions = [{i} for i in range(n)]\\n        constr = [{i} for i in range(n)]\\n        for i, j in restrs:\\n            constr[i].add(j)\\n            constr[j].add(i)\\n        \\n        return [union(i, j) for i, j in requests]\\n```",
                "solutionTags": [],
                "code": "```python\\n    def friendRequests(self, n: int, restrs: List[List[int]], requests: List[List[int]]) -> List[bool]:\\n        def find(x):\\n            if parent[x] != x:\\n                return find(parent[x])\\n            return x\\n        \\n        def union(x, y):\\n            rx, ry = find(x), find(y)\\n            if rx == ry:\\n                return True\\n            \\n            if len(constr[rx].intersection(unions[ry])) > 0:\\n                return False\\n            \\n            if rank[rx] >= rank[ry]:\\n                parent[ry] = rx\\n                unions[rx] |= unions[ry]\\n                unions[ry] = set()\\n                constr[rx] |= constr[ry]\\n                constr[ry] = set()\\n            else:\\n                parent[rx] = ry\\n                unions[ry] |= unions[rx]\\n                unions[rx] = set()\\n                constr[ry] |= constr[rx]\\n                constr[rx] = set()\\n            \\n            if rank[rx] == rank[ry]:\\n                rank[rx] += 1\\n                \\n            return True\\n        \\n        parent = list(range(n))\\n        rank = [0] * n\\n        unions = [{i} for i in range(n)]\\n        constr = [{i} for i in range(n)]\\n        for i, j in restrs:\\n            constr[i].add(j)\\n            constr[j].add(i)\\n        \\n        return [union(i, j) for i, j in requests]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1665055,
                "title": "clean-union-find-solution-in-python3",
                "content": "This is a clean Union-Find solution in Python3.\\n\\n```python\\nclass UnionFind:\\n    def __init__(self, size):\\n        self.root = [i for i in range(size)]\\n        self.rank = [1] * size\\n    \\n    def find(self, x):\\n        if self.root[x] != x:\\n            self.root[x] = self.find(self.root[x])\\n        \\n        return self.root[x]\\n    \\n    def union(self, x, y):\\n        root_x, root_y = self.find(x), self.find(y)\\n        \\n        if root_x == root_y:\\n            return\\n        \\n        if self.rank[root_x] > self.rank[root_y]:\\n            self.root[root_y] = root_x\\n        elif self.rank[root_x] < self.rank[root_y]:\\n            self.root[root_x] = root_y\\n        else:\\n            self.root[root_y] = root_x\\n            self.rank[root_x] += 1\\n\\nclass Solution:\\n    def friendRequests(self, n: int, restrictions: List[List[int]], requests: List[List[int]]) -> List[bool]:\\n        res = []\\n        uf = UnionFind(n)\\n        \\n        for u, v in requests:\\n            root_u, root_v = uf.find(u), uf.find(v)\\n            approved = True\\n            \\n            if root_u == root_v:\\n                res.append(approved)\\n                uf.union(u, v)\\n                continue\\n\\n            for x, y in restrictions:\\n                root_x, root_y = uf.find(x), uf.find(y)\\n\\n                if (root_u, root_v) == (root_x, root_y) or \\\\\\n                    (root_u, root_v) == (root_y, root_x):\\n                    approved = False\\n                    break\\n            \\n            res.append(approved)\\n            \\n            if approved:\\n                uf.union(u, v)\\n                \\n        return res\\n\\n```",
                "solutionTags": [],
                "code": "```python\\nclass UnionFind:\\n    def __init__(self, size):\\n        self.root = [i for i in range(size)]\\n        self.rank = [1] * size\\n    \\n    def find(self, x):\\n        if self.root[x] != x:\\n            self.root[x] = self.find(self.root[x])\\n        \\n        return self.root[x]\\n    \\n    def union(self, x, y):\\n        root_x, root_y = self.find(x), self.find(y)\\n        \\n        if root_x == root_y:\\n            return\\n        \\n        if self.rank[root_x] > self.rank[root_y]:\\n            self.root[root_y] = root_x\\n        elif self.rank[root_x] < self.rank[root_y]:\\n            self.root[root_x] = root_y\\n        else:\\n            self.root[root_y] = root_x\\n            self.rank[root_x] += 1\\n\\nclass Solution:\\n    def friendRequests(self, n: int, restrictions: List[List[int]], requests: List[List[int]]) -> List[bool]:\\n        res = []\\n        uf = UnionFind(n)\\n        \\n        for u, v in requests:\\n            root_u, root_v = uf.find(u), uf.find(v)\\n            approved = True\\n            \\n            if root_u == root_v:\\n                res.append(approved)\\n                uf.union(u, v)\\n                continue\\n\\n            for x, y in restrictions:\\n                root_x, root_y = uf.find(x), uf.find(y)\\n\\n                if (root_u, root_v) == (root_x, root_y) or \\\\\\n                    (root_u, root_v) == (root_y, root_x):\\n                    approved = False\\n                    break\\n            \\n            res.append(approved)\\n            \\n            if approved:\\n                uf.union(u, v)\\n                \\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1663531,
                "title": "java-union-find-with-possible-optimizations-path-compression-union-by-rank",
                "content": "\\n    public int[] root;\\n    public int[] rank;\\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) \\n    {\\n        boolean[] ans=new boolean[requests.length];\\n        \\n        root=new int[n];\\n        rank=new int[n];\\n        for(int i=0; i<n; i++)\\n        {\\n            root[i]=i;\\n            rank[i]=1;\\n        }\\n        \\n        for(int i=0; i<requests.length; i++)\\n        {\\n            int x=requests[i][0];\\n            int y=requests[i][1];\\n            int rootX=find(x);\\n            int rootY=find(y);\\n            \\n            if(rootX==rootY) //if they are already indirectly connected\\n            {\\n                ans[i]=true;\\n                continue;\\n            }\\n            \\n            boolean can_connect=true;\\n            for(int[] res: restrictions)\\n            {\\n                int resX=find(res[0]);\\n                int resY=find(res[1]);\\n                \\n                //check roots and compare\\n                if((resX==rootX && resY==rootY) || (resX==rootY && resY==rootX))\\n                {\\n                    can_connect=false;\\n                    break;\\n                }  \\n            }\\n            \\n            if(can_connect)\\n            {\\n                ans[i]=true;\\n                if(rank[rootX]<rank[rootY])\\n                {\\n                    root[rootX]=rootY;\\n                    rank[rootY] += rank[rootX];\\n                }\\n                else\\n                {\\n                    root[rootY]=rootX;\\n                    rank[rootX] += rank[rootY];\\n                }\\n            }\\n            else\\n                ans[i]=false;\\n            \\n        }\\n        return ans;\\n    }\\n    \\n    public int find(int x)\\n    {\\n        while(x!=root[x])\\n        {\\n            root[x]=root[root[x]];\\n            x=root[x];\\n        }\\n        return x;\\n    }\\n",
                "solutionTags": [],
                "code": "\\n    public int[] root;\\n    public int[] rank;\\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) \\n    {\\n        boolean[] ans=new boolean[requests.length];\\n        \\n        root=new int[n];\\n        rank=new int[n];\\n        for(int i=0; i<n; i++)\\n        {\\n            root[i]=i;\\n            rank[i]=1;\\n        }\\n        \\n        for(int i=0; i<requests.length; i++)\\n        {\\n            int x=requests[i][0];\\n            int y=requests[i][1];\\n            int rootX=find(x);\\n            int rootY=find(y);\\n            \\n            if(rootX==rootY) //if they are already indirectly connected\\n            {\\n                ans[i]=true;\\n                continue;\\n            }\\n            \\n            boolean can_connect=true;\\n            for(int[] res: restrictions)\\n            {\\n                int resX=find(res[0]);\\n                int resY=find(res[1]);\\n                \\n                //check roots and compare\\n                if((resX==rootX && resY==rootY) || (resX==rootY && resY==rootX))\\n                {\\n                    can_connect=false;\\n                    break;\\n                }  \\n            }\\n            \\n            if(can_connect)\\n            {\\n                ans[i]=true;\\n                if(rank[rootX]<rank[rootY])\\n                {\\n                    root[rootX]=rootY;\\n                    rank[rootY] += rank[rootX];\\n                }\\n                else\\n                {\\n                    root[rootY]=rootX;\\n                    rank[rootX] += rank[rootY];\\n                }\\n            }\\n            else\\n                ans[i]=false;\\n            \\n        }\\n        return ans;\\n    }\\n    \\n    public int find(int x)\\n    {\\n        while(x!=root[x])\\n        {\\n            root[x]=root[root[x]];\\n            x=root[x];\\n        }\\n        return x;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1656465,
                "title": "time-limit-exceeded-for-python-solution-with-optimized-union-find",
                "content": "\\nI used both path compression and wighted union, but still the code is failing with TLE. Any idea why this is happening ?\\n\\n```\\nclass UnionFind:\\n    def __init__(self,n):\\n        self.parent = [i for i in range(n)]\\n        self.size = [1] * n\\n    # with path compression\\n    def find(self,a):\\n        if a != self.parent[a]:\\n            self.parent[a] = self.find(self.parent[a])\\n        return self.parent[a]\\n    \\n    #weighted union\\n    def union(self,a,b):\\n        root_a = self.find(a)\\n        root_b = self.find(b)\\n        if self.size[a] < self.size[b]:\\n            self.parent[root_a] = root_b\\n            self.size[root_b] += self.size[root_a]\\n        else:\\n            self.parent[root_b] = root_a\\n            self.size[root_a] += self.size[root_b]\\n        \\n\\nclass Solution:\\n    def friendRequests(self, n: int, restrictions: List[List[int]], requests: List[List[int]]) -> List[bool]:\\n        res = []\\n        union_find = UnionFind(n)\\n        #iterate over requests\\n        for request in requests:\\n            a = request[0]\\n            b = request[1]\\n            root_a = union_find.find(a)\\n            root_b = union_find.find(b)\\n            has_conflict = False\\n            for restriction in restrictions:\\n                root_1 = union_find.find(restriction[0])\\n                root_2 = union_find.find(restriction[1])\\n                if set([root_a,root_b]) == set([root_1,root_2]):\\n                    res.append(False)\\n                    has_conflict = True\\n                    break\\n            if not has_conflict:\\n                union_find.union(a,b)\\n                res.append(True)\\n        return res\\n                    \\n            \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass UnionFind:\\n    def __init__(self,n):\\n        self.parent = [i for i in range(n)]\\n        self.size = [1] * n\\n    # with path compression\\n    def find(self,a):\\n        if a != self.parent[a]:\\n            self.parent[a] = self.find(self.parent[a])\\n        return self.parent[a]\\n    \\n    #weighted union\\n    def union(self,a,b):\\n        root_a = self.find(a)\\n        root_b = self.find(b)\\n        if self.size[a] < self.size[b]:\\n            self.parent[root_a] = root_b\\n            self.size[root_b] += self.size[root_a]\\n        else:\\n            self.parent[root_b] = root_a\\n            self.size[root_a] += self.size[root_b]\\n        \\n\\nclass Solution:\\n    def friendRequests(self, n: int, restrictions: List[List[int]], requests: List[List[int]]) -> List[bool]:\\n        res = []\\n        union_find = UnionFind(n)\\n        #iterate over requests\\n        for request in requests:\\n            a = request[0]\\n            b = request[1]\\n            root_a = union_find.find(a)\\n            root_b = union_find.find(b)\\n            has_conflict = False\\n            for restriction in restrictions:\\n                root_1 = union_find.find(restriction[0])\\n                root_2 = union_find.find(restriction[1])\\n                if set([root_a,root_b]) == set([root_1,root_2]):\\n                    res.append(False)\\n                    has_conflict = True\\n                    break\\n            if not has_conflict:\\n                union_find.union(a,b)\\n                res.append(True)\\n        return res\\n                    \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1645573,
                "title": "java-with-union-find-template-comments",
                "content": "```class Solution {\\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        boolean[] result = new boolean[requests.length];\\n        \\n        UnionFind myUnionFind = new UnionFind(n);\\n        \\n        for(int i = 0; i < requests.length; i++)\\n        {\\n            int firstRequestParent = myUnionFind.find(requests[i][0]);\\n            int secondRequestParent = myUnionFind.find(requests[i][1]);\\n            \\n            // if they have the same parent, they can be friends\\n            if(firstRequestParent == secondRequestParent)\\n            {\\n                result[i] = true;\\n            }\\n            else\\n            {\\n                boolean canBeFriend = true;\\n                \\n                // if they don\\'t have the same parent, then we need to check do those two candidicates have any restrictions to be friends.\\n                for(int j = 0; j < restrictions.length; j++)\\n                {\\n                    int firstRestrictionParent = myUnionFind.find(restrictions[j][0]);\\n                    int secondRestrictionParent = myUnionFind.find(restrictions[j][1]);\\n                    \\n                    // if both of them are in the same set of the restiction, then they cann\\'t be friends.\\n                    if((firstRestrictionParent == firstRequestParent && secondRestrictionParent == secondRequestParent) ||(firstRestrictionParent == secondRequestParent && secondRestrictionParent == firstRequestParent))\\n                    {\\n                        canBeFriend = false;\\n                        result[i] = false;\\n                        break;\\n                    }\\n                }\\n                \\n                // if we pass the restriction check, we can union those two candidates into the same set.\\n                if(canBeFriend)\\n                {\\n                    result[i] = true;\\n                    myUnionFind.union(firstRequestParent, secondRequestParent);\\n                }\\n            }\\n        }\\n        \\n        return result;\\n        \\n    }\\n}\\n\\nclass UnionFind\\n{\\n    private Map<Integer,Integer>curToParent;\\n    \\n    public UnionFind(int n)\\n    {\\n        curToParent = new HashMap<>();\\n        for(int i = 0; i < n; i++)\\n        {\\n            curToParent.put(i, null);\\n        }\\n    }\\n    \\n    public void union(int x, int y)\\n    {\\n        int rootX = find(x);\\n        int rootY = find(y);\\n        \\n        if (rootX != rootY)\\n        {\\n            curToParent.put(rootX, rootY);\\n        }\\n    }\\n    \\n    public int find(int x)\\n    {\\n        int root = x;\\n        \\n        while(curToParent.get(root) != null)\\n        {\\n            root = curToParent.get(root);\\n        }\\n        \\n        while(root != x)\\n        {\\n            int tempFather = curToParent.get(x);\\n            curToParent.put(x, root);\\n            x = tempFather;\\n        }\\n        \\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```class Solution {\\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        boolean[] result = new boolean[requests.length];\\n        \\n        UnionFind myUnionFind = new UnionFind(n);\\n        \\n        for(int i = 0; i < requests.length; i++)\\n        {\\n            int firstRequestParent = myUnionFind.find(requests[i][0]);\\n            int secondRequestParent = myUnionFind.find(requests[i][1]);\\n            \\n            // if they have the same parent, they can be friends\\n            if(firstRequestParent == secondRequestParent)\\n            {\\n                result[i] = true;\\n            }\\n            else\\n            {\\n                boolean canBeFriend = true;\\n                \\n                // if they don\\'t have the same parent, then we need to check do those two candidicates have any restrictions to be friends.\\n                for(int j = 0; j < restrictions.length; j++)\\n                {\\n                    int firstRestrictionParent = myUnionFind.find(restrictions[j][0]);\\n                    int secondRestrictionParent = myUnionFind.find(restrictions[j][1]);\\n                    \\n                    // if both of them are in the same set of the restiction, then they cann\\'t be friends.\\n                    if((firstRestrictionParent == firstRequestParent && secondRestrictionParent == secondRequestParent) ||(firstRestrictionParent == secondRequestParent && secondRestrictionParent == firstRequestParent))\\n                    {\\n                        canBeFriend = false;\\n                        result[i] = false;\\n                        break;\\n                    }\\n                }\\n                \\n                // if we pass the restriction check, we can union those two candidates into the same set.\\n                if(canBeFriend)\\n                {\\n                    result[i] = true;\\n                    myUnionFind.union(firstRequestParent, secondRequestParent);\\n                }\\n            }\\n        }\\n        \\n        return result;\\n        \\n    }\\n}\\n\\nclass UnionFind\\n{\\n    private Map<Integer,Integer>curToParent;\\n    \\n    public UnionFind(int n)\\n    {\\n        curToParent = new HashMap<>();\\n        for(int i = 0; i < n; i++)\\n        {\\n            curToParent.put(i, null);\\n        }\\n    }\\n    \\n    public void union(int x, int y)\\n    {\\n        int rootX = find(x);\\n        int rootY = find(y);\\n        \\n        if (rootX != rootY)\\n        {\\n            curToParent.put(rootX, rootY);\\n        }\\n    }\\n    \\n    public int find(int x)\\n    {\\n        int root = x;\\n        \\n        while(curToParent.get(root) != null)\\n        {\\n            root = curToParent.get(root);\\n        }\\n        \\n        while(root != x)\\n        {\\n            int tempFather = curToParent.get(x);\\n            curToParent.put(x, root);\\n            x = tempFather;\\n        }\\n        \\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1642096,
                "title": "python-adjacent-list-bfs-solution",
                "content": "```\\nclass Solution:\\n    def friendRequests(self, n: int, restrictions: List[List[int]], requests: List[List[int]]) -> List[bool]:\\n        \\'\\'\\'\\n\\t\\tEX:\\n        restrictions = [[0,1],[1,2],[2,3]], requests = [[0,4],[1,2],[3,1],[3,4]\\n        ban_map:\\n        {\\n        0: 1\\n        1: 0, 2\\n        2: 1, 3\\n        3: 2\\n        }\\n        friends_map\\n        {\\n        0: 4\\n        4: 0\\n        3: 1\\n        1: 3\\n        }\\n        \\'\\'\\'\\n        \\n        def bfs(_id):\\n            peri = deque([_id])\\n            visited = set([_id])\\n            relations = set()\\n            while peri:\\n                curr_id = peri.popleft()\\n                relations.add(curr_id)\\n                for edge in friends_map[curr_id]:\\n                    if edge not in visited:\\n                        visited.add(edge)\\n                        peri.append(edge)\\n            return relations\\n                        \\n        #O 4Rest\\n        ban_map = defaultdict(lambda: set())\\n        for ban in restrictions:\\n            ban_map[ban[0]].add(ban[1])\\n            ban_map[ban[1]].add(ban[0])\\n        \\n        ans = [False] * len(requests)\\n        \\n        #O 4Req\\n        friends_map = defaultdict(lambda: [])\\n        \\n        #O Req\\n        for i, req in enumerate(requests):\\n            if req[1] in ban_map[req[0]]:\\n                ans[i] = False\\n            else:\\n                set_1 = bfs(req[0])\\n                set_2 = bfs(req[1])\\n                banned = False\\n                for key in set_1:\\n                    for banned_id in ban_map[key]:\\n                        if banned_id in set_2:\\n                            ans[i] = False\\n                            banned = True\\n                if not banned:\\n                    ans[i] = True\\n                    friends_map[req[0]].append(req[1]) \\n                    friends_map[req[1]].append(req[0]) \\n        return ans\\n",
                "solutionTags": [],
                "code": "class Solution:\\n    def friendRequests(self, n: int, restrictions: List[List[int]], requests: List[List[int]]) -> List[bool]:\\n        \\'\\'\\'\\n\\t\\tEX:\\n        restrictions = [[0,1],[1,2],[2,3]], requests = [[0,4],[1,2],[3,1],[3,4]\\n        ban_map:\\n        {\\n        0: 1\\n        1: 0, 2\\n        2: 1, 3\\n        3: 2\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1629043,
                "title": "c-dsu",
                "content": "```\\nclass Solution {\\npublic:\\n    struct dsu\\n    {\\n        vector<int>parent;\\n        dsu(int n)\\n        {\\n            parent.resize(n);\\n            for(int i=0;i<n;i++)\\n                parent[i]=i;\\n        }\\n        int find(int x)\\n        {\\n            if(parent[x]!=x)\\n                parent[x]=find(parent[x]);\\n            return parent[x];\\n        }\\n        void Union(int x,int y)\\n        {\\n            parent[y]=x;\\n        }\\n    };\\n    vector<bool> friendRequests(int n, vector<vector<int>>& rest,vector<vector<int>>& req) \\n    {\\n        dsu graph=dsu(n);\\n        vector<vector<bool>>mat(n,vector<bool>(n,false));\\n        for(auto v:rest)\\n        {\\n            mat[v[0]][v[1]]=mat[v[1]][v[0]]=true;\\n        }\\n        vector<bool>res;\\n        for(auto v:req)\\n        {\\n            int pa=graph.find(v[0]);\\n            int pb=graph.find(v[1]);\\n            if(!mat[pa][pb])\\n            {\\n                res.push_back(true);\\n                graph.Union(pa,pb);\\n                for(int i=0;i<n;i++)\\n                {\\n                    if(mat[pb][i])\\n                    {\\n                        mat[pa][i]=mat[i][pa]=true;\\n                    }\\n                }\\n            }\\n            else\\n                res.push_back(false);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    struct dsu\\n    {\\n        vector<int>parent;\\n        dsu(int n)\\n        {\\n            parent.resize(n);\\n            for(int i=0;i<n;i++)\\n                parent[i]=i;\\n        }\\n        int find(int x)\\n        {\\n            if(parent[x]!=x)\\n                parent[x]=find(parent[x]);\\n            return parent[x];\\n        }\\n        void Union(int x,int y)\\n        {\\n            parent[y]=x;\\n        }\\n    };\\n    vector<bool> friendRequests(int n, vector<vector<int>>& rest,vector<vector<int>>& req) \\n    {\\n        dsu graph=dsu(n);\\n        vector<vector<bool>>mat(n,vector<bool>(n,false));\\n        for(auto v:rest)\\n        {\\n            mat[v[0]][v[1]]=mat[v[1]][v[0]]=true;\\n        }\\n        vector<bool>res;\\n        for(auto v:req)\\n        {\\n            int pa=graph.find(v[0]);\\n            int pb=graph.find(v[1]);\\n            if(!mat[pa][pb])\\n            {\\n                res.push_back(true);\\n                graph.Union(pa,pb);\\n                for(int i=0;i<n;i++)\\n                {\\n                    if(mat[pb][i])\\n                    {\\n                        mat[pa][i]=mat[i][pa]=true;\\n                    }\\n                }\\n            }\\n            else\\n                res.push_back(false);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1622141,
                "title": "c-solution",
                "content": "Union Find Class\\n```\\npublic class Solution {\\n    public bool[] FriendRequests(int n, int[][] rests, int[][] reqs) {\\n        UnionFind uf = new UnionFind(n);\\n        \\n        bool[] r = new bool[reqs.Length];\\n        \\n        for (int i = 0; i < reqs.Length; ++i) {\\n            r[i] = true;\\n            int[] req = reqs[i];\\n            int pf = uf.Find(req[0]);\\n            int ps = uf.Find(req[1]);\\n            \\n            if (pf != ps) {\\n                foreach (int[] rest in rests) {\\n                    int px = uf.Find(rest[0]);\\n                    int py = uf.Find(rest[1]);\\n                    if ((pf == px && ps == py) || (pf == py && ps == px)) {\\n                        r[i] = false;\\n                        break;\\n                    }\\n                }\\n            }\\n            \\n            if (r[i]) {\\n                uf.Union(req[0], req[1]);\\n            }\\n        }\\n        \\n        return r;\\n    }\\n}\\n\\npublic class UnionFind {\\n    int[] Parents;\\n    \\n    public UnionFind(int n) {\\n        Parents = new int[n];\\n        for (int i = 0; i < n; ++i) Parents[i] = i;\\n    }\\n    \\n    public void Union(int u, int v) {\\n        int pu = Find(u);\\n        int pv = Find(v);\\n        \\n        Parents[pu] = pv;\\n    }\\n    \\n    public int Find(int u) {\\n        while (u != Parents[u]) {\\n            Parents[u] = Parents[Parents[u]];\\n            u = Parents[u];\\n        }\\n        \\n        return u;\\n    }\\n    \\n    public bool IsConnected(int u, int v) {\\n        return Find(u) == Find(v);\\n    }\\n    \\n    public void ResetParent(int u) {\\n        Parents[u] = u;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public bool[] FriendRequests(int n, int[][] rests, int[][] reqs) {\\n        UnionFind uf = new UnionFind(n);\\n        \\n        bool[] r = new bool[reqs.Length];\\n        \\n        for (int i = 0; i < reqs.Length; ++i) {\\n            r[i] = true;\\n            int[] req = reqs[i];\\n            int pf = uf.Find(req[0]);\\n            int ps = uf.Find(req[1]);\\n            \\n            if (pf != ps) {\\n                foreach (int[] rest in rests) {\\n                    int px = uf.Find(rest[0]);\\n                    int py = uf.Find(rest[1]);\\n                    if ((pf == px && ps == py) || (pf == py && ps == px)) {\\n                        r[i] = false;\\n                        break;\\n                    }\\n                }\\n            }\\n            \\n            if (r[i]) {\\n                uf.Union(req[0], req[1]);\\n            }\\n        }\\n        \\n        return r;\\n    }\\n}\\n\\npublic class UnionFind {\\n    int[] Parents;\\n    \\n    public UnionFind(int n) {\\n        Parents = new int[n];\\n        for (int i = 0; i < n; ++i) Parents[i] = i;\\n    }\\n    \\n    public void Union(int u, int v) {\\n        int pu = Find(u);\\n        int pv = Find(v);\\n        \\n        Parents[pu] = pv;\\n    }\\n    \\n    public int Find(int u) {\\n        while (u != Parents[u]) {\\n            Parents[u] = Parents[Parents[u]];\\n            u = Parents[u];\\n        }\\n        \\n        return u;\\n    }\\n    \\n    public bool IsConnected(int u, int v) {\\n        return Find(u) == Find(v);\\n    }\\n    \\n    public void ResetParent(int u) {\\n        Parents[u] = u;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1617498,
                "title": "java-union-find-solution",
                "content": "```\\nclass Solution {\\n    int[] roots;\\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        boolean[] res = new boolean[requests.length];\\n        roots = new int[n+1];\\n        for(int i = 0; i <= n; i++)\\n        {\\n            roots[i] = i;\\n        }\\n        \\n        int i = 0;\\n        for(int[] request : requests)\\n        {\\n            int rx = findRoot(request[0]), ry = findRoot(request[1]);\\n            boolean canAdd = true;\\n            for(int[] restriction : restrictions)\\n            {\\n                int ra = findRoot(restriction[0]), rb = findRoot(restriction[1]);\\n                if((ra == rx && ry == rb) || (ra == ry && rb== rx))\\n                {\\n                    canAdd = false;\\n                    break;\\n                }\\n            }\\n            \\n            if(canAdd)\\n            {\\n                res[i++] = true;\\n                union(rx, ry);\\n            }\\n            else\\n            {\\n                res[i++] = false;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n    public int findRoot(int i)\\n    {\\n        int cur = i;\\n        while(roots[cur]!=cur)\\n        {\\n            cur = roots[roots[cur]];\\n        }\\n        \\n        roots[i] = cur;\\n        return cur;\\n    }\\n    \\n    public void union(int i, int j)\\n    {\\n        int r1 = findRoot(i), r2 = findRoot(j);\\n        roots[r1] = r2;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int[] roots;\\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        boolean[] res = new boolean[requests.length];\\n        roots = new int[n+1];\\n        for(int i = 0; i <= n; i++)\\n        {\\n            roots[i] = i;\\n        }\\n        \\n        int i = 0;\\n        for(int[] request : requests)\\n        {\\n            int rx = findRoot(request[0]), ry = findRoot(request[1]);\\n            boolean canAdd = true;\\n            for(int[] restriction : restrictions)\\n            {\\n                int ra = findRoot(restriction[0]), rb = findRoot(restriction[1]);\\n                if((ra == rx && ry == rb) || (ra == ry && rb== rx))\\n                {\\n                    canAdd = false;\\n                    break;\\n                }\\n            }\\n            \\n            if(canAdd)\\n            {\\n                res[i++] = true;\\n                union(rx, ry);\\n            }\\n            else\\n            {\\n                res[i++] = false;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n    public int findRoot(int i)\\n    {\\n        int cur = i;\\n        while(roots[cur]!=cur)\\n        {\\n            cur = roots[roots[cur]];\\n        }\\n        \\n        roots[i] = cur;\\n        return cur;\\n    }\\n    \\n    public void union(int i, int j)\\n    {\\n        int r1 = findRoot(i), r2 = findRoot(j);\\n        roots[r1] = r2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1617178,
                "title": "typical-unionfind-except-we-make-it-faster-by-remember-what-we-checked",
                "content": "For each group of friends, we keep track of who they can\\'t be friends with by assigning a blacklisted set to their root. When we try to union two groups, we check if the other group contains anything from the current group\\'s blacklist. \\n\\nBut this takes constant time and we want to minimize this. As a result, if it turns out we can\\'t union two groups, we add each group\\'s head to the other group\\'s head\\'s blacklist. This way, if we got another request from the childs of two groups, we can instantly check that their heads had blacklisted one another, and quickly return False.\\n\\nAnyways here\\'s the code:\\n```\\nclass Solution:\\n    def friendRequests(self, n: int, restrictions: List[List[int]], req: List[List[int]]) -> List[bool]:\\n        \\n        parent = {}\\n        child = collections.defaultdict(set)\\n        for i in range(n):\\n            parent[i] = i\\n            child[i].add(i)\\n        \\n        \\n        banned = collections.defaultdict(set)\\n        for a, b in restrictions:\\n            banned[a].add(b)\\n            banned[b].add(a)\\n            \\n        \\n        res = []\\n        for a, b in req:\\n            \\n            \\n            # if any part of a has restriction with any part of b: False.\\n            p1 = parent[a]\\n            p2 = parent[b]\\n            \\n            \\n            #check if we can union them.\\n            \\n            if p1 in banned[p2] or p2 in banned[p1]:\\n                #fast check to see if we have tried to union them already and it no work.\\n                res.append(False)\\n                continue\\n            \\n            if p1 == p2: \\n                res.append(True)\\n                continue\\n            \\n            doable = True\\n\\n            \\n            for e in banned[p1]:\\n                if e in child[p2]:\\n                    doable = False\\n                    break\\n            \\n            if doable != False:\\n                for e in banned[p2]:\\n                    if e in child[p1]:\\n                        doable = False\\n                        break\\n            \\n            \\n            if doable: #we union them\\n                res.append(True)\\n                \\n                #put smaller p2 into bigger p1\\n                if len(child[p2]) > len(child[p1]):\\n                    tmp = p1\\n                    p1 = p2\\n                    p2 = tmp\\n                \\n                for e in banned[p2]:\\n                    banned[p1].add(e)\\n                \\n                for e in child[p2]:\\n                    child[p1].add(e)\\n                    parent[e] = p1\\n                \\n                del child[p2]\\n                del banned[p2]\\n                \\n            else:\\n                banned[p1].add(p2) #next time we try to union these two groups, we know that they\\'re already not possible\\n                banned[p2].add(p1)\\n                \\n                res.append(False)\\n            \\n#             print(\"after unioning\", a, b)\\n#             print(child)\\n        \\n        \\n        \\n        \\n        return res\\n     \\n```",
                "solutionTags": [
                    "Python",
                    "Union Find"
                ],
                "code": "```\\nclass Solution:\\n    def friendRequests(self, n: int, restrictions: List[List[int]], req: List[List[int]]) -> List[bool]:\\n        \\n        parent = {}\\n        child = collections.defaultdict(set)\\n        for i in range(n):\\n            parent[i] = i\\n            child[i].add(i)\\n        \\n        \\n        banned = collections.defaultdict(set)\\n        for a, b in restrictions:\\n            banned[a].add(b)\\n            banned[b].add(a)\\n            \\n        \\n        res = []\\n        for a, b in req:\\n            \\n            \\n            # if any part of a has restriction with any part of b: False.\\n            p1 = parent[a]\\n            p2 = parent[b]\\n            \\n            \\n            #check if we can union them.\\n            \\n            if p1 in banned[p2] or p2 in banned[p1]:\\n                #fast check to see if we have tried to union them already and it no work.\\n                res.append(False)\\n                continue\\n            \\n            if p1 == p2: \\n                res.append(True)\\n                continue\\n            \\n            doable = True\\n\\n            \\n            for e in banned[p1]:\\n                if e in child[p2]:\\n                    doable = False\\n                    break\\n            \\n            if doable != False:\\n                for e in banned[p2]:\\n                    if e in child[p1]:\\n                        doable = False\\n                        break\\n            \\n            \\n            if doable: #we union them\\n                res.append(True)\\n                \\n                #put smaller p2 into bigger p1\\n                if len(child[p2]) > len(child[p1]):\\n                    tmp = p1\\n                    p1 = p2\\n                    p2 = tmp\\n                \\n                for e in banned[p2]:\\n                    banned[p1].add(e)\\n                \\n                for e in child[p2]:\\n                    child[p1].add(e)\\n                    parent[e] = p1\\n                \\n                del child[p2]\\n                del banned[p2]\\n                \\n            else:\\n                banned[p1].add(p2) #next time we try to union these two groups, we know that they\\'re already not possible\\n                banned[p2].add(p1)\\n                \\n                res.append(False)\\n            \\n#             print(\"after unioning\", a, b)\\n#             print(child)\\n        \\n        \\n        \\n        \\n        return res\\n     \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1613336,
                "title": "brute-force-via-union-find",
                "content": "**Idea**: For every request, see if it results in a violation. If yes, then mark request as not processable. Else, unify the request and mark it as processable.\\n\\n**Violation**: A request is said to be a violation, if processing the request makes any of restrictions fall inside a same component. i.e., if roots of a request == roots of a restriction, then its a violation\\n\\nRuntime: O(requests*restrictions)\\n\\n```\\nclass Solution:\\n    \\n    def find(self, x, parent):\\n        y = x\\n        while(parent[x] != x):\\n            x = parent[x]\\n        parent[y] = x\\n        return x\\n    \\n    def union(self, x, y, parent):\\n        r1 = self.find(x, parent)\\n        r2 = self.find(y, parent)\\n        parent[r2] = r1\\n        return r2\\n    \\n    def violation(self, req, restrictions, parent):\\n        req_r1 = self.find(req[0], parent)\\n        req_r2 = self.find(req[1], parent)\\n        \\n        for restr in restrictions:\\n            restr_r1 = self.find(restr[0], parent)\\n            restr_r2 = self.find(restr[1], parent)\\n            \\n            if (restr_r1 == req_r1 and restr_r2 == req_r2) or (restr_r1 == req_r2 and restr_r2 == req_r1):\\n                return True\\n        \\n        return False\\n            \\n    def friendRequests(self, n: int, restrictions: List[List[int]], requests: List[List[int]]) -> List[bool]:\\n        \\n        parent = {i:i for i in range(n)}\\n        res = []\\n        for req in requests:\\n            if self.violation(req, restrictions, parent):\\n                res.append(False)\\n            else:\\n                self.union(req[0], req[1], parent)\\n                res.append(True)\\n        return res\\n```",
                "solutionTags": [
                    "Union Find"
                ],
                "code": "```\\nclass Solution:\\n    \\n    def find(self, x, parent):\\n        y = x\\n        while(parent[x] != x):\\n            x = parent[x]\\n        parent[y] = x\\n        return x\\n    \\n    def union(self, x, y, parent):\\n        r1 = self.find(x, parent)\\n        r2 = self.find(y, parent)\\n        parent[r2] = r1\\n        return r2\\n    \\n    def violation(self, req, restrictions, parent):\\n        req_r1 = self.find(req[0], parent)\\n        req_r2 = self.find(req[1], parent)\\n        \\n        for restr in restrictions:\\n            restr_r1 = self.find(restr[0], parent)\\n            restr_r2 = self.find(restr[1], parent)\\n            \\n            if (restr_r1 == req_r1 and restr_r2 == req_r2) or (restr_r1 == req_r2 and restr_r2 == req_r1):\\n                return True\\n        \\n        return False\\n            \\n    def friendRequests(self, n: int, restrictions: List[List[int]], requests: List[List[int]]) -> List[bool]:\\n        \\n        parent = {i:i for i in range(n)}\\n        res = []\\n        for req in requests:\\n            if self.violation(req, restrictions, parent):\\n                res.append(False)\\n            else:\\n                self.union(req[0], req[1], parent)\\n                res.append(True)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1607322,
                "title": "java",
                "content": "```\\nclass Solution {\\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        int[] djs = new int[n];\\n        boolean[] res = new boolean[requests.length];\\n        \\n        Arrays.fill(djs, -1);\\n        \\n        int index = 0;\\n        for (int i = 0; i < requests.length; i++) {\\n            int parent = getParent(djs, requests[i][0]);\\n            int parent1 = getParent(djs, requests[i][1]);\\n            \\n            if (parent == parent1) {\\n                res[index++] = true;\\n                continue;                \\n            } \\n            \\n            djs[parent] = parent1;\\n            \\n            boolean remove = false;\\n            for (int j = 0; j < restrictions.length; j++) {\\n                \\n                int p = getParent(djs, restrictions[j][0]);\\n                int p1 = getParent(djs, restrictions[j][1]);\\n                \\n                if (p == p1) {\\n                    remove = true;\\n                    break;\\n                }\\n            }\\n            if (remove) {\\n                djs[parent] = -1;\\n                res[index++] = false;\\n            } else {\\n                res[index++] = true;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n    private int getParent(int[] djs, int node) {\\n        while (djs[node] != -1) {\\n            node = djs[node];\\n        }\\n        return node;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        int[] djs = new int[n];\\n        boolean[] res = new boolean[requests.length];\\n        \\n        Arrays.fill(djs, -1);\\n        \\n        int index = 0;\\n        for (int i = 0; i < requests.length; i++) {\\n            int parent = getParent(djs, requests[i][0]);\\n            int parent1 = getParent(djs, requests[i][1]);\\n            \\n            if (parent == parent1) {\\n                res[index++] = true;\\n                continue;                \\n            } \\n            \\n            djs[parent] = parent1;\\n            \\n            boolean remove = false;\\n            for (int j = 0; j < restrictions.length; j++) {\\n                \\n                int p = getParent(djs, restrictions[j][0]);\\n                int p1 = getParent(djs, restrictions[j][1]);\\n                \\n                if (p == p1) {\\n                    remove = true;\\n                    break;\\n                }\\n            }\\n            if (remove) {\\n                djs[parent] = -1;\\n                res[index++] = false;\\n            } else {\\n                res[index++] = true;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n    private int getParent(int[] djs, int node) {\\n        while (djs[node] != -1) {\\n            node = djs[node];\\n        }\\n        return node;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1601582,
                "title": "cheating-question",
                "content": "Basically you only need to notice the length of restrictions and requests are both below or equal to 1000, then for each iteration of requests you can go through restrictions to check if it\\'s forbidden or not, so it\\'s boring.\\n\\n```\\nclass Solution {\\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        // also a union find question life sucks\\n        UF uf = new UF(n);\\n        boolean[] res = new boolean[requests.length];\\n        \\n        for (int i = 0; i < requests.length; i++){\\n            int a = requests[i][0], b = requests[i][1];\\n            boolean flag = false;\\n            int pa = uf.find(a), pb = uf.find(b);\\n            for (int j = 0; j < restrictions.length; j++){\\n                int ra = uf.find(restrictions[j][0]), rb = uf.find(restrictions[j][1]);\\n                if ((ra == pa && rb == pb) || (ra == pb && rb == pa)){\\n                    flag = true;\\n                    break;\\n                }\\n            }\\n            if (flag) continue;\\n            uf.union(pa,pb);\\n            res[i] = true;\\n        }\\n        \\n        return res;\\n    }\\n}\\n\\nclass UF {\\n    int[] parents;\\n    int[] rank;\\n    public UF(int n){\\n        parents = new int[n];\\n        rank = new int[n];\\n        for (int i = 0; i < n; i++){\\n            parents[i] = i;\\n            rank[i] = 1;\\n        }\\n    }\\n    \\n    public int find(int node){\\n        if (parents[node] == node) return node;\\n        return parents[node] = find(parents[node]);\\n    }\\n    \\n    public void union(int x, int y){\\n        int px = find(x), py = find(y);\\n        if (px != py){\\n            if (rank[px] >= rank[py]){\\n                parents[py] = px;\\n                rank[px] += rank[py];\\n            }else{\\n                parents[px] = py;\\n                rank[py] += rank[px];\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        // also a union find question life sucks\\n        UF uf = new UF(n);\\n        boolean[] res = new boolean[requests.length];\\n        \\n        for (int i = 0; i < requests.length; i++){\\n            int a = requests[i][0], b = requests[i][1];\\n            boolean flag = false;\\n            int pa = uf.find(a), pb = uf.find(b);\\n            for (int j = 0; j < restrictions.length; j++){\\n                int ra = uf.find(restrictions[j][0]), rb = uf.find(restrictions[j][1]);\\n                if ((ra == pa && rb == pb) || (ra == pb && rb == pa)){\\n                    flag = true;\\n                    break;\\n                }\\n            }\\n            if (flag) continue;\\n            uf.union(pa,pb);\\n            res[i] = true;\\n        }\\n        \\n        return res;\\n    }\\n}\\n\\nclass UF {\\n    int[] parents;\\n    int[] rank;\\n    public UF(int n){\\n        parents = new int[n];\\n        rank = new int[n];\\n        for (int i = 0; i < n; i++){\\n            parents[i] = i;\\n            rank[i] = 1;\\n        }\\n    }\\n    \\n    public int find(int node){\\n        if (parents[node] == node) return node;\\n        return parents[node] = find(parents[node]);\\n    }\\n    \\n    public void union(int x, int y){\\n        int px = find(x), py = find(y);\\n        if (px != py){\\n            if (rank[px] >= rank[py]){\\n                parents[py] = px;\\n                rank[px] += rank[py];\\n            }else{\\n                parents[px] = py;\\n                rank[py] += rank[px];\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1594415,
                "title": "go-union-find-set",
                "content": "```go\\nfunc friendRequests(n int, restrictions [][]int, requests [][]int) []bool {\\n\\tans := make([]bool, 0)\\n\\tufs := initUFS(n)\\n\\tfor _, request := range requests {\\n\\t\\tpx := ufs.find(request[0])\\n\\t\\tpy := ufs.find(request[1])\\n\\t\\tif px == py {\\n\\t\\t\\tans = append(ans, true)\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tmerge := true\\n\\t\\tfor _, restriction := range restrictions {\\n\\t\\t\\tp0 := ufs.find(restriction[0])\\n\\t\\t\\tp1 := ufs.find(restriction[1])\\n\\t\\t\\tif (p0 == px && p1 == py) || (p1 == px && p0 == py) {\\n\\t\\t\\t\\tmerge = false\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif merge {\\n\\t\\t\\tufs.merge(request[0], request[1])\\n\\t\\t\\tans = append(ans, true)\\n\\t\\t} else {\\n\\t\\t\\tans = append(ans, false)\\n\\t\\t}\\n\\t}\\n\\treturn ans\\n}\\n\\ntype UnionFindSet struct {\\n\\tparent []int\\n\\trank   []int\\n}\\n\\nfunc initUFS(n int) *UnionFindSet {\\n\\tufs := &UnionFindSet{\\n\\t\\tparent: make([]int, n),\\n\\t\\trank:   make([]int, n),\\n\\t}\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tufs.parent[i] = i\\n\\t\\tufs.rank[i] = 1\\n\\t}\\n\\treturn ufs\\n}\\n\\nfunc (ufs *UnionFindSet) find(x int) int {\\n\\tif x == ufs.parent[x] {\\n\\t\\treturn x\\n\\t} else {\\n\\t\\tufs.parent[x] = ufs.find(ufs.parent[x])\\n\\t\\treturn ufs.parent[x]\\n\\t}\\n}\\n\\nfunc (ufs *UnionFindSet) merge(x, y int) {\\n\\tpx := ufs.find(x)\\n\\tpy := ufs.find(y)\\n\\tif ufs.rank[px] <= ufs.rank[py] {\\n\\t\\tufs.parent[px] = py\\n\\t} else {\\n\\t\\tufs.parent[py] = px\\n\\t}\\n\\tif ufs.rank[px] == ufs.rank[py] && px != py {\\n\\t\\tufs.rank[py]++\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc friendRequests(n int, restrictions [][]int, requests [][]int) []bool {\\n\\tans := make([]bool, 0)\\n\\tufs := initUFS(n)\\n\\tfor _, request := range requests {\\n\\t\\tpx := ufs.find(request[0])\\n\\t\\tpy := ufs.find(request[1])\\n\\t\\tif px == py {\\n\\t\\t\\tans = append(ans, true)\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tmerge := true\\n\\t\\tfor _, restriction := range restrictions {\\n\\t\\t\\tp0 := ufs.find(restriction[0])\\n\\t\\t\\tp1 := ufs.find(restriction[1])\\n\\t\\t\\tif (p0 == px && p1 == py) || (p1 == px && p0 == py) {\\n\\t\\t\\t\\tmerge = false\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif merge {\\n\\t\\t\\tufs.merge(request[0], request[1])\\n\\t\\t\\tans = append(ans, true)\\n\\t\\t} else {\\n\\t\\t\\tans = append(ans, false)\\n\\t\\t}\\n\\t}\\n\\treturn ans\\n}\\n\\ntype UnionFindSet struct {\\n\\tparent []int\\n\\trank   []int\\n}\\n\\nfunc initUFS(n int) *UnionFindSet {\\n\\tufs := &UnionFindSet{\\n\\t\\tparent: make([]int, n),\\n\\t\\trank:   make([]int, n),\\n\\t}\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tufs.parent[i] = i\\n\\t\\tufs.rank[i] = 1\\n\\t}\\n\\treturn ufs\\n}\\n\\nfunc (ufs *UnionFindSet) find(x int) int {\\n\\tif x == ufs.parent[x] {\\n\\t\\treturn x\\n\\t} else {\\n\\t\\tufs.parent[x] = ufs.find(ufs.parent[x])\\n\\t\\treturn ufs.parent[x]\\n\\t}\\n}\\n\\nfunc (ufs *UnionFindSet) merge(x, y int) {\\n\\tpx := ufs.find(x)\\n\\tpy := ufs.find(y)\\n\\tif ufs.rank[px] <= ufs.rank[py] {\\n\\t\\tufs.parent[px] = py\\n\\t} else {\\n\\t\\tufs.parent[py] = px\\n\\t}\\n\\tif ufs.rank[px] == ufs.rank[py] && px != py {\\n\\t\\tufs.rank[py]++\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1592653,
                "title": "c-union-find-by-rank",
                "content": "```\\nclass DisjointSetElement{\\n    public:\\n    int parent;\\n    int rank;\\n};\\nclass UnionFind{\\n    private:\\n    void merge(int fin,int init){\\n        this->parents[init].parent=fin;\\n        this->parents[fin].rank+=this->parents[init].rank;\\n    }\\n    public:\\n    vector<DisjointSetElement>parents;\\n    UnionFind(int n){\\n        for(int i=0;i<n;i++){\\n            DisjointSetElement element;\\n            element.parent=i;\\n            element.rank=1;\\n            this->parents.push_back(element);\\n        }\\n    }\\n    int findParent(int x){\\n        while(x!=this->parents[x].parent){\\n            x=this->parents[x].parent;\\n        }\\n        return x;\\n    }\\n    bool findUnion(int x,int y){\\n        int parx=this->findParent(x);\\n        int pary=this->findParent(y);\\n        if(parx!=pary){\\n            if(this->parents[parx].rank>=this->parents[pary].rank){\\n                this->merge(parx,pary);\\n            } else {\\n                this->merge(pary,parx);\\n            }\\n            return false;\\n        } else {\\n            return true;\\n        }\\n    }\\n    bool isConnected(int x,int y){\\n        return this->findParent(x)==this->findParent(y);\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        UnionFind uf(n);\\n        vector<bool>ans;\\n        for(int i=0;i<requests.size();i++){\\n            int u=requests[i][0];\\n            int v=requests[i][1];\\n            vector<DisjointSetElement>tmp=uf.parents;\\n            uf.findUnion(u,v);\\n            bool canAdd=true;\\n            for(int j=0;j<restrictions.size();j++){\\n                if(uf.isConnected(restrictions[j][0],restrictions[j][1])){\\n                    canAdd=false;\\n                    break;\\n                }\\n            }\\n            if(!canAdd){\\n                uf.parents=tmp;\\n            }\\n            ans.push_back(canAdd);\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Union Find"
                ],
                "code": "class Solution {\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        UnionFind uf(n);\\n        vector<bool>ans;\\n        for(int i=0;i<requests.size();i++){\\n            int u=requests[i][0];\\n            int v=requests[i][1];\\n            vector<DisjointSetElement>tmp=uf.parents;\\n            uf.findUnion(u,v);\\n            bool canAdd=true;\\n            for(int j=0;j<restrictions.size();j++){\\n                if(uf.isConnected(restrictions[j][0],restrictions[j][1])){\\n                    canAdd=false;\\n                    break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1592088,
                "title": "c-verbose-and-lengthy-solution",
                "content": "Have seen very clean solutions from others whereas my solutions are very lengthy, cumbersome and hard to debug. Any tips for shorter and cleaner solutions would be highly appreciated\\n```\\nclass Solution {\\npublic:\\n  int getCliqueForClique(int clique,\\n                       unordered_map<int, int>& cliqueToClique,\\n                       unordered_map<int, unordered_set<int>>& personToEnemyCliques,\\n                       unordered_map<int, unordered_set<int>>& cliqueToEnemies,\\n                       unordered_map<int, unordered_set<int>>& cliqueToEnemyCliques) {\\n    if (cliqueToClique.find(clique) == cliqueToClique.end() ||\\n        cliqueToClique[clique] == clique) {\\n      return clique;\\n    }\\n    int parent = getCliqueForClique(cliqueToClique[clique], cliqueToClique,\\n                                    personToEnemyCliques,\\n                                    cliqueToEnemies, cliqueToEnemyCliques);\\n    cliqueToClique[clique] = parent;\\n    \\n    auto& enemies = cliqueToEnemies[clique];\\n    for (auto it = enemies.begin(); it != enemies.end(); ++it) {\\n      cliqueToEnemies[parent].insert(*it);\\n      personToEnemyCliques[*it].insert(parent);\\n    }\\n    enemies.clear();\\n    \\n    auto& enemyCliques = cliqueToEnemyCliques[clique];\\n    for (auto it = enemyCliques.begin(); it != enemyCliques.end(); ++it) {\\n      cliqueToEnemyCliques[parent].insert(*it);\\n      cliqueToEnemyCliques[*it].insert(parent);\\n    }\\n    enemyCliques.clear();\\n    return parent;\\n  }\\n  \\n  int getCliqueForPerson(int person,\\n                       unordered_map<int, int>& personToClique,\\n                       unordered_map<int, int>& cliqueToClique,\\n                       unordered_map<int, unordered_set<int>>& personToEnemies,\\n                       unordered_map<int, unordered_set<int>>& personToEnemyCliques,\\n                       unordered_map<int, unordered_set<int>>& cliqueToEnemies,\\n                       unordered_map<int, unordered_set<int>>& cliqueToEnemyCliques) {\\n    if (personToClique.find(person) == personToClique.end()) {\\n      return -1;\\n    }\\n    int clique = getCliqueForClique(personToClique[person], cliqueToClique,\\n                                    personToEnemyCliques,\\n                                    cliqueToEnemies, cliqueToEnemyCliques);\\n    \\n    personToClique[person] = clique;\\n    auto& enemies = personToEnemies[person];\\n    for (auto it = enemies.begin(); it != enemies.end(); ++it) {\\n      cliqueToEnemies[clique].insert(*it);\\n      personToEnemyCliques[*it].insert(clique);\\n    }\\n    enemies.clear();\\n    \\n    auto& enemyCliques = personToEnemyCliques[person];\\n    for (auto it = enemyCliques.begin(); it != enemyCliques.end(); ++it) {\\n      cliqueToEnemyCliques[clique].insert(*it);\\n      cliqueToEnemyCliques[*it].insert(clique);\\n    }\\n    enemyCliques.clear();\\n    return clique;\\n  }\\n  \\n  vector<bool> friendRequests(int n, vector<vector<int>>& restrictions,\\n                              vector<vector<int>>& requests) {\\n    vector<bool> result(requests.size(), false);\\n    unordered_map<int, int> personToClique;\\n    unordered_map<int, int> cliqueToClique;\\n    \\n    unordered_map<int, unordered_set<int>> personToEnemies;\\n    unordered_map<int, unordered_set<int>> cliqueToEnemies;\\n    unordered_map<int, unordered_set<int>> personToEnemyCliques;\\n    unordered_map<int, unordered_set<int>> cliqueToEnemyCliques;\\n    \\n    for (auto& vc: restrictions) {\\n      int p1 = vc[0], p2 = vc[1];\\n      personToEnemies[p1].insert(p2);\\n      personToEnemies[p2].insert(p1);\\n    }\\n    \\n    int numCliques = 0;\\n    for (int i = 0; i < requests.size(); ++i) {\\n      auto& vc = requests[i];\\n      int p1 = vc[0], p2 = vc[1];\\n      \\n      int c1 = getCliqueForPerson(p1, personToClique, cliqueToClique,\\n                                  personToEnemies,\\n                                  personToEnemyCliques,\\n                                  cliqueToEnemies,\\n                                  cliqueToEnemyCliques);\\n      int c2 = getCliqueForPerson(p2, personToClique, cliqueToClique,\\n                                  personToEnemies,\\n                                  personToEnemyCliques,\\n                                  cliqueToEnemies,\\n                                  cliqueToEnemyCliques);\\n      \\n      bool outcome = true;\\n      \\n      if (personToEnemies[p1].find(p2) != personToEnemies[p1].end()) {\\n        outcome = false;\\n      } else if (c1 != -1 && c2 != -1) {\\n        if (c1 == c2) {\\n          outcome = true;\\n        } else if (cliqueToEnemyCliques[c1].find(c2) !=\\n                   cliqueToEnemyCliques[c1].end()) {\\n          outcome = false;\\n        } else if (cliqueToEnemies[c1].find(p2) != cliqueToEnemies[c1].end()) {\\n          outcome = false;\\n        }\\n      } else if (c1 != -1) {\\n        if (cliqueToEnemies[c1].find(p2) != cliqueToEnemies[c1].end()) {\\n          outcome = false;\\n        }\\n      } else if (c2 != -1) {\\n        if (cliqueToEnemies[c2].find(p1) != cliqueToEnemies[c2].end()) {\\n          outcome = false;\\n        }\\n      }\\n      \\n      if (outcome) {\\n        if (c1 != -1 && c2 != -1) {\\n          cliqueToClique[c1] = c2;\\n        } else if (c1 != -1) {\\n          personToClique[p2] = c1;\\n        } else if (c2 != -1) {\\n          personToClique[p1] = c2;\\n        } else {\\n          personToClique[p1] = numCliques;\\n          personToClique[p2] = numCliques;\\n          numCliques++;\\n        }\\n      } else {\\n        personToEnemies[p1].insert(p2);\\n        personToEnemies[p2].insert(p1);\\n        if (c1 != -1 && c2 != -1) {\\n          cliqueToEnemyCliques[c1].insert(c2);\\n          cliqueToEnemyCliques[c2].insert(c1);\\n          personToEnemyCliques[p1].insert(c2);\\n          personToEnemyCliques[p2].insert(c1);\\n        } else if (c1 != -1) {\\n          personToClique[p2] = numCliques;\\n          numCliques++;\\n          \\n          cliqueToEnemies[c1].insert(p2);\\n          personToEnemyCliques[p2].insert(c1);\\n        } else if (c2 != -1) {\\n          personToClique[p1] = numCliques;\\n          numCliques++;\\n          \\n          cliqueToEnemies[c2].insert(p1);\\n          personToEnemyCliques[p1].insert(c2);\\n        } else {\\n          personToClique[p1] = numCliques;\\n          numCliques++;\\n          personToClique[p2] = numCliques;\\n          numCliques++;\\n        }\\n      }\\n\\n      c1 = getCliqueForPerson(p1, personToClique, cliqueToClique,\\n                              personToEnemies,\\n                              personToEnemyCliques,\\n                              cliqueToEnemies,\\n                              cliqueToEnemyCliques);\\n      c2 = getCliqueForPerson(p2, personToClique, cliqueToClique,\\n                              personToEnemies,\\n                              personToEnemyCliques,\\n                              cliqueToEnemies,\\n                              cliqueToEnemyCliques);\\n\\n      result[i] = outcome;\\n    }\\n    return result;\\n  }\\n\\n};\\n```",
                "solutionTags": [
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int getCliqueForClique(int clique,\\n                       unordered_map<int, int>& cliqueToClique,\\n                       unordered_map<int, unordered_set<int>>& personToEnemyCliques,\\n                       unordered_map<int, unordered_set<int>>& cliqueToEnemies,\\n                       unordered_map<int, unordered_set<int>>& cliqueToEnemyCliques) {\\n    if (cliqueToClique.find(clique) == cliqueToClique.end() ||\\n        cliqueToClique[clique] == clique) {\\n      return clique;\\n    }\\n    int parent = getCliqueForClique(cliqueToClique[clique], cliqueToClique,\\n                                    personToEnemyCliques,\\n                                    cliqueToEnemies, cliqueToEnemyCliques);\\n    cliqueToClique[clique] = parent;\\n    \\n    auto& enemies = cliqueToEnemies[clique];\\n    for (auto it = enemies.begin(); it != enemies.end(); ++it) {\\n      cliqueToEnemies[parent].insert(*it);\\n      personToEnemyCliques[*it].insert(parent);\\n    }\\n    enemies.clear();\\n    \\n    auto& enemyCliques = cliqueToEnemyCliques[clique];\\n    for (auto it = enemyCliques.begin(); it != enemyCliques.end(); ++it) {\\n      cliqueToEnemyCliques[parent].insert(*it);\\n      cliqueToEnemyCliques[*it].insert(parent);\\n    }\\n    enemyCliques.clear();\\n    return parent;\\n  }\\n  \\n  int getCliqueForPerson(int person,\\n                       unordered_map<int, int>& personToClique,\\n                       unordered_map<int, int>& cliqueToClique,\\n                       unordered_map<int, unordered_set<int>>& personToEnemies,\\n                       unordered_map<int, unordered_set<int>>& personToEnemyCliques,\\n                       unordered_map<int, unordered_set<int>>& cliqueToEnemies,\\n                       unordered_map<int, unordered_set<int>>& cliqueToEnemyCliques) {\\n    if (personToClique.find(person) == personToClique.end()) {\\n      return -1;\\n    }\\n    int clique = getCliqueForClique(personToClique[person], cliqueToClique,\\n                                    personToEnemyCliques,\\n                                    cliqueToEnemies, cliqueToEnemyCliques);\\n    \\n    personToClique[person] = clique;\\n    auto& enemies = personToEnemies[person];\\n    for (auto it = enemies.begin(); it != enemies.end(); ++it) {\\n      cliqueToEnemies[clique].insert(*it);\\n      personToEnemyCliques[*it].insert(clique);\\n    }\\n    enemies.clear();\\n    \\n    auto& enemyCliques = personToEnemyCliques[person];\\n    for (auto it = enemyCliques.begin(); it != enemyCliques.end(); ++it) {\\n      cliqueToEnemyCliques[clique].insert(*it);\\n      cliqueToEnemyCliques[*it].insert(clique);\\n    }\\n    enemyCliques.clear();\\n    return clique;\\n  }\\n  \\n  vector<bool> friendRequests(int n, vector<vector<int>>& restrictions,\\n                              vector<vector<int>>& requests) {\\n    vector<bool> result(requests.size(), false);\\n    unordered_map<int, int> personToClique;\\n    unordered_map<int, int> cliqueToClique;\\n    \\n    unordered_map<int, unordered_set<int>> personToEnemies;\\n    unordered_map<int, unordered_set<int>> cliqueToEnemies;\\n    unordered_map<int, unordered_set<int>> personToEnemyCliques;\\n    unordered_map<int, unordered_set<int>> cliqueToEnemyCliques;\\n    \\n    for (auto& vc: restrictions) {\\n      int p1 = vc[0], p2 = vc[1];\\n      personToEnemies[p1].insert(p2);\\n      personToEnemies[p2].insert(p1);\\n    }\\n    \\n    int numCliques = 0;\\n    for (int i = 0; i < requests.size(); ++i) {\\n      auto& vc = requests[i];\\n      int p1 = vc[0], p2 = vc[1];\\n      \\n      int c1 = getCliqueForPerson(p1, personToClique, cliqueToClique,\\n                                  personToEnemies,\\n                                  personToEnemyCliques,\\n                                  cliqueToEnemies,\\n                                  cliqueToEnemyCliques);\\n      int c2 = getCliqueForPerson(p2, personToClique, cliqueToClique,\\n                                  personToEnemies,\\n                                  personToEnemyCliques,\\n                                  cliqueToEnemies,\\n                                  cliqueToEnemyCliques);\\n      \\n      bool outcome = true;\\n      \\n      if (personToEnemies[p1].find(p2) != personToEnemies[p1].end()) {\\n        outcome = false;\\n      } else if (c1 != -1 && c2 != -1) {\\n        if (c1 == c2) {\\n          outcome = true;\\n        } else if (cliqueToEnemyCliques[c1].find(c2) !=\\n                   cliqueToEnemyCliques[c1].end()) {\\n          outcome = false;\\n        } else if (cliqueToEnemies[c1].find(p2) != cliqueToEnemies[c1].end()) {\\n          outcome = false;\\n        }\\n      } else if (c1 != -1) {\\n        if (cliqueToEnemies[c1].find(p2) != cliqueToEnemies[c1].end()) {\\n          outcome = false;\\n        }\\n      } else if (c2 != -1) {\\n        if (cliqueToEnemies[c2].find(p1) != cliqueToEnemies[c2].end()) {\\n          outcome = false;\\n        }\\n      }\\n      \\n      if (outcome) {\\n        if (c1 != -1 && c2 != -1) {\\n          cliqueToClique[c1] = c2;\\n        } else if (c1 != -1) {\\n          personToClique[p2] = c1;\\n        } else if (c2 != -1) {\\n          personToClique[p1] = c2;\\n        } else {\\n          personToClique[p1] = numCliques;\\n          personToClique[p2] = numCliques;\\n          numCliques++;\\n        }\\n      } else {\\n        personToEnemies[p1].insert(p2);\\n        personToEnemies[p2].insert(p1);\\n        if (c1 != -1 && c2 != -1) {\\n          cliqueToEnemyCliques[c1].insert(c2);\\n          cliqueToEnemyCliques[c2].insert(c1);\\n          personToEnemyCliques[p1].insert(c2);\\n          personToEnemyCliques[p2].insert(c1);\\n        } else if (c1 != -1) {\\n          personToClique[p2] = numCliques;\\n          numCliques++;\\n          \\n          cliqueToEnemies[c1].insert(p2);\\n          personToEnemyCliques[p2].insert(c1);\\n        } else if (c2 != -1) {\\n          personToClique[p1] = numCliques;\\n          numCliques++;\\n          \\n          cliqueToEnemies[c2].insert(p1);\\n          personToEnemyCliques[p1].insert(c2);\\n        } else {\\n          personToClique[p1] = numCliques;\\n          numCliques++;\\n          personToClique[p2] = numCliques;\\n          numCliques++;\\n        }\\n      }\\n\\n      c1 = getCliqueForPerson(p1, personToClique, cliqueToClique,\\n                              personToEnemies,\\n                              personToEnemyCliques,\\n                              cliqueToEnemies,\\n                              cliqueToEnemyCliques);\\n      c2 = getCliqueForPerson(p2, personToClique, cliqueToClique,\\n                              personToEnemies,\\n                              personToEnemyCliques,\\n                              cliqueToEnemies,\\n                              cliqueToEnemyCliques);\\n\\n      result[i] = outcome;\\n    }\\n    return result;\\n  }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1589411,
                "title": "python-explanation-faster-than-99",
                "content": "```\\nclass Solution:\\n    def friendRequests(self, n: int, restrictions: List[List[int]], requests: List[List[int]]) -> List[bool]:\\n        \\n        solution = []\\n        \\n        node_node = {i:set() for i in range(n)} # mapping of node to the nodes it has restrictions with\\n        \\n        node_component = {i:-1 for i in range(n)} # mapping of node to the component ID it belongs to\\n        \\n        components = {} # mapping of the different components to their component ID\\n        \\n        for edge in restrictions:\\n            u,v = edge\\n            node_node[u].add(v)\\n            node_node[v].add(u)\\n            \\n        for request in requests:\\n            u,v = request\\n            \\n            # if neither are in a component, make new component with this edge\\n            if node_component[u] == -1 and node_component[v] == -1:\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# check if direct restriction exists\\n                if u not in node_node[v] and v not in node_node[u]:\\n                    min_node = min(u,v)\\n                    node_component[u] = min_node\\n                    node_component[v] = min_node\\n                    components[min_node] = {u,v}\\n                    solution.append(True)\\n                else:\\n                    solution.append(False)\\n            \\n            # if both are in a component, check for indirect restrictions\\n            elif node_component[u] != -1 and node_component[v] != -1:\\n                component1 = components[node_component[u]]\\n                component2 = components[node_component[v]]\\n                flag = True\\n                \\n\\t\\t\\t\\t# check if both belong to the same component\\n                if node_component[u] == node_component[v]:\\n                    solution.append(True)\\n                    flag = False\\n                \\n\\t\\t\\t\\t\\n                # for every node in 1 component check every node in the other component for restrictions\\n                if flag:\\n                    for node in component1:\\n                        if len(node_node[node].intersection(component2)) != 0:\\n                            solution.append(False)\\n                            flag = False\\n                            break\\n                if flag:\\n                    for node in component2:\\n                        if len(node_node[node].intersection(component1)) != 0:\\n                            solution.append(False)\\n                            flag = False\\n                            break\\n\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t# if no restriction, union their two components and delete one component\\n                if flag:\\n                    min_node = min(node_component[u],node_component[v])\\n                    max_node = max(node_component[u],node_component[v])\\n                    components[min_node].update(components[max_node])\\n                    for node in components[max_node]:\\n                        node_component[node] = min_node\\n                    del components[max_node]\\n                    solution.append(True)\\n            \\n            # if only one is in a component\\n            else:\\n                # check if the node without a component has an issue with the nodes in the other component\\n                if node_component[u] == -1:\\n                    res = (len(node_node[u].intersection(components[node_component[v]])) != 0)\\n                    if res:\\n                        solution.append(False)\\n                    else:\\n                        components[node_component[v]].add(u)\\n                        node_component[u] = node_component[v]\\n                        solution.append(True)\\n                else:\\n                    res = (len(node_node[v].intersection(components[node_component[u]])) != 0)\\n                    if res:\\n                        solution.append(False)\\n                    else:\\n                        components[node_component[u]].add(v)\\n                        node_component[v] = node_component[u]\\n                        solution.append(True)\\n\\n        return solution\\n```",
                "solutionTags": [
                    "Python",
                    "Union Find"
                ],
                "code": "```\\nclass Solution:\\n    def friendRequests(self, n: int, restrictions: List[List[int]], requests: List[List[int]]) -> List[bool]:\\n        \\n        solution = []\\n        \\n        node_node = {i:set() for i in range(n)} # mapping of node to the nodes it has restrictions with\\n        \\n        node_component = {i:-1 for i in range(n)} # mapping of node to the component ID it belongs to\\n        \\n        components = {} # mapping of the different components to their component ID\\n        \\n        for edge in restrictions:\\n            u,v = edge\\n            node_node[u].add(v)\\n            node_node[v].add(u)\\n            \\n        for request in requests:\\n            u,v = request\\n            \\n            # if neither are in a component, make new component with this edge\\n            if node_component[u] == -1 and node_component[v] == -1:\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# check if direct restriction exists\\n                if u not in node_node[v] and v not in node_node[u]:\\n                    min_node = min(u,v)\\n                    node_component[u] = min_node\\n                    node_component[v] = min_node\\n                    components[min_node] = {u,v}\\n                    solution.append(True)\\n                else:\\n                    solution.append(False)\\n            \\n            # if both are in a component, check for indirect restrictions\\n            elif node_component[u] != -1 and node_component[v] != -1:\\n                component1 = components[node_component[u]]\\n                component2 = components[node_component[v]]\\n                flag = True\\n                \\n\\t\\t\\t\\t# check if both belong to the same component\\n                if node_component[u] == node_component[v]:\\n                    solution.append(True)\\n                    flag = False\\n                \\n\\t\\t\\t\\t\\n                # for every node in 1 component check every node in the other component for restrictions\\n                if flag:\\n                    for node in component1:\\n                        if len(node_node[node].intersection(component2)) != 0:\\n                            solution.append(False)\\n                            flag = False\\n                            break\\n                if flag:\\n                    for node in component2:\\n                        if len(node_node[node].intersection(component1)) != 0:\\n                            solution.append(False)\\n                            flag = False\\n                            break\\n\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t# if no restriction, union their two components and delete one component\\n                if flag:\\n                    min_node = min(node_component[u],node_component[v])\\n                    max_node = max(node_component[u],node_component[v])\\n                    components[min_node].update(components[max_node])\\n                    for node in components[max_node]:\\n                        node_component[node] = min_node\\n                    del components[max_node]\\n                    solution.append(True)\\n            \\n            # if only one is in a component\\n            else:\\n                # check if the node without a component has an issue with the nodes in the other component\\n                if node_component[u] == -1:\\n                    res = (len(node_node[u].intersection(components[node_component[v]])) != 0)\\n                    if res:\\n                        solution.append(False)\\n                    else:\\n                        components[node_component[v]].add(u)\\n                        node_component[u] = node_component[v]\\n                        solution.append(True)\\n                else:\\n                    res = (len(node_node[v].intersection(components[node_component[u]])) != 0)\\n                    if res:\\n                        solution.append(False)\\n                    else:\\n                        components[node_component[u]].add(v)\\n                        node_component[v] = node_component[u]\\n                        solution.append(True)\\n\\n        return solution\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1588082,
                "title": "c-union-find-soln",
                "content": "1. First step iterate  requests from 1 to n;\\n2. find the parent of u and v(requests[i][0],requests[i][1]),suppose parent a and b respectively.\\n3. if(a==b) ---> (u,v) requests valid=true , and push into the vector and continue for other requests.\\n4. else iterate restrictions from 1 to m;\\n5. find the parent of u1,v1(restrictions[i][0],restrictions[i][1]) ,suppose parents a1,b1 respectively\\n6.    if(a1==a && b1==b || a1==b && b1==a || (u==u1 && v==v1)|| (u==v1&& v==u1))--> valid=false and break the inner loop\\n7.    Now if valid==true --> then take union parent[b]=a and push the valid into vector\\n8.    final step return vector\\n\\n\\n\\nclass Solution {\\npublic:\\n    \\n    vector<int>parent;\\n    int find_set(int u)\\n    {\\n        if(parent[u]==u)\\n            return u;\\n        return  find_set(parent[u]);\\n    }\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests)\\n    {\\n        for(int i=0;i<n;i++)\\n        {\\n            parent.push_back(i);\\n        }\\n        vector<bool>res;\\n        \\n        for(int i=0;i<requests.size();i++)\\n        {\\n            int u=requests[i][0];\\n            int v=requests[i][1];\\n            int a=find_set(u);\\n            int b=find_set(v);\\n            bool valid=true;\\n            if(a==b)\\n            {\\n                valid=true;\\n                res.push_back(valid);\\n                continue;\\n            }\\n            for(int j=0;j<restrictions.size();j++)\\n            {\\n                int u1=restrictions[j][0];\\n                int v1=restrictions[j][1];\\n                int a1=find_set(u1);\\n                int b1=find_set(v1);\\n                if(a1==a && b1==b || a1==b && b1==a || (u==u1 && v==v1)|| (u==v1&& v==u1))\\n                {\\n                    res.push_back(false);\\n                    valid =false;\\n                    break;\\n                }\\n            }\\n            if(valid==true)\\n            {\\n                res.push_back(true);\\n                parent[b]=a;\\n            }\\n                \\n        }\\n        return res;\\n        \\n    }\\n};",
                "solutionTags": [
                    "Union Find"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    vector<int>parent;\\n    int find_set(int u)\\n    {\\n        if(parent[u]==u)\\n            return u;\\n        return  find_set(parent[u]);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1588016,
                "title": "c-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        int r_i = 0;\\n        vector<bool> ans;\\n        for(auto& v : requests) {\\n            int a = v[0], b = v[1];\\n            bool is_possible = 1;\\n            for(auto& r : restrictions) {\\n                int x = r[0], y = r[1];\\n                if((a == x && b == y) || (a == y && b == x)) {\\n                    is_possible = false;\\n                    break;\\n                }\\n            }\\n            \\n            if(is_possible) {\\n                for(int i = r_i+1; i < requests.size(); i++) {\\n                    if(requests[i][0] == a) requests[i][0] = b;\\n                    if(requests[i][1] == a) requests[i][1] = b;\\n                }\\n                \\n                for(int i = 0; i < restrictions.size(); i++) {\\n                    if(restrictions[i][0] == a) restrictions[i][0] = b;\\n                    if(restrictions[i][1] == a) restrictions[i][1] = b;\\n                }\\n            }\\n            \\n            ans.push_back(is_possible);\\n            r_i++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        int r_i = 0;\\n        vector<bool> ans;\\n        for(auto& v : requests) {\\n            int a = v[0], b = v[1];\\n            bool is_possible = 1;\\n            for(auto& r : restrictions) {\\n                int x = r[0], y = r[1];\\n                if((a == x && b == y) || (a == y && b == x)) {\\n                    is_possible = false;\\n                    break;\\n                }\\n            }\\n            \\n            if(is_possible) {\\n                for(int i = r_i+1; i < requests.size(); i++) {\\n                    if(requests[i][0] == a) requests[i][0] = b;\\n                    if(requests[i][1] == a) requests[i][1] = b;\\n                }\\n                \\n                for(int i = 0; i < restrictions.size(); i++) {\\n                    if(restrictions[i][0] == a) restrictions[i][0] = b;\\n                    if(restrictions[i][1] == a) restrictions[i][1] = b;\\n                }\\n            }\\n            \\n            ans.push_back(is_possible);\\n            r_i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1880136,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "in example 3 [3,1] should be false as 0 ,1,2,3 are connected through restrictions itself\\nwhat am i missing ? thanks"
                    },
                    {
                        "username": "czjnbb",
                        "content": "1 and 3 can be friend. Before the [3,1] friend request, friends groups are: (0,4), (1), (2), (3); and (0,4), (1,3), (2) won't violate any of the restrictions."
                    },
                    {
                        "username": "rohit__27",
                        "content": "Google , Hard, lengthy .... \nfrom laid back to fully focused !!\n"
                    }
                ]
            },
            {
                "id": 1774271,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "in example 3 [3,1] should be false as 0 ,1,2,3 are connected through restrictions itself\\nwhat am i missing ? thanks"
                    },
                    {
                        "username": "czjnbb",
                        "content": "1 and 3 can be friend. Before the [3,1] friend request, friends groups are: (0,4), (1), (2), (3); and (0,4), (1,3), (2) won't violate any of the restrictions."
                    },
                    {
                        "username": "rohit__27",
                        "content": "Google , Hard, lengthy .... \nfrom laid back to fully focused !!\n"
                    }
                ]
            }
        ]
    },
    {
        "title": "Paths in Maze That Lead to Same Room",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1722898,
                "content": [
                    {
                        "username": "RohitSgh",
                        "content": "**Question :** Let `n` be $V$, and `corridors.length` be $E$. What will be the best Time Complexity for this problem **?**"
                    },
                    {
                        "username": "Soumya_The_Legend",
                        "content": " `class Solution {\\npublic:\\n    void dfs(int node, vector<int>& vis, vector<vector<int>>& adjList, int connectedCorners, int connectedEdges){\\n        vis[node] = 1;\\n        connectedEdges += adjList[node].size();\\n        connectedCorners++;\\n        for(auto a : adjList[node]){\\n            if(!vis[a]) dfs(a, vis, adjList, connectedCorners, connectedEdges);\\n        }\\n    }\\npublic:\\n    int numberOfPaths(int n, vector<vector<int>>& corridors) {\\n        //so the corridors are basically the undirected edges in the graph\\n        //number of different cycles of lenght 3 is the number of complete components\\n        //that have the number of edges 3\\n        int k = corridors.size();\\n        vector<vector<int>> adjList(n);\\n        for(int i=0; i< k; i++){\\n            adjList[corridors[i][0] - 1].push_back(corridors[i][1] - 1);\\n            adjList[corridors[i][1] - 1].push_back(corridors[i][0] - 1);\\n        }\\n        vector<int> vis(n, 0);\\n        int confusionScore = 0;\\n        for(int i=0; i< n; i++){\\n            if(!vis[i]){\\n                int connectedCorners = 0;\\n                int connectedEdges = 0;\\n                dfs(i, vis, adjList, connectedCorners, connectedEdges);\\n                if((connectedCorners*(connectedCorners-1) == connectedEdges) && (connectedCorners == 3)) confusionScore++;\\n            }\\n        }\\n        return confusionScore;\\n    }\\n};\\nCan anyone tell me where I went wrong???\\n\\n"
                    }
                ]
            },
            {
                "id": 2015514,
                "content": [
                    {
                        "username": "RohitSgh",
                        "content": "**Question :** Let `n` be $V$, and `corridors.length` be $E$. What will be the best Time Complexity for this problem **?**"
                    },
                    {
                        "username": "Soumya_The_Legend",
                        "content": " `class Solution {\\npublic:\\n    void dfs(int node, vector<int>& vis, vector<vector<int>>& adjList, int connectedCorners, int connectedEdges){\\n        vis[node] = 1;\\n        connectedEdges += adjList[node].size();\\n        connectedCorners++;\\n        for(auto a : adjList[node]){\\n            if(!vis[a]) dfs(a, vis, adjList, connectedCorners, connectedEdges);\\n        }\\n    }\\npublic:\\n    int numberOfPaths(int n, vector<vector<int>>& corridors) {\\n        //so the corridors are basically the undirected edges in the graph\\n        //number of different cycles of lenght 3 is the number of complete components\\n        //that have the number of edges 3\\n        int k = corridors.size();\\n        vector<vector<int>> adjList(n);\\n        for(int i=0; i< k; i++){\\n            adjList[corridors[i][0] - 1].push_back(corridors[i][1] - 1);\\n            adjList[corridors[i][1] - 1].push_back(corridors[i][0] - 1);\\n        }\\n        vector<int> vis(n, 0);\\n        int confusionScore = 0;\\n        for(int i=0; i< n; i++){\\n            if(!vis[i]){\\n                int connectedCorners = 0;\\n                int connectedEdges = 0;\\n                dfs(i, vis, adjList, connectedCorners, connectedEdges);\\n                if((connectedCorners*(connectedCorners-1) == connectedEdges) && (connectedCorners == 3)) confusionScore++;\\n            }\\n        }\\n        return confusionScore;\\n    }\\n};\\nCan anyone tell me where I went wrong???\\n\\n"
                    }
                ]
            }
        ]
    },
    {
        "title": "Two Furthest Houses With Different Colors",
        "question_content": "<p>There are <code>n</code> houses evenly lined up on the street, and each house is beautifully painted. You are given a <strong>0-indexed</strong> integer array <code>colors</code> of length <code>n</code>, where <code>colors[i]</code> represents the color of the <code>i<sup>th</sup></code> house.</p>\n\n<p>Return <em>the <strong>maximum</strong> distance between <strong>two</strong> houses with <strong>different</strong> colors</em>.</p>\n\n<p>The distance between the <code>i<sup>th</sup></code> and <code>j<sup>th</sup></code> houses is <code>abs(i - j)</code>, where <code>abs(x)</code> is the <strong>absolute value</strong> of <code>x</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/10/31/eg1.png\" style=\"width: 610px; height: 84px;\" />\n<pre>\n<strong>Input:</strong> colors = [<u><strong>1</strong></u>,1,1,<strong><u>6</u></strong>,1,1,1]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> In the above image, color 1 is blue, and color 6 is red.\nThe furthest two houses with different colors are house 0 and house 3.\nHouse 0 has color 1, and house 3 has color 6. The distance between them is abs(0 - 3) = 3.\nNote that houses 3 and 6 can also produce the optimal answer.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/10/31/eg2.png\" style=\"width: 426px; height: 84px;\" />\n<pre>\n<strong>Input:</strong> colors = [<u><strong>1</strong></u>,8,3,8,<u><strong>3</strong></u>]\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> In the above image, color 1 is blue, color 8 is yellow, and color 3 is green.\nThe furthest two houses with different colors are house 0 and house 4.\nHouse 0 has color 1, and house 4 has color 3. The distance between them is abs(0 - 4) = 4.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> colors = [<u><strong>0</strong></u>,<strong><u>1</u></strong>]\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> The furthest two houses with different colors are house 0 and house 1.\nHouse 0 has color 0, and house 1 has color 1. The distance between them is abs(0 - 1) = 1.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n ==&nbsp;colors.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 100</code></li>\n\t<li><code>0 &lt;= colors[i] &lt;= 100</code></li>\n\t<li>Test data are generated such that <strong>at least</strong> two houses have different colors.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 1589141,
                "title": "java-c-python-o-n-solution",
                "content": "# **Intuition**\\nThe first and the last house can be one of the furthest houses.\\n<br>\\n\\n# **Complexity**\\nTime `O(n)`\\nSpace `O(1)`\\n<br>\\n\\n# **Solution 1**\\nFind the last house with different color of the fisrt house.\\nFind the first house with different color of the last house.\\nReturn the max distance of these two options.\\n\\n**Java**\\n```java\\n    public int maxDistance(int[] A) {\\n        int n = A.length, i = 0, j = n - 1;\\n        while (A[0] == A[j]) j--;\\n        while (A[n - 1] == A[i]) i++;\\n        return Math.max(n - 1 - i, j);\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    int maxDistance(vector<int>& A) {\\n        int n = A.size(), i = 0, j = n - 1;\\n        while (A[0] == A[j]) j--;\\n        while (A[n - 1] == A[i]) i++;\\n        return max(n - 1 - i, j);\\n    }\\n```\\n\\n**Python**\\n```py\\n    def maxDistance(self, A):\\n        i, j = 0, len(A) - 1\\n        while A[0] == A[j]: j -= 1\\n        while A[-1] == A[i]: i += 1\\n        return max(len(A) - 1 - i, j)\\n```\\n\\n# **Solution 2**\\nIdea from @ye15\\nIterate all element,\\nand check its color with the first and the last house.\\n\\n**Java**\\n```java\\n    public int maxDistance(int[] A) {\\n        int res = 0, n = A.length;\\n        for (int i = 0; i < n; ++i) {\\n            if (A[i] != A[0])\\n                res = Math.max(res, i);\\n            if (A[i] != A[n - 1])\\n                res = Math.max(res, n - 1 - i);\\n        }\\n        return res;\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    int maxDistance(vector<int>& A) {\\n        int res = 0, n = A.size();\\n        for (int i = 0; i < n; ++i) {\\n            if (A[i] != A[0])\\n                res = max(res, i);\\n            if (A[i] != A[n - 1])\\n                res = max(res, n - 1 - i);\\n        }\\n        return res;\\n    }\\n```\\n\\n**Python**\\n```py\\n    def maxDistance(self, A):\\n        res = 0\\n        for i, x in enumerate(A):\\n            if x != A[0]:\\n                res = max(res, i)\\n            if x != A[-1]:\\n                res = max(res, len(A) - 1 - i)\\n        return res\\n```\\n",
                "solutionTags": [],
                "code": "```java\\n    public int maxDistance(int[] A) {\\n        int n = A.length, i = 0, j = n - 1;\\n        while (A[0] == A[j]) j--;\\n        while (A[n - 1] == A[i]) i++;\\n        return Math.max(n - 1 - i, j);\\n    }\\n```\n```cpp\\n    int maxDistance(vector<int>& A) {\\n        int n = A.size(), i = 0, j = n - 1;\\n        while (A[0] == A[j]) j--;\\n        while (A[n - 1] == A[i]) i++;\\n        return max(n - 1 - i, j);\\n    }\\n```\n```py\\n    def maxDistance(self, A):\\n        i, j = 0, len(A) - 1\\n        while A[0] == A[j]: j -= 1\\n        while A[-1] == A[i]: i += 1\\n        return max(len(A) - 1 - i, j)\\n```\n```java\\n    public int maxDistance(int[] A) {\\n        int res = 0, n = A.length;\\n        for (int i = 0; i < n; ++i) {\\n            if (A[i] != A[0])\\n                res = Math.max(res, i);\\n            if (A[i] != A[n - 1])\\n                res = Math.max(res, n - 1 - i);\\n        }\\n        return res;\\n    }\\n```\n```cpp\\n    int maxDistance(vector<int>& A) {\\n        int res = 0, n = A.size();\\n        for (int i = 0; i < n; ++i) {\\n            if (A[i] != A[0])\\n                res = max(res, i);\\n            if (A[i] != A[n - 1])\\n                res = max(res, n - 1 - i);\\n        }\\n        return res;\\n    }\\n```\n```py\\n    def maxDistance(self, A):\\n        res = 0\\n        for i, x in enumerate(A):\\n            if x != A[0]:\\n                res = max(res, i)\\n            if x != A[-1]:\\n                res = max(res, len(A) - 1 - i)\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1589029,
                "title": "constant-space",
                "content": "The maximum distance will always include either first or the last house. This can be proven by a contradiction.\\n\\nTherefore, we need to return the maximum of two cases: `max(j, n - i - 1)`, where\\n- `i` is the leftmost position of the color different from the last color.\\n- `j` is the rightmost position of the color different from the first one.\\n\\n![image](https://assets.leetcode.com/users/images/e6c7f77b-1f76-4ec8-9488-43a197994d62_1637524109.6583953.png)\\n\\n**C++**\\n```cpp\\nint maxDistance(vector<int>& cs) {\\n    int n = cs.size(), i = 0, j = n - 1;\\n    while (cs[0] == cs[j])\\n        --j;\\n    while (cs[n - 1] == cs[i])\\n        ++i;\\n    return max(j, n - i - 1);\\n}\\n```\\n**Java**\\n```java\\npublic int maxDistance(int[] cs) {\\n    int n = cs.length, i = 0, j = n - 1;\\n    while (cs[0] == cs[j])\\n        --j;\\n    while (cs[n - 1] == cs[i])\\n        ++i;\\n    return Math.max(j, n - i - 1);     \\n}\\n```\\n\\n#### Alternative Solution\\nWe only care about two positions: `0` for the first color, and the first position for some other color (`p`).\\n\\nIt works since we are looking for a maximum distance:\\n- If color `i` is different than the first one, the maximum distance is `i`.\\n- If color `i` is the same as the first one, the maximum distance is `i - p`.\\n\\n**Python 3**\\n```python\\nclass Solution:\\n    def maxDistance(self, colors: List[int]) -> int:\\n        p, res = inf, 0\\n        for i, c in enumerate(colors):\\n            if (c != colors[0]):\\n                res = i\\n                p = min(p, i)\\n            else:\\n                res = max(res, i - p)\\n        return res\\n```\\n**C++**\\n```cpp\\nint maxDistance(vector<int>& cs) {\\n    int p = INT_MAX, res = 1;\\n    for (int i = 1; i < cs.size(); ++i) {\\n        if (cs[i] != cs[0])\\n            p = min(i, p);\\n        res = max({res, cs[i] == cs[0] ? 0 : i, i - p });\\n    }\\n    return res;\\n}\\n```\\n**Java**\\n```java\\npublic int maxDistance(int[] cs) {\\n    int p_col2 = Integer.MAX_VALUE, res = 1;\\n    for (int i = 1; i < cs.length; ++i) {\\n        if (cs[i] != cs[0]) {\\n            p_col2 = Math.min(i, p_col2);\\n            res = i;\\n        }\\n        else\\n            res = Math.max(res, i - p_col2);\\n    }\\n    return res;        \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "C"
                ],
                "code": "```cpp\\nint maxDistance(vector<int>& cs) {\\n    int n = cs.size(), i = 0, j = n - 1;\\n    while (cs[0] == cs[j])\\n        --j;\\n    while (cs[n - 1] == cs[i])\\n        ++i;\\n    return max(j, n - i - 1);\\n}\\n```\n```java\\npublic int maxDistance(int[] cs) {\\n    int n = cs.length, i = 0, j = n - 1;\\n    while (cs[0] == cs[j])\\n        --j;\\n    while (cs[n - 1] == cs[i])\\n        ++i;\\n    return Math.max(j, n - i - 1);     \\n}\\n```\n```python\\nclass Solution:\\n    def maxDistance(self, colors: List[int]) -> int:\\n        p, res = inf, 0\\n        for i, c in enumerate(colors):\\n            if (c != colors[0]):\\n                res = i\\n                p = min(p, i)\\n            else:\\n                res = max(res, i - p)\\n        return res\\n```\n```cpp\\nint maxDistance(vector<int>& cs) {\\n    int p = INT_MAX, res = 1;\\n    for (int i = 1; i < cs.size(); ++i) {\\n        if (cs[i] != cs[0])\\n            p = min(i, p);\\n        res = max({res, cs[i] == cs[0] ? 0 : i, i - p });\\n    }\\n    return res;\\n}\\n```\n```java\\npublic int maxDistance(int[] cs) {\\n    int p_col2 = Integer.MAX_VALUE, res = 1;\\n    for (int i = 1; i < cs.length; ++i) {\\n        if (cs[i] != cs[0]) {\\n            p_col2 = Math.min(i, p_col2);\\n            res = i;\\n        }\\n        else\\n            res = Math.max(res, i - p_col2);\\n    }\\n    return res;        \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1591355,
                "title": "c-simple-4-line-solution-o-n-tc-o-1-tc-explained",
                "content": "**Explanation:**\\nWe are guaranteed to have at least two houses with different colors.\\nThe biggest distance with probably be the first house or the last house, with some other one.\\nSo in the first loop we find the leftmost house that has a different color from the last house.\\nIn the second loop we find the rightmost house that has a different color from the first house.\\nWe return the maximum between both.\\n\\n**Time Complexity:** O(n)\\n**Space Complexity:** O(1)\\n```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        int from_left = 0, n = colors.size(), from_right = n - 1;\\n        while (colors[from_left] == colors[n-1]) from_left++;\\n        while (colors[from_right] == colors[0]) from_right--;\\n        return max(from_right, n-from_left-1);\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        int from_left = 0, n = colors.size(), from_right = n - 1;\\n        while (colors[from_left] == colors[n-1]) from_left++;\\n        while (colors[from_right] == colors[0]) from_right--;\\n        return max(from_right, n-from_left-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1589119,
                "title": "python3-one-of-end-points-will-be-used",
                "content": "Downvoters, lease a comment! \\n\\nIt is not difficult to find out that at least one of the end points will be used. \\n\\nPlease check out this [commit](https://github.com/gaosanyong/leetcode/commit/b5ca73e6f7d317e9f30f7e67a499b0bf489ec019) for the solutions of weekly 268. \\n```\\nclass Solution:\\n    def maxDistance(self, colors: List[int]) -> int:\\n        ans = 0 \\n        for i, x in enumerate(colors): \\n            if x != colors[0]: ans = max(ans, i)\\n            if x != colors[-1]: ans = max(ans, len(colors)-1-i)\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxDistance(self, colors: List[int]) -> int:\\n        ans = 0 \\n        for i, x in enumerate(colors): \\n            if x != colors[0]: ans = max(ans, i)\\n            if x != colors[-1]: ans = max(ans, len(colors)-1-i)\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1589010,
                "title": "c-o-n-time-one-pass",
                "content": "\\n\\nSee my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n\\n## Solution 1. Map\\n\\nFor each `A[i]`:\\n* If this is the first occurrence of this value, store `A[i] -> i` in a map `m`.\\n* Loop through each `num, index` pair the map `m` and calculate the maximum `i - index` value if `num != A[i]`.\\n\\n```cpp\\n// OJ: https://leetcode.com/contest/weekly-contest-268/problems/two-furthest-houses-with-different-colors/\\n// Author: github.com/lzl124631x\\n// Time: O(NM) where `N` is the length of `A` and `M` is the range of numbers in `A`.\\n// Space: O(M)\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& A) {\\n        unordered_map<int, int> m; // first occurrence index\\n        int ans = 0;\\n        for (int i = 0; i < A.size(); ++i) {\\n            if (m.count(A[i]) == 0) m[A[i]] = i;\\n            for (auto &[c, j] : m) {\\n                if (c != A[i]) {\\n                    ans = max(ans, i - j);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nOr use array.\\n\\n```cpp\\n// OJ: https://leetcode.com/contest/weekly-contest-268/problems/two-furthest-houses-with-different-colors/\\n// Author: github.com/lzl124631x\\n// Time: O(NM) where `N` is the length of `A` and `M` is the range of numbers in `A`.\\n// Space: O(M)\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& A) {\\n        int ans = 0, index[101] = {[0 ... 100] = -1};\\n        for (int i = 0; i < A.size(); ++i) {\\n            if (index[A[i]] == -1) index[A[i]] = i;\\n            for (int j = 0; j <= 100; ++j) {\\n                if (index[j] != -1 && j != A[i]) {\\n                    ans = max(ans, i - index[j]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n## Solution 2. Mono-increasing Index Array\\n\\nFor each `A[i]`:\\n* If this is the first occurrence of this value, push `i` into a `vector<int> index`.\\n* Loop through each index value `j` in `index` array, and update answer with `i - j` for the first `A[j] != A[i]`. This step at most looks at two indices, so it\\'s `O(1)` time.\\n\\n```cpp\\n// OJ: https://leetcode.com/contest/weekly-contest-268/problems/two-furthest-houses-with-different-colors/\\n// Author: github.com/lzl124631x\\n// Time: O(N) where `N` is the length of `A` and `M` is the range of numbers in `A`.\\n// Space: O(M)\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& A) {\\n        vector<int> index; // first occurrence index\\n        int ans = 0, seen[101] = {};\\n        for (int i = 0; i < A.size(); ++i) {\\n            if (!seen[i]) {\\n                seen[i] = 1;\\n                index.push_back(i);\\n            }\\n            for (int j : index) {\\n                if (A[j] != A[i]) {\\n                    ans = max(ans, i - j);\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/contest/weekly-contest-268/problems/two-furthest-houses-with-different-colors/\\n// Author: github.com/lzl124631x\\n// Time: O(NM) where `N` is the length of `A` and `M` is the range of numbers in `A`.\\n// Space: O(M)\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& A) {\\n        unordered_map<int, int> m; // first occurrence index\\n        int ans = 0;\\n        for (int i = 0; i < A.size(); ++i) {\\n            if (m.count(A[i]) == 0) m[A[i]] = i;\\n            for (auto &[c, j] : m) {\\n                if (c != A[i]) {\\n                    ans = max(ans, i - j);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```cpp\\n// OJ: https://leetcode.com/contest/weekly-contest-268/problems/two-furthest-houses-with-different-colors/\\n// Author: github.com/lzl124631x\\n// Time: O(NM) where `N` is the length of `A` and `M` is the range of numbers in `A`.\\n// Space: O(M)\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& A) {\\n        int ans = 0, index[101] = {[0 ... 100] = -1};\\n        for (int i = 0; i < A.size(); ++i) {\\n            if (index[A[i]] == -1) index[A[i]] = i;\\n            for (int j = 0; j <= 100; ++j) {\\n                if (index[j] != -1 && j != A[i]) {\\n                    ans = max(ans, i - index[j]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```cpp\\n// OJ: https://leetcode.com/contest/weekly-contest-268/problems/two-furthest-houses-with-different-colors/\\n// Author: github.com/lzl124631x\\n// Time: O(N) where `N` is the length of `A` and `M` is the range of numbers in `A`.\\n// Space: O(M)\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& A) {\\n        vector<int> index; // first occurrence index\\n        int ans = 0, seen[101] = {};\\n        for (int i = 0; i < A.size(); ++i) {\\n            if (!seen[i]) {\\n                seen[i] = 1;\\n                index.push_back(i);\\n            }\\n            for (int j : index) {\\n                if (A[j] != A[i]) {\\n                    ans = max(ans, i - j);\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908014,
                "title": "90-o-n-fast-easy-2-pointer-greedy",
                "content": "Easiest way to do a scan like this is with two pointers. Fix a left pointer, and while they\\'re equal, move the right pointer from the end, inward until they arent. Then, take the distance by index. However, that will only solve the example cases. To correctly solve an edge case (where Greedy comes in to play), do the same thing but from the other end. Fix the right pointer at the end and move the left pointer by one every time. Since you\\'re making two separate passes, time complexity isn\\'t compounding so it is just O(n). No extra space, either O(1). \\n![image](https://assets.leetcode.com/users/images/00d1685d-6a91-4a26-b2c3-6e6d3f8d7593_1648929985.1841433.png)\\n\\n```\\nclass Solution:\\n    def maxDistance(self, colors: List[int]) -> int:\\n\\t\\t#first pass\\n        l, r = 0, len(colors)-1\\n        dist = 0\\n        \\n        while r > l:\\n            if colors[r] != colors[l]:\\n                dist = r-l\\n\\t\\t\\t\\t#slight performance increase, break out if you find it \\n\\t\\t\\t\\t#because it can\\'t get bigger than this\\n                break \\n            r -= 1\\n\\t\\t\\t\\n        #second pass, backwards\\n        l, r = 0, len(colors)-1\\n        while r > l:\\n            if colors[r] != colors[l]:\\n                dist = max(dist, r-l)\\n                break\\n            l += 1\\n        \\n        return dist\\n\\t\\n\\t",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers",
                    "Greedy"
                ],
                "code": "Easiest way to do a scan like this is with two pointers. Fix a left pointer, and while they\\'re equal, move the right pointer from the end, inward until they arent. Then, take the distance by index. However, that will only solve the example cases. To correctly solve an edge case (where Greedy comes in to play), do the same thing but from the other end. Fix the right pointer at the end and move the left pointer by one every time. Since you\\'re making two separate passes, time complexity isn\\'t compounding so it is just O(n). No extra space, either O(1). \\n![image](https://assets.leetcode.com/users/images/00d1685d-6a91-4a26-b2c3-6e6d3f8d7593_1648929985.1841433.png)\\n\\n```\\nclass Solution:\\n    def maxDistance(self, colors: List[int]) -> int:\\n\\t\\t#first pass\\n        l, r = 0, len(colors)-1\\n        dist = 0\\n        \\n        while r > l:\\n            if colors[r] != colors[l]:\\n                dist = r-l\\n\\t\\t\\t\\t#slight performance increase, break out if you find it \\n\\t\\t\\t\\t#because it can\\'t get bigger than this\\n                break \\n            r -= 1\\n\\t\\t\\t\\n        #second pass, backwards\\n        l, r = 0, len(colors)-1\\n        while r > l:\\n            if colors[r] != colors[l]:\\n                dist = max(dist, r-l)\\n                break\\n            l += 1\\n        \\n        return dist\\n\\t\\n\\t",
                "codeTag": "Java"
            },
            {
                "id": 1663289,
                "title": "easy-python-solution",
                "content": "```\\ndef maxDistance(self, colors: List[int]) -> int:\\n        m=0\\n        for i in range(0,len(colors)):\\n            for j in range(len(colors)-1,0,-1):\\n                if colors[i]!=colors[j] and j>i:\\n                    m=max(m,j-i)\\n        return m\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef maxDistance(self, colors: List[int]) -> int:\\n        m=0\\n        for i in range(0,len(colors)):\\n            for j in range(len(colors)-1,0,-1):\\n                if colors[i]!=colors[j] and j>i:\\n                    m=max(m,j-i)\\n        return m\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1725518,
                "title": "beginner-friendly-java-solution",
                "content": "```\\nclass Solution {\\n    public int maxDistance(int[] colors) {\\n        int l = 0, r = colors.length-1;\\n        while(colors[colors.length-1] == colors[l]) l++;\\n        while(colors[0] == colors[r]) r--;\\n        return Math.max(r, colors.length - 1 - l);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDistance(int[] colors) {\\n        int l = 0, r = colors.length-1;\\n        while(colors[colors.length-1] == colors[l]) l++;\\n        while(colors[0] == colors[r]) r--;\\n        return Math.max(r, colors.length - 1 - l);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1596964,
                "title": "python-loop-from-both-sides",
                "content": "```\\n        l = 0\\n        r = len(colors) - 1\\n\\t\\tc_len = r\\n        while colors[l] == colors[r]:\\n            r -= 1\\n        while colors[c_len] == colors[l]:\\n            l += 1\\n        return max(r-0, c_len-l)\\n```",
                "solutionTags": [],
                "code": "```\\n        l = 0\\n        r = len(colors) - 1\\n\\t\\tc_len = r\\n        while colors[l] == colors[r]:\\n            r -= 1\\n        while colors[c_len] == colors[l]:\\n            l += 1\\n        return max(r-0, c_len-l)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1589851,
                "title": "2078-two-furthest-houses-with-different-colors",
                "content": "---\\n\\n- Contest - https://leetcode.com/contest/weekly-contest-268/\\n  - Q1 Answer\\n    - below\\n\\t\\t- O(N ^ 2) solution\\n\\t\\t- O(N) solution\\n          - https://leetcode.com/problems/two-furthest-houses-with-different-colors/discuss/1589851/2078.-Two-Furthest-Houses-With-Different-Colors\\n  - Q2 Answer\\n    - https://leetcode.com/problems/watering-plants/discuss/1589904/2079.-Watering-Plants\\n  - Q3 Answer\\n    - https://leetcode.com/problems/range-frequency-queries/discuss/1589775/2080.-Range-Frequency-Queries\\n  - Q4 Answer\\n    - https://leetcode.com/problems/sum-of-k-mirror-numbers/discuss/1590172/2081.-Sum-of-k-Mirror-Numbers\\n\\n---\\n\\nHope it is simple to understand.\\n\\n---\\n\\n**O(N ^ 2) solution**\\n\\n```\\nvar maxDistance = function (colors) {\\n    let n = colors.length;\\n\\n    let max = 0;\\n    for (let i = 0; i < n; i++) {\\n        for (let j = i + 1; j < n; j++) {\\n            if (colors[i] !== colors[j]) {\\n                max = Math.max(max, j - i);\\n            }\\n        }\\n    }\\n    return max;\\n};\\n```\\n\\n---\\n\\n**O(N) solution**\\n\\n- Credit:\\n  - https://leetcode-cn.com/for-you-9\\n  - See (`for-you-9` row, `Q1` column) at https://leetcode.com/contest/weekly-contest-268/ranking\\n\\n```\\nvar maxDistance = function (colors) {\\n    let n = colors.length;\\n\\n    let max = 0;\\n    for (let i = 0; i < n; i++) {\\n        if (colors[i] !== colors[0]) {\\n            max = Math.max(max, i);\\n        }\\n        if (colors[i] !== colors[n - 1]) {\\n            max = Math.max(max, n - 1 - i);\\n        }\\n    }\\n    return max;\\n};\\n```\\n\\n---\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maxDistance = function (colors) {\\n    let n = colors.length;\\n\\n    let max = 0;\\n    for (let i = 0; i < n; i++) {\\n        for (let j = i + 1; j < n; j++) {\\n            if (colors[i] !== colors[j]) {\\n                max = Math.max(max, j - i);\\n            }\\n        }\\n    }\\n    return max;\\n};\\n```\n```\\nvar maxDistance = function (colors) {\\n    let n = colors.length;\\n\\n    let max = 0;\\n    for (let i = 0; i < n; i++) {\\n        if (colors[i] !== colors[0]) {\\n            max = Math.max(max, i);\\n        }\\n        if (colors[i] !== colors[n - 1]) {\\n            max = Math.max(max, n - 1 - i);\\n        }\\n    }\\n    return max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3285318,
                "title": "3-liner-easy-to-understand-100-efficient-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        int n=colors.size(),i=0, j=n-1;\\n        while(colors[j]==colors[0]) j--;\\n        while(colors[i]==colors[n-1]) i++;\\n        return max(j,n-1-i);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        int n=colors.size(),i=0, j=n-1;\\n        while(colors[j]==colors[0]) j--;\\n        while(colors[i]==colors[n-1]) i++;\\n        return max(j,n-1-i);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2596331,
                "title": "java-beats-100-simple",
                "content": "```\\nclass Solution {\\n    public int maxDistance(int[] colors) {\\n        int j=colors.length-1;\\n        int i=0;\\n        while(colors[j]==colors[0])j--;\\n        while(colors[i]==colors[colors.length-1])i++;\\n        return Math.max(colors.length-i-1,j);\\n    }\\n}\\nPlease upvote if you like the solution \\uD83D\\uDE4F",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int maxDistance(int[] colors) {\\n        int j=colors.length-1;\\n        int i=0;\\n        while(colors[j]==colors[0])j--;\\n        while(colors[i]==colors[colors.length-1])i++;\\n        return Math.max(colors.length-i-1,j);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2209588,
                "title": "c-solution-0ms-100-faster-time-o-n-space-o-1-explained",
                "content": "**Method:**\\n\\n```\\nAs we know that, there will be least two houses with different colors.\\n* The maximum distance will always include either first or the last house. \\n* So in the first loop we find the leftmost house that has a different color from the last house.\\n* In the second loop we find the rightmost house that has a different color from the first house.\\n* return the minimum of both distances.\\n\\n```\\n\\n**Time Complexity:O(n)**\\n**Space Complexity:O(1)**\\n\\n**Code:**\\n\\n```\\nclass Solution\\n{\\npublic:\\n    int maxDistance(vector<int> &colors)\\n    {\\n        int n = colors.size();\\n        int from_start = 0;    //first index from the start which is different from the last element\\n        int from_end = n - 1;   //first index from the last which is different from the first element\\n        while (colors[0] == colors[from_end])\\n            from_end--;\\n        while (colors[n - 1] == colors[from_start])\\n            from_start++;\\n        return max(from_end, n - from_start - 1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers",
                    "Greedy"
                ],
                "code": "```\\nAs we know that, there will be least two houses with different colors.\\n* The maximum distance will always include either first or the last house. \\n* So in the first loop we find the leftmost house that has a different color from the last house.\\n* In the second loop we find the rightmost house that has a different color from the first house.\\n* return the minimum of both distances.\\n\\n```\n```\\nclass Solution\\n{\\npublic:\\n    int maxDistance(vector<int> &colors)\\n    {\\n        int n = colors.size();\\n        int from_start = 0;    //first index from the start which is different from the last element\\n        int from_end = n - 1;   //first index from the last which is different from the first element\\n        while (colors[0] == colors[from_end])\\n            from_end--;\\n        while (colors[n - 1] == colors[from_start])\\n            from_start++;\\n        return max(from_end, n - from_start - 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1779719,
                "title": "java-1ms-very-fast-and-easy-solution",
                "content": "In this Question it is required that we find out the maximum distance between two distinct numbers in an array.\\nFor this we can use the following approach which is an efficient way to find the required output.\\n\\n**Approach**\\n\\n*Step 1* :- First of all we run a loop from the *front* or the *left part of the Array.\\n\\n*Step 2* :- Then we run a nested loop from the *rear* side or the *right par* of the Array so that we can find the number which is not matching with the number we choosed in the front part.\\n\\n*Step 3* :- Then we check if the difference between there indices is gretear than the maximum difference or not.\\n\\n*Step 4* :- If yes then we store this difference in max\\n\\n```\\n\\n    public int maxDistance(int[] colors) {\\n        int m=0;\\n        for(int i=0;i<colors.length;i++)\\n        {\\n            for(int j=colors.length-1;j>=0;j--)\\n            {\\n                if(colors[i]!=colors[j])\\n                {\\n                    if(Math.abs(j-i)>m)\\n                        m=Math.abs(j-i);\\n                    break;\\n                }\\n            }\\n        }\\n        return m;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "In this Question it is required that we find out the maximum distance between two distinct numbers in an array.\\nFor this we can use the following approach which is an efficient way to find the required output.\\n\\n**Approach**\\n\\n*Step 1* :- First of all we run a loop from the *front* or the *left part of the Array.\\n\\n*Step 2* :- Then we run a nested loop from the *rear* side or the *right par* of the Array so that we can find the number which is not matching with the number we choosed in the front part.\\n\\n*Step 3* :- Then we check if the difference between there indices is gretear than the maximum difference or not.\\n\\n*Step 4* :- If yes then we store this difference in max\\n\\n```\\n\\n    public int maxDistance(int[] colors) {\\n        int m=0;\\n        for(int i=0;i<colors.length;i++)\\n        {\\n            for(int j=colors.length-1;j>=0;j--)\\n            {\\n                if(colors[i]!=colors[j])\\n                {\\n                    if(Math.abs(j-i)>m)\\n                        m=Math.abs(j-i);\\n                    break;\\n                }\\n            }\\n        }\\n        return m;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1775316,
                "title": "python3-both-side-checking-fastest",
                "content": "```\\nclass Solution:\\n    def maxDistance(self, colors: List[int]) -> int:\\n        clr1=colors[0]\\n        clr2=colors[-1]\\n        mx=0\\n        for i in range(len(colors)-1,-1,-1):\\n            if clr1!=colors[i]:\\n                mx=max(mx,i)\\n                break\\n        for i in range(len(colors)):\\n            if clr2!=colors[i]:\\n                mx=max(mx,len(colors)-i-1)\\n        return mx\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxDistance(self, colors: List[int]) -> int:\\n        clr1=colors[0]\\n        clr2=colors[-1]\\n        mx=0\\n        for i in range(len(colors)-1,-1,-1):\\n            if clr1!=colors[i]:\\n                mx=max(mx,i)\\n                break\\n        for i in range(len(colors)):\\n            if clr2!=colors[i]:\\n                mx=max(mx,len(colors)-i-1)\\n        return mx\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1590542,
                "title": "javascript-o-n-solution-100",
                "content": "```\\nvar maxDistance = function(colors) {\\n    // using two pointers from start and end\\n    // Time complexity O(n)\\n    // Space complexity O(1)\\n    \\n    const start = 0;\\n    const end = colors.length - 1;\\n\\n    // maximum distance possible is length of arr, so start with two pointer\\n\\t// one at the start and one at the end\\n    const startColor = colors[start];\\n    const endColor = colors[end];\\n    \\n\\t// base condition, to check if they are not already equal\\n    if (startColor !== endColor) {\\n        return end;\\n    }\\n    \\n\\t// move the forward pointer till we find the differend color\\n    let forwardPtr = start;\\n    while (startColor === colors[forwardPtr]) {\\n        ++forwardPtr;\\n    }\\n    \\n    // move the backward pointer till we find the differend color\\n    let backwardPtr = end;\\n    while(endColor === colors[backwardPtr]) {\\n        --backwardPtr;\\n    }\\n    \\n    // Till here, We already know that startColor === endColor\\n    // hence we did two things,\\n \\t// 1. we kept startColor fixed and moved backwardPtr till we find different color\\n    // 2. similarly, we kept endColor fixed and moved the forwardPtr till we find the different color.\\n   // we will return the max different out of two now.\\n    return Math.max(Math.abs(start - backwardPtr), Math.abs(end - forwardPtr));\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maxDistance = function(colors) {\\n    // using two pointers from start and end\\n    // Time complexity O(n)\\n    // Space complexity O(1)\\n    \\n    const start = 0;\\n    const end = colors.length - 1;\\n\\n    // maximum distance possible is length of arr, so start with two pointer\\n\\t// one at the start and one at the end\\n    const startColor = colors[start];\\n    const endColor = colors[end];\\n    \\n\\t// base condition, to check if they are not already equal\\n    if (startColor !== endColor) {\\n        return end;\\n    }\\n    \\n\\t// move the forward pointer till we find the differend color\\n    let forwardPtr = start;\\n    while (startColor === colors[forwardPtr]) {\\n        ++forwardPtr;\\n    }\\n    \\n    // move the backward pointer till we find the differend color\\n    let backwardPtr = end;\\n    while(endColor === colors[backwardPtr]) {\\n        --backwardPtr;\\n    }\\n    \\n    // Till here, We already know that startColor === endColor\\n    // hence we did two things,\\n \\t// 1. we kept startColor fixed and moved backwardPtr till we find different color\\n    // 2. similarly, we kept endColor fixed and moved the forwardPtr till we find the different color.\\n   // we will return the max different out of two now.\\n    return Math.max(Math.abs(start - backwardPtr), Math.abs(end - forwardPtr));\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1590429,
                "title": "worst-case-o-n-time-complexity",
                "content": "The algorithm consists of two steps:\\n- find the first house from the end which does not match the color of the house at front\\n- find the first house from the front which does not match the color of the house at back\\n\\nWe can use while loop for both steps. It will give us an algorithm with worst case time complexity of O(n).\\n\\n```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        int Max = INT_MIN;\\n        int N = colors.size();\\n        \\n        // find the first house from the end which does not match the color of house at front\\n        int j=N;\\n        while(--j>=0 && colors[0]==colors[j]) { }   // worst-case O(n)\\n        Max = abs(j-0);\\n        \\n        // find the first house from the front which does not match the color of house at back\\n        j=-1;\\n        while(++j<N && colors[N-1]==colors[j]) { }  // worst-case O(n)\\n        Max = max(Max, abs(j-(N-1)));\\n        \\n        return Max;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        int Max = INT_MIN;\\n        int N = colors.size();\\n        \\n        // find the first house from the end which does not match the color of house at front\\n        int j=N;\\n        while(--j>=0 && colors[0]==colors[j]) { }   // worst-case O(n)\\n        Max = abs(j-0);\\n        \\n        // find the first house from the front which does not match the color of house at back\\n        j=-1;\\n        while(++j<N && colors[N-1]==colors[j]) { }  // worst-case O(n)\\n        Max = max(Max, abs(j-(N-1)));\\n        \\n        return Max;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1589540,
                "title": "python-solution-with-explanation",
                "content": "here we first fix the initial value as value of color at index 1st and in second case value at index last .\\nwe do so to find the  max value of x (which is the distance between 2 different colors ).\\n```\\nclass Solution:\\n    def maxDistance(self, colors: List[int]) -> int:\\n        x=0\\n        first=0\\n        last=len(colors)-1\\n        while(first<last):\\n            if(colors[first]!=colors[last]):\\n                x=max(x,last-first)\\n            last=last-1\\n            \\n        first=0\\n        last=len(colors)-1\\n        while(first<last):\\n            if(colors[first]!=colors[last]):\\n                x=max(x,last-first)\\n            first+=1\\n            \\n        return(x)\\n```\\nIf u understood the code then plz...UPVOTE",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maxDistance(self, colors: List[int]) -> int:\\n        x=0\\n        first=0\\n        last=len(colors)-1\\n        while(first<last):\\n            if(colors[first]!=colors[last]):\\n                x=max(x,last-first)\\n            last=last-1\\n            \\n        first=0\\n        last=len(colors)-1\\n        while(first<last):\\n            if(colors[first]!=colors[last]):\\n                x=max(x,last-first)\\n            first+=1\\n            \\n        return(x)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3228880,
                "title": "easy-java-solution-time-complexity-o-n",
                "content": "```\\nclass Solution {\\n    public int maxDistance(int[] colors) {\\n        int ans=-1;\\n        int left=0,right=colors.length-1;\\n        while(left<=right){\\n            if(colors[left]==colors[right]){\\n                right--;\\n            }\\n            else{\\n                ans=Math.max(ans,right-left);\\n                left++;\\n                right=colors.length-1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDistance(int[] colors) {\\n        int ans=-1;\\n        int left=0,right=colors.length-1;\\n        while(left<=right){\\n            if(colors[left]==colors[right]){\\n                right--;\\n            }\\n            else{\\n                ans=Math.max(ans,right-left);\\n                left++;\\n                right=colors.length-1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2774236,
                "title": "java-easy-solution-4-liner",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDistance(int[] colors) {\\n      int n = colors.length, i = 0, j = n - 1;\\n        while (colors[0] == colors[j]) j--;\\n        while (colors[n - 1] == colors[i]) i++;\\n        return Math.max(n - 1 - i, j);  \\n    }\\n}\\n```\\n# PLEASE UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDistance(int[] colors) {\\n      int n = colors.length, i = 0, j = n - 1;\\n        while (colors[0] == colors[j]) j--;\\n        while (colors[n - 1] == colors[i]) i++;\\n        return Math.max(n - 1 - i, j);  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2629656,
                "title": "c-2-pointer-approch-andd-grredy",
                "content": "class Solution {\\npublic:\\n    int maxDistance(vector<int>& c) \\n    {\\n        int n=c.size();\\n        int j=n-1;\\n        int i=0;\\n        while(c[0]==c[j])\\n            j--;\\n        while(c[i]==c[n-1])\\n            i++;\\n        return max(n-1-i,j);\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int maxDistance(vector<int>& c) \\n    {\\n        int n=c.size();\\n        int j=n-1;\\n        int i=0;\\n        while(c[0]==c[j])\\n            j--;\\n        while(c[i]==c[n-1])\\n            i++;\\n        return max(n-1-i,j);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2608812,
                "title": "1ms-simple-fast-and-easy-java-solution-with-o-n-complexity",
                "content": "```\\nclass Solution \\n{\\n    public int maxDistance(int[] colors) \\n    {\\n        int j = colors.length-1;\\n        int k = 0;\\n        int dist1 = 0;\\n        int dist2 =0;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// distance from front index.\\n        for(int i=0;i<colors.length;i++){\\n              if(colors[i] != colors[j]){\\n                  dist1 = j-i;\\n                  break;\\n              }\\n          }\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t // distance from last index\\n        for(int i = colors.length-1; i>-1;i--){\\n            if(colors[i] != colors[k]){\\n                dist2 = i-k;\\n                break;\\n            }\\n\\t\\t\\t\\t}\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t              \\t// whichever is having more distance.\\n        return Math.max(dist1,dist2);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution \\n{\\n    public int maxDistance(int[] colors) \\n    {\\n        int j = colors.length-1;\\n        int k = 0;\\n        int dist1 = 0;\\n        int dist2 =0;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// distance from front index.\\n        for(int i=0;i<colors.length;i++){\\n              if(colors[i] != colors[j]){\\n                  dist1 = j-i;\\n                  break;\\n              }\\n          }\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t // distance from last index\\n        for(int i = colors.length-1; i>-1;i--){\\n            if(colors[i] != colors[k]){\\n                dist2 = i-k;\\n                break;\\n            }\\n\\t\\t\\t\\t}\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t              \\t// whichever is having more distance.\\n        return Math.max(dist1,dist2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2459626,
                "title": "runtime-0-ms-faster-than-100-00-very-easy-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& arr) \\n    {\\n        int start=0;\\n        int end=arr.size()-1;\\n        \\n        int ans=INT_MIN;\\n        \\n        while(arr[start]==arr[end])\\n        {\\n            end--;\\n        }\\n        ans=max(ans,end-start);\\n        \\n        start=0;\\n        end=arr.size()-1;\\n        \\n        while(arr[start]==arr[end])\\n        {\\n            start++;\\n        }\\n        \\n        ans=max(ans,end-start);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& arr) \\n    {\\n        int start=0;\\n        int end=arr.size()-1;\\n        \\n        int ans=INT_MIN;\\n        \\n        while(arr[start]==arr[end])\\n        {\\n            end--;\\n        }\\n        ans=max(ans,end-start);\\n        \\n        start=0;\\n        end=arr.size()-1;\\n        \\n        while(arr[start]==arr[end])\\n        {\\n            start++;\\n        }\\n        \\n        ans=max(ans,end-start);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2324246,
                "title": "two-solutions-o-n-and-o-n-2",
                "content": "O(n)\\n```\\nclass Solution:\\n    def maxDistance(self, colors: List[int]) -> int:\\n        i=0\\n        l=len(colors)\\n        j=l-1\\n        while colors[j] == colors[0]:\\n            j-=1\\n        \\n        while colors[-1] == colors[i]:\\n            i+=1\\n        return max(j,l-1-i)\\n```\\nO(n^2)\\n```\\n        max_dist=0\\n        l=len(colors)\\n        for i in range(l):\\n             for j in range(l):\\n                if colors[i]!=colors[j]:\\n                     max_dist = max(max_dist,abs(j-i))\\n        return max_dist\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxDistance(self, colors: List[int]) -> int:\\n        i=0\\n        l=len(colors)\\n        j=l-1\\n        while colors[j] == colors[0]:\\n            j-=1\\n        \\n        while colors[-1] == colors[i]:\\n            i+=1\\n        return max(j,l-1-i)\\n```\n```\\n        max_dist=0\\n        l=len(colors)\\n        for i in range(l):\\n             for j in range(l):\\n                if colors[i]!=colors[j]:\\n                     max_dist = max(max_dist,abs(j-i))\\n        return max_dist\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1616071,
                "title": "simple-python-solution-o-n",
                "content": "## INTUITION:\\n\\n- __Target__: Compute the maximum distance between two houses of different colors\\n- __Assumption__: \\n\\t- The distance between any two houses is uniform and equal to one.\\n\\t- There has to be atleast two elements in the array/list to compute the distance.\\n- Maximum possible distance is observed  when the house on the two ends are of different color\\n    - In such a scenario, we can simply look up the first and last elements of the array/list and return the distance as `length_of _array - 1 `\\n- If the first and last houses are of the same color, \\n\\t- We need to traverse the array to find a house of different color\\n\\t- Compute the distance from the houses on either ends and take the maximum of it.\\n\\t- Update a Counter Variable that maintains the largest distance for any such house of different color\\n\\n## CODE:\\n```python\\nclass Solution:\\n    def maxDistance(self, colors: List[int]) -> int:\\n        n = len(colors)\\n        if n < 2:\\n            return 0 \\n        if colors[0]!=colors[-1]:\\n            return n-1\\n        d = 0\\n        for i in range(n):\\n            if colors[i] != colors[0]:\\n                d = max(d,i)\\n            if colors[i] != colors[-1]:\\n                d = max(d,n-1-i)\\n        return d\\n```\\n\\n ## TIME COMPLEXITY:\\n-  O(n)\\n- In the worst case scenario, we have to iterate through the entire list/array of colors for n houses\\n\\n## SPACE COMPLEXITY:\\n- O(1)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array"
                ],
                "code": "```python\\nclass Solution:\\n    def maxDistance(self, colors: List[int]) -> int:\\n        n = len(colors)\\n        if n < 2:\\n            return 0 \\n        if colors[0]!=colors[-1]:\\n            return n-1\\n        d = 0\\n        for i in range(n):\\n            if colors[i] != colors[0]:\\n                d = max(d,i)\\n            if colors[i] != colors[-1]:\\n                d = max(d,n-1-i)\\n        return d\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1591546,
                "title": "c-1-line-solution-w-explanations-o-n-100-time-o-1-space",
                "content": "# Solution idea\\nWe only need to consider these two options and pick the best of two results:\\n- Distance between the first house and the rightmost house having a different color\\n- Distance between the last house and the leftmost house having a different color\\n\\n![image](https://assets.leetcode.com/users/images/8b213169-ee1d-4eec-9538-9cd84cac6f8c_1637591631.338769.png)\\n\\nFor a trivial case where the first and the last house have different colors, this logic will also work, even though these distance will be the same:\\n![image](https://assets.leetcode.com/users/images/18761997-f8e7-4da0-8c03-83a7614152f3_1637591667.0252492.png)\\n\\n# One-line solution\\n```csharp\\npublic int MaxDistance(int[] colors) \\n{\\n  return Math.Max(\\n    Array.FindLastIndex(colors, x => x != colors.First()), \\n    colors.Length - Array.FindIndex(colors, x => x != colors.Last()) - 1\\n  );\\n}\\n```\\n\\n# More verbose solution\\nThough, this is how I would solve it in production code or during a coding interview:\\n\\n```csharp\\n  public int MaxDistance(int[] colors) \\n  {\\n    if (colors == null)\\n      throw new ArgumentNullException(nameof(colors));\\n    \\n    if (colors.Length < 2)\\n      throw new ArgumentException(nameof(colors), \"Should contain at least two houses\");\\n    \\n\\t// Trivial case: 1st and last house are different, use them\\n    if (colors[0] != colors[colors.Length - 1]) \\n      return colors.Length - 1;\\n     \\n    // Non-trivial case: 1st and last houses are the same\\n\\t// Then try to match them separately against the furthest house on the opposide side\\n    int leftmostIndex = Array.FindIndex(colors, x => x != colors[0]);\\n      \\n    if (leftmostIndex == -1)\\n      throw new ArgumentException(nameof(colors), \"All houses have the same color, invalid input\");\\n      \\n    int rightmostIndex = Array.FindLastIndex(colors, x => x != colors[0]);      \\n\\n    return Math.Max(\\n      rightmostIndex,\\n      colors.Length - leftmostIndex - 1\\n    );\\n }\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic int MaxDistance(int[] colors) \\n{\\n  return Math.Max(\\n    Array.FindLastIndex(colors, x => x != colors.First()), \\n    colors.Length - Array.FindIndex(colors, x => x != colors.Last()) - 1\\n  );\\n}\\n```\n```csharp\\n  public int MaxDistance(int[] colors) \\n  {\\n    if (colors == null)\\n      throw new ArgumentNullException(nameof(colors));\\n    \\n    if (colors.Length < 2)\\n      throw new ArgumentException(nameof(colors), \"Should contain at least two houses\");\\n    \\n\\t// Trivial case: 1st and last house are different, use them\\n    if (colors[0] != colors[colors.Length - 1]) \\n      return colors.Length - 1;\\n     \\n    // Non-trivial case: 1st and last houses are the same\\n\\t// Then try to match them separately against the furthest house on the opposide side\\n    int leftmostIndex = Array.FindIndex(colors, x => x != colors[0]);\\n      \\n    if (leftmostIndex == -1)\\n      throw new ArgumentException(nameof(colors), \"All houses have the same color, invalid input\");\\n      \\n    int rightmostIndex = Array.FindLastIndex(colors, x => x != colors[0]);      \\n\\n    return Math.Max(\\n      rightmostIndex,\\n      colors.Length - leftmostIndex - 1\\n    );\\n }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3909874,
                "title": "c-solution-100-beats-easy-to-understand-o-n",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        int i =0;\\n        int j =colors.size()-1;\\n        int ans1 = 0;\\n        while(i<j){\\n            if(colors[i]!=colors[j]){\\n                 ans1 = max(ans1,abs(j-i));\\n            }\\n            j--;\\n        }\\n\\n        i =0;\\n        j =colors.size()-1;\\n        int ans2 = 0;\\n        while(i<j){\\n            if(colors[i]!=colors[j]){\\n                 ans2 = max(ans2,abs(j-i));\\n            }\\n            i++;\\n        }\\n        return max(ans1,ans2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        int i =0;\\n        int j =colors.size()-1;\\n        int ans1 = 0;\\n        while(i<j){\\n            if(colors[i]!=colors[j]){\\n                 ans1 = max(ans1,abs(j-i));\\n            }\\n            j--;\\n        }\\n\\n        i =0;\\n        j =colors.size()-1;\\n        int ans2 = 0;\\n        while(i<j){\\n            if(colors[i]!=colors[j]){\\n                 ans2 = max(ans2,abs(j-i));\\n            }\\n            i++;\\n        }\\n        return max(ans1,ans2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3453056,
                "title": "fastest-solution-with-java-0ms",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDistance(int[] colors) {\\n        int first = colors[0];\\n        int index = 0;\\n        for(int a = 1; a < colors.length; a++){\\n            if(colors[a] != first) index = a;\\n        }\\n        int last = colors[colors.length-1];\\n        int index2 = colors.length-1;\\n        for(int a = colors.length-1; a > -1; a--){\\n            if(colors[a] != last) index2 = a;\\n        }\\n        int revindex = (colors.length-1)-index2;\\n        return Math.max(index, revindex);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDistance(int[] colors) {\\n        int first = colors[0];\\n        int index = 0;\\n        for(int a = 1; a < colors.length; a++){\\n            if(colors[a] != first) index = a;\\n        }\\n        int last = colors[colors.length-1];\\n        int index2 = colors.length-1;\\n        for(int a = colors.length-1; a > -1; a--){\\n            if(colors[a] != last) index2 = a;\\n        }\\n        int revindex = (colors.length-1)-index2;\\n        return Math.max(index, revindex);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3413533,
                "title": "beats-100-cpp-sol",
                "content": "# **IF HELPFUL PLS UPVOTE\\uD83E\\uDD79, IT MOTIVATES !**\\n\\n# Approach\\nApproach is written in the code in the form of comments just go through them and dry run once code , you will get to know the appraoch...\\n\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n![Screenshot 2023-04-13 at 9.52.01 PM.png](https://assets.leetcode.com/users/images/13673aed-0709-4006-ac1a-4e6733d9d716_1681403069.363195.png)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        // This problem is an example of simple two pointer appraoch \\n        // we want the maximum distance , and maximum distance will be the difference of beg and end\\n\\n        // putting a pointer at the begining \\n        int i = 0;\\n\\n        // putting a pointer at the end \\n        int j = colors.size()-1;\\n\\n        // creating answer variable to store the final ans\\n        int ans1 = 0;\\n\\n        while(i<j){\\n            if(colors[i] != colors[j]){\\n                ans1 = max(ans1, j-i);\\n            }\\n            j--;\\n        }\\n\\n        i = 0;\\n        j = colors.size()-1;\\n        int ans2 = 0;\\n        while(i<j){\\n            if(colors[i]!=colors[j]){\\n                ans2 = max(ans2, abs(i-j));\\n            }\\n            i++;\\n        }\\n        return max(ans1, ans2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        // This problem is an example of simple two pointer appraoch \\n        // we want the maximum distance , and maximum distance will be the difference of beg and end\\n\\n        // putting a pointer at the begining \\n        int i = 0;\\n\\n        // putting a pointer at the end \\n        int j = colors.size()-1;\\n\\n        // creating answer variable to store the final ans\\n        int ans1 = 0;\\n\\n        while(i<j){\\n            if(colors[i] != colors[j]){\\n                ans1 = max(ans1, j-i);\\n            }\\n            j--;\\n        }\\n\\n        i = 0;\\n        j = colors.size()-1;\\n        int ans2 = 0;\\n        while(i<j){\\n            if(colors[i]!=colors[j]){\\n                ans2 = max(ans2, abs(i-j));\\n            }\\n            i++;\\n        }\\n        return max(ans1, ans2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3348692,
                "title": "4-line-easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nfind max distance between two unique elements in an array.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nuse 2 pointer approach where is color[i]!=color[j] get there address difference and maximize it.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(n^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& nums) {\\n        int ans =0;\\n        for(int i = 0;i<nums.size();i++){\\n            for(int j = i+1;j<nums.size();j++){\\n            if(nums[i]!=nums[j]){\\n                ans = max(ans,(j-i));\\n           }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& nums) {\\n        int ans =0;\\n        for(int i = 0;i<nums.size();i++){\\n            for(int j = i+1;j<nums.size();j++){\\n            if(nums[i]!=nums[j]){\\n                ans = max(ans,(j-i));\\n           }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3311422,
                "title": "easy-python-solution-beats-89-95",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def maxDistance(self, colors: List[int]) -> int:\\n        ind1, ind2 = 0, -1\\n        size = len(colors)\\n        while ind1 < size:\\n            front = colors[ind1]\\n            if front != colors[-1]:\\n                return size - ind1 - 1\\n            last = colors[ind2]\\n            if last != colors[0]:\\n                return size + ind2\\n            ind1 += 1\\n            ind2 -= 1\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def maxDistance(self, colors: List[int]) -> int:\\n        ind1, ind2 = 0, -1\\n        size = len(colors)\\n        while ind1 < size:\\n            front = colors[ind1]\\n            if front != colors[-1]:\\n                return size - ind1 - 1\\n            last = colors[ind2]\\n            if last != colors[0]:\\n                return size + ind2\\n            ind1 += 1\\n            ind2 -= 1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3046236,
                "title": "python3-beats-99-18-must-use-ends-explained",
                "content": "# Intuition\\nIf both ends are unequal, then we\\'ve already found our solution.\\nIf both ends are equal, it must be the case that the solution uses one of the end points. This is true by contradiction. \\n\\nSuppose that the solution exists and it does not use an end. Therefore it can **not** be the case that $$(endColor \\\\neq colors[i]$$ or $$endColor \\\\neq colors[j])$$ as that would provide a longer solution. Therefore $$endColor=colors[i]=colors[j]$$ as $$!(! p \\\\ or \\\\ !q)\\\\iff p \\\\ and \\\\ q$$. But since $$colors[i] \\\\neq colors[j]$$ by definition of being a solution, this is a contradiction, and therefore our supposition is wrong.\\n\\n# Approach\\nBy entering the loop, we know our end-colors are equal. We are looking for the first different color, as that would have the largest distance from the right house. We are also looking for the last different color, as that would have the largest distance from the left house. \\n\\nSuppose we found a different color, $$i$$ is the distance from the left end-color to the house while $$len(colors) - 1 - i$$ is the distance from the house to the right end-color. We take the max each time and return that.\\n\\n# Complexity\\n- $$n=len(colors)$$\\n\\n- Time complexity: $$O(n)$$ as we iterate over $$colors$$ once and perform $$O(1)$$ operations per iteration.\\n\\n- Space complexity: $$O(1)$$ as we only keep track of $$res$$.\\n\\n# Code\\n```Python\\nclass Solution:\\n    def maxDistance(self, colors: List[int]) -> int:\\n        if colors[0] != colors[-1]:\\n            return len(colors) - 1\\n\\n        res: int = 0\\n        for i, color in enumerate(colors):\\n            if color != colors[0]:\\n                res = max(res, i, len(colors) - 1 - i)\\n            \\n        return res   \\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Math"
                ],
                "code": "```Python\\nclass Solution:\\n    def maxDistance(self, colors: List[int]) -> int:\\n        if colors[0] != colors[-1]:\\n            return len(colors) - 1\\n\\n        res: int = 0\\n        for i, color in enumerate(colors):\\n            if color != colors[0]:\\n                res = max(res, i, len(colors) - 1 - i)\\n            \\n        return res   \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2830195,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDistance(int[] colors) {\\n        int i = 0,ans1 = 0,ans2 = 0;\\n        int j = colors.length-1;\\n        while(i <= j){\\n           if(colors[i]==colors[j]) j--;\\n           else {\\n               ans1 = j;\\n               break;\\n           }\\n\\n        }\\n        i = 0;j = colors.length-1;\\n        while(i <= j){\\n           if(colors[i]==colors[j]) i++;\\n           else {\\n               ans2 = i;\\n               break;\\n           }\\n\\n        }\\n        return Math.max(ans1,colors.length-ans2-1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDistance(int[] colors) {\\n        int i = 0,ans1 = 0,ans2 = 0;\\n        int j = colors.length-1;\\n        while(i <= j){\\n           if(colors[i]==colors[j]) j--;\\n           else {\\n               ans1 = j;\\n               break;\\n           }\\n\\n        }\\n        i = 0;j = colors.length-1;\\n        while(i <= j){\\n           if(colors[i]==colors[j]) i++;\\n           else {\\n               ans2 = i;\\n               break;\\n           }\\n\\n        }\\n        return Math.max(ans1,colors.length-ans2-1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2724221,
                "title": "c-easy-short",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int> &colors)\\n    {\\n        int n = colors.size();\\n        int from_start = 0;   \\n        int from_end = n - 1; \\n        while (colors[0] == colors[from_end])\\n            from_end--;\\n        while (colors[n - 1] == colors[from_start])\\n            from_start++;\\n        return max(from_end, n - from_start - 1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int> &colors)\\n    {\\n        int n = colors.size();\\n        int from_start = 0;   \\n        int from_end = n - 1; \\n        while (colors[0] == colors[from_end])\\n            from_end--;\\n        while (colors[n - 1] == colors[from_start])\\n            from_start++;\\n        return max(from_end, n - from_start - 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2539094,
                "title": "c-c-simple-solution-in-o-n",
                "content": "In the following `C++` approach, the array is traversed both forward and backward. The best solution for the forward traversal and the backward traversal is stored in `int forward` and `int backward` respectively. Finally, the `forward` and `backward` is compared and the greater value is printed.\\n* In C Programming, you just need to replace *the size of the array* with the given variable `int colorsSize`  \\n```\\n    int maxDistance(vector<int>& colors) {\\n        int forward=0, backward=0;\\n        \\n        for(int i=0; i<colors.size(); i++) \\n            if( colors[0] != colors[i] ) \\n                forward = i;\\n        \\n        for(int i=colors.size()-1; i>=0; i--) \\n            if( colors[colors.size()-1] != colors[i] ) \\n                backward = (colors.size()-1) - i;\\n        \\n        return (forward > backward) ? forward : backward;\\n    }\\n\\t\\n```",
                "solutionTags": [
                    "Array",
                    "Greedy"
                ],
                "code": "```\\n    int maxDistance(vector<int>& colors) {\\n        int forward=0, backward=0;\\n        \\n        for(int i=0; i<colors.size(); i++) \\n            if( colors[0] != colors[i] ) \\n                forward = i;\\n        \\n        for(int i=colors.size()-1; i>=0; i--) \\n            if( colors[colors.size()-1] != colors[i] ) \\n                backward = (colors.size()-1) - i;\\n        \\n        return (forward > backward) ? forward : backward;\\n    }\\n\\t\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2506689,
                "title": "100-faster-simple-java-code",
                "content": "```\\nclass Solution {\\n    public int maxDistance(int[] colors) {\\n       int i=0,j=colors.length-1;\\n        int d=0;\\n        while(colors[i]==colors[j])j--;\\n        d=j-i;\\n        j=colors.length-1;\\n        while(colors[i]==colors[j])i++;\\n        d=Math.max(d,j-i);\\n        return d;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxDistance(int[] colors) {\\n       int i=0,j=colors.length-1;\\n        int d=0;\\n        while(colors[i]==colors[j])j--;\\n        d=j-i;\\n        j=colors.length-1;\\n        while(colors[i]==colors[j])i++;\\n        d=Math.max(d,j-i);\\n        return d;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2090639,
                "title": "c-solution-o-n-solution",
                "content": "The maximum distance will be from either of the two ends of the array. If the ends of the arrays have different colors then return the length of the array. Otherwise find the maximum distance from either ends and return their maximum\\n```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        int n=colors.size();\\n        if(colors[0]!=colors[n-1]){\\n            return n-1;\\n        } else {\\n            int back=0;\\n            int front=0;\\n            for(int i=0;i<n;i++){\\n                if(colors[i]!=colors[0]){\\n                    front=i;\\n                    back=max(back,n-front-1);\\n                } \\n            }\\n            return max(front,back);\\n        }\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "class Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        int n=colors.size();\\n        if(colors[0]!=colors[n-1]){\\n            return n-1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2013380,
                "title": "100-java-solution-with-constant-space",
                "content": "**Intitution**: Either of the first house or the last house will always be one of the furthest houses.\\n**Logic**: Iterate from start as well as last to find the different color houses. Return from the point you found one. \\n```\\nclass Solution {\\n    public int maxDistance(int[] colors) {\\n        if(colors.length==2 ){\\n            return colors[0]==colors[1]?0:1;\\n        }\\n        int i = 0, j = colors.length - 1;\\n        \\n        while (i < colors.length) {\\n            if (colors[0] == colors[j])\\n                j--;\\n            else\\n                return j;\\n            if (colors[colors.length - 1] == colors[i])\\n                i++;\\n            else\\n                return colors.length - i - 1;\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDistance(int[] colors) {\\n        if(colors.length==2 ){\\n            return colors[0]==colors[1]?0:1;\\n        }\\n        int i = 0, j = colors.length - 1;\\n        \\n        while (i < colors.length) {\\n            if (colors[0] == colors[j])\\n                j--;\\n            else\\n                return j;\\n            if (colors[colors.length - 1] == colors[i])\\n                i++;\\n            else\\n                return colors.length - i - 1;\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1955608,
                "title": "python3-simple-solution",
                "content": "```\\nclass Solution:\\n    def maxDistance(self, colors: List[int]) -> int:\\n        x = []\\n        for i in range(len(colors)-1):\\n            for j in range(i+1,len(colors)):\\n                if colors[i] != colors[j]:\\n                    x.append(j-i)\\n        return max(x)\\n```\\n**If you like this solution, please upvote for this**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxDistance(self, colors: List[int]) -> int:\\n        x = []\\n        for i in range(len(colors)-1):\\n            for j in range(i+1,len(colors)):\\n                if colors[i] != colors[j]:\\n                    x.append(j-i)\\n        return max(x)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1724743,
                "title": "short-python-code-100-faster-time-o-n-space-o-1",
                "content": "Here l and r are left most and right most indices. Variable \\'dist\\' counts the distance between two Furthest Houses With Different Colors. Code is easy to understance once you give a try.\\n\\n```\\nclass Solution:\\n    def maxDistance(self, colors: List[int]) -> int:\\n        l, r, prev = 0, len(colors)-1, colors[0]\\n        dist = 0\\n        while (l<=r): \\n            if colors[l] == colors[r] and prev == colors[l]:\\n                prev = colors[l]\\n                r -= 1\\n                l += 1\\n                dist += 1\\n            else:\\n                dist += r-l\\n                return dist\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxDistance(self, colors: List[int]) -> int:\\n        l, r, prev = 0, len(colors)-1, colors[0]\\n        dist = 0\\n        while (l<=r): \\n            if colors[l] == colors[r] and prev == colors[l]:\\n                prev = colors[l]\\n                r -= 1\\n                l += 1\\n                dist += 1\\n            else:\\n                dist += r-l\\n                return dist\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1716702,
                "title": "python-94-42-faster-o-1-space-o-n-time-10-lines",
                "content": "```\\nmax_dist = 0\\nfirst_diff = 0\\nfor i in range(1,len(colors)):\\n\\tif colors[i] != colors[0]:\\n\\t\\tif not first_diff:\\n\\t\\t\\tfirst_diff = i\\n\\t\\tmax_dist = max(max_dist, i)\\n\\telse:\\n\\t\\tmax_dist = max(max_dist, i - first_diff)\\nreturn max_dist\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nmax_dist = 0\\nfirst_diff = 0\\nfor i in range(1,len(colors)):\\n\\tif colors[i] != colors[0]:\\n\\t\\tif not first_diff:\\n\\t\\t\\tfirst_diff = i\\n\\t\\tmax_dist = max(max_dist, i)\\n\\telse:\\n\\t\\tmax_dist = max(max_dist, i - first_diff)\\nreturn max_dist\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1681845,
                "title": "python-o-n-solution-with-provement-of-the-greed-propery",
                "content": "The problem is straight forward if you know the greed property of the solution which is:\\n\\nThe maximum distance is the maximum of:\\n1. the distance between the first house and a house with a differen color in its right.\\n2. the distance between the last house and a house with a different color in its left.\\n\\nOk, but why this holds? Implementing greed is easy (that\\'s also one of the reason it\\'s called greed), but prove the greed property is essential for the solution. Do realise that during an interview, the interviwer may ask you why the greed property holds.\\n\\nLet\\'s try to prove this by induction:\\n1. `Guess`: the greed propery holds for any valid input array.\\n2. `Hypothesis`: assume it holds for a valid input array `A`, and the maximum distance is between `A[0]` and `A[i]` where `i > 0`.\\n3. Now we add one element to the end of `A` to form `A\\'` which is still a valid input. Then we have a few situations to discuss:\\n\\t3.1.  If the new element has the same color of `A[i]`. The maximum distance is now `A\\'[0]` and` A\\'[n]` where n is the last index of `A\\'`. The guess holds.\\n\\t3.2. If the new element has the same color of `A[0]`. The maximum distance is now either `A\\'[0]` and `A\\'[i]` or `A\\'[j]` and `A\\'[n]` where `j < n`. Because in `A\\'`, if any distance greater than `A\\'[0]` and `A\\'[i]` exists, it must ends with `A\\'[n]`. Otherwise this distance is already found in `A`. The guess holds.\\n\\t3.3. If the new element is different from `A[0]` and `A[i]`. The maximum distance is now `A\\'[0]` and `A\\'[n]`. The guess holds.\\n4. Similar duscissions in 3 can be applied to:\\n\\t4.1. If we pre-append an element to `A`.\\n\\t4.2. If the maximum distance in `A` is between `A[j]` and `A[n]`, where `n` is the last index of `A` and `j < n`.\\n5. The guess is proved.\\n\\n** IMO, this problem is medium if you count the process of find and prove the greed property. Usually, greedy solution is more difficult than dynamic programming since you have to make guess of the greed property and prove it while the later you just need to find the recurrence relationship.\\n\\nAnd below is an implmentation based on Python:\\n```python\\nclass Solution:\\n    def maxDistance(self, colors: List[int]) -> int:\\n        ret = 0\\n        left_c = colors[0]\\n        right_c = colors[-1]\\n        for i in range(1, len(colors)):\\n            if colors[i] != left_c:\\n                ret = i\\n                \\n        for i in range(len(colors) - 2, -1, -1):\\n            if colors[i] != right_c:\\n                ret = max(ret, len(colors) - 1 - i)\\n                \\n        return ret\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```python\\nclass Solution:\\n    def maxDistance(self, colors: List[int]) -> int:\\n        ret = 0\\n        left_c = colors[0]\\n        right_c = colors[-1]\\n        for i in range(1, len(colors)):\\n            if colors[i] != left_c:\\n                ret = i\\n                \\n        for i in range(len(colors) - 2, -1, -1):\\n            if colors[i] != right_c:\\n                ret = max(ret, len(colors) - 1 - i)\\n                \\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1622510,
                "title": "easy-c-solution-4ms",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        int diff=0;\\n        for(int i=0; i<colors.size()-1; i++)\\n        {\\n            for(int j=colors.size()-1; j>i; j--)\\n            {\\n                if(colors[j]==colors[i])\\n                    continue;\\n                else\\n                {\\n                    diff=max(diff, abs(j-i));\\n                    break;\\n                }\\n            }\\n        }\\n        return diff;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        int diff=0;\\n        for(int i=0; i<colors.size()-1; i++)\\n        {\\n            for(int j=colors.size()-1; j>i; j--)\\n            {\\n                if(colors[j]==colors[i])\\n                    continue;\\n                else\\n                {\\n                    diff=max(diff, abs(j-i));\\n                    break;\\n                }\\n            }\\n        }\\n        return diff;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1589264,
                "title": "c-solution-brute-force-two-loops",
                "content": "```\\n    int maxDistance(vector<int>& colors) \\n    {\\n        int n=colors.size(),res=INT_MIN;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i+1;j<n;j++)\\n            {\\n                if(colors[i]!=colors[j])\\n                    res=max(res,abs(i-j));\\n            }\\n                \\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int maxDistance(vector<int>& colors) \\n    {\\n        int n=colors.size(),res=INT_MIN;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i+1;j<n;j++)\\n            {\\n                if(colors[i]!=colors[j])\\n                    res=max(res,abs(i-j));\\n            }\\n                \\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1589059,
                "title": "java-o-n-solution",
                "content": "This is my first time writing the solution.\\nIf anything wrong please let me know!\\n\\n\\n```\\nclass Solution {\\n    public int maxDistance(int[] colors) {\\n        //one side must contsains start point or end point\\n        \\n        //fix right point, find the farest left\\n        int left = 0;\\n        int right = colors.length - 1;\\n        while(colors[left] == colors[right]){\\n            left++;\\n        }\\n        int retval = right - left;\\n\\n        //fix left point, find the farest rigth\\n        left = 0;\\n        right = colors.length - 1;        \\n        while(colors[left] == colors[right]){\\n           right--;\\n        }\\n        \\n        return Math.max(retval, right - left);\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDistance(int[] colors) {\\n        //one side must contsains start point or end point\\n        \\n        //fix right point, find the farest left\\n        int left = 0;\\n        int right = colors.length - 1;\\n        while(colors[left] == colors[right]){\\n            left++;\\n        }\\n        int retval = right - left;\\n\\n        //fix left point, find the farest rigth\\n        left = 0;\\n        right = colors.length - 1;        \\n        while(colors[left] == colors[right]){\\n           right--;\\n        }\\n        \\n        return Math.max(retval, right - left);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3460791,
                "title": "simple-java-100-explained-a",
                "content": "# Approach\\n- for O(n\\xB2) set 2 for loops iterating through the entire array twice and only records the maximum value between current max and the new distance for different colored houses.\\n\\n# Complexity\\n- Time complexity: O(n\\xB2)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDistance(int[] colors) {\\n        \\n        int dist = 0;\\n        \\n        for(int i = 0;i<colors.length;i++){\\n            for(int j = colors.length-1;j>=0;j--){\\n                if(colors[i] != colors[j]){\\n                    dist = Math.max(j - i,dist);\\n                }\\n            }            \\n        }\\n\\n        return dist;\\n        \\n        \\n    }\\n}\\n```\\n\\n![images.jpeg](https://assets.leetcode.com/users/images/d7b15911-1568-42ce-b5ee-6e374a1a6c23_1682603015.5590189.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDistance(int[] colors) {\\n        \\n        int dist = 0;\\n        \\n        for(int i = 0;i<colors.length;i++){\\n            for(int j = colors.length-1;j>=0;j--){\\n                if(colors[i] != colors[j]){\\n                    dist = Math.max(j - i,dist);\\n                }\\n            }            \\n        }\\n\\n        return dist;\\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3349023,
                "title": "two-furthest-houses-with-different-colors-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        int i, j, max=0;\\n        for(i=0 ; i<colors.size()-1 ; i++)\\n        {\\n            for(j=i+max ; j<colors.size() ; j++)\\n            {\\n                if(colors[i]!=colors[j] && (j-i)>max)\\n                {\\n                    max = j-i;\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        int i, j, max=0;\\n        for(i=0 ; i<colors.size()-1 ; i++)\\n        {\\n            for(j=i+max ; j<colors.size() ; j++)\\n            {\\n                if(colors[i]!=colors[j] && (j-i)>max)\\n                {\\n                    max = j-i;\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3304843,
                "title": "2-solution-c-easy-brute-force-two-pointer",
                "content": "# BRUTE FORCE\\n```\\nclass Solution {\\npublic:\\n   class Solution {\\npublic:\\n    int maxDistance(vector<int>& nums) {\\n        int i=0;\\n        int maxi=INT_MIN ;\\n       while(i<nums.size()){\\n        int j=0;\\n           while(j<nums.size()){\\n               if(nums[i] != nums[j]){\\n                   maxi=max(maxi,j-i);\\n               }\\n               j++;\\n           }\\n           i++;\\n       }\\n        return maxi;\\n    }\\n};\\n```\\n# TWO POINTERS\\n```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& nums) {\\n        int i=0;\\n        int j=nums.size()-1;\\n        int maxi=INT_MIN ;\\n        while(j<nums.size()){\\n            if(nums[i] != nums[j])\\n                maxi=max(maxi,j-i); \\n             j--;\\n        }\\n        i=0;\\n        j=nums.size()-1;\\n      while(i<nums.size()){\\n          if(nums[i] != nums[j])\\n              maxi=max(maxi,j-i);\\n          i++;\\n      }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   class Solution {\\npublic:\\n    int maxDistance(vector<int>& nums) {\\n        int i=0;\\n        int maxi=INT_MIN ;\\n       while(i<nums.size()){\\n        int j=0;\\n           while(j<nums.size()){\\n               if(nums[i] != nums[j]){\\n                   maxi=max(maxi,j-i);\\n               }\\n               j++;\\n           }\\n           i++;\\n       }\\n        return maxi;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& nums) {\\n        int i=0;\\n        int j=nums.size()-1;\\n        int maxi=INT_MIN ;\\n        while(j<nums.size()){\\n            if(nums[i] != nums[j])\\n                maxi=max(maxi,j-i); \\n             j--;\\n        }\\n        i=0;\\n        j=nums.size()-1;\\n      while(i<nums.size()){\\n          if(nums[i] != nums[j])\\n              maxi=max(maxi,j-i);\\n          i++;\\n      }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3187759,
                "title": "o-n-2-solution-in-cpp",
                "content": "\\n# Complexity\\n- Time complexity:O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        int ans = 0;\\n        for(int i = 0; i  < colors.size(); i++){\\n            for(int j = i + 1; j < colors.size(); j++){\\n                if(colors[i] != colors[j])\\n                ans = max(ans,abs(j - i));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        int ans = 0;\\n        for(int i = 0; i  < colors.size(); i++){\\n            for(int j = i + 1; j < colors.size(); j++){\\n                if(colors[i] != colors[j])\\n                ans = max(ans,abs(j - i));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2973250,
                "title": "c-simple-and-easy-to-understand-solution-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nfinding first and last occurence of each coloured house \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nkeep maxm diff and return \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(Nlogn)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colours) {\\n        map<int,int>m1,m2;\\n        for(int i=0;i<colours.size();i++){\\n            m1.insert({colours[i],i});\\n        }\\n        for(int i=colours.size()-1;i>=0;i--){\\n            m2.insert({colours[i],i});\\n        }\\n        int mexi=INT_MIN;\\n        for(auto it1=m1.begin();it1!=m1.end();it1++){\\n      \\n        for(auto it2=m2.begin();it2!=m2.end();it2++){\\n         if(it1->first!=it2->first){\\n             mexi=max(abs(it1->second-it2->second),mexi);\\n         }\\n        }\\n        }\\n  \\n    return mexi;\\n        // return 2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colours) {\\n        map<int,int>m1,m2;\\n        for(int i=0;i<colours.size();i++){\\n            m1.insert({colours[i],i});\\n        }\\n        for(int i=colours.size()-1;i>=0;i--){\\n            m2.insert({colours[i],i});\\n        }\\n        int mexi=INT_MIN;\\n        for(auto it1=m1.begin();it1!=m1.end();it1++){\\n      \\n        for(auto it2=m2.begin();it2!=m2.end();it2++){\\n         if(it1->first!=it2->first){\\n             mexi=max(abs(it1->second-it2->second),mexi);\\n         }\\n        }\\n        }\\n  \\n    return mexi;\\n        // return 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2968965,
                "title": "go",
                "content": "```\\nfunc maxDistance(colors []int) int {\\n    max := 0\\n    for i := 0; i < len(colors) - 1; i++ {\\n        for j := i + 1; j < len(colors); j++ {\\n            if colors[i] != colors[j] && j - i > max {\\n                max = j - i\\n            }\\n        }\\n    }\\n    return max\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc maxDistance(colors []int) int {\\n    max := 0\\n    for i := 0; i < len(colors) - 1; i++ {\\n        for j := i + 1; j < len(colors); j++ {\\n            if colors[i] != colors[j] && j - i > max {\\n                max = j - i\\n            }\\n        }\\n    }\\n    return max\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2459634,
                "title": "c-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& arr) {\\n        int start=0;\\n        int end=arr.size()-1;\\n        int ans=0;\\n        while(start<end)\\n        {\\n            if(arr[start]==arr[end])\\n            {\\n                end--;\\n            }\\n            else\\n            {\\n                ans=max(ans,abs(end-start));\\n                start++;\\n            }\\n        }\\n        start=0;\\n        end=arr.size()-1;\\n        while(start<end)\\n        {\\n            if(arr[start]==arr[end])\\n            {\\n                start++;\\n            }\\n            else\\n            {\\n                ans=max(ans,abs(end-start));\\n                end--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& arr) {\\n        int start=0;\\n        int end=arr.size()-1;\\n        int ans=0;\\n        while(start<end)\\n        {\\n            if(arr[start]==arr[end])\\n            {\\n                end--;\\n            }\\n            else\\n            {\\n                ans=max(ans,abs(end-start));\\n                start++;\\n            }\\n        }\\n        start=0;\\n        end=arr.size()-1;\\n        while(start<end)\\n        {\\n            if(arr[start]==arr[end])\\n            {\\n                start++;\\n            }\\n            else\\n            {\\n                ans=max(ans,abs(end-start));\\n                end--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2458960,
                "title": "fatstest-js-solution",
                "content": "```\\nvar maxDistance = function(colors) {\\n    let n = colors.length;\\n    let ans = 1;\\n    for(let i =0 ; i<colors.length; i++){\\n        if(colors[i] != colors[0])\\n            ans = Math.max(ans, i);\\n        if(colors[i] != colors[n-1])\\n            ans = Math.max(ans, n-1-i);\\n    }\\n    return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maxDistance = function(colors) {\\n    let n = colors.length;\\n    let ans = 1;\\n    for(let i =0 ; i<colors.length; i++){\\n        if(colors[i] != colors[0])\\n            ans = Math.max(ans, i);\\n        if(colors[i] != colors[n-1])\\n            ans = Math.max(ans, n-1-i);\\n    }\\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2451257,
                "title": "c-one-loop",
                "content": "```\\n\\tint maxDistance(vector<int>& c) {\\n        int n = c.size(), ans = 0;\\n        for(int i = 0; i < n; i++){\\n            if(c[0] != c[n - i - 1]) ans = max(n - i - 1, ans);\\n            if(c[i] != c[n - 1]) ans = max(n - i - 1, ans);\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\tint maxDistance(vector<int>& c) {\\n        int n = c.size(), ans = 0;\\n        for(int i = 0; i < n; i++){\\n            if(c[0] != c[n - i - 1]) ans = max(n - i - 1, ans);\\n            if(c[i] != c[n - 1]) ans = max(n - i - 1, ans);\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2450695,
                "title": "java-solution-o-n-2",
                "content": "```\\nclass Solution {\\n    public int maxDistance(int[] colors) {\\n        int max = Integer.MIN_VALUE;;\\n        int n = colors.length;\\n\\n        for (int i = 0; i < n; i++) {\\n            for (int j = i + 1; j < n; j++) {\\n                if (colors[j] != colors[i]) {\\n                    int diff = Math.abs(j - i);\\n                    max = Math.max(max, diff);\\n                }\\n            }\\n        }\\n\\n        return max;\\n    }\\n}\\n\\n// TC: O(n^2), SC: O(1)\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDistance(int[] colors) {\\n        int max = Integer.MIN_VALUE;;\\n        int n = colors.length;\\n\\n        for (int i = 0; i < n; i++) {\\n            for (int j = i + 1; j < n; j++) {\\n                if (colors[j] != colors[i]) {\\n                    int diff = Math.abs(j - i);\\n                    max = Math.max(max, diff);\\n                }\\n            }\\n        }\\n\\n        return max;\\n    }\\n}\\n\\n// TC: O(n^2), SC: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2440124,
                "title": "python-super-easy-greedy-o-n",
                "content": "```\\nclass Solution:\\n    def maxDistance(self, colors: List[int]) -> int:\\n        \\n        ans = -1 \\n        for i in range(len(colors)):\\n                if colors[i] != colors[0]:\\n                    ans = max(ans, i)\\n                if colors[i] != colors[-1]:\\n                    ans = max(ans, len(colors)- i - 1)\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxDistance(self, colors: List[int]) -> int:\\n        \\n        ans = -1 \\n        for i in range(len(colors)):\\n                if colors[i] != colors[0]:\\n                    ans = max(ans, i)\\n                if colors[i] != colors[-1]:\\n                    ans = max(ans, len(colors)- i - 1)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2306251,
                "title": "java-greedy-explained",
                "content": "**Idea:** Max distance involves one of first or last houses\\n**Method 1:** Find the last house different from first and first house different from last. Return the max of two distances\\n>**T/S:** O(n)/O(1)\\n```\\npublic int maxDistance(int[] colors) {\\n\\tvar distance = 0;\\n\\t\\n\\tfor (int i = 0, n = colors.length; i < n; i++) {\\n\\t\\tif (colors[i] != colors[0])\\n\\t\\t\\tdistance = Math.max(distance, i);\\n\\t\\tif (colors[i] != colors[n - 1])\\n\\t\\t\\tdistance = Math.max(distance, n - 1 - i);\\n\\t}\\n\\treturn distance;\\n}\\n```\\n**Method 2:** Same idea, different code\\n>**T/S:** O(n)/O(1)\\n```\\npublic int maxDistance(int[] colors) {\\n\\tvar n = colors.length;\\n\\tvar right = n - 1;\\n\\tvar left = 0;\\n\\n\\tfor (; right >= 0 && colors[0] == colors[right]; right--);\\n\\tfor (; left < n && colors[left] == colors[n - 1]; left++);\\n\\treturn Math.max(n - 1 - left, right);\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int maxDistance(int[] colors) {\\n\\tvar distance = 0;\\n\\t\\n\\tfor (int i = 0, n = colors.length; i < n; i++) {\\n\\t\\tif (colors[i] != colors[0])\\n\\t\\t\\tdistance = Math.max(distance, i);\\n\\t\\tif (colors[i] != colors[n - 1])\\n\\t\\t\\tdistance = Math.max(distance, n - 1 - i);\\n\\t}\\n\\treturn distance;\\n}\\n```\n```\\npublic int maxDistance(int[] colors) {\\n\\tvar n = colors.length;\\n\\tvar right = n - 1;\\n\\tvar left = 0;\\n\\n\\tfor (; right >= 0 && colors[0] == colors[right]; right--);\\n\\tfor (; left < n && colors[left] == colors[n - 1]; left++);\\n\\treturn Math.max(n - 1 - left, right);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2304419,
                "title": "super-easy-0ms-100",
                "content": "```\\npublic int maxDistance(int[] A) {\\n        int n = A.length, i = 0, j = n-1;\\n        while (A[0] == A[j]) j--;\\n        while (A[n - 1] == A[i]) i++;\\n        return Math.max(n - 1 - i, j);\\n        \\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int maxDistance(int[] A) {\\n        int n = A.length, i = 0, j = n-1;\\n        while (A[0] == A[j]) j--;\\n        while (A[n - 1] == A[i]) i++;\\n        return Math.max(n - 1 - i, j);\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2234855,
                "title": "c-solution",
                "content": "int maxDistance(vector<int>& colors) {\\n        int n=colors.size();\\n        if(colors[0]!=colors[n-1]){\\n            return n-1;\\n        }\\n        int i=0;\\n        int j=n-1;\\n        int res1;\\n        int res2;\\n        while(i<j){\\n            if(colors[i]!=colors[j]){\\n                res1=j-i;\\n                break;\\n            }\\n            else{\\n                j--;\\n            }\\n        }\\n        i=0,j=n-1;\\n         while(i<j){\\n            if(colors[i]!=colors[j]){\\n                res2=j-i;\\n                break;\\n            }\\n            else{\\n                i++;\\n            }\\n        }\\n        int res=max(res1,res2);\\n        return res;\\n    }",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "int maxDistance(vector<int>& colors) {\\n        int n=colors.size();\\n        if(colors[0]!=colors[n-1]){\\n            return n-1;\\n        }\\n        int i=0;\\n        int j=n-1;\\n        int res1;\\n        int res2;\\n        while(i<j){\\n            if(colors[i]!=colors[j]){\\n                res1=j-i;\\n                break;\\n            }\\n            else{\\n                j--;\\n            }\\n        }\\n        i=0,j=n-1;\\n         while(i<j){\\n            if(colors[i]!=colors[j]){\\n                res2=j-i;\\n                break;\\n            }\\n            else{\\n                i++;\\n            }\\n        }\\n        int res=max(res1,res2);\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2126746,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def maxDistance(self, colors):\\n        \\n        max_distance = 0\\n        \\n        for i in range(1, len(colors)):\\n            if colors[0] != colors[i]:\\n                max_distance = max(max_distance, i)\\n            if colors[i] != colors[-1]:\\n                max_distance = max(max_distance, len(colors) - i - 1)\\n            \\n        return max_distance\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maxDistance(self, colors):\\n        \\n        max_distance = 0\\n        \\n        for i in range(1, len(colors)):\\n            if colors[0] != colors[i]:\\n                max_distance = max(max_distance, i)\\n            if colors[i] != colors[-1]:\\n                max_distance = max(max_distance, len(colors) - i - 1)\\n            \\n        return max_distance\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2115394,
                "title": "python-o-n-time-o-1-space-easy-to-understand",
                "content": "* The premise is that the first house will always have some other house with a different color, and the last one will always have some other house with a different color (if confused about this fact, read the description carefully).\\n* Using the above premise, we conclude that the max distance is either between the first house and the last differently colored house, or the last house and the first differently colored house.\\n\\nSo we go through the loop, and we update the max using the above rule. Then finally we return it.\\n\\n```\\nclass Solution:\\n    def maxDistance(self, colors: List[int]) -> int:\\n        res = 0\\n        for i in range(len(colors)):\\n            if colors[i] != colors[0]:\\n                res = max(res, i)\\n            if colors[i] != colors[-1]:\\n                res = max(res, len(colors)-1-i)\\n                \\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxDistance(self, colors: List[int]) -> int:\\n        res = 0\\n        for i in range(len(colors)):\\n            if colors[i] != colors[0]:\\n                res = max(res, i)\\n            if colors[i] != colors[-1]:\\n                res = max(res, len(colors)-1-i)\\n                \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2100626,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        int distance = 0;\\n        \\n        for(int i = 0;i<colors.size();i++)\\n        {\\n            int j = colors.size()-1;\\n            \\n            while(i < j){\\n                if(colors[i] != colors[j]){\\n                    distance = max(distance,abs(i - j));\\n            }\\n            j--;\\n            }\\n            \\n            \\n        }\\n        return distance;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        int distance = 0;\\n        \\n        for(int i = 0;i<colors.size();i++)\\n        {\\n            int j = colors.size()-1;\\n            \\n            while(i < j){\\n                if(colors[i] != colors[j]){\\n                    distance = max(distance,abs(i - j));\\n            }\\n            j--;\\n            }\\n            \\n            \\n        }\\n        return distance;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2094592,
                "title": "easiest-and-fastest-solution-1ms-runtime-java",
                "content": "\\t\\tint n = colors.length;\\n        \\n        int maxDiff = Integer.MIN_VALUE;\\n        \\n        for(int i=0; i<n-1; i++){\\n            \\n            int diff = 0;\\n            \\n            for(int j=i+1; j<n; j++){\\n                \\n                if(colors[i] != colors[j]){\\n                    diff = Math.abs(i-j);\\n                }\\n            }\\n            maxDiff = Math.max(maxDiff, diff);\\n        }\\n        return maxDiff;",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "\\t\\tint n = colors.length;\\n        \\n        int maxDiff = Integer.MIN_VALUE;\\n        \\n        for(int i=0; i<n-1; i++){\\n            \\n            int diff = 0;\\n            \\n            for(int j=i+1; j<n; j++){\\n                \\n                if(colors[i] != colors[j]){\\n                    diff = Math.abs(i-j);\\n                }\\n            }\\n            maxDiff = Math.max(maxDiff, diff);\\n        }\\n        return maxDiff;",
                "codeTag": "Unknown"
            },
            {
                "id": 2051117,
                "title": "java-2ms-solution-easy-explanation",
                "content": "class Solution {\\n    public int maxDistance(int[] colors) {  \\n        int i,j,max=0,k;\\n        for(i=0;i<colors.length-1;i++)\\n        {\\n            for(j=i+1;j<colors.length;j++)\\n            {\\n            if(colors[i]!=colors[j]){\\n                k=Math.abs(i-j);\\n                if(max<k)\\n                {\\n                    max=k;\\n                }\\n            }\\n        }\\n    }\\n        return max;\\n  }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int maxDistance(int[] colors) {  \\n        int i,j,max=0,k;\\n        for(i=0;i<colors.length-1;i++)\\n        {\\n            for(j=i+1;j<colors.length;j++)\\n            {\\n            if(colors[i]!=colors[j]){\\n                k=Math.abs(i-j);\\n                if(max<k)\\n                {\\n                    max=k;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2027579,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        int md = 0, n = colors.size();\\n        \\n        for(int i = 0; i < n ; i++){\\n            int left = 0, right = n-1;\\n            \\n            \\n            //look from the left \\n            while(left < i){\\n                if(colors[left] != colors[i]) {\\n                    md = max(md,abs(left-i));\\n                    break;\\n                }\\n                left++;\\n            }\\n            \\n            //look from right\\n            while(right > i){\\n                \\n                if(colors[right] != colors[i]) {\\n                    md = max(md,abs(right-i));\\n                    break;\\n                }\\n                right--;\\n            }\\n            \\n            \\n        }\\n        \\n        \\n        return md;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        int md = 0, n = colors.size();\\n        \\n        for(int i = 0; i < n ; i++){\\n            int left = 0, right = n-1;\\n            \\n            \\n            //look from the left \\n            while(left < i){\\n                if(colors[left] != colors[i]) {\\n                    md = max(md,abs(left-i));\\n                    break;\\n                }\\n                left++;\\n            }\\n            \\n            //look from right\\n            while(right > i){\\n                \\n                if(colors[right] != colors[i]) {\\n                    md = max(md,abs(right-i));\\n                    break;\\n                }\\n                right--;\\n            }\\n            \\n            \\n        }\\n        \\n        \\n        return md;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2007484,
                "title": "two-pointer-easy-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& arr) {\\n        int l=0;\\n        int h=arr.size()-1;\\n        int first=0;\\n        int second=0;\\n        while(l<h)\\n        {\\n            if(arr[l]!=arr[h])\\n            {\\n                first=h-l;\\n                break;\\n            }\\n            else\\n                h--;\\n        }\\n        l=0;\\n        h=arr.size()-1;\\n        while(l<h)\\n        {\\n            if(arr[l]!=arr[h])\\n            {\\n                second=h-l;\\n                break;\\n            }\\n            else\\n                l++;\\n        }\\n         return max(second,first);\\n    }\\n   \\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& arr) {\\n        int l=0;\\n        int h=arr.size()-1;\\n        int first=0;\\n        int second=0;\\n        while(l<h)\\n        {\\n            if(arr[l]!=arr[h])\\n            {\\n                first=h-l;\\n                break;\\n            }\\n            else\\n                h--;\\n        }\\n        l=0;\\n        h=arr.size()-1;\\n        while(l<h)\\n        {\\n            if(arr[l]!=arr[h])\\n            {\\n                second=h-l;\\n                break;\\n            }\\n            else\\n                l++;\\n        }\\n         return max(second,first);\\n    }\\n   \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1898886,
                "title": "explained-o-n-easy-to-understand-javascript",
                "content": "Find **two** distance between between first element (a) & last element (b). (when a !=b) \\n\\n**first distance:** from index 0 to last different element;\\nindex 0 is fixed change another.\\n \\n**second distance:** from last index to first different element; \\nlast index is fixed change another.\\n\\n\\n**EXAMPLE:** \\n```arr=[1,1,1,6,7,5,4,3,2,8,1,1,1,1];``` \\n\\n```first distance= arr[0]~arr[9] ----> 1~8 ----> 9;``` \\n\\n```second distance=arr[arr.length-1]~arr[3] ----> 1~6 ---->10;``` \\n\\nas 10 is max return 10;\\n**note:** in the first case index 0 is fixed, in second index last is fixed. \\n\\n\\n```\\nvar maxDistance = function(c) {\\n    let n=c.length;\\n     \\n    let indx1=0;\\n    while(true){ \\n      if(c[n-1]!==c[indx1]){break;}\\n      indx1++;\\n    }\\n    \\n    let indx2=c.length-1;\\n    while(true){\\n        if(c[0]!==c[indx2]){break;}\\n        indx2--;\\n    }\\n    return Math.max(n-indx1-1,indx2);  \\n}; \\n```\\n",
                "solutionTags": [],
                "code": "```arr=[1,1,1,6,7,5,4,3,2,8,1,1,1,1];```\n```first distance= arr[0]~arr[9] ----> 1~8 ----> 9;```\n```second distance=arr[arr.length-1]~arr[3] ----> 1~6 ---->10;```\n```\\nvar maxDistance = function(c) {\\n    let n=c.length;\\n     \\n    let indx1=0;\\n    while(true){ \\n      if(c[n-1]!==c[indx1]){break;}\\n      indx1++;\\n    }\\n    \\n    let indx2=c.length-1;\\n    while(true){\\n        if(c[0]!==c[indx2]){break;}\\n        indx2--;\\n    }\\n    return Math.max(n-indx1-1,indx2);  \\n}; \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1878208,
                "title": "python-easy-solution-by-swiping-from-left-and-right",
                "content": "\"\"\"\\n\\n    def maxDistance(self, colors: List[int]) -> int:\\n        leftmax, rightmax = 0,0\\n        \\n        i, j = 0, len(colors) -1\\n        \\n        # Swiping from right to left\\n        while(i<j):\\n            if colors[i] != colors[j]:\\n                leftmax = j - i\\n                break\\n            else:\\n                j -= 1\\n        \\n        i, j = 0, len(colors) -1\\n        # Swiping from left to right\\n        while(i<j):\\n            if colors[i] != colors[j]:\\n                rightmax = j - i\\n                break\\n            else:\\n                i += 1\\n                \\n        return max(leftmax, rightmax)\\n\"\"\"",
                "solutionTags": [],
                "code": "\"\"\"\\n\\n    def maxDistance(self, colors: List[int]) -> int:\\n        leftmax, rightmax = 0,0\\n        \\n        i, j = 0, len(colors) -1\\n        \\n        # Swiping from right to left\\n        while(i<j):\\n            if colors[i] != colors[j]:\\n                leftmax = j - i\\n                break\\n            else:\\n                j -= 1\\n        \\n        i, j = 0, len(colors) -1\\n        # Swiping from left to right\\n        while(i<j):\\n            if colors[i] != colors[j]:\\n                rightmax = j - i\\n                break\\n            else:\\n                i += 1\\n                \\n        return max(leftmax, rightmax)\\n\"\"\"",
                "codeTag": "Python3"
            },
            {
                "id": 1849660,
                "title": "c-easy-to-understand-o-n-solution-beginners-friendly",
                "content": "// Plaese Upvote If It helps........\\n\\n```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) \\n    {\\n        int n = colors.size();         // extracting the size of the vector\\n        int mx = INT_MIN;              // for storing the ans\\n        \\n        // finding the max distance from left side\\n        // just finding out the different color house for the index 0 at max possible\\n        for(int left=1;left<n;left++)\\n        {\\n            if(colors[left] != colors[0])\\n            {\\n                mx = left;\\n            }\\n        }\\n        \\n        // finding the max distance from right side\\n        // just finding out the different color house for the index n-1 at max possible\\n        for(int right=0;right<n-1;right++)\\n        {\\n            if(colors[right] != colors[n-1] && (n-1-right)>mx)\\n            {\\n                mx = n-1-right;         // storing the max distance value\\n            }\\n        }\\n        \\n        return mx;\\n    }\\n};\\n```\\n\\n// Plaese Upvote If It helps........",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) \\n    {\\n        int n = colors.size();         // extracting the size of the vector\\n        int mx = INT_MIN;              // for storing the ans\\n        \\n        // finding the max distance from left side\\n        // just finding out the different color house for the index 0 at max possible\\n        for(int left=1;left<n;left++)\\n        {\\n            if(colors[left] != colors[0])\\n            {\\n                mx = left;\\n            }\\n        }\\n        \\n        // finding the max distance from right side\\n        // just finding out the different color house for the index n-1 at max possible\\n        for(int right=0;right<n-1;right++)\\n        {\\n            if(colors[right] != colors[n-1] && (n-1-right)>mx)\\n            {\\n                mx = n-1-right;         // storing the max distance value\\n            }\\n        }\\n        \\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1797377,
                "title": "java-iterate-from-both-end-using-two-sets-of-start-and-end",
                "content": "```\\nclass Solution {\\n    public int maxDistance(int[] colors) {\\n        int start1 = 0;\\n        int end1 = colors.length - 1;\\n\\n        int start = 0;\\n        int end = colors.length - 1;\\n\\n        while (start < end) {\\n            if (colors[start] != colors[end]) {\\n                return Math.abs(end - start);\\n            }\\n            end--;\\n            if (colors[start1] != colors[end1]) {\\n                return Math.abs(end1 - start1);\\n            }\\n            start1++;\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDistance(int[] colors) {\\n        int start1 = 0;\\n        int end1 = colors.length - 1;\\n\\n        int start = 0;\\n        int end = colors.length - 1;\\n\\n        while (start < end) {\\n            if (colors[start] != colors[end]) {\\n                return Math.abs(end - start);\\n            }\\n            end--;\\n            if (colors[start1] != colors[end1]) {\\n                return Math.abs(end1 - start1);\\n            }\\n            start1++;\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1776517,
                "title": "java-easy-easy-to-understand",
                "content": "The problem is quite interesting can be solve in O(n2) and also in O(n) also \\nLets discuss optimal approach\\n\\nmax distance will be either end of the array so we are first finding first color that is not equals to the end of the array and so on \\n\\n```\\nclass Solution {\\n    public int maxDistance(int[] colors) \\n    {\\n        int n = colors.length;\\n        int i =0;\\n        int j = n-1;\\n        int ans = Integer.MIN_VALUE;\\n        while(colors[i]==colors[n-1])\\n        {\\n            i++;\\n        }\\n        ans = Math.max(ans,(n-1-i));\\n        while(colors[j]==colors[0])\\n        {\\n            j--;\\n        }\\n        ans = Math.max(ans,(j-0));\\n        return ans;\\n        \\n        \\n    }\\n}\\n```\\n\\nTC - O(n)\\nSC - O(1)\\n\\n100%",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDistance(int[] colors) \\n    {\\n        int n = colors.length;\\n        int i =0;\\n        int j = n-1;\\n        int ans = Integer.MIN_VALUE;\\n        while(colors[i]==colors[n-1])\\n        {\\n            i++;\\n        }\\n        ans = Math.max(ans,(n-1-i));\\n        while(colors[j]==colors[0])\\n        {\\n            j--;\\n        }\\n        ans = Math.max(ans,(j-0));\\n        return ans;\\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1768830,
                "title": "python-easy-and-understandable-solution-92-faster",
                "content": "We need to find the maximum distance, therefore one of the houses should be at one of the ends only, then only the difference is maximum.\\n```\\nclass Solution:\\n    def maxDistance(self, colors: List[int]) -> int:\\n        clr=colors[0]\\n        clr2=colors[-1]\\n        maxi=0\\n        for i in range(len(colors)-1,-1,-1):\\n            if clr!=colors[i]:\\n                maxi=max(maxi,i)\\n                break\\n        for i in range(len(colors)):\\n            if clr2!=colors[i]:\\n                maxi=max(maxi,len(colors)-i-1)\\n        return maxi\\n```\\n1. Here we take the first and last colours of house as `clr` and `clr2`\\n1. First traverising from the last if the colour of the house is not same as `clr` we save the index ( which is the distance between the houses) in maxi then break\\n1. Then traversing from the beginning of the list if the color of the house is not same, subtract the index from `len(colors)-1`, which we will compare with maxi and save the maximum\\n1. Maximum distance is returned\\n\\n#thanks for viewing the solution",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxDistance(self, colors: List[int]) -> int:\\n        clr=colors[0]\\n        clr2=colors[-1]\\n        maxi=0\\n        for i in range(len(colors)-1,-1,-1):\\n            if clr!=colors[i]:\\n                maxi=max(maxi,i)\\n                break\\n        for i in range(len(colors)):\\n            if clr2!=colors[i]:\\n                maxi=max(maxi,len(colors)-i-1)\\n        return maxi\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1725520,
                "title": "beginner-friendly-javascript-solution",
                "content": "```\\n/**\\n * @param {number[]} colors\\n * @return {number}\\n */\\nvar maxDistance = function(colors) {\\n    let l = 0, r = colors.length-1;\\n    while(colors[colors.length-1] == colors[l]) l++;\\n    while(colors[0] == colors[r]) r--;\\n    return Math.max(r, colors.length - 1 - l);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} colors\\n * @return {number}\\n */\\nvar maxDistance = function(colors) {\\n    let l = 0, r = colors.length-1;\\n    while(colors[colors.length-1] == colors[l]) l++;\\n    while(colors[0] == colors[r]) r--;\\n    return Math.max(r, colors.length - 1 - l);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1690903,
                "title": "c-time-complexity-o-n-space-complexity-o-1-two-pointers-and-one-end-at-a-time-traversal",
                "content": "```\\n#define deb(x) cout << #x << \" = \" << x << endl;\\n#define min(a, b) a < b ? a : b\\n#define max(a, b) a > b ? a : b\\n\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        int n = colors.size();\\n        int res = 0, start = 0, finish = n - 1, startCopy = 0, finishCopy = n - 1;;\\n        \\n        while (colors[start] == colors[finishCopy])\\n            start++;\\n        while (colors[startCopy] == colors[finish])\\n            finish--;\\n        \\n        res = max((finishCopy - start), (finish - startCopy));\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n#define deb(x) cout << #x << \" = \" << x << endl;\\n#define min(a, b) a < b ? a : b\\n#define max(a, b) a > b ? a : b\\n\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        int n = colors.size();\\n        int res = 0, start = 0, finish = n - 1, startCopy = 0, finishCopy = n - 1;;\\n        \\n        while (colors[start] == colors[finishCopy])\\n            start++;\\n        while (colors[startCopy] == colors[finish])\\n            finish--;\\n        \\n        res = max((finishCopy - start), (finish - startCopy));\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1684415,
                "title": "c-runtime-0-ms-faster-than-100-00-memory-usage-9-1-mb-less-than-20-34",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        int i, first = colors[0], sz = colors.size();\\n        int j, last = colors[sz - 1];\\n        for(i = sz - 1 ; i >= 0 ; i--) if(colors[i] != first) break;\\n        for(j = 0 ; j < sz ; j++) if(colors[j] != last) break;\\n        return max(i, sz-1-j);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        int i, first = colors[0], sz = colors.size();\\n        int j, last = colors[sz - 1];\\n        for(i = sz - 1 ; i >= 0 ; i--) if(colors[i] != first) break;\\n        for(j = 0 ; j < sz ; j++) if(colors[j] != last) break;\\n        return max(i, sz-1-j);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1663999,
                "title": "faster-than-100-00-of-go-online-submissions-for-two-furthest-houses-with-different-colors",
                "content": "```\\nfunc maxDistance(colors []int) int {\\n    a := colors[0]\\n    b := colors[len(colors)-1]\\n    left := -1\\n    right := -1\\n    var i int\\n    for j := len(colors)-1; j >= 1; j-- {\\n        if left == -1 && a != colors[j] {\\n            left = j\\n        }\\n        if right == -1 && b != colors[i] {\\n            right = j\\n        }\\n        i++\\n    }\\n    \\n    if left > right {\\n        return left\\n    }\\n    \\n    return right\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc maxDistance(colors []int) int {\\n    a := colors[0]\\n    b := colors[len(colors)-1]\\n    left := -1\\n    right := -1\\n    var i int\\n    for j := len(colors)-1; j >= 1; j-- {\\n        if left == -1 && a != colors[j] {\\n            left = j\\n        }\\n        if right == -1 && b != colors[i] {\\n            right = j\\n        }\\n        i++\\n    }\\n    \\n    if left > right {\\n        return left\\n    }\\n    \\n    return right\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1661792,
                "title": "brute-force-solution-simple",
                "content": "public int maxDistance(int[] colors) {\\nint maxdis = 0;\\nfor (int i = 0;i<colors.length;i++){\\n for (int j = 0; j<colors.length;j++) {\\n\\n     if (colors[i] != colors[j] ){\\n       if (Math.abs(i-j)>maxdis ){\\n           maxdis = Math.abs(i-j);\\n       }\\n\\n\\n\\n     }\\n }\\n}\\n\\nreturn maxdis;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "public int maxDistance(int[] colors) {\\nint maxdis = 0;\\nfor (int i = 0;i<colors.length;i++){\\n for (int j = 0; j<colors.length;j++) {\\n\\n     if (colors[i] != colors[j] ){\\n       if (Math.abs(i-j)>maxdis ){\\n           maxdis = Math.abs(i-j);\\n       }\\n\\n\\n\\n     }\\n }\\n}\\n\\nreturn maxdis;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1656662,
                "title": "python-one-liner-using-list-comprehensions",
                "content": "```\\nclass Solution:\\n    def maxDistance(self, colors: List[int]) -> int:\\n \\xA0 \\xA0 \\xA0 \\xA0return max([abs(i-j) for i in range(len(colors)) for j in range (len(colors)) if colors[i]!=colors[j]]) \\n```\\n\\t\\t",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxDistance(self, colors: List[int]) -> int:\\n \\xA0 \\xA0 \\xA0 \\xA0return max([abs(i-j) for i in range(len(colors)) for j in range (len(colors)) if colors[i]!=colors[j]]) \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1646085,
                "title": "simple-easy-solution-by-python-3",
                "content": "```\\nclass Solution:\\n    def maxDistance(self, colors: List[int]) -> int:\\n        for i in range(len(colors) - 1):\\n            if colors[i] != colors[-1] or colors[-(i + 1)] != colors[0]:\\n                return len(colors) - i - 1\\n\\n        return 0\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxDistance(self, colors: List[int]) -> int:\\n        for i in range(len(colors) - 1):\\n            if colors[i] != colors[-1] or colors[-(i + 1)] != colors[0]:\\n                return len(colors) - i - 1\\n\\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1623156,
                "title": "c-0ms-100-faster-than-c-2-lines-solutions-easy-clean-explained",
                "content": "**C++ solutions :**\\n```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& a,int maxl=1) {\\n        for(int i=0;i<a.size();i++)\\n        for(int j=i+1;j<a.size();j++) if(abs(j-i)>maxl && a[i]!=a[j]) maxl=abs(j-i);\\n        return maxl;\\n    }\\n};\\n```\\n**if you like this solutions , please upvote for my motivations \\nany doubt ---> comment\\nThank you.**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& a,int maxl=1) {\\n        for(int i=0;i<a.size();i++)\\n        for(int j=i+1;j<a.size();j++) if(abs(j-i)>maxl && a[i]!=a[j]) maxl=abs(j-i);\\n        return maxl;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1611799,
                "title": "java-0ms-explanations",
                "content": "```\\nclass Solution {\\n    /** Algorithm\\n        1. The max distance must be between two possibilies:\\n            - one house [0] and one house between [n..1] OR\\n            - one from from [N] and one house from [0...n-1].\\n        2. Traverse the array twice, once from left and once from right and measure the max from both sides. \\n        3. Return the max of both traversals.   \\n    */\\n    public int maxDistance(int[] colors) {\\n        int max = 1;\\n        // select house[0] and look for houses from n,n-1, n-2 .. 1. Break at the first found as this is the max\\n        for (int i = colors.length -1; i >= 1; i--) {\\n           if (colors[0] != colors[i]) {\\n               max = Math.max(max, i);\\n               break;\\n           } \\n        }\\n        // select house[n] and look for houses from 0,1...n-1. Break at the first found as this is the max\\n        for(int i = 0; i < colors.length -1; i++) {\\n            if (colors[i] != colors[colors.length -1]) {\\n                max = Math.max(max, colors.length -1 - i);\\n                break;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    /** Algorithm\\n        1. The max distance must be between two possibilies:\\n            - one house [0] and one house between [n..1] OR\\n            - one from from [N] and one house from [0...n-1].\\n        2. Traverse the array twice, once from left and once from right and measure the max from both sides. \\n        3. Return the max of both traversals.   \\n    */\\n    public int maxDistance(int[] colors) {\\n        int max = 1;\\n        // select house[0] and look for houses from n,n-1, n-2 .. 1. Break at the first found as this is the max\\n        for (int i = colors.length -1; i >= 1; i--) {\\n           if (colors[0] != colors[i]) {\\n               max = Math.max(max, i);\\n               break;\\n           } \\n        }\\n        // select house[n] and look for houses from 0,1...n-1. Break at the first found as this is the max\\n        for(int i = 0; i < colors.length -1; i++) {\\n            if (colors[i] != colors[colors.length -1]) {\\n                max = Math.max(max, colors.length -1 - i);\\n                break;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1602995,
                "title": "100-fast-o-n",
                "content": "```\\nclass Solution {\\n    public int maxDistance(int[] colors) {\\n        int len=-1;\\n        int start = 0,end=colors.length-1;\\n        //Left->Right scan\\n        while(start<end){\\n            if(colors[start]==colors[end]){\\n                start++;\\n            }else{\\n                if(len< end-start)\\n                    len=end-start;\\n                end--;\\n            }\\n        }\\n        start = 0;\\n        end=colors.length-1;\\n        //Right->Left scan\\n         while(start<end){\\n            if(colors[start]==colors[end]){\\n                end--;\\n            }else{\\n                if(len< end-start)\\n                    len=end-start;\\n                start++;\\n            }\\n        }\\n        return len;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDistance(int[] colors) {\\n        int len=-1;\\n        int start = 0,end=colors.length-1;\\n        //Left->Right scan\\n        while(start<end){\\n            if(colors[start]==colors[end]){\\n                start++;\\n            }else{\\n                if(len< end-start)\\n                    len=end-start;\\n                end--;\\n            }\\n        }\\n        start = 0;\\n        end=colors.length-1;\\n        //Right->Left scan\\n         while(start<end){\\n            if(colors[start]==colors[end]){\\n                end--;\\n            }else{\\n                if(len< end-start)\\n                    len=end-start;\\n                start++;\\n            }\\n        }\\n        return len;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1600345,
                "title": "java-dp",
                "content": "class Solution {\\n    public int maxDistance(int[] colors) {\\n        int[] DP = new int[colors.length];\\n        for(int i=0; i<colors.length; i++){\\n            int j = 0;\\n            while(colors[j] == colors[i] && j < i){\\n                j++;\\n            }\\n            DP[i] = i-j;\\n        }\\n        \\n        int furthestDistance = 0;\\n         for(int i=0; i<colors.length; i++){\\n             System.out.print(DP[i]+\" \");\\n            furthestDistance = Math.max(furthestDistance, DP[i]);\\n         }\\n        \\n        return furthestDistance;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int maxDistance(int[] colors) {\\n        int[] DP = new int[colors.length];\\n        for(int i=0; i<colors.length; i++){\\n            int j = 0;\\n            while(colors[j] == colors[i] && j < i){\\n                j++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1595237,
                "title": "swift-clean-solution",
                "content": "```\\nclass Solution {\\n    func maxDistance(_ colors: [Int]) -> Int {\\n        var l = 0\\n        var r = colors.count - 1\\n        var n = colors.count - 1\\n        \\n        // find max distance from index 0\\n        while colors[0] == colors[r] {\\n            r -= 1\\n        }\\n        // find max distance from last index\\n        while colors[l] == colors[n] {\\n            l += 1\\n        }\\n        // return max\\n        return max(r-0, n-l)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func maxDistance(_ colors: [Int]) -> Int {\\n        var l = 0\\n        var r = colors.count - 1\\n        var n = colors.count - 1\\n        \\n        // find max distance from index 0\\n        while colors[0] == colors[r] {\\n            r -= 1\\n        }\\n        // find max distance from last index\\n        while colors[l] == colors[n] {\\n            l += 1\\n        }\\n        // return max\\n        return max(r-0, n-l)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1594332,
                "title": "java-100-one-pass",
                "content": "```\\npublic int maxDistance(int[] colors) {\\n        int size = colors.length - 1;\\n        int half = colors.length / 2;\\n        for(int i = 0; i <= half; i++) {\\n            if((colors[size] != colors[i]) || colors[0] != colors[size - i]) {\\n                return size - i;\\n            }\\n        }\\n        return -1;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int maxDistance(int[] colors) {\\n        int size = colors.length - 1;\\n        int half = colors.length / 2;\\n        for(int i = 0; i <= half; i++) {\\n            if((colors[size] != colors[i]) || colors[0] != colors[size - i]) {\\n                return size - i;\\n            }\\n        }\\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1592777,
                "title": "python-one-liner-o-n",
                "content": "An ugly one-liner for fun:\\n```\\n    def maxDistance(self, A):\\n        return max(max(0 if x == A[0] else i, 0 if x == A[-1] else len(A) - i - 1) for i, x in enumerate(A))\\n```\\n\\nHere it is in expanded form:\\n```\\n    def maxDistance(self, A):\\n        res = 0\\n        for i, x in enumerate(A):\\n            if x != A[0]:\\n                res = max(res, i)\\n            if x != A[-1]:\\n                res = max(res, len(A) - 1 - i)\\n        return res",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def maxDistance(self, A):\\n        return max(max(0 if x == A[0] else i, 0 if x == A[-1] else len(A) - i - 1) for i, x in enumerate(A))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1591593,
                "title": "c-worst-case-o-n-time-complexity-and-o-1-space-complexity",
                "content": "The basic approach is that result can be obtained using end points only:\\n1. find the max(i - 0) by fixing the first element and comparing other element from opposite end if its equal then move to next value other wise (i - 0) is the max value in that case and break the loop.\\n2. Repeat the above case and find max (n - 1 - i) fixing the last element and starting from 0 index.\\n3. Maximum of both values will be desired result.\\n```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        int n = colors.size();\\n        int max_value_1 = n - 1;\\n        int max_value_2 = n - 1;\\n        while(colors[0] == colors[max_value_1])\\n            max_value_1--;\\n        while((colors[n - 1] == colors[n - 1 - max_value_2]) && (max_value_2 > max_value_1))\\n            max_value_2--;\\n        return max(max_value_1, max_value_2);\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        int n = colors.size();\\n        int max_value_1 = n - 1;\\n        int max_value_2 = n - 1;\\n        while(colors[0] == colors[max_value_1])\\n            max_value_1--;\\n        while((colors[n - 1] == colors[n - 1 - max_value_2]) && (max_value_2 > max_value_1))\\n            max_value_2--;\\n        return max(max_value_1, max_value_2);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1591108,
                "title": "c-solution",
                "content": "Solution 1:\\n```\\npublic class Solution {\\n    public int MaxDistance(int[] colors) {\\n        int max = 0, length = colors.Length;\\n        for(int i = 0; i < length; i++){\\n            if(colors[0] != colors[i])\\n                max = Math.Max(max, i);\\n            if(colors[length-1] != colors[i])\\n                max = Math.Max(max, length-i-1);\\n        }\\n        return max;\\n    }\\n}\\n```\\n\\nSolution 2:\\n```\\npublic class Solution {\\n    public int MaxDistance(int[] colors) {\\n        int i = 0, j = colors.Length-1, n = colors.Length-1;\\n        while(colors[i] == colors[n])\\n            i++;\\n        while(colors[j] == colors[0])\\n            j--;\\n        return Math.Max(j, n-i);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MaxDistance(int[] colors) {\\n        int max = 0, length = colors.Length;\\n        for(int i = 0; i < length; i++){\\n            if(colors[0] != colors[i])\\n                max = Math.Max(max, i);\\n            if(colors[length-1] != colors[i])\\n                max = Math.Max(max, length-i-1);\\n        }\\n        return max;\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public int MaxDistance(int[] colors) {\\n        int i = 0, j = colors.Length-1, n = colors.Length-1;\\n        while(colors[i] == colors[n])\\n            i++;\\n        while(colors[j] == colors[0])\\n            j--;\\n        return Math.Max(j, n-i);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1590840,
                "title": "simple-java-solution",
                "content": "class Solution {\\n\\n    public int maxDistance(int[] c) {\\n        int k=c.length,m=0,n=0;\\n        for(int i=0;i<k;i++)\\n        {\\n            if(c[k-1]!=c[i])\\n            {\\n                m=Math.max(m,k-1-i);\\n            }\\n        }\\n        for(int i=k-1;i>=0;i--)\\n        {\\n            if(c[i]!=c[0])\\n            {\\n                n=Math.max(n,i-0);\\n            }\\n        }\\n        return Math.max(m,n);\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n    public int maxDistance(int[] c) {\\n        int k=c.length,m=0,n=0;\\n        for(int i=0;i<k;i++)\\n        {\\n            if(c[k-1]!=c[i])\\n            {\\n                m=Math.max(m,k-1-i);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1590836,
                "title": "c-two-pointers-o-n-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        int ans=INT_MIN;\\n        int i=0;\\n        int j=colors.size()-1;\\n        while(j!=i){\\n            if(colors[i]!=colors[j]) ans=max(ans,abs(j-i));\\n            j--;\\n        }\\n          j = colors.size()-1;\\n         while(i!=j){\\n            if(colors[i]!=colors[j]) ans=max(ans,abs(j-i));\\n            i++;\\n        }\\n           return ans;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        int ans=INT_MIN;\\n        int i=0;\\n        int j=colors.size()-1;\\n        while(j!=i){\\n            if(colors[i]!=colors[j]) ans=max(ans,abs(j-i));\\n            j--;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1590625,
                "title": "c-2078-two-furthest-houses-with-different-colors",
                "content": "\\n\\n```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        int ans = 0, n = colors.size(); \\n        for (int i = 0; i < n; ++i) {\\n            if (colors.front() != colors[i]) ans = max(ans, i); \\n            if (colors[i] != colors.back()) ans = max(ans, n-1-i); \\n        }\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        int ans = 0, n = colors.size(); \\n        for (int i = 0; i < n; ++i) {\\n            if (colors.front() != colors[i]) ans = max(ans, i); \\n            if (colors[i] != colors.back()) ans = max(ans, n-1-i); \\n        }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1590506,
                "title": "c-brute-force-and-optimal-solution-o-n-2-and-o-n-time-complexity",
                "content": "**Brute Force solution :**\\n```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        int mxDist = 0;\\n        int size = colors.size();\\n        for(int i = 0; i < size; i++){\\n            for(int j = 0; j < size; j++){\\n                if(colors[i] != colors[j])\\n                    mxDist = max(mxDist, (j - i));\\n            }\\n        }\\n        return mxDist;\\n    }\\n};\\n```\\n\\n** **\\n**Optimal Solution :**\\n```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        int mxDist = 0;\\n        int size = colors.size();\\n        int first = colors[0];\\n        for(int i = size-1; i >= 0; i--){\\n            if(first != colors[i]){\\n                mxDist = max(mxDist, i);\\n                break;\\n            }\\n        }\\n        int last = colors[size-1];\\n        for(int i = 0; i < size; i++){\\n            if(colors[i] != last){\\n                mxDist = max(mxDist, size-1-i);\\n            }\\n        }\\n        return mxDist;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        int mxDist = 0;\\n        int size = colors.size();\\n        for(int i = 0; i < size; i++){\\n            for(int j = 0; j < size; j++){\\n                if(colors[i] != colors[j])\\n                    mxDist = max(mxDist, (j - i));\\n            }\\n        }\\n        return mxDist;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        int mxDist = 0;\\n        int size = colors.size();\\n        int first = colors[0];\\n        for(int i = size-1; i >= 0; i--){\\n            if(first != colors[i]){\\n                mxDist = max(mxDist, i);\\n                break;\\n            }\\n        }\\n        int last = colors[size-1];\\n        for(int i = 0; i < size; i++){\\n            if(colors[i] != last){\\n                mxDist = max(mxDist, size-1-i);\\n            }\\n        }\\n        return mxDist;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1590166,
                "title": "two-pass-0ms",
                "content": "```\\nclass Solution {\\n    public int maxDistance(int[] colors) {\\n        int l=0;\\n        int r=colors.length-1;\\n        int dis=0;\\n        while(l<r){\\n            if(colors[l]!=colors[r--]){\\n                dis=r-l + 1;\\n                break;\\n            }\\n        }\\n        l=0;\\n        r=colors.length-1;\\n        while(l<r){\\n            if(colors[l++]!=colors[r]){\\n                dis=Math.max(dis,r-l + 1);\\n                break;\\n            } \\n        }\\n        return dis;\\n    }\\n}",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "class Solution {\\n    public int maxDistance(int[] colors) {\\n        int l=0;\\n        int r=colors.length-1;\\n        int dis=0;\\n        while(l<r){\\n            if(colors[l]!=colors[r--]){\\n                dis=r-l + 1;\\n                break;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1590139,
                "title": "javascript-js",
                "content": "```\\n/**\\n * @param {number[]} colors\\n * @return {number}\\n */\\nvar maxDistance = function (colors) {\\n  let a = 0;\\n\\n  for (let i = 0; i < colors.length - 1; i++) {\\n    for (let j = i + 1; j < colors.length; j++) {\\n      if (colors[i] !== colors[j]) {\\n        a = Math.max(a, Math.abs(i - j));\\n      }\\n    }\\n  }\\n\\n  return a;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[]} colors\\n * @return {number}\\n */\\nvar maxDistance = function (colors) {\\n  let a = 0;\\n\\n  for (let i = 0; i < colors.length - 1; i++) {\\n    for (let j = i + 1; j < colors.length; j++) {\\n      if (colors[i] !== colors[j]) {\\n        a = Math.max(a, Math.abs(i - j));\\n      }\\n    }\\n  }\\n\\n  return a;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1589987,
                "title": "c-simple-approach",
                "content": "Logic - We store all the distances between two houses of different colours  in the variable x and we find the maximum of all the distances because we want maximum distance between two houses of different colours.\\n```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        int x=0;\\n        int maxx=0;\\n        for(int i=0;i<colors.size()-1;i++){\\n            for(int j=i+1;j<colors.size();j++){\\n                if(colors[i]!=colors[j]) \\n                    x=abs(i-j);\\n                    \\n            }\\n            maxx=max(maxx,x);\\n        }\\n        \\n        return maxx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        int x=0;\\n        int maxx=0;\\n        for(int i=0;i<colors.size()-1;i++){\\n            for(int j=i+1;j<colors.size();j++){\\n                if(colors[i]!=colors[j]) \\n                    x=abs(i-j);\\n                    \\n            }\\n            maxx=max(maxx,x);\\n        }\\n        \\n        return maxx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1589307,
                "title": "java-single-pass-solution",
                "content": "Check whether 1st and n-1th numbers are different if it is so then this will be our answer(n-1)\\nelse\\ncheck the first index from front such that colors[0] !=colors[i]\\n check the last index nearest index from last such that colors[n-1]!=colors[j]\\nthen return maximum of farthest house considering the first index , farthest house considering the last index\\n.Here\\'s the code .\\n\\n\\n\\n```\\nclass Solution {\\n    public int maxDistance(int[] colors) {\\n     int n=colors.length;\\n        if(colors[0]!=colors[n-1])\\n        {\\n            return n-1;\\n        }\\n        int i=n-1;\\n           while(colors[0]==colors[i])\\n           { \\n              i--;\\n           }\\n          int j=0;\\n        while(colors[n-1]==colors[j])\\n        {\\n          j++;\\n        }\\n        return Math.max(n-1-j,i);\\n           \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDistance(int[] colors) {\\n     int n=colors.length;\\n        if(colors[0]!=colors[n-1])\\n        {\\n            return n-1;\\n        }\\n        int i=n-1;\\n           while(colors[0]==colors[i])\\n           { \\n              i--;\\n           }\\n          int j=0;\\n        while(colors[n-1]==colors[j])\\n        {\\n          j++;\\n        }\\n        return Math.max(n-1-j,i);\\n           \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1589130,
                "title": "simple-o-n-time-one-pass-solution-java",
                "content": "```class Solution {\\n    public int maxDistance(int[] colors) {\\n        for(int i=0, j=colors.length-1; i<=j;)\\n        {\\n            if(colors[j]!=colors[i])\\n                return j-i;\\n            if(colors[i]!=colors[i+1])\\n            {\\n                i++;\\n            }\\n            else if(colors[j]!=colors[j-1])\\n            {\\n                j--;\\n            }\\n            else\\n            {\\n                int count1=0;\\n                int count2=0;\\n                int temp1 = i;\\n                int temp2 = j;\\n                while(colors[temp1]==colors[temp1+1])\\n                {\\n                    temp1++;\\n                    count1++;\\n                }\\n                while(colors[temp2]==colors[temp2-1])\\n                {\\n                    temp2--;\\n                    count2++;\\n                }\\n                if(count1<=count2)\\n                {\\n                    i=temp1;\\n                }\\n                else\\n                {\\n                    j=temp2;\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n}```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```class Solution {\\n    public int maxDistance(int[] colors) {\\n        for(int i=0, j=colors.length-1; i<=j;)\\n        {\\n            if(colors[j]!=colors[i])\\n                return j-i;\\n            if(colors[i]!=colors[i+1])\\n            {\\n                i++;\\n            }\\n            else if(colors[j]!=colors[j-1])\\n            {\\n                j--;\\n            }\\n            else\\n            {\\n                int count1=0;\\n                int count2=0;\\n                int temp1 = i;\\n                int temp2 = j;\\n                while(colors[temp1]==colors[temp1+1])\\n                {\\n                    temp1++;\\n                    count1++;\\n                }\\n                while(colors[temp2]==colors[temp2-1])\\n                {\\n                    temp2--;\\n                    count2++;\\n                }\\n                if(count1<=count2)\\n                {\\n                    i=temp1;\\n                }\\n                else\\n                {\\n                    j=temp2;\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n}```",
                "codeTag": "Java"
            },
            {
                "id": 1589122,
                "title": "python-brute-force-to-optimal",
                "content": "```\\n#brute force\\nclass Solution:\\n    def maxDistance(self, colors: List[int]) -> int:\\n        n = len(colors)\\n        res = 0\\n        for i in range(n-1):\\n            for j in range(i+1, n):\\n                if colors[i] != colors[j]:\\n                    res = max(res, abs(i-j))\\n                    \\n        return res\\n```\\n\\n```\\n#using first and last elements\\nclass Solution:\\n    def maxDistance(self, arr: List[int]) -> int:\\n        res = 0 \\n\\t\\tn = len(arr)\\n\\t\\t\\n        for i in range(n): \\n            if arr[i] != arr[0]:  #first\\n\\t\\t\\t\\tres = max(res, i)\\n            if arr[i] != arr[-1]:  #last \\n\\t\\t\\t\\tres = max(res, n-i-1)\\n\\t\\t\\t\\n        return res \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n#brute force\\nclass Solution:\\n    def maxDistance(self, colors: List[int]) -> int:\\n        n = len(colors)\\n        res = 0\\n        for i in range(n-1):\\n            for j in range(i+1, n):\\n                if colors[i] != colors[j]:\\n                    res = max(res, abs(i-j))\\n                    \\n        return res\\n```\n```\\n#using first and last elements\\nclass Solution:\\n    def maxDistance(self, arr: List[int]) -> int:\\n        res = 0 \\n\\t\\tn = len(arr)\\n\\t\\t\\n        for i in range(n): \\n            if arr[i] != arr[0]:  #first\\n\\t\\t\\t\\tres = max(res, i)\\n            if arr[i] != arr[-1]:  #last \\n\\t\\t\\t\\tres = max(res, n-i-1)\\n\\t\\t\\t\\n        return res \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1589083,
                "title": "simple-c-solution",
                "content": "class Solution {\\npublic:\\n    int maxDistance(vector<int>& nums) {\\n        int maxi=INT_MIN;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            for(int j=i;j<nums.size();j++)\\n            {\\n                if(nums[i]!=nums[j])\\n                    maxi=max(j-i,maxi);\\n            }\\n        }\\n        return maxi;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int maxDistance(vector<int>& nums) {\\n        int maxi=INT_MIN;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            for(int j=i;j<nums.size();j++)\\n            {\\n                if(nums[i]!=nums[j])\\n                    maxi=max(j-i,maxi);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 4077562,
                "title": "c-easy-worst-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        int ans=0;\\n        for(int i=0;i<colors.size();i++)\\n        {\\n          for(int j=i+1;j<colors.size();j++)\\n          {\\n            if(colors[i]!=colors[j])\\n            {\\n              ans=max(ans,abs(i-j));\\n            }\\n          }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        int ans=0;\\n        for(int i=0;i<colors.size();i++)\\n        {\\n          for(int j=i+1;j<colors.size();j++)\\n          {\\n            if(colors[i]!=colors[j])\\n            {\\n              ans=max(ans,abs(i-j));\\n            }\\n          }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4075107,
                "title": "2078",
                "content": "# Intuition\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDistance(int[] colors) {\\n        int f = 0, r = colors.length-1;\\n        while(f != r){\\n            if(colors[f] != colors[r]){\\n                return r-f;\\n            }else{\\n                if(colors[f] != colors[f+1]){\\n                    f++;\\n                    return Math.max(r-f,r-1);\\n                }else if(colors[r] != colors[r-1]){\\n                    r--;\\n                    return Math.max(r-f,r-0);\\n                }else{\\n                    r--;\\n                    f++;\\n                }\\n            }\\n        }\\n        return r-f;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDistance(int[] colors) {\\n        int f = 0, r = colors.length-1;\\n        while(f != r){\\n            if(colors[f] != colors[r]){\\n                return r-f;\\n            }else{\\n                if(colors[f] != colors[f+1]){\\n                    f++;\\n                    return Math.max(r-f,r-1);\\n                }else if(colors[r] != colors[r-1]){\\n                    r--;\\n                    return Math.max(r-f,r-0);\\n                }else{\\n                    r--;\\n                    f++;\\n                }\\n            }\\n        }\\n        return r-f;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4062161,
                "title": "one-line-solution",
                "content": "```\\nclass Solution:\\n    def maxDistance(self, colors: List[int]) -> int:\\n        return max(len(colors)-1-reduce(lambda s, _: s+1, takewhile(lambda i: colors[i] == colors[-1], count(0)), 0), reduce(lambda s, _: s-1, takewhile(lambda i: colors[i] == colors[-1], count(len(colors)-1, -1)), len(colors)-1))\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxDistance(self, colors: List[int]) -> int:\\n        return max(len(colors)-1-reduce(lambda s, _: s+1, takewhile(lambda i: colors[i] == colors[-1], count(0)), 0), reduce(lambda s, _: s-1, takewhile(lambda i: colors[i] == colors[-1], count(len(colors)-1, -1)), len(colors)-1))\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4047237,
                "title": "solution-in-java-100ms-runtime",
                "content": "```\\nclass Solution {\\n    public int maxDistance(int[] colors) {\\n        int ans = 0;\\n        int s =0;\\n        int e = colors.length-1;\\n        while(s<e){\\n            while(colors[s]==colors[e]){\\n                e--;\\n            }\\n            ans = Math.max(ans,Math.abs(e-s));\\n            s++;\\n            if(s>0 && colors[s-1]!=colors[s]){\\n               e=colors.length-1;   \\n            }\\n             \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxDistance(int[] colors) {\\n        int ans = 0;\\n        int s =0;\\n        int e = colors.length-1;\\n        while(s<e){\\n            while(colors[s]==colors[e]){\\n                e--;\\n            }\\n            ans = Math.max(ans,Math.abs(e-s));\\n            s++;\\n            if(s>0 && colors[s-1]!=colors[s]){\\n               e=colors.length-1;   \\n            }\\n             \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4042148,
                "title": "c-stl-beats-100",
                "content": "# Intuition\\none of color of **max diffrent color pair** must be location at index 0 or index n-1 \\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        int first = colors[0];\\n        auto iter = std::find_if(colors.rbegin(), colors.rend(), [&](int x){\\n            return x!=first;\\n        });\\n        int end = colors.back();\\n        auto iter2 = std::find_if(colors.begin(), colors.end(), [&](int x){\\n            return x!=end;\\n        });\\n        int dis1 = std::distance(iter,colors.rend())-1;\\n        int dis2 = std::distance(iter2,colors.end())-1;\\n        return max(dis1,dis2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        int first = colors[0];\\n        auto iter = std::find_if(colors.rbegin(), colors.rend(), [&](int x){\\n            return x!=first;\\n        });\\n        int end = colors.back();\\n        auto iter2 = std::find_if(colors.begin(), colors.end(), [&](int x){\\n            return x!=end;\\n        });\\n        int dis1 = std::distance(iter,colors.rend())-1;\\n        int dis2 = std::distance(iter2,colors.end())-1;\\n        return max(dis1,dis2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4039026,
                "title": "c-two-pointers",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\npublic class Solution\\n{\\n    public int MaxDistance(int[] colors)\\n    {\\n        var n = colors.Length;\\n        var i = 0;\\n        var j = n - 1;\\n\\n        while (colors[0] == colors[j])\\n        {\\n            j--;\\n        }\\n\\n        while (colors[n - 1] == colors[i])\\n        {\\n            i++;\\n        }\\n\\n        return Math.Max(n - 1 - i, j);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public int MaxDistance(int[] colors)\\n    {\\n        var n = colors.Length;\\n        var i = 0;\\n        var j = n - 1;\\n\\n        while (colors[0] == colors[j])\\n        {\\n            j--;\\n        }\\n\\n        while (colors[n - 1] == colors[i])\\n        {\\n            i++;\\n        }\\n\\n        return Math.Max(n - 1 - i, j);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4032939,
                "title": "beats-100-fastest-and-smallest-solution",
                "content": "# Intuition\\nif a[i]!=a[j], then a[0] will be farther than a[i], doesnt matter a[0] == a[i] or not. Same intuition from the end.\\n\\n# Approach\\ntwo pointers\\n# Complexity\\n- Time complexity:\\nO(n) + O(n)  = O(2n) = O(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        int ans = 0;\\n        for(int j = 1;j < colors.size();j++){\\n            if(colors[0] != colors[j]){\\n                ans = max(ans, j);\\n            }\\n        }\\n        int n = colors.size();\\n        for(int i = n-2;i >=0;i--){\\n            if(colors[i]!=colors[colors.size()-1]){\\n                ans = max(ans, n-i-1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        int ans = 0;\\n        for(int j = 1;j < colors.size();j++){\\n            if(colors[0] != colors[j]){\\n                ans = max(ans, j);\\n            }\\n        }\\n        int n = colors.size();\\n        for(int i = n-2;i >=0;i--){\\n            if(colors[i]!=colors[colors.size()-1]){\\n                ans = max(ans, n-i-1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4031274,
                "title": "easy-understandable-java-soln",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDistance(int[] colors) {\\n        int n = colors.length;\\n        int i = 0;\\n        int j = n-1;\\n        int dist1 = 0;\\n        int dist2 = 0;\\n        while(i < j) {\\n            if(colors[i] == colors[j]) {\\n                j--;\\n            } else {\\n                dist1 = Math.abs(j - i);\\n                break;\\n            }\\n\\n        }\\n        i = 0; j = n-1;\\n        while(i < j) {\\n            if(colors[i] == colors[j]) {\\n                i++;\\n            } else {\\n                dist2 = Math.abs(j - i);\\n                break;\\n            }\\n        }\\n        return Math.max(dist1, dist2);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDistance(int[] colors) {\\n        int n = colors.length;\\n        int i = 0;\\n        int j = n-1;\\n        int dist1 = 0;\\n        int dist2 = 0;\\n        while(i < j) {\\n            if(colors[i] == colors[j]) {\\n                j--;\\n            } else {\\n                dist1 = Math.abs(j - i);\\n                break;\\n            }\\n\\n        }\\n        i = 0; j = n-1;\\n        while(i < j) {\\n            if(colors[i] == colors[j]) {\\n                i++;\\n            } else {\\n                dist2 = Math.abs(j - i);\\n                break;\\n            }\\n        }\\n        return Math.max(dist1, dist2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4027932,
                "title": "harshi-s-simple-sol",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& c) {\\n       int max=0;\\n       for(int i=0;i<c.size();i++){\\n           for(int j=i+1;j<c.size();j++){\\n                if(c[i]!=c[j])\\n                {\\n                    if(max<j-i)\\n                    max=j-i;\\n                }\\n           }\\n       } \\n       return max;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& c) {\\n       int max=0;\\n       for(int i=0;i<c.size();i++){\\n           for(int j=i+1;j<c.size();j++){\\n                if(c[i]!=c[j])\\n                {\\n                    if(max<j-i)\\n                    max=j-i;\\n                }\\n           }\\n       } \\n       return max;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4024877,
                "title": "simple-c-solution-o-n-runtime-beats-100-memory-beats-93",
                "content": "\\n# Complexity\\n- Time complexity: O(n)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        int l=0;\\n        int r=colors.size()-1;\\n        int m1=0;\\n        int m2=0;\\n        while(l<=r){\\n            if(colors[l]!=colors[r]){\\n                m1=abs(l-r);\\n                break;\\n            }\\n            l++;\\n        }\\n        l=0;\\n        r=colors.size()-1;\\n        while(l<=r){\\n            if(colors[l]!=colors[r]){\\n                m2=abs(l-r);\\n                break;\\n            }\\n            r--;\\n        }\\n        return max(m1,m2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        int l=0;\\n        int r=colors.size()-1;\\n        int m1=0;\\n        int m2=0;\\n        while(l<=r){\\n            if(colors[l]!=colors[r]){\\n                m1=abs(l-r);\\n                break;\\n            }\\n            l++;\\n        }\\n        l=0;\\n        r=colors.size()-1;\\n        while(l<=r){\\n            if(colors[l]!=colors[r]){\\n                m2=abs(l-r);\\n                break;\\n            }\\n            r--;\\n        }\\n        return max(m1,m2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4024360,
                "title": "time-complexity-o-n-space-complexity-o-1-solution-for-beginner",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        \\n        int len = colors.size();\\n        int ans = 0;\\n\\n        for(int i = 1 ; i < len ; i++)\\n        {\\n            if( colors[i] != colors[0])\\n                ans = max(ans,i);\\n            if( colors[i] != colors[len - 1])\\n                ans = max(ans,(len - 1 - i));\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        \\n        int len = colors.size();\\n        int ans = 0;\\n\\n        for(int i = 1 ; i < len ; i++)\\n        {\\n            if( colors[i] != colors[0])\\n                ans = max(ans,i);\\n            if( colors[i] != colors[len - 1])\\n                ans = max(ans,(len - 1 - i));\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4024346,
                "title": "o-n-solution-for-beginner",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        vector <int > distances;\\n        int len = colors.size();\\n\\n        for(int i = 1 ; i < len ; i++)\\n        {\\n            if( colors[i] != colors[0])\\n                distances.push_back(i);\\n            if( colors[i] != colors[len - 1])\\n                distances.push_back(len - 1 - i);\\n        }\\n\\n        return *max_element(distances.begin(),distances.end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        vector <int > distances;\\n        int len = colors.size();\\n\\n        for(int i = 1 ; i < len ; i++)\\n        {\\n            if( colors[i] != colors[0])\\n                distances.push_back(i);\\n            if( colors[i] != colors[len - 1])\\n                distances.push_back(len - 1 - i);\\n        }\\n\\n        return *max_element(distances.begin(),distances.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4005945,
                "title": "for-beginners-beatzz-97",
                "content": "## Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n## Code\\n```\\nclass Solution:\\n    def maxDistance(self, colors: List[int]) -> int:\\n        res = 0\\n        l = 0 \\n        limit = r = len(colors) - 1\\n        while l != limit:\\n            if res >= r - l:\\n                 l += 1\\n                 r = limit\\n                 continue\\n            elif colors[l] != colors[r]:\\n                res = max(res , r-l )\\n                l += 1\\n                r = limit\\n            else:\\n                r -= 1\\n        return res\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxDistance(self, colors: List[int]) -> int:\\n        res = 0\\n        l = 0 \\n        limit = r = len(colors) - 1\\n        while l != limit:\\n            if res >= r - l:\\n                 l += 1\\n                 r = limit\\n                 continue\\n            elif colors[l] != colors[r]:\\n                res = max(res , r-l )\\n                l += 1\\n                r = limit\\n            else:\\n                r -= 1\\n        return res\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4000744,
                "title": "python-best-o-n-with-simple-logic-explained",
                "content": "# Intuition\\nCase - I : Ends are Different, so value will be length -1\\n\\nCase - II : Ends are same, Check, first distinct element from left side and right side \\n\\nLet\\'s say this : **A(0)..... L....R.....A(n-1)**\\n\\n**ANSWER** -  maximum of |R-0| or |n-1-L|\\n\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def maxDistance(self, colors: List[int]) -> int:\\n        n=len(colors)\\n        # Case -1 : End Different\\n        # Case -2 : End Same - Look for first different\\n\\n        if colors[0]!=colors[n-1]:\\n            return abs(n-1)\\n        else:\\n            val=colors[0]\\n            diff_left=0\\n            diff_right=n-1\\n            for i in range(1,n-1):\\n                if colors[i]!=val:\\n                    if diff_left==0:\\n                        diff_left=i\\n                        diff_right=i\\n                    else:\\n                        diff_right=i\\n        return max(abs(diff_right),(n-1-diff_left))\\n\\n\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxDistance(self, colors: List[int]) -> int:\\n        n=len(colors)\\n        # Case -1 : End Different\\n        # Case -2 : End Same - Look for first different\\n\\n        if colors[0]!=colors[n-1]:\\n            return abs(n-1)\\n        else:\\n            val=colors[0]\\n            diff_left=0\\n            diff_right=n-1\\n            for i in range(1,n-1):\\n                if colors[i]!=val:\\n                    if diff_left==0:\\n                        diff_left=i\\n                        diff_right=i\\n                    else:\\n                        diff_right=i\\n        return max(abs(diff_right),(n-1-diff_left))\\n\\n\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3999747,
                "title": "easiest-two-pointer-java-solution-100-beast",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach : Two Pointer\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDistance(int[] colors) {\\n        int maxDist1 = 0;  // Initialize the maximum distance to 0.\\n        int i = 0;         // Initialize the left pointer to the start of the array.\\n        int j = colors.length - 1;  // Initialize the right pointer to the end of the array.\\n\\n        // Loop from both ends of the array until the pointers meet or cross.\\n        while (i <= j) {\\n            int diff = j - i;  // Calculate the difference between the current positions of pointers.\\n\\n            // Check if the colors at the current positions are different and if the current diff is greater than the maxDist1.\\n            if (colors[i] != colors[j] && maxDist1 < diff) {\\n                maxDist1 = diff;  // Update maxDist1 with the new maximum distance.\\n                break;  // Exit the loop since we\\'ve found a maximum distance.\\n            } else {\\n                j--;  // Move the right pointer one step to the left.\\n            }\\n        }\\n\\n        // Reset pointers and repeat the process, but this time start from the left and move the right pointer.\\n        i = 0;\\n        j = colors.length - 1;\\n\\n        while (i <= j) {\\n            int diff = j - i;\\n\\n            if (colors[i] != colors[j] && maxDist1 < diff) {\\n                maxDist1 = diff;\\n                break;\\n            } else {\\n                i++;  // Move the left pointer one step to the right.\\n            }\\n        }\\n\\n        return maxDist1;  // Return the maximum distance found in both directions.\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDistance(int[] colors) {\\n        int maxDist1 = 0;  // Initialize the maximum distance to 0.\\n        int i = 0;         // Initialize the left pointer to the start of the array.\\n        int j = colors.length - 1;  // Initialize the right pointer to the end of the array.\\n\\n        // Loop from both ends of the array until the pointers meet or cross.\\n        while (i <= j) {\\n            int diff = j - i;  // Calculate the difference between the current positions of pointers.\\n\\n            // Check if the colors at the current positions are different and if the current diff is greater than the maxDist1.\\n            if (colors[i] != colors[j] && maxDist1 < diff) {\\n                maxDist1 = diff;  // Update maxDist1 with the new maximum distance.\\n                break;  // Exit the loop since we\\'ve found a maximum distance.\\n            } else {\\n                j--;  // Move the right pointer one step to the left.\\n            }\\n        }\\n\\n        // Reset pointers and repeat the process, but this time start from the left and move the right pointer.\\n        i = 0;\\n        j = colors.length - 1;\\n\\n        while (i <= j) {\\n            int diff = j - i;\\n\\n            if (colors[i] != colors[j] && maxDist1 < diff) {\\n                maxDist1 = diff;\\n                break;\\n            } else {\\n                i++;  // Move the left pointer one step to the right.\\n            }\\n        }\\n\\n        return maxDist1;  // Return the maximum distance found in both directions.\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3999581,
                "title": "easy-cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:(O(N^2)):\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1):\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        int ans=INT_MIN;\\n        for(int i=0;i<colors.size();i++)\\n        {\\n            for(int j=0;j<colors.size();j++)\\n            {\\n                if(colors[i]!=colors[j])\\n                {\\n                    ans=max(ans,abs(i-j));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        int ans=INT_MIN;\\n        for(int i=0;i<colors.size();i++)\\n        {\\n            for(int j=0;j<colors.size();j++)\\n            {\\n                if(colors[i]!=colors[j])\\n                {\\n                    ans=max(ans,abs(i-j));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3999239,
                "title": "greedy-algorithm-with-2-pointers-beats-100-on-time-0ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach- Two pointers with two loops, return the maxium output comparing both the loops\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDistance(int[] colors) {\\n        int left = 0;\\n        int len = colors.length;\\n        int right = len-1;\\n        while(left<right){\\n            if(colors[left] != colors[right]){\\n                break;\\n            } else {\\n                right--;\\n            }\\n        }\\n        int left2=0;\\n        int right2=len-1;\\n        while(left2<right2){\\n            if(colors[left2] != colors[right2]){\\n                break;\\n            } else {\\n                left2++;\\n            }\\n        }\\n        return Math.max(Math.abs(left - right),Math.abs(left2-right2));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDistance(int[] colors) {\\n        int left = 0;\\n        int len = colors.length;\\n        int right = len-1;\\n        while(left<right){\\n            if(colors[left] != colors[right]){\\n                break;\\n            } else {\\n                right--;\\n            }\\n        }\\n        int left2=0;\\n        int right2=len-1;\\n        while(left2<right2){\\n            if(colors[left2] != colors[right2]){\\n                break;\\n            } else {\\n                left2++;\\n            }\\n        }\\n        return Math.max(Math.abs(left - right),Math.abs(left2-right2));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3987402,
                "title": "best-sollution-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDistance(int[] colors) {\\n        int sum = 0;\\n        int diff = 0;\\n        int x = sum;\\n        for(int i=0;i<colors.length;i++){\\n            for(int j=i+1;j<colors.length;j++){\\n                if(colors[i]!=colors[j]){\\n                    sum = Math.abs(i-j);\\n                }\\n            }\\n            if(sum>diff){\\n             x = sum;\\n             diff = sum;\\n            }\\n        }\\n        return x;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDistance(int[] colors) {\\n        int sum = 0;\\n        int diff = 0;\\n        int x = sum;\\n        for(int i=0;i<colors.length;i++){\\n            for(int j=i+1;j<colors.length;j++){\\n                if(colors[i]!=colors[j]){\\n                    sum = Math.abs(i-j);\\n                }\\n            }\\n            if(sum>diff){\\n             x = sum;\\n             diff = sum;\\n            }\\n        }\\n        return x;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3982373,
                "title": "2-solutions",
                "content": "# Code\\n```\\nclass Solution {\\n\\n    // TC: O(n)\\n    // SC: O(1)\\n    public int maxDistance(int[] colors) {\\n        int n = colors.length;\\n        int l = 0;\\n        int r = n-1;\\n\\n        while(colors[0]==colors[r]){\\n            r--;\\n        }\\n        while(colors[l]==colors[n-1]){\\n            l++;\\n        }\\n        return Math.max(n-1-l,r);\\n    }\\n\\n    // TC: O(n^2)\\n    // SC: O(1)\\n    public int maxDistance2(int[] colors) {\\n        int ans = 0;\\n        for(int i=0;i<colors.length;i++){\\n            int curr = 0;\\n            for(int j=i;j<colors.length;j++){\\n                if(colors[i]!=colors[j] && j-i>curr){\\n                    curr=j-i;\\n                }\\n            }\\n            ans = Math.max(ans,curr);\\n        }\\n        return ans;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n\\n    // TC: O(n)\\n    // SC: O(1)\\n    public int maxDistance(int[] colors) {\\n        int n = colors.length;\\n        int l = 0;\\n        int r = n-1;\\n\\n        while(colors[0]==colors[r]){\\n            r--;\\n        }\\n        while(colors[l]==colors[n-1]){\\n            l++;\\n        }\\n        return Math.max(n-1-l,r);\\n    }\\n\\n    // TC: O(n^2)\\n    // SC: O(1)\\n    public int maxDistance2(int[] colors) {\\n        int ans = 0;\\n        for(int i=0;i<colors.length;i++){\\n            int curr = 0;\\n            for(int j=i;j<colors.length;j++){\\n                if(colors[i]!=colors[j] && j-i>curr){\\n                    curr=j-i;\\n                }\\n            }\\n            ans = Math.max(ans,curr);\\n        }\\n        return ans;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3981990,
                "title": "easy-approach-in-c",
                "content": "# Code\\n```\\nclass Solution\\n{\\n    public:\\n        int maxDistance(vector<int> &colors)\\n        {\\n            int l = colors.size();\\n            int res = 0;\\n\\n            for (int i = 0; i < l; i++)\\n            {\\n                for (int j = i + 1; j < l; j++)\\n                {\\n                    if (colors[i] != colors[j])\\n                    {\\n                        res = max(res, abs(i - j));\\n\\n                    }\\n                }\\n            }\\n            return res;\\n        }\\n        };\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n        int maxDistance(vector<int> &colors)\\n        {\\n            int l = colors.size();\\n            int res = 0;\\n\\n            for (int i = 0; i < l; i++)\\n            {\\n                for (int j = i + 1; j < l; j++)\\n                {\\n                    if (colors[i] != colors[j])\\n                    {\\n                        res = max(res, abs(i - j));\\n\\n                    }\\n                }\\n            }\\n            return res;\\n        }\\n        };\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3981428,
                "title": "easy-javascript-solution-with-line-by-line-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} colors\\n * @return {number}\\n */\\nvar maxDistance = function (colors) {\\n\\n    // initialize distance and k to zero\\n    let distance = 0, k = 0;\\n\\n    // loop through 0 to less than 1\\n    for (let i = 0; i < 1; i++) {\\n\\n        // loop through i+1 to length of colors\\n        for (let j = i + 1; j < colors.length; j++) {\\n\\n            // if colors[i] not equal to colros[j] then distance is equal to subtraction of j and i\\n            if (colors[i] !== colors[j]) {\\n\\n                // if distance is equal to zero then k becomes j\\n                if (distance === 0) {\\n                    k = j;\\n                }\\n\\n                // distance is equal to subtraction of j and i\\n                distance = j - i;\\n            } else {\\n\\n                // else if k is greater than zero\\n                if (k > 0) {\\n\\n                    // max is equal to subtraction of j and k\\n                    let max = j - k;\\n                    \\n                    // if max is greater than distance then assgin max to distnace\\n                    if (max > distance) {\\n                        distance = max;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    // return distance\\n    return distance;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} colors\\n * @return {number}\\n */\\nvar maxDistance = function (colors) {\\n\\n    // initialize distance and k to zero\\n    let distance = 0, k = 0;\\n\\n    // loop through 0 to less than 1\\n    for (let i = 0; i < 1; i++) {\\n\\n        // loop through i+1 to length of colors\\n        for (let j = i + 1; j < colors.length; j++) {\\n\\n            // if colors[i] not equal to colros[j] then distance is equal to subtraction of j and i\\n            if (colors[i] !== colors[j]) {\\n\\n                // if distance is equal to zero then k becomes j\\n                if (distance === 0) {\\n                    k = j;\\n                }\\n\\n                // distance is equal to subtraction of j and i\\n                distance = j - i;\\n            } else {\\n\\n                // else if k is greater than zero\\n                if (k > 0) {\\n\\n                    // max is equal to subtraction of j and k\\n                    let max = j - k;\\n                    \\n                    // if max is greater than distance then assgin max to distnace\\n                    if (max > distance) {\\n                        distance = max;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    // return distance\\n    return distance;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3976119,
                "title": "solution-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxDistance(self, colors: List[int]) -> int:\\n        b=[]\\n        for i in range(0,len(colors)-1) :\\n            a=0\\n            for j in range(i+1,len(colors)) :\\n                if colors[i]==colors[j] :\\n                    a+=1\\n                elif colors[i]!=colors[j] :\\n                    a+=1\\n                    b.append(a)\\n        return max(b)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxDistance(self, colors: List[int]) -> int:\\n        b=[]\\n        for i in range(0,len(colors)-1) :\\n            a=0\\n            for j in range(i+1,len(colors)) :\\n                if colors[i]==colors[j] :\\n                    a+=1\\n                elif colors[i]!=colors[j] :\\n                    a+=1\\n                    b.append(a)\\n        return max(b)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3970946,
                "title": "beats-100-00-of-users-with-ruby",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# @param {Integer[]} colors\\n# @return {Integer}\\ndef max_distance(colors)\\n  p colors\\n  max = 0\\n  (0..colors.length/2 + 1).each do |i|\\n    (i + 1..colors.length - 1).each do |j|\\n      if colors[i] != colors[j] && (j - i) > max\\n        p \"i: #{i}, j: #{j}\"\\n        max = j - i\\n      end\\n    end\\n  end\\n  max\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {Integer[]} colors\\n# @return {Integer}\\ndef max_distance(colors)\\n  p colors\\n  max = 0\\n  (0..colors.length/2 + 1).each do |i|\\n    (i + 1..colors.length - 1).each do |j|\\n      if colors[i] != colors[j] && (j - i) > max\\n        p \"i: #{i}, j: #{j}\"\\n        max = j - i\\n      end\\n    end\\n  end\\n  max\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3958023,
                "title": "nice-and-elegant-solution-in-java-beats-100-rt-and-98-memory",
                "content": "```\\nclass Solution {\\n    public int maxDistance(int[] colors) {\\n        int diff = 0;\\n        int output = 0;\\n        for (int i = 0; i < colors.length - 1; i++) {\\n            int shift = 0;\\n            int index = i + 1;\\n            boolean shouldSkip = true;\\n            for (int j = colors.length - 1; j >= i + 1; j--) {\\n                if (shouldSkip && colors[i] == colors[index++]) {\\n                    shift++;\\n                } else {\\n                    shouldSkip = false;\\n                }\\n                if (colors[i] != colors[j]) {\\n                    diff = Math.abs(i - j);\\n                    break;\\n                }\\n            }\\n            output = Math.max(output, diff);\\n            if (output == colors.length) {\\n                return output;\\n            }\\n            i += shift;\\n        }\\n        return output;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDistance(int[] colors) {\\n        int diff = 0;\\n        int output = 0;\\n        for (int i = 0; i < colors.length - 1; i++) {\\n            int shift = 0;\\n            int index = i + 1;\\n            boolean shouldSkip = true;\\n            for (int j = colors.length - 1; j >= i + 1; j--) {\\n                if (shouldSkip && colors[i] == colors[index++]) {\\n                    shift++;\\n                } else {\\n                    shouldSkip = false;\\n                }\\n                if (colors[i] != colors[j]) {\\n                    diff = Math.abs(i - j);\\n                    break;\\n                }\\n            }\\n            output = Math.max(output, diff);\\n            if (output == colors.length) {\\n                return output;\\n            }\\n            i += shift;\\n        }\\n        return output;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3953917,
                "title": "java-solution-time-complexity-o-n-2-space-complexity-o-1",
                "content": "# Complexity\\n- Time complexity: $$O(n^2)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDistance(int[] colors) {\\n        int result = 0;\\n\\n        for (int i = 0; i < colors.length; i++) {\\n            for (int j = 0; j < colors.length; j++) {\\n                if (colors[i] != colors[j]) {\\n                    int min = Math.abs(j - i);\\n\\n                    if (result < min) {\\n                        result = min;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDistance(int[] colors) {\\n        int result = 0;\\n\\n        for (int i = 0; i < colors.length; i++) {\\n            for (int j = 0; j < colors.length; j++) {\\n                if (colors[i] != colors[j]) {\\n                    int min = Math.abs(j - i);\\n\\n                    if (result < min) {\\n                        result = min;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3951743,
                "title": "easy-to-understand-python3-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxDistance(self, colors: List[int]) -> int:\\n        houses = list(set(colors))\\n        maxval = 0\\n\\n        print(houses)\\n\\n        for h in houses:\\n            l = 0\\n\\n            while l < len(colors):\\n                if colors[l] == h:\\n                    break\\n                l += 1\\n            \\n            r = len(colors) - 1\\n\\n            while r >= 0:\\n                if colors[r] != h:\\n                    break\\n                r -= 1\\n            \\n            maxval = max(maxval, r-l)\\n        \\n        print(maxval)\\n        return maxval\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxDistance(self, colors: List[int]) -> int:\\n        houses = list(set(colors))\\n        maxval = 0\\n\\n        print(houses)\\n\\n        for h in houses:\\n            l = 0\\n\\n            while l < len(colors):\\n                if colors[l] == h:\\n                    break\\n                l += 1\\n            \\n            r = len(colors) - 1\\n\\n            while r >= 0:\\n                if colors[r] != h:\\n                    break\\n                r -= 1\\n            \\n            maxval = max(maxval, r-l)\\n        \\n        print(maxval)\\n        return maxval\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3938040,
                "title": "beats-easy-beginner-friendly-solution-simple-and-easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDistance(int[] c) {\\n        int n=c.length;\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                if(c[i]!=c[j]){\\n                    ans=Math.max(ans,(j-i));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDistance(int[] c) {\\n        int n=c.length;\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                if(c[i]!=c[j]){\\n                    ans=Math.max(ans,(j-i));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3938039,
                "title": "beats-easy-beginner-friendly-solution-simple-and-easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDistance(int[] c) {\\n        int n=c.length;\\n        int f=0;\\n        for(int i=1;i<n;i++){\\n            if(c[0]!=c[i]){\\n                f=i;\\n            }\\n        }\\n        int l=n-1;\\n        for(int i=n-1;i>=0;i--){\\n            if(c[n-1]!=c[i]){\\n                l=i;\\n            }\\n        }\\n        l=n-l-1;\\n        return Math.max(l,f);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDistance(int[] c) {\\n        int n=c.length;\\n        int f=0;\\n        for(int i=1;i<n;i++){\\n            if(c[0]!=c[i]){\\n                f=i;\\n            }\\n        }\\n        int l=n-1;\\n        for(int i=n-1;i>=0;i--){\\n            if(c[n-1]!=c[i]){\\n                l=i;\\n            }\\n        }\\n        l=n-l-1;\\n        return Math.max(l,f);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3925818,
                "title": "enhance-your-dp-python",
                "content": "# Intuition\\nThis problem can be solved using normal loops and pointers but in case you want to practice your dp you can try this method. \\n\\n# Code\\n```\\nclass Solution:\\n    def maxDistance(self, colors: List[int]) -> int:\\n        # either choose the front color\\n        # or choose the back color\\n        @cache\\n        def recur(i, j):\\n            if colors[i] != colors[j]:\\n                return j - i\\n            \\n            if i >= j:\\n                return 0\\n            r1 = 0\\n            r2 = 0\\n            if colors[i] == colors[j]:\\n                r1 = recur(i+1, j)\\n                r2 = recur(i, j-1)\\n            return max(r1, r2)\\n        length = recur(0, len(colors)-1)\\n        return length\\n\\n        \\n        # maxLen = 0\\n        # for i in range(len(colors)-1):\\n        #     for j in range(i+1, len(colors)):\\n        #         if colors[i] != colors[j]:\\n        #             maxLen = max(maxLen, j-i)\\n        # return maxLen\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maxDistance(self, colors: List[int]) -> int:\\n        # either choose the front color\\n        # or choose the back color\\n        @cache\\n        def recur(i, j):\\n            if colors[i] != colors[j]:\\n                return j - i\\n            \\n            if i >= j:\\n                return 0\\n            r1 = 0\\n            r2 = 0\\n            if colors[i] == colors[j]:\\n                r1 = recur(i+1, j)\\n                r2 = recur(i, j-1)\\n            return max(r1, r2)\\n        length = recur(0, len(colors)-1)\\n        return length\\n\\n        \\n        # maxLen = 0\\n        # for i in range(len(colors)-1):\\n        #     for j in range(i+1, len(colors)):\\n        #         if colors[i] != colors[j]:\\n        #             maxLen = max(maxLen, j-i)\\n        # return maxLen\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3924521,
                "title": "typescript-javascript-elegant-solution-in-o-n",
                "content": "\\n\\n# Code\\n```\\nfunction maxDistance(colors: number[]): number {\\n  let color = colors.at(0) \\n  let result = 0\\n\\n  for(let i = 1, j = colors.length - 2; i < colors.length; i++, j--) {\\n    if(colors[i] !== color || colors[j] !== color) {\\n      result = Math.max(result, Math.abs(Math.max(i, j)))\\n    } \\n  }\\n\\n  return result\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction maxDistance(colors: number[]): number {\\n  let color = colors.at(0) \\n  let result = 0\\n\\n  for(let i = 1, j = colors.length - 2; i < colors.length; i++, j--) {\\n    if(colors[i] !== color || colors[j] !== color) {\\n      result = Math.max(result, Math.abs(Math.max(i, j)))\\n    } \\n  }\\n\\n  return result\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3922169,
                "title": "python-single-line-code",
                "content": "# Code\\n```\\nclass Solution:\\n    def maxDistance(self, colors: List[int]) -> int:\\n        return next(len(colors)-1-i for i in range(len(colors)) if (colors[0] != colors [-i-1]) or (colors[i] != colors [-1]))\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxDistance(self, colors: List[int]) -> int:\\n        return next(len(colors)-1-i for i in range(len(colors)) if (colors[0] != colors [-i-1]) or (colors[i] != colors [-1]))\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3904793,
                "title": "easy-java-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDistance(int[] colors) {\\n        int i,j,max=0,length=0;\\n        for(i=0;i<colors.length;i++)\\n        {\\n            for(j=i+1;j<colors.length;j++)\\n            {\\n                if(colors[i]!=colors[j])\\n                    length=Math.abs(i-j);\\n\\n                 if(length>max)\\n                    max=length;   \\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDistance(int[] colors) {\\n        int i,j,max=0,length=0;\\n        for(i=0;i<colors.length;i++)\\n        {\\n            for(j=i+1;j<colors.length;j++)\\n            {\\n                if(colors[i]!=colors[j])\\n                    length=Math.abs(i-j);\\n\\n                 if(length>max)\\n                    max=length;   \\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3902485,
                "title": "easy-solution-in-c",
                "content": "# Intuition\\n\\n\\n# Approach\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        int m=-1111111;\\n        \\n        for(int i=0;i<colors.size();i++){\\n            int a=colors[i];\\n            for(int j=i+1;j<colors.size();j++){\\n                if(a!=colors[j]){\\n                m=max(m,abs(i-j));\\n                 }\\n            }\\n        }\\n        return m;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        int m=-1111111;\\n        \\n        for(int i=0;i<colors.size();i++){\\n            int a=colors[i];\\n            for(int j=i+1;j<colors.size();j++){\\n                if(a!=colors[j]){\\n                m=max(m,abs(i-j));\\n                 }\\n            }\\n        }\\n        return m;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3899560,
                "title": "python-easy-clean-solution",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxDistance(self, colors: List[int]) -> int:\\n        start = 0 \\n        end = len(colors) - 1\\n\\n        while start <= end:\\n            if colors[start] != colors[0]:\\n                return abs(len(colors) - 1 - start)\\n            elif colors[end] != colors[len(colors) - 1]:\\n                return end\\n            elif colors[start] != colors[end]:\\n                return abs(end - start)\\n            start += 1\\n            end -= 1\\n```\\n![catty.png](https://assets.leetcode.com/users/images/ed5994f8-ac2e-4268-9055-e74b48aa6d84_1691848736.10279.png)\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxDistance(self, colors: List[int]) -> int:\\n        start = 0 \\n        end = len(colors) - 1\\n\\n        while start <= end:\\n            if colors[start] != colors[0]:\\n                return abs(len(colors) - 1 - start)\\n            elif colors[end] != colors[len(colors) - 1]:\\n                return end\\n            elif colors[start] != colors[end]:\\n                return abs(end - start)\\n            start += 1\\n            end -= 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3884115,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDistance(int[] colors) {\\n        int start = 0;\\n        int end = colors.length - 1;\\n\\n        while (start < end) {\\n            if (colors[start] != colors[end]) {\\n                break;\\n            }\\n            else {\\n                --end;\\n            }\\n        }\\n\\n        int start1 = 0;\\n        int end1 = colors.length - 1;\\n\\n        while (start1 < end1) {\\n            if (colors[start1] != colors[end1]) {\\n                break;\\n            }\\n            else {\\n                ++start1;\\n            }\\n        }\\n\\n        return Math.max(end - start, end1 - start1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDistance(int[] colors) {\\n        int start = 0;\\n        int end = colors.length - 1;\\n\\n        while (start < end) {\\n            if (colors[start] != colors[end]) {\\n                break;\\n            }\\n            else {\\n                --end;\\n            }\\n        }\\n\\n        int start1 = 0;\\n        int end1 = colors.length - 1;\\n\\n        while (start1 < end1) {\\n            if (colors[start1] != colors[end1]) {\\n                break;\\n            }\\n            else {\\n                ++start1;\\n            }\\n        }\\n\\n        return Math.max(end - start, end1 - start1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3873964,
                "title": "a-rigorous-proof-for-lee215-solution-and-a-painfully-long-explanation-of-how-you-could-have-found-it",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI don\\'t pretend to know how he thought about this magnificent solution but here how i understood it, and I hope it helps you.\\n\\nThe key idea here is two-pointer. And it turns out the first pointer is useless. We will see why.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n## The looooong explanation (You can skip this if you just want the proof)\\n\\n\\nHere is my initial approach(two-pointer):\\n\\nInitialize two pointers, left and right, at the beginning and end of the colors array, respectively.\\nIterate through the colors array using a loop.\\nCheck if the colors at the left and right pointers are different.\\nIf they are different, return the absolute difference between their positions, representing the distance between two different-colored houses.\\nIf the colors at the left and right pointers are the same:\\nCheck if the color at left+1 is different from the color at left.\\nIf they are different, increment the left pointer to move one step to the right.\\nPrint the updated left and right pointers (optional, for understanding).\\nIf the color at left+1 is the same as the color at left, move the right pointer one step to the left.\\nRepeat the process until finding two different-colored houses.\\n\\nThis works for the testcases. But they happend to be symetric. It won\\'t always work if the colors list is asymetric.\\n\\n\\nThis testcase here illustrate it:\\n[4,4,4,11,4,4,11,4,4,4,4,4]\\nAt the end of our program, left=0, right=6 =>[4,4,4,11,4,4,11]\\nBut there is a bigger interval actually: [11,4,4,11,4,4,4,4,4]\\nOur algorithm is perfectly capable of finding it, just reverse the string. And everything will work fine.\\nThe problem lies here:\\n\"Check if the color at left+1 is different from the color at left.\\nIf they are different, increment the left pointer to move one step to the right.\"\\nYou may not have the exact same condition, but most two-pointers approach incorporate this sense of direction because usually you have to move one pointer first. Lee215\\'solution fix this problem by running a two-pointer approach in both direction.\\n\\n## Why is the first-pointer immobile(a proof by contradiction)\\n\\nHis solution suggest that the maxDistance is always achieved with a house on the border of the array.\\nWhy? \\nLet\\'s suppose that it\\'s not the case. Therefore, the two houses with different colors at the maximun distance are at best at distance n-3\\n[start,best-position-first-color,........,best-position-second-color,end].\\n(best config we could hope for)\\nWe have a contradiction here. Because, if \"start\" and best-position-first-color don\\'t have the same color, than we didn\\'t reach the maximun distance since we could have got n-2.\\nBut if they are of the same color, than we can still get n-2 by picking \"start\" and \"best-postion-second-color\". And you can do the same reasoning starting with best-position-second-color.\\n\\nSo we know for sure, that the maximum distance is reach on a border. We just don\\'t know which one. And from this you get his solution by implementing a baby two-pointer.\\nVICTORY!!!\\n\\n\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n2*O(n) ==> O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def maxDistance(self, colors: List[int]) -> int:\\n        #Credit to lee215, i saw this approach in his post.\\n        i, j = 0, len(colors) - 1\\n        while colors[0] == colors[j]: j -= 1\\n        while colors[-1] == colors[i]: i += 1\\n        return max(len(colors) - 1 - i, j)\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxDistance(self, colors: List[int]) -> int:\\n        #Credit to lee215, i saw this approach in his post.\\n        i, j = 0, len(colors) - 1\\n        while colors[0] == colors[j]: j -= 1\\n        while colors[-1] == colors[i]: i += 1\\n        return max(len(colors) - 1 - i, j)\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3868884,
                "title": "o-n-n-approach-beats-100-on-time",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nChecking every pair of the array for inequality.\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        if(colors[0]!=colors[colors.size()-1])\\n            return colors.size()-1;\\n        int c=0;\\n        for(int i=0;i<colors.size();i++)\\n        {\\n            for(int j=i;j<colors.size();j++)\\n            {\\n                if(colors[i]!=colors[j])\\n                {    \\n                    if(colors[i] != colors[j])\\n                        c = max(c,abs(j - i));\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        if(colors[0]!=colors[colors.size()-1])\\n            return colors.size()-1;\\n        int c=0;\\n        for(int i=0;i<colors.size();i++)\\n        {\\n            for(int j=i;j<colors.size();j++)\\n            {\\n                if(colors[i]!=colors[j])\\n                {    \\n                    if(colors[i] != colors[j])\\n                        c = max(c,abs(j - i));\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3867205,
                "title": "easy-and-100-efficiant-solution-in-cpp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        int n=colors.size();\\n        int ans=0;\\n        for(int i=0; i<n-1; i++)\\n        {\\n            for(int j=i+1; j<n; j++)\\n            {\\n                if(colors[i]!=colors[j])\\n                {\\n                    ans=max(ans,abs(i-j));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        int n=colors.size();\\n        int ans=0;\\n        for(int i=0; i<n-1; i++)\\n        {\\n            for(int j=i+1; j<n; j++)\\n            {\\n                if(colors[i]!=colors[j])\\n                {\\n                    ans=max(ans,abs(i-j));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3867120,
                "title": "java-simple-solution",
                "content": "\\n# Complexity\\n- Time complexity: O(n * log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDistance(int[] colors) {\\n        int max = 0, n = colors.length;\\n\\n        if(colors[0] != colors[n-1]) return n-1;\\n\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < i; j++){\\n                if(colors[j] != colors[i]){\\n                   max = Math.max(max, i - j);\\n                   break;\\n                }\\n            }\\n\\n            for(int j = i + 1; j < n; j++){\\n                if(colors[j] != colors[i]){\\n                   max = Math.max(max, j - i);\\n                   break;\\n                }\\n            }\\n        }\\n            \\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDistance(int[] colors) {\\n        int max = 0, n = colors.length;\\n\\n        if(colors[0] != colors[n-1]) return n-1;\\n\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < i; j++){\\n                if(colors[j] != colors[i]){\\n                   max = Math.max(max, i - j);\\n                   break;\\n                }\\n            }\\n\\n            for(int j = i + 1; j < n; j++){\\n                if(colors[j] != colors[i]){\\n                   max = Math.max(max, j - i);\\n                   break;\\n                }\\n            }\\n        }\\n            \\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3847108,
                "title": "beat-100-java-solution-using-double-pointer",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDistance(int[] colors) {\\n        int n=colors.length;\\n        int i=0;\\n        int j=n-1;\\n        int ans=0;\\n        int max=Integer.MIN_VALUE;\\n      while(i<j)\\n      {\\n          if(colors[i]!=colors[j])\\n          {\\n              ans=Math.abs(j-i);\\n              max=Math.max(ans,max);\\n              \\n              j--;\\n          }\\n          else{\\n              \\n              j--;\\n          }\\n\\n              \\n      }\\ni=0;\\nj=n-1;\\n      while(i<j)\\n      {\\n         if(colors[i]!=colors[j])\\n          {\\n              ans=Math.abs(j-i);\\n              max=Math.max(ans,max);\\n              \\n              i++;\\n          }\\n          else{\\n              \\n              i++;\\n          }\\n\\n\\n\\n\\n\\n      }\\n       return max;\\n\\n    }\\n\\n \\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDistance(int[] colors) {\\n        int n=colors.length;\\n        int i=0;\\n        int j=n-1;\\n        int ans=0;\\n        int max=Integer.MIN_VALUE;\\n      while(i<j)\\n      {\\n          if(colors[i]!=colors[j])\\n          {\\n              ans=Math.abs(j-i);\\n              max=Math.max(ans,max);\\n              \\n              j--;\\n          }\\n          else{\\n              \\n              j--;\\n          }\\n\\n              \\n      }\\ni=0;\\nj=n-1;\\n      while(i<j)\\n      {\\n         if(colors[i]!=colors[j])\\n          {\\n              ans=Math.abs(j-i);\\n              max=Math.max(ans,max);\\n              \\n              i++;\\n          }\\n          else{\\n              \\n              i++;\\n          }\\n\\n\\n\\n\\n\\n      }\\n       return max;\\n\\n    }\\n\\n \\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3844739,
                "title": "beats-57-use-for-comparing-with-code-simple-code",
                "content": "\\n\\n# Code\\n```\\nclass Solution(object):\\n    def maxDistance(self, colors):\\n        d=0\\n        c=0\\n        i=0\\n        j=len(colors)-1\\n        while j>0:\\n            \\n            if colors[j]==colors[i]:\\n                j-=1\\n            else:\\n                d=j\\n                break\\n        k=0\\n        l=len(colors)-1\\n        while k<len(colors):\\n            if colors[l]==colors[k]:\\n                k+=1\\n            else:\\n                c=l-k\\n                break\\n\\n                    \\n        \\n                \\n        return max(d,c)\\n                \\n\\n        \\n        \\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def maxDistance(self, colors):\\n        d=0\\n        c=0\\n        i=0\\n        j=len(colors)-1\\n        while j>0:\\n            \\n            if colors[j]==colors[i]:\\n                j-=1\\n            else:\\n                d=j\\n                break\\n        k=0\\n        l=len(colors)-1\\n        while k<len(colors):\\n            if colors[l]==colors[k]:\\n                k+=1\\n            else:\\n                c=l-k\\n                break\\n\\n                    \\n        \\n                \\n        return max(d,c)\\n                \\n\\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3844180,
                "title": "maximum-distance-between-different-colors",
                "content": "# Intuition\\nThe problem asks us to find the maximum distance between two indices in the given vector colors such that the colors at those indices are different. We want to find the maximum distance between such indices.\\n# Approach\\nThe given solution uses a nested loop to compare all pairs of indices i and j in the vector colors (where i < j). For each pair, it checks if the colors at these indices are different. If they are different, it updates the maxi variable to store the maximum distance between such indices found so far.\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        int maxi = INT_MIN;\\n        for(int i =0;i<colors.size();i++)\\n        {\\n            for(int j =i+1;j<colors.size();j++)\\n            {\\n                if(colors[i] != colors[j])\\n                maxi = max(maxi, abs(i-j));\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        int maxi = INT_MIN;\\n        for(int i =0;i<colors.size();i++)\\n        {\\n            for(int j =i+1;j<colors.size();j++)\\n            {\\n                if(colors[i] != colors[j])\\n                maxi = max(maxi, abs(i-j));\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3829296,
                "title": "recursion-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int f(int p1, int p2, vector<int>& colors, vector<vector<int>>& dp){\\n        if(p1>=p2){\\n            return 0;\\n        }\\n        if(dp[p1][p2]!=-1){\\n            return dp[p1][p2];\\n        }\\n        if(colors[p1]!=colors[p2]){\\n            return p2-p1;\\n        }\\n        int a = f(p1, p2-1, colors, dp);\\n        int b = f(p1+1, p2, colors, dp);\\n        return dp[p1][p2] = max(a,b);\\n    }\\n    int maxDistance(vector<int>& colors) {\\n        int p1 = 0;\\n        int p2 = colors.size()-1;\\n        vector<vector<int>> dp(1001, vector<int>(1001,-1));\\n        return f(p1, p2, colors,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int f(int p1, int p2, vector<int>& colors, vector<vector<int>>& dp){\\n        if(p1>=p2){\\n            return 0;\\n        }\\n        if(dp[p1][p2]!=-1){\\n            return dp[p1][p2];\\n        }\\n        if(colors[p1]!=colors[p2]){\\n            return p2-p1;\\n        }\\n        int a = f(p1, p2-1, colors, dp);\\n        int b = f(p1+1, p2, colors, dp);\\n        return dp[p1][p2] = max(a,b);\\n    }\\n    int maxDistance(vector<int>& colors) {\\n        int p1 = 0;\\n        int p2 = colors.size()-1;\\n        vector<vector<int>> dp(1001, vector<int>(1001,-1));\\n        return f(p1, p2, colors,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3796193,
                "title": "two-furthest-houses-with-different-colors",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDistance(int[] colors) {\\n        int max=0;\\n        int i=0;\\n        int j=1;\\n        while(i<colors.length-1)\\n        {\\n            if(colors[i]!=colors[j])\\n            max = Math.max(max,Math.abs(i-j));\\n            j++;\\n            if(j==colors.length)\\n            {\\n                i=i+1;\\n                j=i+1;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDistance(int[] colors) {\\n        int max=0;\\n        int i=0;\\n        int j=1;\\n        while(i<colors.length-1)\\n        {\\n            if(colors[i]!=colors[j])\\n            max = Math.max(max,Math.abs(i-j));\\n            j++;\\n            if(j==colors.length)\\n            {\\n                i=i+1;\\n                j=i+1;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3791429,
                "title": "python-beats-97-3-and-94-59",
                "content": "![\\u672A\\u547D\\u540D.png](https://assets.leetcode.com/users/images/8ae26379-fea0-4e3c-bd99-096089ab9809_1689841394.1180787.png)\\n\\n# Code\\n```\\nclass Solution:\\n    def maxDistance(self, colors: List[int]) -> int:\\n        ln = len(colors) - 1\\n        i = 0\\n        j = ln\\n        d = j - i\\n        while True:\\n            if colors[i] != colors[j]:\\n                return j - i\\n            else:\\n                if j == ln:\\n                    i = 0\\n                    d = d - 1\\n                    j = i + d\\n                else:\\n                    i = i + 1\\n                    j = j + 1\\n        \\n        # 20230720\\n\\n        # \\u9577\\u5EA6\\u8D8A\\u4F86\\u8D8A\\u77ED\\u7684\\u6BDB\\u6BDB\\u87F2\\u5F9E\\u982D\\u958B\\u59CB\\u5F80\\u524D\\u722C\\u884C\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxDistance(self, colors: List[int]) -> int:\\n        ln = len(colors) - 1\\n        i = 0\\n        j = ln\\n        d = j - i\\n        while True:\\n            if colors[i] != colors[j]:\\n                return j - i\\n            else:\\n                if j == ln:\\n                    i = 0\\n                    d = d - 1\\n                    j = i + d\\n                else:\\n                    i = i + 1\\n                    j = j + 1\\n        \\n        # 20230720\\n\\n        # \\u9577\\u5EA6\\u8D8A\\u4F86\\u8D8A\\u77ED\\u7684\\u6BDB\\u6BDB\\u87F2\\u5F9E\\u982D\\u958B\\u59CB\\u5F80\\u524D\\u722C\\u884C\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3769720,
                "title": "c-runtime-beats-100",
                "content": "![image.png](https://assets.leetcode.com/users/images/00b6ada3-de52-4ce1-b5ea-1d9d63d23f0c_1689440456.590977.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        int dist=INT_MIN;\\n        for(int i=0;i<colors.size();i++)\\n        {\\n            for(int j=i+1;j<colors.size();j++)\\n            {\\n                if(colors[i]!=colors[j])\\n                {\\n                    dist=max(dist,abs(i-j));\\n                }\\n            }\\n        }\\n        return dist;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        int dist=INT_MIN;\\n        for(int i=0;i<colors.size();i++)\\n        {\\n            for(int j=i+1;j<colors.size();j++)\\n            {\\n                if(colors[i]!=colors[j])\\n                {\\n                    dist=max(dist,abs(i-j));\\n                }\\n            }\\n        }\\n        return dist;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3763196,
                "title": "c-smartest-approach-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nBegin with pointers i which points at beginning, and j which points at the end.\\nIf houses have the same color then You have to set one of these pointers to the first color that is different, but You have to choose the closest one. If colors are different then You can simply return the distance. Consider:\\n\\n[1, 8, ..., 8, 1, 1]\\n-i-------------j \\n\\n[1, 8, ..., 8, 1, 1] To set j there is worse - Shorter distance\\n-i--------j\\n\\n[1, 8, ..., 8, 1, 1] Better - Longer distance\\n----i----------j \\n\\nIf You think about this, one of the pointers will always be either at beginning or at the end of the array!\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        int n = colors.size(), i = 0, j = n - 1;\\n\\n        if(colors[i] == colors[j]){\\n            int iCopy = i, jCopy = j;\\n\\n            while(iCopy <= jCopy){\\n\\n                if(colors[iCopy] != colors[i]){\\n                    i = iCopy;\\n                    break;\\n                }\\n                if(colors[jCopy] != colors[j]){\\n                    j = jCopy;\\n                    break;\\n                }\\n\\n                if(iCopy == jCopy) return 0;\\n\\n                iCopy++;\\n                jCopy--;\\n            }\\n\\n        }\\n\\n        return j - i;\\n    }                  \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        int n = colors.size(), i = 0, j = n - 1;\\n\\n        if(colors[i] == colors[j]){\\n            int iCopy = i, jCopy = j;\\n\\n            while(iCopy <= jCopy){\\n\\n                if(colors[iCopy] != colors[i]){\\n                    i = iCopy;\\n                    break;\\n                }\\n                if(colors[jCopy] != colors[j]){\\n                    j = jCopy;\\n                    break;\\n                }\\n\\n                if(iCopy == jCopy) return 0;\\n\\n                iCopy++;\\n                jCopy--;\\n            }\\n\\n        }\\n\\n        return j - i;\\n    }                  \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3756025,
                "title": "masum-code-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        int maxx=0;\\n        for(int i=0;i<colors.size();i++)\\n        {\\n            for(int j=i+1;j<colors.size();j++)\\n            {\\n                if(colors[i]!=colors[j])\\n                {\\n                    maxx=max(maxx,(j-i));\\n                }\\n            }\\n        }\\n        return maxx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        int maxx=0;\\n        for(int i=0;i<colors.size();i++)\\n        {\\n            for(int j=i+1;j<colors.size();j++)\\n            {\\n                if(colors[i]!=colors[j])\\n                {\\n                    maxx=max(maxx,(j-i));\\n                }\\n            }\\n        }\\n        return maxx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3753096,
                "title": "python-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxDistance(self, arr: List[int]) -> int:\\n        n=len(arr)\\n        i=0\\n        j=len(arr)-1\\n        while arr[0]==arr[j]:\\n            j-=1\\n        \\n        while arr[n-1]==arr[i]:\\n            i+=1\\n        \\n        return max(n-1-i,j)\\n\\n\\n        \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxDistance(self, arr: List[int]) -> int:\\n        n=len(arr)\\n        i=0\\n        j=len(arr)-1\\n        while arr[0]==arr[j]:\\n            j-=1\\n        \\n        while arr[n-1]==arr[i]:\\n            i+=1\\n        \\n        return max(n-1-i,j)\\n\\n\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3748118,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>c){\\n        int i=0 , j=c.size()-1 , mx1=0 , mx2=0;\\n        while(i<j){\\n            if(c[i]==c[j]){\\n                j--;\\n            }\\n            else{\\n                mx1 = abs(i-j);\\n                break;\\n            }\\n        }\\n        int k=0 , l=c.size()-1;\\n        while(k<l){\\n            if(c[k]==c[l]){\\n                k++;\\n            }\\n            else{\\n                mx2 = abs(k-l);\\n                break;\\n            }\\n        }\\n        return max(mx1,mx2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>c){\\n        int i=0 , j=c.size()-1 , mx1=0 , mx2=0;\\n        while(i<j){\\n            if(c[i]==c[j]){\\n                j--;\\n            }\\n            else{\\n                mx1 = abs(i-j);\\n                break;\\n            }\\n        }\\n        int k=0 , l=c.size()-1;\\n        while(k<l){\\n            if(c[k]==c[l]){\\n                k++;\\n            }\\n            else{\\n                mx2 = abs(k-l);\\n                break;\\n            }\\n        }\\n        return max(mx1,mx2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3736503,
                "title": "simple-java-100-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDistance(int[] colors) {\\n        int i=0;\\n        int j=colors.length-1;\\n        int max1=0;\\n        int max2=0;\\n        while(i<j){\\n            if(colors[i]!=colors[j]){\\n                max1=j-i;\\n                break;\\n            }\\n            j--;\\n        }\\n        i=0;\\n        j=colors.length-1;\\n        while(i<j){\\n            if(colors[i]!=colors[j]){\\n                max2=j-i;\\n                break;\\n            }\\n            i++;\\n        }\\n        if(max1>max2){\\n            return max1;\\n        }\\n        return max2;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDistance(int[] colors) {\\n        int i=0;\\n        int j=colors.length-1;\\n        int max1=0;\\n        int max2=0;\\n        while(i<j){\\n            if(colors[i]!=colors[j]){\\n                max1=j-i;\\n                break;\\n            }\\n            j--;\\n        }\\n        i=0;\\n        j=colors.length-1;\\n        while(i<j){\\n            if(colors[i]!=colors[j]){\\n                max2=j-i;\\n                break;\\n            }\\n            i++;\\n        }\\n        if(max1>max2){\\n            return max1;\\n        }\\n        return max2;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1844748,
                "content": [
                    {
                        "username": "Msey",
                        "content": "take max from (differentHouseIndex - firstHouseIndex) (lastHouseIndex  - differentHouseIndex)"
                    },
                    {
                        "username": "dpwang",
                        "content": "assigin the  hourses index are \\na1 a2 a.. an\\n\\nif the firts or the  last hourse eighter in the first or in the last, \\nassume the index of first house is ai, and the last house is  aj (i < j)\\nso colors[ai] != colors[aj]\\n\\nbecause [a1, aj] is not the best answer, so  colors[a1] = colors[aj]\\nThe same , colors[aj] = colors[an],\\nas a reuslt,  colors[a1] =  colors[ai] = colors[aj] =  colors[an],  the hypothesis does not hold\\n"
                    },
                    {
                        "username": "potatopie",
                        "content": "can probably add a two pointer tag here"
                    },
                    {
                        "username": "Shanmugamayan",
                        "content": "  int color = colors[0];\\n        int ans =0;\\n        for(int i=1;i<colors.size();i++)\\n        {\\n            if(colors[i]!=color)\\n            {\\n                ans= max(ans,i-0);\\n                \\n              \\n            }\\n            else if(colors[i]==color)\\n            {\\n                color = colors[i];\\n                \\n            }\\n        }\\n        return ans;  \\n\\npassed 81 test cases.. what went wrong?? please correct the code and give explanation"
                    },
                    {
                        "username": "laichbr",
                        "content": "The issue is that you need to consider this from both points of view. Let\\'s stake two points, the first and last index of colors. These indices obviously have the largest distance from any other distance within the list for having different colors. With this in mind, \\n\\nSet current index to 0, answer_1 to 0, and color to colors at current index. Loop from 1 to length of colors over index i. answer_1 is max of self and i - current index if colors at i != color else answer_1. \\n\\nSet current index to length of colors - 1. Set answer_2 to 0. Set color to colors at current index. Loop from current_index - 1 to -1 in steps of -1, where answer_2 is max of self and current index - i if colors[i] != color, else answer_2 \\n\\nSet answer to max of answer_1 and answer_2. Return answer. "
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "nice beginner friendly question"
                    },
                    {
                        "username": "Abhishek_WX7",
                        "content": "Two pointer should be tagged in this problem related topics."
                    },
                    {
                        "username": "swseverance",
                        "content": "It\\'s a good problem. They should\\'ve set proper constraints and made it a medium"
                    }
                ]
            },
            {
                "id": 1576012,
                "content": [
                    {
                        "username": "Msey",
                        "content": "take max from (differentHouseIndex - firstHouseIndex) (lastHouseIndex  - differentHouseIndex)"
                    },
                    {
                        "username": "dpwang",
                        "content": "assigin the  hourses index are \\na1 a2 a.. an\\n\\nif the firts or the  last hourse eighter in the first or in the last, \\nassume the index of first house is ai, and the last house is  aj (i < j)\\nso colors[ai] != colors[aj]\\n\\nbecause [a1, aj] is not the best answer, so  colors[a1] = colors[aj]\\nThe same , colors[aj] = colors[an],\\nas a reuslt,  colors[a1] =  colors[ai] = colors[aj] =  colors[an],  the hypothesis does not hold\\n"
                    },
                    {
                        "username": "potatopie",
                        "content": "can probably add a two pointer tag here"
                    },
                    {
                        "username": "Shanmugamayan",
                        "content": "  int color = colors[0];\\n        int ans =0;\\n        for(int i=1;i<colors.size();i++)\\n        {\\n            if(colors[i]!=color)\\n            {\\n                ans= max(ans,i-0);\\n                \\n              \\n            }\\n            else if(colors[i]==color)\\n            {\\n                color = colors[i];\\n                \\n            }\\n        }\\n        return ans;  \\n\\npassed 81 test cases.. what went wrong?? please correct the code and give explanation"
                    },
                    {
                        "username": "laichbr",
                        "content": "The issue is that you need to consider this from both points of view. Let\\'s stake two points, the first and last index of colors. These indices obviously have the largest distance from any other distance within the list for having different colors. With this in mind, \\n\\nSet current index to 0, answer_1 to 0, and color to colors at current index. Loop from 1 to length of colors over index i. answer_1 is max of self and i - current index if colors at i != color else answer_1. \\n\\nSet current index to length of colors - 1. Set answer_2 to 0. Set color to colors at current index. Loop from current_index - 1 to -1 in steps of -1, where answer_2 is max of self and current index - i if colors[i] != color, else answer_2 \\n\\nSet answer to max of answer_1 and answer_2. Return answer. "
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "nice beginner friendly question"
                    },
                    {
                        "username": "Abhishek_WX7",
                        "content": "Two pointer should be tagged in this problem related topics."
                    },
                    {
                        "username": "swseverance",
                        "content": "It\\'s a good problem. They should\\'ve set proper constraints and made it a medium"
                    }
                ]
            },
            {
                "id": 2060267,
                "content": [
                    {
                        "username": "Msey",
                        "content": "take max from (differentHouseIndex - firstHouseIndex) (lastHouseIndex  - differentHouseIndex)"
                    },
                    {
                        "username": "dpwang",
                        "content": "assigin the  hourses index are \\na1 a2 a.. an\\n\\nif the firts or the  last hourse eighter in the first or in the last, \\nassume the index of first house is ai, and the last house is  aj (i < j)\\nso colors[ai] != colors[aj]\\n\\nbecause [a1, aj] is not the best answer, so  colors[a1] = colors[aj]\\nThe same , colors[aj] = colors[an],\\nas a reuslt,  colors[a1] =  colors[ai] = colors[aj] =  colors[an],  the hypothesis does not hold\\n"
                    },
                    {
                        "username": "potatopie",
                        "content": "can probably add a two pointer tag here"
                    },
                    {
                        "username": "Shanmugamayan",
                        "content": "  int color = colors[0];\\n        int ans =0;\\n        for(int i=1;i<colors.size();i++)\\n        {\\n            if(colors[i]!=color)\\n            {\\n                ans= max(ans,i-0);\\n                \\n              \\n            }\\n            else if(colors[i]==color)\\n            {\\n                color = colors[i];\\n                \\n            }\\n        }\\n        return ans;  \\n\\npassed 81 test cases.. what went wrong?? please correct the code and give explanation"
                    },
                    {
                        "username": "laichbr",
                        "content": "The issue is that you need to consider this from both points of view. Let\\'s stake two points, the first and last index of colors. These indices obviously have the largest distance from any other distance within the list for having different colors. With this in mind, \\n\\nSet current index to 0, answer_1 to 0, and color to colors at current index. Loop from 1 to length of colors over index i. answer_1 is max of self and i - current index if colors at i != color else answer_1. \\n\\nSet current index to length of colors - 1. Set answer_2 to 0. Set color to colors at current index. Loop from current_index - 1 to -1 in steps of -1, where answer_2 is max of self and current index - i if colors[i] != color, else answer_2 \\n\\nSet answer to max of answer_1 and answer_2. Return answer. "
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "nice beginner friendly question"
                    },
                    {
                        "username": "Abhishek_WX7",
                        "content": "Two pointer should be tagged in this problem related topics."
                    },
                    {
                        "username": "swseverance",
                        "content": "It\\'s a good problem. They should\\'ve set proper constraints and made it a medium"
                    }
                ]
            },
            {
                "id": 2036031,
                "content": [
                    {
                        "username": "Msey",
                        "content": "take max from (differentHouseIndex - firstHouseIndex) (lastHouseIndex  - differentHouseIndex)"
                    },
                    {
                        "username": "dpwang",
                        "content": "assigin the  hourses index are \\na1 a2 a.. an\\n\\nif the firts or the  last hourse eighter in the first or in the last, \\nassume the index of first house is ai, and the last house is  aj (i < j)\\nso colors[ai] != colors[aj]\\n\\nbecause [a1, aj] is not the best answer, so  colors[a1] = colors[aj]\\nThe same , colors[aj] = colors[an],\\nas a reuslt,  colors[a1] =  colors[ai] = colors[aj] =  colors[an],  the hypothesis does not hold\\n"
                    },
                    {
                        "username": "potatopie",
                        "content": "can probably add a two pointer tag here"
                    },
                    {
                        "username": "Shanmugamayan",
                        "content": "  int color = colors[0];\\n        int ans =0;\\n        for(int i=1;i<colors.size();i++)\\n        {\\n            if(colors[i]!=color)\\n            {\\n                ans= max(ans,i-0);\\n                \\n              \\n            }\\n            else if(colors[i]==color)\\n            {\\n                color = colors[i];\\n                \\n            }\\n        }\\n        return ans;  \\n\\npassed 81 test cases.. what went wrong?? please correct the code and give explanation"
                    },
                    {
                        "username": "laichbr",
                        "content": "The issue is that you need to consider this from both points of view. Let\\'s stake two points, the first and last index of colors. These indices obviously have the largest distance from any other distance within the list for having different colors. With this in mind, \\n\\nSet current index to 0, answer_1 to 0, and color to colors at current index. Loop from 1 to length of colors over index i. answer_1 is max of self and i - current index if colors at i != color else answer_1. \\n\\nSet current index to length of colors - 1. Set answer_2 to 0. Set color to colors at current index. Loop from current_index - 1 to -1 in steps of -1, where answer_2 is max of self and current index - i if colors[i] != color, else answer_2 \\n\\nSet answer to max of answer_1 and answer_2. Return answer. "
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "nice beginner friendly question"
                    },
                    {
                        "username": "Abhishek_WX7",
                        "content": "Two pointer should be tagged in this problem related topics."
                    },
                    {
                        "username": "swseverance",
                        "content": "It\\'s a good problem. They should\\'ve set proper constraints and made it a medium"
                    }
                ]
            },
            {
                "id": 1829496,
                "content": [
                    {
                        "username": "Msey",
                        "content": "take max from (differentHouseIndex - firstHouseIndex) (lastHouseIndex  - differentHouseIndex)"
                    },
                    {
                        "username": "dpwang",
                        "content": "assigin the  hourses index are \\na1 a2 a.. an\\n\\nif the firts or the  last hourse eighter in the first or in the last, \\nassume the index of first house is ai, and the last house is  aj (i < j)\\nso colors[ai] != colors[aj]\\n\\nbecause [a1, aj] is not the best answer, so  colors[a1] = colors[aj]\\nThe same , colors[aj] = colors[an],\\nas a reuslt,  colors[a1] =  colors[ai] = colors[aj] =  colors[an],  the hypothesis does not hold\\n"
                    },
                    {
                        "username": "potatopie",
                        "content": "can probably add a two pointer tag here"
                    },
                    {
                        "username": "Shanmugamayan",
                        "content": "  int color = colors[0];\\n        int ans =0;\\n        for(int i=1;i<colors.size();i++)\\n        {\\n            if(colors[i]!=color)\\n            {\\n                ans= max(ans,i-0);\\n                \\n              \\n            }\\n            else if(colors[i]==color)\\n            {\\n                color = colors[i];\\n                \\n            }\\n        }\\n        return ans;  \\n\\npassed 81 test cases.. what went wrong?? please correct the code and give explanation"
                    },
                    {
                        "username": "laichbr",
                        "content": "The issue is that you need to consider this from both points of view. Let\\'s stake two points, the first and last index of colors. These indices obviously have the largest distance from any other distance within the list for having different colors. With this in mind, \\n\\nSet current index to 0, answer_1 to 0, and color to colors at current index. Loop from 1 to length of colors over index i. answer_1 is max of self and i - current index if colors at i != color else answer_1. \\n\\nSet current index to length of colors - 1. Set answer_2 to 0. Set color to colors at current index. Loop from current_index - 1 to -1 in steps of -1, where answer_2 is max of self and current index - i if colors[i] != color, else answer_2 \\n\\nSet answer to max of answer_1 and answer_2. Return answer. "
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "nice beginner friendly question"
                    },
                    {
                        "username": "Abhishek_WX7",
                        "content": "Two pointer should be tagged in this problem related topics."
                    },
                    {
                        "username": "swseverance",
                        "content": "It\\'s a good problem. They should\\'ve set proper constraints and made it a medium"
                    }
                ]
            },
            {
                "id": 1806031,
                "content": [
                    {
                        "username": "Msey",
                        "content": "take max from (differentHouseIndex - firstHouseIndex) (lastHouseIndex  - differentHouseIndex)"
                    },
                    {
                        "username": "dpwang",
                        "content": "assigin the  hourses index are \\na1 a2 a.. an\\n\\nif the firts or the  last hourse eighter in the first or in the last, \\nassume the index of first house is ai, and the last house is  aj (i < j)\\nso colors[ai] != colors[aj]\\n\\nbecause [a1, aj] is not the best answer, so  colors[a1] = colors[aj]\\nThe same , colors[aj] = colors[an],\\nas a reuslt,  colors[a1] =  colors[ai] = colors[aj] =  colors[an],  the hypothesis does not hold\\n"
                    },
                    {
                        "username": "potatopie",
                        "content": "can probably add a two pointer tag here"
                    },
                    {
                        "username": "Shanmugamayan",
                        "content": "  int color = colors[0];\\n        int ans =0;\\n        for(int i=1;i<colors.size();i++)\\n        {\\n            if(colors[i]!=color)\\n            {\\n                ans= max(ans,i-0);\\n                \\n              \\n            }\\n            else if(colors[i]==color)\\n            {\\n                color = colors[i];\\n                \\n            }\\n        }\\n        return ans;  \\n\\npassed 81 test cases.. what went wrong?? please correct the code and give explanation"
                    },
                    {
                        "username": "laichbr",
                        "content": "The issue is that you need to consider this from both points of view. Let\\'s stake two points, the first and last index of colors. These indices obviously have the largest distance from any other distance within the list for having different colors. With this in mind, \\n\\nSet current index to 0, answer_1 to 0, and color to colors at current index. Loop from 1 to length of colors over index i. answer_1 is max of self and i - current index if colors at i != color else answer_1. \\n\\nSet current index to length of colors - 1. Set answer_2 to 0. Set color to colors at current index. Loop from current_index - 1 to -1 in steps of -1, where answer_2 is max of self and current index - i if colors[i] != color, else answer_2 \\n\\nSet answer to max of answer_1 and answer_2. Return answer. "
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "nice beginner friendly question"
                    },
                    {
                        "username": "Abhishek_WX7",
                        "content": "Two pointer should be tagged in this problem related topics."
                    },
                    {
                        "username": "swseverance",
                        "content": "It\\'s a good problem. They should\\'ve set proper constraints and made it a medium"
                    }
                ]
            },
            {
                "id": 1765447,
                "content": [
                    {
                        "username": "Msey",
                        "content": "take max from (differentHouseIndex - firstHouseIndex) (lastHouseIndex  - differentHouseIndex)"
                    },
                    {
                        "username": "dpwang",
                        "content": "assigin the  hourses index are \\na1 a2 a.. an\\n\\nif the firts or the  last hourse eighter in the first or in the last, \\nassume the index of first house is ai, and the last house is  aj (i < j)\\nso colors[ai] != colors[aj]\\n\\nbecause [a1, aj] is not the best answer, so  colors[a1] = colors[aj]\\nThe same , colors[aj] = colors[an],\\nas a reuslt,  colors[a1] =  colors[ai] = colors[aj] =  colors[an],  the hypothesis does not hold\\n"
                    },
                    {
                        "username": "potatopie",
                        "content": "can probably add a two pointer tag here"
                    },
                    {
                        "username": "Shanmugamayan",
                        "content": "  int color = colors[0];\\n        int ans =0;\\n        for(int i=1;i<colors.size();i++)\\n        {\\n            if(colors[i]!=color)\\n            {\\n                ans= max(ans,i-0);\\n                \\n              \\n            }\\n            else if(colors[i]==color)\\n            {\\n                color = colors[i];\\n                \\n            }\\n        }\\n        return ans;  \\n\\npassed 81 test cases.. what went wrong?? please correct the code and give explanation"
                    },
                    {
                        "username": "laichbr",
                        "content": "The issue is that you need to consider this from both points of view. Let\\'s stake two points, the first and last index of colors. These indices obviously have the largest distance from any other distance within the list for having different colors. With this in mind, \\n\\nSet current index to 0, answer_1 to 0, and color to colors at current index. Loop from 1 to length of colors over index i. answer_1 is max of self and i - current index if colors at i != color else answer_1. \\n\\nSet current index to length of colors - 1. Set answer_2 to 0. Set color to colors at current index. Loop from current_index - 1 to -1 in steps of -1, where answer_2 is max of self and current index - i if colors[i] != color, else answer_2 \\n\\nSet answer to max of answer_1 and answer_2. Return answer. "
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "nice beginner friendly question"
                    },
                    {
                        "username": "Abhishek_WX7",
                        "content": "Two pointer should be tagged in this problem related topics."
                    },
                    {
                        "username": "swseverance",
                        "content": "It\\'s a good problem. They should\\'ve set proper constraints and made it a medium"
                    }
                ]
            }
        ]
    },
    {
        "title": "Watering Plants",
        "question_content": "<p>You want to water <code>n</code> plants in your garden with a watering can. The plants are arranged in a row and are labeled from <code>0</code> to <code>n - 1</code> from left to right where the <code>i<sup>th</sup></code> plant is located at <code>x = i</code>. There is a river at <code>x = -1</code> that you can refill your watering can at.</p>\n\n<p>Each plant needs a specific amount of water. You will water the plants in the following way:</p>\n\n<ul>\n\t<li>Water the plants in order from left to right.</li>\n\t<li>After watering the current plant, if you do not have enough water to <strong>completely</strong> water the next plant, return to the river to fully refill the watering can.</li>\n\t<li>You <strong>cannot</strong> refill the watering can early.</li>\n</ul>\n\n<p>You are initially at the river (i.e., <code>x = -1</code>). It takes <strong>one step</strong> to move <strong>one unit</strong> on the x-axis.</p>\n\n<p>Given a <strong>0-indexed</strong> integer array <code>plants</code> of <code>n</code> integers, where <code>plants[i]</code> is the amount of water the <code>i<sup>th</sup></code> plant needs, and an integer <code>capacity</code> representing the watering can capacity, return <em>the <strong>number of steps</strong> needed to water all the plants</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> plants = [2,2,3,3], capacity = 5\n<strong>Output:</strong> 14\n<strong>Explanation:</strong> Start at the river with a full watering can:\n- Walk to plant 0 (1 step) and water it. Watering can has 3 units of water.\n- Walk to plant 1 (1 step) and water it. Watering can has 1 unit of water.\n- Since you cannot completely water plant 2, walk back to the river to refill (2 steps).\n- Walk to plant 2 (3 steps) and water it. Watering can has 2 units of water.\n- Since you cannot completely water plant 3, walk back to the river to refill (3 steps).\n- Walk to plant 3 (4 steps) and water it.\nSteps needed = 1 + 1 + 2 + 3 + 3 + 4 = 14.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> plants = [1,1,1,4,2,3], capacity = 4\n<strong>Output:</strong> 30\n<strong>Explanation:</strong> Start at the river with a full watering can:\n- Water plants 0, 1, and 2 (3 steps). Return to river (3 steps).\n- Water plant 3 (4 steps). Return to river (4 steps).\n- Water plant 4 (5 steps). Return to river (5 steps).\n- Water plant 5 (6 steps).\nSteps needed = 3 + 3 + 4 + 4 + 5 + 5 + 6 = 30.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> plants = [7,7,7,7,7,7,7], capacity = 8\n<strong>Output:</strong> 49\n<strong>Explanation:</strong> You have to refill before watering each plant.\nSteps needed = 1 + 1 + 2 + 2 + 3 + 3 + 4 + 4 + 5 + 5 + 6 + 6 + 7 = 49.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == plants.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 1000</code></li>\n\t<li><code>1 &lt;= plants[i] &lt;= 10<sup>6</sup></code></li>\n\t<li><code>max(plants[i]) &lt;= capacity &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 1589049,
                "title": "simulation",
                "content": "**Java**\\n```java\\npublic int wateringPlants(int[] p, int capacity) {\\n    int res = 0, can = capacity;\\n    for (int i = 0; i < p.length; ++i) {\\n        if (can < p[i]) {\\n            res += i * 2;\\n            can = capacity;\\n        }\\n        can -= p[i];\\n    }\\n    return res + p.length;        \\n}\\n```\\n**C++**\\n```cpp\\nint wateringPlants(vector<int>& p, int capacity) {\\n    int res = 0, can = capacity;\\n    for (int i = 0; i < p.size(); ++i) {\\n        if (can < p[i]) {\\n            res += i * 2;\\n            can = capacity;\\n        }\\n        can -= p[i];\\n    }\\n    return res + p.size();\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```java\\npublic int wateringPlants(int[] p, int capacity) {\\n    int res = 0, can = capacity;\\n    for (int i = 0; i < p.length; ++i) {\\n        if (can < p[i]) {\\n            res += i * 2;\\n            can = capacity;\\n        }\\n        can -= p[i];\\n    }\\n    return res + p.length;        \\n}\\n```\n```cpp\\nint wateringPlants(vector<int>& p, int capacity) {\\n    int res = 0, can = capacity;\\n    for (int i = 0; i < p.size(); ++i) {\\n        if (can < p[i]) {\\n            res += i * 2;\\n            can = capacity;\\n        }\\n        can -= p[i];\\n    }\\n    return res + p.size();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1589012,
                "title": "c-commented-and-clean-code-time-comp-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int wateringPlants(vector<int>& p, int capacity) {\\n        int ans=0,c=capacity;\\n        for(int i=0;i<p.size();i++){\\n            if(c>=p[i])\\n                ans++;  // if you have enough water then water the plant and it will cost 1 step from previous plant.\\n            else{\\n                ans+=i; // if you don\\'t have enough water then go back from previous plant and fill the container \\n                ans+=i+1; // and come to the current plant.\\n                c=capacity;\\n            }\\n             c=c-p[i]; // water the plant and move to the next one.\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Time Complexity**:- O(n)\\n**Space Complexity**:- O(1)\\n\\nDo **UPVOTE** if it helps :)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int wateringPlants(vector<int>& p, int capacity) {\\n        int ans=0,c=capacity;\\n        for(int i=0;i<p.size();i++){\\n            if(c>=p[i])\\n                ans++;  // if you have enough water then water the plant and it will cost 1 step from previous plant.\\n            else{\\n                ans+=i; // if you don\\'t have enough water then go back from previous plant and fill the container \\n                ans+=i+1; // and come to the current plant.\\n                c=capacity;\\n            }\\n             c=c-p[i]; // water the plant and move to the next one.\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1589030,
                "title": "python3-simulation",
                "content": "Please check out this [commit](https://github.com/gaosanyong/leetcode/commit/b5ca73e6f7d317e9f30f7e67a499b0bf489ec019) for the solutions of weekly 268. \\n```\\nclass Solution:\\n    def wateringPlants(self, plants: List[int], capacity: int) -> int:\\n        ans = 0\\n        can = capacity\\n        for i, x in enumerate(plants): \\n            if can < x: \\n                ans += 2*i\\n                can = capacity\\n            ans += 1\\n            can -= x\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def wateringPlants(self, plants: List[int], capacity: int) -> int:\\n        ans = 0\\n        can = capacity\\n        for i, x in enumerate(plants): \\n            if can < x: \\n                ans += 2*i\\n                can = capacity\\n            ans += 1\\n            can -= x\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1799752,
                "title": "java-solution-with-comments-faster-than-100",
                "content": "class Solution {\\n    public int wateringPlants(int[] plants, int capacity) {\\n\\t\\n     int n=plants.length;\\n        int ans=0;\\n        int temp=capacity;//Water currently in the can\\n    for(int i=0;i<n;i++)\\n    {\\n        if(plants[i]>temp)\\n        {\\n            ans+=(2*i);//Steps required to re-fill the can and come back\\n            temp=capacity;//Re-filling the water can\\n        }\\n        ans+=1;\\n        temp-=plants[i];\\n    }\\n            return ans;\\n\\n      }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int wateringPlants(int[] plants, int capacity) {\\n\\t\\n     int n=plants.length;\\n        int ans=0;\\n        int temp=capacity;//Water currently in the can\\n    for(int i=0;i<n;i++)\\n    {\\n        if(plants[i]>temp)\\n        {\\n            ans+=(2*i);//Steps required to re-fill the can and come back\\n            temp=capacity;//Re-filling the water can\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1589474,
                "title": "c-o-n-solution",
                "content": "\\n```int wateringPlants(vector<int>& plants, int capacity) {\\n        int i,j,temp=capacity,sum=0;\\n        for(i=0;i<plants.size();i++){\\n            if(temp>=plants[i]){\\n                sum=sum+1;\\n                temp=temp-plants[i];\\n            }else{\\n                temp=capacity;\\n                sum=sum+i+(i+1);\\n                temp=temp-plants[i];\\n            }\\n        }\\n        return sum;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "\\n```int wateringPlants(vector<int>& plants, int capacity) {\\n        int i,j,temp=capacity,sum=0;\\n        for(i=0;i<plants.size();i++){\\n            if(temp>=plants[i]){\\n                sum=sum+1;\\n                temp=temp-plants[i];\\n            }else{\\n                temp=capacity;\\n                sum=sum+i+(i+1);\\n                temp=temp-plants[i];\\n            }\\n        }\\n        return sum;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2673930,
                "title": "line-by-line-explained-c-solution-desi-style",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int wateringPlants(vector<int>& plants, int capacity) \\n    {\\n        int steps=0, baalti=capacity;\\n\\n        for(int i=0;i<plants.size();i++)\\n        {\\n            if(baalti>=plants[i])\\n            {\\n                steps++; // simply kadam badhate jaao\\n\\n                baalti=baalti - plants[i]; // plants ko paani dete jaao and balti mai paani ka pta lagao\\n            }\\n\\n            else\\n            {\\n                baalti=capacity;  // baalti bhar denge nadi k pass jaa k\\n\\n\\n                baalti=baalti - plants[i];  // balti mai se fir se plants ko paani dena chaloo kar denge\\n                steps=steps + 2*i+1;  // nadi mai jana and then wapas ana 1 agge wale plant per it takes 2 times ana jana +1\\n            }\\n        }\\n        return steps;\\n    }\\n};\\n```\\nPlease do upvote if it helped... Thank you...\\n\\u2B07",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int wateringPlants(vector<int>& plants, int capacity) \\n    {\\n        int steps=0, baalti=capacity;\\n\\n        for(int i=0;i<plants.size();i++)\\n        {\\n            if(baalti>=plants[i])\\n            {\\n                steps++; // simply kadam badhate jaao\\n\\n                baalti=baalti - plants[i]; // plants ko paani dete jaao and balti mai paani ka pta lagao\\n            }\\n\\n            else\\n            {\\n                baalti=capacity;  // baalti bhar denge nadi k pass jaa k\\n\\n\\n                baalti=baalti - plants[i];  // balti mai se fir se plants ko paani dena chaloo kar denge\\n                steps=steps + 2*i+1;  // nadi mai jana and then wapas ana 1 agge wale plant per it takes 2 times ana jana +1\\n            }\\n        }\\n        return steps;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1589067,
                "title": "simple-solution-w-explanation-easy-one-pass-simulation-o-n-o-1",
                "content": "\\u2714\\uFE0F ***Solution***\\n\\nWe start with watering can at full capacity `C`.\\nEach time, we need to take 1 step to move to the next plant to be watered.\\nIf current plant needs greater water than what\\'s available in can, we should have filled from previous index. \\nSo increase step by `2*((i-1)-(-1)) = 2*i`. `i-1` term denotes previous index, `-1` denotes index of river. We subtract them both to get the distance from previous index to river. Finally, it is multiplied by 2 since we need to go till river and come back\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    int wateringPlants(vector<int>& P, int C) {\\n        int ans = 0, cur = C;\\n        for(int i = 0; i < size(P); i++) {\\n            if(P[i] > cur) {      // water available less than whats needed\\n                cur = C;\\n                ans += 2*i;\\n            }\\n            ans++;                // move to current index\\n            cur -= P[i];          // subtract available water from can\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n***Time Complexity :*** `O(N)`\\n***Space Complexity :*** `O(1)`",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int wateringPlants(vector<int>& P, int C) {\\n        int ans = 0, cur = C;\\n        for(int i = 0; i < size(P); i++) {\\n            if(P[i] > cur) {      // water available less than whats needed\\n                cur = C;\\n                ans += 2*i;\\n            }\\n            ans++;                // move to current index\\n            cur -= P[i];          // subtract available water from can\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3443679,
                "title": "c-easy-solution-time-complexity-o-n-space-complexity-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n  $$O(N)$$ \\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n  $$O(1)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int wateringPlants(vector<int>& plants, int capacity) {\\n        int i = -1, steps = 0, maxCap = capacity;\\n        int n = plants.size();\\n        while((i+1)<n)\\n        {\\n            if(maxCap >= plants[i+1])\\n            {\\n                maxCap -= plants[i+1];\\n                steps++;\\n                i++;\\n            }\\n            else\\n            {\\n                steps += 2*i + 2;\\n                maxCap = capacity;\\n            }\\n        }\\n        return steps;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int wateringPlants(vector<int>& plants, int capacity) {\\n        int i = -1, steps = 0, maxCap = capacity;\\n        int n = plants.size();\\n        while((i+1)<n)\\n        {\\n            if(maxCap >= plants[i+1])\\n            {\\n                maxCap -= plants[i+1];\\n                steps++;\\n                i++;\\n            }\\n            else\\n            {\\n                steps += 2*i + 2;\\n                maxCap = capacity;\\n            }\\n        }\\n        return steps;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832327,
                "title": "c-solutions",
                "content": "```\\nclass Solution {\\npublic:\\n    int wateringPlants(vector<int>& P, int capacity) {\\n        int res=0,curr_water=capacity;\\n        for(int i=0;i<P.size();i++){\\n            if(curr_water>=P[i]){\\n                res++;\\n                curr_water-=P[i];\\n                continue;\\n            }\\n            curr_water=capacity-P[i];\\n            res++;\\n            res+=(i*2);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int wateringPlants(vector<int>& P, int capacity) {\\n        int res=0,curr_water=capacity;\\n        for(int i=0;i<P.size();i++){\\n            if(curr_water>=P[i]){\\n                res++;\\n                curr_water-=P[i];\\n                continue;\\n            }\\n            curr_water=capacity-P[i];\\n            res++;\\n            res+=(i*2);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1611217,
                "title": "easy-c-solution-by-simulation",
                "content": "```\\nclass Solution {\\npublic:\\n    int wateringPlants(vector<int>& p, int c) {\\n        //remaining water -> r\\n        //steps -> s\\n        //axis -> a\\n        //plant requirement -> p\\n        // capacity -> c\\n        int r = c,s = 0,a = -1;\\n        for(int i = 0; i < p.size(); i++)\\n        {\\n            if(r >= p[i])\\n            {\\n                s += i - a;\\n                r -= p[i];\\n                a = i;\\n            }\\n            else\\n            {\\n                r = c - p[i];\\n                s += ((2 * i) + 1);\\n                a = i;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int wateringPlants(vector<int>& p, int c) {\\n        //remaining water -> r\\n        //steps -> s\\n        //axis -> a\\n        //plant requirement -> p\\n        // capacity -> c\\n        int r = c,s = 0,a = -1;\\n        for(int i = 0; i < p.size(); i++)\\n        {\\n            if(r >= p[i])\\n            {\\n                s += i - a;\\n                r -= p[i];\\n                a = i;\\n            }\\n            else\\n            {\\n                r = c - p[i];\\n                s += ((2 * i) + 1);\\n                a = i;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1589110,
                "title": "c-faster-than-100-simple-intuitive-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int wateringPlants(vector<int>& P, int capacity) {\\n        int res=0,curr_water=capacity;\\n        for(int i=0;i<P.size();i++){\\n            if(curr_water>=P[i]){\\n                res++;\\n                curr_water-=P[i];\\n                continue;\\n            }\\n            curr_water=capacity-P[i];\\n            res++;\\n            res+=(i*2);\\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int wateringPlants(vector<int>& P, int capacity) {\\n        int res=0,curr_water=capacity;\\n        for(int i=0;i<P.size();i++){\\n            if(curr_water>=P[i]){\\n                res++;\\n                curr_water-=P[i];\\n                continue;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1718676,
                "title": "java-0ms-faster-than-100-online-java-users",
                "content": "**//please upvote if you like my solution**\\n```\\nclass Solution {\\n    public int wateringPlants(int[] plants, int capacity) {\\n        int count=0,c=capacity;\\n        for(int i=0;i<plants.length;i++){\\n            if(c>=plants[i]){\\n                c-=plants[i];\\n                count++;\\n            }\\n            else {\\n                c=capacity;\\n                count=count+i+(i+1);\\n                c-=plants[i];\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int wateringPlants(int[] plants, int capacity) {\\n        int count=0,c=capacity;\\n        for(int i=0;i<plants.length;i++){\\n            if(c>=plants[i]){\\n                c-=plants[i];\\n                count++;\\n            }\\n            else {\\n                c=capacity;\\n                count=count+i+(i+1);\\n                c-=plants[i];\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1589981,
                "title": "python-easy-solution-beats-100-faster-and-100-memory-usage",
                "content": "Here we first store the value of capacity into x variable after that we work on the plants list and check for each index value , and if the can capacity x is less then the plant required value we add its travelling back and forth value to the count and decrease its current index value from the max capacity at the same time .\\n```\\nclass Solution:\\n    def wateringPlants(self, plants: List[int], capacity: int) -> int:\\n        x=capacity\\n        count=0\\n        for i in range(len(plants)):\\n            if(x<plants[i]):\\n                count=count+i+i+1\\n                x=capacity-plants[i]\\n            \\n            else:\\n                count=count+1\\n                x=x-plants[i]\\n                  \\n        return(count)\\n```\\nIf u understood the code then plz...UPVOTE",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def wateringPlants(self, plants: List[int], capacity: int) -> int:\\n        x=capacity\\n        count=0\\n        for i in range(len(plants)):\\n            if(x<plants[i]):\\n                count=count+i+i+1\\n                x=capacity-plants[i]\\n            \\n            else:\\n                count=count+1\\n                x=x-plants[i]\\n                  \\n        return(count)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3615960,
                "title": "easiest-way-to-understand-100-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int wateringPlants(vector<int>& plants, int capacity) {\\n        int step=0;\\n        int back_step=0;\\n        int initial_capacity=capacity;\\n\\n        for(auto need:plants){\\n            if(capacity<need){\\n                back_step+=step+step;\\n                capacity=initial_capacity;\\n            }\\n            capacity=capacity-need;\\n            step++;\\n\\n        }\\n        return back_step+step;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int wateringPlants(vector<int>& plants, int capacity) {\\n        int step=0;\\n        int back_step=0;\\n        int initial_capacity=capacity;\\n\\n        for(auto need:plants){\\n            if(capacity<need){\\n                back_step+=step+step;\\n                capacity=initial_capacity;\\n            }\\n            capacity=capacity-need;\\n            step++;\\n\\n        }\\n        return back_step+step;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2164473,
                "title": "c-easy-solution-o-n",
                "content": "# C++ Code:\\n```\\nclass Solution {\\npublic:\\n    int wateringPlants(vector<int>& plants, int capacity) {\\n        int n= plants.size();\\n        int steps=0;\\n        int i=0;\\n        int currCapacity=capacity;\\n        \\n        while(i < n){\\n      \\n    //if, current cap is more or equal than cap of ith plant\\n            if(currCapacity >= plants[i]){\\n                \\n                steps += 1;\\n                currCapacity -= plants[i];\\n                \\n                i++; //update the pointer\\n                \\n            }\\n    \\n    //else, we need to GO BACK to \"-1\"th idx from \"i-1\"th idx \\n    // and AGAIN COME BACK to \"i-1\"th idx, which takes \"2*i\" steps in total\\n            else{\\n                \\n                steps += 2*i;\\n                currCapacity = capacity;\\n                \\n            }\\n        }\\n        \\n        return steps;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int wateringPlants(vector<int>& plants, int capacity) {\\n        int n= plants.size();\\n        int steps=0;\\n        int i=0;\\n        int currCapacity=capacity;\\n        \\n        while(i < n){\\n      \\n    //if, current cap is more or equal than cap of ith plant\\n            if(currCapacity >= plants[i]){\\n                \\n                steps += 1;\\n                currCapacity -= plants[i];\\n                \\n                i++; //update the pointer\\n                \\n            }\\n    \\n    //else, we need to GO BACK to \"-1\"th idx from \"i-1\"th idx \\n    // and AGAIN COME BACK to \"i-1\"th idx, which takes \"2*i\" steps in total\\n            else{\\n                \\n                steps += 2*i;\\n                currCapacity = capacity;\\n                \\n            }\\n        }\\n        \\n        return steps;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1589176,
                "title": "java-simple-o-n-0-ms-faster-than-100-00-of-java",
                "content": "```\\nclass Solution {\\n    public int wateringPlants(int[] plants, int capacity) {\\n        int steps = 0;\\n        int can = capacity;\\n        for(int i=0;i<plants.length;i++){\\n            if(plants[i] <= can){\\n                can -= plants[i];\\n            }else {\\n                steps+= i + i;\\n                can = capacity-plants[i];\\n            }\\n            steps++;\\n        }\\n        return steps;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int wateringPlants(int[] plants, int capacity) {\\n        int steps = 0;\\n        int can = capacity;\\n        for(int i=0;i<plants.length;i++){\\n            if(plants[i] <= can){\\n                can -= plants[i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2556951,
                "title": "easy-to-understand-java-code",
                "content": "```\\nclass Solution {\\n    public int wateringPlants(int[] plants, int capacity) {\\n      int  count=0,d=capacity;\\n       for (int i = 0; i < plants.length; ++i) {\\n        if (d < plants[i]) {\\n            count += i * 2;\\n            d = capacity;\\n        }\\n        d -= plants[i];\\n           count++;\\n    }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int wateringPlants(int[] plants, int capacity) {\\n      int  count=0,d=capacity;\\n       for (int i = 0; i < plants.length; ++i) {\\n        if (d < plants[i]) {\\n            count += i * 2;\\n            d = capacity;\\n        }\\n        d -= plants[i];\\n           count++;\\n    }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1895113,
                "title": "faster-then-100-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int wateringPlants(int[] plants, int capacity) {\\n        int step = 0;\\n        int temp = capacity;\\n        for(int i=0;i<plants.length;i++){\\n            if(capacity<plants[i]){\\n                step += 2*(i+1)-1;\\n                capacity = temp-plants[i];\\n            }else{\\n                step +=1;\\n                capacity -= plants[i];\\n            }\\n        }\\n        return step;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int wateringPlants(int[] plants, int capacity) {\\n        int step = 0;\\n        int temp = capacity;\\n        for(int i=0;i<plants.length;i++){\\n            if(capacity<plants[i]){\\n                step += 2*(i+1)-1;\\n                capacity = temp-plants[i];\\n            }else{\\n                step +=1;\\n                capacity -= plants[i];\\n            }\\n        }\\n        return step;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1664728,
                "title": "easy-to-understand-solution",
                "content": "\\'\\'\\'\\nclass Solution {\\npublic:\\n    int wateringPlants(vector<int>& plants, int capacity) \\n    {\\n        int step=0, full=capacity;\\n        for(int i=0; i<plants.size(); i++)\\n        {\\n            if(capacity-plants[i]>=0)\\n            {\\n                capacity-=plants[i];\\n                step++;\\n            }\\n            else{\\n                capacity=full;\\n                step+=2*i;\\n                i--;\\n            }\\n        }\\n        return step;\\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int wateringPlants(vector<int>& plants, int capacity) \\n    {\\n        int step=0, full=capacity;\\n        for(int i=0; i<plants.size(); i++)\\n        {\\n            if(capacity-plants[i]>=0)\\n            {\\n                capacity-=plants[i];\\n                step++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1657546,
                "title": "weeb-does-python-c",
                "content": "Python\\n\\n\\tclass Solution:\\n\\t\\tdef wateringPlants(self, plants: List[int], capacity: int) -> int:\\n\\t\\t\\tresult = 0\\n\\t\\t\\tcurCap = capacity\\n\\n\\t\\t\\tfor i in range(len(plants)):\\n\\t\\t\\t\\tif curCap >= plants[i]:\\n\\t\\t\\t\\t\\tcurCap -= plants[i]\\n\\t\\t\\t\\t\\tresult += 1\\n\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tresult += i * 2 + 1\\n\\t\\t\\t\\t\\tcurCap = capacity - plants[i]\\n\\n\\t\\t\\treturn result\\n\\nC++\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint wateringPlants(vector<int>& plants, int capacity) {\\n\\t\\t\\tint result = 0;\\n\\t\\t\\tint curCap = capacity;\\n\\n\\t\\t\\tfor (int i=0; i < plants.size(); i++){\\n\\t\\t\\t\\tif (curCap >= plants[i]){\\n\\t\\t\\t\\t\\tcurCap -= plants[i];\\n\\t\\t\\t\\t\\tresult++;    \\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tresult += i * 2 + 1;\\n\\t\\t\\t\\t\\tcurCap = capacity - plants[i];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t};\\n\\nChill leetcoders, take a break and watch some anime, you deserve it.\\nCheck out **\\u771F\\u306E\\u4EF2\\u9593\\u3058\\u3083\\u306A\\u3044\\u3068\\u52C7\\u8005\\u306E\\u30D1\\u30FC\\u30C6\\u30A3\\u30FC\\u3092\\u8FFD\\u3044\\u51FA\\u3055\\u308C\\u305F\\u306E\\u3067\\u3001\\u8FBA\\u5883\\u3067\\u30B9\\u30ED\\u30FC\\u30E9\\u30A4\\u30D5\\u3059\\u308B\\u3053\\u3068\\u306B\\u3057\\u307E\\u3057\\u305F\\n(Banished from the Hero\\'s Party, I Decided to Live a Quiet Life in the Countryside)**\\n\\n# Episodes: 13\\n# Genres: Adventure, Fantasy, Romance, Slice of Life\\n\\nSolid anime with good romance. Enjoy it.",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Python3",
                    "C",
                    "Array"
                ],
                "code": "class Solution:\\n\\t\\tdef wateringPlants(self, plants: List[int], capacity: int) -> int:\\n\\t\\t\\tresult = 0\\n\\t\\t\\tcurCap = capacity\\n\\n\\t\\t\\tfor i in range(len(plants)):\\n\\t\\t\\t\\tif curCap >= plants[i]:\\n\\t\\t\\t\\t\\tcurCap -= plants[i]\\n\\t\\t\\t\\t\\tresult += 1\\n\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tresult += i * 2 + 1\\n\\t\\t\\t\\t\\tcurCap = capacity - plants[i]\\n\\n\\t\\t\\treturn result\\n\\nC++\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint wateringPlants(vector<int>& plants, int capacity) {\\n\\t\\t\\tint result = 0;\\n\\t\\t\\tint curCap = capacity;\\n\\n\\t\\t\\tfor (int i=0; i < plants.size(); i++){\\n\\t\\t\\t\\tif (curCap >= plants[i]){\\n\\t\\t\\t\\t\\tcurCap -= plants[i];\\n\\t\\t\\t\\t\\tresult++;    \\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1589589,
                "title": "java-easy-and-unique-check-it",
                "content": "\\tpublic static int wateringPlants(int[] plants, int capacity) {\\n\\t\\tint sum = 0;\\n\\t\\tint ans = 0;\\n\\t\\tfor (int i = 0; i < plants.length; i++) {\\n\\t\\t\\tsum += plants[i];\\n\\t\\t\\tif (sum <= capacity) {\\n\\t\\t\\t\\tans++;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tsum = plants[i];\\n\\t\\t\\t\\tans += 2 * (i);\\n\\t\\t\\t\\tans++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "\\tpublic static int wateringPlants(int[] plants, int capacity) {\\n\\t\\tint sum = 0;\\n\\t\\tint ans = 0;\\n\\t\\tfor (int i = 0; i < plants.length; i++) {\\n\\t\\t\\tsum += plants[i];\\n\\t\\t\\tif (sum <= capacity) {\\n\\t\\t\\t\\tans++;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tsum = plants[i];\\n\\t\\t\\t\\tans += 2 * (i);\\n\\t\\t\\t\\tans++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1589258,
                "title": "c-solution",
                "content": "```\\n    int wateringPlants(vector<int>& plants, int c) \\n    {\\n        int res=0,mainc=c;\\n        for(int i=0;i<plants.size();i++)\\n        {\\n          if(plants[i]>c)\\n          {\\n              c=mainc;\\n              res=res+2*i+1;\\n          }\\n           else\\n           res=res+1;\\n          c-=plants[i];\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int wateringPlants(vector<int>& plants, int c) \\n    {\\n        int res=0,mainc=c;\\n        for(int i=0;i<plants.size();i++)\\n        {\\n          if(plants[i]>c)\\n          {\\n              c=mainc;\\n              res=res+2*i+1;\\n          }\\n           else\\n           res=res+1;\\n          c-=plants[i];\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3686553,
                "title": "easy-c-solution-beginner-friendly-approach",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int wateringPlants(vector<int>& plants, int capacity) {\\n        int step = 0, k = capacity;\\n        for(int i=0; i<plants.size(); i++)\\n        {\\n            if(plants[i]<=k){\\n                step++;\\n                k-=plants[i];\\n            }\\n            else{\\n                step+=(2*i); \\n                k = capacity;\\n                i--; // We decrement i by 1 so that we can again traverse the index where we needed to fill the watering can\\n            }\\n        }\\n        return step;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int wateringPlants(vector<int>& plants, int capacity) {\\n        int step = 0, k = capacity;\\n        for(int i=0; i<plants.size(); i++)\\n        {\\n            if(plants[i]<=k){\\n                step++;\\n                k-=plants[i];\\n            }\\n            else{\\n                step+=(2*i); \\n                k = capacity;\\n                i--; // We decrement i by 1 so that we can again traverse the index where we needed to fill the watering can\\n            }\\n        }\\n        return step;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3449978,
                "title": "simple-c-solution-proper-approach-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIn this problem, we are given an array plants representing the amount of water required by n plants to grow. We are also given an integer capacity representing the maximum amount of water that can be poured in the watering can. Our task is to calculate the minimum number of steps required to water all the plants.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can start by initializing the current capacity of the watering can to capacity and the number of steps to 0. We can then iterate over the array of plants and for each plant, we can check if its water requirement is greater than the current capacity of the watering can. If it is, then we will refill the watering can to its full capacity, pour the water on the current plant, and update the current capacity of the watering can accordingly. \\n\\nSince we have poured all the water in the watering can, we need to count this as a step, which is why we increment the steps variable by 1.\\n\\nAdditionally, we will need to take two steps to return to the faucet to refill the watering can and return to the plant. Therefore, we increment the steps variable by 2*i where i is the index of the current plant. \\n\\nIf the water requirement of the current plant is less than or equal to the current capacity of the watering can, we can simply pour the water on the current plant and update the current capacity of the watering can. We also increment the steps variable by 1 since we have poured water on the current plant.\\n# Complexity\\n- Time complexity: $$O(n)$$ \\n     We are iterating over the array of plants only once, so the time complexity is linear in the number of plants\\n- Space complexity: $$O(1)$$ \\n   We are not using any extra space, so the space complexity is constant\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution\\n{\\npublic:\\n    int wateringPlants(vector<int> &plants, int capacity)\\n    {\\n        int n = plants.size();\\n        int steps = 0;\\n        int currCap = capacity;\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (plants[i] > currCap)\\n            {\\n                currCap = capacity - plants[i];\\n                steps = steps + 1 + 2 * i;\\n            }\\n            else\\n            {\\n                currCap -= plants[i];\\n                steps++;\\n            }\\n        }\\n        return steps;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int wateringPlants(vector<int> &plants, int capacity)\\n    {\\n        int n = plants.size();\\n        int steps = 0;\\n        int currCap = capacity;\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (plants[i] > currCap)\\n            {\\n                currCap = capacity - plants[i];\\n                steps = steps + 1 + 2 * i;\\n            }\\n            else\\n            {\\n                currCap -= plants[i];\\n                steps++;\\n            }\\n        }\\n        return steps;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3441788,
                "title": "easy-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int wateringPlants(vector<int>& nums, int capacity) {\\n       int step=0;\\n        int vol=capacity;\\n        int j=0;\\n    \\n        \\n        for(int i=j;i<nums.size();i++)\\n        {\\n                 \\n            if(nums[i]<=capacity){\\n                step++;\\n                capacity-=nums[i];\\n                j++;\\n            }\\n            \\n            else if(capacity<nums[i]){\\n                step=step+2*i+1;\\n                capacity=vol-nums[i];\\n               j=i;\\n                \\n            }\\n            \\n        }\\n        return step;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int wateringPlants(vector<int>& nums, int capacity) {\\n       int step=0;\\n        int vol=capacity;\\n        int j=0;\\n    \\n        \\n        for(int i=j;i<nums.size();i++)\\n        {\\n                 \\n            if(nums[i]<=capacity){\\n                step++;\\n                capacity-=nums[i];\\n                j++;\\n            }\\n            \\n            else if(capacity<nums[i]){\\n                step=step+2*i+1;\\n                capacity=vol-nums[i];\\n               j=i;\\n                \\n            }\\n            \\n        }\\n        return step;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3301182,
                "title": "beats-100-java-solution",
                "content": "##### EXPLAINED WITH COMMENTS\\n```\\nclass Solution {\\n    public int wateringPlants(int[] plants, int capacity) {\\n        int steps=0;\\n        int temp=capacity;\\n        for(int i=0;i<plants.length;i++){//loop through the plant array\\n                if(capacity-plants[i]>=0){ //check if the subtracted(Watered plant) value is greater than or equal to zero and increment the steps\\n                    steps++;\\n                    capacity-=plants[i];//keep subtracting  the plant ith element from total capacity until the condition satisfies\\n                }\\n                else{\\n                    steps+=i; //go back to the river and fetch the water\\n                    capacity=temp;//restore the capacity\\n                    steps+=i+1;//come back to the original position and water the plant\\n                    capacity-=plants[i];subtract the watered plant from the total capacity\\n                }\\n        }\\n        return steps;//return the steps\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int wateringPlants(int[] plants, int capacity) {\\n        int steps=0;\\n        int temp=capacity;\\n        for(int i=0;i<plants.length;i++){//loop through the plant array\\n                if(capacity-plants[i]>=0){ //check if the subtracted(Watered plant) value is greater than or equal to zero and increment the steps\\n                    steps++;\\n                    capacity-=plants[i];//keep subtracting  the plant ith element from total capacity until the condition satisfies\\n                }\\n                else{\\n                    steps+=i; //go back to the river and fetch the water\\n                    capacity=temp;//restore the capacity\\n                    steps+=i+1;//come back to the original position and water the plant\\n                    capacity-=plants[i];subtract the watered plant from the total capacity\\n                }\\n        }\\n        return steps;//return the steps\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3285439,
                "title": "100-efficient-1-loop-best-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int wateringPlants(vector<int>& plants, int capacity) {\\n        int ans =1, z = capacity;\\n        capacity -= plants[0];\\n        for(int i=1;i<plants.size();i++){\\n            if(capacity>=plants[i]){\\n                ans+=1;\\n                capacity-=plants[i];\\n            }\\n            else{\\n                ans+= 2*i+1;\\n                capacity = z -plants[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int wateringPlants(vector<int>& plants, int capacity) {\\n        int ans =1, z = capacity;\\n        capacity -= plants[0];\\n        for(int i=1;i<plants.size();i++){\\n            if(capacity>=plants[i]){\\n                ans+=1;\\n                capacity-=plants[i];\\n            }\\n            else{\\n                ans+= 2*i+1;\\n                capacity = z -plants[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2953395,
                "title": "java-easy-solution-o-n-time-complexity",
                "content": "```\\nclass Solution {\\n    public int wateringPlants(int[] plants, int capacity) {\\n       int cap = capacity;\\n       int steps = 0;\\n       for(int i = 0; i<plants.length; i++){\\n           if(plants[i]<= cap){\\n               cap = cap - plants[i];\\n               steps++;\\n           }else{\\n              steps += i*2;\\n               cap = capacity;\\n               i = i-1;\\n           }\\n       }\\n        return steps;\\n    }\\n}",
                "solutionTags": [
                    "Array"
                ],
                "code": "class Solution {\\n    public int wateringPlants(int[] plants, int capacity) {\\n       int cap = capacity;\\n       int steps = 0;\\n       for(int i = 0; i<plants.length; i++){\\n           if(plants[i]<= cap){\\n               cap = cap - plants[i];\\n               steps++;\\n           }",
                "codeTag": "Java"
            },
            {
                "id": 2807935,
                "title": "python-straight-forward-simulation",
                "content": "# Code\\n```python []\\nclass Solution:\\n    def wateringPlants(self, plants: list[int], capacity: int) -> int:\\n        steps = 1  # the first step from -1 to 0\\n        cur_capacity = capacity\\n        for i in range(len(plants) - 1):\\n            cur_capacity -= plants[i]  # watering the current plant\\n            if cur_capacity < plants[i + 1]:  # if water isn\\'t enough\\n                steps += (i + 1) * 2 + 1 # steps from i to -1 then from -1 to i + 1\\n                cur_capacity = capacity  # restore the capacity\\n            else:\\n                steps += 1  # just move forward\\n        return steps\\n```\\n# Approach\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array"
                ],
                "code": "```python []\\nclass Solution:\\n    def wateringPlants(self, plants: list[int], capacity: int) -> int:\\n        steps = 1  # the first step from -1 to 0\\n        cur_capacity = capacity\\n        for i in range(len(plants) - 1):\\n            cur_capacity -= plants[i]  # watering the current plant\\n            if cur_capacity < plants[i + 1]:  # if water isn\\'t enough\\n                steps += (i + 1) * 2 + 1 # steps from i to -1 then from -1 to i + 1\\n                cur_capacity = capacity  # restore the capacity\\n            else:\\n                steps += 1  # just move forward\\n        return steps\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2277430,
                "title": "python-3-faster-than-96-9-less-than-84-8",
                "content": "Runtime: **47 ms, faster than 96.80%** of Python3 online submissions for Watering Plants.\\nMemory Usage: **14 MB, less than 84.80%** of Python3 online submissions for Watering Plants.\\n```\\nclass Solution:\\n    def wateringPlants(self, plants: List[int], capacity: int) -> int:\\n        s, p, c = 0, -1, capacity\\n        for i, e in enumerate(plants):\\n            if e <= c: s += i - p; c -= e\\n            else: s += p + i + 2; c = capacity - e\\n            p = i\\n        return s",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Enumeration"
                ],
                "code": "Runtime: **47 ms, faster than 96.80%** of Python3 online submissions for Watering Plants.\\nMemory Usage: **14 MB, less than 84.80%** of Python3 online submissions for Watering Plants.\\n```\\nclass Solution:\\n    def wateringPlants(self, plants: List[int], capacity: int) -> int:\\n        s, p, c = 0, -1, capacity\\n        for i, e in enumerate(plants):\\n            if e <= c: s += i - p; c -= e\\n            else: s += p + i + 2; c = capacity - e\\n            p = i\\n        return s",
                "codeTag": "Java"
            },
            {
                "id": 1891965,
                "title": "c-easy-sol",
                "content": "class Solution {\\npublic:\\n```\\n    int wateringPlants(vector<int>& plants, int capacity) {\\n        int n=plants.size();\\n        int steps=0;\\n        int k=capacity;\\n        for(int i=0;i<plants.size();i++)\\n        {\\n            if(plants[i]<=capacity)\\n            {capacity-=plants[i];\\n             steps++;}\\n            else if(plants[i]>capacity)\\n            {\\n                steps+=i;\\n                steps+=i+1;\\n                capacity=k;\\n                capacity-=plants[i];\\n            }\\n            \\n        }\\n        return steps;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    int wateringPlants(vector<int>& plants, int capacity) {\\n        int n=plants.size();\\n        int steps=0;\\n        int k=capacity;\\n        for(int i=0;i<plants.size();i++)\\n        {\\n            if(plants[i]<=capacity)\\n            {capacity-=plants[i];\\n             steps++;}\\n            else if(plants[i]>capacity)\\n            {\\n                steps+=i;\\n                steps+=i+1;\\n                capacity=k;\\n                capacity-=plants[i];\\n            }\\n            \\n        }\\n        return steps;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1602383,
                "title": "python-very-easy-solution-o-n",
                "content": "class Solution:\\n\\n    def wateringPlants(self, lst: List[int], capacity: int) -> int:     \\n        count = 0\\n        c = capacity\\n        for i in range(len(lst)):\\n            if lst[i] <= capacity:\\n                count += 1\\n                capacity -= lst[i]\\n            else:\\n                count += i\\n                capacity = c\\n                count += (i + 1)\\n                capacity -= lst[i]\\n\\n        return (count)\\n# if you like the solution, Please upvotes!!",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "class Solution:\\n\\n    def wateringPlants(self, lst: List[int], capacity: int) -> int:     \\n        count = 0\\n        c = capacity\\n        for i in range(len(lst)):\\n            if lst[i] <= capacity:\\n                count += 1\\n                capacity -= lst[i]\\n            else:\\n                count += i\\n                capacity = c\\n                count += (i + 1)\\n                capacity -= lst[i]\\n\\n        return (count)\\n# if you like the solution, Please upvotes!!",
                "codeTag": "Java"
            },
            {
                "id": 1593609,
                "title": "java-super-explained-solution-o-n",
                "content": "```\\nclass Solution {\\n    public int wateringPlants(int[] plants, int capacity) {\\n        int steps = 0;\\n        int availableWater = capacity;               // Bucket with full water\\n        for (int i = 0; i < plants.length; i++) {    // Go from first\\n            if (availableWater >= plants[i]) {       // If availableWater is enough to water certain plant\\n                availableWater -= plants[i];         // Ok, watered it, now our availableWater reduced by that amount\\n                steps++;                             // Go to next plant\\n            } else {                                 // else, not enough to water certain plant, need to go river\\n                steps += i;                          // Go back to river, steps count is same like certain loop index\\n                availableWater = capacity;           // Refill bucket with water\\n                steps += i;                          // Go back to certain plant, step count is also same like before, certain loop index\\n                availableWater -= plants[i];         // Water it, now our availableWater reduced by that amount\\n                steps++;                             // Go to next plant\\n            }\\n        }\\n        return steps;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int wateringPlants(int[] plants, int capacity) {\\n        int steps = 0;\\n        int availableWater = capacity;               // Bucket with full water\\n        for (int i = 0; i < plants.length; i++) {    // Go from first\\n            if (availableWater >= plants[i]) {       // If availableWater is enough to water certain plant\\n                availableWater -= plants[i];         // Ok, watered it, now our availableWater reduced by that amount\\n                steps++;                             // Go to next plant\\n            } else {                                 // else, not enough to water certain plant, need to go river\\n                steps += i;                          // Go back to river, steps count is same like certain loop index\\n                availableWater = capacity;           // Refill bucket with water\\n                steps += i;                          // Go back to certain plant, step count is also same like before, certain loop index\\n                availableWater -= plants[i];         // Water it, now our availableWater reduced by that amount\\n                steps++;                             // Go to next plant\\n            }\\n        }\\n        return steps;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1591149,
                "title": "python-100-fast-easy-and-best-solution-python-o-n",
                "content": "```\\n        cap=capacity\\n        steps=[1]\\n        for i in range(len(plants)-1):\\n            if plants[i]<=cap:\\n                cap-=plants[i]\\n            if plants[i+1]>cap:\\n                steps.append(i+1)\\n                steps.append(i+2)\\n                cap=capacity\\n            else:\\n                steps.append(1)\\n        return sum(steps)\\n```",
                "solutionTags": [],
                "code": "```\\n        cap=capacity\\n        steps=[1]\\n        for i in range(len(plants)-1):\\n            if plants[i]<=cap:\\n                cap-=plants[i]\\n            if plants[i+1]>cap:\\n                steps.append(i+1)\\n                steps.append(i+2)\\n                cap=capacity\\n            else:\\n                steps.append(1)\\n        return sum(steps)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1590841,
                "title": "intuition-explained-simple-simulation-easy-c-clean-code",
                "content": "**Intuition :**\\n\\n* Idea here is to simulate the way you will plant water , and \\n\\n* When we do not have sufficient water, just go back to river and refill. \\n* Also, when we refill, updated `steps = 2*(current position)`. \\n* Lets do a dry run on a TC :\\n\\n\\t\\tEx : plants = [2, 2, 3, 3] , capacity = 5 \\n\\t\\t\\n\\t\\tInitially, we are at position i = -1, and water left = 5\\n\\t\\t\\n\\t\\t0. i = 0 : waterLeft = 5 - 2 = 3 , steps = 1\\n\\t\\t1. i = 1 : waterLeft = 3 - 2 = 1, steps = 1 + 1 = 2\\n\\t\\t2. i = 2 : since here we do not have sufficient water left, so we first go and refill , \\n\\t\\t\\t\\t\\t and then we water current plant\\n\\t\\t\\t-> waterLeft = 5(refilled water) - 3 = 2, \\n\\t\\t\\t-> steps = i(go to river) + i(return to current position) + 1(move to next plant)  + steps \\n\\t\\t\\t\\t\\t = 2 + 2 + 1 + 2 = 7\\n\\t\\t\\t\\t\\t \\n\\t\\t3. i = 3 : since here we do not have sufficient water left, so we first go and refill , \\n\\t\\t\\t\\t\\t and then we water current plant\\n\\t\\t\\t-> waterLeft = 5(refilled water) - 3 = 2, \\n\\t\\t\\t-> steps = i(go to river) + i(return to current position) + 1(move to next plant)  + steps \\n\\t\\t\\t\\t\\t = 3 + 3 + 1 + 7 = 14\\n\\t\\t\\t\\t\\t \\n\\t\\tTherefore, total steps travelled to water all plants = 14.\\n\\t\\t\\n# Code:\\n```\\nclass Solution {\\npublic:\\n    int wateringPlants(vector<int>& plants, int capacity) {\\n        \\n        int steps = 0, waterLeft = capacity, i = 0;\\n        \\n        while(i < plants.size()) {\\n\\t\\t\\t// Water current plant and move to next plant\\n            if(plants[i] <= waterLeft) {\\n                waterLeft -= plants[i];\\n                steps++;\\n            }\\n            else {\\n                // Go and Fill water first and \\n\\t\\t\\t\\t// Then return and water current plant\\n\\t\\t\\t\\t// And at last move to next plant\\n                waterLeft = capacity - plants[i];\\n                steps += 2*i + 1;\\n            }\\n            i++;\\n        }\\n        \\n        return steps;\\n    }\\n};\\n```\\n\\n**Complexity:** \\n\\n* Time : `O(N)` , N is size of plants array\\n* Space : `O(1)`\\n\\n***If you find this solution helpful, do give it a like :)***",
                "solutionTags": [
                    "C",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int wateringPlants(vector<int>& plants, int capacity) {\\n        \\n        int steps = 0, waterLeft = capacity, i = 0;\\n        \\n        while(i < plants.size()) {\\n\\t\\t\\t// Water current plant and move to next plant\\n            if(plants[i] <= waterLeft) {\\n                waterLeft -= plants[i];\\n                steps++;\\n            }\\n            else {\\n                // Go and Fill water first and \\n\\t\\t\\t\\t// Then return and water current plant\\n\\t\\t\\t\\t// And at last move to next plant\\n                waterLeft = capacity - plants[i];\\n                steps += 2*i + 1;\\n            }\\n            i++;\\n        }\\n        \\n        return steps;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1590628,
                "title": "c-2079-watering-plants",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int wateringPlants(vector<int>& plants, int capacity) {\\n        int ans = 0, can = capacity; \\n        for (int i = 0; i < plants.size(); ++i, ++ans) {\\n            if (can < plants[i]) ans += 2*i, can = capacity; \\n            can -= plants[i]; \\n        }\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int wateringPlants(vector<int>& plants, int capacity) {\\n        int ans = 0, can = capacity; \\n        for (int i = 0; i < plants.size(); ++i, ++ans) {\\n            if (can < plants[i]) ans += 2*i, can = capacity; \\n            can -= plants[i]; \\n        }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1589414,
                "title": "python-solution-simple-time-o-n-space-o-1",
                "content": "```\\n    def wateringPlants(self, plants: List[int], capacity: int) -> int:\\n        res = 0\\n        initialCapacity = capacity\\n        for i, plant in enumerate(plants):\\n            res += 1\\n            if plants[i] > capacity:\\n                res += 2 * i\\n                capacity = initialCapacity\\n            capacity -= plant\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n    def wateringPlants(self, plants: List[int], capacity: int) -> int:\\n        res = 0\\n        initialCapacity = capacity\\n        for i, plant in enumerate(plants):\\n            res += 1\\n            if plants[i] > capacity:\\n                res += 2 * i\\n                capacity = initialCapacity\\n            capacity -= plant\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1589159,
                "title": "java-time-o-n-space-o-1",
                "content": "keep walking until the capacity can\\'t cover the next plant. Then add distance times two.\\nThe last plant is one way.\\n```\\nclass Solution {\\n    public int wateringPlants(int[] plants, int capacity) {\\n        int res = 0;\\n        int cap = capacity;\\n        for (int i = 0; i < plants.length-1; i++) {\\n            if (cap - plants[i] < plants[i+1]) {\\n                cap = capacity;\\n                res += (i+1)*2;\\n            } else {\\n                cap -= plants[i];\\n            }\\n        }\\n        res += plants.length;\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int wateringPlants(int[] plants, int capacity) {\\n        int res = 0;\\n        int cap = capacity;\\n        for (int i = 0; i < plants.length-1; i++) {\\n            if (cap - plants[i] < plants[i+1]) {\\n                cap = capacity;\\n                res += (i+1)*2;\\n            } else {\\n                cap -= plants[i];\\n            }\\n        }\\n        res += plants.length;\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1589074,
                "title": "c-3-ms-explained-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int wateringPlants(vector<int>& a, int k) {\\n        int n = a.size(), steps = 0, wat = k;\\n        for(int i=0; i<n; ++i) { \\n            if(a[i] <= wat) { // if true, means we can water plant at that index so we increase steps by 1.\\n                wat -= a[i]; // decrease water value in can\\n                steps++;\\n            } else { // this says, we cannot water particular plant anymore for that index.\\n                steps += 2*i; // thus we go back to river and come back again. So, 2*i steps added.\\n                wat = k;\\n                i--; // we need to check for that index again, so we check for it in next iteration.\\n            }\\n        }\\n        return steps;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int wateringPlants(vector<int>& a, int k) {\\n        int n = a.size(), steps = 0, wat = k;\\n        for(int i=0; i<n; ++i) { \\n            if(a[i] <= wat) { // if true, means we can water plant at that index so we increase steps by 1.\\n                wat -= a[i]; // decrease water value in can\\n                steps++;\\n            } else { // this says, we cannot water particular plant anymore for that index.\\n                steps += 2*i; // thus we go back to river and come back again. So, 2*i steps added.\\n                wat = k;\\n                i--; // we need to check for that index again, so we check for it in next iteration.\\n            }\\n        }\\n        return steps;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1589038,
                "title": "python-3-prefix-sum-followed-by-binary-search-w-brief-explanation-and-analysis",
                "content": "**Summary:**\\n\\nUsing both prefix sum and binary search for this problem appear to be a over kill, just for referrence or practice.\\n\\n----\\n\\n1. Construct prefix sum for `plants` to do binary search;\\n2. For each search result, modify the volume of used water, and the lower bound of next search range;\\n3. repeat 2 till used water reach the sum of `plants`.\\n\\n```java\\n    public int wateringPlants(int[] plants, int capacity) {\\n        int n = plants.length, totalSteps = 0;\\n        int[] prefixSum = new int[n + 1];\\n        for (int i = 0; i < n; ++i) {\\n            prefixSum[i + 1] = prefixSum[i] + plants[i];\\n        }\\n        for (int usedWater = 0, steps = 0, toRiverSteps = 0; usedWater < prefixSum[n]; usedWater = prefixSum[steps]) {\\n            totalSteps += toRiverSteps;\\n            int index = Arrays.binarySearch(prefixSum, steps + 1, n + 1, capacity + usedWater);\\n            steps = index = index < 0 ? -index - 2 : index;\\n            totalSteps += steps;\\n            toRiverSteps = steps;\\n        }\\n        return totalSteps;\\n    }\\n```\\n```python\\n    def wateringPlants(self, plants: List[int], capacity: int) -> int:\\n        prefix_sum, n = [0], len(plants) + 1\\n        for p in plants:\\n            prefix_sum.append(p + prefix_sum[-1])\\n        total_steps = used_water = to_river_steps = steps = 0\\n        while used_water < prefix_sum[-1]:\\n            total_steps += to_river_steps\\n            steps = bisect.bisect_right(prefix_sum, capacity + used_water, steps + 1) - 1\\n            total_steps += steps\\n            used_water = prefix_sum[steps if steps < n else -1]\\n            to_river_steps = steps\\n        return total_steps\\n```\\n\\n**Analysis:**\\n1. Construct prefix sum array `prefixSum` cost `O(n)` time;\\n2. Binary Search: Since each time we use binary search, theoretically the time should be better than `O(n)`, but in worst case, we can forward only `1` step for each search. Therefore, \\n\\nTime & space: `O(n)`.",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "Binary Tree",
                    "Prefix Sum"
                ],
                "code": "```java\\n    public int wateringPlants(int[] plants, int capacity) {\\n        int n = plants.length, totalSteps = 0;\\n        int[] prefixSum = new int[n + 1];\\n        for (int i = 0; i < n; ++i) {\\n            prefixSum[i + 1] = prefixSum[i] + plants[i];\\n        }\\n        for (int usedWater = 0, steps = 0, toRiverSteps = 0; usedWater < prefixSum[n]; usedWater = prefixSum[steps]) {\\n            totalSteps += toRiverSteps;\\n            int index = Arrays.binarySearch(prefixSum, steps + 1, n + 1, capacity + usedWater);\\n            steps = index = index < 0 ? -index - 2 : index;\\n            totalSteps += steps;\\n            toRiverSteps = steps;\\n        }\\n        return totalSteps;\\n    }\\n```\n```python\\n    def wateringPlants(self, plants: List[int], capacity: int) -> int:\\n        prefix_sum, n = [0], len(plants) + 1\\n        for p in plants:\\n            prefix_sum.append(p + prefix_sum[-1])\\n        total_steps = used_water = to_river_steps = steps = 0\\n        while used_water < prefix_sum[-1]:\\n            total_steps += to_river_steps\\n            steps = bisect.bisect_right(prefix_sum, capacity + used_water, steps + 1) - 1\\n            total_steps += steps\\n            used_water = prefix_sum[steps if steps < n else -1]\\n            to_river_steps = steps\\n        return total_steps\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4053139,
                "title": "easy-to-understand-c-solution-o-n",
                "content": "\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int wateringPlants(vector<int>& plants, int capacity) {\\n        int ans = 0;\\n        int curr = capacity;\\n\\n        for(int i = 0; i < plants.size();i++){\\n            if(plants[i] <= curr){\\n                ans++;\\n                curr -= plants[i];\\n            }\\n            else{\\n                curr = capacity;\\n                ans += 2*i;\\n                ans++;\\n                curr -= plants[i];\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int wateringPlants(vector<int>& plants, int capacity) {\\n        int ans = 0;\\n        int curr = capacity;\\n\\n        for(int i = 0; i < plants.size();i++){\\n            if(plants[i] <= curr){\\n                ans++;\\n                curr -= plants[i];\\n            }\\n            else{\\n                curr = capacity;\\n                ans += 2*i;\\n                ans++;\\n                curr -= plants[i];\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3958233,
                "title": "easy-and-basic-solution",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int wateringPlants(vector<int>& plants, int capacity) {\\n        int steps=0;\\n        int currCapcity = capacity;\\n        int start =0;\\n        while(start<plants.size()){\\n\\n              if(plants[start]<=currCapcity){\\n                  currCapcity-=plants[start];\\n              }\\n              else{\\n                  currCapcity = capacity;\\n                  currCapcity-=plants[start];\\n                  steps +=(start*2);\\n              }\\n              start++;\\n              steps ++;\\n        }\\n    return steps;\\n    }\\n};\\n\\n\\n//     2.  2.  3.  3\\n// -1  0.  1.  2.  3\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int wateringPlants(vector<int>& plants, int capacity) {\\n        int steps=0;\\n        int currCapcity = capacity;\\n        int start =0;\\n        while(start<plants.size()){\\n\\n              if(plants[start]<=currCapcity){\\n                  currCapcity-=plants[start];\\n              }\\n              else{\\n                  currCapcity = capacity;\\n                  currCapcity-=plants[start];\\n                  steps +=(start*2);\\n              }\\n              start++;\\n              steps ++;\\n        }\\n    return steps;\\n    }\\n};\\n\\n\\n//     2.  2.  3.  3\\n// -1  0.  1.  2.  3\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3957800,
                "title": "easy-hai",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    func wateringPlants(_ plants: [Int], _ capacity: Int) -> Int {\\n        var ans = 0\\n\\n        var waterInBucket = capacity \\n        for i in 0..<plants.count {\\n            if waterInBucket >= plants[i] {\\n                ans += 1\\n            }  else {\\n                ans += 2*(i+1)-1\\n                waterInBucket = capacity\\n            }\\n            waterInBucket -= plants[i]\\n        }\\n        return ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func wateringPlants(_ plants: [Int], _ capacity: Int) -> Int {\\n        var ans = 0\\n\\n        var waterInBucket = capacity \\n        for i in 0..<plants.count {\\n            if waterInBucket >= plants[i] {\\n                ans += 1\\n            }  else {\\n                ans += 2*(i+1)-1\\n                waterInBucket = capacity\\n            }\\n            waterInBucket -= plants[i]\\n        }\\n        return ans\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3838149,
                "title": "java-easy-solution-100-beats-with-explanation",
                "content": "# Approach\\n\\nThe problem requires watering plants in a row, starting from a river (x = -1) and moving towards the right. We have a watering can with a certain capacity, and each plant requires a specific amount of water. We need to find the minimum number of steps required to water all the plants while refilling the watering can at the river whenever needed.\\n\\n**Logic:**\\n1. We start at the river (x = -1) with a full watering can. Initialize variables `water` to keep track of the current water amount in the can and `count` to keep track of the total steps taken.\\n2. We iterate through the plants from left to right (from index 0 to n-1).\\n3. For each plant, we check if the amount of water in the can (`water`) is sufficient to water that plant.\\n4. If there is enough water, we water the plant and reduce the amount of water in the can accordingly.\\n5. If there is not enough water, we refill the watering can at the river and water the current plant again. We keep track of the number of steps taken to refill and water the plant.\\n6. After watering each plant, we increment the `count` to keep track of the total steps taken.\\n7. Finally, we return the `count`, which represents the minimum number of steps needed to water all the plants.\\n\\n**Explanation:**\\nThe given solution uses a simple logic to water the plants efficiently while keeping track of the steps taken. It starts at the river with a full watering can and iterates through the plants from left to right. At each plant, it checks the amount of water in the can and waters the plant accordingly.\\n\\nIf there is not enough water to fully water the current plant, it refills the watering can at the river, and then waters the current plant again. This ensures that the plants are watered completely and that we minimize the number of steps needed.\\n\\nThe solution efficiently handles the refilling and watering process and keeps track of the total steps taken. It returns the total count of steps, which represents the minimum number of steps needed to water all the plants.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int wateringPlants(int[] plants, int capacity) {\\n        int water = capacity;\\n        int count = 0;\\n\\n        for(int i = 0; i < plants.length; i++) {\\n            if(water < plants[i]) {\\n                count += (i + i + 1);\\n                water = capacity - plants[i];\\n            } else {\\n                count++;\\n                water -= plants[i];\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C#",
                    "Array",
                    "Design"
                ],
                "code": "```\\nclass Solution {\\n    public int wateringPlants(int[] plants, int capacity) {\\n        int water = capacity;\\n        int count = 0;\\n\\n        for(int i = 0; i < plants.length; i++) {\\n            if(water < plants[i]) {\\n                count += (i + i + 1);\\n                water = capacity - plants[i];\\n            } else {\\n                count++;\\n                water -= plants[i];\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3668367,
                "title": "basic-c-solution-explained-and-easy-beats-90-runtime-array-basics-beginner-friendly",
                "content": "# Intuition\\nThe provided code is a C++ implementation of a function called `wateringPlants`. This function takes a vector of integers `plants`, representing the water needed for each plant, and an integer `capacity`, indicating the maximum capacity of the watering can. The function calculates and returns the minimum number of steps required to water all the plants.\\n\\n# Approach\\n\\n1. The function initializes an integer variable `step` to 0, representing the current step number, and an integer variable `can` to `capacity`, representing the remaining water in the watering can.\\n\\n2. It enters a loop that iterates over each plant in the `plants` vector.\\n\\n3. Inside the loop, there are three cases to consider:\\n\\n   a. If the watering can is full (`can == capacity`), it means a new watering step is started. The code increments `step` by `i+1` since `i` represents the index of the current plant. It also subtracts the water needed for the current plant (`plants[i]`) from the watering can (`can`).\\n\\n   b. If the watering can has enough water to water the current plant (`can >= plants[i]`), the code increments `step` by 1 since the current plant can be watered in the same step. It also subtracts the water needed for the current plant from the watering can.\\n\\n   c. If the watering can does not have enough water to water the current plant, it means the watering can needs to be refilled. The code increments `step` by `i` since all the plants from index 0 to `i-1` have been watered. It then decreases `i` by 1 to repeat the watering step for the current plant in the next iteration. Additionally, it resets the watering can capacity to `capacity`.\\n\\n4. After the loop completes, the function has gone through all the plants, and the final value of `step` represents the minimum number of steps required to water all the plants.\\n\\n5. The function returns the value of `step`.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of this code is O(n), where n is the number of plants. This is because the code performs a linear iteration over the `plants` vector once. Each iteration involves constant-time operations, such as comparisons and arithmetic calculations.\\n\\n# Please Upvote\\n\\n![star-wars-bb8.gif](https://assets.leetcode.com/users/images/5ef1fb3e-16b3-4823-8512-a5d3d5f983ad_1688038384.0324068.gif)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int wateringPlants(vector<int>& plants, int capacity) {\\n        int step = 0 , can = capacity;\\n        for(int i = 0 ; i<plants.size() ; i++)\\n        {\\n            if(can == capacity)\\n            {\\n                step =  step + (i+1);\\n                can = can - plants[i];\\n            }\\n            else if(can >= plants[i])\\n            {\\n                step =  step + 1;\\n                can = can - plants[i];\\n            }\\n            else \\n            {\\n                step = step + i;\\n                i = i-1;\\n                can = capacity; //Filled up water\\n            }\\n        }\\n        return step;\\n    }\\n}; //Please UPVOTE\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int wateringPlants(vector<int>& plants, int capacity) {\\n        int step = 0 , can = capacity;\\n        for(int i = 0 ; i<plants.size() ; i++)\\n        {\\n            if(can == capacity)\\n            {\\n                step =  step + (i+1);\\n                can = can - plants[i];\\n            }\\n            else if(can >= plants[i])\\n            {\\n                step =  step + 1;\\n                can = can - plants[i];\\n            }\\n            else \\n            {\\n                step = step + i;\\n                i = i-1;\\n                can = capacity; //Filled up water\\n            }\\n        }\\n        return step;\\n    }\\n}; //Please UPVOTE\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3645491,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int wateringPlants(vector<int>& plants, int capacity) {\\n       int steps = 0, c = capacity; \\n       for(int i=0; i<plants.size(); i++){\\n           if(c >= plants[i]) {steps++; c -= plants[i]; }\\n           else { steps += 2*i+1; c = capacity-plants[i]; }\\n       }\\n       return steps; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int wateringPlants(vector<int>& plants, int capacity) {\\n       int steps = 0, c = capacity; \\n       for(int i=0; i<plants.size(); i++){\\n           if(c >= plants[i]) {steps++; c -= plants[i]; }\\n           else { steps += 2*i+1; c = capacity-plants[i]; }\\n       }\\n       return steps; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3629323,
                "title": "c-simple",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int wateringPlants(vector<int>& plants, int capacity) {\\n        int n = plants.size();\\n        int ans = n;\\n        int temp = capacity;\\n        for(int i = 0;i<n;i++){\\n             if(capacity < plants[i]){\\n                 ans += i*2;\\n                 capacity = temp - plants[i];\\n             }\\n             else{\\n                 capacity -= plants[i];\\n             }\\n\\n        }   \\n        return ans; \\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int wateringPlants(vector<int>& plants, int capacity) {\\n        int n = plants.size();\\n        int ans = n;\\n        int temp = capacity;\\n        for(int i = 0;i<n;i++){\\n             if(capacity < plants[i]){\\n                 ans += i*2;\\n                 capacity = temp - plants[i];\\n             }\\n             else{\\n                 capacity -= plants[i];\\n             }\\n\\n        }   \\n        return ans; \\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3531092,
                "title": "best-easy-to-understand-beginner-friendly-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int wateringPlants(vector<int>& plants, int capacity) {\\n        int cap=capacity;\\n        int i,steps=0;\\n        int n=plants.size();\\n        for(i=0;i<n;i++){\\n            if(cap>=plants[i]){\\n                cap=cap-plants[i];\\n                steps++;\\n            }\\n            else{\\n                cap=capacity;\\n                cap=cap-plants[i];\\n                steps=steps+(2*(i)+1);\\n            }\\n        }\\n        return steps;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int wateringPlants(vector<int>& plants, int capacity) {\\n        int cap=capacity;\\n        int i,steps=0;\\n        int n=plants.size();\\n        for(i=0;i<n;i++){\\n            if(cap>=plants[i]){\\n                cap=cap-plants[i];\\n                steps++;\\n            }\\n            else{\\n                cap=capacity;\\n                cap=cap-plants[i];\\n                steps=steps+(2*(i)+1);\\n            }\\n        }\\n        return steps;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3528387,
                "title": "simple-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int wateringPlants(vector<int>& plants, int capacity) {\\n        int n = plants.size();\\n        int steps = 0;\\n        int amtleft = capacity;\\n\\n        for (int i=0; i<n; i++) {\\n            if (plants[i] <= amtleft) {\\n                steps++;\\n                amtleft -= plants[i];\\n            }\\n            else {\\n                steps += (i+1)*2 - 1;\\n                amtleft = capacity - plants[i];\\n            }\\n        }\\n\\n        return steps;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int wateringPlants(vector<int>& plants, int capacity) {\\n        int n = plants.size();\\n        int steps = 0;\\n        int amtleft = capacity;\\n\\n        for (int i=0; i<n; i++) {\\n            if (plants[i] <= amtleft) {\\n                steps++;\\n                amtleft -= plants[i];\\n            }\\n            else {\\n                steps += (i+1)*2 - 1;\\n                amtleft = capacity - plants[i];\\n            }\\n        }\\n\\n        return steps;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3276221,
                "title": "javascript-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} plants\\n * @param {number} capacity\\n * @return {number}\\n */\\nvar wateringPlants = function (plants, capacity) {\\n    plants.unshift(capacity)\\n    let steps =0\\n    let newCapacity =0\\n    for(let j=0;j<plants.length;j++){\\n        if(j===0){\\n            newCapacity =capacity\\n            //steps++\\n            continue\\n        }\\n        if (plants[j] <= newCapacity) {\\n            newCapacity = newCapacity - plants[j]\\n            plants[j]=0\\n            steps++\\n        }else{\\n            steps += (j*2)-1   \\n             newCapacity = capacity - plants[j]\\n             steps[j]=0\\n        }\\n    }\\nreturn steps\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} plants\\n * @param {number} capacity\\n * @return {number}\\n */\\nvar wateringPlants = function (plants, capacity) {\\n    plants.unshift(capacity)\\n    let steps =0\\n    let newCapacity =0\\n    for(let j=0;j<plants.length;j++){\\n        if(j===0){\\n            newCapacity =capacity\\n            //steps++\\n            continue\\n        }\\n        if (plants[j] <= newCapacity) {\\n            newCapacity = newCapacity - plants[j]\\n            plants[j]=0\\n            steps++\\n        }else{\\n            steps += (j*2)-1   \\n             newCapacity = capacity - plants[j]\\n             steps[j]=0\\n        }\\n    }\\nreturn steps\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3250105,
                "title": "simple-python-solution-8-lines-63",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def wateringPlants(self, plants: List[int], capacity: int) -> int:\\n        right, water,steps = 0, capacity, 0, \\n        while right < len(plants):\\n            water = capacity\\n            while right < len(plants) and water >= plants[right]:\\n                steps += 1\\n                water -= plants[right]\\n                right += 1\\n\\n            if right <len(plants):    \\n                steps += (2* (right))\\n        return steps    \\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def wateringPlants(self, plants: List[int], capacity: int) -> int:\\n        right, water,steps = 0, capacity, 0, \\n        while right < len(plants):\\n            water = capacity\\n            while right < len(plants) and water >= plants[right]:\\n                steps += 1\\n                water -= plants[right]\\n                right += 1\\n\\n            if right <len(plants):    \\n                steps += (2* (right))\\n        return steps    \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3246820,
                "title": "simple-simple-solution-just-arrays-a",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int wateringPlants(vector<int>& plants, int capacity) {\\n\\n        int steps = 0;\\n        int cap = capacity;\\n        for(int i=0;i<plants.size();i++){\\n           \\n           if(plants[i]>cap){            \\n               steps = steps + (i-0);\\n               cap = capacity;\\n               steps = steps + (i - 0) + 1;\\n               cap = cap-plants[i];\\n           }else{\\n               cap = cap-plants[i];\\n              steps++;\\n              \\n           }\\n           \\n        }\\n\\n            return steps;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int wateringPlants(vector<int>& plants, int capacity) {\\n\\n        int steps = 0;\\n        int cap = capacity;\\n        for(int i=0;i<plants.size();i++){\\n           \\n           if(plants[i]>cap){            \\n               steps = steps + (i-0);\\n               cap = capacity;\\n               steps = steps + (i - 0) + 1;\\n               cap = cap-plants[i];\\n           }else{\\n               cap = cap-plants[i];\\n              steps++;\\n              \\n           }\\n           \\n        }\\n\\n            return steps;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3189623,
                "title": "binary-search-prefix-sum-c-standard-method",
                "content": "```\\nint wateringPlants(vector<int>& p, int c) {\\n\\n        int n = p.size();\\n        vector<int> pre(n,0);\\n        pre[0] = p[0];\\n        \\n        for(int i=1;i<n;i++) pre[i] = pre[i-1] + p[i];\\n        \\n        int curr = 0,sc = c,ans = 0;\\n        \\n        while(1){\\n            \\n            int ind = lower_bound(pre.begin(),pre.end(),sc)-pre.begin();\\n            \\n            if(ind>=n)  return ans+n;\\n      \\n            else if(pre[ind]==sc){\\n                if(ind==n-1) return ans+n; \\n                curr = ind;\\n            }\\n    \\n            else  curr = ind-1;\\n       \\n            sc = c + pre[curr];\\n            ans+=(2*(curr+1));\\n        } return 0;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree",
                    "Prefix Sum"
                ],
                "code": "```\\nint wateringPlants(vector<int>& p, int c) {\\n\\n        int n = p.size();\\n        vector<int> pre(n,0);\\n        pre[0] = p[0];\\n        \\n        for(int i=1;i<n;i++) pre[i] = pre[i-1] + p[i];\\n        \\n        int curr = 0,sc = c,ans = 0;\\n        \\n        while(1){\\n            \\n            int ind = lower_bound(pre.begin(),pre.end(),sc)-pre.begin();\\n            \\n            if(ind>=n)  return ans+n;\\n      \\n            else if(pre[ind]==sc){\\n                if(ind==n-1) return ans+n; \\n                curr = ind;\\n            }\\n    \\n            else  curr = ind-1;\\n       \\n            sc = c + pre[curr];\\n            ans+=(2*(curr+1));\\n        } return 0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3100815,
                "title": "java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int wateringPlants(int[] plants, int capacity) {\\n        int t=capacity;\\n        int idx=0;\\n        int c=0;\\n       for(int i=0;i<plants.length;)\\n       {\\n           if(t>=plants[i])\\n           {\\n               t-=plants[i];\\n               c++;\\n               i++;\\n           }\\n           else \\n           {\\n               c+=2*i;\\n               t=capacity;\\n           }\\n           System.out.println(c);\\n       }\\n       return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int wateringPlants(int[] plants, int capacity) {\\n        int t=capacity;\\n        int idx=0;\\n        int c=0;\\n       for(int i=0;i<plants.length;)\\n       {\\n           if(t>=plants[i])\\n           {\\n               t-=plants[i];\\n               c++;\\n               i++;\\n           }\\n           else \\n           {\\n               c+=2*i;\\n               t=capacity;\\n           }\\n           System.out.println(c);\\n       }\\n       return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2870827,
                "title": "just-do-same-as-the-question-is-saying",
                "content": "```\\nclass Solution {\\npublic:\\n    int wateringPlants(vector<int>& p, int c) {\\n        int steps = 0;\\n        int n = p.size();\\n        int temp = c;\\n        for(int i=0;i<n;i++)\\n        {\\n            steps++;\\n            if(p[i]>temp)\\n            {\\n                steps+=(i+i);\\n                temp = c;\\n            }\\n            \\n            temp-=p[i];\\n            \\n        }\\n        \\n        return steps;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int wateringPlants(vector<int>& p, int c) {\\n        int steps = 0;\\n        int n = p.size();\\n        int temp = c;\\n        for(int i=0;i<n;i++)\\n        {\\n            steps++;\\n            if(p[i]>temp)\\n            {\\n                steps+=(i+i);\\n                temp = c;\\n            }\\n            \\n            temp-=p[i];\\n            \\n        }\\n        \\n        return steps;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2682606,
                "title": "easy-intuitive-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nWe try to water each plant with the can. If the can\\'s capacity becomes less than the plant capacity, we add steps of going to the starting point and then returning back to our current position and also add 1 to take the current step. \\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int wateringPlants(vector<int>& plants, int capacity) {\\n        int cap = capacity;\\n        int ans = 0;\\n        for(int i = 0; i < plants.size(); i++) {\\n            if(cap >= plants[i]) {\\n                cap -= plants[i];\\n                ans++;\\n            }\\n            else {\\n                int d = (2 * i) + 1;\\n                ans += d;\\n                cap = capacity - plants[i];\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int wateringPlants(vector<int>& plants, int capacity) {\\n        int cap = capacity;\\n        int ans = 0;\\n        for(int i = 0; i < plants.size(); i++) {\\n            if(cap >= plants[i]) {\\n                cap -= plants[i];\\n                ans++;\\n            }\\n            else {\\n                int d = (2 * i) + 1;\\n                ans += d;\\n                cap = capacity - plants[i];\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2673396,
                "title": "python-3-lines",
                "content": "```\\nclass Solution:\\n    def wateringPlants(self, plants: List[int], capacity: int) -> int:\\n        s, w, c = 1, capacity, capacity\\n        for i, j in enumerate(plants): s, w = (s+2*i, c-j) if w-j < 0 else (s, w-j)\\n        return s + i\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def wateringPlants(self, plants: List[int], capacity: int) -> int:\\n        s, w, c = 1, capacity, capacity\\n        for i, j in enumerate(plants): s, w = (s+2*i, c-j) if w-j < 0 else (s, w-j)\\n        return s + i\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2592888,
                "title": "faster-than-94-23-of-c-beginners-c-loops",
                "content": "```\\nclass Solution {\\npublic:\\n    int wateringPlants(vector<int>& plants, int capacity) {\\n        \\n        int steps_back =0;\\n        int steps_for = 0;\\n        int cap = capacity;\\n        \\n        for(int i=0;i<size(plants);i++)\\n        {\\n            if(cap<plants[i]){\\n                // move back then come for and water \\n                steps_back+=i;\\n                cap = capacity;\\n                steps_for+=i+1;\\n                cap-=plants[i];\\n                }\\n            \\n             else  { // move 1 step and water \\n                steps_for++;\\n                cap-=plants[i];\\n           }\\n        }\\n        \\n        return steps_for+steps_back;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int wateringPlants(vector<int>& plants, int capacity) {\\n        \\n        int steps_back =0;\\n        int steps_for = 0;\\n        int cap = capacity;\\n        \\n        for(int i=0;i<size(plants);i++)\\n        {\\n            if(cap<plants[i]){\\n                // move back then come for and water \\n                steps_back+=i;\\n                cap = capacity;\\n                steps_for+=i+1;\\n                cap-=plants[i];\\n                }\\n            \\n             else  { // move 1 step and water \\n                steps_for++;\\n                cap-=plants[i];\\n           }\\n        }\\n        \\n        return steps_for+steps_back;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2582073,
                "title": "c-solution-easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    int wateringPlants(vector<int>& plants, int capacity) {\\n        int count = 0;\\n        int temp = capacity;\\n        int n = plants.size();\\n        for(int i = 0; i<n; i++)\\n        {   \\n            \\n            if(capacity < plants[i])\\n            {\\n                capacity = temp;\\n                count += 2 * i;  \\n            }\\n            capacity -= plants[i];\\n            count++;\\n\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int wateringPlants(vector<int>& plants, int capacity) {\\n        int count = 0;\\n        int temp = capacity;\\n        int n = plants.size();\\n        for(int i = 0; i<n; i++)\\n        {   \\n            \\n            if(capacity < plants[i])\\n            {\\n                capacity = temp;\\n                count += 2 * i;  \\n            }\\n            capacity -= plants[i];\\n            count++;\\n\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2497076,
                "title": "java-solution-100-explained",
                "content": "As we iterate through the plants array the can ask ourselves two questions before attempting to water the next plant:\\n\\n**Can we move onto the next plant?\\nDo we need to refil?**\\n\\nThis is reduced to \"**can we completely water plant n?**\"\\n\\nMoving to the next plant is straight forward, update our capacity and increment the steps taken. One way to refill our capacity is to move the same number of steps back and forward as our current index. \\n```\\nc = 4\\n------>X\\n[1, 2, 3, 4, 5, 6]\\n<-------\\n```\\nDecrementing our iterator ensures we check the capacity agaisnt the plant once more.\\n\\n```\\nclass Solution {\\n    public int wateringPlants(int[] plants, int capacity) {\\n        int steps = 0;\\n        int originalCap = capacity;\\n        \\n        for (int i = 0; i < plants.length; i++) {\\n            if (capacity >= plants[i]) {\\n                steps++;\\n                capacity -= plants[i];\\n            } else {\\n                steps += i + i;\\n                capacity = originalCap;\\n                i--;\\n            }\\n        }\\n        return steps;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nc = 4\\n------>X\\n[1, 2, 3, 4, 5, 6]\\n<-------\\n```\n```\\nclass Solution {\\n    public int wateringPlants(int[] plants, int capacity) {\\n        int steps = 0;\\n        int originalCap = capacity;\\n        \\n        for (int i = 0; i < plants.length; i++) {\\n            if (capacity >= plants[i]) {\\n                steps++;\\n                capacity -= plants[i];\\n            } else {\\n                steps += i + i;\\n                capacity = originalCap;\\n                i--;\\n            }\\n        }\\n        return steps;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2484019,
                "title": "super-easy-0ms-100",
                "content": "```\\n public int wateringPlants(int[] plants, int capicity) {\\n        int c=capicity;\\n        int ans=0;\\n        int step=0;\\n        for(int i=0;i<plants.length;i++){\\n            if(capicity>=plants[i]){\\n                ans++;\\n                capicity-=plants[i];\\n                \\n            }\\n            else{\\n                int s=i;\\n                capicity=c;\\n                \\n                ans+=s+s+1;\\n                \\n                capicity-=plants[i];\\n                \\n                \\n            }\\n\\n        }\\n        return ans;\\n        \\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n public int wateringPlants(int[] plants, int capicity) {\\n        int c=capicity;\\n        int ans=0;\\n        int step=0;\\n        for(int i=0;i<plants.length;i++){\\n            if(capicity>=plants[i]){\\n                ans++;\\n                capicity-=plants[i];\\n                \\n            }\\n            else{\\n                int s=i;\\n                capicity=c;\\n                \\n                ans+=s+s+1;\\n                \\n                capicity-=plants[i];\\n                \\n                \\n            }\\n\\n        }\\n        return ans;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2482352,
                "title": "easy-java-solution-100ms-faster",
                "content": "```\\nclass Solution {\\n    public int wateringPlants(int[] plants, int capacity) {\\n        int water= capacity;\\n        int steps= 0;\\n        int index= 0;\\n        int n= plants.length;\\n        \\n        while(index < n){\\n\\t\\t\\n            while( index < n && water>= plants[index] ){\\n                water-= plants[index];\\n                steps++;\\n                index++;\\n            }\\n            \\n            if(index == n){\\n                break;\\n            }\\n            \\n            water= capacity;\\n            steps+= 2*index +1;\\n            water-= plants[index];\\n            index++;\\n        }\\n        return steps;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int wateringPlants(int[] plants, int capacity) {\\n        int water= capacity;\\n        int steps= 0;\\n        int index= 0;\\n        int n= plants.length;\\n        \\n        while(index < n){\\n\\t\\t\\n            while( index < n && water>= plants[index] ){\\n                water-= plants[index];\\n                steps++;\\n                index++;\\n            }\\n            \\n            if(index == n){\\n                break;\\n            }\\n            \\n            water= capacity;\\n            steps+= 2*index +1;\\n            water-= plants[index];\\n            index++;\\n        }\\n        return steps;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2474176,
                "title": "easy-python-solution",
                "content": "```\\nclass Solution:\\n    def wateringPlants(self, plants: List[int], capacity: int) -> int:\\n        steps = 0\\n        po = capacity\\n        for i in range(len(plants)):\\n            if plants[i]<=capacity:\\n                capacity-=plants[i]\\n                steps+=1\\n            else:\\n                steps+=i\\n                capacity = po \\n                capacity-=plants[i]\\n                steps+=(i+1)\\n        return steps\\n                \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def wateringPlants(self, plants: List[int], capacity: int) -> int:\\n        steps = 0\\n        po = capacity\\n        for i in range(len(plants)):\\n            if plants[i]<=capacity:\\n                capacity-=plants[i]\\n                steps+=1\\n            else:\\n                steps+=i\\n                capacity = po \\n                capacity-=plants[i]\\n                steps+=(i+1)\\n        return steps\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2443626,
                "title": "simple-c-brute-force",
                "content": "\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    int wateringPlants(vector<int>& plants, int capacity) {\\n      int n=plants.size();\\n        int y= capacity;\\n        int steps=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(capacity>=plants[i])\\n            {\\n                capacity=capacity-plants[i];\\n                steps=steps+1;\\n            }\\n            else\\n            {\\n                capacity=y;\\n                steps=steps+2*(i);\\n                 capacity=capacity-plants[i];\\n                steps=steps+1;\\n                \\n            }\\n        }\\n        return steps;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Array",
                    "Math"
                ],
                "code": "class Solution {\\npublic:\\n    int wateringPlants(vector<int>& plants, int capacity) {\\n      int n=plants.size();\\n        int y= capacity;\\n        int steps=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(capacity>=plants[i])\\n            {\\n                capacity=capacity-plants[i];\\n                steps=steps+1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2440549,
                "title": "simple-java-solution",
                "content": "class Solution {\\n    public int wateringPlants(int[] plants, int capacity) {\\n        \\n        int steps=0, i=0, water=capacity;\\n        \\n        while(i<plants.length){\\n            \\n            if(plants[i]<=water){\\n                water -= plants[i];\\n                i++;\\n                steps++;\\n            } else{\\n                steps += i+i;\\n                water=capacity;\\n            }\\n        }\\n        \\n        return steps;\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int wateringPlants(int[] plants, int capacity) {\\n        \\n        int steps=0, i=0, water=capacity;\\n        \\n        while(i<plants.length){\\n            \\n            if(plants[i]<=water){\\n                water -= plants[i];\\n                i++;\\n                steps++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2419508,
                "title": "c-logic-explained-straightforward",
                "content": "![image](https://assets.leetcode.com/users/images/5b9b4578-1988-45d7-848f-fc4afa796623_1660392373.7372632.png)\\n\\n**n==plants.size() \\nT->O(n) && S->O(1)**\\n\\n**Logic->Return to refill the container once you meet a plant that needs more water than you have.**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint wateringPlants(vector<int>& p, int cap) {\\n\\t\\t\\tint steps=1;\\n\\t\\t\\tint curr=cap;\\n\\t\\t\\tfor(int i=0;i<p.size()-1;i++){\\n\\t\\t\\t\\tif(curr>=p[i]) curr-=p[i];\\n\\t\\t\\t\\tif(curr<p[i+1]){\\n\\t\\t\\t\\t\\tsteps+=2*(i+1);\\n\\t\\t\\t\\t\\tcurr=cap;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tsteps++;\\n\\t\\t\\t}\\n\\t\\t\\treturn steps;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint wateringPlants(vector<int>& p, int cap) {\\n\\t\\t\\tint steps=1;\\n\\t\\t\\tint curr=cap;\\n\\t\\t\\tfor(int i=0;i<p.size()-1;i++){\\n\\t\\t\\t\\tif(curr>=p[i]) curr-=p[i];\\n\\t\\t\\t\\tif(curr<p[i+1]){\\n\\t\\t\\t\\t\\tsteps+=2*(i+1);\\n\\t\\t\\t\\t\\tcurr=cap;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2407267,
                "title": "easy-simple-approach-o-n-time-faster-than-others",
                "content": "```\\nclass Solution {\\npublic:\\n    int wateringPlants(vector<int>& plants, int capacity) {\\n        int res=0,org=capacity;\\n        for(int i=0;i<plants.size();i++){\\n            if(capacity>=plants[i]){\\n                res++;\\n                capacity-=plants[i];\\n            }\\n            else if(capacity<plants[i]){\\n                res+=2*i+1;\\n                capacity=(org-plants[i]);\\n            }\\n        }\\n        return res;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int wateringPlants(vector<int>& plants, int capacity) {\\n        int res=0,org=capacity;\\n        for(int i=0;i<plants.size();i++){\\n            if(capacity>=plants[i]){\\n                res++;\\n                capacity-=plants[i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2396426,
                "title": "simple-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int wateringPlants(vector<int>& plants, int capacity) {\\n        int steps=0;\\n        int cap=capacity;\\n        for(int i=0;i<plants.size();i++){\\n            if(plants[i]<=cap){\\n                steps+=1;\\n                cap-=plants[i];\\n            }\\n            else{\\n                steps=steps+i*2+1;\\n                cap=capacity-plants[i];\\n            }\\n        }\\n        return steps;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int wateringPlants(vector<int>& plants, int capacity) {\\n        int steps=0;\\n        int cap=capacity;\\n        for(int i=0;i<plants.size();i++){\\n            if(plants[i]<=cap){\\n                steps+=1;\\n                cap-=plants[i];\\n            }\\n            else{\\n                steps=steps+i*2+1;\\n                cap=capacity-plants[i];\\n            }\\n        }\\n        return steps;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2393376,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public int wateringPlants(int[] plants, int capacity) {\\n        int ans = 0;\\n        int max = capacity;\\n        for(int i=0;i<plants.length;i++){\\n            if(capacity<plants[i]){\\n                ans += i+i+1;\\n                capacity = max;\\n                capacity -= plants[i];\\n            }else{\\n                capacity -= plants[i];\\n                ans++;\\n            }  \\n            // System.out.print(capacity+\" \");\\n        }\\n        return ans++;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int wateringPlants(int[] plants, int capacity) {\\n        int ans = 0;\\n        int max = capacity;\\n        for(int i=0;i<plants.length;i++){\\n            if(capacity<plants[i]){\\n                ans += i+i+1;\\n                capacity = max;\\n                capacity -= plants[i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2272121,
                "title": "c",
                "content": "```\\n   int n=p.size();\\n        int ci=c;\\n        int stps=0;\\n        for(int i=0;i<n;i++){\\n            int val=p[i];\\n            if(ci>=val){\\n                ci-=val;\\n                stps++;\\n            }\\n            else{\\n                ci=c;\\n                stps+=i;\\n                \\n                 stps+=i+1;\\n             ci-=val;\\n            }\\n        }\\n        return stps;",
                "solutionTags": [],
                "code": "```\\n   int n=p.size();\\n        int ci=c;\\n        int stps=0;\\n        for(int i=0;i<n;i++){\\n            int val=p[i];\\n            if(ci>=val){\\n                ci-=val;\\n                stps++;\\n            }\\n            else{\\n                ci=c;\\n                stps+=i;\\n                \\n                 stps+=i+1;\\n             ci-=val;\\n            }\\n        }\\n        return stps;",
                "codeTag": "Unknown"
            },
            {
                "id": 2238020,
                "title": "c-solution-o-n-time",
                "content": "```\\nclass Solution {\\npublic:\\n    int wateringPlants(vector<int>& plants, int capacity) {\\n        \\n        int sum = 0, position = -1, tmp = capacity;\\n        \\n        for(int i=0; i<plants.size(); i++)\\n        {\\n            if(capacity >= plants[i])\\n            {\\n                sum += i - position;\\n                capacity -= plants[i];\\n                position++;\\n            }\\n            else\\n            {\\n                position++;\\n                sum += 2*(i + 1) - 1;\\n                capacity = tmp - plants[i];\\n            }\\n        }\\n        \\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int wateringPlants(vector<int>& plants, int capacity) {\\n        \\n        int sum = 0, position = -1, tmp = capacity;\\n        \\n        for(int i=0; i<plants.size(); i++)\\n        {\\n            if(capacity >= plants[i])\\n            {\\n                sum += i - position;\\n                capacity -= plants[i];\\n                position++;\\n            }\\n            else\\n            {\\n                position++;\\n                sum += 2*(i + 1) - 1;\\n                capacity = tmp - plants[i];\\n            }\\n        }\\n        \\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2124110,
                "title": "java-faster-than-100-less-space-than-97-easy-to-understand",
                "content": "![image](https://assets.leetcode.com/users/images/a97c329e-02f7-4709-9bad-e857372df5ff_1654643509.8462474.png)\\n\\n\\n```\\n// Time complexity = O(n)\\n// Space complexity = O(1)\\n\\nclass Solution {\\n    public int wateringPlants(int[] plants, int capacity) {\\n        int steps = 0, currCapacity = capacity;\\n        \\n        for(int i = 0; i < plants.length; i++) {\\n            steps++;\\n            if(currCapacity < plants[i]) {\\n                steps += i * 2;\\n                currCapacity = capacity;\\n            }\\n            currCapacity -= plants[i];\\n        }\\n        \\n        return steps;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// Time complexity = O(n)\\n// Space complexity = O(1)\\n\\nclass Solution {\\n    public int wateringPlants(int[] plants, int capacity) {\\n        int steps = 0, currCapacity = capacity;\\n        \\n        for(int i = 0; i < plants.length; i++) {\\n            steps++;\\n            if(currCapacity < plants[i]) {\\n                steps += i * 2;\\n                currCapacity = capacity;\\n            }\\n            currCapacity -= plants[i];\\n        }\\n        \\n        return steps;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2102660,
                "title": "simple-c-solution-o-n-time-o-1-space",
                "content": "```\\nint wateringPlants(vector<int>& plants, int capacity) {\\n        int steps_need=0;\\n        int c=capacity;\\n        for(int i=0;i<plants.size();i++){\\n            if(plants[i]>c){\\n                steps_need+=(i);\\n                c=capacity;\\n                steps_need+=(i+1);\\n                c=c-plants[i];\\n            }\\n            else\\n            {\\n                c=c-plants[i];\\n                steps_need++;\\n            }\\n        }\\n        return steps_need;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint wateringPlants(vector<int>& plants, int capacity) {\\n        int steps_need=0;\\n        int c=capacity;\\n        for(int i=0;i<plants.size();i++){\\n            if(plants[i]>c){\\n                steps_need+=(i);\\n                c=capacity;\\n                steps_need+=(i+1);\\n                c=c-plants[i];\\n            }\\n            else\\n            {\\n                c=c-plants[i];\\n                steps_need++;\\n            }\\n        }\\n        return steps_need;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2084219,
                "title": "fastest-java-solution",
                "content": "```\\nclass Solution {\\n    public int wateringPlants(int[] plants, int capacity) \\n    {\\n        int distance = 0;\\n        int jar = capacity;\\n        for(int i=0;i<plants.length;i++)\\n        {\\n            if(jar<plants[i])\\n            {\\n                distance+=(2*i);\\n                jar = capacity;\\n            }\\n            jar-=plants[i];\\n        }\\n        return distance+plants.length;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Simulation"
                ],
                "code": "class Solution {\\n    public int wateringPlants(int[] plants, int capacity) \\n    {\\n        int distance = 0;\\n        int jar = capacity;\\n        for(int i=0;i<plants.length;i++)\\n        {\\n            if(jar<plants[i])\\n            {\\n                distance+=(2*i);\\n                jar = capacity;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2012078,
                "title": "c-easy-understanding-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int wateringPlants(vector<int>& plants, int capacity) {\\n        int answer = 0;\\n        int current_position = -1; // Initially, you are at the river\\n        int current_capacity = capacity;\\n        for(int i = 0; i < plants.size(); i++){\\n            // You water the current plant\\n            current_capacity -= plants[i];\\n            current_position++;\\n            answer++; // Travel to next plant (cost 1 step)\\n            // You check if you have enough water for the next plant\\n            // If not enough water, you travel back to the river to get more water -> you travel to the river from the current position and get back the the current position -> double steps \\n            if((current_position+1) < plants.size() && current_capacity < plants[current_position+1] ){\\n                answer += 2*(current_position+1); \\n                current_capacity = capacity;\\n            }\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int wateringPlants(vector<int>& plants, int capacity) {\\n        int answer = 0;\\n        int current_position = -1; // Initially, you are at the river\\n        int current_capacity = capacity;\\n        for(int i = 0; i < plants.size(); i++){\\n            // You water the current plant\\n            current_capacity -= plants[i];\\n            current_position++;\\n            answer++; // Travel to next plant (cost 1 step)\\n            // You check if you have enough water for the next plant\\n            // If not enough water, you travel back to the river to get more water -> you travel to the river from the current position and get back the the current position -> double steps \\n            if((current_position+1) < plants.size() && current_capacity < plants[current_position+1] ){\\n                answer += 2*(current_position+1); \\n                current_capacity = capacity;\\n            }\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1956597,
                "title": "easy-java-solution-beats-100",
                "content": "```\\n\\n```class Solution {\\n    public int wateringPlants(int[] plants, int capacity) {\\n        int sumOfSteps = 0;\\n        int water = capacity;\\n        for(int i = 0; i < plants.length; i++){\\n            sumOfSteps++;\\n            water -= plants[i];\\n            if(i < plants.length - 1){\\n                if(plants[i + 1] > water){\\n                    sumOfSteps += (i + 1) * 2;\\n                    water = capacity;\\n                }\\n            }\\n            \\n        }\\n        return sumOfSteps;\\n    }\\n}",
                "solutionTags": [],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1938355,
                "title": "java-solution",
                "content": "```java\\nclass Solution {\\n    public int wateringPlants(int[] plants, int capacity) {\\n        int cap=capacity;\\n        int steps=0;\\n        for(int i=0;i<plants.length;i++)\\n        {\\n            if(plants[i]>cap)\\n            {\\n                steps+=2*i;\\n                cap=capacity;\\n                i--;\\n            }\\n            else\\n            {\\n                cap-=plants[i];\\n                  steps++;\\n            }   \\n        }\\n        return steps;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int wateringPlants(int[] plants, int capacity) {\\n        int cap=capacity;\\n        int steps=0;\\n        for(int i=0;i<plants.length;i++)\\n        {\\n            if(plants[i]>cap)\\n            {\\n                steps+=2*i;\\n                cap=capacity;\\n                i--;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1890720,
                "title": "c-easiest-solution",
                "content": "If you find this helpful please drop an upvote, thank you so much!\\n\\n```\\nint wateringPlants(vector<int>& plants, int capacity) {\\n        int ans = 0;\\n        int temp = capacity;\\n        for(int i = 0; i < plants.size(); ++i)\\n        {\\n            if (temp < plants[i])\\n            {\\n                ans += 2 * i;\\n                temp = capacity;\\n            }\\n            ++ans;    \\n            temp -= plants[i];\\n        }\\n        \\n        return ans;\\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint wateringPlants(vector<int>& plants, int capacity) {\\n        int ans = 0;\\n        int temp = capacity;\\n        for(int i = 0; i < plants.size(); ++i)\\n        {\\n            if (temp < plants[i])\\n            {\\n                ans += 2 * i;\\n                temp = capacity;\\n            }\\n            ++ans;    \\n            temp -= plants[i];\\n        }\\n        \\n        return ans;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1829189,
                "title": "c-o-n-easy-solution-with-explanation",
                "content": "***So what we are doing here is, we are creating a variable called pWater (which will initially stores the maximum value of water a can has which is provided to us as capacity) and we initially declare steps as 0***\\n**Now we run a loop where we go from 0 to n-1**\\nIn each iteration we if we counter that the water need at ith plant is less than the cans capacity we water the plant and reduce the pWater with the ith palnt need, \\nIf we counter an iteration where the need of plants is more than the cans available water we go back ***i steps to fill the water back in the can*** now we also want to come back to the ith plants location which will be again ***i and 1 step for the rive part (so, [ix2]+1)***\\nok, than at that moment we water the ith plant and reduce the pWater value.\\n\\n***Note : This solution takes O(n) time | O(1) auxilary space***\\n```\\nclass Solution {\\npublic:\\n    int wateringPlants(vector<int>& arr, int capacity) {\\n        int pWater = capacity, steps = 0;\\n        //  5 2 2 3 3\\n        // -1 0 1 2 3\\n        for(int i=0;i<arr.size();i++){\\n            if(arr[i] <= pWater){\\n                steps++;\\n                pWater -= arr[i];\\n            }\\n            else{\\n                steps += (i*2) + 1;\\n                pWater = capacity - arr[i];\\n            }\\n        }\\n        return steps;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int wateringPlants(vector<int>& arr, int capacity) {\\n        int pWater = capacity, steps = 0;\\n        //  5 2 2 3 3\\n        // -1 0 1 2 3\\n        for(int i=0;i<arr.size();i++){\\n            if(arr[i] <= pWater){\\n                steps++;\\n                pWater -= arr[i];\\n            }\\n            else{\\n                steps += (i*2) + 1;\\n                pWater = capacity - arr[i];\\n            }\\n        }\\n        return steps;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1816126,
                "title": "java-0ms-easy-with-explanation",
                "content": "```\\n public int wateringPlants(int[] plants, int capacity) {\\n        int water=capacity;//taking water of can\\n            int step=0; //for storing number of steps\\n        for(int i=0;i<plants.length;i++){\\n            if(water>=plants[i]){//if current water in can is greater than required then step++ and deduct the water used\\n                step++;\\n                water=water-plants[i];\\n            }else{\\n                step=step+i; //for steping bak to -1 to fill the can\\n                water=capacity;// fill the can with max capacity\\n\\t\\t\\t\\t step=step+i;// steps added to move to current position\\n                i--;//decrement so that current plant can be filled again\\n            }\\n        }\\n        return step;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n public int wateringPlants(int[] plants, int capacity) {\\n        int water=capacity;//taking water of can\\n            int step=0; //for storing number of steps\\n        for(int i=0;i<plants.length;i++){\\n            if(water>=plants[i]){//if current water in can is greater than required then step++ and deduct the water used\\n                step++;\\n                water=water-plants[i];\\n            }else{\\n                step=step+i; //for steping bak to -1 to fill the can\\n                water=capacity;// fill the can with max capacity\\n\\t\\t\\t\\t step=step+i;// steps added to move to current position\\n                i--;//decrement so that current plant can be filled again\\n            }\\n        }\\n        return step;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1796982,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int wateringPlants(vector<int>& plants, int capacity) {\\n        int count = 0;\\n        int i = 0;\\n        int x = capacity;\\n        while(i < plants.size()) {\\n            if(capacity >= plants[i]) {\\n                count++;\\n                capacity -= plants[i];\\n                i++;\\n            } else {\\n                count += 2*i;\\n                if(capacity == 0)\\n                    capacity = x;\\n                else\\n                    capacity += (x - capacity);\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int wateringPlants(vector<int>& plants, int capacity) {\\n        int count = 0;\\n        int i = 0;\\n        int x = capacity;\\n        while(i < plants.size()) {\\n            if(capacity >= plants[i]) {\\n                count++;\\n                capacity -= plants[i];\\n                i++;\\n            } else {\\n                count += 2*i;\\n                if(capacity == 0)\\n                    capacity = x;\\n                else\\n                    capacity += (x - capacity);\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1792386,
                "title": "simple-c-solution",
                "content": "class Solution {\\npublic:\\n    int wateringPlants(vector<int>& plants, int capacity) {\\n        int step=0;\\n        int c=capacity;\\n        for(int i=0;i<plants.size();i++)\\n        {\\n            if(c<plants[i]){\\n                step+=i;    //when don\\'t have enough water then go back from previous plant and fill the container  \\n                step+=i+1;    // for comming to the current plant \\n                c=capacity;   // capacity will be reset to original\\n            }\\n            else{\\n                step++;     //if capacity is enough increament the step\\n            }\\n            c=c-plants[i];  // water the plant and move to the next one.\\n        }\\n        return step;\\n    }\\n};\\n\\nTime Complexity:- O(n)\\nSpace Complexity:- O(1)",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "class Solution {\\npublic:\\n    int wateringPlants(vector<int>& plants, int capacity) {\\n        int step=0;\\n        int c=capacity;\\n        for(int i=0;i<plants.size();i++)\\n        {\\n            if(c<plants[i]){\\n                step+=i;    //when don\\'t have enough water then go back from previous plant and fill the container  \\n                step+=i+1;    // for comming to the current plant \\n                c=capacity;   // capacity will be reset to original\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1772417,
                "title": "c-short-and-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    int wateringPlants(vector<int>&A, int c) {\\n        int n = A.size();\\n        int cur_c = c;\\n        int steps = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            cur_c -= A[i];\\n            if(cur_c >= 0)\\n            {\\n                steps++;\\n            }\\n            else\\n            {\\n                steps += (i + i);\\n                cur_c = c;\\n                i--;\\n            }\\n        }\\n        return steps;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int wateringPlants(vector<int>&A, int c) {\\n        int n = A.size();\\n        int cur_c = c;\\n        int steps = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            cur_c -= A[i];\\n            if(cur_c >= 0)\\n            {\\n                steps++;\\n            }\\n            else\\n            {\\n                steps += (i + i);\\n                cur_c = c;\\n                i--;\\n            }\\n        }\\n        return steps;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1754942,
                "title": "c-basic-approach-with-comments-faster-than-85-self-explanatory",
                "content": "class Solution {\\npublic:\\n\\n    int wateringPlants(vector<int>& plants, int capacity)\\n    {\\n        int steps = 0;\\n        int cap = capacity;\\n        \\n        for(int i = 0; i < plants.size(); i++)\\n        {\\n            if(plants[i] <= cap)\\n            {\\n                steps++;\\n                cap -= plants[i];                //reduces the capacity of container\\n            }\\n            else\\n            {\\n                cap = capacity;\\n                cap -= plants[i];\\n               //walking to the river to re-fill the container and coming back to the plant takes (2 * i) + 1 steps.\\n                steps += (2 * i) + 1;\\n            }\\n        }\\n        return steps;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int wateringPlants(vector<int>& plants, int capacity)\\n    {\\n        int steps = 0;\\n        int cap = capacity;\\n        \\n        for(int i = 0; i < plants.size(); i++)\\n        {\\n            if(plants[i] <= cap)\\n            {\\n                steps++;\\n                cap -= plants[i];                //reduces the capacity of container\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1752561,
                "title": "solition-c",
                "content": "class Solution {\\npublic:\\n    int wateringPlants(vector<int>& plants, int capacity) {\\n        int cap=capacity; \\n        int step=0;\\n        for(int i=0; i<plants.size(); i++){\\n            if(capacity>=plants[i]){\\n                step++;\\n                capacity=capacity-plants[i];\\n            }\\n            else {\\n            \\n                step+=2*(i);\\n                capacity=cap;\\n                 step++;\\n                capacity=capacity-plants[i];\\n                \\n                \\n            }\\n        }\\n        return step;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int wateringPlants(vector<int>& plants, int capacity) {\\n        int cap=capacity; \\n        int step=0;\\n        for(int i=0; i<plants.size(); i++){\\n            if(capacity>=plants[i]){\\n                step++;\\n                capacity=capacity-plants[i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1728305,
                "title": "c-two-pointer-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int wateringPlants(vector<int>& plants, int capacity) {\\n        int temp_cap = capacity;\\n        int begin = 0;\\n        int next =0;\\n        int result = 0;\\n        while(begin<(int)plants.size()){\\n            // Two pointer.\\n            next = begin;\\n            while(next <(int)plants.size() && temp_cap >=plants[next]){\\n                temp_cap -= plants[next++];\\n                result++;\\n            }\\n            // When loop out here one of the following condition hold:\\n            // 1. Remanding water in the can is no enough to water next plants\\n            // 2. All plants has been wartered. \\n            // If next pointer out of the range of array,\\n            // all plants has been wartered.\\n            // There is no need go back to refill water again.\\n            if(next<(int)plants.size())\\n                result += 2*next;\\n            temp_cap = capacity;\\n            begin = next;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int wateringPlants(vector<int>& plants, int capacity) {\\n        int temp_cap = capacity;\\n        int begin = 0;\\n        int next =0;\\n        int result = 0;\\n        while(begin<(int)plants.size()){\\n            // Two pointer.\\n            next = begin;\\n            while(next <(int)plants.size() && temp_cap >=plants[next]){\\n                temp_cap -= plants[next++];\\n                result++;\\n            }\\n            // When loop out here one of the following condition hold:\\n            // 1. Remanding water in the can is no enough to water next plants\\n            // 2. All plants has been wartered. \\n            // If next pointer out of the range of array,\\n            // all plants has been wartered.\\n            // There is no need go back to refill water again.\\n            if(next<(int)plants.size())\\n                result += 2*next;\\n            temp_cap = capacity;\\n            begin = next;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1700650,
                "title": "javascript-o-n-solution-98-faster-in-space-complexity",
                "content": "```\\n/**\\n * @param {number[]} plants\\n * @param {number} capacity\\n * @return {number}\\n */\\nvar wateringPlants = function(plants, capacity) {\\n    var temp = capacity, steps=0;\\n    for(var i=0; i<plants.length; i++)\\n        {\\n            if(capacity>=plants[i])\\n                {\\n                    steps++;\\n                    capacity-=plants[i];\\n                }\\n            else\\n                {\\n                    steps+=i+i+1;\\n                    capacity=temp-plants[i];\\n                }\\n        }\\n    return steps;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Iterator"
                ],
                "code": "```\\n/**\\n * @param {number[]} plants\\n * @param {number} capacity\\n * @return {number}\\n */\\nvar wateringPlants = function(plants, capacity) {\\n    var temp = capacity, steps=0;\\n    for(var i=0; i<plants.length; i++)\\n        {\\n            if(capacity>=plants[i])\\n                {\\n                    steps++;\\n                    capacity-=plants[i];\\n                }\\n            else\\n                {\\n                    steps+=i+i+1;\\n                    capacity=temp-plants[i];\\n                }\\n        }\\n    return steps;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1679723,
                "title": "simple-solution-in-javascript",
                "content": "```\\nvar wateringPlants = function(plants, capacity) {\\n    var cap = capacity;\\n    var steps = 0;\\n    for(let i = 0; i < plants.length;i++){\\n        if(cap >= plants[i]){\\n            steps = steps + 1;\\n        }else{\\n            cap = capacity;\\n            steps = steps + (2 *i + 1);\\n        }\\n        cap = cap - plants[i];\\n    }\\n    return steps;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar wateringPlants = function(plants, capacity) {\\n    var cap = capacity;\\n    var steps = 0;\\n    for(let i = 0; i < plants.length;i++){\\n        if(cap >= plants[i]){\\n            steps = steps + 1;\\n        }else{\\n            cap = capacity;\\n            steps = steps + (2 *i + 1);\\n        }\\n        cap = cap - plants[i];\\n    }\\n    return steps;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1659854,
                "title": "very-simple-c-solution-to-understand",
                "content": "Just need to itrate and calculate the answer in one go\\n\\nHere is my approch \\n\\nEverytime when we have less capacity then we go back and refil it , after that we will come back to water the plants \\n\\nSo, If I am at position let say **i** then going back takes **i** steps and coming back takes **i+1** steps \\n\\nHere is my code : \\n\\n```\\nint wateringPlants(vector<int>& plants, int capacity) {\\n        int take = capacity;\\n        int n = plants.size();\\n        int ans = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(plants[i] > take)\\n            {\\n                ans += (i);\\n                ans += (i + 1);\\n                take = capacity;\\n                take -= plants[i];\\n            }\\n            \\n            else \\n            {\\n                ans++;\\n                take -= plants[i];\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint wateringPlants(vector<int>& plants, int capacity) {\\n        int take = capacity;\\n        int n = plants.size();\\n        int ans = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(plants[i] > take)\\n            {\\n                ans += (i);\\n                ans += (i + 1);\\n                take = capacity;\\n                take -= plants[i];\\n            }\\n            \\n            else \\n            {\\n                ans++;\\n                take -= plants[i];\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1659371,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int wateringPlants(int[] plants, int capacity) {\\n        int count=0;\\n        int x=capacity;\\n       for(int i=0;i<plants.length;i++)\\n       {\\n           if(plants[i]<=capacity)\\n           {\\n               capacity=capacity-plants[i];\\n               count++;\\n           }\\n           else\\n           {\\n               capacity=x;\\n               count=count+i+1+i;\\n               capacity=capacity-plants[i];\\n           }\\n       }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int wateringPlants(int[] plants, int capacity) {\\n        int count=0;\\n        int x=capacity;\\n       for(int i=0;i<plants.length;i++)\\n       {\\n           if(plants[i]<=capacity)\\n           {\\n               capacity=capacity-plants[i];\\n               count++;\\n           }\\n           else\\n           {\\n               capacity=x;\\n               count=count+i+1+i;\\n               capacity=capacity-plants[i];\\n           }\\n       }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1654242,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int wateringPlants(int[] plants, int capacity) {\\n        int result = 0;\\n        int tank = capacity;\\n        for(int i =0;i<plants.length;i++)\\n        {\\n            if(capacity < plants[i])\\n            {\\n                capacity = tank-plants[i];\\n                // cost of round-trip\\n                result += i + i+1;\\n            }\\n            else{\\n                capacity -= plants[i];\\n                // directly moving to next plant\\n                result++;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int wateringPlants(int[] plants, int capacity) {\\n        int result = 0;\\n        int tank = capacity;\\n        for(int i =0;i<plants.length;i++)\\n        {\\n            if(capacity < plants[i])\\n            {\\n                capacity = tank-plants[i];\\n                // cost of round-trip\\n                result += i + i+1;\\n            }\\n            else{\\n                capacity -= plants[i];\\n                // directly moving to next plant\\n                result++;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1625613,
                "title": "java-100-faster-solution-easy-approach",
                "content": "```\\nclass Solution {\\n    public int wateringPlants(int[] arr, int x) {\\n        int n=arr.length; int i=0;\\n        int cnt=0;\\n        int curr=x;\\n        while(i<n)\\n        {\\n            if(arr[i]<=curr) {\\n                curr-=arr[i];\\n                cnt++;\\n                i++;\\n            }\\n            else{\\n                cnt+=2*(i);\\n                curr=x;\\n            }\\n            \\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int wateringPlants(int[] arr, int x) {\\n        int n=arr.length; int i=0;\\n        int cnt=0;\\n        int curr=x;\\n        while(i<n)\\n        {\\n            if(arr[i]<=curr) {\\n                curr-=arr[i];\\n                cnt++;\\n                i++;\\n            }\\n            else{\\n                cnt+=2*(i);\\n                curr=x;\\n            }\\n            \\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1623785,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def wateringPlants(self, plants: List[int], capacity: int) -> int:\\n        n=len(plants)-1\\n        ans=1\\n        i=0\\n        initial_capacity=capacity\\n        while(i<=n):\\n            if capacity>=plants[i]:\\n                capacity-=plants[i]\\n                i+=1\\n                if i>n:\\n                    break\\n                ans+=1\\n            elif capacity<plants[i]:\\n                ans+=(i*2)\\n                capacity=initial_capacity\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def wateringPlants(self, plants: List[int], capacity: int) -> int:\\n        n=len(plants)-1\\n        ans=1\\n        i=0\\n        initial_capacity=capacity\\n        while(i<=n):\\n            if capacity>=plants[i]:\\n                capacity-=plants[i]\\n                i+=1\\n                if i>n:\\n                    break\\n                ans+=1\\n            elif capacity<plants[i]:\\n                ans+=(i*2)\\n                capacity=initial_capacity\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1616650,
                "title": "java-100-faster-o-n-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int wateringPlants(int[] plants, int capacity) {\\n        int water=capacity;\\n        boolean refilled = false;\\n        int steps=0;\\n        \\n        for(int i=0 ;i<plants.length ;i++){\\n           \\n                if(refilled==false){\\n                    steps=steps+1;\\n                    water-=plants[i];\\n                }\\n                if(refilled==true){\\n                    steps=steps+i+1;\\n                    water-=plants[i];\\n                    refilled=false;\\n                }\\n        \\n            if(i==plants.length-1) break;\\n            if(water<plants[i+1]){\\n                steps=steps+i+1;\\n                water=capacity;\\n                refilled=true;\\n            }\\n        }\\n      return steps;  \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int wateringPlants(int[] plants, int capacity) {\\n        int water=capacity;\\n        boolean refilled = false;\\n        int steps=0;\\n        \\n        for(int i=0 ;i<plants.length ;i++){\\n           \\n                if(refilled==false){\\n                    steps=steps+1;\\n                    water-=plants[i];\\n                }\\n                if(refilled==true){\\n                    steps=steps+i+1;\\n                    water-=plants[i];\\n                    refilled=false;\\n                }\\n        \\n            if(i==plants.length-1) break;\\n            if(water<plants[i+1]){\\n                steps=steps+i+1;\\n                water=capacity;\\n                refilled=true;\\n            }\\n        }\\n      return steps;  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1606288,
                "title": "java-0ms-explanations",
                "content": "```\\nclass Solution {\\n    /** Algorithm\\n\\t\\t- Loop and check if there is enough water for current plant. If yes, increment step count by 1, water the plant and move on\\n\\t\\t- If not, increase the capacity to max and add i *2 nr of steps to total step count\\n\\t*/\\n\\tpublic int wateringPlants(int[] plants, int capacity) {\\n        int totalSteps = 0;\\n        int tempCapacity = capacity;\\n        for (int i = 0; i < plants.length;) {\\n            // if enough water for current plant, water it, deduce from tempCapacity and add one step\\n\\t\\t\\tif (tempCapacity >= plants[i]) {\\n                totalSteps++;\\n                tempCapacity -= plants[i];\\n                i++;\\n            } else {\\n\\t\\t\\t// if not enough water, refill and add the number of steps back to this plant.\\n                tempCapacity = capacity;\\n                totalSteps += i * 2; \\n            }\\n        }\\n        return totalSteps;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    /** Algorithm\\n\\t\\t- Loop and check if there is enough water for current plant. If yes, increment step count by 1, water the plant and move on\\n\\t\\t- If not, increase the capacity to max and add i *2 nr of steps to total step count\\n\\t*/\\n\\tpublic int wateringPlants(int[] plants, int capacity) {\\n        int totalSteps = 0;\\n        int tempCapacity = capacity;\\n        for (int i = 0; i < plants.length;) {\\n            // if enough water for current plant, water it, deduce from tempCapacity and add one step\\n\\t\\t\\tif (tempCapacity >= plants[i]) {\\n                totalSteps++;\\n                tempCapacity -= plants[i];\\n                i++;\\n            } else {\\n\\t\\t\\t// if not enough water, refill and add the number of steps back to this plant.\\n                tempCapacity = capacity;\\n                totalSteps += i * 2; \\n            }\\n        }\\n        return totalSteps;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1604339,
                "title": "simple-for-loop-0-n-time-complexity",
                "content": "Just loop through the plant items..\\nfor each plant deduct the capacity\\nand for remaining capacity check it can satisfy the next plant\\nif not go back and come back...2*(i+1)\\nsimple\\n```\\nclass Solution:\\n    def wateringPlants(self, plants: List[int], capacity: int) -> int:\\n        steps=0\\n        rem_capacity=capacity\\n        for i in range(len(plants)-1):\\n            rem_capacity-=plants[i]\\n            steps+=1\\n            if rem_capacity<plants[i+1]:\\n                steps+=2*(i+1)\\n                rem_capacity=capacity\\n                \\n        if plants[-1]<=rem_capacity:\\n            steps+=1\\n            \\n        return steps\\n\\t\\t```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def wateringPlants(self, plants: List[int], capacity: int) -> int:\\n        steps=0\\n        rem_capacity=capacity\\n        for i in range(len(plants)-1):\\n            rem_capacity-=plants[i]\\n            steps+=1\\n            if rem_capacity<plants[i+1]:\\n                steps+=2*(i+1)\\n                rem_capacity=capacity\\n                \\n        if plants[-1]<=rem_capacity:\\n            steps+=1\\n            \\n        return steps\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1600940,
                "title": "easy-to-understand-for-beginners-as-well",
                "content": "```\\nvar wateringPlants = function(p, c) {\\n    let capacity=c;\\n    let step=0;\\n\\t\\n    for(let i=0;i<p.length;i++){\\n        if(p[i]<=capacity){\\n            capacity-=p[i]\\n            step++\\n        }else{\\n            step+=i-0 // steps for going back to refill\\n            capacity=c // now its refilled\\n            step+=i-0+1 // steps for again coming to the same plant to water it\\n            capacity-=p[i] // after watering\\n        }\\n    }\\n    return step\\n};\\n```\\nRuntime: 68 ms, faster than 97.28% of JavaScript online submissions for Watering Plants.\\nMemory Usage: 39.2 MB, less than 22.28% of JavaScript online submissions for Watering Plants.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar wateringPlants = function(p, c) {\\n    let capacity=c;\\n    let step=0;\\n\\t\\n    for(let i=0;i<p.length;i++){\\n        if(p[i]<=capacity){\\n            capacity-=p[i]\\n            step++\\n        }else{\\n            step+=i-0 // steps for going back to refill\\n            capacity=c // now its refilled\\n            step+=i-0+1 // steps for again coming to the same plant to water it\\n            capacity-=p[i] // after watering\\n        }\\n    }\\n    return step\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1598539,
                "title": "code-explaination",
                "content": "```\\nclass Solution {\\npublic:\\n    int wateringPlants(vector<int>& plants, int capacity) {\\n        int volume = capacity; // store capacity in another variable for future use\\n        int len = plants.size();\\n        int dist_travelled = 0;\\n        for(int i=0; i< len; i++){\\n\\t\\t\\t//  if our vessel has more water than amount of water required by plant,\\n\\t\\t\\t// then only we could water the plant\\n            if(volume>=plants[i]){\\n                volume -= plants[i]; // after watering, this would be the water remained in our vessel\\n                dist_travelled += 1; // only one unit of distance travelled in such cases\\n            }\\n\\t\\t\\t// otherwise we have to go back and fill our water vessel upto its volume\\n\\t\\t\\t// distance travelled to reach river is i\\n\\t\\t\\t// after we filling our vessel with water we will go to the next plant ( dist travelled = i+1) and \\n\\t\\t\\t// water it. (new Volume = capacity - plants[i]) \\n\\t\\t\\telse{\\n                volume = capacity - plants[i];\\n                dist_travelled += (i+1) + (i);\\n            }\\n        }\\n        return dist_travelled;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int wateringPlants(vector<int>& plants, int capacity) {\\n        int volume = capacity; // store capacity in another variable for future use\\n        int len = plants.size();\\n        int dist_travelled = 0;\\n        for(int i=0; i< len; i++){\\n\\t\\t\\t//  if our vessel has more water than amount of water required by plant,\\n\\t\\t\\t// then only we could water the plant\\n            if(volume>=plants[i]){\\n                volume -= plants[i]; // after watering, this would be the water remained in our vessel\\n                dist_travelled += 1; // only one unit of distance travelled in such cases\\n            }\\n\\t\\t\\t// otherwise we have to go back and fill our water vessel upto its volume\\n\\t\\t\\t// distance travelled to reach river is i\\n\\t\\t\\t// after we filling our vessel with water we will go to the next plant ( dist travelled = i+1) and \\n\\t\\t\\t// water it. (new Volume = capacity - plants[i]) \\n\\t\\t\\telse{\\n                volume = capacity - plants[i];\\n                dist_travelled += (i+1) + (i);\\n            }\\n        }\\n        return dist_travelled;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1596756,
                "title": "java-easy-solution-beats-100",
                "content": "```\\nclass Solution {\\n    public int wateringPlants(int[] plants, int capacity) {\\n        int res = 0, sum = 0;\\n        for (int i = 0; i < plants.length; i++) {\\n            sum += plants[i];\\n            if (capacity >= sum) {\\n                res++;\\n            } else {\\n                res += i * 2;\\n                sum = 0;\\n                i--;\\n            }\\n        }\\n        return res;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int wateringPlants(int[] plants, int capacity) {\\n        int res = 0, sum = 0;\\n        for (int i = 0; i < plants.length; i++) {\\n            sum += plants[i];\\n            if (capacity >= sum) {\\n                res++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1592830,
                "title": "watering-plants",
                "content": "class Solution {\\npublic:\\n    int wateringPlants(vector<int>& plants, int capacity) {\\n        int cap=capacity;\\n        int step=0;\\n        for(int i=0;i<plants.size();i++){\\n            if(cap>=plants[i]){\\n                cap-=plants[i];\\n                step+=1;\\n            }\\n            else{\\n                step+=2*i+1;\\n                cap=capacity;\\n                cap-=plants[i];\\n            }\\n        }\\n        return step;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int wateringPlants(vector<int>& plants, int capacity) {\\n        int cap=capacity;\\n        int step=0;\\n        for(int i=0;i<plants.size();i++){\\n            if(cap>=plants[i]){\\n                cap-=plants[i];\\n                step+=1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1592478,
                "title": "javascript-solution-88-16-76ms",
                "content": "```\\nvar wateringPlants = function(plants, capacity) {\\n\\t// initiate the step count and the water level\\n    let steps = 0, water = capacity\\n\\t// loop through the plants, starting at the river (0)\\n    for(let i = 1; i <= plants.length; i++){\\n        // if the water level is great enough to water the next plant...\\n\\t\\tif(water >= plants[i-1]){\\n\\t\\t\\t// take a step\\n            steps++\\n\\t\\t\\t// water the plant - decrease the water value by the \\'plants[i]\\' amount\\n            water -= plants[i-1]\\n\\t\\t// else if the water level isnt enough to fill the next plant\\n        } else {\\n\\t\\t\\t//walk back to the river (\\'i\\' amount of steps - 1) to fill the can, then walk to the plant (\\'i\\' amount of steps)\\n            steps += (i+i-1)\\n\\t\\t\\t// water the plant with your newly filled can - decrease the water value (full capacity) by the \\'plants[i]\\' amount\\n            water = capacity - plants[i-1]\\n        }\\n    }\\n\\t// after the loop has finished return the final amount of steps\\n    return steps\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar wateringPlants = function(plants, capacity) {\\n\\t// initiate the step count and the water level\\n    let steps = 0, water = capacity\\n\\t// loop through the plants, starting at the river (0)\\n    for(let i = 1; i <= plants.length; i++){\\n        // if the water level is great enough to water the next plant...\\n\\t\\tif(water >= plants[i-1]){\\n\\t\\t\\t// take a step\\n            steps++\\n\\t\\t\\t// water the plant - decrease the water value by the \\'plants[i]\\' amount\\n            water -= plants[i-1]\\n\\t\\t// else if the water level isnt enough to fill the next plant\\n        } else {\\n\\t\\t\\t//walk back to the river (\\'i\\' amount of steps - 1) to fill the can, then walk to the plant (\\'i\\' amount of steps)\\n            steps += (i+i-1)\\n\\t\\t\\t// water the plant with your newly filled can - decrease the water value (full capacity) by the \\'plants[i]\\' amount\\n            water = capacity - plants[i-1]\\n        }\\n    }\\n\\t// after the loop has finished return the final amount of steps\\n    return steps\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1592115,
                "title": "c-easy-soln-o-n",
                "content": "```\\n\\n```class Solution {\\npublic:\\n    int wateringPlants(vector<int>& p, int capacity) {\\n        int ans=0; int c=capacity;\\n        int n=p.size();\\n        for(int i=0;i<n;i++){\\n            if(c>=p[i]){\\n                ans+=1;\\n            }\\n            else{\\n                ans+=2*i+1;\\n                c=capacity;\\n            }\\n            c=c-p[i];\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1591999,
                "title": "simple-c-solution-with-comments-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int wateringPlants(vector<int>& plants, int capacity) {\\n       int ct=0,rfill=capacity;\\n        for(int i=0;i<plants.size();i++)\\n        {\\n            if(capacity>=plants[i])//ive checked if remaining capacity is enough for the next plant or not\\n            {\\n              capacity=capacity-plants[i];//if it is enough i simply update my capacity and increase my count\\n              ct++;\\n            }\\n            else{\\n                capacity=rfill;//I refill in case its not enough and update my count with twice the length\\n\\t\\t\\t                         //\\tive traversed so far and an additonal +1 since my capacity will be enough \\n\\t\\t\\t    ct=ct+2*i;\\n                ct++;\\n                capacity-=plants[i];\\n            }\\n        }\\n        return ct;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int wateringPlants(vector<int>& plants, int capacity) {\\n       int ct=0,rfill=capacity;\\n        for(int i=0;i<plants.size();i++)\\n        {\\n            if(capacity>=plants[i])//ive checked if remaining capacity is enough for the next plant or not\\n            {\\n              capacity=capacity-plants[i];//if it is enough i simply update my capacity and increase my count\\n              ct++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1591850,
                "title": "c-simulation-time-complexity-o-n",
                "content": "```\\n\\tpublic int WateringPlants(int[] plants, int capacity) {\\n        var numberOfSteps = 0;\\n        var remainingWater = capacity;\\n        for (int i=0; i<plants.Length; i++) {\\n            if (plants[i] > remainingWater) {\\n                numberOfSteps += 2*i;\\n                remainingWater = capacity;    \\n            }\\n            remainingWater -= plants[i];\\n            numberOfSteps++;\\n        }\\n        return numberOfSteps;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tpublic int WateringPlants(int[] plants, int capacity) {\\n        var numberOfSteps = 0;\\n        var remainingWater = capacity;\\n        for (int i=0; i<plants.Length; i++) {\\n            if (plants[i] > remainingWater) {\\n                numberOfSteps += 2*i;\\n                remainingWater = capacity;    \\n            }\\n            remainingWater -= plants[i];\\n            numberOfSteps++;\\n        }\\n        return numberOfSteps;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1591599,
                "title": "java-o-n",
                "content": "```\\nclass Solution {\\n    public int wateringPlants(int[] plants, int capacity) {\\n        int c=capacity;\\n        int steps=0;\\n        for(int i=0;i<plants.length;i++){\\n            if(plants[i]>c){\\n                steps+=(i * 2) + 1; \\n                c=capacity-plants[i];\\n            }\\n            else \\n            {\\n                steps+=1;\\n                c-=plants[i];\\n            }\\n        }\\n        return steps;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int wateringPlants(int[] plants, int capacity) {\\n        int c=capacity;\\n        int steps=0;\\n        for(int i=0;i<plants.length;i++){\\n            if(plants[i]>c){\\n                steps+=(i * 2) + 1; \\n                c=capacity-plants[i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1590875,
                "title": "c-simple-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int wateringPlants(vector<int>& plants, int capacity) {\\n        int ct=0;\\n        int x = capacity;\\n        for(int i=0;i<plants.size();i++){\\n            x = x - plants[i];\\n            \\n            if(x<0){\\n             x=capacity-plants[i];\\n                \\n            ct+= (i+1+i);\\n            }\\n            else{\\n               ct++; \\n            } \\n        }\\n       return ct;\\n        \\n }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int wateringPlants(vector<int>& plants, int capacity) {\\n        int ct=0;\\n        int x = capacity;\\n        for(int i=0;i<plants.size();i++){\\n            x = x - plants[i];\\n            \\n            if(x<0){\\n             x=capacity-plants[i];\\n                \\n            ct+= (i+1+i);\\n            }\\n            else{\\n               ct++; \\n            } \\n        }\\n       return ct;\\n        \\n }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1590864,
                "title": "simple-java-solution",
                "content": "class Solution {\\n\\n    public int wateringPlants(int[] p, int c) {\\n        int k=p.length,s=0,c1=c;\\n        for(int i=0;i<k;i++)\\n        {\\n            if(p[i]>c1)\\n            {\\n                s=s+(i-0)+i;\\n                c1=c;\\n            }\\n            s+=1;\\n            c1-=p[i];\\n        }\\n        return s;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Simulation"
                ],
                "code": "class Solution {\\n\\n    public int wateringPlants(int[] p, int c) {\\n        int k=p.length,s=0,c1=c;\\n        for(int i=0;i<k;i++)\\n        {\\n            if(p[i]>c1)\\n            {\\n                s=s+(i-0)+i;\\n                c1=c;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1590850,
                "title": "c-100-time-self-explanatory",
                "content": "```\\nclass Solution {\\npublic:\\n    int wateringPlants(vector<int>& plants, int cap) {\\n        int capacity=cap,start=1,count=0;\\n        for(int i=0;i<plants.size();){\\n            if(capacity>=plants[i]){\\n                capacity-=plants[i];\\n                i++;\\n                count++;\\n            }\\n            else{\\n                count+=(i)+(i+1);\\n                capacity=cap;\\n                capacity-=plants[i];\\n                i++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int wateringPlants(vector<int>& plants, int cap) {\\n        int capacity=cap,start=1,count=0;\\n        for(int i=0;i<plants.size();){\\n            if(capacity>=plants[i]){\\n                capacity-=plants[i];\\n                i++;\\n                count++;\\n            }\\n            else{\\n                count+=(i)+(i+1);\\n                capacity=cap;\\n                capacity-=plants[i];\\n                i++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1590261,
                "title": "there-s-really-nothing-much",
                "content": "tbh this dosen\\'t really seem like medium problem\\uD83D\\uDE1B\\n```\\nclass Solution {\\npublic:\\n    int wateringPlants(vector<int>& plants, int capacity) {\\n        int i=0; \\n        int steps = 0; \\n        int n = plants.size() , curr=capacity; \\n        while(i<n){\\n            if(plants[i]>curr)  {\\n                curr = capacity;\\n                steps += i*2+1; \\n            }\\n            else \\n                steps++;\\n            curr -= plants[i];\\n            i++;\\n        }\\n        return steps; \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int wateringPlants(vector<int>& plants, int capacity) {\\n        int i=0; \\n        int steps = 0; \\n        int n = plants.size() , curr=capacity; \\n        while(i<n){\\n            if(plants[i]>curr)  {\\n                curr = capacity;\\n                steps += i*2+1; \\n            }\\n            else \\n                steps++;\\n            curr -= plants[i];\\n            i++;\\n        }\\n        return steps; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1589910,
                "title": "python-simulation",
                "content": "```\\nclass Solution:\\n    def wateringPlants(self, P: List[int], C: int) -> int:\\n        \\n        cur_c = C\\n        res = 0\\n        for i, p in enumerate(P):\\n            if cur_c >= p:\\n                res += 1\\n                cur_c -= p\\n            else:\\n                res += 2 * i + 1\\n                cur_c = C - p\\n                \\n        return res",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def wateringPlants(self, P: List[int], C: int) -> int:\\n        \\n        cur_c = C\\n        res = 0\\n        for i, p in enumerate(P):\\n            if cur_c >= p:\\n                res += 1\\n                cur_c -= p\\n            else:\\n                res += 2 * i + 1\\n                cur_c = C - p\\n                \\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 1589458,
                "title": "c-easy-to-understand-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int wateringPlants(vector<int>& plants, int capacity) \\n    {\\n\\t    //Storing capacity in nc will use to refill it later\\n        int nc=capacity;\\n\\t\\t//Initially steps are 0\\n        int steps=0;\\n        for(int i=0;i<plants.size();i++)\\n        {\\n\\t\\t//We will only water plant if the capacity is greater than the plant need\\n            if(plants[i]<=nc)\\n            {\\n\\t\\t\\t//After giving water new capacity\\n                nc=nc-plants[i];\\n\\t\\t\\t\\t//Increase the steps\\n                steps++;\\n\\t\\t//If we had given water to the plant make it zero because we will count our steps again when we come to refill can \\n                plants[i]=0;\\n            }\\n            else if(plants[i]>nc)\\n            {\\n\\t\\t\\t// counting the steps when we are returning to refill water\\n                steps=i+steps+1;\\n\\t\\t\\t\\t// water is refilled\\n                nc=capacity;\\n\\t\\t\\t\\t//now giving water to the plant \\n                nc=nc-plants[i];\\n\\t\\t\\t\\t// after giving water make it zero\\n                plants[i]=0;\\n\\t\\t\\t\\t// we did i=0 to start steps again from the starting \\n                i=0;\\n            }\\n        }\\n        return steps;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int wateringPlants(vector<int>& plants, int capacity) \\n    {\\n\\t    //Storing capacity in nc will use to refill it later\\n        int nc=capacity;\\n\\t\\t//Initially steps are 0\\n        int steps=0;\\n        for(int i=0;i<plants.size();i++)\\n        {\\n\\t\\t//We will only water plant if the capacity is greater than the plant need\\n            if(plants[i]<=nc)\\n            {\\n\\t\\t\\t//After giving water new capacity\\n                nc=nc-plants[i];\\n\\t\\t\\t\\t//Increase the steps\\n                steps++;\\n\\t\\t//If we had given water to the plant make it zero because we will count our steps again when we come to refill can \\n                plants[i]=0;\\n            }\\n            else if(plants[i]>nc)\\n            {\\n\\t\\t\\t// counting the steps when we are returning to refill water\\n                steps=i+steps+1;\\n\\t\\t\\t\\t// water is refilled\\n                nc=capacity;\\n\\t\\t\\t\\t//now giving water to the plant \\n                nc=nc-plants[i];\\n\\t\\t\\t\\t// after giving water make it zero\\n                plants[i]=0;\\n\\t\\t\\t\\t// we did i=0 to start steps again from the starting \\n                i=0;\\n            }\\n        }\\n        return steps;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1589346,
                "title": "python-simulation-explained-100-faster-in-both-time-and-space",
                "content": "```\\nclass Solution:\\n    def wateringPlants(self, plants: List[int], capacity: int) -> int:\\n        ans = 0\\n        cur = capacity\\n        \\n        for i in range(len(plants)):\\n            if plants[i] > cur:\\n                cur = capacity\\n                ans += 2 * i\\n            ans += 1\\n            cur -= plants[i]\\n            \\n        return ans\\n```\\nWhen we are at a value that is less than capacity we just increment the ans by 1 but when we are at a value that exceeds the capacity we have to go back `2*i` steps so we just add this steps when this is the case\\n![image](https://assets.leetcode.com/users/images/656103d8-1d0d-4eeb-b2cc-c7b465555e4c_1637473772.9196455.png)\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Simulation"
                ],
                "code": "```\\nclass Solution:\\n    def wateringPlants(self, plants: List[int], capacity: int) -> int:\\n        ans = 0\\n        cur = capacity\\n        \\n        for i in range(len(plants)):\\n            if plants[i] > cur:\\n                cur = capacity\\n                ans += 2 * i\\n            ans += 1\\n            cur -= plants[i]\\n            \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1589189,
                "title": "c-o-n-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int wateringPlants(vector<int>& plants, int capacity) {\\n        int c=capacity;\\n        int n=plants.size();\\n        int steps=0;\\n        for(int i=0;i<n;i++) {\\n            if(plants[i]<=capacity) {\\n                steps++;\\n            }\\n            else {\\n                int step=(2*i)+1;\\n                capacity=c;\\n                steps+=step;\\n            }\\n            capacity-=plants[i];\\n        }\\n        return steps;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int wateringPlants(vector<int>& plants, int capacity) {\\n        int c=capacity;\\n        int n=plants.size();\\n        int steps=0;\\n        for(int i=0;i<n;i++) {\\n            if(plants[i]<=capacity) {\\n                steps++;\\n            }\\n            else {\\n                int step=(2*i)+1;\\n                capacity=c;\\n                steps+=step;\\n            }\\n            capacity-=plants[i];\\n        }\\n        return steps;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1589165,
                "title": "c-o-n-well-explained-and-commented-solution",
                "content": "convert the ith element to 0 if it can be watered coming from previous plants,and if you need to go back to plant the water, then convert it to 1.\\nif converted element is 0,then ans++, else go back from (i-1)th element to -1 and come back to ith element for watering the plant i.e. from (i-1) to -1 =i-1-1=i-2 then move i+1 steps to come to il i.e. i-2+i+1=2i-1.\\n```\\nclass Solution {\\npublic:\\n    int wateringPlants(vector<int>& plants, int c) {\\n        int n=plants.size();\\n        int sum=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            sum+=plants[i];\\n            if(sum<=c)\\n                plants[i]=0;   //if sum is smaller or equal to capacity\\n            else{\\n                sum=plants[i];  // if not, then put 1\\n                plants[i]=1;\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n            cout<<plants[i];\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(plants[i]==0)        //if ith element equals 0,just move forward\\n                ans++;\\n            else ans+=2*(i+1)-1;     //else from (i-1)th go to -1 then come back to 1;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int wateringPlants(vector<int>& plants, int c) {\\n        int n=plants.size();\\n        int sum=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            sum+=plants[i];\\n            if(sum<=c)\\n                plants[i]=0;   //if sum is smaller or equal to capacity\\n            else{\\n                sum=plants[i];  // if not, then put 1\\n                plants[i]=1;\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n            cout<<plants[i];\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(plants[i]==0)        //if ith element equals 0,just move forward\\n                ans++;\\n            else ans+=2*(i+1)-1;     //else from (i-1)th go to -1 then come back to 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1589136,
                "title": "c-simple-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint wateringPlants(vector<int>& plants, int capacity) {\\n\\t\\t\\tint ans = 0;\\n\\t\\t\\tint curr = capacity;\\n\\t\\t\\tfor(int i = 0; i < plants.size(); i++){\\n\\t\\t\\t\\tif(curr >= plants[i]){\\n\\t\\t\\t\\t\\tans++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tans += i;\\n\\t\\t\\t\\t\\tans += (i + 1);\\n\\t\\t\\t\\t\\tcurr = capacity;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcurr -= plants[i];\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint wateringPlants(vector<int>& plants, int capacity) {\\n\\t\\t\\tint ans = 0;\\n\\t\\t\\tint curr = capacity;\\n\\t\\t\\tfor(int i = 0; i < plants.size(); i++){\\n\\t\\t\\t\\tif(curr >= plants[i]){\\n\\t\\t\\t\\t\\tans++;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1589097,
                "title": "javascript-simple-and-clean-solution",
                "content": "```\\n/**\\n * @param {number[]} plants\\n * @param {number} capacity\\n * @return {number}\\n */\\n var wateringPlants = function(plants, capacity) {\\n    let steps = 0\\n    let cap = capacity // current capacity\\n\\n    for(let i = 0; i < plants.length; i++) {\\n\\n        if(cap < plants[i]) {\\n            steps += 2*i\\n            cap = capacity\\n        }\\n\\n        steps++\\n        cap -= plants[i]\\n    }\\n\\n\\n    return steps\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Simulation"
                ],
                "code": "```\\n/**\\n * @param {number[]} plants\\n * @param {number} capacity\\n * @return {number}\\n */\\n var wateringPlants = function(plants, capacity) {\\n    let steps = 0\\n    let cap = capacity // current capacity\\n\\n    for(let i = 0; i < plants.length; i++) {\\n\\n        if(cap < plants[i]) {\\n            steps += 2*i\\n            cap = capacity\\n        }\\n\\n        steps++\\n        cap -= plants[i]\\n    }\\n\\n\\n    return steps\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1589053,
                "title": "simple-c-solution",
                "content": "class Solution {\\npublic:\\n    int wateringPlants(vector<int>& nums, int capacity) {\\n        int steps=0;\\n        int tempCP=capacity;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]<=tempCP)\\n            {\\n                tempCP-=nums[i];\\n            }\\n            else\\n            {\\n                steps+=i; // go backwards to fill water\\n                steps+=i; // aage forwrad to plant water\\n                //tempCP=capacity;\\n                tempCP=capacity-nums[i];\\n            }\\n            steps++;\\n        }\\n        return steps;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int wateringPlants(vector<int>& nums, int capacity) {\\n        int steps=0;\\n        int tempCP=capacity;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]<=tempCP)\\n            {\\n                tempCP-=nums[i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1589047,
                "title": "java-one-pass",
                "content": "```\\nclass Solution {\\n    public int wateringPlants(int[] plants, int capacity) {\\n        int fullCap = capacity;\\n        \\n        int res = 0;\\n        \\n        for (int i = 0; i < plants.length; i++) {\\n            if (capacity - plants[i] >= 0) {\\n                res++;\\n                capacity = capacity - plants[i];\\n                continue;\\n            } else {\\n                res = res + 2 * (i);\\n                res++;\\n                capacity = fullCap;\\n                capacity = capacity - plants[i];\\n            }\\n        }\\n        \\n        return res;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int wateringPlants(int[] plants, int capacity) {\\n        int fullCap = capacity;\\n        \\n        int res = 0;\\n        \\n        for (int i = 0; i < plants.length; i++) {\\n            if (capacity - plants[i] >= 0) {\\n                res++;\\n                capacity = capacity - plants[i];\\n                continue;\\n            } else {\\n                res = res + 2 * (i);\\n                res++;\\n                capacity = fullCap;\\n                capacity = capacity - plants[i];\\n            }\\n        }\\n        \\n        return res;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4087659,
                "title": "2079",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int wateringPlants(int[] plants, int capacity) {\\n        int river = -1;\\n        int count = 0;\\n        int step;\\n        int max = capacity;\\n        for(int i = 0;i < plants.length-1;i++){\\n            count++;\\n            capacity -= plants[i];\\n            if(capacity < plants[i+1]){\\n                step = 2 * (i - river);\\n                count += step;\\n                capacity = max;\\n            }\\n        }\\n        count++;\\n        return count; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int wateringPlants(int[] plants, int capacity) {\\n        int river = -1;\\n        int count = 0;\\n        int step;\\n        int max = capacity;\\n        for(int i = 0;i < plants.length-1;i++){\\n            count++;\\n            capacity -= plants[i];\\n            if(capacity < plants[i+1]){\\n                step = 2 * (i - river);\\n                count += step;\\n                capacity = max;\\n            }\\n        }\\n        count++;\\n        return count; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4082350,
                "title": "java-iteration",
                "content": "```\\nclass Solution {\\n    public int wateringPlants(int[] plants, int capacity) {\\n        \\n        int remWater = capacity;\\n        int step =0;\\n        \\n        for(int i=0;i <plants.length; i++){\\n            step++;\\n            if(remWater <plants[i]){\\n                step = step + refill(i);\\n                remWater = capacity- plants[i];\\n                \\n            }else{\\n                remWater = remWater -plants[i];\\n            }\\n        }\\n        return step;\\n    }\\n    \\n    private int refill(int currStep){\\n        return 2*currStep;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int wateringPlants(int[] plants, int capacity) {\\n        \\n        int remWater = capacity;\\n        int step =0;\\n        \\n        for(int i=0;i <plants.length; i++){\\n            step++;\\n            if(remWater <plants[i]){\\n                step = step + refill(i);\\n                remWater = capacity- plants[i];\\n                \\n            }else{\\n                remWater = remWater -plants[i];\\n            }\\n        }\\n        return step;\\n    }\\n    \\n    private int refill(int currStep){\\n        return 2*currStep;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4076034,
                "title": "easy-clean-code",
                "content": "# Complexity\\n```\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n```\\n\\n# Code\\n## Please Upvote if u found it useful\\uD83E\\uDD17\\n```\\nclass Solution {\\npublic:\\n    int wateringPlants(vector<int>& plants, int capacity) {\\n        int n = plants.size(), steps = 1, x = capacity;\\n        x -= plants[0];\\n        for(int i = 0 ; i < n - 1; i++){\\n            if(x >= plants[i + 1])\\n                steps++;\\n            else{\\n                steps += (i + 1) * 2 + 1;\\n                x = capacity;\\n            }\\n            x -= plants[i + 1];\\n        }\\n        return steps;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n```\n```\\nclass Solution {\\npublic:\\n    int wateringPlants(vector<int>& plants, int capacity) {\\n        int n = plants.size(), steps = 1, x = capacity;\\n        x -= plants[0];\\n        for(int i = 0 ; i < n - 1; i++){\\n            if(x >= plants[i + 1])\\n                steps++;\\n            else{\\n                steps += (i + 1) * 2 + 1;\\n                x = capacity;\\n            }\\n            x -= plants[i + 1];\\n        }\\n        return steps;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4074075,
                "title": "easy-to-understand-python3-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def wateringPlants(self, plants: List[int], capacity: int) -> int:\\n        l, steps, k = 0, 0, capacity\\n\\n        while l < len(plants):\\n            if plants[l] <= k:\\n                steps += 1\\n                k -= plants[l]\\n                l += 1\\n            else:\\n                steps += 2 * l\\n                k = capacity\\n\\n        return steps\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def wateringPlants(self, plants: List[int], capacity: int) -> int:\\n        l, steps, k = 0, 0, capacity\\n\\n        while l < len(plants):\\n            if plants[l] <= k:\\n                steps += 1\\n                k -= plants[l]\\n                l += 1\\n            else:\\n                steps += 2 * l\\n                k = capacity\\n\\n        return steps\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4060690,
                "title": "100-fast-solution",
                "content": "# Intuition\\nCalculate if we have enough space in the container for the next tree\\n\\n# Approach\\nStarting from the 0th tree, analyze if we have enough container space to water the next tree, if we have enough space, then we go to the next tree directly by adding 1 cost to the result, otherwise go to the river with 2 * (i + 1 where i is the current tree number in the row) cost and navigate to the next tree by adding 1 cost to the result.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int wateringPlants(int[] plants, int capacity) {\\n        int result = 0, tempCapacity = capacity;\\n        for (int i = 0; i < plants.length - 1; i++) {\\n            result++;\\n            tempCapacity -= plants[i];\\n            if (plants[i + 1] <= tempCapacity) continue;\\n            else {\\n                result += 2 * (i + 1);\\n                tempCapacity = capacity;\\n            }\\n        }\\n        result++;\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int wateringPlants(int[] plants, int capacity) {\\n        int result = 0, tempCapacity = capacity;\\n        for (int i = 0; i < plants.length - 1; i++) {\\n            result++;\\n            tempCapacity -= plants[i];\\n            if (plants[i + 1] <= tempCapacity) continue;\\n            else {\\n                result += 2 * (i + 1);\\n                tempCapacity = capacity;\\n            }\\n        }\\n        result++;\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4059673,
                "title": "java-easy-solution",
                "content": "Please **UPVOTE** if you like my solution!\\n\\n```\\nclass Solution {\\n    public int wateringPlants(int[] plants, int cap) {\\n        int x = cap;\\n        int count = 0;\\n        for(int i = 0;i<plants.length-1;i++){\\n            cap = cap - plants[i];\\n            if(plants[i+1]>cap){\\n                cap = x;\\n                count += (2*(i+1)+1);\\n            }\\n            else{\\n                count++;\\n            }\\n        }\\n        return count+1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int wateringPlants(int[] plants, int cap) {\\n        int x = cap;\\n        int count = 0;\\n        for(int i = 0;i<plants.length-1;i++){\\n            cap = cap - plants[i];\\n            if(plants[i+1]>cap){\\n                cap = x;\\n                count += (2*(i+1)+1);\\n            }\\n            else{\\n                count++;\\n            }\\n        }\\n        return count+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4057203,
                "title": "brute-force",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int wateringPlants(vector<int>& plants, int capacity) {\\n        int n=plants.size();\\n        int steps=0;\\n        int in=capacity;\\n        for(int i=0;i<n;){\\n            if(i==-1){\\n                capacity=in;\\n                i++;\\n                continue;\\n            }\\n            if(plants[i]<=capacity){\\n                capacity-=plants[i];\\n                plants[i]=0;\\n                i++;\\n                steps++;\\n                continue;\\n            }\\n            else{\\n                steps+=(i);\\n                i=-1;\\n                continue;\\n            }\\n\\n        }\\n        return steps;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int wateringPlants(vector<int>& plants, int capacity) {\\n        int n=plants.size();\\n        int steps=0;\\n        int in=capacity;\\n        for(int i=0;i<n;){\\n            if(i==-1){\\n                capacity=in;\\n                i++;\\n                continue;\\n            }\\n            if(plants[i]<=capacity){\\n                capacity-=plants[i];\\n                plants[i]=0;\\n                i++;\\n                steps++;\\n                continue;\\n            }\\n            else{\\n                steps+=(i);\\n                i=-1;\\n                continue;\\n            }\\n\\n        }\\n        return steps;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4054837,
                "title": "brute-force-approach-1ms",
                "content": "****Bold****# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int wateringPlants(int[] plants, int capacity) {\\n        \\n        int steps = 0;\\n        int refill =0;\\n        int i =0;\\n        int newCapacity = capacity;\\n        if(1<=plants.length && plants.length<=1000)\\n        {\\n\\n         while(i<plants.length)\\n         {\\n            if(newCapacity>=plants[i])\\n            {\\n                steps++;\\n                newCapacity = newCapacity-plants[i];\\n                i++;\\n            }\\n            else\\n            {\\n                int j = i;\\n                steps = steps + 2*j+1;\\n                newCapacity = capacity;\\n                refill++;\\n            }\\n         }\\n        }\\n\\n        return steps-refill;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int wateringPlants(int[] plants, int capacity) {\\n        \\n        int steps = 0;\\n        int refill =0;\\n        int i =0;\\n        int newCapacity = capacity;\\n        if(1<=plants.length && plants.length<=1000)\\n        {\\n\\n         while(i<plants.length)\\n         {\\n            if(newCapacity>=plants[i])\\n            {\\n                steps++;\\n                newCapacity = newCapacity-plants[i];\\n                i++;\\n            }\\n            else\\n            {\\n                int j = i;\\n                steps = steps + 2*j+1;\\n                newCapacity = capacity;\\n                refill++;\\n            }\\n         }\\n        }\\n\\n        return steps-refill;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4042899,
                "title": "fast-and-simple-kotlin-solution-o-n-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n   fun wateringPlants(plants: IntArray, capacity: Int): Int {\\n    var stepsResult = 0\\n    var position = -1\\n    var currentCapacity = capacity\\n    plants.forEachIndexed { index, waterNeeded ->\\n        var steps = 0\\n        if(waterNeeded > currentCapacity){\\n            steps += (position - (-1))*2 + 1\\n            currentCapacity = capacity\\n        }else{\\n            steps += 1\\n        }\\n        currentCapacity -= waterNeeded\\n        position = index\\n        stepsResult += steps\\n    }\\n    return stepsResult\\n}\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n   fun wateringPlants(plants: IntArray, capacity: Int): Int {\\n    var stepsResult = 0\\n    var position = -1\\n    var currentCapacity = capacity\\n    plants.forEachIndexed { index, waterNeeded ->\\n        var steps = 0\\n        if(waterNeeded > currentCapacity){\\n            steps += (position - (-1))*2 + 1\\n            currentCapacity = capacity\\n        }else{\\n            steps += 1\\n        }\\n        currentCapacity -= waterNeeded\\n        position = index\\n        stepsResult += steps\\n    }\\n    return stepsResult\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4041271,
                "title": "java-solution-beats-100",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int wateringPlants(int[] plants, int capacity) {\\n        int k=0;\\n        int c=capacity;\\n        for(int i=0;i<plants.length;i++){\\n            if(capacity>=plants[i]){\\n                capacity-=plants[i];\\n                k++;\\n            }\\n            else{\\n                capacity=c;\\n                k+=i;\\n                k=k+i+1;\\n                capacity-=plants[i];\\n            }\\n        }\\n        return k;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int wateringPlants(int[] plants, int capacity) {\\n        int k=0;\\n        int c=capacity;\\n        for(int i=0;i<plants.length;i++){\\n            if(capacity>=plants[i]){\\n                capacity-=plants[i];\\n                k++;\\n            }\\n            else{\\n                capacity=c;\\n                k+=i;\\n                k=k+i+1;\\n                capacity-=plants[i];\\n            }\\n        }\\n        return k;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4039120,
                "title": "runtime-details-0ms-beats-100-00-of-users-with-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int wateringPlants(int[] plants, int capacity) {\\n        int steps=0,currCapacity = capacity;\\n        for(int i=0;i<plants.length ;i++){\\n            steps++;\\n            if(currCapacity<plants[i]){\\n                steps += i*2;\\n                currCapacity = capacity;\\n            }\\n            currCapacity -= plants[i];\\n        }\\n        return steps;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int wateringPlants(int[] plants, int capacity) {\\n        int steps=0,currCapacity = capacity;\\n        for(int i=0;i<plants.length ;i++){\\n            steps++;\\n            if(currCapacity<plants[i]){\\n                steps += i*2;\\n                currCapacity = capacity;\\n            }\\n            currCapacity -= plants[i];\\n        }\\n        return steps;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4038404,
                "title": "simple-java-solution-faster-than-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity : O(plants.length)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int wateringPlants(int[] plants, int capacity) {\\n        int count = 0;\\n        int c = capacity;\\n        int i=0;\\n        while(i<plants.length){\\n            if(capacity>=plants[i]){\\n                count++;\\n                capacity=capacity-plants[i];\\n                i++;\\n            }else{\\n                count=count+(i*2);\\n                capacity=c;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int wateringPlants(int[] plants, int capacity) {\\n        int count = 0;\\n        int c = capacity;\\n        int i=0;\\n        while(i<plants.length){\\n            if(capacity>=plants[i]){\\n                count++;\\n                capacity=capacity-plants[i];\\n                i++;\\n            }else{\\n                count=count+(i*2);\\n                capacity=c;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4032685,
                "title": "video-walkthrough-python-time-o-n-space-o-1",
                "content": "[Click Here For Video Walkthrough](https://youtu.be/gKaIXNxxyFM)\\n```\\nclass Solution:\\n    def wateringPlants(self, plants: List[int], capacity: int) -> int:\\n        steps, cCapacity = 0, capacity\\n        for idx, w in enumerate(plants):\\n            if cCapacity < w:  steps, cCapacity = steps + 2 * idx, capacity\\n            cCapacity, steps = cCapacity - w, steps + 1\\n        return steps\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def wateringPlants(self, plants: List[int], capacity: int) -> int:\\n        steps, cCapacity = 0, capacity\\n        for idx, w in enumerate(plants):\\n            if cCapacity < w:  steps, cCapacity = steps + 2 * idx, capacity\\n            cCapacity, steps = cCapacity - w, steps + 1\\n        return steps\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4001935,
                "title": "simple-o-n-solution",
                "content": "# Intuition\\nTake an origin as -1 as subtract it from the current Idx.\\n# Approach\\nTake an origin as -1 as subtract it from the current Idx. Also subtract from the previous idx if the JUG is sufficient enough.\\n# Complexity\\n- Time complexity:\\nO(n)\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int wateringPlants(vector<int>& plants, int capacity) {\\n        int jug = capacity;\\n        int idx=0;\\n        int totalSteps=0;\\n        int origin =-1;\\n        int prev = origin;\\n        while(idx<plants.size())\\n        {\\n            if (jug >= plants[idx])\\n            {\\n                jug = jug -plants[idx];\\n                totalSteps = totalSteps + idx -prev;\\n                prev = idx;\\n            }\\n            else\\n            {\\n                totalSteps = totalSteps + prev - origin; // go back\\n                totalSteps = totalSteps + idx -origin; // come back\\n                prev =idx;\\n                jug = capacity;\\n                jug = jug -plants[idx];\\n            }\\n            idx++;\\n        }\\n        return totalSteps;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int wateringPlants(vector<int>& plants, int capacity) {\\n        int jug = capacity;\\n        int idx=0;\\n        int totalSteps=0;\\n        int origin =-1;\\n        int prev = origin;\\n        while(idx<plants.size())\\n        {\\n            if (jug >= plants[idx])\\n            {\\n                jug = jug -plants[idx];\\n                totalSteps = totalSteps + idx -prev;\\n                prev = idx;\\n            }\\n            else\\n            {\\n                totalSteps = totalSteps + prev - origin; // go back\\n                totalSteps = totalSteps + idx -origin; // come back\\n                prev =idx;\\n                jug = capacity;\\n                jug = jug -plants[idx];\\n            }\\n            idx++;\\n        }\\n        return totalSteps;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4001182,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int wateringPlants(vector<int>& plants, int capacity) \\n    {\\n        int count= 0,curr_cap = capacity;\\n        for(int i=0;i<plants.size();i++)\\n        {\\n            if(curr_cap < plants[i])\\n            {\\n                count = count+ i+ i+1;\\n                curr_cap = capacity;\\n            }\\n            else\\n                count = count+1;\\n            curr_cap = curr_cap -plants[i];\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int wateringPlants(vector<int>& plants, int capacity) \\n    {\\n        int count= 0,curr_cap = capacity;\\n        for(int i=0;i<plants.size();i++)\\n        {\\n            if(curr_cap < plants[i])\\n            {\\n                count = count+ i+ i+1;\\n                curr_cap = capacity;\\n            }\\n            else\\n                count = count+1;\\n            curr_cap = curr_cap -plants[i];\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4000252,
                "title": "easy-to-understand-c-approach-with-0ms-runtime",
                "content": "\\n# Complexity\\n- Time complexity: O(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int wateringPlants(vector<int>& plants, int capacity) {\\n        int k=capacity;\\n        int steps=0;\\n        for(int i=0;i<plants.size();i++){\\n            if(k>=plants[i]){\\n                k-=plants[i];\\n                steps++;\\n            }else{\\n                steps=steps+(2*i) +1;\\n                k=capacity;\\n                k-=plants[i];\\n            }\\n        }\\n        return steps;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int wateringPlants(vector<int>& plants, int capacity) {\\n        int k=capacity;\\n        int steps=0;\\n        for(int i=0;i<plants.size();i++){\\n            if(k>=plants[i]){\\n                k-=plants[i];\\n                steps++;\\n            }else{\\n                steps=steps+(2*i) +1;\\n                k=capacity;\\n                k-=plants[i];\\n            }\\n        }\\n        return steps;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3999945,
                "title": "very-easy-approach-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int wateringPlants(int[] plants, int capacity) {\\n        int c=0;\\n        int max=capacity;\\n        int i=0;\\n        while(i<plants.length){\\n            if(max>=plants[i]){\\n                c++;\\n                max=max-plants[i];\\n                i++;\\n            }\\n            else{\\n                c=c+i+i;\\n                max=capacity;\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int wateringPlants(int[] plants, int capacity) {\\n        int c=0;\\n        int max=capacity;\\n        int i=0;\\n        while(i<plants.length){\\n            if(max>=plants[i]){\\n                c++;\\n                max=max-plants[i];\\n                i++;\\n            }\\n            else{\\n                c=c+i+i;\\n                max=capacity;\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3998039,
                "title": "java-0ms-simple-code-easy",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int wateringPlants(int[] plants, int capacity) {\\n        int i = 0;\\n        int temp = capacity;\\n        int step = 0;\\n\\n        while(i<plants.length){\\n            if(plants[i]-temp>0){\\n                step+=i+i;\\n                temp=capacity;\\n            }\\n            temp-=plants[i];\\n            step++;\\n            i++;\\n        }\\n        return step;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int wateringPlants(int[] plants, int capacity) {\\n        int i = 0;\\n        int temp = capacity;\\n        int step = 0;\\n\\n        while(i<plants.length){\\n            if(plants[i]-temp>0){\\n                step+=i+i;\\n                temp=capacity;\\n            }\\n            temp-=plants[i];\\n            step++;\\n            i++;\\n        }\\n        return step;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3985186,
                "title": "easy-solution-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int wateringPlants(vector<int>& plants, int capacity) {\\n        int steps=0;\\n        int temp=capacity;\\n        for(int i=0;i<plants.size();i++){\\n            if(temp>=plants[i]){\\n                steps++;\\n            }\\n            else{\\n                temp=capacity;\\n                steps+=2*i+1;\\n            }\\n            temp-=plants[i];\\n        }\\n        return steps;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int wateringPlants(vector<int>& plants, int capacity) {\\n        int steps=0;\\n        int temp=capacity;\\n        for(int i=0;i<plants.size();i++){\\n            if(temp>=plants[i]){\\n                steps++;\\n            }\\n            else{\\n                temp=capacity;\\n                steps+=2*i+1;\\n            }\\n            temp-=plants[i];\\n        }\\n        return steps;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3980498,
                "title": "brute-force-simple-traversal",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust traversing and keeping count of steps moved\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nyou can easily understand by lookling the code\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n O(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n O(1)\\n# Code\\n```\\nclass Solution:\\n    def wateringPlants(self, plants: List[int], capacity: int) -> int:\\n        c=capacity\\n        count=0\\n        for i in range(len(plants)):\\n            if c<plants[i]:\\n                count+=i\\n                c=capacity\\n                count+=(i+1)\\n                c=c-plants[i]\\n            else: \\n                c=c-plants[i]\\n                count+=1\\n        return count                   \\n                    \\n\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def wateringPlants(self, plants: List[int], capacity: int) -> int:\\n        c=capacity\\n        count=0\\n        for i in range(len(plants)):\\n            if c<plants[i]:\\n                count+=i\\n                c=capacity\\n                count+=(i+1)\\n                c=c-plants[i]\\n            else: \\n                c=c-plants[i]\\n                count+=1\\n        return count                   \\n                    \\n\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3976445,
                "title": "python-simple-python-solution",
                "content": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 55 ms, faster than 70.10% of Python3 online submissions for Watering Plants.\\n# Memory Usage: 16.4 MB, less than 64.66% of Python3 online submissions for Watering Plants.\\n\\n\\tclass Solution:\\n\\t\\tdef wateringPlants(self, plants: List[int], capacity: int) -> int:\\n\\n\\t\\t\\tresult = 0\\n\\n\\t\\t\\tcurrent_capacity = capacity\\n\\n\\t\\t\\tindex = 0\\n\\n\\t\\t\\twhile index < len(plants):\\n\\n\\t\\t\\t\\tif plants[index] <= current_capacity:\\n\\t\\t\\t\\t\\tcurrent_capacity = current_capacity - plants[index]\\n\\t\\t\\t\\t\\tresult = result + 1\\n\\t\\t\\t\\t\\tindex = index + 1\\n\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tcurrent_capacity = capacity\\n\\t\\t\\t\\t\\tresult = result + 2 * (index)\\n\\t\\t\\t\\t\\tindex = index\\n\\n\\t\\t\\treturn result\\n\\t\\t\\t\\n\\tTime Complexity : O(n)\\n\\tSpace Complexity : O(1)\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 55 ms, faster than 70.10% of Python3 online submissions for Watering Plants.\\n# Memory Usage: 16.4 MB, less than 64.66% of Python3 online submissions for Watering Plants.\\n\\n\\tclass Solution:\\n\\t\\tdef wateringPlants(self, plants: List[int], capacity: int) -> int:\\n\\n\\t\\t\\tresult = 0\\n\\n\\t\\t\\tcurrent_capacity = capacity\\n\\n\\t\\t\\tindex = 0\\n\\n\\t\\t\\twhile index < len(plants):\\n\\n\\t\\t\\t\\tif plants[index] <= current_capacity:\\n\\t\\t\\t\\t\\tcurrent_capacity = current_capacity - plants[index]\\n\\t\\t\\t\\t\\tresult = result + 1\\n\\t\\t\\t\\t\\tindex = index + 1\\n\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tcurrent_capacity = capacity\\n\\t\\t\\t\\t\\tresult = result + 2 * (index)\\n\\t\\t\\t\\t\\tindex = index\\n\\n\\t\\t\\treturn result\\n\\t\\t\\t\\n\\tTime Complexity : O(n)\\n\\tSpace Complexity : O(1)\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "codeTag": "Java"
            },
            {
                "id": 3969678,
                "title": "c-solve-the-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nthe length of the arrays is the steps default. All I have to count is when getting the water. because you have plus all the default steps, so when go back to the river, no need to +1 to i. then do as you imagine. remember to count your go back, too\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nint wateringPlants(int* plants, int plantsSize, int capacity){\\n    int step=0;\\n    int i;\\n    int water=capacity;\\n    int goback=0;\\n    for(i=0;i<plantsSize;i++) {\\n        while(water<*(plants+i)) {\\n            water=capacity;\\n            step=step+i;\\n            goback=goback+i;\\n            \\n        }\\n        water=water-*(plants+i);\\n        step++;\\n    }\\n    return step+goback;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint wateringPlants(int* plants, int plantsSize, int capacity){\\n    int step=0;\\n    int i;\\n    int water=capacity;\\n    int goback=0;\\n    for(i=0;i<plantsSize;i++) {\\n        while(water<*(plants+i)) {\\n            water=capacity;\\n            step=step+i;\\n            goback=goback+i;\\n            \\n        }\\n        water=water-*(plants+i);\\n        step++;\\n    }\\n    return step+goback;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3959665,
                "title": "easiest-solution-linear-search-cpp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int wateringPlants(vector<int>& plants, int capacity) {\\n        int steps=0,a=capacity;\\n        int n=plants.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(capacity<plants[i])\\n            {\\n                steps=steps+i+i+1;\\n                capacity=a;\\n            }\\n            else{\\n                steps=steps+1;\\n            }\\n            capacity=capacity-plants[i];\\n            \\n        }\\n        return steps;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int wateringPlants(vector<int>& plants, int capacity) {\\n        int steps=0,a=capacity;\\n        int n=plants.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(capacity<plants[i])\\n            {\\n                steps=steps+i+i+1;\\n                capacity=a;\\n            }\\n            else{\\n                steps=steps+1;\\n            }\\n            capacity=capacity-plants[i];\\n            \\n        }\\n        return steps;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3956859,
                "title": "c-time-o-n-space-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n# Code\\n```\\npublic class Solution {\\n    public int WateringPlants(int[] plants, int capacity) {\\n        int curCapacity = capacity;\\n        int lastIdx = -1;\\n        int steps = 0;\\n        int i = 0;\\n\\n        while (i < plants.Length)\\n        {\\n            if (curCapacity >= plants[i])\\n            {\\n                steps += (i - lastIdx);\\n                curCapacity -= plants[i];\\n                lastIdx = i;\\n                i++;\\n            }\\n            else // need refill\\n            {\\n                curCapacity = capacity;\\n                steps += (lastIdx + 1); // walk to river\\n                lastIdx = -1;\\n            }\\n        }\\n\\n        return steps;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int WateringPlants(int[] plants, int capacity) {\\n        int curCapacity = capacity;\\n        int lastIdx = -1;\\n        int steps = 0;\\n        int i = 0;\\n\\n        while (i < plants.Length)\\n        {\\n            if (curCapacity >= plants[i])\\n            {\\n                steps += (i - lastIdx);\\n                curCapacity -= plants[i];\\n                lastIdx = i;\\n                i++;\\n            }\\n            else // need refill\\n            {\\n                curCapacity = capacity;\\n                steps += (lastIdx + 1); // walk to river\\n                lastIdx = -1;\\n            }\\n        }\\n\\n        return steps;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3953344,
                "title": "easy-javascript-solution",
                "content": "\\n```\\n\\nlet distance = 0\\nlet c = capacity\\n\\nfor(var i=0; i<plants.length; i++) {\\n    let steps = i+1    \\n        \\n    if(c >= plants[i]) {\\n        distance += 1\\n    }\\n    else {\\n        c = capacity\\n        distance += (steps*2 - 1)\\n    }\\n        \\n    c = c - plants[i]\\n}\\nreturn distance\\n\\n\\n```\\n\\n## Please upvote if you like the solution.",
                "solutionTags": [
                    "JavaScript",
                    "Array"
                ],
                "code": "```\\n\\nlet distance = 0\\nlet c = capacity\\n\\nfor(var i=0; i<plants.length; i++) {\\n    let steps = i+1    \\n        \\n    if(c >= plants[i]) {\\n        distance += 1\\n    }\\n    else {\\n        c = capacity\\n        distance += (steps*2 - 1)\\n    }\\n        \\n    c = c - plants[i]\\n}\\nreturn distance\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3942165,
                "title": "c-beats-100-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int wateringPlants(vector<int>& plants, int capacity) {\\n        int cur=capacity;\\n        int steps=0,i=0;\\n        while(i!=plants.size())\\n        {\\n            if(cur>=plants[i]){\\n                cur-=plants[i];\\n                steps+=1;\\n                i++;\\n            }\\n            else{\\n                steps+=2*i;\\n                cur=capacity;\\n            }\\n        }\\n        return steps;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int wateringPlants(vector<int>& plants, int capacity) {\\n        int cur=capacity;\\n        int steps=0,i=0;\\n        while(i!=plants.size())\\n        {\\n            if(cur>=plants[i]){\\n                cur-=plants[i];\\n                steps+=1;\\n                i++;\\n            }\\n            else{\\n                steps+=2*i;\\n                cur=capacity;\\n            }\\n        }\\n        return steps;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3941047,
                "title": "easy-to-understand-for-beginners-0ms-runtime",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int wateringPlants(int[] plants, int capacity) {\\n        int cap = capacity;\\n        int counter = 0;\\n        for(int i=0; i<plants.length; i++){\\n            if(plants[i]<=cap){\\n                cap = cap - plants[i];\\n                counter++;\\n            }\\n            else{\\n                cap = capacity;\\n                counter = counter+(2*i+1);\\n                cap = cap - plants[i];\\n            }\\n        }\\n        return counter;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int wateringPlants(int[] plants, int capacity) {\\n        int cap = capacity;\\n        int counter = 0;\\n        for(int i=0; i<plants.length; i++){\\n            if(plants[i]<=cap){\\n                cap = cap - plants[i];\\n                counter++;\\n            }\\n            else{\\n                cap = capacity;\\n                counter = counter+(2*i+1);\\n                cap = cap - plants[i];\\n            }\\n        }\\n        return counter;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3940744,
                "title": "easiiiiiieeeesttt-cheeesiesssst-solution-c-java-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def wateringPlants(self, plants: List[int], capacity: int) -> int:\\n        count=0\\n        som=capacity\\n        i=-1\\n        while(i<len(plants)-1):\\n            if som>=plants[i+1]:\\n                som =som - plants[i+1]\\n                i=i+1\\n                count=count+1\\n            else:\\n                count=count+2*(i+1)\\n                som=capacity\\n        return count\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C"
                ],
                "code": "```\\nclass Solution:\\n    def wateringPlants(self, plants: List[int], capacity: int) -> int:\\n        count=0\\n        som=capacity\\n        i=-1\\n        while(i<len(plants)-1):\\n            if som>=plants[i+1]:\\n                som =som - plants[i+1]\\n                i=i+1\\n                count=count+1\\n            else:\\n                count=count+2*(i+1)\\n                som=capacity\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3937490,
                "title": "java-easy-1-if-condition-check-o-n-time-and-o-1-space",
                "content": "The idea is simple. \\n1. At `ith` plant it is guaranteed that you\\'ll have enough to water the `ith` plant as it is clearly given that `Max(Array) <= capacity.`\\n2. Increment the step by 1 as you just iterated the loop.\\n3. Now staying at the `ith` plant check if there is enough water for the next plant `(i+1)th`. If there is not you would need (i + 1) steps to go to the river and exactly the same number of steps to come back to your current position. (`i`) NOTE: Do not add `+ 1` here to the logic, we\\'re incrementing by 1 every time we iterate over plants.\\n4. Every time you go back to the river initialize your `k` back to capacity. We can\\'t change `capacity` as we need to resize it back, so using a dummy variable `k`.\\n5. Also note that we iterate through `(n - 2)nd` position and not iterate the last element. You need 1 step to add to your `steps` after you\\'re done iterating the loop until the second last element. So return `steps + 1`.\\n\\n\\nTIME O(N) as we iterate over the array exactly once. \\nSPACE O(1) as we just a couple `vars`.\\n\\n ```\\nclass Solution {\\n    public int wateringPlants(int[] plants, int capacity) {\\n        int steps = 0, k = capacity;\\n        for(int i = 0; i < plants.length - 1; i++){\\n            steps += 1;\\n            k -= plants[i];\\n            if(k < plants[i + 1]){\\n                steps = steps + ((i + 1) * 2);\\n                k = capacity;\\n            }\\n        }\\n        return steps + 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int wateringPlants(int[] plants, int capacity) {\\n        int steps = 0, k = capacity;\\n        for(int i = 0; i < plants.length - 1; i++){\\n            steps += 1;\\n            k -= plants[i];\\n            if(k < plants[i + 1]){\\n                steps = steps + ((i + 1) * 2);\\n                k = capacity;\\n            }\\n        }\\n        return steps + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3926040,
                "title": "java-solution-beats-100-0ms",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int wateringPlants(int[] plants, int capacity) {\\n        int cap = capacity;\\n        int steps = 0;\\n        for(int i = 0; i < plants.length; i++) {\\n            if(plants[i] <= cap) {\\n                steps += 1;\\n                cap -= plants[i];\\n            } else {\\n                cap += (capacity - cap);\\n                steps += (2 * i) + 1;\\n                cap -= plants[i];\\n            }\\n        }\\n        return steps;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int wateringPlants(int[] plants, int capacity) {\\n        int cap = capacity;\\n        int steps = 0;\\n        for(int i = 0; i < plants.length; i++) {\\n            if(plants[i] <= cap) {\\n                steps += 1;\\n                cap -= plants[i];\\n            } else {\\n                cap += (capacity - cap);\\n                steps += (2 * i) + 1;\\n                cap -= plants[i];\\n            }\\n        }\\n        return steps;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3925361,
                "title": "python3-simple-simulation",
                "content": "# Code\\n```\\nclass Solution:\\n    def wateringPlants(self, plants: List[int], capacity: int) -> int:\\n        N = len(plants)\\n        cnt = 0\\n        cur = capacity\\n        for i in range(N):\\n            p = plants[i]\\n            if cur >= p:\\n                cur-=p\\n                cnt+=1\\n            else:\\n                cnt+=(i*2)+1\\n                cur = capacity-p\\n        return cnt\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def wateringPlants(self, plants: List[int], capacity: int) -> int:\\n        N = len(plants)\\n        cnt = 0\\n        cur = capacity\\n        for i in range(N):\\n            p = plants[i]\\n            if cur >= p:\\n                cur-=p\\n                cnt+=1\\n            else:\\n                cnt+=(i*2)+1\\n                cur = capacity-p\\n        return cnt\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3923259,
                "title": "best-solution-beats-100-cpp-users-mkbatman",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int wateringPlants(vector<int>& plants, int capacity) {\\n        \\n        int n=plants.size();\\n        int cap=capacity;\\n        int steps=0;\\n\\n        for(int i=0;i<n;i++){\\n            if(plants[i]<=cap){\\n                steps+=1;\\n                cap-=plants[i];\\n            }\\n            else if(plants[i]>cap){\\n                cap=0;\\n                int returncost=i+1;\\n                steps+=returncost;\\n                steps+=i;\\n                cap=capacity;\\n                cap-=plants[i]; \\n            }\\n        }\\n\\n\\n        return steps;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int wateringPlants(vector<int>& plants, int capacity) {\\n        \\n        int n=plants.size();\\n        int cap=capacity;\\n        int steps=0;\\n\\n        for(int i=0;i<n;i++){\\n            if(plants[i]<=cap){\\n                steps+=1;\\n                cap-=plants[i];\\n            }\\n            else if(plants[i]>cap){\\n                cap=0;\\n                int returncost=i+1;\\n                steps+=returncost;\\n                steps+=i;\\n                cap=capacity;\\n                cap-=plants[i]; \\n            }\\n        }\\n\\n\\n        return steps;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565413,
                "content": [
                    {
                        "username": "stevele",
                        "content": "Wrong tag I think. Should be an easy problem"
                    },
                    {
                        "username": "Asmodeus11",
                        "content": "I know it is easy but remember an easy problem can be hard for another especially new leetcoders on the platform.  i can see you are close to 700 problem so ofc this problem would be easy for you.."
                    },
                    {
                        "username": "ILIHAS",
                        "content": "To boost the confidence of the beginners to solve the hard problem it is necessary to have some question to be solve easily."
                    },
                    {
                        "username": "reneilpascua",
                        "content": "YOU CAN REFILL WATER EARLY\\n\\nclarification needed on description.\\nit says you CAN\\'T water early, which can be interpreted to mean \"only fill up when your bucket reaches 0 units of water\"\\nactually, it means \"refill your bucket even if it\\'s not empty IF the next plant requires more water than you currently have\"\\nbig difference."
                    },
                    {
                        "username": "dcollins175",
                        "content": "I believe the reason this is marked as medium is that you need to figure out a bit of mathematics to get O(n) time complexity. Counting each and every step as a brute force approach instead of using arithmetic would get a time complexity of O(n^2). I don't know if that will result in a TLE, but I feel that this problem should require an O(n) time complexity algorithm, with a solution no better than O(n^2) resulting in TLE.\n\nEDIT - I just tested this with the clumsy approach. TLE does not happen which is unfortunate."
                    },
                    {
                        "username": "ap3223",
                        "content": "examples are misleading for newbie"
                    },
                    {
                        "username": "meta_fever",
                        "content": "Solution seems too simple.. just doing what the description says will result in O(n)...\\nWhy is this question tagged as Medium?"
                    },
                    {
                        "username": "user2285TI",
                        "content": "I think simulation should be under Related Topic since it\\'s the most straight forward way to see the problem in my opinion."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "the indexing threw me off quite a bit..."
                    },
                    {
                        "username": "itzRAYY",
                        "content": "    public int wateringPlants(int[] p, int c) {\\n        int n = p.length;\\n        int s = 0;\\n        int cap = c;\\n        for(int i=0;i<n;++i){\\n           if(c<p[i]){\\n              c = cap;\\n              s+=(i+1)+(i);\\n           }else{\\n               ++s;\\n           }\\n           c-=p[i];\\n        }\\n        return s;\\n    }"
                    },
                    {
                        "username": "spectrashohan",
                        "content": "easy problem"
                    },
                    {
                        "username": "onefineday01",
                        "content": "Wrong tag. Should be an easy problem."
                    }
                ]
            },
            {
                "id": 1672470,
                "content": [
                    {
                        "username": "stevele",
                        "content": "Wrong tag I think. Should be an easy problem"
                    },
                    {
                        "username": "Asmodeus11",
                        "content": "I know it is easy but remember an easy problem can be hard for another especially new leetcoders on the platform.  i can see you are close to 700 problem so ofc this problem would be easy for you.."
                    },
                    {
                        "username": "ILIHAS",
                        "content": "To boost the confidence of the beginners to solve the hard problem it is necessary to have some question to be solve easily."
                    },
                    {
                        "username": "reneilpascua",
                        "content": "YOU CAN REFILL WATER EARLY\\n\\nclarification needed on description.\\nit says you CAN\\'T water early, which can be interpreted to mean \"only fill up when your bucket reaches 0 units of water\"\\nactually, it means \"refill your bucket even if it\\'s not empty IF the next plant requires more water than you currently have\"\\nbig difference."
                    },
                    {
                        "username": "dcollins175",
                        "content": "I believe the reason this is marked as medium is that you need to figure out a bit of mathematics to get O(n) time complexity. Counting each and every step as a brute force approach instead of using arithmetic would get a time complexity of O(n^2). I don't know if that will result in a TLE, but I feel that this problem should require an O(n) time complexity algorithm, with a solution no better than O(n^2) resulting in TLE.\n\nEDIT - I just tested this with the clumsy approach. TLE does not happen which is unfortunate."
                    },
                    {
                        "username": "ap3223",
                        "content": "examples are misleading for newbie"
                    },
                    {
                        "username": "meta_fever",
                        "content": "Solution seems too simple.. just doing what the description says will result in O(n)...\\nWhy is this question tagged as Medium?"
                    },
                    {
                        "username": "user2285TI",
                        "content": "I think simulation should be under Related Topic since it\\'s the most straight forward way to see the problem in my opinion."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "the indexing threw me off quite a bit..."
                    },
                    {
                        "username": "itzRAYY",
                        "content": "    public int wateringPlants(int[] p, int c) {\\n        int n = p.length;\\n        int s = 0;\\n        int cap = c;\\n        for(int i=0;i<n;++i){\\n           if(c<p[i]){\\n              c = cap;\\n              s+=(i+1)+(i);\\n           }else{\\n               ++s;\\n           }\\n           c-=p[i];\\n        }\\n        return s;\\n    }"
                    },
                    {
                        "username": "spectrashohan",
                        "content": "easy problem"
                    },
                    {
                        "username": "onefineday01",
                        "content": "Wrong tag. Should be an easy problem."
                    }
                ]
            },
            {
                "id": 1902402,
                "content": [
                    {
                        "username": "stevele",
                        "content": "Wrong tag I think. Should be an easy problem"
                    },
                    {
                        "username": "Asmodeus11",
                        "content": "I know it is easy but remember an easy problem can be hard for another especially new leetcoders on the platform.  i can see you are close to 700 problem so ofc this problem would be easy for you.."
                    },
                    {
                        "username": "ILIHAS",
                        "content": "To boost the confidence of the beginners to solve the hard problem it is necessary to have some question to be solve easily."
                    },
                    {
                        "username": "reneilpascua",
                        "content": "YOU CAN REFILL WATER EARLY\\n\\nclarification needed on description.\\nit says you CAN\\'T water early, which can be interpreted to mean \"only fill up when your bucket reaches 0 units of water\"\\nactually, it means \"refill your bucket even if it\\'s not empty IF the next plant requires more water than you currently have\"\\nbig difference."
                    },
                    {
                        "username": "dcollins175",
                        "content": "I believe the reason this is marked as medium is that you need to figure out a bit of mathematics to get O(n) time complexity. Counting each and every step as a brute force approach instead of using arithmetic would get a time complexity of O(n^2). I don't know if that will result in a TLE, but I feel that this problem should require an O(n) time complexity algorithm, with a solution no better than O(n^2) resulting in TLE.\n\nEDIT - I just tested this with the clumsy approach. TLE does not happen which is unfortunate."
                    },
                    {
                        "username": "ap3223",
                        "content": "examples are misleading for newbie"
                    },
                    {
                        "username": "meta_fever",
                        "content": "Solution seems too simple.. just doing what the description says will result in O(n)...\\nWhy is this question tagged as Medium?"
                    },
                    {
                        "username": "user2285TI",
                        "content": "I think simulation should be under Related Topic since it\\'s the most straight forward way to see the problem in my opinion."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "the indexing threw me off quite a bit..."
                    },
                    {
                        "username": "itzRAYY",
                        "content": "    public int wateringPlants(int[] p, int c) {\\n        int n = p.length;\\n        int s = 0;\\n        int cap = c;\\n        for(int i=0;i<n;++i){\\n           if(c<p[i]){\\n              c = cap;\\n              s+=(i+1)+(i);\\n           }else{\\n               ++s;\\n           }\\n           c-=p[i];\\n        }\\n        return s;\\n    }"
                    },
                    {
                        "username": "spectrashohan",
                        "content": "easy problem"
                    },
                    {
                        "username": "onefineday01",
                        "content": "Wrong tag. Should be an easy problem."
                    }
                ]
            },
            {
                "id": 1744208,
                "content": [
                    {
                        "username": "stevele",
                        "content": "Wrong tag I think. Should be an easy problem"
                    },
                    {
                        "username": "Asmodeus11",
                        "content": "I know it is easy but remember an easy problem can be hard for another especially new leetcoders on the platform.  i can see you are close to 700 problem so ofc this problem would be easy for you.."
                    },
                    {
                        "username": "ILIHAS",
                        "content": "To boost the confidence of the beginners to solve the hard problem it is necessary to have some question to be solve easily."
                    },
                    {
                        "username": "reneilpascua",
                        "content": "YOU CAN REFILL WATER EARLY\\n\\nclarification needed on description.\\nit says you CAN\\'T water early, which can be interpreted to mean \"only fill up when your bucket reaches 0 units of water\"\\nactually, it means \"refill your bucket even if it\\'s not empty IF the next plant requires more water than you currently have\"\\nbig difference."
                    },
                    {
                        "username": "dcollins175",
                        "content": "I believe the reason this is marked as medium is that you need to figure out a bit of mathematics to get O(n) time complexity. Counting each and every step as a brute force approach instead of using arithmetic would get a time complexity of O(n^2). I don't know if that will result in a TLE, but I feel that this problem should require an O(n) time complexity algorithm, with a solution no better than O(n^2) resulting in TLE.\n\nEDIT - I just tested this with the clumsy approach. TLE does not happen which is unfortunate."
                    },
                    {
                        "username": "ap3223",
                        "content": "examples are misleading for newbie"
                    },
                    {
                        "username": "meta_fever",
                        "content": "Solution seems too simple.. just doing what the description says will result in O(n)...\\nWhy is this question tagged as Medium?"
                    },
                    {
                        "username": "user2285TI",
                        "content": "I think simulation should be under Related Topic since it\\'s the most straight forward way to see the problem in my opinion."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "the indexing threw me off quite a bit..."
                    },
                    {
                        "username": "itzRAYY",
                        "content": "    public int wateringPlants(int[] p, int c) {\\n        int n = p.length;\\n        int s = 0;\\n        int cap = c;\\n        for(int i=0;i<n;++i){\\n           if(c<p[i]){\\n              c = cap;\\n              s+=(i+1)+(i);\\n           }else{\\n               ++s;\\n           }\\n           c-=p[i];\\n        }\\n        return s;\\n    }"
                    },
                    {
                        "username": "spectrashohan",
                        "content": "easy problem"
                    },
                    {
                        "username": "onefineday01",
                        "content": "Wrong tag. Should be an easy problem."
                    }
                ]
            },
            {
                "id": 1575990,
                "content": [
                    {
                        "username": "stevele",
                        "content": "Wrong tag I think. Should be an easy problem"
                    },
                    {
                        "username": "Asmodeus11",
                        "content": "I know it is easy but remember an easy problem can be hard for another especially new leetcoders on the platform.  i can see you are close to 700 problem so ofc this problem would be easy for you.."
                    },
                    {
                        "username": "ILIHAS",
                        "content": "To boost the confidence of the beginners to solve the hard problem it is necessary to have some question to be solve easily."
                    },
                    {
                        "username": "reneilpascua",
                        "content": "YOU CAN REFILL WATER EARLY\\n\\nclarification needed on description.\\nit says you CAN\\'T water early, which can be interpreted to mean \"only fill up when your bucket reaches 0 units of water\"\\nactually, it means \"refill your bucket even if it\\'s not empty IF the next plant requires more water than you currently have\"\\nbig difference."
                    },
                    {
                        "username": "dcollins175",
                        "content": "I believe the reason this is marked as medium is that you need to figure out a bit of mathematics to get O(n) time complexity. Counting each and every step as a brute force approach instead of using arithmetic would get a time complexity of O(n^2). I don't know if that will result in a TLE, but I feel that this problem should require an O(n) time complexity algorithm, with a solution no better than O(n^2) resulting in TLE.\n\nEDIT - I just tested this with the clumsy approach. TLE does not happen which is unfortunate."
                    },
                    {
                        "username": "ap3223",
                        "content": "examples are misleading for newbie"
                    },
                    {
                        "username": "meta_fever",
                        "content": "Solution seems too simple.. just doing what the description says will result in O(n)...\\nWhy is this question tagged as Medium?"
                    },
                    {
                        "username": "user2285TI",
                        "content": "I think simulation should be under Related Topic since it\\'s the most straight forward way to see the problem in my opinion."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "the indexing threw me off quite a bit..."
                    },
                    {
                        "username": "itzRAYY",
                        "content": "    public int wateringPlants(int[] p, int c) {\\n        int n = p.length;\\n        int s = 0;\\n        int cap = c;\\n        for(int i=0;i<n;++i){\\n           if(c<p[i]){\\n              c = cap;\\n              s+=(i+1)+(i);\\n           }else{\\n               ++s;\\n           }\\n           c-=p[i];\\n        }\\n        return s;\\n    }"
                    },
                    {
                        "username": "spectrashohan",
                        "content": "easy problem"
                    },
                    {
                        "username": "onefineday01",
                        "content": "Wrong tag. Should be an easy problem."
                    }
                ]
            },
            {
                "id": 2062800,
                "content": [
                    {
                        "username": "stevele",
                        "content": "Wrong tag I think. Should be an easy problem"
                    },
                    {
                        "username": "Asmodeus11",
                        "content": "I know it is easy but remember an easy problem can be hard for another especially new leetcoders on the platform.  i can see you are close to 700 problem so ofc this problem would be easy for you.."
                    },
                    {
                        "username": "ILIHAS",
                        "content": "To boost the confidence of the beginners to solve the hard problem it is necessary to have some question to be solve easily."
                    },
                    {
                        "username": "reneilpascua",
                        "content": "YOU CAN REFILL WATER EARLY\\n\\nclarification needed on description.\\nit says you CAN\\'T water early, which can be interpreted to mean \"only fill up when your bucket reaches 0 units of water\"\\nactually, it means \"refill your bucket even if it\\'s not empty IF the next plant requires more water than you currently have\"\\nbig difference."
                    },
                    {
                        "username": "dcollins175",
                        "content": "I believe the reason this is marked as medium is that you need to figure out a bit of mathematics to get O(n) time complexity. Counting each and every step as a brute force approach instead of using arithmetic would get a time complexity of O(n^2). I don't know if that will result in a TLE, but I feel that this problem should require an O(n) time complexity algorithm, with a solution no better than O(n^2) resulting in TLE.\n\nEDIT - I just tested this with the clumsy approach. TLE does not happen which is unfortunate."
                    },
                    {
                        "username": "ap3223",
                        "content": "examples are misleading for newbie"
                    },
                    {
                        "username": "meta_fever",
                        "content": "Solution seems too simple.. just doing what the description says will result in O(n)...\\nWhy is this question tagged as Medium?"
                    },
                    {
                        "username": "user2285TI",
                        "content": "I think simulation should be under Related Topic since it\\'s the most straight forward way to see the problem in my opinion."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "the indexing threw me off quite a bit..."
                    },
                    {
                        "username": "itzRAYY",
                        "content": "    public int wateringPlants(int[] p, int c) {\\n        int n = p.length;\\n        int s = 0;\\n        int cap = c;\\n        for(int i=0;i<n;++i){\\n           if(c<p[i]){\\n              c = cap;\\n              s+=(i+1)+(i);\\n           }else{\\n               ++s;\\n           }\\n           c-=p[i];\\n        }\\n        return s;\\n    }"
                    },
                    {
                        "username": "spectrashohan",
                        "content": "easy problem"
                    },
                    {
                        "username": "onefineday01",
                        "content": "Wrong tag. Should be an easy problem."
                    }
                ]
            },
            {
                "id": 1982459,
                "content": [
                    {
                        "username": "stevele",
                        "content": "Wrong tag I think. Should be an easy problem"
                    },
                    {
                        "username": "Asmodeus11",
                        "content": "I know it is easy but remember an easy problem can be hard for another especially new leetcoders on the platform.  i can see you are close to 700 problem so ofc this problem would be easy for you.."
                    },
                    {
                        "username": "ILIHAS",
                        "content": "To boost the confidence of the beginners to solve the hard problem it is necessary to have some question to be solve easily."
                    },
                    {
                        "username": "reneilpascua",
                        "content": "YOU CAN REFILL WATER EARLY\\n\\nclarification needed on description.\\nit says you CAN\\'T water early, which can be interpreted to mean \"only fill up when your bucket reaches 0 units of water\"\\nactually, it means \"refill your bucket even if it\\'s not empty IF the next plant requires more water than you currently have\"\\nbig difference."
                    },
                    {
                        "username": "dcollins175",
                        "content": "I believe the reason this is marked as medium is that you need to figure out a bit of mathematics to get O(n) time complexity. Counting each and every step as a brute force approach instead of using arithmetic would get a time complexity of O(n^2). I don't know if that will result in a TLE, but I feel that this problem should require an O(n) time complexity algorithm, with a solution no better than O(n^2) resulting in TLE.\n\nEDIT - I just tested this with the clumsy approach. TLE does not happen which is unfortunate."
                    },
                    {
                        "username": "ap3223",
                        "content": "examples are misleading for newbie"
                    },
                    {
                        "username": "meta_fever",
                        "content": "Solution seems too simple.. just doing what the description says will result in O(n)...\\nWhy is this question tagged as Medium?"
                    },
                    {
                        "username": "user2285TI",
                        "content": "I think simulation should be under Related Topic since it\\'s the most straight forward way to see the problem in my opinion."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "the indexing threw me off quite a bit..."
                    },
                    {
                        "username": "itzRAYY",
                        "content": "    public int wateringPlants(int[] p, int c) {\\n        int n = p.length;\\n        int s = 0;\\n        int cap = c;\\n        for(int i=0;i<n;++i){\\n           if(c<p[i]){\\n              c = cap;\\n              s+=(i+1)+(i);\\n           }else{\\n               ++s;\\n           }\\n           c-=p[i];\\n        }\\n        return s;\\n    }"
                    },
                    {
                        "username": "spectrashohan",
                        "content": "easy problem"
                    },
                    {
                        "username": "onefineday01",
                        "content": "Wrong tag. Should be an easy problem."
                    }
                ]
            },
            {
                "id": 1906434,
                "content": [
                    {
                        "username": "stevele",
                        "content": "Wrong tag I think. Should be an easy problem"
                    },
                    {
                        "username": "Asmodeus11",
                        "content": "I know it is easy but remember an easy problem can be hard for another especially new leetcoders on the platform.  i can see you are close to 700 problem so ofc this problem would be easy for you.."
                    },
                    {
                        "username": "ILIHAS",
                        "content": "To boost the confidence of the beginners to solve the hard problem it is necessary to have some question to be solve easily."
                    },
                    {
                        "username": "reneilpascua",
                        "content": "YOU CAN REFILL WATER EARLY\\n\\nclarification needed on description.\\nit says you CAN\\'T water early, which can be interpreted to mean \"only fill up when your bucket reaches 0 units of water\"\\nactually, it means \"refill your bucket even if it\\'s not empty IF the next plant requires more water than you currently have\"\\nbig difference."
                    },
                    {
                        "username": "dcollins175",
                        "content": "I believe the reason this is marked as medium is that you need to figure out a bit of mathematics to get O(n) time complexity. Counting each and every step as a brute force approach instead of using arithmetic would get a time complexity of O(n^2). I don't know if that will result in a TLE, but I feel that this problem should require an O(n) time complexity algorithm, with a solution no better than O(n^2) resulting in TLE.\n\nEDIT - I just tested this with the clumsy approach. TLE does not happen which is unfortunate."
                    },
                    {
                        "username": "ap3223",
                        "content": "examples are misleading for newbie"
                    },
                    {
                        "username": "meta_fever",
                        "content": "Solution seems too simple.. just doing what the description says will result in O(n)...\\nWhy is this question tagged as Medium?"
                    },
                    {
                        "username": "user2285TI",
                        "content": "I think simulation should be under Related Topic since it\\'s the most straight forward way to see the problem in my opinion."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "the indexing threw me off quite a bit..."
                    },
                    {
                        "username": "itzRAYY",
                        "content": "    public int wateringPlants(int[] p, int c) {\\n        int n = p.length;\\n        int s = 0;\\n        int cap = c;\\n        for(int i=0;i<n;++i){\\n           if(c<p[i]){\\n              c = cap;\\n              s+=(i+1)+(i);\\n           }else{\\n               ++s;\\n           }\\n           c-=p[i];\\n        }\\n        return s;\\n    }"
                    },
                    {
                        "username": "spectrashohan",
                        "content": "easy problem"
                    },
                    {
                        "username": "onefineday01",
                        "content": "Wrong tag. Should be an easy problem."
                    }
                ]
            },
            {
                "id": 1730022,
                "content": [
                    {
                        "username": "stevele",
                        "content": "Wrong tag I think. Should be an easy problem"
                    },
                    {
                        "username": "Asmodeus11",
                        "content": "I know it is easy but remember an easy problem can be hard for another especially new leetcoders on the platform.  i can see you are close to 700 problem so ofc this problem would be easy for you.."
                    },
                    {
                        "username": "ILIHAS",
                        "content": "To boost the confidence of the beginners to solve the hard problem it is necessary to have some question to be solve easily."
                    },
                    {
                        "username": "reneilpascua",
                        "content": "YOU CAN REFILL WATER EARLY\\n\\nclarification needed on description.\\nit says you CAN\\'T water early, which can be interpreted to mean \"only fill up when your bucket reaches 0 units of water\"\\nactually, it means \"refill your bucket even if it\\'s not empty IF the next plant requires more water than you currently have\"\\nbig difference."
                    },
                    {
                        "username": "dcollins175",
                        "content": "I believe the reason this is marked as medium is that you need to figure out a bit of mathematics to get O(n) time complexity. Counting each and every step as a brute force approach instead of using arithmetic would get a time complexity of O(n^2). I don't know if that will result in a TLE, but I feel that this problem should require an O(n) time complexity algorithm, with a solution no better than O(n^2) resulting in TLE.\n\nEDIT - I just tested this with the clumsy approach. TLE does not happen which is unfortunate."
                    },
                    {
                        "username": "ap3223",
                        "content": "examples are misleading for newbie"
                    },
                    {
                        "username": "meta_fever",
                        "content": "Solution seems too simple.. just doing what the description says will result in O(n)...\\nWhy is this question tagged as Medium?"
                    },
                    {
                        "username": "user2285TI",
                        "content": "I think simulation should be under Related Topic since it\\'s the most straight forward way to see the problem in my opinion."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "the indexing threw me off quite a bit..."
                    },
                    {
                        "username": "itzRAYY",
                        "content": "    public int wateringPlants(int[] p, int c) {\\n        int n = p.length;\\n        int s = 0;\\n        int cap = c;\\n        for(int i=0;i<n;++i){\\n           if(c<p[i]){\\n              c = cap;\\n              s+=(i+1)+(i);\\n           }else{\\n               ++s;\\n           }\\n           c-=p[i];\\n        }\\n        return s;\\n    }"
                    },
                    {
                        "username": "spectrashohan",
                        "content": "easy problem"
                    },
                    {
                        "username": "onefineday01",
                        "content": "Wrong tag. Should be an easy problem."
                    }
                ]
            },
            {
                "id": 1716232,
                "content": [
                    {
                        "username": "stevele",
                        "content": "Wrong tag I think. Should be an easy problem"
                    },
                    {
                        "username": "Asmodeus11",
                        "content": "I know it is easy but remember an easy problem can be hard for another especially new leetcoders on the platform.  i can see you are close to 700 problem so ofc this problem would be easy for you.."
                    },
                    {
                        "username": "ILIHAS",
                        "content": "To boost the confidence of the beginners to solve the hard problem it is necessary to have some question to be solve easily."
                    },
                    {
                        "username": "reneilpascua",
                        "content": "YOU CAN REFILL WATER EARLY\\n\\nclarification needed on description.\\nit says you CAN\\'T water early, which can be interpreted to mean \"only fill up when your bucket reaches 0 units of water\"\\nactually, it means \"refill your bucket even if it\\'s not empty IF the next plant requires more water than you currently have\"\\nbig difference."
                    },
                    {
                        "username": "dcollins175",
                        "content": "I believe the reason this is marked as medium is that you need to figure out a bit of mathematics to get O(n) time complexity. Counting each and every step as a brute force approach instead of using arithmetic would get a time complexity of O(n^2). I don't know if that will result in a TLE, but I feel that this problem should require an O(n) time complexity algorithm, with a solution no better than O(n^2) resulting in TLE.\n\nEDIT - I just tested this with the clumsy approach. TLE does not happen which is unfortunate."
                    },
                    {
                        "username": "ap3223",
                        "content": "examples are misleading for newbie"
                    },
                    {
                        "username": "meta_fever",
                        "content": "Solution seems too simple.. just doing what the description says will result in O(n)...\\nWhy is this question tagged as Medium?"
                    },
                    {
                        "username": "user2285TI",
                        "content": "I think simulation should be under Related Topic since it\\'s the most straight forward way to see the problem in my opinion."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "the indexing threw me off quite a bit..."
                    },
                    {
                        "username": "itzRAYY",
                        "content": "    public int wateringPlants(int[] p, int c) {\\n        int n = p.length;\\n        int s = 0;\\n        int cap = c;\\n        for(int i=0;i<n;++i){\\n           if(c<p[i]){\\n              c = cap;\\n              s+=(i+1)+(i);\\n           }else{\\n               ++s;\\n           }\\n           c-=p[i];\\n        }\\n        return s;\\n    }"
                    },
                    {
                        "username": "spectrashohan",
                        "content": "easy problem"
                    },
                    {
                        "username": "onefineday01",
                        "content": "Wrong tag. Should be an easy problem."
                    }
                ]
            },
            {
                "id": 1565413,
                "content": [
                    {
                        "username": "stevele",
                        "content": "Wrong tag I think. Should be an easy problem"
                    },
                    {
                        "username": "Asmodeus11",
                        "content": "I know it is easy but remember an easy problem can be hard for another especially new leetcoders on the platform.  i can see you are close to 700 problem so ofc this problem would be easy for you.."
                    },
                    {
                        "username": "ILIHAS",
                        "content": "To boost the confidence of the beginners to solve the hard problem it is necessary to have some question to be solve easily."
                    },
                    {
                        "username": "reneilpascua",
                        "content": "YOU CAN REFILL WATER EARLY\\n\\nclarification needed on description.\\nit says you CAN\\'T water early, which can be interpreted to mean \"only fill up when your bucket reaches 0 units of water\"\\nactually, it means \"refill your bucket even if it\\'s not empty IF the next plant requires more water than you currently have\"\\nbig difference."
                    },
                    {
                        "username": "dcollins175",
                        "content": "I believe the reason this is marked as medium is that you need to figure out a bit of mathematics to get O(n) time complexity. Counting each and every step as a brute force approach instead of using arithmetic would get a time complexity of O(n^2). I don't know if that will result in a TLE, but I feel that this problem should require an O(n) time complexity algorithm, with a solution no better than O(n^2) resulting in TLE.\n\nEDIT - I just tested this with the clumsy approach. TLE does not happen which is unfortunate."
                    },
                    {
                        "username": "ap3223",
                        "content": "examples are misleading for newbie"
                    },
                    {
                        "username": "meta_fever",
                        "content": "Solution seems too simple.. just doing what the description says will result in O(n)...\\nWhy is this question tagged as Medium?"
                    },
                    {
                        "username": "user2285TI",
                        "content": "I think simulation should be under Related Topic since it\\'s the most straight forward way to see the problem in my opinion."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "the indexing threw me off quite a bit..."
                    },
                    {
                        "username": "itzRAYY",
                        "content": "    public int wateringPlants(int[] p, int c) {\\n        int n = p.length;\\n        int s = 0;\\n        int cap = c;\\n        for(int i=0;i<n;++i){\\n           if(c<p[i]){\\n              c = cap;\\n              s+=(i+1)+(i);\\n           }else{\\n               ++s;\\n           }\\n           c-=p[i];\\n        }\\n        return s;\\n    }"
                    },
                    {
                        "username": "spectrashohan",
                        "content": "easy problem"
                    },
                    {
                        "username": "onefineday01",
                        "content": "Wrong tag. Should be an easy problem."
                    }
                ]
            },
            {
                "id": 1672470,
                "content": [
                    {
                        "username": "stevele",
                        "content": "Wrong tag I think. Should be an easy problem"
                    },
                    {
                        "username": "Asmodeus11",
                        "content": "I know it is easy but remember an easy problem can be hard for another especially new leetcoders on the platform.  i can see you are close to 700 problem so ofc this problem would be easy for you.."
                    },
                    {
                        "username": "ILIHAS",
                        "content": "To boost the confidence of the beginners to solve the hard problem it is necessary to have some question to be solve easily."
                    },
                    {
                        "username": "reneilpascua",
                        "content": "YOU CAN REFILL WATER EARLY\\n\\nclarification needed on description.\\nit says you CAN\\'T water early, which can be interpreted to mean \"only fill up when your bucket reaches 0 units of water\"\\nactually, it means \"refill your bucket even if it\\'s not empty IF the next plant requires more water than you currently have\"\\nbig difference."
                    },
                    {
                        "username": "dcollins175",
                        "content": "I believe the reason this is marked as medium is that you need to figure out a bit of mathematics to get O(n) time complexity. Counting each and every step as a brute force approach instead of using arithmetic would get a time complexity of O(n^2). I don't know if that will result in a TLE, but I feel that this problem should require an O(n) time complexity algorithm, with a solution no better than O(n^2) resulting in TLE.\n\nEDIT - I just tested this with the clumsy approach. TLE does not happen which is unfortunate."
                    },
                    {
                        "username": "ap3223",
                        "content": "examples are misleading for newbie"
                    },
                    {
                        "username": "meta_fever",
                        "content": "Solution seems too simple.. just doing what the description says will result in O(n)...\\nWhy is this question tagged as Medium?"
                    },
                    {
                        "username": "user2285TI",
                        "content": "I think simulation should be under Related Topic since it\\'s the most straight forward way to see the problem in my opinion."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "the indexing threw me off quite a bit..."
                    },
                    {
                        "username": "itzRAYY",
                        "content": "    public int wateringPlants(int[] p, int c) {\\n        int n = p.length;\\n        int s = 0;\\n        int cap = c;\\n        for(int i=0;i<n;++i){\\n           if(c<p[i]){\\n              c = cap;\\n              s+=(i+1)+(i);\\n           }else{\\n               ++s;\\n           }\\n           c-=p[i];\\n        }\\n        return s;\\n    }"
                    },
                    {
                        "username": "spectrashohan",
                        "content": "easy problem"
                    },
                    {
                        "username": "onefineday01",
                        "content": "Wrong tag. Should be an easy problem."
                    }
                ]
            },
            {
                "id": 1902402,
                "content": [
                    {
                        "username": "stevele",
                        "content": "Wrong tag I think. Should be an easy problem"
                    },
                    {
                        "username": "Asmodeus11",
                        "content": "I know it is easy but remember an easy problem can be hard for another especially new leetcoders on the platform.  i can see you are close to 700 problem so ofc this problem would be easy for you.."
                    },
                    {
                        "username": "ILIHAS",
                        "content": "To boost the confidence of the beginners to solve the hard problem it is necessary to have some question to be solve easily."
                    },
                    {
                        "username": "reneilpascua",
                        "content": "YOU CAN REFILL WATER EARLY\\n\\nclarification needed on description.\\nit says you CAN\\'T water early, which can be interpreted to mean \"only fill up when your bucket reaches 0 units of water\"\\nactually, it means \"refill your bucket even if it\\'s not empty IF the next plant requires more water than you currently have\"\\nbig difference."
                    },
                    {
                        "username": "dcollins175",
                        "content": "I believe the reason this is marked as medium is that you need to figure out a bit of mathematics to get O(n) time complexity. Counting each and every step as a brute force approach instead of using arithmetic would get a time complexity of O(n^2). I don't know if that will result in a TLE, but I feel that this problem should require an O(n) time complexity algorithm, with a solution no better than O(n^2) resulting in TLE.\n\nEDIT - I just tested this with the clumsy approach. TLE does not happen which is unfortunate."
                    },
                    {
                        "username": "ap3223",
                        "content": "examples are misleading for newbie"
                    },
                    {
                        "username": "meta_fever",
                        "content": "Solution seems too simple.. just doing what the description says will result in O(n)...\\nWhy is this question tagged as Medium?"
                    },
                    {
                        "username": "user2285TI",
                        "content": "I think simulation should be under Related Topic since it\\'s the most straight forward way to see the problem in my opinion."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "the indexing threw me off quite a bit..."
                    },
                    {
                        "username": "itzRAYY",
                        "content": "    public int wateringPlants(int[] p, int c) {\\n        int n = p.length;\\n        int s = 0;\\n        int cap = c;\\n        for(int i=0;i<n;++i){\\n           if(c<p[i]){\\n              c = cap;\\n              s+=(i+1)+(i);\\n           }else{\\n               ++s;\\n           }\\n           c-=p[i];\\n        }\\n        return s;\\n    }"
                    },
                    {
                        "username": "spectrashohan",
                        "content": "easy problem"
                    },
                    {
                        "username": "onefineday01",
                        "content": "Wrong tag. Should be an easy problem."
                    }
                ]
            },
            {
                "id": 1744208,
                "content": [
                    {
                        "username": "stevele",
                        "content": "Wrong tag I think. Should be an easy problem"
                    },
                    {
                        "username": "Asmodeus11",
                        "content": "I know it is easy but remember an easy problem can be hard for another especially new leetcoders on the platform.  i can see you are close to 700 problem so ofc this problem would be easy for you.."
                    },
                    {
                        "username": "ILIHAS",
                        "content": "To boost the confidence of the beginners to solve the hard problem it is necessary to have some question to be solve easily."
                    },
                    {
                        "username": "reneilpascua",
                        "content": "YOU CAN REFILL WATER EARLY\\n\\nclarification needed on description.\\nit says you CAN\\'T water early, which can be interpreted to mean \"only fill up when your bucket reaches 0 units of water\"\\nactually, it means \"refill your bucket even if it\\'s not empty IF the next plant requires more water than you currently have\"\\nbig difference."
                    },
                    {
                        "username": "dcollins175",
                        "content": "I believe the reason this is marked as medium is that you need to figure out a bit of mathematics to get O(n) time complexity. Counting each and every step as a brute force approach instead of using arithmetic would get a time complexity of O(n^2). I don't know if that will result in a TLE, but I feel that this problem should require an O(n) time complexity algorithm, with a solution no better than O(n^2) resulting in TLE.\n\nEDIT - I just tested this with the clumsy approach. TLE does not happen which is unfortunate."
                    },
                    {
                        "username": "ap3223",
                        "content": "examples are misleading for newbie"
                    },
                    {
                        "username": "meta_fever",
                        "content": "Solution seems too simple.. just doing what the description says will result in O(n)...\\nWhy is this question tagged as Medium?"
                    },
                    {
                        "username": "user2285TI",
                        "content": "I think simulation should be under Related Topic since it\\'s the most straight forward way to see the problem in my opinion."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "the indexing threw me off quite a bit..."
                    },
                    {
                        "username": "itzRAYY",
                        "content": "    public int wateringPlants(int[] p, int c) {\\n        int n = p.length;\\n        int s = 0;\\n        int cap = c;\\n        for(int i=0;i<n;++i){\\n           if(c<p[i]){\\n              c = cap;\\n              s+=(i+1)+(i);\\n           }else{\\n               ++s;\\n           }\\n           c-=p[i];\\n        }\\n        return s;\\n    }"
                    },
                    {
                        "username": "spectrashohan",
                        "content": "easy problem"
                    },
                    {
                        "username": "onefineday01",
                        "content": "Wrong tag. Should be an easy problem."
                    }
                ]
            },
            {
                "id": 1575990,
                "content": [
                    {
                        "username": "stevele",
                        "content": "Wrong tag I think. Should be an easy problem"
                    },
                    {
                        "username": "Asmodeus11",
                        "content": "I know it is easy but remember an easy problem can be hard for another especially new leetcoders on the platform.  i can see you are close to 700 problem so ofc this problem would be easy for you.."
                    },
                    {
                        "username": "ILIHAS",
                        "content": "To boost the confidence of the beginners to solve the hard problem it is necessary to have some question to be solve easily."
                    },
                    {
                        "username": "reneilpascua",
                        "content": "YOU CAN REFILL WATER EARLY\\n\\nclarification needed on description.\\nit says you CAN\\'T water early, which can be interpreted to mean \"only fill up when your bucket reaches 0 units of water\"\\nactually, it means \"refill your bucket even if it\\'s not empty IF the next plant requires more water than you currently have\"\\nbig difference."
                    },
                    {
                        "username": "dcollins175",
                        "content": "I believe the reason this is marked as medium is that you need to figure out a bit of mathematics to get O(n) time complexity. Counting each and every step as a brute force approach instead of using arithmetic would get a time complexity of O(n^2). I don't know if that will result in a TLE, but I feel that this problem should require an O(n) time complexity algorithm, with a solution no better than O(n^2) resulting in TLE.\n\nEDIT - I just tested this with the clumsy approach. TLE does not happen which is unfortunate."
                    },
                    {
                        "username": "ap3223",
                        "content": "examples are misleading for newbie"
                    },
                    {
                        "username": "meta_fever",
                        "content": "Solution seems too simple.. just doing what the description says will result in O(n)...\\nWhy is this question tagged as Medium?"
                    },
                    {
                        "username": "user2285TI",
                        "content": "I think simulation should be under Related Topic since it\\'s the most straight forward way to see the problem in my opinion."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "the indexing threw me off quite a bit..."
                    },
                    {
                        "username": "itzRAYY",
                        "content": "    public int wateringPlants(int[] p, int c) {\\n        int n = p.length;\\n        int s = 0;\\n        int cap = c;\\n        for(int i=0;i<n;++i){\\n           if(c<p[i]){\\n              c = cap;\\n              s+=(i+1)+(i);\\n           }else{\\n               ++s;\\n           }\\n           c-=p[i];\\n        }\\n        return s;\\n    }"
                    },
                    {
                        "username": "spectrashohan",
                        "content": "easy problem"
                    },
                    {
                        "username": "onefineday01",
                        "content": "Wrong tag. Should be an easy problem."
                    }
                ]
            },
            {
                "id": 2062800,
                "content": [
                    {
                        "username": "stevele",
                        "content": "Wrong tag I think. Should be an easy problem"
                    },
                    {
                        "username": "Asmodeus11",
                        "content": "I know it is easy but remember an easy problem can be hard for another especially new leetcoders on the platform.  i can see you are close to 700 problem so ofc this problem would be easy for you.."
                    },
                    {
                        "username": "ILIHAS",
                        "content": "To boost the confidence of the beginners to solve the hard problem it is necessary to have some question to be solve easily."
                    },
                    {
                        "username": "reneilpascua",
                        "content": "YOU CAN REFILL WATER EARLY\\n\\nclarification needed on description.\\nit says you CAN\\'T water early, which can be interpreted to mean \"only fill up when your bucket reaches 0 units of water\"\\nactually, it means \"refill your bucket even if it\\'s not empty IF the next plant requires more water than you currently have\"\\nbig difference."
                    },
                    {
                        "username": "dcollins175",
                        "content": "I believe the reason this is marked as medium is that you need to figure out a bit of mathematics to get O(n) time complexity. Counting each and every step as a brute force approach instead of using arithmetic would get a time complexity of O(n^2). I don't know if that will result in a TLE, but I feel that this problem should require an O(n) time complexity algorithm, with a solution no better than O(n^2) resulting in TLE.\n\nEDIT - I just tested this with the clumsy approach. TLE does not happen which is unfortunate."
                    },
                    {
                        "username": "ap3223",
                        "content": "examples are misleading for newbie"
                    },
                    {
                        "username": "meta_fever",
                        "content": "Solution seems too simple.. just doing what the description says will result in O(n)...\\nWhy is this question tagged as Medium?"
                    },
                    {
                        "username": "user2285TI",
                        "content": "I think simulation should be under Related Topic since it\\'s the most straight forward way to see the problem in my opinion."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "the indexing threw me off quite a bit..."
                    },
                    {
                        "username": "itzRAYY",
                        "content": "    public int wateringPlants(int[] p, int c) {\\n        int n = p.length;\\n        int s = 0;\\n        int cap = c;\\n        for(int i=0;i<n;++i){\\n           if(c<p[i]){\\n              c = cap;\\n              s+=(i+1)+(i);\\n           }else{\\n               ++s;\\n           }\\n           c-=p[i];\\n        }\\n        return s;\\n    }"
                    },
                    {
                        "username": "spectrashohan",
                        "content": "easy problem"
                    },
                    {
                        "username": "onefineday01",
                        "content": "Wrong tag. Should be an easy problem."
                    }
                ]
            },
            {
                "id": 1982459,
                "content": [
                    {
                        "username": "stevele",
                        "content": "Wrong tag I think. Should be an easy problem"
                    },
                    {
                        "username": "Asmodeus11",
                        "content": "I know it is easy but remember an easy problem can be hard for another especially new leetcoders on the platform.  i can see you are close to 700 problem so ofc this problem would be easy for you.."
                    },
                    {
                        "username": "ILIHAS",
                        "content": "To boost the confidence of the beginners to solve the hard problem it is necessary to have some question to be solve easily."
                    },
                    {
                        "username": "reneilpascua",
                        "content": "YOU CAN REFILL WATER EARLY\\n\\nclarification needed on description.\\nit says you CAN\\'T water early, which can be interpreted to mean \"only fill up when your bucket reaches 0 units of water\"\\nactually, it means \"refill your bucket even if it\\'s not empty IF the next plant requires more water than you currently have\"\\nbig difference."
                    },
                    {
                        "username": "dcollins175",
                        "content": "I believe the reason this is marked as medium is that you need to figure out a bit of mathematics to get O(n) time complexity. Counting each and every step as a brute force approach instead of using arithmetic would get a time complexity of O(n^2). I don't know if that will result in a TLE, but I feel that this problem should require an O(n) time complexity algorithm, with a solution no better than O(n^2) resulting in TLE.\n\nEDIT - I just tested this with the clumsy approach. TLE does not happen which is unfortunate."
                    },
                    {
                        "username": "ap3223",
                        "content": "examples are misleading for newbie"
                    },
                    {
                        "username": "meta_fever",
                        "content": "Solution seems too simple.. just doing what the description says will result in O(n)...\\nWhy is this question tagged as Medium?"
                    },
                    {
                        "username": "user2285TI",
                        "content": "I think simulation should be under Related Topic since it\\'s the most straight forward way to see the problem in my opinion."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "the indexing threw me off quite a bit..."
                    },
                    {
                        "username": "itzRAYY",
                        "content": "    public int wateringPlants(int[] p, int c) {\\n        int n = p.length;\\n        int s = 0;\\n        int cap = c;\\n        for(int i=0;i<n;++i){\\n           if(c<p[i]){\\n              c = cap;\\n              s+=(i+1)+(i);\\n           }else{\\n               ++s;\\n           }\\n           c-=p[i];\\n        }\\n        return s;\\n    }"
                    },
                    {
                        "username": "spectrashohan",
                        "content": "easy problem"
                    },
                    {
                        "username": "onefineday01",
                        "content": "Wrong tag. Should be an easy problem."
                    }
                ]
            },
            {
                "id": 1906434,
                "content": [
                    {
                        "username": "stevele",
                        "content": "Wrong tag I think. Should be an easy problem"
                    },
                    {
                        "username": "Asmodeus11",
                        "content": "I know it is easy but remember an easy problem can be hard for another especially new leetcoders on the platform.  i can see you are close to 700 problem so ofc this problem would be easy for you.."
                    },
                    {
                        "username": "ILIHAS",
                        "content": "To boost the confidence of the beginners to solve the hard problem it is necessary to have some question to be solve easily."
                    },
                    {
                        "username": "reneilpascua",
                        "content": "YOU CAN REFILL WATER EARLY\\n\\nclarification needed on description.\\nit says you CAN\\'T water early, which can be interpreted to mean \"only fill up when your bucket reaches 0 units of water\"\\nactually, it means \"refill your bucket even if it\\'s not empty IF the next plant requires more water than you currently have\"\\nbig difference."
                    },
                    {
                        "username": "dcollins175",
                        "content": "I believe the reason this is marked as medium is that you need to figure out a bit of mathematics to get O(n) time complexity. Counting each and every step as a brute force approach instead of using arithmetic would get a time complexity of O(n^2). I don't know if that will result in a TLE, but I feel that this problem should require an O(n) time complexity algorithm, with a solution no better than O(n^2) resulting in TLE.\n\nEDIT - I just tested this with the clumsy approach. TLE does not happen which is unfortunate."
                    },
                    {
                        "username": "ap3223",
                        "content": "examples are misleading for newbie"
                    },
                    {
                        "username": "meta_fever",
                        "content": "Solution seems too simple.. just doing what the description says will result in O(n)...\\nWhy is this question tagged as Medium?"
                    },
                    {
                        "username": "user2285TI",
                        "content": "I think simulation should be under Related Topic since it\\'s the most straight forward way to see the problem in my opinion."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "the indexing threw me off quite a bit..."
                    },
                    {
                        "username": "itzRAYY",
                        "content": "    public int wateringPlants(int[] p, int c) {\\n        int n = p.length;\\n        int s = 0;\\n        int cap = c;\\n        for(int i=0;i<n;++i){\\n           if(c<p[i]){\\n              c = cap;\\n              s+=(i+1)+(i);\\n           }else{\\n               ++s;\\n           }\\n           c-=p[i];\\n        }\\n        return s;\\n    }"
                    },
                    {
                        "username": "spectrashohan",
                        "content": "easy problem"
                    },
                    {
                        "username": "onefineday01",
                        "content": "Wrong tag. Should be an easy problem."
                    }
                ]
            },
            {
                "id": 1730022,
                "content": [
                    {
                        "username": "stevele",
                        "content": "Wrong tag I think. Should be an easy problem"
                    },
                    {
                        "username": "Asmodeus11",
                        "content": "I know it is easy but remember an easy problem can be hard for another especially new leetcoders on the platform.  i can see you are close to 700 problem so ofc this problem would be easy for you.."
                    },
                    {
                        "username": "ILIHAS",
                        "content": "To boost the confidence of the beginners to solve the hard problem it is necessary to have some question to be solve easily."
                    },
                    {
                        "username": "reneilpascua",
                        "content": "YOU CAN REFILL WATER EARLY\\n\\nclarification needed on description.\\nit says you CAN\\'T water early, which can be interpreted to mean \"only fill up when your bucket reaches 0 units of water\"\\nactually, it means \"refill your bucket even if it\\'s not empty IF the next plant requires more water than you currently have\"\\nbig difference."
                    },
                    {
                        "username": "dcollins175",
                        "content": "I believe the reason this is marked as medium is that you need to figure out a bit of mathematics to get O(n) time complexity. Counting each and every step as a brute force approach instead of using arithmetic would get a time complexity of O(n^2). I don't know if that will result in a TLE, but I feel that this problem should require an O(n) time complexity algorithm, with a solution no better than O(n^2) resulting in TLE.\n\nEDIT - I just tested this with the clumsy approach. TLE does not happen which is unfortunate."
                    },
                    {
                        "username": "ap3223",
                        "content": "examples are misleading for newbie"
                    },
                    {
                        "username": "meta_fever",
                        "content": "Solution seems too simple.. just doing what the description says will result in O(n)...\\nWhy is this question tagged as Medium?"
                    },
                    {
                        "username": "user2285TI",
                        "content": "I think simulation should be under Related Topic since it\\'s the most straight forward way to see the problem in my opinion."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "the indexing threw me off quite a bit..."
                    },
                    {
                        "username": "itzRAYY",
                        "content": "    public int wateringPlants(int[] p, int c) {\\n        int n = p.length;\\n        int s = 0;\\n        int cap = c;\\n        for(int i=0;i<n;++i){\\n           if(c<p[i]){\\n              c = cap;\\n              s+=(i+1)+(i);\\n           }else{\\n               ++s;\\n           }\\n           c-=p[i];\\n        }\\n        return s;\\n    }"
                    },
                    {
                        "username": "spectrashohan",
                        "content": "easy problem"
                    },
                    {
                        "username": "onefineday01",
                        "content": "Wrong tag. Should be an easy problem."
                    }
                ]
            },
            {
                "id": 1716232,
                "content": [
                    {
                        "username": "stevele",
                        "content": "Wrong tag I think. Should be an easy problem"
                    },
                    {
                        "username": "Asmodeus11",
                        "content": "I know it is easy but remember an easy problem can be hard for another especially new leetcoders on the platform.  i can see you are close to 700 problem so ofc this problem would be easy for you.."
                    },
                    {
                        "username": "ILIHAS",
                        "content": "To boost the confidence of the beginners to solve the hard problem it is necessary to have some question to be solve easily."
                    },
                    {
                        "username": "reneilpascua",
                        "content": "YOU CAN REFILL WATER EARLY\\n\\nclarification needed on description.\\nit says you CAN\\'T water early, which can be interpreted to mean \"only fill up when your bucket reaches 0 units of water\"\\nactually, it means \"refill your bucket even if it\\'s not empty IF the next plant requires more water than you currently have\"\\nbig difference."
                    },
                    {
                        "username": "dcollins175",
                        "content": "I believe the reason this is marked as medium is that you need to figure out a bit of mathematics to get O(n) time complexity. Counting each and every step as a brute force approach instead of using arithmetic would get a time complexity of O(n^2). I don't know if that will result in a TLE, but I feel that this problem should require an O(n) time complexity algorithm, with a solution no better than O(n^2) resulting in TLE.\n\nEDIT - I just tested this with the clumsy approach. TLE does not happen which is unfortunate."
                    },
                    {
                        "username": "ap3223",
                        "content": "examples are misleading for newbie"
                    },
                    {
                        "username": "meta_fever",
                        "content": "Solution seems too simple.. just doing what the description says will result in O(n)...\\nWhy is this question tagged as Medium?"
                    },
                    {
                        "username": "user2285TI",
                        "content": "I think simulation should be under Related Topic since it\\'s the most straight forward way to see the problem in my opinion."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "the indexing threw me off quite a bit..."
                    },
                    {
                        "username": "itzRAYY",
                        "content": "    public int wateringPlants(int[] p, int c) {\\n        int n = p.length;\\n        int s = 0;\\n        int cap = c;\\n        for(int i=0;i<n;++i){\\n           if(c<p[i]){\\n              c = cap;\\n              s+=(i+1)+(i);\\n           }else{\\n               ++s;\\n           }\\n           c-=p[i];\\n        }\\n        return s;\\n    }"
                    },
                    {
                        "username": "spectrashohan",
                        "content": "easy problem"
                    },
                    {
                        "username": "onefineday01",
                        "content": "Wrong tag. Should be an easy problem."
                    }
                ]
            }
        ]
    },
    {
        "title": "Range Frequency Queries",
        "question_content": "<p>Design a data structure to find the <strong>frequency</strong> of a given value in a given subarray.</p>\n\n<p>The <strong>frequency</strong> of a value in a subarray is the number of occurrences of that value in the subarray.</p>\n\n<p>Implement the <code>RangeFreqQuery</code> class:</p>\n\n<ul>\n\t<li><code>RangeFreqQuery(int[] arr)</code> Constructs an instance of the class with the given <strong>0-indexed</strong> integer array <code>arr</code>.</li>\n\t<li><code>int query(int left, int right, int value)</code> Returns the <strong>frequency</strong> of <code>value</code> in the subarray <code>arr[left...right]</code>.</li>\n</ul>\n\n<p>A <strong>subarray</strong> is a contiguous sequence of elements within an array. <code>arr[left...right]</code> denotes the subarray that contains the elements of <code>nums</code> between indices <code>left</code> and <code>right</code> (<strong>inclusive</strong>).</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;RangeFreqQuery&quot;, &quot;query&quot;, &quot;query&quot;]\n[[[12, 33, 4, 56, 22, 2, 34, 33, 22, 12, 34, 56]], [1, 2, 4], [0, 11, 33]]\n<strong>Output</strong>\n[null, 1, 2]\n\n<strong>Explanation</strong>\nRangeFreqQuery rangeFreqQuery = new RangeFreqQuery([12, 33, 4, 56, 22, 2, 34, 33, 22, 12, 34, 56]);\nrangeFreqQuery.query(1, 2, 4); // return 1. The value 4 occurs 1 time in the subarray [33, 4]\nrangeFreqQuery.query(0, 11, 33); // return 2. The value 33 occurs 2 times in the whole array.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arr.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= arr[i], value &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= left &lt;= right &lt; arr.length</code></li>\n\t<li>At most <code>10<sup>5</sup></code> calls will be made to <code>query</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 1589037,
                "title": "c-simple-solution-w-explanation-binary-search-on-array-of-indices-one-liner",
                "content": "\\u2714\\uFE0F ***Solution (Vector of Index & Binary Search)***\\n\\nWe just need to maintain a vector of indices for each element in the order they occur. \\nThen querying for frequency between a range `[L, R]` is simply finding highest index and lowest index of that element within the given range and returning number of elements between them in the vector of indices.\\nThe highest and lowest index can be found using binary search (upper_bound and lower_bound) in `O(logN)` time.\\n\\n**C++**\\n```cpp\\nclass RangeFreqQuery {\\n    unordered_map<int, vector<int>> mp;\\npublic:\\n    RangeFreqQuery(vector<int>& arr) {\\n        for(int i = 0; i < size(arr); i++) mp[arr[i]].push_back(i);\\n    }\\n    \\n    int query(int L, int R, int V) {\\n        return upper_bound(begin(mp[V]), end(mp[V]), R) - lower_bound(begin(mp[V]), end(mp[V]), L); \\n    }\\n};\\n```\\n\\n***Time Complexity :*** \\n1. `RangeFreqQuery`: `O(N)`, where `N` is the number of elements in `arr`.\\n2. `query`: `O(logN)`\\n\\n***Space Complexity :*** `O(N)`, required for maintaining hashmap",
                "solutionTags": [],
                "code": "```cpp\\nclass RangeFreqQuery {\\n    unordered_map<int, vector<int>> mp;\\npublic:\\n    RangeFreqQuery(vector<int>& arr) {\\n        for(int i = 0; i < size(arr); i++) mp[arr[i]].push_back(i);\\n    }\\n    \\n    int query(int L, int R, int V) {\\n        return upper_bound(begin(mp[V]), end(mp[V]), R) - lower_bound(begin(mp[V]), end(mp[V]), L); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1589040,
                "title": "java-treemap",
                "content": "```\\nclass RangeFreqQuery {\\n    Map<Integer, TreeMap<Integer, Integer>> map = new HashMap<>();\\n    public RangeFreqQuery(int[] arr) {\\n        for(int i = 0; i < arr.length;i++){\\n            map.putIfAbsent(arr[i], new TreeMap<>());\\n            map.get(arr[i]).put(i, map.get(arr[i]).size());\\n        }\\n        \\n    }\\n    \\n    public int query(int left, int right, int value) {\\n        if(!map.containsKey(value)) return 0;\\n        TreeMap<Integer, Integer> nums = map.get(value);\\n        Integer a = nums.ceilingKey(left), b = nums.floorKey(right);\\n        if(a == null || b == null) return 0;\\n        return nums.get(b) - nums.get(a) +1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass RangeFreqQuery {\\n    Map<Integer, TreeMap<Integer, Integer>> map = new HashMap<>();\\n    public RangeFreqQuery(int[] arr) {\\n        for(int i = 0; i < arr.length;i++){\\n            map.putIfAbsent(arr[i], new TreeMap<>());\\n            map.get(arr[i]).put(i, map.get(arr[i]).size());\\n        }\\n        \\n    }\\n    \\n    public int query(int left, int right, int value) {\\n        if(!map.containsKey(value)) return 0;\\n        TreeMap<Integer, Integer> nums = map.get(value);\\n        Integer a = nums.ceilingKey(left), b = nums.floorKey(right);\\n        if(a == null || b == null) return 0;\\n        return nums.get(b) - nums.get(a) +1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1589077,
                "title": "arrays-of-indices",
                "content": "Since the value is limited to 10,000, we can just store positions for each value and then binary-search for the range.\\n\\n> Note: a lot of folks got TLE because they collected frequencies for each number and each position. This allows answering queries in O(1), but populating the array takes O(n * m) time and space.\\n\\n**Java**\\n```java\\nList<Integer>[] ids = new ArrayList[10001];\\nFunction<Integer, Integer> lower_bound = (pos) -> pos < 0 ? ~pos : pos;\\npublic RangeFreqQuery(int[] arr) {\\n    for (int i = 0; i < ids.length; ++i)\\n        ids[i] = new ArrayList<>();\\n    for (int i = 0; i < arr.length; ++i)\\n        ids[arr[i]].add(i);\\n}\\npublic int query(int l, int r, int v) {\\n    return lower_bound.apply(Collections.binarySearch(ids[v], r + 1)) - lower_bound.apply(Collections.binarySearch(ids[v], l));\\n}\\n```\\n\\n**Python 3**\\n```python\\nclass RangeFreqQuery:\\n    def __init__(self, arr: List[int]):\\n        self.l = [[] for _ in range(10001)]\\n        for i, v in enumerate(arr):\\n            self.l[v].append(i)\\n    def query(self, left: int, right: int, v: int) -> int:\\n        return bisect_right(self.l[v], right) - bisect_left(self.l[v], left)\\n```\\n\\n**C++**\\n```cpp\\nvector<int> ids[10001] = {};\\nRangeFreqQuery(vector<int>& arr) {\\n    for (int i = 0; i < arr.size(); ++i)\\n        ids[arr[i]].push_back(i);\\n}\\nint query(int left, int right, int v) {\\n    return upper_bound(begin(ids[v]), end(ids[v]), right) - \\n        lower_bound(begin(ids[v]), end(ids[v]), left);\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "C"
                ],
                "code": "```java\\nList<Integer>[] ids = new ArrayList[10001];\\nFunction<Integer, Integer> lower_bound = (pos) -> pos < 0 ? ~pos : pos;\\npublic RangeFreqQuery(int[] arr) {\\n    for (int i = 0; i < ids.length; ++i)\\n        ids[i] = new ArrayList<>();\\n    for (int i = 0; i < arr.length; ++i)\\n        ids[arr[i]].add(i);\\n}\\npublic int query(int l, int r, int v) {\\n    return lower_bound.apply(Collections.binarySearch(ids[v], r + 1)) - lower_bound.apply(Collections.binarySearch(ids[v], l));\\n}\\n```\n```python\\nclass RangeFreqQuery:\\n    def __init__(self, arr: List[int]):\\n        self.l = [[] for _ in range(10001)]\\n        for i, v in enumerate(arr):\\n            self.l[v].append(i)\\n    def query(self, left: int, right: int, v: int) -> int:\\n        return bisect_right(self.l[v], right) - bisect_left(self.l[v], left)\\n```\n```cpp\\nvector<int> ids[10001] = {};\\nRangeFreqQuery(vector<int>& arr) {\\n    for (int i = 0; i < arr.size(); ++i)\\n        ids[arr[i]].push_back(i);\\n}\\nint query(int left, int right, int v) {\\n    return upper_bound(begin(ids[v]), end(ids[v]), right) - \\n        lower_bound(begin(ids[v]), end(ids[v]), left);\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1589201,
                "title": "python-binary-search",
                "content": "# **Explanation**\\n`init`: Store the index for the same value.\\n`query`: Binary search the `left` and `right` in the stored indices.\\n\\nTime `O(qlogn)`\\nSpace `O(n)`\\n<br>\\n\\n**Python**\\n```py\\n    def __init__(self, A):\\n        self.count = collections.defaultdict(list)\\n        for i, a in enumerate(A):\\n            self.count[a].append(i)\\n\\n    def query(self, left, right, a):\\n        i = bisect.bisect(self.count[a], left - 1)\\n        j = bisect.bisect(self.count[a], right)\\n        return j - i\\n```\\n",
                "solutionTags": [],
                "code": "```py\\n    def __init__(self, A):\\n        self.count = collections.defaultdict(list)\\n        for i, a in enumerate(A):\\n            self.count[a].append(i)\\n\\n    def query(self, left, right, a):\\n        i = bisect.bisect(self.count[a], left - 1)\\n        j = bisect.bisect(self.count[a], right)\\n        return j - i\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1589082,
                "title": "c-brute-to-optimal-binary-search-best-explanation",
                "content": "The **Brute force** solution for this problem would be to check every subarray from left to right , maintain the frequency\\nof each element and then for every query return the frequency.size\\nHowever, the constraints on Number of Query is (Query=10^5) and size of array is also in range of 10^5. So, this would\\ndefinitely give us a TLE.\\n\\n**So, How to think about the optimum solution?**\\n\\nWell, what if we can find the  first occurance of every element  and the **first occurance of its next greater element in the Sorted array**.  Then, (second-first) will be\\nour frequency of the element.Right?\\n```\\n\\tEx-> arr=[12, 33, 4, 56, 22, 2, 34, 33, 22, 12, 34, 56]\\n    Query=[0, 11, 33] -> find occurance of 33 in subarray from 0 to 11\\n```\\n\\n**Approach**\\n```\\n\\tSorted array=[2, 4, 12, 12, 22, 22, 33, 33, 34, 34, 56, 56]\\n    occurance of 33 : index 6\\n    occurance of 34(the next greater element of 33) : index 8\\n    so, freq of 33 is (8-6) = 2\\n```\\n    \\n\\n**How to Code this logic?**\\nWe will use lower_bound and upper_bound for this. *lowerbound basically finds the first index of an element* (here 33 in above example) in sorted array \\nand *upperbound finds the first index of element> that element*(Here, 34 in above example).\\n\\nBelow is the C++ Code\\n```\\nclass RangeFreqQuery {\\nprivate:\\n    int size;\\n    unordered_map< int, vector<int> > mp;\\npublic:\\n    RangeFreqQuery(vector<int>& arr) {\\n        size=arr.size();\\n        for (int i=0; i<size;i++){\\n            mp[arr[i]].push_back(i);\\n        }\\n    }\\n    int query(int left, int right, int value) {\\n        int first = lower_bound(mp[value].begin(),mp[value].end(),left)- mp[value].begin();\\n        int second = upper_bound(mp[value].begin(),mp[value].end(),right)- mp[value].begin();\\n        return second-first;\\n    }\\n};\\n```\\n**Time Complexity** : O(QlogN)\\n**Space Complexity :** O(N)  for maintaining map\\n\\n\\nPlease upvote \\nThank You!",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\n\\tEx-> arr=[12, 33, 4, 56, 22, 2, 34, 33, 22, 12, 34, 56]\\n    Query=[0, 11, 33] -> find occurance of 33 in subarray from 0 to 11\\n```\n```\\n\\tSorted array=[2, 4, 12, 12, 22, 22, 33, 33, 34, 34, 56, 56]\\n    occurance of 33 : index 6\\n    occurance of 34(the next greater element of 33) : index 8\\n    so, freq of 33 is (8-6) = 2\\n```\n```\\nclass RangeFreqQuery {\\nprivate:\\n    int size;\\n    unordered_map< int, vector<int> > mp;\\npublic:\\n    RangeFreqQuery(vector<int>& arr) {\\n        size=arr.size();\\n        for (int i=0; i<size;i++){\\n            mp[arr[i]].push_back(i);\\n        }\\n    }\\n    int query(int left, int right, int value) {\\n        int first = lower_bound(mp[value].begin(),mp[value].end(),left)- mp[value].begin();\\n        int second = upper_bound(mp[value].begin(),mp[value].end(),right)- mp[value].begin();\\n        return second-first;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1589019,
                "title": "java-binary-search-log-n-for-every-query",
                "content": "`\\nQuestion -> How did you get the equation of s=(s+1)(-1); and e=(e+2)(-1);? could you please clarify?\\n\\nCollections.binarySearch return the negative value is no is not found in the list\\n\\n* suppose you are searching 4 in the list 1,2,3,5 it will return -4 ( to find the starting index i will do (-4+1)*-1 which is equal to 3)\\n* and for (e+2)(-1) suppose right is 4 in same list 1,2,3,5 it will return -4 but we have to consider the index of 3 which is 2beacuse if want element smaller then equal to the current index so in this case we have to consider the index of 3 ( so I do (e+2)(-1)).\\n\\nif you understand plz upvote the post\\n\\nclass RangeFreqQuery {\\n\\n    Map<Integer,List<Integer>> map;\\n    public RangeFreqQuery(int[] arr) {\\n        map=new HashMap<>();\\n        for(int i=0;i<arr.length;i++){\\n            if(!map.containsKey(arr[i])) map.put(arr[i],new ArrayList<>());\\n            map.get(arr[i]).add(i);\\n        }\\n    }\\n    \\n    public int query(int left, int right, int value) {\\n        \\n        if(!map.containsKey(value)) return 0;\\n        List<Integer> list=map.get(value);\\n        int s = Collections.binarySearch(list, left);\\n        int e = Collections.binarySearch(list, right);\\n        \\n        if(s<0) s=(s+1)*(-1);\\n        if(e<0) e=(e+2)*(-1);\\n        return e-s+1;\\n    }\\n}`\\n\\nTime Complexity :\\n\\n* RangeFreqQuery: O(N), where N is the number of elements in arr.\\n* query: O(logN)\\n\\nSpace Complexity : \\n* O(N), required for maintaining hashmap",
                "solutionTags": [
                    "Java"
                ],
                "code": "`\\nQuestion -> How did you get the equation of s=(s+1)(-1); and e=(e+2)(-1);? could you please clarify?\\n\\nCollections.binarySearch return the negative value is no is not found in the list\\n\\n* suppose you are searching 4 in the list 1,2,3,5 it will return -4 ( to find the starting index i will do (-4+1)*-1 which is equal to 3)\\n* and for (e+2)(-1) suppose right is 4 in same list 1,2,3,5 it will return -4 but we have to consider the index of 3 which is 2beacuse if want element smaller then equal to the current index so in this case we have to consider the index of 3 ( so I do (e+2)(-1)).\\n\\nif you understand plz upvote the post\\n\\nclass RangeFreqQuery {\\n\\n    Map<Integer,List<Integer>> map;\\n    public RangeFreqQuery(int[] arr) {\\n        map=new HashMap<>();\\n        for(int i=0;i<arr.length;i++){\\n            if(!map.containsKey(arr[i])) map.put(arr[i],new ArrayList<>());\\n            map.get(arr[i]).add(i);\\n        }\\n    }\\n    \\n    public int query(int left, int right, int value) {\\n        \\n        if(!map.containsKey(value)) return 0;\\n        List<Integer> list=map.get(value);\\n        int s = Collections.binarySearch(list, left);\\n        int e = Collections.binarySearch(list, right);\\n        \\n        if(s<0) s=(s+1)*(-1);\\n        if(e<0) e=(e+2)*(-1);\\n        return e-s+1;\\n    }\\n}`\\n\\nTime Complexity :\\n\\n* RangeFreqQuery: O(N), where N is the number of elements in arr.\\n* query: O(logN)\\n\\nSpace Complexity : \\n* O(N), required for maintaining hashmap",
                "codeTag": "Java"
            },
            {
                "id": 1984720,
                "title": "c-segment-tree-solution-with-comments",
                "content": "```\\nclass RangeFreqQuery {\\npublic:\\n    int n;\\n    // Every node is segment tree keeps a hashmap of count of array items for the given range.\\n    unordered_map<int,int> *seg;\\n    RangeFreqQuery(vector<int>& arr) {\\n        n = arr.size(); \\n        seg = new unordered_map<int,int>[4*n]; // Because max nodes or indexes in segment tree can be 4*n [There is a proof for that].\\n        build(0,0,n-1,arr);\\n    }\\n    \\n    void build(int ind,int low,int high,vector<int>& arr){\\n        if(low == high){\\n            seg[ind][arr[low]]++;\\n            return;\\n        }\\n\\n        int mid = (low + high) / 2;\\n        \\n        // Recursively build for left and right subtree.\\n        build(2*ind+1,low,mid,arr);\\n        build(2*ind+2,mid+1,high,arr);\\n        \\n        unordered_map<int,int> map;\\n        \\n        for(auto it = seg[2*ind+1].begin();it!=seg[2*ind+1].end();it++){\\n            map[it->first] += it->second;\\n        }\\n        \\n        for(auto it = seg[2*ind+2].begin();it!=seg[2*ind+2].end();it++){\\n            map[it->first] += it->second;\\n        }\\n        // Merging the right and left subtree solutions.\\n        seg[ind] = map;\\n    }\\n    \\n    \\n    int queryH(int ind, int low, int high, int l, int r, int value){\\n        // No overlap\\n        // [l r] [low high] or [low high] [l r]\\n        if(r < low || high < l){\\n            return 0;\\n        }\\n\\n        // Complete overlap\\n        // [l low high r]\\n\\n        if(l <= low && high <= r){\\n            return seg[ind][value];\\n        }\\n\\n        // Partial overlap\\n        int mid = (low + high) / 2;\\n\\n        // Querying the answer from left and right subtree.\\n        int left = queryH(2*ind+1,low,mid,l,r,value);\\n        int right = queryH(2*ind+2,mid+1,high,l,r,value);\\n        \\n        return left + right;;\\n    }\\n    \\n    \\n    int query(int left, int right, int value) {\\n        return queryH(0,0,n-1,left,right,value);\\n    }\\n};\\n",
                "solutionTags": [
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\nclass RangeFreqQuery {\\npublic:\\n    int n;\\n    // Every node is segment tree keeps a hashmap of count of array items for the given range.\\n    unordered_map<int,int> *seg;\\n    RangeFreqQuery(vector<int>& arr) {\\n        n = arr.size(); \\n        seg = new unordered_map<int,int>[4*n]; // Because max nodes or indexes in segment tree can be 4*n [There is a proof for that].\\n        build(0,0,n-1,arr);\\n    }\\n    \\n    void build(int ind,int low,int high,vector<int>& arr){\\n        if(low == high){\\n            seg[ind][arr[low]]++;\\n            return;\\n        }\\n\\n        int mid = (low + high) / 2;\\n        \\n        // Recursively build for left and right subtree.\\n        build(2*ind+1,low,mid,arr);\\n        build(2*ind+2,mid+1,high,arr);\\n        \\n        unordered_map<int,int> map;\\n        \\n        for(auto it = seg[2*ind+1].begin();it!=seg[2*ind+1].end();it++){\\n            map[it->first] += it->second;\\n        }\\n        \\n        for(auto it = seg[2*ind+2].begin();it!=seg[2*ind+2].end();it++){\\n            map[it->first] += it->second;\\n        }\\n        // Merging the right and left subtree solutions.\\n        seg[ind] = map;\\n    }\\n    \\n    \\n    int queryH(int ind, int low, int high, int l, int r, int value){\\n        // No overlap\\n        // [l r] [low high] or [low high] [l r]\\n        if(r < low || high < l){\\n            return 0;\\n        }\\n\\n        // Complete overlap\\n        // [l low high r]\\n\\n        if(l <= low && high <= r){\\n            return seg[ind][value];\\n        }\\n\\n        // Partial overlap\\n        int mid = (low + high) / 2;\\n\\n        // Querying the answer from left and right subtree.\\n        int left = queryH(2*ind+1,low,mid,l,r,value);\\n        int right = queryH(2*ind+2,mid+1,high,l,r,value);\\n        \\n        return left + right;;\\n    }\\n    \\n    \\n    int query(int left, int right, int value) {\\n        return queryH(0,0,n-1,left,right,value);\\n    }\\n};\\n",
                "codeTag": "Java"
            },
            {
                "id": 1589039,
                "title": "merge-sort-tree-segment-tree",
                "content": "This is called Merge Sort Tree.\\nNot optimal for this problem, but a cool solution I think. \\nIf the problem asked for more types of queries, we can accomplish them without any other preprocess.\\nRead more about this variant of segment tree here:\\nhttps://discuss.codechef.com/t/merge-sort-tree-tutorial/14277\\n```\\nclass RangeFreqQuery {\\npublic:\\n    int N;\\n    vector<int> &A;  // ref to original array\\n    vector<vector<int>> T;  // to store tree information\\n    \\n    void build(int v, int tl, int tr) {  // N log N\\n        if (tl == tr) T[v] = {A[tl]};\\n        else {\\n            int mid = (tl + tr) / 2;\\n            build(v*2, tl, mid);\\n            build(v*2+1, mid+1, tr);\\n            T[v].resize(tr-tl+1);\\n            auto &L = T[v*2], &R = T[v*2+1];\\n            merge(begin(L), end(L), begin(R), end(R), begin(T[v]));\\n        }\\n    }\\n    int query(int L, int R, int x) { return query(x, L, R, 1, 0, N-1); }\\n    int query(int x, int al, int ar, int v, int tl, int tr) {\\n        if (tr < al || ar < tl) return 0;\\n        if (al <= tl && tr <= ar)  { // return the range of indices that are equal to x\\n\\t\\t\\tauto right = upper_bound(begin(T[v]), end(T[v]), x);\\n\\t\\t\\tauto left  = lower_bound(begin(T[v]), end(T[v]), x);\\n\\t\\t\\treturn right - left;\\n\\t\\t}\\n        int mid = (tl + tr) / 2;\\n        int ql = query(x, al, ar, v*2, tl, mid);\\n        int qr = query(x, al, ar, v*2+1, mid+1, tr);\\n        return ql + qr;\\n    }\\n\\n    RangeFreqQuery(vector<int>& arr) : A(arr) {\\n\\t\\tN = arr.size();\\n\\t\\tT.resize(4ul*N);\\n        build(1, 0, N-1);\\n    }\\n\\n};\\nstatic auto _ = []() {\\n    ios::sync_with_stdio(false);\\n    cin.tie(0);\\n    return 0;\\n}();\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass RangeFreqQuery {\\npublic:\\n    int N;\\n    vector<int> &A;  // ref to original array\\n    vector<vector<int>> T;  // to store tree information\\n    \\n    void build(int v, int tl, int tr) {  // N log N\\n        if (tl == tr) T[v] = {A[tl]};\\n        else {\\n            int mid = (tl + tr) / 2;\\n            build(v*2, tl, mid);\\n            build(v*2+1, mid+1, tr);\\n            T[v].resize(tr-tl+1);\\n            auto &L = T[v*2], &R = T[v*2+1];\\n            merge(begin(L), end(L), begin(R), end(R), begin(T[v]));\\n        }\\n    }\\n    int query(int L, int R, int x) { return query(x, L, R, 1, 0, N-1); }\\n    int query(int x, int al, int ar, int v, int tl, int tr) {\\n        if (tr < al || ar < tl) return 0;\\n        if (al <= tl && tr <= ar)  { // return the range of indices that are equal to x\\n\\t\\t\\tauto right = upper_bound(begin(T[v]), end(T[v]), x);\\n\\t\\t\\tauto left  = lower_bound(begin(T[v]), end(T[v]), x);\\n\\t\\t\\treturn right - left;\\n\\t\\t}\\n        int mid = (tl + tr) / 2;\\n        int ql = query(x, al, ar, v*2, tl, mid);\\n        int qr = query(x, al, ar, v*2+1, mid+1, tr);\\n        return ql + qr;\\n    }\\n\\n    RangeFreqQuery(vector<int>& arr) : A(arr) {\\n\\t\\tN = arr.size();\\n\\t\\tT.resize(4ul*N);\\n        build(1, 0, N-1);\\n    }\\n\\n};\\nstatic auto _ = []() {\\n    ios::sync_with_stdio(false);\\n    cin.tie(0);\\n    return 0;\\n}();\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1589024,
                "title": "java-o-nlog-n",
                "content": "This is my first time writing the solution.\\nIf anything wrong please let me know!\\n```\\nclass RangeFreqQuery {\\n    //Use map\\'s key to store arr\\'s value, map\\'s value to keep <value\\'s location, cummulative arr\\'s value count>\\n    HashMap<Integer, TreeMap<Integer, Integer>> map;\\n    public RangeFreqQuery(int[] arr) {\\n        //O(nlog(n))\\n        map = new HashMap<>();\\n        for(int i = 0; i < arr.length; i++){\\n            map.putIfAbsent(arr[i], new TreeMap<>());\\n            TreeMap<Integer, Integer> tree = map.get(arr[i]);\\n            //i = value\\'s location\\n            //tree.size() = cummulative arr\\'s value count - 1\\n            tree.put(i, tree.size());\\n        }\\n    }\\n    \\n    public int query(int left, int right, int value) {\\n        //O(log(n))\\n        \\n        //check if value exist in map\\n        if(!map.containsKey(value)){\\n            return 0;\\n        }\\n        TreeMap<Integer, Integer> tree = map.get(value);\\n        \\n        //check if there exist position >= left and position <= right\\n        //if not, return 0\\n        if(tree.ceilingKey(left) == null || tree.floorKey(right) == null){\\n            return 0;\\n        }\\n        //get leftMost position\\'s cummulative count\\n        int leftMost = tree.get(tree.ceilingKey(left));\\n        //get rightMost position\\'s cummulative count\\n        int rightMost = tree.get(tree.floorKey(right));\\n        \\n        return rightMost - leftMost + 1;\\n    }\\n}\\n\\n/**\\n * Your RangeFreqQuery object will be instantiated and called as such:\\n * RangeFreqQuery obj = new RangeFreqQuery(arr);\\n * int param_1 = obj.query(left,right,value);\\n */\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass RangeFreqQuery {\\n    //Use map\\'s key to store arr\\'s value, map\\'s value to keep <value\\'s location, cummulative arr\\'s value count>\\n    HashMap<Integer, TreeMap<Integer, Integer>> map;\\n    public RangeFreqQuery(int[] arr) {\\n        //O(nlog(n))\\n        map = new HashMap<>();\\n        for(int i = 0; i < arr.length; i++){\\n            map.putIfAbsent(arr[i], new TreeMap<>());\\n            TreeMap<Integer, Integer> tree = map.get(arr[i]);\\n            //i = value\\'s location\\n            //tree.size() = cummulative arr\\'s value count - 1\\n            tree.put(i, tree.size());\\n        }\\n    }\\n    \\n    public int query(int left, int right, int value) {\\n        //O(log(n))\\n        \\n        //check if value exist in map\\n        if(!map.containsKey(value)){\\n            return 0;\\n        }\\n        TreeMap<Integer, Integer> tree = map.get(value);\\n        \\n        //check if there exist position >= left and position <= right\\n        //if not, return 0\\n        if(tree.ceilingKey(left) == null || tree.floorKey(right) == null){\\n            return 0;\\n        }\\n        //get leftMost position\\'s cummulative count\\n        int leftMost = tree.get(tree.ceilingKey(left));\\n        //get rightMost position\\'s cummulative count\\n        int rightMost = tree.get(tree.floorKey(right));\\n        \\n        return rightMost - leftMost + 1;\\n    }\\n}\\n\\n/**\\n * Your RangeFreqQuery object will be instantiated and called as such:\\n * RangeFreqQuery obj = new RangeFreqQuery(arr);\\n * int param_1 = obj.query(left,right,value);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1589188,
                "title": "python3-binary-search",
                "content": "Downvoters, leave a comment! \\n\\nPlease check out this [commit](https://github.com/gaosanyong/leetcode/commit/b5ca73e6f7d317e9f30f7e67a499b0bf489ec019) for the solutions of weekly 268. \\n```\\nclass RangeFreqQuery:\\n\\n    def __init__(self, arr: List[int]):\\n        self.loc = defaultdict(list)\\n        for i, x in enumerate(arr): self.loc[x].append(i)\\n\\n    def query(self, left: int, right: int, value: int) -> int:\\n        if value not in self.loc: return 0 \\n        lo = bisect_left(self.loc[value], left)\\n        hi = bisect_right(self.loc[value], right)\\n        return hi - lo \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass RangeFreqQuery:\\n\\n    def __init__(self, arr: List[int]):\\n        self.loc = defaultdict(list)\\n        for i, x in enumerate(arr): self.loc[x].append(i)\\n\\n    def query(self, left: int, right: int, value: int) -> int:\\n        if value not in self.loc: return 0 \\n        lo = bisect_left(self.loc[value], left)\\n        hi = bisect_right(self.loc[value], right)\\n        return hi - lo \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1589789,
                "title": "python-binary-search-faster-than-100-clean-and-easy-to-understand",
                "content": "```\\nclass RangeFreqQuery(object):\\n    def __init__(self, arr):\\n        self.data = collections.defaultdict(list)\\n        for i, n in enumerate(arr):\\n            self.data[n].append(i)\\n        \\n\\n    def query(self, left, right, value):\\n        return bisect.bisect_right(self.data[value], right) - bisect.bisect_left(self.data[value], left)\\n```\\n**Please UPVOTE!**",
                "solutionTags": [
                    "Python",
                    "Binary Search"
                ],
                "code": "```\\nclass RangeFreqQuery(object):\\n    def __init__(self, arr):\\n        self.data = collections.defaultdict(list)\\n        for i, n in enumerate(arr):\\n            self.data[n].append(i)\\n        \\n\\n    def query(self, left, right, value):\\n        return bisect.bisect_right(self.data[value], right) - bisect.bisect_left(self.data[value], left)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2219145,
                "title": "commented-segment-tree-solution-with-map-c",
                "content": "**I know this might be the slowest solution out there, but I just wanted to try out a segment tree based approach.**\\n```\\nclass RangeFreqQuery {\\npublic:\\n    //define a vector which contains its elements as node and each node contains a map\\n    //that stores the frequency of each element taking as him the root\\n    \\n    \\n    vector<unordered_map<int, int>> segmentTree;\\n    int n;\\n    \\n    vector<int> nums; //create a vector to make the elements global\\n    \\n    RangeFreqQuery(vector<int>& arr) {\\n        n = arr.size();\\n        \\n        segmentTree.resize(4 * n); //segment tree requires at most 4 * n size(check proof: https://www.quora.com/Why-does-4-*-N-space-have-to-be-allocated-for-a-segment-tree-where-N-is-the-size-of-the-original-array)\\n        \\n        \\n        nums = arr;\\n        \\n        build(0, 0, n - 1); //it starts building the segment tree\\n        \\n    }\\n    \\n    int query(int left, int right, int value) {\\n        \\n        return queryUtil(0, 0, n - 1, left, right, value); //it calls the queryUtil function\\n        \\n    }\\n    void build(int ind, int left, int right){\\n        \\n        //Base case -> if it is the leaf node: put it in the map and increase the count\\n        \\n        if(left == right){\\n            segmentTree[ind][nums[left]]++;\\n            return;\\n        }\\n        int mid = left + (right - left)/2;\\n        \\n        build(2 * ind + 1, left, mid); //start building up left subtree\\n        \\n        build(2 * ind + 2, mid + 1, right); //start building up right subtree\\n        \\n        //Now while backtracking -> add all the element valles of left subtree with right subtree \\n        // and store in the map of the current parent node\\n        \\n        for(auto &c : segmentTree[2 * ind + 1]){\\n            segmentTree[ind][c.first] += segmentTree[2 * ind + 1][c.first];\\n\\n        }\\n        for(auto &c : segmentTree[2 * ind + 2]){\\n            segmentTree[ind][c.first] += segmentTree[2 * ind + 2][c.first];\\n        }\\n    }\\n    int queryUtil(int ind, int left, int right, int l, int r, int value){\\n        //If complete overlap\\n        \\n        if(l <= left && r >= right){\\n            return segmentTree[ind][value];\\n        }\\n        //If no overlap\\n        \\n        if(r < left || l > right) return 0;\\n        int mid = left + (right - left)/2;\\n        \\n        //If there is some partial overlap\\n        \\n        return queryUtil(2 * ind + 1, left, mid, l, r, value) + queryUtil(2 * ind + 2, mid + 1, right, l, r, value);\\n    }\\n};\\n\\n/**\\n * Your RangeFreqQuery object will be instantiated and called as such:\\n * RangeFreqQuery* obj = new RangeFreqQuery(arr);\\n * int param_1 = obj->query(left,right,value);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree"
                ],
                "code": "```\\nclass RangeFreqQuery {\\npublic:\\n    //define a vector which contains its elements as node and each node contains a map\\n    //that stores the frequency of each element taking as him the root\\n    \\n    \\n    vector<unordered_map<int, int>> segmentTree;\\n    int n;\\n    \\n    vector<int> nums; //create a vector to make the elements global\\n    \\n    RangeFreqQuery(vector<int>& arr) {\\n        n = arr.size();\\n        \\n        segmentTree.resize(4 * n); //segment tree requires at most 4 * n size(check proof: https://www.quora.com/Why-does-4-*-N-space-have-to-be-allocated-for-a-segment-tree-where-N-is-the-size-of-the-original-array)\\n        \\n        \\n        nums = arr;\\n        \\n        build(0, 0, n - 1); //it starts building the segment tree\\n        \\n    }\\n    \\n    int query(int left, int right, int value) {\\n        \\n        return queryUtil(0, 0, n - 1, left, right, value); //it calls the queryUtil function\\n        \\n    }\\n    void build(int ind, int left, int right){\\n        \\n        //Base case -> if it is the leaf node: put it in the map and increase the count\\n        \\n        if(left == right){\\n            segmentTree[ind][nums[left]]++;\\n            return;\\n        }\\n        int mid = left + (right - left)/2;\\n        \\n        build(2 * ind + 1, left, mid); //start building up left subtree\\n        \\n        build(2 * ind + 2, mid + 1, right); //start building up right subtree\\n        \\n        //Now while backtracking -> add all the element valles of left subtree with right subtree \\n        // and store in the map of the current parent node\\n        \\n        for(auto &c : segmentTree[2 * ind + 1]){\\n            segmentTree[ind][c.first] += segmentTree[2 * ind + 1][c.first];\\n\\n        }\\n        for(auto &c : segmentTree[2 * ind + 2]){\\n            segmentTree[ind][c.first] += segmentTree[2 * ind + 2][c.first];\\n        }\\n    }\\n    int queryUtil(int ind, int left, int right, int l, int r, int value){\\n        //If complete overlap\\n        \\n        if(l <= left && r >= right){\\n            return segmentTree[ind][value];\\n        }\\n        //If no overlap\\n        \\n        if(r < left || l > right) return 0;\\n        int mid = left + (right - left)/2;\\n        \\n        //If there is some partial overlap\\n        \\n        return queryUtil(2 * ind + 1, left, mid, l, r, value) + queryUtil(2 * ind + 2, mid + 1, right, l, r, value);\\n    }\\n};\\n\\n/**\\n * Your RangeFreqQuery object will be instantiated and called as such:\\n * RangeFreqQuery* obj = new RangeFreqQuery(arr);\\n * int param_1 = obj->query(left,right,value);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2015416,
                "title": "java-treemap",
                "content": "```java\\nprivate final Map<Integer, TreeMap<Integer, Integer>> map = new HashMap<>();\\n    public RangeFreqQuery(int[] arr) {\\n        for (int i = 0; i < arr.length; i++) {\\n            map.putIfAbsent(arr[i], new TreeMap<>());\\n            map.get(arr[i]).put(i, map.get(arr[i]).size());\\n        }\\n    }\\n\\n    public int query(int left, int right, int value) {\\n        if (!map.containsKey(value)) return 0;\\n        \\n        Map.Entry<Integer, Integer> floor = map.get(value).floorEntry(right);\\n        Map.Entry<Integer, Integer> ceil = map.get(value).ceilingEntry(left);\\n\\n        return  (floor == null || ceil == null) ? 0 : floor.getValue() - ceil.getValue() + 1;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nprivate final Map<Integer, TreeMap<Integer, Integer>> map = new HashMap<>();\\n    public RangeFreqQuery(int[] arr) {\\n        for (int i = 0; i < arr.length; i++) {\\n            map.putIfAbsent(arr[i], new TreeMap<>());\\n            map.get(arr[i]).put(i, map.get(arr[i]).size());\\n        }\\n    }\\n\\n    public int query(int left, int right, int value) {\\n        if (!map.containsKey(value)) return 0;\\n        \\n        Map.Entry<Integer, Integer> floor = map.get(value).floorEntry(right);\\n        Map.Entry<Integer, Integer> ceil = map.get(value).ceilingEntry(left);\\n\\n        return  (floor == null || ceil == null) ? 0 : floor.getValue() - ceil.getValue() + 1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1592938,
                "title": "intuition-explained-map-binary-search-c-clean-code",
                "content": "**Intuition :**\\n\\n* Idea here is to store index of occurances of element in input array. \\n\\n* This, will help in searching occurances of given value in query, between left and right\\n* To search within range, we can easily find the first index next to left i.e `left <= start`\\n\\t* We can use `lower_bound()` , to find first number greater than or equal to `left`.\\n* Similarly. we can get last index just before right, i.e `end <= right`\\n\\t* We can use `upper_bound()`, to find last number less than or equal to `right`.\\n* Thus, frequency of `value` within range `[left, right]` is difference of indexes .\\n\\t* i.e `frequency = end - start`\\n# Code :\\n\\n```\\nclass RangeFreqQuery {\\n    unordered_map<int, vector<int>> indexes;\\npublic:\\n    RangeFreqQuery(vector<int>& arr) {\\n        \\n        int n = arr.size();\\n        \\n        for(int i=0; i<n; i++) {\\n            indexes[arr[i]].push_back(i);\\n        }\\n    }\\n    \\n    int query(int left, int right, int value) {\\n\\t\\t// Since we get vector by reference, copy of it is not created\\n        // Thus, it is efficient and save us from TLE \\n        vector<int> &index = indexes[value]; \\n        \\n        int start = lower_bound(index.begin(), index.end(), left) - index.begin();\\n        int end = upper_bound(index.begin(), index.end(), right) - index.begin();\\n        \\n        return end - start;\\n    }\\n};\\n```\\n\\n**Complexity :**\\n\\n* Time : \\n\\t* `RangeFreqQuery()` : `O(N)` , \\n\\t\\t* to index into map, we need to traverse complete array\\n\\t* `query()` : `O(log N)`, \\n\\t\\t* binary search to get start and end index\\n\\t\\t* N number of items in array\\n\\n* Space : `O(N)`\\n\\n***If you this helpful, do give it a like :)***",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass RangeFreqQuery {\\n    unordered_map<int, vector<int>> indexes;\\npublic:\\n    RangeFreqQuery(vector<int>& arr) {\\n        \\n        int n = arr.size();\\n        \\n        for(int i=0; i<n; i++) {\\n            indexes[arr[i]].push_back(i);\\n        }\\n    }\\n    \\n    int query(int left, int right, int value) {\\n\\t\\t// Since we get vector by reference, copy of it is not created\\n        // Thus, it is efficient and save us from TLE \\n        vector<int> &index = indexes[value]; \\n        \\n        int start = lower_bound(index.begin(), index.end(), left) - index.begin();\\n        int end = upper_bound(index.begin(), index.end(), right) - index.begin();\\n        \\n        return end - start;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1589052,
                "title": "straightforward-solution-c-better-than-100-memory-and-time",
                "content": "Naive approach : is to traverse from left to right and update count variable whenever we find the element. \\n    But it will TLE !\\n    \\n Efficient approach :  is to use an unordered_map and store the indexes of all the occurences of all the exisiting distinct values in the arr\\n                    so that in queries we can just look out for the indexes between left and right where value was present !!\\n```\\t\\t\\t\\t\\t\\nclass RangeFreqQuery {\\nprivate:\\n    unordered_map<int,vector<int>>mp;\\npublic:\\n    RangeFreqQuery(vector<int>& arr) {\\n        for(int i=0;i<arr.size();i++){\\n            if(mp.count(arr[i])<1){\\n                vector<int>temp;\\n                temp.push_back(i);\\n                mp[arr[i]]=temp;\\n                continue;\\n            }\\n            mp[arr[i]].push_back(i);\\n        }\\n    }\\n    \\n    int query(int left, int right, int value) {\\n        int a = lower_bound(mp[value].begin(),mp[value].end(),left)-mp[value].begin();\\n        int b = upper_bound(mp[value].begin(),mp[value].end(),right)-mp[value].begin();\\n        return b-a;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "Naive approach : is to traverse from left to right and update count variable whenever we find the element. \\n    But it will TLE !\\n    \\n Efficient approach :  is to use an unordered_map and store the indexes of all the occurences of all the exisiting distinct values in the arr\\n                    so that in queries we can just look out for the indexes between left and right where value was present !!\\n```\\t\\t\\t\\t\\t\\nclass RangeFreqQuery {\\nprivate:\\n    unordered_map<int,vector<int>>mp;\\npublic:\\n    RangeFreqQuery(vector<int>& arr) {\\n        for(int i=0;i<arr.size();i++){\\n            if(mp.count(arr[i])<1){\\n                vector<int>temp;\\n                temp.push_back(i);\\n                mp[arr[i]]=temp;\\n                continue;\\n            }\\n            mp[arr[i]].push_back(i);\\n        }\\n    }\\n    \\n    int query(int left, int right, int value) {\\n        int a = lower_bound(mp[value].begin(),mp[value].end(),left)-mp[value].begin();\\n        int b = upper_bound(mp[value].begin(),mp[value].end(),right)-mp[value].begin();\\n        return b-a;\\n    }\\n};",
                "codeTag": "Java"
            },
            {
                "id": 1592208,
                "title": "python-segment-tree",
                "content": "Segment tree solution for Python\\n```\\nclass SegmentTreeNode:\\n    def __init__(self, left, right):\\n        self.leftNode, self.rightNode = None, None\\n        self.left, self.right = left, right\\n        self.val2freq = {}\\n\\nclass RangeFreqQuery:\\n    def __init__(self, arr: List[int]):\\n        self.root = self.buildSegmentTree(arr, 0, len(arr) - 1)\\n\\n    def query(self, left: int, right: int, value: int) -> int:\\n        return self.doQuery(left, right, value, self.root)\\n\\n    def buildSegmentTree(self, arr, left, right):\\n        if left == right:\\n            root = SegmentTreeNode(left, right)\\n            root.val2freq = {arr[left]: 1}\\n            return root\\n\\n        if left > right:\\n            return None\\n\\n        root = SegmentTreeNode(left, right)\\n        mid = (left + right) // 2\\n        root.leftNode = self.buildSegmentTree(arr, left, mid)\\n        root.rightNode = self.buildSegmentTree(arr, mid + 1, right)\\n        root.val2freq = self.merge(root.leftNode, root.rightNode)\\n        return root\\n\\n    def merge(self, leftNode, rightNode):\\n        if leftNode == None:\\n            if rightNode == None:\\n                return {}\\n            else:\\n                return rightNode.val2freq\\n\\n        if rightNode == None:\\n            if leftNode == None:\\n                return {}\\n            else:\\n                return leftNode.val2freq\\n\\n        merged = {}\\n        for key in leftNode.val2freq:\\n            merged[key] = leftNode.val2freq[key]\\n\\n        for key in rightNode.val2freq:\\n            if key in merged:\\n                merged[key] += rightNode.val2freq[key]\\n            else:\\n                merged[key] = rightNode.val2freq[key]\\n\\n        return merged\\n\\n    def doQuery(self, left, right, val, root):\\n        if left <= root.left and right >= root.right:\\n            if val in root.val2freq:\\n                return root.val2freq[val]\\n            else:\\n                return 0\\n\\n        res = 0\\n        mid = (root.left + root.right) // 2\\n        if left <= mid:\\n            res += self.doQuery(left, right, val, root.leftNode)\\n        if right > mid:\\n            res += self.doQuery(left, right, val, root.rightNode)\\n\\n        return res\\n```",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```\\nclass SegmentTreeNode:\\n    def __init__(self, left, right):\\n        self.leftNode, self.rightNode = None, None\\n        self.left, self.right = left, right\\n        self.val2freq = {}\\n\\nclass RangeFreqQuery:\\n    def __init__(self, arr: List[int]):\\n        self.root = self.buildSegmentTree(arr, 0, len(arr) - 1)\\n\\n    def query(self, left: int, right: int, value: int) -> int:\\n        return self.doQuery(left, right, value, self.root)\\n\\n    def buildSegmentTree(self, arr, left, right):\\n        if left == right:\\n            root = SegmentTreeNode(left, right)\\n            root.val2freq = {arr[left]: 1}\\n            return root\\n\\n        if left > right:\\n            return None\\n\\n        root = SegmentTreeNode(left, right)\\n        mid = (left + right) // 2\\n        root.leftNode = self.buildSegmentTree(arr, left, mid)\\n        root.rightNode = self.buildSegmentTree(arr, mid + 1, right)\\n        root.val2freq = self.merge(root.leftNode, root.rightNode)\\n        return root\\n\\n    def merge(self, leftNode, rightNode):\\n        if leftNode == None:\\n            if rightNode == None:\\n                return {}\\n            else:\\n                return rightNode.val2freq\\n\\n        if rightNode == None:\\n            if leftNode == None:\\n                return {}\\n            else:\\n                return leftNode.val2freq\\n\\n        merged = {}\\n        for key in leftNode.val2freq:\\n            merged[key] = leftNode.val2freq[key]\\n\\n        for key in rightNode.val2freq:\\n            if key in merged:\\n                merged[key] += rightNode.val2freq[key]\\n            else:\\n                merged[key] = rightNode.val2freq[key]\\n\\n        return merged\\n\\n    def doQuery(self, left, right, val, root):\\n        if left <= root.left and right >= root.right:\\n            if val in root.val2freq:\\n                return root.val2freq[val]\\n            else:\\n                return 0\\n\\n        res = 0\\n        mid = (root.left + root.right) // 2\\n        if left <= mid:\\n            res += self.doQuery(left, right, val, root.leftNode)\\n        if right > mid:\\n            res += self.doQuery(left, right, val, root.rightNode)\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1590629,
                "title": "c-2080-range-frequency-queries",
                "content": "\\n```\\nclass RangeFreqQuery {\\n    unordered_map<int, vector<int>> loc; \\npublic:\\n    RangeFreqQuery(vector<int>& arr) {\\n        for (int i = 0; i < arr.size(); ++i) loc[arr[i]].push_back(i); \\n    }\\n    \\n    int query(int left, int right, int value) {\\n        auto lo = lower_bound(loc[value].begin(), loc[value].end(), left); \\n        auto hi = upper_bound(loc[value].begin(), loc[value].end(), right); \\n        return hi - lo; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass RangeFreqQuery {\\n    unordered_map<int, vector<int>> loc; \\npublic:\\n    RangeFreqQuery(vector<int>& arr) {\\n        for (int i = 0; i < arr.size(); ++i) loc[arr[i]].push_back(i); \\n    }\\n    \\n    int query(int left, int right, int value) {\\n        auto lo = lower_bound(loc[value].begin(), loc[value].end(), left); \\n        auto hi = upper_bound(loc[value].begin(), loc[value].end(), right); \\n        return hi - lo; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1589224,
                "title": "python3-binary-search-easy-to-understand-beats-100-100",
                "content": "Start by inserting all the numbers in the array into a hashmap along with their index.\\n\\nSince the indexes are inserted in order, one can use binary search to look for the range in which these numbers might occur.\\n\\n```\\nclass RangeFreqQuery:\\n\\n    def __init__(self, arr: List[int]):\\n        self.seen = defaultdict(list)\\n        for i, num in enumerate(arr):\\n            self.seen[num].append(i)\\n        \\n\\n    def query(self, left: int, right: int, value: int) -> int:\\n        if value not in self.seen:\\n            return 0\\n        \\n        nums = self.seen[value]\\n        \\n        if right < nums[0]:\\n            return 0\\n        elif left > nums[-1]:\\n            return 0\\n        \\n        \\n        if len(nums) == 1:\\n            if left <= nums[0] <= right:\\n                return 1\\n            else:\\n                return 0\\n        \\n        l = 0\\n        r = len(nums)-1\\n        \\n        # binary search for left\\n        start = math.inf\\n        while l <= r:\\n            mid = l + (r-l) // 2\\n            \\n            if nums[mid] == left:\\n                start = mid\\n                break\\n            elif nums[mid] < left:\\n                l = mid + 1\\n            else:\\n                start = mid\\n                r = mid - 1\\n        \\n        \\n        l = start\\n        r = len(nums)-1\\n        \\n        # binary search for right\\n        end = math.inf\\n        while l <= r:\\n            mid = l + (r-l) // 2\\n            \\n            if nums[mid] == right:\\n                end = mid\\n                break\\n            elif nums[mid] < right:\\n                end = mid\\n                l = mid + 1\\n            else:\\n                r = mid - 1\\n        \\n        if end == math.inf or start == math.inf:\\n            return 0\\n        \\n        return end - start + 1\\n            \\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass RangeFreqQuery:\\n\\n    def __init__(self, arr: List[int]):\\n        self.seen = defaultdict(list)\\n        for i, num in enumerate(arr):\\n            self.seen[num].append(i)\\n        \\n\\n    def query(self, left: int, right: int, value: int) -> int:\\n        if value not in self.seen:\\n            return 0\\n        \\n        nums = self.seen[value]\\n        \\n        if right < nums[0]:\\n            return 0\\n        elif left > nums[-1]:\\n            return 0\\n        \\n        \\n        if len(nums) == 1:\\n            if left <= nums[0] <= right:\\n                return 1\\n            else:\\n                return 0\\n        \\n        l = 0\\n        r = len(nums)-1\\n        \\n        # binary search for left\\n        start = math.inf\\n        while l <= r:\\n            mid = l + (r-l) // 2\\n            \\n            if nums[mid] == left:\\n                start = mid\\n                break\\n            elif nums[mid] < left:\\n                l = mid + 1\\n            else:\\n                start = mid\\n                r = mid - 1\\n        \\n        \\n        l = start\\n        r = len(nums)-1\\n        \\n        # binary search for right\\n        end = math.inf\\n        while l <= r:\\n            mid = l + (r-l) // 2\\n            \\n            if nums[mid] == right:\\n                end = mid\\n                break\\n            elif nums[mid] < right:\\n                end = mid\\n                l = mid + 1\\n            else:\\n                r = mid - 1\\n        \\n        if end == math.inf or start == math.inf:\\n            return 0\\n        \\n        return end - start + 1\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1589028,
                "title": "c-straightforward-binary-search",
                "content": "\\nSee my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n\\n## Solution 1. Binary Search\\n\\nInitialization: For each unique value in `A`, store its corresponding indices in a map `m`.\\n\\nQuery: \\n* If `value` doesn\\'t exist in the original array, return `0`.\\n* Otherwise, let `v = m[value]` -- the array of all the indices of `value` in the original array  \\n**NOTE: you must use reference here so that you are not copying `m[value]` to `v`, but just aliasing `m[value]` as `v`.**\\n* Binary search the first index `j` that `v[j] > right`.\\n* Binary search the first index `i` that `v[j] >= left`.\\n* The answer is `j - i`.\\n\\n```cpp\\n// OJ: https://leetcode.com/contest/weekly-contest-268/problems/range-frequency-queries/\\n// Author: github.com/lzl124631x\\n// Time:\\n//      RangeFreqQuery: O(N)\\n//      query: O(log(N))\\n// Space: O(N)\\nclass RangeFreqQuery {\\n    unordered_map<int, vector<int>> m; // map from a value to all its indices\\npublic:\\n    RangeFreqQuery(vector<int>& A) {\\n        for (int i = 0; i < A.size(); ++i) m[A[i]].push_back(i);\\n    }\\n    int query(int left, int right, int value) {\\n        if (m.count(value) == 0) return 0; // `value` doesn\\'t exist in the original array\\n        auto &v = m[value]; // `v` is the array of all the indices of `value` in the original array\\n        int j = upper_bound(begin(v), end(v), right) - begin(v); // Find the first index `j` that `v[j] > right`.\\n        int i = lower_bound(begin(v), end(v), left) - begin(v); // Find the first index `i` that `v[i] >= left`.\\n        return j - i; // The answer is `j - i`\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/contest/weekly-contest-268/problems/range-frequency-queries/\\n// Author: github.com/lzl124631x\\n// Time:\\n//      RangeFreqQuery: O(N)\\n//      query: O(log(N))\\n// Space: O(N)\\nclass RangeFreqQuery {\\n    unordered_map<int, vector<int>> m; // map from a value to all its indices\\npublic:\\n    RangeFreqQuery(vector<int>& A) {\\n        for (int i = 0; i < A.size(); ++i) m[A[i]].push_back(i);\\n    }\\n    int query(int left, int right, int value) {\\n        if (m.count(value) == 0) return 0; // `value` doesn\\'t exist in the original array\\n        auto &v = m[value]; // `v` is the array of all the indices of `value` in the original array\\n        int j = upper_bound(begin(v), end(v), right) - begin(v); // Find the first index `j` that `v[j] > right`.\\n        int i = lower_bound(begin(v), end(v), left) - begin(v); // Find the first index `i` that `v[i] >= left`.\\n        return j - i; // The answer is `j - i`\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3334586,
                "title": "c-faster-than-90-hashing-binary-search-clean-code",
                "content": "\\n\\n# Code\\n```\\nclass RangeFreqQuery {\\npublic:\\n\\nunordered_map<int,vector<int>>mpp;\\n    RangeFreqQuery(vector<int>& arr) {\\n\\n        for(int i = 0;i<arr.size();++i)\\n            mpp[arr[i]].push_back(i);\\n        \\n    }\\n    \\n    int query(int left, int right, int value) {\\n        \\n       int l = lower_bound(mpp[value].begin(),mpp[value].end(),left)-mpp[value].begin();\\n       int r = upper_bound(mpp[value].begin(),mpp[value].end(),right)-mpp[value].begin();\\n     \\n       return r-l;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass RangeFreqQuery {\\npublic:\\n\\nunordered_map<int,vector<int>>mpp;\\n    RangeFreqQuery(vector<int>& arr) {\\n\\n        for(int i = 0;i<arr.size();++i)\\n            mpp[arr[i]].push_back(i);\\n        \\n    }\\n    \\n    int query(int left, int right, int value) {\\n        \\n       int l = lower_bound(mpp[value].begin(),mpp[value].end(),left)-mpp[value].begin();\\n       int r = upper_bound(mpp[value].begin(),mpp[value].end(),right)-mpp[value].begin();\\n     \\n       return r-l;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2420869,
                "title": "c-segment-tree-only-read-if-u-know-seg-tree",
                "content": "```\\nclass RangeFreqQuery{\\npublic: \\n    int n;\\n    vector<unordered_map<int,int>> seg;\\n    \\n    void segTree(vector<int>& a)\\n    {\\n        n = a.size();\\n        seg.resize(4*n); \\n        buildTree(a, 0, n-1, 0);\\n    }\\n    \\n    unordered_map<int,int> buildTree(const vector<int>& a, int l, int r, int i)\\n    {\\n        if(l == r)\\n        {\\n            unordered_map<int,int> mp;\\n            mp[a[l]] = 1;\\n            seg[i] = mp;\\n            return mp;\\n        }\\n        \\n        int mid = l+(r-l)/2;\\n        unordered_map<int,int> lmp = buildTree(a, l, mid, 2*i+1);\\n        unordered_map<int,int> rmp = buildTree(a, mid+1, r, 2*i+2);\\n        \\n        for(auto it : lmp)\\n        {\\n            if(rmp.count(it.first)) rmp[it.first]+=it.second;\\n            else rmp[it.first] = it.second;\\n        }\\n        \\n        seg[i] = rmp;\\n        return rmp;\\n    }\\n    \\n    \\n    int segQuery(int ql, int qr, int l, int r, int val, int pos)\\n    {\\n       if(ql > r || qr < l) return 0;\\n       if(ql <= l && qr >= r) return seg[pos][val];\\n         \\n        int mid = l + (r-l)/2;\\n        return segQuery(ql, qr, l, mid, val, 2*pos+1) + segQuery(ql, qr, mid+1, r,val, 2*pos+2); \\n    }\\n    \\n    RangeFreqQuery(vector<int>& arr) {\\n        segTree(arr);\\n    }\\n    \\n    int query(int left, int right, int value) {\\n        return segQuery(left, right, 0, n-1, value, 0);\\n \\n    }\\n};\\n\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass RangeFreqQuery{\\npublic: \\n    int n;\\n    vector<unordered_map<int,int>> seg;\\n    \\n    void segTree(vector<int>& a)\\n    {\\n        n = a.size();\\n        seg.resize(4*n); \\n        buildTree(a, 0, n-1, 0);\\n    }\\n    \\n    unordered_map<int,int> buildTree(const vector<int>& a, int l, int r, int i)\\n    {\\n        if(l == r)\\n        {\\n            unordered_map<int,int> mp;\\n            mp[a[l]] = 1;\\n            seg[i] = mp;\\n            return mp;\\n        }\\n        \\n        int mid = l+(r-l)/2;\\n        unordered_map<int,int> lmp = buildTree(a, l, mid, 2*i+1);\\n        unordered_map<int,int> rmp = buildTree(a, mid+1, r, 2*i+2);\\n        \\n        for(auto it : lmp)\\n        {\\n            if(rmp.count(it.first)) rmp[it.first]+=it.second;\\n            else rmp[it.first] = it.second;\\n        }\\n        \\n        seg[i] = rmp;\\n        return rmp;\\n    }\\n    \\n    \\n    int segQuery(int ql, int qr, int l, int r, int val, int pos)\\n    {\\n       if(ql > r || qr < l) return 0;\\n       if(ql <= l && qr >= r) return seg[pos][val];\\n         \\n        int mid = l + (r-l)/2;\\n        return segQuery(ql, qr, l, mid, val, 2*pos+1) + segQuery(ql, qr, mid+1, r,val, 2*pos+2); \\n    }\\n    \\n    RangeFreqQuery(vector<int>& arr) {\\n        segTree(arr);\\n    }\\n    \\n    int query(int left, int right, int value) {\\n        return segQuery(left, right, 0, n-1, value, 0);\\n \\n    }\\n};\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 3292084,
                "title": "segment-tree-very-easy-to-understand-must-see",
                "content": "# Code\\n```\\nstatic int fast_io = []() \\n{ \\n    std::ios::sync_with_stdio(false); \\n    cin.tie(nullptr); \\n    cout.tie(nullptr); \\n    return 0; \\n}();\\n\\n#ifdef LOCAL\\n    freopen(\"input.txt\", \"r\" , stdin);\\n    freopen(\"output.txt\", \"w\", stdout);\\n#endif\\n\\nclass RangeFreqQuery {\\npublic: \\n    //making the segment tree\\n    int n;\\n    vector<unordered_map<int,int>>tree;\\n    RangeFreqQuery(vector<int>& arr) \\n    {\\n         //taking the size of the arr for the use in the other functions\\n         n = arr.size();\\n\\n         //building the segment tree\\n         tree.resize(4*n);\\n         build(0,0,arr.size()-1,arr);\\n    }\\n    void build(int node,int start,int end,vector<int>&arr)\\n    {\\n        //start and end pointing to the same element in the arr\\n        if(start == end)\\n        {\\n            tree[node][arr[start]]++;\\n            return;\\n        }\\n\\n        int mid = (start+end)/2;\\n        build(2*node+1,start,mid,arr);\\n        build(2*node+2,mid+1,end,arr);\\n        \\n        //making the result from the left \\n        for(auto it = tree[2*node+1].begin() ; it!=tree[2*node+1].end() ; it++)\\n        {\\n            int ele = it->first;\\n            int freq = it->second;\\n            tree[node][ele]+=freq;\\n        }\\n        //making the ans from the right\\n        for(auto it = tree[2*node+2].begin() ; it!=tree[2*node+2].end() ; it++)\\n        {\\n            int ele = it->first;\\n            int freq = it->second;\\n            tree[node][ele]+=freq;\\n        }\\n    }\\n    \\n    int query(int left, int right, int value) \\n    {\\n        return query_(0,0,n-1,left,right,value);    \\n    }\\n    int query_(int node,int start,int end,int &left,int &right,int &value)\\n    {\\n         //if the curr segment is nonoverlapping \\n         if(left > end or start > right)\\n         {\\n             return 0;\\n         }\\n         //if the curr segment is complete/proper segment\\n         if(start>=left and end<=right)\\n         {\\n             return tree[node][value];\\n         }\\n\\n         int mid = (start+end)/2;\\n\\n         int freq1 = query_(2*node+1,start,mid,left,right,value);\\n         int freq2 = query_(2*node+2,mid+1,end,left,right,value);\\n\\n         return freq1+freq2;\\n    }\\n};\\n\\n/**\\n * Your RangeFreqQuery object will be instantiated and called as such:\\n * RangeFreqQuery* obj = new RangeFreqQuery(arr);\\n * int param_1 = obj->query(left,right,value);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Binary Search",
                    "Design",
                    "Segment Tree"
                ],
                "code": "```\\nstatic int fast_io = []() \\n{ \\n    std::ios::sync_with_stdio(false); \\n    cin.tie(nullptr); \\n    cout.tie(nullptr); \\n    return 0; \\n}();\\n\\n#ifdef LOCAL\\n    freopen(\"input.txt\", \"r\" , stdin);\\n    freopen(\"output.txt\", \"w\", stdout);\\n#endif\\n\\nclass RangeFreqQuery {\\npublic: \\n    //making the segment tree\\n    int n;\\n    vector<unordered_map<int,int>>tree;\\n    RangeFreqQuery(vector<int>& arr) \\n    {\\n         //taking the size of the arr for the use in the other functions\\n         n = arr.size();\\n\\n         //building the segment tree\\n         tree.resize(4*n);\\n         build(0,0,arr.size()-1,arr);\\n    }\\n    void build(int node,int start,int end,vector<int>&arr)\\n    {\\n        //start and end pointing to the same element in the arr\\n        if(start == end)\\n        {\\n            tree[node][arr[start]]++;\\n            return;\\n        }\\n\\n        int mid = (start+end)/2;\\n        build(2*node+1,start,mid,arr);\\n        build(2*node+2,mid+1,end,arr);\\n        \\n        //making the result from the left \\n        for(auto it = tree[2*node+1].begin() ; it!=tree[2*node+1].end() ; it++)\\n        {\\n            int ele = it->first;\\n            int freq = it->second;\\n            tree[node][ele]+=freq;\\n        }\\n        //making the ans from the right\\n        for(auto it = tree[2*node+2].begin() ; it!=tree[2*node+2].end() ; it++)\\n        {\\n            int ele = it->first;\\n            int freq = it->second;\\n            tree[node][ele]+=freq;\\n        }\\n    }\\n    \\n    int query(int left, int right, int value) \\n    {\\n        return query_(0,0,n-1,left,right,value);    \\n    }\\n    int query_(int node,int start,int end,int &left,int &right,int &value)\\n    {\\n         //if the curr segment is nonoverlapping \\n         if(left > end or start > right)\\n         {\\n             return 0;\\n         }\\n         //if the curr segment is complete/proper segment\\n         if(start>=left and end<=right)\\n         {\\n             return tree[node][value];\\n         }\\n\\n         int mid = (start+end)/2;\\n\\n         int freq1 = query_(2*node+1,start,mid,left,right,value);\\n         int freq2 = query_(2*node+2,mid+1,end,left,right,value);\\n\\n         return freq1+freq2;\\n    }\\n};\\n\\n/**\\n * Your RangeFreqQuery object will be instantiated and called as such:\\n * RangeFreqQuery* obj = new RangeFreqQuery(arr);\\n * int param_1 = obj->query(left,right,value);\\n */\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3265409,
                "title": "segment-tree-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass RangeFreqQuery { \\n    Map<Integer, Integer>[] st;\\n    int[] a;\\n    int n;\\n\\n    public RangeFreqQuery(int[] arr) {\\n        n = arr.length;\\n        st = new HashMap[n * 4];\\n        a = arr;\\n\\n        build(1, 0, n - 1);\\n    }\\n\\n    void build(int v, int tl, int tr){\\n        if(tl == tr){\\n            Map<Integer, Integer> m = new HashMap<>();\\n            m.put(a[tl], 1);\\n            st[v] = m;\\n            return;\\n        }\\n\\n        int mid = (tl + tr) >> 1;\\n        build(v * 2, tl, mid);\\n        build(v * 2 + 1, mid + 1, tr);\\n        \\n        st[v] = merge(st[v * 2], st[v * 2 + 1]);\\n    }\\n\\n     Map<Integer, Integer> merge(Map<Integer, Integer> a,  Map<Integer, Integer> b){\\n         Map<Integer, Integer> map = new HashMap<>();\\n\\n        for (int i : a.keySet())\\n            map.put(i, map.getOrDefault(i, 0) + a.get(i));\\n\\n        for (int i : b.keySet())\\n            map.put(i, map.getOrDefault(i, 0) + b.get(i));\\n        \\n        return map;\\n    } \\n    \\n    public int query(int left, int right, int value) {\\n        return getQuery(1, 0, n - 1, left, right, value);\\n    }\\n\\n    int getQuery(int v, int tl, int tr, int l, int r, int val){ \\n        if(l > r)\\n            return 0;\\n        if(tl == l && tr == r){\\n            if(st[v].get(val) == null) return 0;\\n            else return st[v].get(val);\\n        }\\n\\n        int mid = (tl + tr) >> 1;\\n        return getQuery(v * 2, tl, mid, l, Math.min(mid, r), val) + getQuery(v * 2 + 1, mid + 1, tr, Math.max(mid + 1, l), r, val);\\n    }\\n}\\n/**\\n * Your RangeFreqQuery object will be instantiated and called as such:\\n * RangeFreqQuery obj = new RangeFreqQuery(arr);\\n * int param_1 = obj.query(left,right,value);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Segment Tree"
                ],
                "code": "```\\nclass RangeFreqQuery { \\n    Map<Integer, Integer>[] st;\\n    int[] a;\\n    int n;\\n\\n    public RangeFreqQuery(int[] arr) {\\n        n = arr.length;\\n        st = new HashMap[n * 4];\\n        a = arr;\\n\\n        build(1, 0, n - 1);\\n    }\\n\\n    void build(int v, int tl, int tr){\\n        if(tl == tr){\\n            Map<Integer, Integer> m = new HashMap<>();\\n            m.put(a[tl], 1);\\n            st[v] = m;\\n            return;\\n        }\\n\\n        int mid = (tl + tr) >> 1;\\n        build(v * 2, tl, mid);\\n        build(v * 2 + 1, mid + 1, tr);\\n        \\n        st[v] = merge(st[v * 2], st[v * 2 + 1]);\\n    }\\n\\n     Map<Integer, Integer> merge(Map<Integer, Integer> a,  Map<Integer, Integer> b){\\n         Map<Integer, Integer> map = new HashMap<>();\\n\\n        for (int i : a.keySet())\\n            map.put(i, map.getOrDefault(i, 0) + a.get(i));\\n\\n        for (int i : b.keySet())\\n            map.put(i, map.getOrDefault(i, 0) + b.get(i));\\n        \\n        return map;\\n    } \\n    \\n    public int query(int left, int right, int value) {\\n        return getQuery(1, 0, n - 1, left, right, value);\\n    }\\n\\n    int getQuery(int v, int tl, int tr, int l, int r, int val){ \\n        if(l > r)\\n            return 0;\\n        if(tl == l && tr == r){\\n            if(st[v].get(val) == null) return 0;\\n            else return st[v].get(val);\\n        }\\n\\n        int mid = (tl + tr) >> 1;\\n        return getQuery(v * 2, tl, mid, l, Math.min(mid, r), val) + getQuery(v * 2 + 1, mid + 1, tr, Math.max(mid + 1, l), r, val);\\n    }\\n}\\n/**\\n * Your RangeFreqQuery object will be instantiated and called as such:\\n * RangeFreqQuery obj = new RangeFreqQuery(arr);\\n * int param_1 = obj.query(left,right,value);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2423524,
                "title": "c-segment-tree-solution",
                "content": "class RangeFreqQuery {\\npublic:\\n\\n    vector<unordered_map<int,int>> tree;\\n    int n=0;\\n    void construct(int i, int l, int r, vector<int>& arr){\\n        if (l > r)  return;\\n    \\n        if(l==r){\\n            tree[i].insert({arr[l], 1});\\n            return;\\n        }\\n        if(l != r){\\n            \\n            int mid = (l + r)/2;\\n\\n            construct(2*i+1, l, mid, arr);\\n            construct(2*i+2, mid+1, r, arr);\\n            // merge child1 and child2 in parent\\n            for (auto itr: tree[2*i+1]){\\n                tree[i][itr.first] += itr.second;\\n            }\\n            for (auto itr: tree[2*i+2]){\\n                tree[i][itr.first] += itr.second;\\n            }\\n        }\\n    }\\n    RangeFreqQuery(vector<int>& arr) {\\n        n = arr.size();\\n        int x = (int)(ceil(log2(n)));\\n        int max_size = 2*(int)pow(2, x) - 1;\\n        tree.resize(max_size);\\n        \\n        construct(0, 0, n-1, arr);\\n    }\\n    int getSum(int si, int sl, int sr, int ql, int qr, int val){\\n        if(sr<ql || qr<sl){ return 0; }\\n        \\n        if(ql<=sl && sr<=qr){\\n            return tree[si].find(val)!=tree[si].end() ? tree[si][val]: 0;\\n        }\\n        \\n        int mid = (sl + sr)/2;\\n        return getSum(2*si+1, sl, mid, ql, qr, val) + getSum(2*si+2, mid+1, sr, ql, qr, val);\\n    }\\n    \\n    int query(int left, int right, int value) {\\n        return getSum(0, 0, n-1, left, right, value);\\n    }\\n};\\n\\n/**\\n * Your RangeFreqQuery object will be instantiated and called as such:\\n * RangeFreqQuery* obj = new RangeFreqQuery(arr);\\n * int param_1 = obj->query(left,right,value);\\n */",
                "solutionTags": [
                    "C",
                    "Tree"
                ],
                "code": "class RangeFreqQuery {\\npublic:\\n\\n    vector<unordered_map<int,int>> tree;\\n    int n=0;\\n    void construct(int i, int l, int r, vector<int>& arr){\\n        if (l > r)  return;\\n    \\n        if(l==r){\\n            tree[i].insert({arr[l], 1});\\n            return;\\n        }\\n        if(l != r){\\n            \\n            int mid = (l + r)/2;\\n\\n            construct(2*i+1, l, mid, arr);\\n            construct(2*i+2, mid+1, r, arr);\\n            // merge child1 and child2 in parent\\n            for (auto itr: tree[2*i+1]){\\n                tree[i][itr.first] += itr.second;\\n            }\\n            for (auto itr: tree[2*i+2]){\\n                tree[i][itr.first] += itr.second;\\n            }\\n        }\\n    }\\n    RangeFreqQuery(vector<int>& arr) {\\n        n = arr.size();\\n        int x = (int)(ceil(log2(n)));\\n        int max_size = 2*(int)pow(2, x) - 1;\\n        tree.resize(max_size);\\n        \\n        construct(0, 0, n-1, arr);\\n    }\\n    int getSum(int si, int sl, int sr, int ql, int qr, int val){\\n        if(sr<ql || qr<sl){ return 0; }\\n        \\n        if(ql<=sl && sr<=qr){\\n            return tree[si].find(val)!=tree[si].end() ? tree[si][val]: 0;\\n        }\\n        \\n        int mid = (sl + sr)/2;\\n        return getSum(2*si+1, sl, mid, ql, qr, val) + getSum(2*si+2, mid+1, sr, ql, qr, val);\\n    }\\n    \\n    int query(int left, int right, int value) {\\n        return getSum(0, 0, n-1, left, right, value);\\n    }\\n};\\n\\n/**\\n * Your RangeFreqQuery object will be instantiated and called as such:\\n * RangeFreqQuery* obj = new RangeFreqQuery(arr);\\n * int param_1 = obj->query(left,right,value);\\n */",
                "codeTag": "Java"
            },
            {
                "id": 1744007,
                "title": "java-hashmap-and-binary-search-without-using-java-s-collection-s-binary-search-api",
                "content": "Store indexes of elements in a HashMap, where key will be \\'Element\\' and value will \\'List of Indexes\\'.\\nFor each Query:\\n* Find if given value exist or not. If it does then, get the list of indexes from the map.\\n* Find upper bound of left index in list that we got from map.\\n* Find lower bound of right index in the list that we got from map.\\n* The bounds found above would represent the start and end positions of the given value.\\n* Return length.\\n\\n```\\nclass RangeFreqQuery {\\n    \\n    HashMap<Integer, ArrayList<Integer>> map;\\n    \\n    public RangeFreqQuery(int[] arr) {\\n        map = new HashMap<>();\\n        for(int i = 0; i < arr.length; i++){\\n            if(!map.containsKey(arr[i])){\\n                map.put(arr[i], new ArrayList<>());\\n            }\\n            map.get(arr[i]).add(i);\\n        }\\n    }\\n    \\n    private int searchUB(ArrayList<Integer> list, int index){\\n        int l = 0;\\n        int r = list.size() - 1;\\n        \\n        int ans = -1;\\n        \\n        while(l <= r){\\n            int mid = (l + r) / 2;\\n            if(list.get(mid) >= index){\\n                if(list.get(mid) == index){\\n                    return mid;\\n                }\\n                \\n                ans = mid;\\n                r = mid - 1;\\n            }else{\\n                l = mid + 1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    private int searchLB(ArrayList<Integer> list, int index){\\n        int l = 0;\\n        int r = list.size() - 1;\\n        \\n        int ans = -1;\\n        \\n        while(l <= r){\\n            int mid = (l + r) / 2;\\n            if(list.get(mid) <= index){\\n                if(list.get(mid) == index){\\n                    return mid;\\n                }\\n                \\n                ans = mid;\\n                l = mid + 1;\\n            }else{\\n                r = mid - 1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    public int query(int left, int right, int value) {\\n        if(!map.containsKey(value)){\\n            return 0;\\n        }else{\\n            \\n            ArrayList<Integer> list = map.get(value);\\n            \\n            int start = searchUB(list, left);\\n            if(start == -1) return 0;\\n            int end = searchLB(list, right);\\n            if(end == -1) return 0;\\n            \\n            return end - start + 1;\\n        }\\n    }\\n}\\n\\n/**\\n * Your RangeFreqQuery object will be instantiated and called as such:\\n * RangeFreqQuery obj = new RangeFreqQuery(arr);\\n * int param_1 = obj.query(left,right,value);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass RangeFreqQuery {\\n    \\n    HashMap<Integer, ArrayList<Integer>> map;\\n    \\n    public RangeFreqQuery(int[] arr) {\\n        map = new HashMap<>();\\n        for(int i = 0; i < arr.length; i++){\\n            if(!map.containsKey(arr[i])){\\n                map.put(arr[i], new ArrayList<>());\\n            }\\n            map.get(arr[i]).add(i);\\n        }\\n    }\\n    \\n    private int searchUB(ArrayList<Integer> list, int index){\\n        int l = 0;\\n        int r = list.size() - 1;\\n        \\n        int ans = -1;\\n        \\n        while(l <= r){\\n            int mid = (l + r) / 2;\\n            if(list.get(mid) >= index){\\n                if(list.get(mid) == index){\\n                    return mid;\\n                }\\n                \\n                ans = mid;\\n                r = mid - 1;\\n            }else{\\n                l = mid + 1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    private int searchLB(ArrayList<Integer> list, int index){\\n        int l = 0;\\n        int r = list.size() - 1;\\n        \\n        int ans = -1;\\n        \\n        while(l <= r){\\n            int mid = (l + r) / 2;\\n            if(list.get(mid) <= index){\\n                if(list.get(mid) == index){\\n                    return mid;\\n                }\\n                \\n                ans = mid;\\n                l = mid + 1;\\n            }else{\\n                r = mid - 1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    public int query(int left, int right, int value) {\\n        if(!map.containsKey(value)){\\n            return 0;\\n        }else{\\n            \\n            ArrayList<Integer> list = map.get(value);\\n            \\n            int start = searchUB(list, left);\\n            if(start == -1) return 0;\\n            int end = searchLB(list, right);\\n            if(end == -1) return 0;\\n            \\n            return end - start + 1;\\n        }\\n    }\\n}\\n\\n/**\\n * Your RangeFreqQuery object will be instantiated and called as such:\\n * RangeFreqQuery obj = new RangeFreqQuery(arr);\\n * int param_1 = obj.query(left,right,value);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1666219,
                "title": "segment-tree-solution",
                "content": "```\\n\\nclass segTree {\\npublic:\\n\\tvector<vector<int>> tree;\\n\\tvector<int> arr;\\n\\tint n;\\n\\tsegTree(vector<int> nums) {\\n\\t\\tthis->n = nums.size();\\n\\t\\ttree.resize(4 * (this->n));\\n\\t\\t// arr.resize(n);\\n\\t\\tarr = nums;\\n\\t\\tbuild(1, 0, n - 1);\\n\\t}\\n\\n\\tvector<int> merge(vector<int> &A, vector<int> &B)  {\\n\\n\\t\\tvector<int> merged(A.size() + B.size());\\n\\t\\tint i = 0, j = 0, k = 0;\\n\\n\\t\\twhile (i < A.size() && j < B.size())  {\\n\\t\\t\\tmerged[k++] = A[i] < B[j] ? A[i++] : B[j++];\\n\\t\\t}\\n\\t\\twhile (i < A.size()) merged[k++] = A[i++];\\n\\t\\twhile (j < B.size()) merged[k++] = B[j++];\\n\\n\\t\\treturn merged;\\n\\n\\t}\\n\\tvoid build(int node, int start, int end) {\\n\\t\\tif (start > end) return;\\n\\n\\t\\tif (start == end) {\\n\\t\\t\\ttree[node] = {arr[start]};\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tint mid = start + (end - start) / 2;\\n\\t\\tbuild(2 * node, start, mid);\\n\\t\\tbuild(2 * node + 1, mid + 1, end);\\n\\t\\ttree[node] = merge(tree[2 * node], tree[2 * node + 1]);\\n\\t}\\n\\tint query(int node, int start, int end, int l, int r, int val) {\\n        // cout << \"here \" << \\'\\\\n\\';\\n\\t\\tif (start > end || start > r || end < l) return 0; // overlap condition\\n        \\n        // complete overlap condition\\n\\t\\tif (start >= l && end <= r) {\\n\\t\\t\\tauto s = lower_bound(tree[node].begin(), tree[node].end(), val);\\n\\t\\t\\tif (s == tree[node].end() || *s != val) return 0;\\n\\t\\t\\tauto e = lower_bound(tree[node].begin(), tree[node].end(), val + 1);\\n\\t\\t\\treturn e - s;\\n\\t\\t}\\n    \\n        // partial overlap condition\\n\\t\\tint mid = start + (end - start) / 2;\\n\\n\\t\\treturn query(2 * node, start, mid, l, r, val) + query(2 * node + 1, mid + 1, end, l, r, val);\\n\\t}\\n\\n\\tint q(int l, int r, int val) {\\n\\t\\treturn query(1, 0, n - 1, l, r, val);\\n\\t}\\n};\\n\\nclass RangeFreqQuery {\\npublic:\\n\\tsegTree* s;\\n\\tRangeFreqQuery(vector<int>& arr) {\\n\\t\\ts = new segTree(arr);\\n\\t}\\n\\n\\tint query(int left, int right, int value) {\\n\\t\\treturn s->q(left, right, value);\\n\\t}\\n};\\n\\n/**\\n * Your RangeFreqQuery object will be instantiated and called as such:\\n * RangeFreqQuery* obj = new RangeFreqQuery(arr);\\n * int param_1 = obj->query(left,right,value);\\n */\\n```",
                "solutionTags": [
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\n\\nclass segTree {\\npublic:\\n\\tvector<vector<int>> tree;\\n\\tvector<int> arr;\\n\\tint n;\\n\\tsegTree(vector<int> nums) {\\n\\t\\tthis->n = nums.size();\\n\\t\\ttree.resize(4 * (this->n));\\n\\t\\t// arr.resize(n);\\n\\t\\tarr = nums;\\n\\t\\tbuild(1, 0, n - 1);\\n\\t}\\n\\n\\tvector<int> merge(vector<int> &A, vector<int> &B)  {\\n\\n\\t\\tvector<int> merged(A.size() + B.size());\\n\\t\\tint i = 0, j = 0, k = 0;\\n\\n\\t\\twhile (i < A.size() && j < B.size())  {\\n\\t\\t\\tmerged[k++] = A[i] < B[j] ? A[i++] : B[j++];\\n\\t\\t}\\n\\t\\twhile (i < A.size()) merged[k++] = A[i++];\\n\\t\\twhile (j < B.size()) merged[k++] = B[j++];\\n\\n\\t\\treturn merged;\\n\\n\\t}\\n\\tvoid build(int node, int start, int end) {\\n\\t\\tif (start > end) return;\\n\\n\\t\\tif (start == end) {\\n\\t\\t\\ttree[node] = {arr[start]};\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tint mid = start + (end - start) / 2;\\n\\t\\tbuild(2 * node, start, mid);\\n\\t\\tbuild(2 * node + 1, mid + 1, end);\\n\\t\\ttree[node] = merge(tree[2 * node], tree[2 * node + 1]);\\n\\t}\\n\\tint query(int node, int start, int end, int l, int r, int val) {\\n        // cout << \"here \" << \\'\\\\n\\';\\n\\t\\tif (start > end || start > r || end < l) return 0; // overlap condition\\n        \\n        // complete overlap condition\\n\\t\\tif (start >= l && end <= r) {\\n\\t\\t\\tauto s = lower_bound(tree[node].begin(), tree[node].end(), val);\\n\\t\\t\\tif (s == tree[node].end() || *s != val) return 0;\\n\\t\\t\\tauto e = lower_bound(tree[node].begin(), tree[node].end(), val + 1);\\n\\t\\t\\treturn e - s;\\n\\t\\t}\\n    \\n        // partial overlap condition\\n\\t\\tint mid = start + (end - start) / 2;\\n\\n\\t\\treturn query(2 * node, start, mid, l, r, val) + query(2 * node + 1, mid + 1, end, l, r, val);\\n\\t}\\n\\n\\tint q(int l, int r, int val) {\\n\\t\\treturn query(1, 0, n - 1, l, r, val);\\n\\t}\\n};\\n\\nclass RangeFreqQuery {\\npublic:\\n\\tsegTree* s;\\n\\tRangeFreqQuery(vector<int>& arr) {\\n\\t\\ts = new segTree(arr);\\n\\t}\\n\\n\\tint query(int left, int right, int value) {\\n\\t\\treturn s->q(left, right, value);\\n\\t}\\n};\\n\\n/**\\n * Your RangeFreqQuery object will be instantiated and called as such:\\n * RangeFreqQuery* obj = new RangeFreqQuery(arr);\\n * int param_1 = obj->query(left,right,value);\\n */\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1601954,
                "title": "java-binary-search",
                "content": "```\\nclass RangeFreqQuery {\\n    Map<Integer, List<Integer>> numPositions;\\n    int[] arr;\\n    public RangeFreqQuery(int[] arr) {\\n        this.arr = arr;\\n        this.numPositions = new HashMap<Integer, List<Integer>>();\\n        for(int idx = 0; idx < arr.length; idx++) {\\n            numPositions.putIfAbsent(arr[idx], new ArrayList<Integer>());\\n            numPositions.get(arr[idx]).add(idx);\\n        }\\n    }\\n    \\n    public int query(int left, int right, int value) {\\n\\n        List<Integer> list = numPositions.get(value);\\n        if(list == null) return 0;\\n        int leftExtreme = list.get(0);\\n        int rightExtreme = list.get(list.size() - 1);\\n        // if the query\\'s interval and the interval being searched are disjoint\\n        if(leftExtreme > right || rightExtreme < left) return 0;\\n        int leftIdx = largestNumberLessThan(left, list);\\n        int rightIdx = smallestNumberGreaterThan(right, list);\\n        \\n        if(rightIdx == -1) rightIdx = list.size() - 1;\\n        if(leftIdx == -1) leftIdx = 0;\\n        \\n        int ans = rightIdx - leftIdx - 1;\\n        if(list.get(rightIdx) <= right) ans++;\\n        if(list.get(leftIdx) >= left) ans++;\\n        \\n        return ans;\\n    }\\n    \\n    public int largestNumberLessThan(int value, List<Integer> list) {\\n        int toReturn = -1;\\n        int l = 0, r = list.size() - 1;\\n        while(l <= r) {\\n            int mid = (l + r)/2;\\n            if(list.get(mid) < value) {\\n                toReturn = mid;\\n                l = mid + 1;\\n            } else {\\n                r = mid - 1;\\n            }\\n        }\\n        return toReturn;\\n    }\\n    \\n    public int smallestNumberGreaterThan(int value, List<Integer> list) { \\n        int toReturn = -1;\\n        int l = 0, r = list.size() - 1;\\n        while(l <= r) {\\n            int mid = (l + r)/2;\\n            if(list.get(mid) > value) {\\n                toReturn = mid;\\n                r = mid - 1;\\n            } else {\\n                l = mid + 1;\\n            }\\n        }\\n         return toReturn;\\n    }\\n}\\n\\n/**\\n * Your RangeFreqQuery object will be instantiated and called as such:\\n * RangeFreqQuery obj = new RangeFreqQuery(arr);\\n * int param_1 = obj.query(left,right,value);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass RangeFreqQuery {\\n    Map<Integer, List<Integer>> numPositions;\\n    int[] arr;\\n    public RangeFreqQuery(int[] arr) {\\n        this.arr = arr;\\n        this.numPositions = new HashMap<Integer, List<Integer>>();\\n        for(int idx = 0; idx < arr.length; idx++) {\\n            numPositions.putIfAbsent(arr[idx], new ArrayList<Integer>());\\n            numPositions.get(arr[idx]).add(idx);\\n        }\\n    }\\n    \\n    public int query(int left, int right, int value) {\\n\\n        List<Integer> list = numPositions.get(value);\\n        if(list == null) return 0;\\n        int leftExtreme = list.get(0);\\n        int rightExtreme = list.get(list.size() - 1);\\n        // if the query\\'s interval and the interval being searched are disjoint\\n        if(leftExtreme > right || rightExtreme < left) return 0;\\n        int leftIdx = largestNumberLessThan(left, list);\\n        int rightIdx = smallestNumberGreaterThan(right, list);\\n        \\n        if(rightIdx == -1) rightIdx = list.size() - 1;\\n        if(leftIdx == -1) leftIdx = 0;\\n        \\n        int ans = rightIdx - leftIdx - 1;\\n        if(list.get(rightIdx) <= right) ans++;\\n        if(list.get(leftIdx) >= left) ans++;\\n        \\n        return ans;\\n    }\\n    \\n    public int largestNumberLessThan(int value, List<Integer> list) {\\n        int toReturn = -1;\\n        int l = 0, r = list.size() - 1;\\n        while(l <= r) {\\n            int mid = (l + r)/2;\\n            if(list.get(mid) < value) {\\n                toReturn = mid;\\n                l = mid + 1;\\n            } else {\\n                r = mid - 1;\\n            }\\n        }\\n        return toReturn;\\n    }\\n    \\n    public int smallestNumberGreaterThan(int value, List<Integer> list) { \\n        int toReturn = -1;\\n        int l = 0, r = list.size() - 1;\\n        while(l <= r) {\\n            int mid = (l + r)/2;\\n            if(list.get(mid) > value) {\\n                toReturn = mid;\\n                r = mid - 1;\\n            } else {\\n                l = mid + 1;\\n            }\\n        }\\n         return toReturn;\\n    }\\n}\\n\\n/**\\n * Your RangeFreqQuery object will be instantiated and called as such:\\n * RangeFreqQuery obj = new RangeFreqQuery(arr);\\n * int param_1 = obj.query(left,right,value);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1600706,
                "title": "c-solution-easy-o-logn",
                "content": "\\tclass RangeFreqQuery {\\n\\tpublic:\\n\\t\\tunordered_map<int,vector<int>> mp;\\n\\t\\tRangeFreqQuery(vector<int>& arr) {\\n\\t\\t\\tfor(int i=0;i<arr.size();i++){\\n\\t\\t\\t\\tif(mp.find(arr[i])==mp.end())\\n\\t\\t\\t\\t\\t mp[arr[i]]={i};\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tmp[arr[i]].push_back(i);\\n\\t\\t\\t}\\n\\t\\t}\\n    \\n    int query(int left, int right, int value) {\\n        //case : when element is not there in original array and map\\n         if(mp.find(value) == mp.end()){\\n            return 0;\\n        }\\n        else{\\n            auto lowerIt = lower_bound(mp[value].begin(), mp[value].end(), left);\\n            auto upperIt = upper_bound(mp[value].begin(), mp[value].end(), right);\\n            return upperIt-lowerIt;\\n        }\\n        \\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "\\tclass RangeFreqQuery {\\n\\tpublic:\\n\\t\\tunordered_map<int,vector<int>> mp;\\n\\t\\tRangeFreqQuery(vector<int>& arr) {\\n\\t\\t\\tfor(int i=0;i<arr.size();i++){\\n\\t\\t\\t\\tif(mp.find(arr[i])==mp.end())\\n\\t\\t\\t\\t\\t mp[arr[i]]={i};\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tmp[arr[i]].push_back(i);\\n\\t\\t\\t}\\n\\t\\t}\\n    \\n    int query(int left, int right, int value) {\\n        //case : when element is not there in original array and map\\n         if(mp.find(value) == mp.end()){\\n            return 0;\\n        }\\n        else{\\n            auto lowerIt = lower_bound(mp[value].begin(), mp[value].end(), left);\\n            auto upperIt = upper_bound(mp[value].begin(), mp[value].end(), right);\\n            return upperIt-lowerIt;\\n        }\\n        \\n    }\\n};",
                "codeTag": "Java"
            },
            {
                "id": 1596196,
                "title": "java-segment-tree",
                "content": "```\\nclass RangeFreqQuery {\\n\\n    Map<Integer, Integer>[] freq;\\n    int n;\\n    \\n    public RangeFreqQuery(int[] arr) {\\n        n = arr.length;\\n        freq = new HashMap[4 * n];\\n        for(int i = 0; i < 4 * n; i++)\\n            freq[i] = new HashMap<>();\\n        build(1, 0, n - 1, arr);\\n    }\\n    \\n    private void build(int id, int start, int end, int[] arr){\\n        if(start == end)\\n            freq[id].put(arr[start], 1);\\n        else{\\n            int mid = (start + end) / 2, left = 2 * id, right = 2 * id + 1;\\n            build(left, start, mid, arr);\\n            build(right, mid + 1, end, arr);\\n            for(int i : freq[left].keySet())\\n                freq[id].put(i, freq[id].getOrDefault(i, 0) + freq[left].get(i));\\n            for(int i : freq[right].keySet())\\n                freq[id].put(i, freq[id].getOrDefault(i, 0) + freq[right].get(i));\\n        }\\n    }\\n    \\n    public int query(int left, int right, int value) {\\n        return find(1, 0, n - 1, left, right, value);\\n    }\\n    \\n    private int find(int id, int start, int end, int l, int r, int value){\\n        if(r < start || end < l)\\n            return 0;\\n        else if(start == end)\\n            return freq[id].getOrDefault(value, 0);\\n        else if(l <= start && end <= r)\\n            return freq[id].getOrDefault(value, 0);\\n        else{\\n            int mid = (start + end) / 2;\\n            int left = find(2 * id, start, mid, l, r, value);\\n            int right = find(2 * id + 1, mid + 1, end, l, r, value);\\n            return left + right;\\n        }\\n    }\\n}\\n\\n/**\\n * Your RangeFreqQuery object will be instantiated and called as such:\\n * RangeFreqQuery obj = new RangeFreqQuery(arr);\\n * int param_1 = obj.query(left,right,value);\\n */\\n ```",
                "solutionTags": [],
                "code": "```\\nclass RangeFreqQuery {\\n\\n    Map<Integer, Integer>[] freq;\\n    int n;\\n    \\n    public RangeFreqQuery(int[] arr) {\\n        n = arr.length;\\n        freq = new HashMap[4 * n];\\n        for(int i = 0; i < 4 * n; i++)\\n            freq[i] = new HashMap<>();\\n        build(1, 0, n - 1, arr);\\n    }\\n    \\n    private void build(int id, int start, int end, int[] arr){\\n        if(start == end)\\n            freq[id].put(arr[start], 1);\\n        else{\\n            int mid = (start + end) / 2, left = 2 * id, right = 2 * id + 1;\\n            build(left, start, mid, arr);\\n            build(right, mid + 1, end, arr);\\n            for(int i : freq[left].keySet())\\n                freq[id].put(i, freq[id].getOrDefault(i, 0) + freq[left].get(i));\\n            for(int i : freq[right].keySet())\\n                freq[id].put(i, freq[id].getOrDefault(i, 0) + freq[right].get(i));\\n        }\\n    }\\n    \\n    public int query(int left, int right, int value) {\\n        return find(1, 0, n - 1, left, right, value);\\n    }\\n    \\n    private int find(int id, int start, int end, int l, int r, int value){\\n        if(r < start || end < l)\\n            return 0;\\n        else if(start == end)\\n            return freq[id].getOrDefault(value, 0);\\n        else if(l <= start && end <= r)\\n            return freq[id].getOrDefault(value, 0);\\n        else{\\n            int mid = (start + end) / 2;\\n            int left = find(2 * id, start, mid, l, r, value);\\n            int right = find(2 * id + 1, mid + 1, end, l, r, value);\\n            return left + right;\\n        }\\n    }\\n}\\n\\n/**\\n * Your RangeFreqQuery object will be instantiated and called as such:\\n * RangeFreqQuery obj = new RangeFreqQuery(arr);\\n * int param_1 = obj.query(left,right,value);\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1589069,
                "title": "python-dict-solution",
                "content": "```\\nclass RangeFreqQuery:\\n    def __init__(self, arr: List[int]):\\n        self.d = collections.defaultdict(list)\\n        for i in range(len(arr)):\\n            self.d[arr[i]].append(i)  # store the indices of a number as map\\n            \\n\\t# difference between right and left gives the frequency\\n    def query(self, left: int, right: int, value: int) -> int:\\n        return bisect_right(self.d[value], right) - bisect_left(self.d[value], left)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\nclass RangeFreqQuery:\\n    def __init__(self, arr: List[int]):\\n        self.d = collections.defaultdict(list)\\n        for i in range(len(arr)):\\n            self.d[arr[i]].append(i)  # store the indices of a number as map\\n            \\n\\t# difference between right and left gives the frequency\\n    def query(self, left: int, right: int, value: int) -> int:\\n        return bisect_right(self.d[value], right) - bisect_left(self.d[value], left)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1589036,
                "title": "python3-o-logn-binary-search-with-hashmap-of-indexes-with-brief-explanation",
                "content": "For each value in the array, we have a hashtable of lists where the lists contain each occurance index of the value in the array. We then binarysearch to find the first index satisfying the bound left, and then binarysearch to find the index satisfying the right bound. We know how many occurances we have based on the number of indexes betwen the right binary search result, and the left binary search result.\\n\\n```\\nfrom bisect import bisect_left, bisect_right\\nclass RangeFreqQuery:\\n\\n    def __init__(self, A: List[int]):\\n        self.O = O = defaultdict(list)\\n        for i, a in enumerate(A):\\n            O[a].append(i)\\n\\n    def query(self, left: int, right: int, v: int) -> int:\\n        _all = self.O[v]\\n        l = bisect_left(_all, left)\\n        r = bisect_right(_all, right)\\n        \\n        return r-l\\n```",
                "solutionTags": [],
                "code": "```\\nfrom bisect import bisect_left, bisect_right\\nclass RangeFreqQuery:\\n\\n    def __init__(self, A: List[int]):\\n        self.O = O = defaultdict(list)\\n        for i, a in enumerate(A):\\n            O[a].append(i)\\n\\n    def query(self, left: int, right: int, v: int) -> int:\\n        _all = self.O[v]\\n        l = bisect_left(_all, left)\\n        r = bisect_right(_all, right)\\n        \\n        return r-l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1589017,
                "title": "java-simple-binary-search-o-logn",
                "content": "```\\nclass RangeFreqQuery {\\n\\n    Map<Integer, List<Integer>> cache = null;\\n    public RangeFreqQuery(int[] arr) {\\n        cache = new HashMap<>();\\n        for(int i= 0;i<arr.length;i++){\\n            List<Integer> inner = cache.get(arr[i]);\\n            if(inner == null){\\n                inner = new ArrayList<>();\\n                cache.put(arr[i], inner);\\n            }\\n            inner.add(i);\\n        }\\n    }\\n    \\n    public int query(int left, int right, int value) {\\n        List<Integer> indexes = cache.get(value);\\n        if(indexes != null){\\n            int l = Collections.binarySearch(indexes, left);\\n            int out = 0;\\n            if(l < 0){\\n                 out -= 1;   ////exlcuding the left index from count\\n                 l = -1 * l -2; //adjust to left index if no exact match\\n            }\\n            int r = Collections.binarySearch(indexes, right);\\n            if(r < 0){\\n                out -= 1;      //exlcuding the right index from count\\n                r = -1 * r -1; //adjust to right index if no exact match\\n            }\\n            out += r-l +1;\\n            return out;\\n        }\\n        return 0;\\n    }\\n}\\n",
                "solutionTags": [],
                "code": "```\\nclass RangeFreqQuery {\\n\\n    Map<Integer, List<Integer>> cache = null;\\n    public RangeFreqQuery(int[] arr) {\\n        cache = new HashMap<>();\\n        for(int i= 0;i<arr.length;i++){\\n            List<Integer> inner = cache.get(arr[i]);\\n            if(inner == null){\\n                inner = new ArrayList<>();\\n                cache.put(arr[i], inner);\\n            }\\n            inner.add(i);\\n        }\\n    }\\n    \\n    public int query(int left, int right, int value) {\\n        List<Integer> indexes = cache.get(value);\\n        if(indexes != null){\\n            int l = Collections.binarySearch(indexes, left);\\n            int out = 0;\\n            if(l < 0){\\n                 out -= 1;   ////exlcuding the left index from count\\n                 l = -1 * l -2; //adjust to left index if no exact match\\n            }\\n            int r = Collections.binarySearch(indexes, right);\\n            if(r < 0){\\n                out -= 1;      //exlcuding the right index from count\\n                r = -1 * r -1; //adjust to right index if no exact match\\n            }\\n            out += r-l +1;\\n            return out;\\n        }\\n        return 0;\\n    }\\n}\\n",
                "codeTag": "Java"
            },
            {
                "id": 3641373,
                "title": "c-solution-using-segment-tree-unordered-hash-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass RangeFreqQuery {\\npublic:\\n        int n;\\n        vector<unordered_map<int,int>>seg;\\n        void build(int index,int lx,int rx,vector<int>&arr,vector<unordered_map<int,int>>&seg){\\n            if(rx-lx==1){\\n                if(lx<arr.size()){\\n                    seg[index][arr[lx]]++;\\n                }\\n                return;\\n            }\\n            int mid = (lx+rx)/2;\\n            build(2*index+1,lx,mid,arr,seg);\\n            build(2*index+2,mid,rx,arr,seg);\\n            for(auto i:seg[2*index+1])seg[index][i.first]+=i.second;\\n            for(auto i:seg[2*index+2])seg[index][i.first]+=i.second;\\n        }\\n        int segmentQuery(int index,int lx,int rx,int l,int r,int val,vector<unordered_map<int,int>>&seg){\\n            if(lx>=l && rx<=r)return seg[index][val];\\n            if(lx>=r || rx<=l)return 0;\\n            int mid = (lx+rx)/2;\\n            int left = segmentQuery(2*index+1,lx,mid,l,r,val,seg);\\n            int right = segmentQuery(2*index+2,mid,rx,l,r,val,seg);\\n            return left+right;\\n        }\\n    RangeFreqQuery(vector<int>& arr) {\\n        n = arr.size();\\n        seg.resize(4*n);\\n        build(0,0,n+1,arr,seg);\\n    }\\n    int query(int left, int right, int value) {\\n        return segmentQuery(0,0,n+1,left,right+1,value,seg);\\n    }\\n};\\n\\n/**\\n * Your RangeFreqQuery object will be instantiated and called as such:\\n * RangeFreqQuery* obj = new RangeFreqQuery(arr);\\n * int param_1 = obj->query(left,right,value);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Segment Tree"
                ],
                "code": "```\\nclass RangeFreqQuery {\\npublic:\\n        int n;\\n        vector<unordered_map<int,int>>seg;\\n        void build(int index,int lx,int rx,vector<int>&arr,vector<unordered_map<int,int>>&seg){\\n            if(rx-lx==1){\\n                if(lx<arr.size()){\\n                    seg[index][arr[lx]]++;\\n                }\\n                return;\\n            }\\n            int mid = (lx+rx)/2;\\n            build(2*index+1,lx,mid,arr,seg);\\n            build(2*index+2,mid,rx,arr,seg);\\n            for(auto i:seg[2*index+1])seg[index][i.first]+=i.second;\\n            for(auto i:seg[2*index+2])seg[index][i.first]+=i.second;\\n        }\\n        int segmentQuery(int index,int lx,int rx,int l,int r,int val,vector<unordered_map<int,int>>&seg){\\n            if(lx>=l && rx<=r)return seg[index][val];\\n            if(lx>=r || rx<=l)return 0;\\n            int mid = (lx+rx)/2;\\n            int left = segmentQuery(2*index+1,lx,mid,l,r,val,seg);\\n            int right = segmentQuery(2*index+2,mid,rx,l,r,val,seg);\\n            return left+right;\\n        }\\n    RangeFreqQuery(vector<int>& arr) {\\n        n = arr.size();\\n        seg.resize(4*n);\\n        build(0,0,n+1,arr,seg);\\n    }\\n    int query(int left, int right, int value) {\\n        return segmentQuery(0,0,n+1,left,right+1,value,seg);\\n    }\\n};\\n\\n/**\\n * Your RangeFreqQuery object will be instantiated and called as such:\\n * RangeFreqQuery* obj = new RangeFreqQuery(arr);\\n * int param_1 = obj->query(left,right,value);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3351372,
                "title": "c-simple-solution-using-unordered-map",
                "content": "# Intuition\\nUsing a hashset to store all the positions of the elements would be the best method to go with.\\n\\n# Approach\\nWe can use element as the key and a vector as the value to store the all indexes of the element in the array.\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn) to build the hashtable. O(logn) for each query as we\\'re doing binary search on all the indexes of the element\\n\\n- Space complexity:\\nAs we\\'re using a hashtable it would be O(n).\\n\\n# Code\\n```\\nclass RangeFreqQuery {\\npublic:\\n    unordered_map<int,vector<int>>m;\\n    RangeFreqQuery(vector<int>& arr) {\\n        for(int i=0;i<arr.size();i++){m[arr[i]].push_back(i);}\\n    }\\n    \\n    int query(int left, int right, int v) {\\n        auto it1=upper_bound(m[v].begin(),m[v].end(),right);\\n        auto it2=lower_bound(m[v].begin(),m[v].end(),left);\\n        return it1-it2;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map"
                ],
                "code": "```\\nclass RangeFreqQuery {\\npublic:\\n    unordered_map<int,vector<int>>m;\\n    RangeFreqQuery(vector<int>& arr) {\\n        for(int i=0;i<arr.size();i++){m[arr[i]].push_back(i);}\\n    }\\n    \\n    int query(int left, int right, int v) {\\n        auto it1=upper_bound(m[v].begin(),m[v].end(),right);\\n        auto it2=lower_bound(m[v].begin(),m[v].end(),left);\\n        return it1-it2;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3351371,
                "title": "c-simple-solution-using-unordered-map",
                "content": "# Intuition\\nUsing a hashset to store all the positions of the elements would be the best method to go with.\\n\\n# Approach\\nWe can use element as the key and a vector as the value to store the all indexes of the element in the array.\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn) to build the hashtable. O(logn) for each query as we\\'re doing binary search on all the indexes of the element\\n\\n- Space complexity:\\nAs we\\'re using a hashtable it would be O(n).\\n\\n# Code\\n```\\nclass RangeFreqQuery {\\npublic:\\n    unordered_map<int,vector<int>>m;\\n    RangeFreqQuery(vector<int>& arr) {\\n        for(int i=0;i<arr.size();i++){m[arr[i]].push_back(i);}\\n    }\\n    \\n    int query(int left, int right, int v) {\\n        auto it1=upper_bound(m[v].begin(),m[v].end(),right);\\n        auto it2=lower_bound(m[v].begin(),m[v].end(),left);\\n        return it1-it2;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map"
                ],
                "code": "```\\nclass RangeFreqQuery {\\npublic:\\n    unordered_map<int,vector<int>>m;\\n    RangeFreqQuery(vector<int>& arr) {\\n        for(int i=0;i<arr.size();i++){m[arr[i]].push_back(i);}\\n    }\\n    \\n    int query(int left, int right, int v) {\\n        auto it1=upper_bound(m[v].begin(),m[v].end(),right);\\n        auto it2=lower_bound(m[v].begin(),m[v].end(),left);\\n        return it1-it2;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2940168,
                "title": "c-segment-tree-implementation",
                "content": "# Intuition\\n- Range Query with frquency map\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- Segement Tree\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:o(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass RangeFreqQuery {\\npublic:\\n   int n;\\n   vector<map<int,int>>seg;\\n    void makeTree(int low,int high,vector<int>&arr,int i){\\n        if(low==high){\\n            map<int,int>m;\\n            m[arr[low]]++;\\n            seg[i]=m;\\n            return;\\n        }\\n        int mid=(low+high)>>1;\\n        makeTree(low,mid,arr,2*i);\\n        makeTree(mid+1,high,arr,2*i+1);\\n        map<int,int>m;\\n        m=seg[2*i];\\n        for(auto it:seg[2*i+1]){\\n            if(m.find(it.first)==m.end())m[it.first]=it.second;\\n            else m[it.first]+=it.second;\\n        }\\n        seg[i]=m;\\n    }\\n    RangeFreqQuery(vector<int>& arr) {\\n        n=arr.size();\\n        map<int,int>m;\\n        seg=vector<map<int,int>>(4*n+1,m);\\n        makeTree(0,n-1,arr,1);\\n    }\\n    int query(int node , int l , int r , int ql , int qr,int  val){\\n        if(l>r|| ql > r || l > qr )\\n            return 0 ;\\n        if(ql<=l&& r <=qr )\\n            return seg[node][val];\\n        int mid = (l+r)>>1;\\n        int left = query(node+node , l , mid , ql , qr ,val );\\n        int right = query(node + node +1 , mid+1 , r , ql , qr,val);\\n        return left + right;\\n    }\\n    int query(int left, int right, int value) {\\n        return query(1,0,n-1,left,right,value);\\n    }\\n};\\n\\n/**\\n * Your RangeFreqQuery object will be instantiated and called as such:\\n * RangeFreqQuery* obj = new RangeFreqQuery(arr);\\n * int param_1 = obj->query(left,right,value);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Segment Tree"
                ],
                "code": "```\\nclass RangeFreqQuery {\\npublic:\\n   int n;\\n   vector<map<int,int>>seg;\\n    void makeTree(int low,int high,vector<int>&arr,int i){\\n        if(low==high){\\n            map<int,int>m;\\n            m[arr[low]]++;\\n            seg[i]=m;\\n            return;\\n        }\\n        int mid=(low+high)>>1;\\n        makeTree(low,mid,arr,2*i);\\n        makeTree(mid+1,high,arr,2*i+1);\\n        map<int,int>m;\\n        m=seg[2*i];\\n        for(auto it:seg[2*i+1]){\\n            if(m.find(it.first)==m.end())m[it.first]=it.second;\\n            else m[it.first]+=it.second;\\n        }\\n        seg[i]=m;\\n    }\\n    RangeFreqQuery(vector<int>& arr) {\\n        n=arr.size();\\n        map<int,int>m;\\n        seg=vector<map<int,int>>(4*n+1,m);\\n        makeTree(0,n-1,arr,1);\\n    }\\n    int query(int node , int l , int r , int ql , int qr,int  val){\\n        if(l>r|| ql > r || l > qr )\\n            return 0 ;\\n        if(ql<=l&& r <=qr )\\n            return seg[node][val];\\n        int mid = (l+r)>>1;\\n        int left = query(node+node , l , mid , ql , qr ,val );\\n        int right = query(node + node +1 , mid+1 , r , ql , qr,val);\\n        return left + right;\\n    }\\n    int query(int left, int right, int value) {\\n        return query(1,0,n-1,left,right,value);\\n    }\\n};\\n\\n/**\\n * Your RangeFreqQuery object will be instantiated and called as such:\\n * RangeFreqQuery* obj = new RangeFreqQuery(arr);\\n * int param_1 = obj->query(left,right,value);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2787134,
                "title": "c-easy-short",
                "content": "\\n\\n# Code\\n```\\nclass RangeFreqQuery {\\npublic:\\n     vector<unordered_map<int,int>> tree;\\nint n=0;\\nvoid construct(int i, int l, int r, vector<int>& arr){\\n    if (l > r)  return;\\n\\n    if(l==r){\\n        tree[i].insert({arr[l], 1});\\n        return;\\n    }\\n    if(l != r){\\n        \\n        int mid = (l + r)/2;\\n\\n        construct(2*i+1, l, mid, arr);\\n        construct(2*i+2, mid+1, r, arr);\\n        // merge child1 and child2 in parent\\n        for (auto itr: tree[2*i+1]){\\n            tree[i][itr.first] += itr.second;\\n        }\\n        for (auto itr: tree[2*i+2]){\\n            tree[i][itr.first] += itr.second;\\n        }\\n    }\\n}\\nRangeFreqQuery(vector<int>& arr) {\\n    n = arr.size();\\n    int x = (int)(ceil(log2(n)));\\n    int max_size = 2*(int)pow(2, x) - 1;\\n    tree.resize(max_size);\\n    \\n    construct(0, 0, n-1, arr);\\n}\\nint getSum(int si, int sl, int sr, int ql, int qr, int val){\\n    if(sr<ql || qr<sl){ return 0; }\\n    \\n    if(ql<=sl && sr<=qr){\\n        return tree[si].find(val)!=tree[si].end() ? tree[si][val]: 0;\\n    }\\n    \\n    int mid = (sl + sr)/2;\\n    return getSum(2*si+1, sl, mid, ql, qr, val) + getSum(2*si+2, mid+1, sr, ql, qr, val);\\n}\\n\\nint query(int left, int right, int value) {\\n    return getSum(0, 0, n-1, left, right, value);\\n}\\n};\\n\\n/**\\n * Your RangeFreqQuery object will be instantiated and called as such:\\n * RangeFreqQuery* obj = new RangeFreqQuery(arr);\\n * int param_1 = obj->query(left,right,value);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass RangeFreqQuery {\\npublic:\\n     vector<unordered_map<int,int>> tree;\\nint n=0;\\nvoid construct(int i, int l, int r, vector<int>& arr){\\n    if (l > r)  return;\\n\\n    if(l==r){\\n        tree[i].insert({arr[l], 1});\\n        return;\\n    }\\n    if(l != r){\\n        \\n        int mid = (l + r)/2;\\n\\n        construct(2*i+1, l, mid, arr);\\n        construct(2*i+2, mid+1, r, arr);\\n        // merge child1 and child2 in parent\\n        for (auto itr: tree[2*i+1]){\\n            tree[i][itr.first] += itr.second;\\n        }\\n        for (auto itr: tree[2*i+2]){\\n            tree[i][itr.first] += itr.second;\\n        }\\n    }\\n}\\nRangeFreqQuery(vector<int>& arr) {\\n    n = arr.size();\\n    int x = (int)(ceil(log2(n)));\\n    int max_size = 2*(int)pow(2, x) - 1;\\n    tree.resize(max_size);\\n    \\n    construct(0, 0, n-1, arr);\\n}\\nint getSum(int si, int sl, int sr, int ql, int qr, int val){\\n    if(sr<ql || qr<sl){ return 0; }\\n    \\n    if(ql<=sl && sr<=qr){\\n        return tree[si].find(val)!=tree[si].end() ? tree[si][val]: 0;\\n    }\\n    \\n    int mid = (sl + sr)/2;\\n    return getSum(2*si+1, sl, mid, ql, qr, val) + getSum(2*si+2, mid+1, sr, ql, qr, val);\\n}\\n\\nint query(int left, int right, int value) {\\n    return getSum(0, 0, n-1, left, right, value);\\n}\\n};\\n\\n/**\\n * Your RangeFreqQuery object will be instantiated and called as such:\\n * RangeFreqQuery* obj = new RangeFreqQuery(arr);\\n * int param_1 = obj->query(left,right,value);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2360097,
                "title": "c-approach-by-segment-trees",
                "content": "**// segment tree**\\n\\n**class RangeFreqQuery {\\npublic:**\\n\\n\\n    vector<unordered_map<int,int>> seg;\\n    int n;\\n    void build(vector<int>&arr,int low,int high,int ind){\\n        if(low==high){\\n            seg[ind][arr[low]]++;\\n            return;\\n        }\\n        int mid=low+(high-low)/2;\\n        build(arr,low,mid,2*ind+1);\\n        build(arr,mid+1,high,2*ind+2);\\n        // seg[ind].insert(seg[2*ind+1].begin(),seg[2*ind+1].end());\\n        // seg[ind].insert(seg[2*ind+2].begin(),seg[2*ind+2].end());\\n        for(auto it=seg[2*ind+1].begin();it!=seg[2*ind+1].end();++it){\\n            seg[ind][it->first]+=it->second;\\n        }\\n        for(auto it=seg[2*ind+2].begin();it!=seg[2*ind+2].end();++it){\\n            seg[ind][it->first]+=it->second;\\n        }\\n        return;\\n    }\\n    RangeFreqQuery(vector<int>& arr) {\\n        // for(int i=0;i<arr.size();++i){\\n        //     mp[i]=arr[i];\\n        // }\\n        n=arr.size();\\n        seg.resize(4*n);\\n        build(arr,0,n-1,0);\\n    }\\n    int check(int left,int right,int value,int l,int r,int ind){\\n        if(left>r || right<l){\\n            return 0;\\n        }\\n        if(left<=l && right>=r){\\n            return seg[ind][value];\\n        }\\n        int mid=l+(r-l)/2;\\n        int low=check(left,right,value,l,mid,2*ind+1);\\n        int high=check(left,right,value,mid+1,r,2*ind+2);\\n        return low+high;\\n    }\\n    int query(int left, int right, int value) {\\n        // int count=0;\\n        // for(int i=left;i<=right;++i){\\n        //     if(mp[i]==value){\\n        //         count++;\\n        //     }\\n        // }\\n        // return count;\\n        int count=check(left,right,value,0,n-1,0);\\n        \\n        return count;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Tree"
                ],
                "code": "**// segment tree**\\n\\n**class RangeFreqQuery {\\npublic:**\\n\\n\\n    vector<unordered_map<int,int>> seg;\\n    int n;\\n    void build(vector<int>&arr,int low,int high,int ind){\\n        if(low==high){\\n            seg[ind][arr[low]]++;\\n            return;\\n        }\\n        int mid=low+(high-low)/2;\\n        build(arr,low,mid,2*ind+1);\\n        build(arr,mid+1,high,2*ind+2);\\n        // seg[ind].insert(seg[2*ind+1].begin(),seg[2*ind+1].end());\\n        // seg[ind].insert(seg[2*ind+2].begin(),seg[2*ind+2].end());\\n        for(auto it=seg[2*ind+1].begin();it!=seg[2*ind+1].end();++it){\\n            seg[ind][it->first]+=it->second;\\n        }\\n        for(auto it=seg[2*ind+2].begin();it!=seg[2*ind+2].end();++it){\\n            seg[ind][it->first]+=it->second;\\n        }\\n        return;\\n    }\\n    RangeFreqQuery(vector<int>& arr) {\\n        // for(int i=0;i<arr.size();++i){\\n        //     mp[i]=arr[i];\\n        // }\\n        n=arr.size();\\n        seg.resize(4*n);\\n        build(arr,0,n-1,0);\\n    }\\n    int check(int left,int right,int value,int l,int r,int ind){\\n        if(left>r || right<l){\\n            return 0;\\n        }\\n        if(left<=l && right>=r){\\n            return seg[ind][value];\\n        }\\n        int mid=l+(r-l)/2;\\n        int low=check(left,right,value,l,mid,2*ind+1);\\n        int high=check(left,right,value,mid+1,r,2*ind+2);\\n        return low+high;\\n    }\\n    int query(int left, int right, int value) {\\n        // int count=0;\\n        // for(int i=left;i<=right;++i){\\n        //     if(mp[i]==value){\\n        //         count++;\\n        //     }\\n        // }\\n        // return count;\\n        int count=check(left,right,value,0,n-1,0);\\n        \\n        return count;\\n    }\\n};",
                "codeTag": "Java"
            },
            {
                "id": 2343136,
                "title": "python-segment-tree",
                "content": "```\\nclass TreeNode:\\n    def __init__(self,start,end):\\n        self.start = start\\n        self.end = end\\n        self.total = collections.defaultdict(int)\\n        self.left = None\\n        self.right = None\\n\\nclass RangeFreqQuery:\\n\\n    def __init__(self, arr: List[int]):\\n        \\n        def create_segment_tree(arr,start,end):\\n            if start>end:\\n                return None\\n            if start == end:\\n                root = TreeNode(start,end)\\n                root.total[arr[start]] += 1\\n                return root\\n            \\n            mid = (start+end)//2\\n            \\n            root = TreeNode(start,end)\\n            \\n            root.left = create_segment_tree(arr,start,mid)\\n            root.right = create_segment_tree(arr,mid+1,end)\\n            \\n            root.total = collections.Counter(root.left.total)+Counter(root.right.total)\\n            \\n            return root\\n                \\n        \\n        self.root = create_segment_tree(arr,0,len(arr)-1)\\n       \\n    def query(self, left: int, right: int, value: int) -> int:\\n        \\n        def get_query_value(root,l,r,value):\\n           \\n            if root.start>r or root.end<l:\\n                return 0\\n            \\n            if root.start == l and root.end==r:\\n                val = root.total[value]\\n                return val\\n            \\n            mid = (root.start+root.end)//2\\n            \\n            if r<=mid:\\n                return get_query_value(root.left,l,r,value)\\n            elif l>mid:\\n                return get_query_value(root.right,l,r,value)\\n            else:\\n                return (get_query_value(root.left,l,mid,value)+get_query_value(root.right,mid+1,r,value))\\n            \\n        \\n        return get_query_value(self.root,left,right,value)\\n\\n\\n# Your RangeFreqQuery object will be instantiated and called as such:\\n# obj = RangeFreqQuery(arr)\\n# param_1 = obj.query(left,right,value)\\n```",
                "solutionTags": [
                    "Python",
                    "Tree"
                ],
                "code": "```\\nclass TreeNode:\\n    def __init__(self,start,end):\\n        self.start = start\\n        self.end = end\\n        self.total = collections.defaultdict(int)\\n        self.left = None\\n        self.right = None\\n\\nclass RangeFreqQuery:\\n\\n    def __init__(self, arr: List[int]):\\n        \\n        def create_segment_tree(arr,start,end):\\n            if start>end:\\n                return None\\n            if start == end:\\n                root = TreeNode(start,end)\\n                root.total[arr[start]] += 1\\n                return root\\n            \\n            mid = (start+end)//2\\n            \\n            root = TreeNode(start,end)\\n            \\n            root.left = create_segment_tree(arr,start,mid)\\n            root.right = create_segment_tree(arr,mid+1,end)\\n            \\n            root.total = collections.Counter(root.left.total)+Counter(root.right.total)\\n            \\n            return root\\n                \\n        \\n        self.root = create_segment_tree(arr,0,len(arr)-1)\\n       \\n    def query(self, left: int, right: int, value: int) -> int:\\n        \\n        def get_query_value(root,l,r,value):\\n           \\n            if root.start>r or root.end<l:\\n                return 0\\n            \\n            if root.start == l and root.end==r:\\n                val = root.total[value]\\n                return val\\n            \\n            mid = (root.start+root.end)//2\\n            \\n            if r<=mid:\\n                return get_query_value(root.left,l,r,value)\\n            elif l>mid:\\n                return get_query_value(root.right,l,r,value)\\n            else:\\n                return (get_query_value(root.left,l,mid,value)+get_query_value(root.right,mid+1,r,value))\\n            \\n        \\n        return get_query_value(self.root,left,right,value)\\n\\n\\n# Your RangeFreqQuery object will be instantiated and called as such:\\n# obj = RangeFreqQuery(arr)\\n# param_1 = obj.query(left,right,value)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2212103,
                "title": "simple-solution-c-less-code",
                "content": "class RangeFreqQuery {\\npublic:\\n    \\n    vector<int>adj[100001];\\n    \\n    RangeFreqQuery(vector<int>& arr) {\\n        \\n        for(int i=0;i<arr.size();i++)\\n        {\\n            adj[arr[i]].push_back(i);\\n        }\\n        \\n    }\\n    \\n    int query(int left, int right, int value) {\\n        \\n        left=lower_bound(adj[value].begin(),adj[value].end(),left)-adj[value].begin();\\n        right=upper_bound(adj[value].begin(),adj[value].end(),right)-adj[value].begin();\\n        \\n        return right-left;\\n    }\\n};\\n\\n",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "class RangeFreqQuery {\\npublic:\\n    \\n    vector<int>adj[100001];\\n    \\n    RangeFreqQuery(vector<int>& arr) {\\n        \\n        for(int i=0;i<arr.size();i++)\\n        {\\n            adj[arr[i]].push_back(i);\\n        }\\n        \\n    }\\n    \\n    int query(int left, int right, int value) {\\n        \\n        left=lower_bound(adj[value].begin(),adj[value].end(),left)-adj[value].begin();\\n        right=upper_bound(adj[value].begin(),adj[value].end(),right)-adj[value].begin();\\n        \\n        return right-left;\\n    }\\n};\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 2163041,
                "title": "c-binary-search-solution-using-map",
                "content": "```\\nmap<int,vector<int>> mp;\\n    RangeFreqQuery(vector<int>& arr) {\\n       for(int i=0;i<arr.size();i++) mp[arr[i]].push_back(i);\\n    }\\n    int query(int left, int right, int value) {\\n       auto it=lower_bound(mp[value].begin(),mp[value].end(),left);\\n       auto it1=upper_bound(mp[value].begin(),mp[value].end(),right);\\n       return it1-it;\\n    }",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "```\\nmap<int,vector<int>> mp;\\n    RangeFreqQuery(vector<int>& arr) {\\n       for(int i=0;i<arr.size();i++) mp[arr[i]].push_back(i);\\n    }\\n    int query(int left, int right, int value) {\\n       auto it=lower_bound(mp[value].begin(),mp[value].end(),left);\\n       auto it1=upper_bound(mp[value].begin(),mp[value].end(),right);\\n       return it1-it;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2077597,
                "title": "c-simple-4-line-solution",
                "content": "```\\nclass RangeFreqQuery {\\npublic:\\n    \\n    unordered_map<int,vector<int>> hash;\\n    \\n    RangeFreqQuery(vector<int>& arr) {\\n        for (int i = 0; i < arr.size(); ++i) hash[arr[i]].push_back(i);\\n    }\\n    int query(int left, int right, int value) {\\n        auto &current = hash[value];\\n        return current.size() - (lower_bound(current.begin(),current.end(),left) - current.begin()) - (current.end() - upper_bound(current.begin(),current.end(),right));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Hash Table",
                    "Binary Tree"
                ],
                "code": "```\\nclass RangeFreqQuery {\\npublic:\\n    \\n    unordered_map<int,vector<int>> hash;\\n    \\n    RangeFreqQuery(vector<int>& arr) {\\n        for (int i = 0; i < arr.size(); ++i) hash[arr[i]].push_back(i);\\n    }\\n    int query(int left, int right, int value) {\\n        auto &current = hash[value];\\n        return current.size() - (lower_bound(current.begin(),current.end(),left) - current.begin()) - (current.end() - upper_bound(current.begin(),current.end(),right));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2069047,
                "title": "java-binarysearch",
                "content": "```\\nclass RangeFreqQuery {\\n\\n    Map<Integer, List<Integer>> valueToIndicesMap;\\n    \\n    public RangeFreqQuery(int[] arr) {\\n        valueToIndicesMap = new HashMap<>();\\n        for (int i = 0; i < arr.length; i++) {\\n            List<Integer> indices = valueToIndicesMap.getOrDefault(arr[i], new ArrayList<>());\\n            indices.add(i);\\n            valueToIndicesMap.put(arr[i], indices);\\n        }\\n    }\\n    \\n    public int findFirstGreaterThan(List<Integer> indices, int i) {\\n        int low = 0, high = indices.size();\\n        while (low < high) {\\n            int mid = low + (high - low) / 2;\\n            if (indices.get(mid) > i) {\\n                high = mid;\\n            } else {\\n                low = mid + 1;\\n            }\\n        }\\n        return high;\\n    }\\n    \\n    public int query(int left, int right, int value) {\\n        List<Integer> indices = valueToIndicesMap.getOrDefault(value, new ArrayList<>());\\n        int countOfValueTillLeftMinusOne = findFirstGreaterThan(indices, left - 1);\\n        int countOfValueTillRight = findFirstGreaterThan(indices, right);\\n        return countOfValueTillRight - countOfValueTillLeftMinusOne;        \\n    }\\n}\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass RangeFreqQuery {\\n\\n    Map<Integer, List<Integer>> valueToIndicesMap;\\n    \\n    public RangeFreqQuery(int[] arr) {\\n        valueToIndicesMap = new HashMap<>();\\n        for (int i = 0; i < arr.length; i++) {\\n            List<Integer> indices = valueToIndicesMap.getOrDefault(arr[i], new ArrayList<>());\\n            indices.add(i);\\n            valueToIndicesMap.put(arr[i], indices);\\n        }\\n    }\\n    \\n    public int findFirstGreaterThan(List<Integer> indices, int i) {\\n        int low = 0, high = indices.size();\\n        while (low < high) {\\n            int mid = low + (high - low) / 2;\\n            if (indices.get(mid) > i) {\\n                high = mid;\\n            } else {\\n                low = mid + 1;\\n            }\\n        }\\n        return high;\\n    }\\n    \\n    public int query(int left, int right, int value) {\\n        List<Integer> indices = valueToIndicesMap.getOrDefault(value, new ArrayList<>());\\n        int countOfValueTillLeftMinusOne = findFirstGreaterThan(indices, left - 1);\\n        int countOfValueTillRight = findFirstGreaterThan(indices, right);\\n        return countOfValueTillRight - countOfValueTillLeftMinusOne;        \\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1887922,
                "title": "simple-solution-in-java-without-using-inbuilt-binary-search-function",
                "content": "```\\nclass RangeFreqQuery {\\n    private int[] arr;\\n    private HashMap<Integer, List<Integer>> map;\\n    \\n    public RangeFreqQuery(int[] arr) {\\n        this.arr = arr;\\n        this.map = new HashMap<>();\\n        \\n        for(int i=0; i<arr.length; i++){\\n            map.putIfAbsent(arr[i], new ArrayList<>());\\n            map.get(arr[i]).add(i);\\n        }\\n    }\\n    \\n    public int query(int left, int right, int value) {\\n        if(!map.containsKey(value)) return 0;\\n        \\n        List<Integer> li = map.get(value);\\n        if(li.get(li.size()-1) < left) return 0;\\n        \\n        int l = find(left, li); \\n        int r = find(right, li);\\n        \\n        if(l == r && li.get(l) != left && li.get(r) != right) return 0;\\n        if(r == li.size() || li.get(r) != right){ // Rightmost index not included \\n            return r - l;\\n        }\\n        return r - l + 1;\\n    }\\n    \\n    private int find(int val, List<Integer> li){\\n        if(li.get(li.size()-1) < val) return li.size();\\n        int l = 0;\\n        int r = li.size() - 1;\\n        \\n        while(l < r){\\n            int m = l + (r-l)/2;\\n            \\n            if(li.get(m) < val){\\n                l = m+1;\\n            }else r = m;\\n        }\\n        \\n        return l;\\n    }\\n}\\n\\n/**\\n * Your RangeFreqQuery object will be instantiated and called as such:\\n * RangeFreqQuery obj = new RangeFreqQuery(arr);\\n * int param_1 = obj.query(left,right,value);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass RangeFreqQuery {\\n    private int[] arr;\\n    private HashMap<Integer, List<Integer>> map;\\n    \\n    public RangeFreqQuery(int[] arr) {\\n        this.arr = arr;\\n        this.map = new HashMap<>();\\n        \\n        for(int i=0; i<arr.length; i++){\\n            map.putIfAbsent(arr[i], new ArrayList<>());\\n            map.get(arr[i]).add(i);\\n        }\\n    }\\n    \\n    public int query(int left, int right, int value) {\\n        if(!map.containsKey(value)) return 0;\\n        \\n        List<Integer> li = map.get(value);\\n        if(li.get(li.size()-1) < left) return 0;\\n        \\n        int l = find(left, li); \\n        int r = find(right, li);\\n        \\n        if(l == r && li.get(l) != left && li.get(r) != right) return 0;\\n        if(r == li.size() || li.get(r) != right){ // Rightmost index not included \\n            return r - l;\\n        }\\n        return r - l + 1;\\n    }\\n    \\n    private int find(int val, List<Integer> li){\\n        if(li.get(li.size()-1) < val) return li.size();\\n        int l = 0;\\n        int r = li.size() - 1;\\n        \\n        while(l < r){\\n            int m = l + (r-l)/2;\\n            \\n            if(li.get(m) < val){\\n                l = m+1;\\n            }else r = m;\\n        }\\n        \\n        return l;\\n    }\\n}\\n\\n/**\\n * Your RangeFreqQuery object will be instantiated and called as such:\\n * RangeFreqQuery obj = new RangeFreqQuery(arr);\\n * int param_1 = obj.query(left,right,value);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1703308,
                "title": "simple-binary-search-for-each-value-o-logn-query",
                "content": "For each value we just remember what positions we saw that number at. Then using lower (for left) and upper bound (for right) in each query, we could easily find how many points are in between.\\n```\\nclass RangeFreqQuery {\\npublic:\\n    vector<vector<int>> vec;\\n    RangeFreqQuery(vector<int>& arr) {\\n        vector<vector<int>>temp(100000);\\n        vec = temp;\\n        for(int i = 0; i < arr.size(); i++)\\n        {\\n            vec[arr[i]].push_back(i);\\n        }\\n    }\\n    \\n    int query(int left, int right, int value) {\\n        bool chk = vec[value].empty();\\n        if(chk)return 0;\\n        vector<int>&st = vec[value];\\n        auto it = lower_bound(st.begin(), st.end(), left);\\n        auto it2 = upper_bound(st.begin(), st.end(), right);\\n        return it2 - it;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass RangeFreqQuery {\\npublic:\\n    vector<vector<int>> vec;\\n    RangeFreqQuery(vector<int>& arr) {\\n        vector<vector<int>>temp(100000);\\n        vec = temp;\\n        for(int i = 0; i < arr.size(); i++)\\n        {\\n            vec[arr[i]].push_back(i);\\n        }\\n    }\\n    \\n    int query(int left, int right, int value) {\\n        bool chk = vec[value].empty();\\n        if(chk)return 0;\\n        vector<int>&st = vec[value];\\n        auto it = lower_bound(st.begin(), st.end(), left);\\n        auto it2 = upper_bound(st.begin(), st.end(), right);\\n        return it2 - it;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1672739,
                "title": "python-bisect-4-lines",
                "content": "```\\nclass RangeFreqQuery:\\n\\n    def __init__(self, arr: List[int]):\\n        self.D=collections.defaultdict(list)\\n        for i,val in enumerate(arr): self.D[val].append(i)\\n\\n    def query(self, left: int, right: int, value: int) -> int:\\n        l,r=bisect.bisect_left(self.D[value],left),bisect.bisect_right(self.D[value],right)\\n        return r-l\\n\\n# Your RangeFreqQuery object will be instantiated and called as such:\\n# obj = RangeFreqQuery(arr)\\n# param_1 = obj.query(left,right,value)\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass RangeFreqQuery:\\n\\n    def __init__(self, arr: List[int]):\\n        self.D=collections.defaultdict(list)\\n        for i,val in enumerate(arr): self.D[val].append(i)\\n\\n    def query(self, left: int, right: int, value: int) -> int:\\n        l,r=bisect.bisect_left(self.D[value],left),bisect.bisect_right(self.D[value],right)\\n        return r-l\\n\\n# Your RangeFreqQuery object will be instantiated and called as such:\\n# obj = RangeFreqQuery(arr)\\n# param_1 = obj.query(left,right,value)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1667948,
                "title": "2080-range-frequency-queries-binary-search-on-indices-easy-to-understand",
                "content": "```\\nclass RangeFreqQuery {\\npublic:\\n    static const int MAXN = 1e4 + 1;\\n    vector<int> pos[MAXN];\\n    RangeFreqQuery(vector<int>& arr) {\\n        for(int i = 0; i < arr.size(); i++) pos[arr[i]].push_back(i);\\n    }\\n    \\n    int query(int left, int right, int value) {\\n        int start = lower_bound(pos[value].begin(), pos[value].end(), left) - pos[value].begin();\\n        int end = upper_bound(pos[value].begin(), pos[value].end(), right) - pos[value].begin();\\n        --end;\\n        return end - start + 1;\\n    }\\n};\\n\\n/**\\n * Your RangeFreqQuery object will be instantiated and called as such:\\n * RangeFreqQuery* obj = new RangeFreqQuery(arr);\\n * int param_1 = obj->query(left,right,value);\\n */\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass RangeFreqQuery {\\npublic:\\n    static const int MAXN = 1e4 + 1;\\n    vector<int> pos[MAXN];\\n    RangeFreqQuery(vector<int>& arr) {\\n        for(int i = 0; i < arr.size(); i++) pos[arr[i]].push_back(i);\\n    }\\n    \\n    int query(int left, int right, int value) {\\n        int start = lower_bound(pos[value].begin(), pos[value].end(), left) - pos[value].begin();\\n        int end = upper_bound(pos[value].begin(), pos[value].end(), right) - pos[value].begin();\\n        --end;\\n        return end - start + 1;\\n    }\\n};\\n\\n/**\\n * Your RangeFreqQuery object will be instantiated and called as such:\\n * RangeFreqQuery* obj = new RangeFreqQuery(arr);\\n * int param_1 = obj->query(left,right,value);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1637197,
                "title": "cpp-code-using-segment-tree",
                "content": "```\\nclass RangeFreqQuery {\\npublic:\\n    map<int, int> tree[400001];\\n    \\n    void formTree(int lo, int hi, int ind, vector<int>&arr){\\n        if(lo == hi){\\n            tree[ind][arr[lo]] = 1;\\n            return;\\n        }\\n        int mid = (lo+hi)/2;\\n        \\n        formTree(lo, mid, 2*ind+1, arr);\\n        formTree(mid+1, hi, 2*ind+2, arr);\\n        \\n        tree[ind] = tree[2*ind+1];\\n        for(auto it: tree[2*ind+2]){\\n            tree[ind][it.first] += it.second;\\n        }\\n        \\n    }\\n    \\n    int n;\\n    \\n    RangeFreqQuery(vector<int>& arr) {\\n        n = arr.size();\\n        formTree(0, n, 0, arr);\\n    }\\n    \\n    int getAns(int lo, int hi, int ind, int left, int right, int val){\\n        if(lo > right) return 0;\\n        if(hi < left) return 0;\\n        if(lo >= left && hi <= right) return tree[ind][val];\\n        \\n        int mid = (lo+hi)/2;\\n        int ans = 0;\\n        ans += getAns(lo, mid, 2*ind+1, left, right, val);\\n        ans += getAns(mid+1, hi, 2*ind+2, left, right, val);\\n        \\n        return ans;\\n        \\n    }\\n    \\n    int query(int left, int right, int value) {\\n        return getAns(0, n, 0, left, right, value);\\n    }\\n};\\n\\n/**\\n * Your RangeFreqQuery object will be instantiated and called as such:\\n * RangeFreqQuery* obj = new RangeFreqQuery(arr);\\n * int param_1 = obj->query(left,right,value);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree"
                ],
                "code": "```\\nclass RangeFreqQuery {\\npublic:\\n    map<int, int> tree[400001];\\n    \\n    void formTree(int lo, int hi, int ind, vector<int>&arr){\\n        if(lo == hi){\\n            tree[ind][arr[lo]] = 1;\\n            return;\\n        }\\n        int mid = (lo+hi)/2;\\n        \\n        formTree(lo, mid, 2*ind+1, arr);\\n        formTree(mid+1, hi, 2*ind+2, arr);\\n        \\n        tree[ind] = tree[2*ind+1];\\n        for(auto it: tree[2*ind+2]){\\n            tree[ind][it.first] += it.second;\\n        }\\n        \\n    }\\n    \\n    int n;\\n    \\n    RangeFreqQuery(vector<int>& arr) {\\n        n = arr.size();\\n        formTree(0, n, 0, arr);\\n    }\\n    \\n    int getAns(int lo, int hi, int ind, int left, int right, int val){\\n        if(lo > right) return 0;\\n        if(hi < left) return 0;\\n        if(lo >= left && hi <= right) return tree[ind][val];\\n        \\n        int mid = (lo+hi)/2;\\n        int ans = 0;\\n        ans += getAns(lo, mid, 2*ind+1, left, right, val);\\n        ans += getAns(mid+1, hi, 2*ind+2, left, right, val);\\n        \\n        return ans;\\n        \\n    }\\n    \\n    int query(int left, int right, int value) {\\n        return getAns(0, n, 0, left, right, value);\\n    }\\n};\\n\\n/**\\n * Your RangeFreqQuery object will be instantiated and called as such:\\n * RangeFreqQuery* obj = new RangeFreqQuery(arr);\\n * int param_1 = obj->query(left,right,value);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1603103,
                "title": "python-binary-search-with-implementation-of-bisect-left-and-bisect-right",
                "content": "```\\nclass RangeFreqQuery:\\n\\n    def __init__(self, arr: List[int]):\\n        self.seen = defaultdict(list)\\n        for i, num in enumerate(arr):\\n            self.seen[num].append(i)        \\n\\n    def query(self, left: int, right: int, value: int) -> int:\\n        arr = self.seen[value]\\n        # binary search for left and right\\n        # need to know the implement of bisect_left and bisect_right\\n\\n        left_idx = self.bsect_left(arr, left)\\n        right_idx = self.bsect_right(arr, right)\\n        \\n        return right_idx - left_idx\\n        \\n    def bsect_right(self, arr, target):\\n        l, h = 0, len(arr) - 1\\n        \\n        while l <= h:\\n            mid = l + (h - l) // 2\\n            if arr[mid] == target:\\n                l = mid + 1\\n            if arr[mid] < target:\\n                l = mid + 1\\n            elif arr[mid] > target:\\n                h = mid - 1\\n        return l\\n    \\n    def bsect_left(self, arr, target):\\n        l, h = 0, len(arr) - 1\\n        \\n        while l <= h:\\n            mid = l + (h - l) // 2\\n            if arr[mid] == target:\\n                h = mid - 1\\n            if arr[mid] < target:\\n                l = mid + 1\\n            elif arr[mid] > target:\\n                h = mid - 1\\n        return l\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass RangeFreqQuery:\\n\\n    def __init__(self, arr: List[int]):\\n        self.seen = defaultdict(list)\\n        for i, num in enumerate(arr):\\n            self.seen[num].append(i)        \\n\\n    def query(self, left: int, right: int, value: int) -> int:\\n        arr = self.seen[value]\\n        # binary search for left and right\\n        # need to know the implement of bisect_left and bisect_right\\n\\n        left_idx = self.bsect_left(arr, left)\\n        right_idx = self.bsect_right(arr, right)\\n        \\n        return right_idx - left_idx\\n        \\n    def bsect_right(self, arr, target):\\n        l, h = 0, len(arr) - 1\\n        \\n        while l <= h:\\n            mid = l + (h - l) // 2\\n            if arr[mid] == target:\\n                l = mid + 1\\n            if arr[mid] < target:\\n                l = mid + 1\\n            elif arr[mid] > target:\\n                h = mid - 1\\n        return l\\n    \\n    def bsect_left(self, arr, target):\\n        l, h = 0, len(arr) - 1\\n        \\n        while l <= h:\\n            mid = l + (h - l) // 2\\n            if arr[mid] == target:\\n                h = mid - 1\\n            if arr[mid] < target:\\n                l = mid + 1\\n            elif arr[mid] > target:\\n                h = mid - 1\\n        return l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1603006,
                "title": "java-treemap-solution-with-o-n-space",
                "content": "Use TreeMaps to keep the frequency of each number so that each query can be answered in logarithmic time.\\n\\nTime Complexity :\\n\\nQuery : `O(log M)`\\nWhere M is the number of occurences of the value being queried in the orignal array.\\n\\nInitialization : `O(N log M)`\\nFor a array of length N and the maximum occurence of M, the time complexity will be bounded by O(N log M) as the worst case time for each iteration is bounded by `O(log M)`.\\n\\nSpace Complexity : `O (N)`\\n\\n```\\nclass RangeFreqQuery {\\n    \\n    HashMap<Integer, TreeMap<Integer, Integer>> indexMap;\\n\\n    public RangeFreqQuery(int[] arr) {\\n        \\n        // temporary map to keep track of the frequency of each number from the index 0.\\n        HashMap<Integer, Integer> frequency = new HashMap<>();\\n        \\n        indexMap = new HashMap<>();\\n        \\n        for (int index = 0; index < arr.length; index++) {\\n            \\n            int value = arr[index];\\n            \\n            // calculate the new frequency\\n            int updatedFreq = frequency.getOrDefault(value, 0) + 1;\\n            \\n            // set it in the temporary map\\n            frequency.put(value, updatedFreq);\\n            \\n            // update the frequency in the treemap of the corresponding value\\n            indexMap.computeIfAbsent(value, k -> new TreeMap<>()).put(index, updatedFreq);\\n        }\\n    }\\n    \\n    public int query(int left, int right, int value) {\\n        \\n        // get the treeMap for the value\\n        TreeMap<Integer, Integer> valueMap = indexMap.get(value);\\n        \\n        // value is not present in the orignal array itself\\n        if (valueMap == null) {\\n            return 0;\\n        }\\n        \\n        // get the frequency until index right\\n        Map.Entry<Integer, Integer> rightMap = valueMap.floorEntry(right);\\n        \\n        // value does not occure until index right\\n        if (rightMap == null) {\\n            return 0;\\n        }\\n        \\n        // get the frequency until index left\\n        Map.Entry<Integer, Integer> leftMap = valueMap.floorEntry(left-1);\\n        \\n        int total = rightMap.getValue();\\n        \\n        // value does not occur until index left\\n        if (leftMap == null) {\\n            return total;\\n        }\\n        \\n        // return the difference\\n        return total - leftMap.getValue();\\n    }\\n}\\n\\n/**\\n * Your RangeFreqQuery object will be instantiated and called as such:\\n * RangeFreqQuery obj = new RangeFreqQuery(arr);\\n * int param_1 = obj.query(left,right,value);\\n */\\n ```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\nclass RangeFreqQuery {\\n    \\n    HashMap<Integer, TreeMap<Integer, Integer>> indexMap;\\n\\n    public RangeFreqQuery(int[] arr) {\\n        \\n        // temporary map to keep track of the frequency of each number from the index 0.\\n        HashMap<Integer, Integer> frequency = new HashMap<>();\\n        \\n        indexMap = new HashMap<>();\\n        \\n        for (int index = 0; index < arr.length; index++) {\\n            \\n            int value = arr[index];\\n            \\n            // calculate the new frequency\\n            int updatedFreq = frequency.getOrDefault(value, 0) + 1;\\n            \\n            // set it in the temporary map\\n            frequency.put(value, updatedFreq);\\n            \\n            // update the frequency in the treemap of the corresponding value\\n            indexMap.computeIfAbsent(value, k -> new TreeMap<>()).put(index, updatedFreq);\\n        }\\n    }\\n    \\n    public int query(int left, int right, int value) {\\n        \\n        // get the treeMap for the value\\n        TreeMap<Integer, Integer> valueMap = indexMap.get(value);\\n        \\n        // value is not present in the orignal array itself\\n        if (valueMap == null) {\\n            return 0;\\n        }\\n        \\n        // get the frequency until index right\\n        Map.Entry<Integer, Integer> rightMap = valueMap.floorEntry(right);\\n        \\n        // value does not occure until index right\\n        if (rightMap == null) {\\n            return 0;\\n        }\\n        \\n        // get the frequency until index left\\n        Map.Entry<Integer, Integer> leftMap = valueMap.floorEntry(left-1);\\n        \\n        int total = rightMap.getValue();\\n        \\n        // value does not occur until index left\\n        if (leftMap == null) {\\n            return total;\\n        }\\n        \\n        // return the difference\\n        return total - leftMap.getValue();\\n    }\\n}\\n\\n/**\\n * Your RangeFreqQuery object will be instantiated and called as such:\\n * RangeFreqQuery obj = new RangeFreqQuery(arr);\\n * int param_1 = obj.query(left,right,value);\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1601031,
                "title": "80-fast-o-logn",
                "content": "class RangeFreqQuery {\\npublic:\\n    \\n    \\n    unordered_map<int,vector<int> > mp;\\n    \\n    RangeFreqQuery(vector<int>& arr) {\\n        \\n        for(int i=0;i<arr.size();i++){\\n            mp[arr[i]].push_back(i);\\n        }\\n        \\n    }\\n    \\n    int query(int l, int r, int v) {\\n        \\n        if(mp.count(v)==0)return 0;\\n        \\n        int n=mp[v].size();\\n        int b=mp[v][0],e=mp[v][n-1];\\n        \\n        if(l>e || r<b)return 0;\\n       \\n        auto f=lower_bound(mp[v].begin(),mp[v].end(),l);\\n        auto s=lower_bound(mp[v].begin(),mp[v].end(),r);\\n        int j=s-mp[v].begin(),i=f-mp[v].begin();\\n        \\n        if(j==n)return n-i;\\n        if(*s==r)return j-i+1;\\n        else if(r<*s)return j-i;\\n        else return 0;\\n        \\n    }\\n};\\n\\n/**\\n * Your RangeFreqQuery object will be instantiated and called as such:\\n * RangeFreqQuery* obj = new RangeFreqQuery(arr);\\n * int param_1 = obj->query(left,right,value);\\n */",
                "solutionTags": [],
                "code": "class RangeFreqQuery {\\npublic:\\n    \\n    \\n    unordered_map<int,vector<int> > mp;\\n    \\n    RangeFreqQuery(vector<int>& arr) {\\n        \\n        for(int i=0;i<arr.size();i++){\\n            mp[arr[i]].push_back(i);\\n        }\\n        \\n    }\\n    \\n    int query(int l, int r, int v) {\\n        \\n        if(mp.count(v)==0)return 0;\\n        \\n        int n=mp[v].size();\\n        int b=mp[v][0],e=mp[v][n-1];\\n        \\n        if(l>e || r<b)return 0;\\n       \\n        auto f=lower_bound(mp[v].begin(),mp[v].end(),l);\\n        auto s=lower_bound(mp[v].begin(),mp[v].end(),r);\\n        int j=s-mp[v].begin(),i=f-mp[v].begin();\\n        \\n        if(j==n)return n-i;\\n        if(*s==r)return j-i+1;\\n        else if(r<*s)return j-i;\\n        else return 0;\\n        \\n    }\\n};\\n\\n/**\\n * Your RangeFreqQuery object will be instantiated and called as such:\\n * RangeFreqQuery* obj = new RangeFreqQuery(arr);\\n * int param_1 = obj->query(left,right,value);\\n */",
                "codeTag": "Java"
            },
            {
                "id": 1592697,
                "title": "java-binary-indexed-tree-segment-tree-o-nlogn-detailed-explanation",
                "content": "The binary search idea is excellent, here I post another two solutions - bianry indexed tree and segment tree:\\n\\n1. Segment Tree - The idea is trival, iterate the arr to build the segTree, for each segTree node we have 5 attributes: a st index and an end index\\nrepresent the index range of the node, a left segNode and a right segNode, and a hasmap storing all numbers\\' frequency with their indexes ranging from st to end. For how to build the segment tree and how to query the tree you may study it yourself.\\n```\\nclass RangeFreqQuery {\\n    seg root;\\n    public RangeFreqQuery(int[] arr) {\\n        root = new seg(0, arr.length - 1);\\n        for (int i = 0; i < arr.length; i++) {\\n            root.insert(i, arr[i]);\\n        }\\n    }\\n    \\n    public int query(int left, int right, int value) {\\n        return root.find(left, right, value);\\n    }\\n    \\n    class seg {\\n        Map<Integer, Integer> map;\\n        int st;\\n        int end;\\n        seg left;\\n        seg right;\\n        public seg(int st, int end) {\\n            this.st = st;\\n            this.end = end;\\n            map = new HashMap();\\n        }\\n        public void insert(int i, int value) {\\n            map.put(value, map.getOrDefault(value, 0) + 1);\\n            if (st == end) return;\\n            int mid = (st + end) >> 1;\\n            if (i <= mid) {\\n                if (left == null) this.left = new seg(st, mid);\\n                this.left.insert(i, value);\\n            } else {\\n                if (right == null) this.right = new seg(mid + 1, end);\\n                this.right.insert(i, value);\\n            }\\n        }\\n        public int find(int l, int r, int value) {\\n            if (l == st && r == end) return map.getOrDefault(value, 0);\\n            int mid = (st + end) >> 1;\\n            if (mid >= r) {\\n                return left.find(l, r, value);\\n            } else if (mid < l) {\\n                return right.find(l, r, value);\\n            } else {\\n                return left.find(l, mid, value) + right.find(mid + 1, r, value);\\n            }\\n        }\\n    }\\n}\\n\\n/**\\n * Your RangeFreqQuery object will be instantiated and called as such:\\n * RangeFreqQuery obj = new RangeFreqQuery(arr);\\n * int param_1 = obj.query(left,right,value);\\n */\\n```\\n2. Binary Indexed Tree - Same idea, but the data structure here saves a lot spaces comparing to segment tree, as we only maintaining number of O(N) hashmaps, where segment tree need O(2N) segNode (that is O(2N) hashmaps)\\n```\\nclass RangeFreqQuery {\\n    Map<Integer, Integer> maps[];\\n    public RangeFreqQuery(int[] arr) {\\n        maps = new HashMap[arr.length];\\n        for (int i = 0; i < arr.length; i++) {\\n            insert(arr[i], i);\\n        }\\n    }\\n    \\n    public void insert(int num, int index) {\\n        while (index <= maps.length - 1) {\\n            if (maps[index] == null) maps[index] = new HashMap();\\n            maps[index].put(num, maps[index].getOrDefault(num, 0) + 1);\\n            index += lowbit(index + 1);\\n        }\\n    }\\n    \\n    public int lowbit(int n) {\\n        return (~n + 1) & n;\\n    }\\n    \\n    public int query(int left, int right, int value) {\\n        return find(value, right) - find(value, left - 1);\\n    }\\n    \\n    public int find(int value, int index) {\\n        if (index < 0) return 0;\\n        int count = 0;\\n        while (index >= 0) {\\n            count += maps[index].getOrDefault(value, 0);\\n            index -= lowbit(index + 1);\\n        }\\n        return count;\\n    }\\n}\\n\\n/**\\n * Your RangeFreqQuery object will be instantiated and called as such:\\n * RangeFreqQuery obj = new RangeFreqQuery(arr);\\n * int param_1 = obj.query(left,right,value);\\n */\\n```",
                "solutionTags": [
                    "Tree",
                    "Binary Indexed Tree"
                ],
                "code": "```\\nclass RangeFreqQuery {\\n    seg root;\\n    public RangeFreqQuery(int[] arr) {\\n        root = new seg(0, arr.length - 1);\\n        for (int i = 0; i < arr.length; i++) {\\n            root.insert(i, arr[i]);\\n        }\\n    }\\n    \\n    public int query(int left, int right, int value) {\\n        return root.find(left, right, value);\\n    }\\n    \\n    class seg {\\n        Map<Integer, Integer> map;\\n        int st;\\n        int end;\\n        seg left;\\n        seg right;\\n        public seg(int st, int end) {\\n            this.st = st;\\n            this.end = end;\\n            map = new HashMap();\\n        }\\n        public void insert(int i, int value) {\\n            map.put(value, map.getOrDefault(value, 0) + 1);\\n            if (st == end) return;\\n            int mid = (st + end) >> 1;\\n            if (i <= mid) {\\n                if (left == null) this.left = new seg(st, mid);\\n                this.left.insert(i, value);\\n            } else {\\n                if (right == null) this.right = new seg(mid + 1, end);\\n                this.right.insert(i, value);\\n            }\\n        }\\n        public int find(int l, int r, int value) {\\n            if (l == st && r == end) return map.getOrDefault(value, 0);\\n            int mid = (st + end) >> 1;\\n            if (mid >= r) {\\n                return left.find(l, r, value);\\n            } else if (mid < l) {\\n                return right.find(l, r, value);\\n            } else {\\n                return left.find(l, mid, value) + right.find(mid + 1, r, value);\\n            }\\n        }\\n    }\\n}\\n\\n/**\\n * Your RangeFreqQuery object will be instantiated and called as such:\\n * RangeFreqQuery obj = new RangeFreqQuery(arr);\\n * int param_1 = obj.query(left,right,value);\\n */\\n```\n```\\nclass RangeFreqQuery {\\n    Map<Integer, Integer> maps[];\\n    public RangeFreqQuery(int[] arr) {\\n        maps = new HashMap[arr.length];\\n        for (int i = 0; i < arr.length; i++) {\\n            insert(arr[i], i);\\n        }\\n    }\\n    \\n    public void insert(int num, int index) {\\n        while (index <= maps.length - 1) {\\n            if (maps[index] == null) maps[index] = new HashMap();\\n            maps[index].put(num, maps[index].getOrDefault(num, 0) + 1);\\n            index += lowbit(index + 1);\\n        }\\n    }\\n    \\n    public int lowbit(int n) {\\n        return (~n + 1) & n;\\n    }\\n    \\n    public int query(int left, int right, int value) {\\n        return find(value, right) - find(value, left - 1);\\n    }\\n    \\n    public int find(int value, int index) {\\n        if (index < 0) return 0;\\n        int count = 0;\\n        while (index >= 0) {\\n            count += maps[index].getOrDefault(value, 0);\\n            index -= lowbit(index + 1);\\n        }\\n        return count;\\n    }\\n}\\n\\n/**\\n * Your RangeFreqQuery object will be instantiated and called as such:\\n * RangeFreqQuery obj = new RangeFreqQuery(arr);\\n * int param_1 = obj.query(left,right,value);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1592256,
                "title": "c-1300-ms-dictionary-of-lists-binary-search-the-correct-list-for-each-query",
                "content": "Dictionary contains a list for each integer. Each list contains the indexes of that integer. BinarySearch the appropriate list for left and right; the count is subtraction.\\n\\n\\n```\\n\\npublic class RangeFreqQuery {\\n\\n    Dictionary<int, List<int>> freq;\\n    \\n    public RangeFreqQuery(int[] arr) {\\n        \\n        freq = new Dictionary<int, List<int>>();\\n        \\n        for(int i = 0; i < arr.Length; i++){\\n            if(!freq.ContainsKey(arr[i])){\\n                freq[arr[i]] = new List<int>();\\n            }\\n            freq[arr[i]].Add(i);\\n        }\\n    }\\n    \\n    public int Query(int left, int right, int value) {\\n        \\n        List<int> list;\\n        if(!freq.TryGetValue(value, out list)) return 0;\\n        \\n        int leftIndex = list.BinarySearch(left);\\n        if(leftIndex < 0) leftIndex = ~leftIndex;\\n        \\n        int rightIndex = list.BinarySearch(right);\\n        if(rightIndex < 0) rightIndex = ~rightIndex - 1;\\n        \\n        return rightIndex - leftIndex + 1;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\n\\npublic class RangeFreqQuery {\\n\\n    Dictionary<int, List<int>> freq;\\n    \\n    public RangeFreqQuery(int[] arr) {\\n        \\n        freq = new Dictionary<int, List<int>>();\\n        \\n        for(int i = 0; i < arr.Length; i++){\\n            if(!freq.ContainsKey(arr[i])){\\n                freq[arr[i]] = new List<int>();\\n            }\\n            freq[arr[i]].Add(i);\\n        }\\n    }\\n    \\n    public int Query(int left, int right, int value) {\\n        \\n        List<int> list;\\n        if(!freq.TryGetValue(value, out list)) return 0;\\n        \\n        int leftIndex = list.BinarySearch(left);\\n        if(leftIndex < 0) leftIndex = ~leftIndex;\\n        \\n        int rightIndex = list.BinarySearch(right);\\n        if(rightIndex < 0) rightIndex = ~rightIndex - 1;\\n        \\n        return rightIndex - leftIndex + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1590662,
                "title": "go-solution-with-hash-and-binary-search",
                "content": "```\\nimport \"sort\"\\n\\n\\ntype RangeFreqQuery struct {\\n    cache map[int][]int\\n}\\n\\n\\nfunc Constructor(arr []int) RangeFreqQuery {\\n    this:=RangeFreqQuery{cache:make(map[int][]int)}\\n    for i,e := range arr {\\n        if _,ok := this.cache[e]; !ok {\\n            this.cache[e] = []int{i}\\n        } else {\\n            this.cache[e] = append(this.cache[e],i)\\n        }\\n    }\\n    return this\\n}\\n\\n\\nfunc (this *RangeFreqQuery) Query(left int, right int, value int) int {\\n    if val,ok := this.cache[value]; ok {\\n        lower := sort.Search(len(val), func (i int) bool { return val[i] >= left} )\\n        upper := sort.Search(len(val), func (i int) bool { return val[i] > right} )\\n        return upper - lower\\n    }\\n    return 0\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nimport \"sort\"\\n\\n\\ntype RangeFreqQuery struct {\\n    cache map[int][]int\\n}\\n\\n\\nfunc Constructor(arr []int) RangeFreqQuery {\\n    this:=RangeFreqQuery{cache:make(map[int][]int)}\\n    for i,e := range arr {\\n        if _,ok := this.cache[e]; !ok {\\n            this.cache[e] = []int{i}\\n        } else {\\n            this.cache[e] = append(this.cache[e],i)\\n        }\\n    }\\n    return this\\n}\\n\\n\\nfunc (this *RangeFreqQuery) Query(left int, right int, value int) int {\\n    if val,ok := this.cache[value]; ok {\\n        lower := sort.Search(len(val), func (i int) bool { return val[i] >= left} )\\n        upper := sort.Search(len(val), func (i int) bool { return val[i] > right} )\\n        return upper - lower\\n    }\\n    return 0\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1590595,
                "title": "python-binary-search-implmentation",
                "content": "\\tclass RangeFreqQuery(object):\\n\\n\\t\\tdef __init__(self, arr):\\n\\t\\t\\t\"\"\"\\n\\t\\t\\t:type arr: List[int]\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tself.maps = collections.defaultdict(list)\\n\\t\\t\\tfor i in range(len(arr)):\\n\\t\\t\\t\\tself.maps[arr[i]].append(i)\\n\\n\\n\\t\\tdef query(self, left, right, val):\\n\\t\\t\\t\"\"\"\\n\\t\\t\\t:type left: int\\n\\t\\t\\t:type right: int\\n\\t\\t\\t:type value: int\\n\\t\\t\\t:rtype: int\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tif val not in self.maps: return 0\\n\\t\\t\\tarr = self.maps[val]\\n\\t\\t\\tres = 0\\n\\t\\t\\ti, j = self.binary_search(left, arr), self.binary_search(right, arr)\\n\\t\\t\\tif j == len(arr): return  j - i\\n\\t\\t\\tif arr[j] == right: j += 1\\n\\t\\t\\treturn j - i\\n\\n\\n\\n\\n\\t\\tdef binary_search(self, target, arr):\\n\\t\\t\\tleft, right = 0, len(arr) \\n\\t\\t\\twhile left < right:\\n\\t\\t\\t\\tmid = (left + right) / 2\\n\\t\\t\\t\\tif arr[mid] >= target:\\n\\t\\t\\t\\t\\tright = mid\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tleft = mid + 1\\n\\t\\t\\treturn left",
                "solutionTags": [],
                "code": "\\tclass RangeFreqQuery(object):\\n\\n\\t\\tdef __init__(self, arr):\\n\\t\\t\\t\"\"\"\\n\\t\\t\\t:type arr: List[int]\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tself.maps = collections.defaultdict(list)\\n\\t\\t\\tfor i in range(len(arr)):\\n\\t\\t\\t\\tself.maps[arr[i]].append(i)\\n\\n\\n\\t\\tdef query(self, left, right, val):\\n\\t\\t\\t\"\"\"\\n\\t\\t\\t:type left: int\\n\\t\\t\\t:type right: int\\n\\t\\t\\t:type value: int\\n\\t\\t\\t:rtype: int\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tif val not in self.maps: return 0\\n\\t\\t\\tarr = self.maps[val]\\n\\t\\t\\tres = 0\\n\\t\\t\\ti, j = self.binary_search(left, arr), self.binary_search(right, arr)\\n\\t\\t\\tif j == len(arr): return  j - i\\n\\t\\t\\tif arr[j] == right: j += 1\\n\\t\\t\\treturn j - i\\n\\n\\n\\n\\n\\t\\tdef binary_search(self, target, arr):\\n\\t\\t\\tleft, right = 0, len(arr) \\n\\t\\t\\twhile left < right:\\n\\t\\t\\t\\tmid = (left + right) / 2\\n\\t\\t\\t\\tif arr[mid] >= target:\\n\\t\\t\\t\\t\\tright = mid\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tleft = mid + 1\\n\\t\\t\\treturn left",
                "codeTag": "Java"
            },
            {
                "id": 1590327,
                "title": "python-o-log-n-binary-search",
                "content": "```\\nclass RangeFreqQuery:\\n\\n    def __init__(self, arr: List[int]):\\n        self.hashmap = collections.defaultdict(list)\\n        for i in range(len(arr)):\\n            self.hashmap[arr[i]].append(i)\\n        \\n\\n    def query(self, left: int, right: int, value: int) -> int:\\n    \\n        target = self.hashmap[value]\\n        low = 0\\n        high = len(target)-1\\n        first=-1\\n        second=-1\\n        while low <= high:\\n            mid = (low+high)//2\\n            if target[mid]>=left:\\n                first=mid\\n                high=mid-1\\n            else:\\n                low=mid+1\\n        \\n        low = 0\\n        high = len(target)-1\\n        while low <= high:\\n            mid = (low+high)//2\\n            if target[mid]<=right:\\n                second=mid\\n                low=mid+1\\n            else:\\n                high=mid-1\\n        \\n        if first == -1 or second == -1:return 0\\n        return second-first+1\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass RangeFreqQuery:\\n\\n    def __init__(self, arr: List[int]):\\n        self.hashmap = collections.defaultdict(list)\\n        for i in range(len(arr)):\\n            self.hashmap[arr[i]].append(i)\\n        \\n\\n    def query(self, left: int, right: int, value: int) -> int:\\n    \\n        target = self.hashmap[value]\\n        low = 0\\n        high = len(target)-1\\n        first=-1\\n        second=-1\\n        while low <= high:\\n            mid = (low+high)//2\\n            if target[mid]>=left:\\n                first=mid\\n                high=mid-1\\n            else:\\n                low=mid+1\\n        \\n        low = 0\\n        high = len(target)-1\\n        while low <= high:\\n            mid = (low+high)//2\\n            if target[mid]<=right:\\n                second=mid\\n                low=mid+1\\n            else:\\n                high=mid-1\\n        \\n        if first == -1 or second == -1:return 0\\n        return second-first+1\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1590244,
                "title": "simple-c",
                "content": "Build hashmap cost O(n)\\n\\ndo each query cost log n\\n\\n```\\nclass RangeFreqQuery {\\npublic:\\n    RangeFreqQuery(vector<int>& arr) {\\n        for(int i = 0; i < arr.size(); i++) {\\n            m[arr[i]].push_back(i);\\n        }\\n    }\\n    \\n    int query(int left, int right, int value) {        \\n        return upper_bound(m[value].begin(), m[value].end(), right) - lower_bound(m[value].begin(), m[value].end(), left);\\n    }\\n    \\n    unordered_map<int, vector<int>> m;\\n};\\n\\n/**\\n * Your RangeFreqQuery object will be instantiated and called as such:\\n * RangeFreqQuery* obj = new RangeFreqQuery(arr);\\n * int param_1 = obj->query(left,right,value);\\n */\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass RangeFreqQuery {\\npublic:\\n    RangeFreqQuery(vector<int>& arr) {\\n        for(int i = 0; i < arr.size(); i++) {\\n            m[arr[i]].push_back(i);\\n        }\\n    }\\n    \\n    int query(int left, int right, int value) {        \\n        return upper_bound(m[value].begin(), m[value].end(), right) - lower_bound(m[value].begin(), m[value].end(), left);\\n    }\\n    \\n    unordered_map<int, vector<int>> m;\\n};\\n\\n/**\\n * Your RangeFreqQuery object will be instantiated and called as such:\\n * RangeFreqQuery* obj = new RangeFreqQuery(arr);\\n * int param_1 = obj->query(left,right,value);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1589938,
                "title": "java-solution-using-hashmap-o-n",
                "content": "```\\nclass RangeFreqQuery {\\n\\n    private int[] a;\\n    private Map<List<Integer>,Integer> m=new HashMap<>();\\n    public RangeFreqQuery(int[] arr) {\\n        this.a=arr;\\n    }\\n    \\n    public int query(int left, int right, int value) {\\n        int count=0;\\n        List<Integer> l=new ArrayList<>();\\n        l.add(left);\\n        l.add(right);\\n        l.add(value);\\n        if(m.containsKey(l)) return m.get(l);\\n        else{\\n             for(int i=left;i<=right;i++){\\n            if(value==this.a[i]) count++;\\n        }\\n            m.put(l,count);\\n        return count;\\n        }\\n    }\\n}\\n\\n/**\\n * Your RangeFreqQuery object will be instantiated and called as such:\\n * RangeFreqQuery obj = new RangeFreqQuery(arr);\\n * int param_1 = obj.query(left,right,value);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass RangeFreqQuery {\\n\\n    private int[] a;\\n    private Map<List<Integer>,Integer> m=new HashMap<>();\\n    public RangeFreqQuery(int[] arr) {\\n        this.a=arr;\\n    }\\n    \\n    public int query(int left, int right, int value) {\\n        int count=0;\\n        List<Integer> l=new ArrayList<>();\\n        l.add(left);\\n        l.add(right);\\n        l.add(value);\\n        if(m.containsKey(l)) return m.get(l);\\n        else{\\n             for(int i=left;i<=right;i++){\\n            if(value==this.a[i]) count++;\\n        }\\n            m.put(l,count);\\n        return count;\\n        }\\n    }\\n}\\n\\n/**\\n * Your RangeFreqQuery object will be instantiated and called as such:\\n * RangeFreqQuery obj = new RangeFreqQuery(arr);\\n * int param_1 = obj.query(left,right,value);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1589901,
                "title": "c-concise",
                "content": "```\\nclass RangeFreqQuery {\\npublic:\\n    RangeFreqQuery(vector<int>& arr) {\\n        for(int i = 0; i < arr.size(); ++i) {\\n            map[arr[i]].push_back(i);\\n        }\\n    }\\n    \\n    int query(int left, int right, int value) {\\n        auto l = lower_bound(map[value].begin(), map[value].end(), left);\\n        auto r = upper_bound(map[value].begin(), map[value].end(), right);\\n        return r - l;\\n    }\\nprivate:\\n    unordered_map<int, vector<int>> map;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass RangeFreqQuery {\\npublic:\\n    RangeFreqQuery(vector<int>& arr) {\\n        for(int i = 0; i < arr.size(); ++i) {\\n            map[arr[i]].push_back(i);\\n        }\\n    }\\n    \\n    int query(int left, int right, int value) {\\n        auto l = lower_bound(map[value].begin(), map[value].end(), left);\\n        auto r = upper_bound(map[value].begin(), map[value].end(), right);\\n        return r - l;\\n    }\\nprivate:\\n    unordered_map<int, vector<int>> map;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1589864,
                "title": "golang-solution-without-binary-search",
                "content": "```go\\n// binary search solution is much more faster :)\\ntype RangeFreqQuery struct {\\n\\tarr   []int\\n\\tmagic [][]int\\n}\\n\\nfunc Constructor(arr []int) RangeFreqQuery {\\n\\tmagic := make([][]int, 0)\\n\\tcounter := make([]int, 10001)\\n\\tfor i, v := range arr {\\n\\t\\tcounter[v]++\\n\\t\\tif i % 100 == 0 {\\n\\t\\t\\tcounterCopy := make([]int, 10001)\\n\\t\\t\\tcopy(counterCopy, counter)\\n\\t\\t\\tmagic = append(magic, counterCopy)\\n\\t\\t}\\n\\t}\\n\\treturn RangeFreqQuery{\\n\\t\\tarr:   arr,\\n\\t\\tmagic: magic,\\n\\t}\\n}\\n\\nfunc (rfq *RangeFreqQuery) Query(left int, right int, value int) int {\\n\\tif right-left <= 100 {\\n\\t\\tfreq := 0\\n\\t\\tfor i := left; i <= right; i++ {\\n\\t\\t\\tif rfq.arr[i] == value {\\n\\t\\t\\t\\tfreq++\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn freq\\n\\t}\\n\\tinitialFreq := rfq.magic[right/100][value]\\n\\tfor i := right/100*100+1; i <= right; i++ {\\n\\t\\tif rfq.arr[i] == value {\\n\\t\\t\\tinitialFreq++\\n\\t\\t}\\n\\t}\\n\\tif initialFreq == 0 {\\n\\t\\treturn 0\\n\\t}\\n\\tmoreFreq := rfq.magic[left/100][value]\\n\\tfor i := left/100*100+1; i < left; i++ {\\n\\t\\tif rfq.arr[i] == value {\\n\\t\\t\\tmoreFreq++\\n\\t\\t}\\n\\t}\\n\\tif left/100*100 == left {\\n\\t\\tif rfq.arr[left] == value {\\n\\t\\t\\tmoreFreq--\\n\\t\\t}\\n\\t}\\n\\treturn initialFreq-moreFreq\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\n// binary search solution is much more faster :)\\ntype RangeFreqQuery struct {\\n\\tarr   []int\\n\\tmagic [][]int\\n}\\n\\nfunc Constructor(arr []int) RangeFreqQuery {\\n\\tmagic := make([][]int, 0)\\n\\tcounter := make([]int, 10001)\\n\\tfor i, v := range arr {\\n\\t\\tcounter[v]++\\n\\t\\tif i % 100 == 0 {\\n\\t\\t\\tcounterCopy := make([]int, 10001)\\n\\t\\t\\tcopy(counterCopy, counter)\\n\\t\\t\\tmagic = append(magic, counterCopy)\\n\\t\\t}\\n\\t}\\n\\treturn RangeFreqQuery{\\n\\t\\tarr:   arr,\\n\\t\\tmagic: magic,\\n\\t}\\n}\\n\\nfunc (rfq *RangeFreqQuery) Query(left int, right int, value int) int {\\n\\tif right-left <= 100 {\\n\\t\\tfreq := 0\\n\\t\\tfor i := left; i <= right; i++ {\\n\\t\\t\\tif rfq.arr[i] == value {\\n\\t\\t\\t\\tfreq++\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn freq\\n\\t}\\n\\tinitialFreq := rfq.magic[right/100][value]\\n\\tfor i := right/100*100+1; i <= right; i++ {\\n\\t\\tif rfq.arr[i] == value {\\n\\t\\t\\tinitialFreq++\\n\\t\\t}\\n\\t}\\n\\tif initialFreq == 0 {\\n\\t\\treturn 0\\n\\t}\\n\\tmoreFreq := rfq.magic[left/100][value]\\n\\tfor i := left/100*100+1; i < left; i++ {\\n\\t\\tif rfq.arr[i] == value {\\n\\t\\t\\tmoreFreq++\\n\\t\\t}\\n\\t}\\n\\tif left/100*100 == left {\\n\\t\\tif rfq.arr[left] == value {\\n\\t\\t\\tmoreFreq--\\n\\t\\t}\\n\\t}\\n\\treturn initialFreq-moreFreq\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1589664,
                "title": "python-binary-search-solution",
                "content": "```python\\nclass RangeFreqQuery:\\n\\n    def __init__(self, arr: List[int]):\\n        self.hm = collections.defaultdict(list)\\n        for i, x in enumerate(arr):\\n            self.hm[x].append(i)\\n        \\n\\n    def query(self, left: int, right: int, value: int) -> int:\\n        arr = self.hm[value]\\n        l = bisect.bisect_left(arr, left)\\n        r = bisect.bisect_right(arr, right)\\n        return r - l\\n\\n\\n# Your RangeFreqQuery object will be instantiated and called as such:\\n# obj = RangeFreqQuery(arr)\\n# param_1 = obj.query(left,right,value)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```python\\nclass RangeFreqQuery:\\n\\n    def __init__(self, arr: List[int]):\\n        self.hm = collections.defaultdict(list)\\n        for i, x in enumerate(arr):\\n            self.hm[x].append(i)\\n        \\n\\n    def query(self, left: int, right: int, value: int) -> int:\\n        arr = self.hm[value]\\n        l = bisect.bisect_left(arr, left)\\n        r = bisect.bisect_right(arr, right)\\n        return r - l\\n\\n\\n# Your RangeFreqQuery object will be instantiated and called as such:\\n# obj = RangeFreqQuery(arr)\\n# param_1 = obj.query(left,right,value)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1589642,
                "title": "c-binary-serach",
                "content": "```\\nclass RangeFreqQuery {\\n    vector<pair<int,int>> v;\\npublic:\\n    RangeFreqQuery(vector<int>& arr) {\\n        for(int i=0; i<arr.size(); i++) \\n           v.push_back(make_pair(arr[i],i));\\n        sort(v.begin(), v.end());\\n    }\\n    \\n    int query(int left, int right, int value) {\\n        auto low=lower_bound (v.begin(), v.end(), make_pair(value,left));\\n        auto up=upper_bound(v.begin(), v.end(), make_pair(value,right));\\n        if (up != v.end() && (up->second == left && up->first == value))\\n            return up - low + 1;\\n        else\\n            return up - low;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass RangeFreqQuery {\\n    vector<pair<int,int>> v;\\npublic:\\n    RangeFreqQuery(vector<int>& arr) {\\n        for(int i=0; i<arr.size(); i++) \\n           v.push_back(make_pair(arr[i],i));\\n        sort(v.begin(), v.end());\\n    }\\n    \\n    int query(int left, int right, int value) {\\n        auto low=lower_bound (v.begin(), v.end(), make_pair(value,left));\\n        auto up=upper_bound(v.begin(), v.end(), make_pair(value,right));\\n        if (up != v.end() && (up->second == left && up->first == value))\\n            return up - low + 1;\\n        else\\n            return up - low;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1589392,
                "title": "c-solution-with-better-than-100-memory-and-time",
                "content": "steps to follow:\\nmap from a value to all its indices\\nif value` doesn\\'t exist in the original array return 0\\nv` is the array of all the indices of `value` in the original array\\nFind the first index `j` that `v[j] > right`.\\nFind the first index `i` that `v[i] >= left`.\\nreturn j-i;\\n\\n\\'\\'\\'\\nclass RangeFreqQuery {\\n    unordered_map<int,vector<int>> m;\\npublic:\\n    RangeFreqQuery(vector<int>& A) {\\n        for (int i = 0; i < A.size(); ++i)\\n            m[A[i]].push_back(i);\\n    }\\n    int query(int left, int right, int value) {\\n        if (m.count(value) == 0) return 0; \\n        auto &v = m[value];\\n        int j = upper_bound(begin(v), end(v), right) - begin(v);\\n        int i = lower_bound(begin(v), end(v), left) - begin(v);\\n        return j-i;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "steps to follow:\\nmap from a value to all its indices\\nif value` doesn\\'t exist in the original array return 0\\nv` is the array of all the indices of `value` in the original array\\nFind the first index `j` that `v[j] > right`.\\nFind the first index `i` that `v[i] >= left`.\\nreturn j-i;\\n\\n\\'\\'\\'\\nclass RangeFreqQuery {\\n    unordered_map<int,vector<int>> m;\\npublic:\\n    RangeFreqQuery(vector<int>& A) {\\n        for (int i = 0; i < A.size(); ++i)\\n            m[A[i]].push_back(i);\\n    }\\n    int query(int left, int right, int value) {\\n        if (m.count(value) == 0) return 0; \\n        auto &v = m[value];\\n        int j = upper_bound(begin(v), end(v), right) - begin(v);\\n        int i = lower_bound(begin(v), end(v), left) - begin(v);\\n        return j-i;\\n    }\\n};",
                "codeTag": "Java"
            },
            {
                "id": 1589316,
                "title": "c-simple-using-binary-search-optimize-code",
                "content": "first we store the index in map and made every element key now simply use upper bound and lower boud to find the range ,thus we cand find count.\\n```\\n unordered_map<int,vector<int>>mp;\\n    \\n    RangeFreqQuery(vector<int>& arr) {\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            mp[arr[i]].push_back(i);\\n        }\\n        \\n    }\\n    \\n    int query(int left, int right, int value) {\\n        int r=lower_bound(mp[value].begin(),mp[value].end(),left)-mp[value].begin();\\n        int l=upper_bound(mp[value].begin(),mp[value].end(),right)-mp[value].begin();\\n        return l-r;\\n    }\\n\\n\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\n unordered_map<int,vector<int>>mp;\\n    \\n    RangeFreqQuery(vector<int>& arr) {\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            mp[arr[i]].push_back(i);\\n        }\\n        \\n    }\\n    \\n    int query(int left, int right, int value) {\\n        int r=lower_bound(mp[value].begin(),mp[value].end(),left)-mp[value].begin();\\n        int l=upper_bound(mp[value].begin(),mp[value].end(),right)-mp[value].begin();\\n        return l-r;\\n    }\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1589273,
                "title": "java-intuitive-solution",
                "content": "```\\nimport java.util.ArrayList;\\nimport java.util.Collections;\\n\\nclass RangeFreqQuery {\\n\\tint N = 10001;\\n\\t// Map<Integer,List<Integer>> can also be used here\\n\\tArrayList<Integer>[] ans = new ArrayList[N];\\n\\tpublic RangeFreqQuery(int[] arr) {\\n\\t\\tint len = arr.length;\\n\\t\\tfor(int i=0;i<N;i++){\\n\\t\\t\\tans[i] = new ArrayList<>();\\n\\t\\t}\\n\\t\\t/**\\n\\t\\t * Creating an array of indices where a particular number is repeated\\n\\t\\t * */\\n\\t\\tfor(int i=0;i<arr.length;i++){\\n\\t\\t\\tans[arr[i]].add(i);\\n\\t\\t}\\n\\t}\\n\\n\\tpublic int query(int left, int right, int value) {\\n\\t\\t/**\\n\\t\\t * Do a binary search to get the lower bound and upper bound and then subtract them to get the answer\\n\\t\\t * */\\n\\t\\tint leftIndex = insertionToIndex(Collections.binarySearch(ans[value],left));\\n\\t\\tint rightIndex = insertionToIndex(Collections.binarySearch(ans[value],right+1));\\n\\t\\tSystem.out.println(rightIndex - leftIndex);\\n\\t\\treturn rightIndex - leftIndex;\\n\\t}\\n\\t// This methods just returns the index where the number needs to be inserted.\\n\\t// Please refer to JAVA Colections.binarySerach to get more knowledge on it.\\n\\tprivate int insertionToIndex(int insertion){\\n\\t\\tif(insertion >= 0) return insertion;\\n\\t\\telse{\\n\\t\\t\\treturn -1*insertion - 1;\\n\\t\\t}\\n\\t}\\n\\n}\\n\\n/**\\n * Your RangeFreqQuery object will be instantiated and called as such:\\n * RangeFreqQuery obj = new RangeFreqQuery(arr);\\n * int param_1 = obj.query(left,right,value);\\n */\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nimport java.util.ArrayList;\\nimport java.util.Collections;\\n\\nclass RangeFreqQuery {\\n\\tint N = 10001;\\n\\t// Map<Integer,List<Integer>> can also be used here\\n\\tArrayList<Integer>[] ans = new ArrayList[N];\\n\\tpublic RangeFreqQuery(int[] arr) {\\n\\t\\tint len = arr.length;\\n\\t\\tfor(int i=0;i<N;i++){\\n\\t\\t\\tans[i] = new ArrayList<>();\\n\\t\\t}\\n\\t\\t/**\\n\\t\\t * Creating an array of indices where a particular number is repeated\\n\\t\\t * */\\n\\t\\tfor(int i=0;i<arr.length;i++){\\n\\t\\t\\tans[arr[i]].add(i);\\n\\t\\t}\\n\\t}\\n\\n\\tpublic int query(int left, int right, int value) {\\n\\t\\t/**\\n\\t\\t * Do a binary search to get the lower bound and upper bound and then subtract them to get the answer\\n\\t\\t * */\\n\\t\\tint leftIndex = insertionToIndex(Collections.binarySearch(ans[value],left));\\n\\t\\tint rightIndex = insertionToIndex(Collections.binarySearch(ans[value],right+1));\\n\\t\\tSystem.out.println(rightIndex - leftIndex);\\n\\t\\treturn rightIndex - leftIndex;\\n\\t}\\n\\t// This methods just returns the index where the number needs to be inserted.\\n\\t// Please refer to JAVA Colections.binarySerach to get more knowledge on it.\\n\\tprivate int insertionToIndex(int insertion){\\n\\t\\tif(insertion >= 0) return insertion;\\n\\t\\telse{\\n\\t\\t\\treturn -1*insertion - 1;\\n\\t\\t}\\n\\t}\\n\\n}\\n\\n/**\\n * Your RangeFreqQuery object will be instantiated and called as such:\\n * RangeFreqQuery obj = new RangeFreqQuery(arr);\\n * int param_1 = obj.query(left,right,value);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1589257,
                "title": "python-inferior-but-fun-bit-solution",
                "content": "BIT (binary indexed tree), a.k.a. Fenwick tree solution\\n\\nSince each counter can get up to size `log(n)`, initialization is `nlog(n)` in both space and time while query is still  `log(n)` time. There is no reason to do this instead of the canonical solution, but it does get AC. Presented here for your entertainment:\\n```\\nclass RangeFreqQuery:\\n\\n    def __init__(self, arr: List[int]):\\n        self.n = len(arr)\\n        self.BIT = [collections.Counter()]\\n        self.BIT.extend([collections.Counter([x]) for x in arr])\\n        for i in range(1, self.n + 1):\\n            next_i = i + (i & -i)\\n            if next_i <= self.n:\\n                self.BIT[next_i] += self.BIT[i]\\n    \\n    def _query(self, i, value):\\n        i += 1\\n        ans = 0\\n        while i:\\n            if value in self.BIT[i]:\\n                ans += self.BIT[i][value]\\n            i -= i & -i\\n        return ans\\n    \\n    def query(self, left: int, right: int, value: int) -> int:\\n        return self._query(right, value) - self._query(left - 1, value)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass RangeFreqQuery:\\n\\n    def __init__(self, arr: List[int]):\\n        self.n = len(arr)\\n        self.BIT = [collections.Counter()]\\n        self.BIT.extend([collections.Counter([x]) for x in arr])\\n        for i in range(1, self.n + 1):\\n            next_i = i + (i & -i)\\n            if next_i <= self.n:\\n                self.BIT[next_i] += self.BIT[i]\\n    \\n    def _query(self, i, value):\\n        i += 1\\n        ans = 0\\n        while i:\\n            if value in self.BIT[i]:\\n                ans += self.BIT[i][value]\\n            i -= i & -i\\n        return ans\\n    \\n    def query(self, left: int, right: int, value: int) -> int:\\n        return self._query(right, value) - self._query(left - 1, value)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1589168,
                "title": "javascript-hashmap-lower-bound-upper-bound-740ms",
                "content": "```\\n//////////////////////////////////////////////Template/////////////////////////////////////////////////////////////\\nfunction Bisect() {\\n    return { insort_right, insort_left, bisect_left, bisect_right }\\n    function insort_right(a, x, lo = 0, hi = null) {\\n        lo = bisect_right(a, x, lo, hi);\\n        a.splice(lo, 0, x);\\n    }\\n    function bisect_right(a, x, lo = 0, hi = null) { // > upper_bound\\n        if (lo < 0) throw new Error(\\'lo must be non-negative\\');\\n        if (hi == null) hi = a.length;\\n        while (lo < hi) {\\n            let mid = parseInt((lo + hi) / 2);\\n            x < a[mid] ? hi = mid : lo = mid + 1;\\n        }\\n        return lo;\\n    }\\n    function insort_left(a, x, lo = 0, hi = null) {\\n        lo = bisect_left(a, x, lo, hi);\\n        a.splice(lo, 0, x);\\n    }\\n    function bisect_left(a, x, lo = 0, hi = null) { // >= lower_bound\\n        if (lo < 0) throw new Error(\\'lo must be non-negative\\');\\n        if (hi == null) hi = a.length;\\n        while (lo < hi) {\\n            let mid = parseInt((lo + hi) / 2);\\n            a[mid] < x ? lo = mid + 1 : hi = mid;\\n        }\\n        return lo;\\n    }\\n}\\n\\n// counter with {value: array indices (increasing order)}\\nconst counter_value_in_indexA_in = (a_or_s) => { let m = new Map(); let n = a_or_s.length; for (let i = 0; i < n; i++) { if (!m.has(a_or_s[i])) m.set(a_or_s[i], []); m.get(a_or_s[i]).push(i); } return m; };\\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\nfunction RangeFreqQuery(a) {\\n    let m = counter_value_in_indexA_in(a), bi = new Bisect();\\n    return { query }\\n    function query(l, r, x) {\\n        if (!m.has(x)) return 0;\\n        let a = m.get(x), len = a.length;\\n        let min = a[0], max = a[len - 1];\\n        if (l <= min && r >= max) return len; // cover all\\n        if (r < min || l > max) return 0; // out of bound\\n        let lbs = bi.bisect_left(a, l); // needs lbs >= l  (lower bound will find first >= l)\\n        let ubs = bi.bisect_right(a, r); // needs ubs <= r    (upper bound will find first ubs > r, -1 will guarantee <= r)\\n        ubs--;\\n        return ubs - lbs + 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Tree"
                ],
                "code": "```\\n//////////////////////////////////////////////Template/////////////////////////////////////////////////////////////\\nfunction Bisect() {\\n    return { insort_right, insort_left, bisect_left, bisect_right }\\n    function insort_right(a, x, lo = 0, hi = null) {\\n        lo = bisect_right(a, x, lo, hi);\\n        a.splice(lo, 0, x);\\n    }\\n    function bisect_right(a, x, lo = 0, hi = null) { // > upper_bound\\n        if (lo < 0) throw new Error(\\'lo must be non-negative\\');\\n        if (hi == null) hi = a.length;\\n        while (lo < hi) {\\n            let mid = parseInt((lo + hi) / 2);\\n            x < a[mid] ? hi = mid : lo = mid + 1;\\n        }\\n        return lo;\\n    }\\n    function insort_left(a, x, lo = 0, hi = null) {\\n        lo = bisect_left(a, x, lo, hi);\\n        a.splice(lo, 0, x);\\n    }\\n    function bisect_left(a, x, lo = 0, hi = null) { // >= lower_bound\\n        if (lo < 0) throw new Error(\\'lo must be non-negative\\');\\n        if (hi == null) hi = a.length;\\n        while (lo < hi) {\\n            let mid = parseInt((lo + hi) / 2);\\n            a[mid] < x ? lo = mid + 1 : hi = mid;\\n        }\\n        return lo;\\n    }\\n}\\n\\n// counter with {value: array indices (increasing order)}\\nconst counter_value_in_indexA_in = (a_or_s) => { let m = new Map(); let n = a_or_s.length; for (let i = 0; i < n; i++) { if (!m.has(a_or_s[i])) m.set(a_or_s[i], []); m.get(a_or_s[i]).push(i); } return m; };\\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\nfunction RangeFreqQuery(a) {\\n    let m = counter_value_in_indexA_in(a), bi = new Bisect();\\n    return { query }\\n    function query(l, r, x) {\\n        if (!m.has(x)) return 0;\\n        let a = m.get(x), len = a.length;\\n        let min = a[0], max = a[len - 1];\\n        if (l <= min && r >= max) return len; // cover all\\n        if (r < min || l > max) return 0; // out of bound\\n        let lbs = bi.bisect_left(a, l); // needs lbs >= l  (lower bound will find first >= l)\\n        let ubs = bi.bisect_right(a, r); // needs ubs <= r    (upper bound will find first ubs > r, -1 will guarantee <= r)\\n        ubs--;\\n        return ubs - lbs + 1;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1589164,
                "title": "python3-dictionary-and-binary-search",
                "content": "```\\nclass RangeFreqQuery:\\n\\n    def __init__(self, arr: List[int]):\\n        self.d={}\\n        for i,x in enumerate(arr):\\n            if x in self.d:\\n                self.d[x].append(i)\\n            else:\\n                self.d[x]=[i]\\n\\n    def query(self, left: int, right: int, value: int) -> int:\\n        if value not in self.d:\\n            return 0\\n        return bisect.bisect_right(self.d[value], right)  -  bisect.bisect_left(self.d[value], left) \\n```",
                "solutionTags": [],
                "code": "```\\nclass RangeFreqQuery:\\n\\n    def __init__(self, arr: List[int]):\\n        self.d={}\\n        for i,x in enumerate(arr):\\n            if x in self.d:\\n                self.d[x].append(i)\\n            else:\\n                self.d[x]=[i]\\n\\n    def query(self, left: int, right: int, value: int) -> int:\\n        if value not in self.d:\\n            return 0\\n        return bisect.bisect_right(self.d[value], right)  -  bisect.bisect_left(self.d[value], left) \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1589158,
                "title": "java-idea-of-prefix-sum-matrix-o-n-n",
                "content": "\\n    public Map<Integer, Integer> map = new HashMap<>();\\n    public int[][] matrix;\\n    public int[] arr;\\n\\t\\n    public RangeFreqQuery(int[] arr) {\\n        \\n        // lable all the distinct number in the array\\n        int index = 0;\\n        for (int num : arr) {\\n            if (!map.containsKey(num)) {\\n                map.put(num, index);\\n                index++;\\n            }\\n        }\\n        \\n        this.arr = arr;\\n        int n = arr.length;\\n        int m = map.size();\\n        matrix = new int[m][n+1]; // row points to the distince value, col is the index in the array\\n        \\n        // matrix[map.get(key)][j] represents the frequency of the key between [0, j] of the array \\n        for (int key : map.keySet()) {\\n            int i = map.get(key);\\n            for (int j = 1; j <= n; j++) {\\n                if (key != arr[j - 1]) {\\n                    matrix[i][j] = matrix[i][j - 1];\\n                } else {\\n                    matrix[i][j] = matrix[i][j - 1] + 1;\\n                }\\n            }\\n        }\\n    }\\n    \\n    public int query(int left, int right, int value) {\\n        if (!map.containsKey(value)) return 0;\\n        \\n        int count = 0;\\n        // get the row where the value is stored in matrix\\n        int index = map.get(value);\\n        count = matrix[index][right+1] - matrix[index][left+1];\\n        // check if arr[left] is equal to value, we have to add one\\n        if (arr[left] == value) {\\n            count++;\\n        }\\n        return count;\\n    }",
                "solutionTags": [],
                "code": "\\n    public Map<Integer, Integer> map = new HashMap<>();\\n    public int[][] matrix;\\n    public int[] arr;\\n\\t\\n    public RangeFreqQuery(int[] arr) {\\n        \\n        // lable all the distinct number in the array\\n        int index = 0;\\n        for (int num : arr) {\\n            if (!map.containsKey(num)) {\\n                map.put(num, index);\\n                index++;\\n            }\\n        }\\n        \\n        this.arr = arr;\\n        int n = arr.length;\\n        int m = map.size();\\n        matrix = new int[m][n+1]; // row points to the distince value, col is the index in the array\\n        \\n        // matrix[map.get(key)][j] represents the frequency of the key between [0, j] of the array \\n        for (int key : map.keySet()) {\\n            int i = map.get(key);\\n            for (int j = 1; j <= n; j++) {\\n                if (key != arr[j - 1]) {\\n                    matrix[i][j] = matrix[i][j - 1];\\n                } else {\\n                    matrix[i][j] = matrix[i][j - 1] + 1;\\n                }\\n            }\\n        }\\n    }\\n    \\n    public int query(int left, int right, int value) {\\n        if (!map.containsKey(value)) return 0;\\n        \\n        int count = 0;\\n        // get the row where the value is stored in matrix\\n        int index = map.get(value);\\n        count = matrix[index][right+1] - matrix[index][left+1];\\n        // check if arr[left] is equal to value, we have to add one\\n        if (arr[left] == value) {\\n            count++;\\n        }\\n        return count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1589099,
                "title": "2080-range-frequency-queries-binary-search-python",
                "content": "class RangeFreqQuery:\\n\\n    def __init__(self, arr: List[int]):\\n        self.a = arr\\n        self.dp = collections.defaultdict(list)\\n        for idx,i in enumerate(self.a):\\n            self.dp[i].append(idx) \\n    def query(self, left: int, right: int, value: int) -> int:\\n        l = bisect.bisect_left(self.dp[value],left)\\n        r = bisect.bisect_right(self.dp[value],right)\\n        return r-l",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "class RangeFreqQuery:\\n\\n    def __init__(self, arr: List[int]):\\n        self.a = arr\\n        self.dp = collections.defaultdict(list)\\n        for idx,i in enumerate(self.a):\\n            self.dp[i].append(idx) \\n    def query(self, left: int, right: int, value: int) -> int:\\n        l = bisect.bisect_left(self.dp[value],left)\\n        r = bisect.bisect_right(self.dp[value],right)\\n        return r-l",
                "codeTag": "Java"
            },
            {
                "id": 1589090,
                "title": "c-binary-search-map-clean-solution",
                "content": "```\\nclass RangeFreqQuery {\\npublic:\\n   \\n    map<int,vector<int>>ma;\\n    RangeFreqQuery(vector<int>& arr) {\\n        \\n       \\n        for(int i=0;i<n;i++)\\n        {\\n            ma[arr[i]].push_back(i+1);\\n        }\\n    }\\n    \\n    int query(int left, int right, int value) {\\n        \\n        left++;\\n        right++;\\n        int a=lower_bound(ma[value].begin(),ma[value].end(),left)-ma[value].begin();\\n        int b=upper_bound(ma[value].begin(),ma[value].end(),right)-ma[value].begin();\\n            \\n        return  b-a;\\n        \\n    }\\n};\\n\\n/**\\n * Your RangeFreqQuery object will be instantiated and called as such:\\n * RangeFreqQuery* obj = new RangeFreqQuery(arr);\\n * int param_1 = obj->query(left,right,value);\\n */\\n```\\n\\n**please upvote if you found helpful**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass RangeFreqQuery {\\npublic:\\n   \\n    map<int,vector<int>>ma;\\n    RangeFreqQuery(vector<int>& arr) {\\n        \\n       \\n        for(int i=0;i<n;i++)\\n        {\\n            ma[arr[i]].push_back(i+1);\\n        }\\n    }\\n    \\n    int query(int left, int right, int value) {\\n        \\n        left++;\\n        right++;\\n        int a=lower_bound(ma[value].begin(),ma[value].end(),left)-ma[value].begin();\\n        int b=upper_bound(ma[value].begin(),ma[value].end(),right)-ma[value].begin();\\n            \\n        return  b-a;\\n        \\n    }\\n};\\n\\n/**\\n * Your RangeFreqQuery object will be instantiated and called as such:\\n * RangeFreqQuery* obj = new RangeFreqQuery(arr);\\n * int param_1 = obj->query(left,right,value);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1589058,
                "title": "c-100-faster-easy-binary-search-using-unordered-map",
                "content": "```\\nclass RangeFreqQuery {\\npublic:\\n    unordered_map<int, vector<int>> mp;\\n    RangeFreqQuery(vector<int>& arr) {\\n        for(int i=0; i<arr.size(); ++i) {\\n            mp[arr[i]].push_back(i);\\n        }\\n    }\\n    \\n    int query(int l, int r, int k) {\\n        int x = lower_bound(mp[k].begin(), mp[k].end(), l) - mp[k].begin();\\n        int y = upper_bound(mp[k].begin(), mp[k].end(), r) - mp[k].begin();\\n        return y-x;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass RangeFreqQuery {\\npublic:\\n    unordered_map<int, vector<int>> mp;\\n    RangeFreqQuery(vector<int>& arr) {\\n        for(int i=0; i<arr.size(); ++i) {\\n            mp[arr[i]].push_back(i);\\n        }\\n    }\\n    \\n    int query(int l, int r, int k) {\\n        int x = lower_bound(mp[k].begin(), mp[k].end(), l) - mp[k].begin();\\n        int y = upper_bound(mp[k].begin(), mp[k].end(), r) - mp[k].begin();\\n        return y-x;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1589051,
                "title": "java-hashmap-binarysearch-with-explanation",
                "content": "```\\nclass RangeFreqQuery {\\n    // HashMap + BinarySearch\\n    // HashMap:\\n    // For each arr[i] or value, we have a list of index representing its occurence in arr.\\n    // For each query, BinarySearch the list to find the lower and upper bounds.\\n    // return upper - lower.\\n    Map<Integer, List<Integer>> map;\\n    \\n    public RangeFreqQuery(int[] arr) {\\n        map = new HashMap<>();\\n        for (int i = 0; i < arr.length; i++) {\\n            map.putIfAbsent(arr[i], new ArrayList<>());\\n            map.get(arr[i]).add(i);\\n        }\\n    }\\n    \\n    public int query(int left, int right, int value) {\\n        if (!map.containsKey(value)) return 0;\\n        \\n        List<Integer> arr = map.get(value);\\n        // binarySearch API will return the index of search key, if return < 0 then -(insert pos)-1\\n        int r = Collections.binarySearch(arr, right);\\n        int l = Collections.binarySearch(arr, left);\\n        if (r >= 0) { // right side exists\\n            l = l < 0 ? -l-1 : l;\\n            return r - l + 1;\\n        } else { // right side doesn\\'t exist\\n            r = -r-1;\\n            l = l < 0 ? -l-1 : l;\\n            return r - l;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass RangeFreqQuery {\\n    // HashMap + BinarySearch\\n    // HashMap:\\n    // For each arr[i] or value, we have a list of index representing its occurence in arr.\\n    // For each query, BinarySearch the list to find the lower and upper bounds.\\n    // return upper - lower.\\n    Map<Integer, List<Integer>> map;\\n    \\n    public RangeFreqQuery(int[] arr) {\\n        map = new HashMap<>();\\n        for (int i = 0; i < arr.length; i++) {\\n            map.putIfAbsent(arr[i], new ArrayList<>());\\n            map.get(arr[i]).add(i);\\n        }\\n    }\\n    \\n    public int query(int left, int right, int value) {\\n        if (!map.containsKey(value)) return 0;\\n        \\n        List<Integer> arr = map.get(value);\\n        // binarySearch API will return the index of search key, if return < 0 then -(insert pos)-1\\n        int r = Collections.binarySearch(arr, right);\\n        int l = Collections.binarySearch(arr, left);\\n        if (r >= 0) { // right side exists\\n            l = l < 0 ? -l-1 : l;\\n            return r - l + 1;\\n        } else { // right side doesn\\'t exist\\n            r = -r-1;\\n            l = l < 0 ? -l-1 : l;\\n            return r - l;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4083103,
                "title": "fastest-solution-in-rust-so-far",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe keep track of indices of every occurance of an element which by default are in sorted order, which means we can use binary search for fast retrieval.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nStore the occurances of each element in a Vec inside a HashMap for O(1) retreival.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n + q (log n)) where n is the size of array and q denotes the number of queries.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n) as each occurance of an element is stored in the HashMap.\\n\\n# Code\\n```\\nuse std::collections::HashMap;\\n\\nstruct RangeFreqQuery {\\n    map: HashMap<i32, Vec<i32>>\\n}\\n\\n/** \\n * `&self` means the method takes an immutable reference.\\n * If you need a mutable reference, change it to `&mut self` instead.\\n */\\nimpl RangeFreqQuery {\\n\\n    fn new(arr: Vec<i32>) -> Self {\\n        let mut map: HashMap<i32, Vec<i32>> = HashMap::new();\\n        map.reserve(arr.len());\\n        for (i, a) in arr.iter().enumerate() {\\n            if let Some(vec) = map.get_mut(a) {\\n                vec.push(i as i32);\\n            } else {\\n                map.insert(*a, vec![i as i32]);\\n            }\\n        }\\n        RangeFreqQuery{ map }\\n    }\\n    \\n    fn query(&self, left: i32, right: i32, value: i32) -> i32 {\\n        if let Some(vec) = self.map.get(&value) {\\n            let l = vec.partition_point(|&x| x < left);\\n            let r = vec.partition_point(|&x| x < right + 1);\\n            (r - l) as i32\\n        } else {\\n            0\\n        }\\n    }\\n}\\n\\n/**\\n * Your RangeFreqQuery object will be instantiated and called as such:\\n * let obj = RangeFreqQuery::new(arr);\\n * let ret_1: i32 = obj.query(left, right, value);\\n */\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::HashMap;\\n\\nstruct RangeFreqQuery {\\n    map: HashMap<i32, Vec<i32>>\\n}\\n\\n/** \\n * `&self` means the method takes an immutable reference.\\n * If you need a mutable reference, change it to `&mut self` instead.\\n */\\nimpl RangeFreqQuery {\\n\\n    fn new(arr: Vec<i32>) -> Self {\\n        let mut map: HashMap<i32, Vec<i32>> = HashMap::new();\\n        map.reserve(arr.len());\\n        for (i, a) in arr.iter().enumerate() {\\n            if let Some(vec) = map.get_mut(a) {\\n                vec.push(i as i32);\\n            } else {\\n                map.insert(*a, vec![i as i32]);\\n            }\\n        }\\n        RangeFreqQuery{ map }\\n    }\\n    \\n    fn query(&self, left: i32, right: i32, value: i32) -> i32 {\\n        if let Some(vec) = self.map.get(&value) {\\n            let l = vec.partition_point(|&x| x < left);\\n            let r = vec.partition_point(|&x| x < right + 1);\\n            (r - l) as i32\\n        } else {\\n            0\\n        }\\n    }\\n}\\n\\n/**\\n * Your RangeFreqQuery object will be instantiated and called as such:\\n * let obj = RangeFreqQuery::new(arr);\\n * let ret_1: i32 = obj.query(left, right, value);\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4078506,
                "title": "c-hash-table-binary-search",
                "content": "# Intuition\\nSince we need to look up frequency of a certain value - realized that I will need a hash table...\\n\\n# Approach\\n- Record offsets for all the values.\\n- to find how many values are between certain offsets use binary search.\\n\\n# Complexity\\n- Time complexity:\\nO(N) to build a hash table. O(log(N)) to make a query.\\nNot a super fast implementation however, but does pass.\\n\\n- Space complexity:\\nO(N) since we store all the indices.\\n\\n# Code\\n```\\npublic class RangeFreqQuery {\\n\\n    Dictionary<int,List<int>> H = new();\\n\\n    public RangeFreqQuery(int[] arr) {\\n//Record offset for each of values\\n        for (int i = 0; i < arr.Length; i++)\\n        {\\n            H.TryAdd(arr[i], new());                    \\n            H[arr[i]].Add(i);        \\n        }    \\n    }\\n// Standard pattern. Alternatively could use List<T>.BinarySearch\\n    int bs(List<int> a, int val)\\n    {\\n        int l = 0;\\n        int r = a.Count;\\n\\n        while (l < r)\\n        {\\n            int m = l + (r - l) / 2;\\n\\n            if (a[m] >= val)\\n                r = m;\\n            else\\n                l = m + 1;            \\n        }\\n\\n        return l;\\n    }\\n    \\n    public int Query(int left, int right, int value) {\\n\\n        if (H.TryGetValue(value, out List<int> list))\\n        {\\n            var li = bs(list, left);\\n            var ri = bs(list, right);\\n// brain does not work anymore...\\n            if (ri == list.Count)\\n                ri--;\\n            if (right < list[ri])\\n                ri--;\\n\\n            return (ri>=li)? ri-li + 1 : 0;\\n        }        \\n        return 0;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class RangeFreqQuery {\\n\\n    Dictionary<int,List<int>> H = new();\\n\\n    public RangeFreqQuery(int[] arr) {\\n//Record offset for each of values\\n        for (int i = 0; i < arr.Length; i++)\\n        {\\n            H.TryAdd(arr[i], new());                    \\n            H[arr[i]].Add(i);        \\n        }    \\n    }\\n// Standard pattern. Alternatively could use List<T>.BinarySearch\\n    int bs(List<int> a, int val)\\n    {\\n        int l = 0;\\n        int r = a.Count;\\n\\n        while (l < r)\\n        {\\n            int m = l + (r - l) / 2;\\n\\n            if (a[m] >= val)\\n                r = m;\\n            else\\n                l = m + 1;            \\n        }\\n\\n        return l;\\n    }\\n    \\n    public int Query(int left, int right, int value) {\\n\\n        if (H.TryGetValue(value, out List<int> list))\\n        {\\n            var li = bs(list, left);\\n            var ri = bs(list, right);\\n// brain does not work anymore...\\n            if (ri == list.Count)\\n                ri--;\\n            if (right < list[ri])\\n                ri--;\\n\\n            return (ri>=li)? ri-li + 1 : 0;\\n        }        \\n        return 0;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4077678,
                "title": "simple-map-binarysearch-c-o-qlogn-time",
                "content": "# Intuition\\nuse map of <value, its indices>.\\nthen for freq of value, binary search in mp[value].\\n\\n# Code\\n```\\nclass RangeFreqQuery {\\npublic:\\n    map<int,vector<int>> mp;\\n    RangeFreqQuery(vector<int>& arr) {\\n        for(int i= 0;i<arr.size();i++){\\n            mp[arr[i]].push_back(i);     \\n        }\\n    }\\n    \\n    int query(int left, int right, int value) {\\n        int l = lower_bound(mp[value].begin() , mp[value].end() , left) - mp[value].begin() ;\\n        int r = upper_bound(mp[value].begin() , mp[value].end() , right) -mp[value].begin();\\n        int n = mp[value].size();\\n        return r-l;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass RangeFreqQuery {\\npublic:\\n    map<int,vector<int>> mp;\\n    RangeFreqQuery(vector<int>& arr) {\\n        for(int i= 0;i<arr.size();i++){\\n            mp[arr[i]].push_back(i);     \\n        }\\n    }\\n    \\n    int query(int left, int right, int value) {\\n        int l = lower_bound(mp[value].begin() , mp[value].end() , left) - mp[value].begin() ;\\n        int r = upper_bound(mp[value].begin() , mp[value].end() , right) -mp[value].begin();\\n        int n = mp[value].size();\\n        return r-l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4074344,
                "title": "binary-search-count-dict-dp-python",
                "content": "# Complexity\\n- Time complexity:\\n\\n    O(N + qlog(N)) \\n\\n    O(N) to build count list.\\n    log(N) for each q queries.\\n\\n- Space complexity:\\n\\n    O(N)\\n\\n# Code\\n```\\nfrom bisect import bisect_right, bisect_left\\nclass RangeFreqQuery:\\n    \\n    def __init__(self, arr: List[int]):\\n        self.count = [[] for _ in range(10001)]\\n        for i, num in enumerate(arr):\\n            self.count[num].append(i)\\n\\n        \\n    def query(self, left: int, right: int, value: int) -> int:\\n        # make sure that left and right do not pass each other\\n        return bisect_right(self.count[value], right) - bisect_left(self.count[value], left)\\n        \\n    \\n\"\"\"\\nThis works but stores a lot of memory\\n\\nclass RangeFreqQuery:\\n    \\n    def __init__(self, arr: List[int]):\\n        self.count = []\\n        curr_dict = {}\\n        for num in arr:\\n            curr_dict[num] = curr_dict.get(num, 0) + 1\\n\\n            self.count.append(curr_dict.copy())\\n        self.count.append({})\\n        \\n    def query(self, left: int, right: int, value: int) -> int:\\n        # make sure that left and right do not pass each other\\n        return self.count[right].get(value, 0) - self.count[left - 1].get(value, 0)\\n\\n---\\n\\nThis is a DP version that takes a lot of memory\\nThis is pretty much like a segment tree without updates\\nclass RangeFreqQuery:\\n    # This is pretty much like a segment tree without updates\\n    def __init__(self, arr: List[int]):\\n        self.arr = arr\\n        \\n    @lru_cache(maxsize=None)\\n    def query(self, left: int, right: int, value: int) -> int:\\n        # make sure that left and right do not pass each other\\n        if left == right:\\n            return int(self.arr[left] == value)\\n        \\n        mid = (right + left) // 2 \\n        return self.query(left, mid, value) + self.query(mid + 1, right, value)\\n\\n\"\"\"\\n        \\n\\n\\n\\n\\n\\n# Your RangeFreqQuery object will be instantiated and called as such:\\n# obj = RangeFreqQuery(arr)\\n# param_1 = obj.query(left,right,value)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom bisect import bisect_right, bisect_left\\nclass RangeFreqQuery:\\n    \\n    def __init__(self, arr: List[int]):\\n        self.count = [[] for _ in range(10001)]\\n        for i, num in enumerate(arr):\\n            self.count[num].append(i)\\n\\n        \\n    def query(self, left: int, right: int, value: int) -> int:\\n        # make sure that left and right do not pass each other\\n        return bisect_right(self.count[value], right) - bisect_left(self.count[value], left)\\n        \\n    \\n\"\"\"\\nThis works but stores a lot of memory\\n\\nclass RangeFreqQuery:\\n    \\n    def __init__(self, arr: List[int]):\\n        self.count = []\\n        curr_dict = {}\\n        for num in arr:\\n            curr_dict[num] = curr_dict.get(num, 0) + 1\\n\\n            self.count.append(curr_dict.copy())\\n        self.count.append({})\\n        \\n    def query(self, left: int, right: int, value: int) -> int:\\n        # make sure that left and right do not pass each other\\n        return self.count[right].get(value, 0) - self.count[left - 1].get(value, 0)\\n\\n---\\n\\nThis is a DP version that takes a lot of memory\\nThis is pretty much like a segment tree without updates\\nclass RangeFreqQuery:\\n    # This is pretty much like a segment tree without updates\\n    def __init__(self, arr: List[int]):\\n        self.arr = arr\\n        \\n    @lru_cache(maxsize=None)\\n    def query(self, left: int, right: int, value: int) -> int:\\n        # make sure that left and right do not pass each other\\n        if left == right:\\n            return int(self.arr[left] == value)\\n        \\n        mid = (right + left) // 2 \\n        return self.query(left, mid, value) + self.query(mid + 1, right, value)\\n\\n\"\"\"\\n        \\n\\n\\n\\n\\n\\n# Your RangeFreqQuery object will be instantiated and called as such:\\n# obj = RangeFreqQuery(arr)\\n# param_1 = obj.query(left,right,value)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4061987,
                "title": "easy-to-understand-java-solution-using-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n$$O(log(n))$$ for query\\n\\n- Space complexity:\\n $$O(n)$$\\n\\n# Code\\n```\\nclass RangeFreqQuery {\\n    private Map<Integer, List<Integer>> locationMap;\\n\\n    public RangeFreqQuery(int[] arr) {\\n        locationMap = new HashMap<>();\\n        for (int i = 0; i < arr.length; i++) {\\n            int el = arr[i];\\n            if (!locationMap.containsKey(el)) {\\n                locationMap.put(el, new ArrayList<>());\\n            }\\n            locationMap.get(el).add(i);\\n        }\\n    }\\n    \\n    public int query(int left, int right, int value) {\\n        if (!locationMap.containsKey(value)) {\\n            return 0;\\n        }\\n        List<Integer> locations = locationMap.get(value);\\n        int foundLeft = Collections.binarySearch(locations, left);\\n        int foundRight = Collections.binarySearch(locations, right);\\n        int leftIndex = (foundLeft >= 0) ? foundLeft : (-foundLeft - 1);\\n        int rightIndex = (foundRight >= 0) ? foundRight : (-foundRight - 2);\\n        return rightIndex - leftIndex + 1;\\n    }\\n}\\n\\n/**\\n * Your RangeFreqQuery object will be instantiated and called as such:\\n * RangeFreqQuery obj = new RangeFreqQuery(arr);\\n * int param_1 = obj.query(left,right,value);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass RangeFreqQuery {\\n    private Map<Integer, List<Integer>> locationMap;\\n\\n    public RangeFreqQuery(int[] arr) {\\n        locationMap = new HashMap<>();\\n        for (int i = 0; i < arr.length; i++) {\\n            int el = arr[i];\\n            if (!locationMap.containsKey(el)) {\\n                locationMap.put(el, new ArrayList<>());\\n            }\\n            locationMap.get(el).add(i);\\n        }\\n    }\\n    \\n    public int query(int left, int right, int value) {\\n        if (!locationMap.containsKey(value)) {\\n            return 0;\\n        }\\n        List<Integer> locations = locationMap.get(value);\\n        int foundLeft = Collections.binarySearch(locations, left);\\n        int foundRight = Collections.binarySearch(locations, right);\\n        int leftIndex = (foundLeft >= 0) ? foundLeft : (-foundLeft - 1);\\n        int rightIndex = (foundRight >= 0) ? foundRight : (-foundRight - 2);\\n        return rightIndex - leftIndex + 1;\\n    }\\n}\\n\\n/**\\n * Your RangeFreqQuery object will be instantiated and called as such:\\n * RangeFreqQuery obj = new RangeFreqQuery(arr);\\n * int param_1 = obj.query(left,right,value);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4054707,
                "title": "two-approaches",
                "content": "class RangeFreqQuery {\\n    private:\\n    unordered_map<int,int> st[400002];\\n    int arr[100002];\\n    int n;\\npublic:\\n    unordered_map<int,int> mergeMaps(unordered_map<int,int>& map1,unordered_map<int,int>& map2){\\n        unordered_map<int,int> m;\\n        for(auto& i: map1){\\n            m[i.first]+=i.second;\\n        }\\n        for(auto& i: map2){\\n            m[i.first]+=i.second;\\n        }\\n        return m;\\n    }\\n    \\n    void buildTree(int start,int end,int node){\\n        if(start==end){\\n            st[node][arr[start]]++;\\n            return;\\n        }\\n        \\n        int mid=start+((end-start)>>1);\\n        buildTree(start,mid,(node<<1)+1);\\n        buildTree(mid+1,end,(node<<1)+2);\\n        \\n        st[node]=mergeMaps(st[(node<<1)+1],st[(node<<1)+2]);\\n    }\\n    \\n    int getAns(int start,int end,int node,int l,int r,int val){\\n        if(start>r or end<l){\\n            return 0;\\n        }\\n        \\n        if(start>=l and end<=r){\\n            return st[node][val];\\n        }\\n        \\n        int mid=start-(start-end)/2;\\n        int left=getAns(start,mid,(node<<1)+1,l,r,val);\\n        int right=getAns(mid+1,end,(node<<1)+2,l,r,val);\\n        \\n        return left+right;\\n    }\\n    \\n    RangeFreqQuery(vector<int>& nums) {\\n        n=nums.size();\\n        for(int i=0;i<4*n;i++){\\n            st[i].clear();\\n        }\\n        for(int i=0;i<n;i++){\\n            arr[i]=nums[i];\\n        }\\n        buildTree(0,n-1,0);\\n    }\\n    \\n    int query(int left, int right, int value) {\\n        int ans=getAns(0,n-1,0,left,right,value);\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your RangeFreqQuery object will be instantiated and called as such:\\n * RangeFreqQuery* obj = new RangeFreqQuery(arr);\\n * int param_1 = obj->query(left,right,value);\\n */\\n \\n ///////////////////////////////Binary Search/////////////////////////////////////////////////////////\\n \\n class RangeFreqQuery {\\n    private:\\n    unordered_map<int,vector<int>> map_freq;\\n    \\npublic:\\n    RangeFreqQuery(vector<int>& arr) {\\n        map_freq.clear();\\n        for(int i=0;i<arr.size();i++){\\n            map_freq[arr[i]].emplace_back(i);\\n        }\\n    }\\n    \\n    int query(int left, int right, int value) {\\n        int idx1=lower_bound(map_freq[value].begin(),map_freq[value].end(),left)-map_freq[value].begin();\\n        int idx2=upper_bound(map_freq[value].begin(),map_freq[value].end(),right)-map_freq[value].begin();\\n        return idx2-idx1;\\n    }\\n};\\n\\n/**\\n * Your RangeFreqQuery object will be instantiated and called as such:\\n * RangeFreqQuery* obj = new RangeFreqQuery(arr);\\n * int param_1 = obj->query(left,right,value);\\n */",
                "solutionTags": [
                    "Binary Search",
                    "Tree"
                ],
                "code": "class RangeFreqQuery {\\n    private:\\n    unordered_map<int,int> st[400002];\\n    int arr[100002];\\n    int n;\\npublic:\\n    unordered_map<int,int> mergeMaps(unordered_map<int,int>& map1,unordered_map<int,int>& map2){\\n        unordered_map<int,int> m;\\n        for(auto& i: map1){\\n            m[i.first]+=i.second;\\n        }\\n        for(auto& i: map2){\\n            m[i.first]+=i.second;\\n        }\\n        return m;\\n    }\\n    \\n    void buildTree(int start,int end,int node){\\n        if(start==end){\\n            st[node][arr[start]]++;\\n            return;\\n        }\\n        \\n        int mid=start+((end-start)>>1);\\n        buildTree(start,mid,(node<<1)+1);\\n        buildTree(mid+1,end,(node<<1)+2);\\n        \\n        st[node]=mergeMaps(st[(node<<1)+1],st[(node<<1)+2]);\\n    }\\n    \\n    int getAns(int start,int end,int node,int l,int r,int val){\\n        if(start>r or end<l){\\n            return 0;\\n        }\\n        \\n        if(start>=l and end<=r){\\n            return st[node][val];\\n        }\\n        \\n        int mid=start-(start-end)/2;\\n        int left=getAns(start,mid,(node<<1)+1,l,r,val);\\n        int right=getAns(mid+1,end,(node<<1)+2,l,r,val);\\n        \\n        return left+right;\\n    }\\n    \\n    RangeFreqQuery(vector<int>& nums) {\\n        n=nums.size();\\n        for(int i=0;i<4*n;i++){\\n            st[i].clear();\\n        }\\n        for(int i=0;i<n;i++){\\n            arr[i]=nums[i];\\n        }\\n        buildTree(0,n-1,0);\\n    }\\n    \\n    int query(int left, int right, int value) {\\n        int ans=getAns(0,n-1,0,left,right,value);\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your RangeFreqQuery object will be instantiated and called as such:\\n * RangeFreqQuery* obj = new RangeFreqQuery(arr);\\n * int param_1 = obj->query(left,right,value);\\n */\\n \\n ///////////////////////////////Binary Search/////////////////////////////////////////////////////////\\n \\n class RangeFreqQuery {\\n    private:\\n    unordered_map<int,vector<int>> map_freq;\\n    \\npublic:\\n    RangeFreqQuery(vector<int>& arr) {\\n        map_freq.clear();\\n        for(int i=0;i<arr.size();i++){\\n            map_freq[arr[i]].emplace_back(i);\\n        }\\n    }\\n    \\n    int query(int left, int right, int value) {\\n        int idx1=lower_bound(map_freq[value].begin(),map_freq[value].end(),left)-map_freq[value].begin();\\n        int idx2=upper_bound(map_freq[value].begin(),map_freq[value].end(),right)-map_freq[value].begin();\\n        return idx2-idx1;\\n    }\\n};\\n\\n/**\\n * Your RangeFreqQuery object will be instantiated and called as such:\\n * RangeFreqQuery* obj = new RangeFreqQuery(arr);\\n * int param_1 = obj->query(left,right,value);\\n */",
                "codeTag": "Java"
            },
            {
                "id": 3991874,
                "title": "c-easy-solution-using-segment-tree",
                "content": "```\\npublic class RangeFreqQuery {\\n    Dictionary<int,int>[] tree;\\n    int n;  \\n    public RangeFreqQuery(int[] arr) {\\n        n = arr.Length;\\n        tree = new Dictionary<int,int>[4 * n + 1];\\n        void build(int v,int vl,int vr){\\n            if(vl == vr){\\n                tree[v] = new Dictionary<int,int>();\\n                tree[v].Add(arr[vl],1);\\n                return;\\n            }\\n            int vm = (vl + vr) / 2;\\n            build(2 * v,vl,vm);\\n            build(2 * v + 1,vm + 1,vr);\\n            tree[v] = new Dictionary<int,int>();\\n            foreach(var kv in tree[2 * v]){\\n                if(!tree[v].ContainsKey(kv.Key)) tree[v].Add(kv.Key,kv.Value);\\n                else tree[v][kv.Key]+= kv.Value;\\n            }\\n            foreach(var kv in tree[2 * v + 1]){\\n                if(!tree[v].ContainsKey(kv.Key)) tree[v].Add(kv.Key,kv.Value);\\n                else tree[v][kv.Key]+= kv.Value;\\n            }\\n        }\\n        build(1,0, n - 1);\\n    }\\n    \\n    public int Query(int left, int right, int value) {\\n        int Get(int v,int vl,int vr,int l,int r){\\n            if(l > r) return 0;\\n            if(vl == l && vr == r)\\n                return (tree[v].ContainsKey(value)) ? tree[v][value] : 0;\\n            int vm = (vl + vr) / 2;\\n            int res1 = Get(2 * v,vl,vm,l,Math.Min(r,vm));\\n            int res2 = Get(2 * v + 1,vm + 1,vr,Math.Max(l,vm + 1),r);\\n            return res1 + res2;\\n        }\\n        return Get(1,0,n - 1,left,right);\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Hash Table",
                    "Segment Tree"
                ],
                "code": "```\\npublic class RangeFreqQuery {\\n    Dictionary<int,int>[] tree;\\n    int n;  \\n    public RangeFreqQuery(int[] arr) {\\n        n = arr.Length;\\n        tree = new Dictionary<int,int>[4 * n + 1];\\n        void build(int v,int vl,int vr){\\n            if(vl == vr){\\n                tree[v] = new Dictionary<int,int>();\\n                tree[v].Add(arr[vl],1);\\n                return;\\n            }\\n            int vm = (vl + vr) / 2;\\n            build(2 * v,vl,vm);\\n            build(2 * v + 1,vm + 1,vr);\\n            tree[v] = new Dictionary<int,int>();\\n            foreach(var kv in tree[2 * v]){\\n                if(!tree[v].ContainsKey(kv.Key)) tree[v].Add(kv.Key,kv.Value);\\n                else tree[v][kv.Key]+= kv.Value;\\n            }\\n            foreach(var kv in tree[2 * v + 1]){\\n                if(!tree[v].ContainsKey(kv.Key)) tree[v].Add(kv.Key,kv.Value);\\n                else tree[v][kv.Key]+= kv.Value;\\n            }\\n        }\\n        build(1,0, n - 1);\\n    }\\n    \\n    public int Query(int left, int right, int value) {\\n        int Get(int v,int vl,int vr,int l,int r){\\n            if(l > r) return 0;\\n            if(vl == l && vr == r)\\n                return (tree[v].ContainsKey(value)) ? tree[v][value] : 0;\\n            int vm = (vl + vr) / 2;\\n            int res1 = Get(2 * v,vl,vm,l,Math.Min(r,vm));\\n            int res2 = Get(2 * v + 1,vm + 1,vr,Math.Max(l,vm + 1),r);\\n            return res1 + res2;\\n        }\\n        return Get(1,0,n - 1,left,right);\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3983508,
                "title": "sqrt-decomposition",
                "content": "```\\nfrom collections import Counter\\n\\nclass RangeFreqQuery:\\n    def __init__(self, arr: List[int]):\\n        n = len(arr)\\n        B = int(pow(n, 0.5) + 1)\\n        blocks = [Counter() for _ in range(B)]\\n        for i in range(n):\\n            blocks[i // B][arr[i]] += 1\\n        self.B = B\\n        self.arr = arr\\n        self.blocks = blocks\\n\\n    def query(self, left: int, right: int, value: int) -> int:\\n        i = left\\n        res = 0\\n        while i <= right:\\n            if i % self.B == 0 and i + self.B - 1 <= right:\\n                res += self.blocks[i // self.B][value]\\n                i += self.B\\n            else:\\n                if self.arr[i] == value:\\n                    res += 1\\n                i += 1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import Counter\\n\\nclass RangeFreqQuery:\\n    def __init__(self, arr: List[int]):\\n        n = len(arr)\\n        B = int(pow(n, 0.5) + 1)\\n        blocks = [Counter() for _ in range(B)]\\n        for i in range(n):\\n            blocks[i // B][arr[i]] += 1\\n        self.B = B\\n        self.arr = arr\\n        self.blocks = blocks\\n\\n    def query(self, left: int, right: int, value: int) -> int:\\n        i = left\\n        res = 0\\n        while i <= right:\\n            if i % self.B == 0 and i + self.B - 1 <= right:\\n                res += self.blocks[i // self.B][value]\\n                i += self.B\\n            else:\\n                if self.arr[i] == value:\\n                    res += 1\\n                i += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3979019,
                "title": "using-segment-tree-in-c-easy-to-understand",
                "content": "\\n# Complexity\\n- Time complexity:\\n:) building tree  ,O( n * (combining the maps)) \\n:) Each Query O(height of tree * acessing element from map)\\nO(logn * logn) for each query\\nO(n * n logn *( acessing each element and updating ))\\nO( (nlogn)^2) building the segment tree; \\n\\n# Code\\n```\\nclass RangeFreqQuery {\\npublic:\\n// there is no update just build the tree\\n vector<unordered_map<int,int>>a;int n ; \\nunordered_map<int,int> combine(unordered_map<int,int>mp1 ,unordered_map<int,int>mp2)\\n{\\n    for(auto it : mp1)\\n    {\\n        mp1[it.first]+=mp2[it.first];\\n    }\\n    for(auto it : mp2)\\n    {\\n        if(mp1[it.first] == 0)\\n        {\\n            mp1[it.first] = mp2[it.first];\\n        }\\n    }\\n    return mp1;\\n}\\n\\n    RangeFreqQuery(vector<int>& arr) {\\n         n = arr.size();\\n        a.resize(3*n);int k = 0;\\n        for(int i = n ;i < 2*n ; ++i)\\n        {\\n            unordered_map<int,int>mp;\\n            mp[arr[k++]] = 1;\\n            a[i] = mp;\\n            //cout << mp[arr[i]] <<\"\\\\n\";\\n        }\\n        for(int i = n-1 ; i >= 1 ; i--)\\n        { //cout <<\"Hey\\\\n\";\\n            a[i] = combine(a[i << 1] , a[i<< 1 | 1]);\\n           \\n        }\\n\\n        // map<int,int >mp = a[0];\\n        // for(auto it : mp)\\n        // {\\n        //     cout <<it.first <<\" \" <<it.second <<\"\\\\n\";\\n        //             }\\n        // // this is building the segment tree\\n    }\\n    \\n    int query(int left, int right, int v) {\\n      \\n     // return 1;\\n       int l = left+n ,r = right+n;int ans = 0 ;\\n       // i just need the frequency of the element in the given range\\n       for( ; l <= r; l = l >> 1 , r = r >> 1)\\n       {\\n           if(l %2 == 1) { ans+=a[l][v]; l++;}\\n           if(r%2 == 0){ ans+=a[r][v] ;r--;}\\n\\n       }\\n\\n       return ans;\\n    }\\n};\\n\\n/**\\n * Your RangeFreqQuery object will be instantiated and called as such:\\n * RangeFreqQuery* obj = new RangeFreqQuery(arr);\\n * int param_1 = obj->query(left,right,value);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass RangeFreqQuery {\\npublic:\\n// there is no update just build the tree\\n vector<unordered_map<int,int>>a;int n ; \\nunordered_map<int,int> combine(unordered_map<int,int>mp1 ,unordered_map<int,int>mp2)\\n{\\n    for(auto it : mp1)\\n    {\\n        mp1[it.first]+=mp2[it.first];\\n    }\\n    for(auto it : mp2)\\n    {\\n        if(mp1[it.first] == 0)\\n        {\\n            mp1[it.first] = mp2[it.first];\\n        }\\n    }\\n    return mp1;\\n}\\n\\n    RangeFreqQuery(vector<int>& arr) {\\n         n = arr.size();\\n        a.resize(3*n);int k = 0;\\n        for(int i = n ;i < 2*n ; ++i)\\n        {\\n            unordered_map<int,int>mp;\\n            mp[arr[k++]] = 1;\\n            a[i] = mp;\\n            //cout << mp[arr[i]] <<\"\\\\n\";\\n        }\\n        for(int i = n-1 ; i >= 1 ; i--)\\n        { //cout <<\"Hey\\\\n\";\\n            a[i] = combine(a[i << 1] , a[i<< 1 | 1]);\\n           \\n        }\\n\\n        // map<int,int >mp = a[0];\\n        // for(auto it : mp)\\n        // {\\n        //     cout <<it.first <<\" \" <<it.second <<\"\\\\n\";\\n        //             }\\n        // // this is building the segment tree\\n    }\\n    \\n    int query(int left, int right, int v) {\\n      \\n     // return 1;\\n       int l = left+n ,r = right+n;int ans = 0 ;\\n       // i just need the frequency of the element in the given range\\n       for( ; l <= r; l = l >> 1 , r = r >> 1)\\n       {\\n           if(l %2 == 1) { ans+=a[l][v]; l++;}\\n           if(r%2 == 0){ ans+=a[r][v] ;r--;}\\n\\n       }\\n\\n       return ans;\\n    }\\n};\\n\\n/**\\n * Your RangeFreqQuery object will be instantiated and called as such:\\n * RangeFreqQuery* obj = new RangeFreqQuery(arr);\\n * int param_1 = obj->query(left,right,value);\\n */\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3973776,
                "title": "segment-tree-python-with-description",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nDivide and Conquer using Segment Tree\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n1. Segment Tree Initialization: You initialized your segment tree as a list of size nodes (which is calculated to be  (2\\xD7 ( 2^height \\u22121), which ensures enough space for all possible nodes in the tree.\\nYou then built the tree in the constructor itself. This is the typical use-case for segment trees: construct once, query many times.\\n\\n2. Building the Tree: If the current segment (defined by arr_left and arr_right) corresponds to a single element of the array, you stored that element in a list for that segment. Otherwise, you recursively built the tree for the left and right halves of the current segment. The values for the current segment are the sorted merge of the values of its two children. This ensures that all elements in the current segment are stored in sorted order for that segment node.\\nQuerying the Tree:\\n\\n3. You perform a standard segment tree query with range checking.\\nIf the current segment lies entirely inside the query range, you returned the count of the given value in the segment. If not, you recursively query the left and right children, if they overlap with the query range.\\n\\n\\n# Complexity\\n- Time complexity: O(n * logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n^2 * logn)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Segment Tree Using Array\\n\\nfrom math import ceil, log2\\n\\nclass Segment_Tree:\\n    def __init__(self, arr):\\n        self._arr = arr\\n        self.n = len(self._arr)\\n        height = ceil(log2(self.n)) # O(n^2 * logn)\\n        nodes = 2 * (2 ** height) - 1\\n        self.segment = [None] * nodes\\n        self.build_tree(0, self.n - 1, 0)\\n\\n    def build_tree(self, arr_left, arr_right, seg_idx):\\n        if arr_left == arr_right:\\n            self.segment[seg_idx] = [self._arr[arr_left]]\\n            return\\n        midpoint = (arr_left + arr_right) // 2\\n        self.build_tree(arr_left, midpoint, 2 * seg_idx + 1)\\n        self.build_tree(midpoint + 1, arr_right, 2 * seg_idx + 2)\\n        self.segment[seg_idx] = sorted(self.segment[2 * seg_idx + 1] + self.segment[2 * seg_idx + 2])\\n\\n    def query(self, query_left, query_right, value):\\n        return self.query_helper(query_left, query_right, 0, self.n - 1, value, 0)\\n\\n    def query_helper(self, query_left, query_right, arr_left, arr_right, value, seg_idx):\\n        if query_right < arr_left or arr_right < query_left:\\n            return 0\\n        if query_left <= arr_left and query_right >= arr_right:\\n            return self.segment[seg_idx].count(value)\\n        midpoint = (arr_left + arr_right) // 2\\n        return (self.query_helper(query_left, query_right, arr_left, midpoint, value, 2 * seg_idx + 1) + \\n                self.query_helper(query_left, query_right, midpoint + 1, arr_right, value, 2 * seg_idx + 2))\\n\\n\\nclass RangeFreqQuery:\\n    def __init__(self, arr: List[int]):\\n        self.st = Segment_Tree(arr)\\n\\n    def query(self, left: int, right: int, value: int) -> int:\\n        return self.st.query(left, right, value)\\n\\n\\n\\n\\n\\n\\n# Segment Tree Using Hashmap\\n\\nclass Segment_Tree:\\n    def __init__(self, arr):\\n        self._arr = arr\\n        self.n = len(self._arr)\\n        self.segment = {}\\n        self.build_tree(0, self.n - 1, 0)\\n\\n    def build_tree(self, arr_left, arr_right, seg_idx):\\n        if arr_left == arr_right:\\n            self.segment[seg_idx] = {self._arr[arr_left]: 1}\\n            return\\n\\n        midpoint = (arr_left + arr_right) // 2\\n        self.build_tree(arr_left, midpoint, 2 * seg_idx + 1)\\n        self.build_tree(midpoint + 1, arr_right, 2 * seg_idx + 2)\\n        \\n        self.segment[seg_idx] = {}\\n        for d in (self.segment[2 * seg_idx + 1], self.segment[2 * seg_idx + 2]):\\n            for key, value in d.items():\\n                if key in self.segment[seg_idx]:\\n                    self.segment[seg_idx][key] += value\\n                else:\\n                    self.segment[seg_idx][key] = value\\n\\n    def query(self, query_left, query_right, value):\\n        return self.query_helper(query_left, query_right, 0, self.n - 1, value, 0)\\n\\n    def query_helper(self, query_left, query_right, arr_left, arr_right, value, seg_idx):\\n        if query_right < arr_left or arr_right < query_left:\\n            return 0\\n        if query_left <= arr_left and query_right >= arr_right:\\n            return self.segment[seg_idx].get(value, 0)\\n        midpoint = (arr_left + arr_right) // 2\\n        return (self.query_helper(query_left, query_right, arr_left, midpoint, value, 2 * seg_idx + 1) + \\n                self.query_helper(query_left, query_right, midpoint + 1, arr_right, value, 2 * seg_idx + 2))\\n\\nclass RangeFreqQuery:\\n    def __init__(self, arr: List[int]):\\n        self.st = Segment_Tree(arr)\\n\\n    def query(self, left: int, right: int, value: int) -> int:\\n        return self.st.query(left, right, value)\\n\\n\\n\\n\\n# Your RangeFreqQuery object will be instantiated and called as such:\\n# obj = RangeFreqQuery(arr)\\n# param_1 = obj.query(left,right,value)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Segment Tree Using Array\\n\\nfrom math import ceil, log2\\n\\nclass Segment_Tree:\\n    def __init__(self, arr):\\n        self._arr = arr\\n        self.n = len(self._arr)\\n        height = ceil(log2(self.n)) # O(n^2 * logn)\\n        nodes = 2 * (2 ** height) - 1\\n        self.segment = [None] * nodes\\n        self.build_tree(0, self.n - 1, 0)\\n\\n    def build_tree(self, arr_left, arr_right, seg_idx):\\n        if arr_left == arr_right:\\n            self.segment[seg_idx] = [self._arr[arr_left]]\\n            return\\n        midpoint = (arr_left + arr_right) // 2\\n        self.build_tree(arr_left, midpoint, 2 * seg_idx + 1)\\n        self.build_tree(midpoint + 1, arr_right, 2 * seg_idx + 2)\\n        self.segment[seg_idx] = sorted(self.segment[2 * seg_idx + 1] + self.segment[2 * seg_idx + 2])\\n\\n    def query(self, query_left, query_right, value):\\n        return self.query_helper(query_left, query_right, 0, self.n - 1, value, 0)\\n\\n    def query_helper(self, query_left, query_right, arr_left, arr_right, value, seg_idx):\\n        if query_right < arr_left or arr_right < query_left:\\n            return 0\\n        if query_left <= arr_left and query_right >= arr_right:\\n            return self.segment[seg_idx].count(value)\\n        midpoint = (arr_left + arr_right) // 2\\n        return (self.query_helper(query_left, query_right, arr_left, midpoint, value, 2 * seg_idx + 1) + \\n                self.query_helper(query_left, query_right, midpoint + 1, arr_right, value, 2 * seg_idx + 2))\\n\\n\\nclass RangeFreqQuery:\\n    def __init__(self, arr: List[int]):\\n        self.st = Segment_Tree(arr)\\n\\n    def query(self, left: int, right: int, value: int) -> int:\\n        return self.st.query(left, right, value)\\n\\n\\n\\n\\n\\n\\n# Segment Tree Using Hashmap\\n\\nclass Segment_Tree:\\n    def __init__(self, arr):\\n        self._arr = arr\\n        self.n = len(self._arr)\\n        self.segment = {}\\n        self.build_tree(0, self.n - 1, 0)\\n\\n    def build_tree(self, arr_left, arr_right, seg_idx):\\n        if arr_left == arr_right:\\n            self.segment[seg_idx] = {self._arr[arr_left]: 1}\\n            return\\n\\n        midpoint = (arr_left + arr_right) // 2\\n        self.build_tree(arr_left, midpoint, 2 * seg_idx + 1)\\n        self.build_tree(midpoint + 1, arr_right, 2 * seg_idx + 2)\\n        \\n        self.segment[seg_idx] = {}\\n        for d in (self.segment[2 * seg_idx + 1], self.segment[2 * seg_idx + 2]):\\n            for key, value in d.items():\\n                if key in self.segment[seg_idx]:\\n                    self.segment[seg_idx][key] += value\\n                else:\\n                    self.segment[seg_idx][key] = value\\n\\n    def query(self, query_left, query_right, value):\\n        return self.query_helper(query_left, query_right, 0, self.n - 1, value, 0)\\n\\n    def query_helper(self, query_left, query_right, arr_left, arr_right, value, seg_idx):\\n        if query_right < arr_left or arr_right < query_left:\\n            return 0\\n        if query_left <= arr_left and query_right >= arr_right:\\n            return self.segment[seg_idx].get(value, 0)\\n        midpoint = (arr_left + arr_right) // 2\\n        return (self.query_helper(query_left, query_right, arr_left, midpoint, value, 2 * seg_idx + 1) + \\n                self.query_helper(query_left, query_right, midpoint + 1, arr_right, value, 2 * seg_idx + 2))\\n\\nclass RangeFreqQuery:\\n    def __init__(self, arr: List[int]):\\n        self.st = Segment_Tree(arr)\\n\\n    def query(self, left: int, right: int, value: int) -> int:\\n        return self.st.query(left, right, value)\\n\\n\\n\\n\\n# Your RangeFreqQuery object will be instantiated and called as such:\\n# obj = RangeFreqQuery(arr)\\n# param_1 = obj.query(left,right,value)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3942710,
                "title": "binary-search-and-partial-caching",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nConstructor $$O(n*log(n))$$\\nQuery $$O(log(n))$$\\nwhere $$n$$ is lenght of initial array\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n*log(n))$$ for binary tree and $$O(n*log(n))$$ for all map-caches in nodes\\n\\n# Code\\n```\\ntype RangeFreqQuery struct {\\n\\tleft_idx  int\\n\\tright_idx int\\n\\tborder    int\\n\\tfreqs     map[int]int\\n\\tleft      *RangeFreqQuery\\n\\tright     *RangeFreqQuery\\n}\\n\\nfunc Constructor(arr []int) RangeFreqQuery {\\n\\treturn *makeRFQNode(arr, 0)\\n}\\n\\nfunc makeRFQNode(arr []int, from_idx int) *RangeFreqQuery {\\n\\tif len(arr) == 0 {\\n\\t\\treturn nil\\n\\t}\\n\\n\\tfreqs := make(map[int]int)\\n\\tfor _, v := range arr {\\n\\t\\tfreqs[v] = freqs[v] + 1\\n\\t}\\n\\n\\tif len(arr) == 1 {\\n\\t\\treturn &RangeFreqQuery{\\n\\t\\t\\tleft_idx:  from_idx,\\n\\t\\t\\tright_idx: from_idx,\\n\\t\\t\\tborder:    from_idx,\\n\\t\\t\\tfreqs:     freqs,\\n\\t\\t\\tleft:      nil,\\n\\t\\t\\tright:     nil,\\n\\t\\t}\\n\\t}\\n\\n\\tleft_sub_arr, right_sub_arr := divide(arr)\\n\\n\\treturn &RangeFreqQuery{\\n\\t\\tleft_idx:  from_idx,\\n\\t\\tright_idx: from_idx + len(arr) - 1,\\n\\t\\tborder:    from_idx + len(arr)/2,\\n\\t\\tfreqs:     freqs,\\n\\t\\tleft:      makeRFQNode(left_sub_arr, from_idx),\\n\\t\\tright:     makeRFQNode(right_sub_arr, from_idx+len(left_sub_arr)),\\n\\t}\\n}\\n\\nfunc divide(arr []int) ([]int, []int) {\\n\\treturn arr[:len(arr)/2], arr[len(arr)/2:]\\n}\\n\\nfunc (this *RangeFreqQuery) Query(left int, right int, value int) int {\\n\\tif left > right || left < this.left_idx || right > this.right_idx {\\n\\t\\treturn 0\\n\\t}\\n\\tif left == this.left_idx && right == this.right_idx {\\n\\t\\treturn this.freqs[value]\\n\\t}\\n\\n\\tfreq := 0\\n\\tif this.left != nil {\\n\\t\\tfreq += this.left.Query(left, min(this.border-1, right), value)\\n\\t}\\n\\tif this.right != nil {\\n\\t\\tfreq += this.right.Query(max(this.border, left), right, value)\\n\\t}\\n\\n\\treturn freq\\n}\\n\\nfunc min(x, y int) int {\\n\\tif x < y {\\n\\t\\treturn x\\n\\t} else {\\n\\t\\treturn y\\n\\t}\\n}\\n\\nfunc max(x, y int) int {\\n\\tif x > y {\\n\\t\\treturn x\\n\\t} else {\\n\\t\\treturn y\\n\\t}\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\ntype RangeFreqQuery struct {\\n\\tleft_idx  int\\n\\tright_idx int\\n\\tborder    int\\n\\tfreqs     map[int]int\\n\\tleft      *RangeFreqQuery\\n\\tright     *RangeFreqQuery\\n}\\n\\nfunc Constructor(arr []int) RangeFreqQuery {\\n\\treturn *makeRFQNode(arr, 0)\\n}\\n\\nfunc makeRFQNode(arr []int, from_idx int) *RangeFreqQuery {\\n\\tif len(arr) == 0 {\\n\\t\\treturn nil\\n\\t}\\n\\n\\tfreqs := make(map[int]int)\\n\\tfor _, v := range arr {\\n\\t\\tfreqs[v] = freqs[v] + 1\\n\\t}\\n\\n\\tif len(arr) == 1 {\\n\\t\\treturn &RangeFreqQuery{\\n\\t\\t\\tleft_idx:  from_idx,\\n\\t\\t\\tright_idx: from_idx,\\n\\t\\t\\tborder:    from_idx,\\n\\t\\t\\tfreqs:     freqs,\\n\\t\\t\\tleft:      nil,\\n\\t\\t\\tright:     nil,\\n\\t\\t}\\n\\t}\\n\\n\\tleft_sub_arr, right_sub_arr := divide(arr)\\n\\n\\treturn &RangeFreqQuery{\\n\\t\\tleft_idx:  from_idx,\\n\\t\\tright_idx: from_idx + len(arr) - 1,\\n\\t\\tborder:    from_idx + len(arr)/2,\\n\\t\\tfreqs:     freqs,\\n\\t\\tleft:      makeRFQNode(left_sub_arr, from_idx),\\n\\t\\tright:     makeRFQNode(right_sub_arr, from_idx+len(left_sub_arr)),\\n\\t}\\n}\\n\\nfunc divide(arr []int) ([]int, []int) {\\n\\treturn arr[:len(arr)/2], arr[len(arr)/2:]\\n}\\n\\nfunc (this *RangeFreqQuery) Query(left int, right int, value int) int {\\n\\tif left > right || left < this.left_idx || right > this.right_idx {\\n\\t\\treturn 0\\n\\t}\\n\\tif left == this.left_idx && right == this.right_idx {\\n\\t\\treturn this.freqs[value]\\n\\t}\\n\\n\\tfreq := 0\\n\\tif this.left != nil {\\n\\t\\tfreq += this.left.Query(left, min(this.border-1, right), value)\\n\\t}\\n\\tif this.right != nil {\\n\\t\\tfreq += this.right.Query(max(this.border, left), right, value)\\n\\t}\\n\\n\\treturn freq\\n}\\n\\nfunc min(x, y int) int {\\n\\tif x < y {\\n\\t\\treturn x\\n\\t} else {\\n\\t\\treturn y\\n\\t}\\n}\\n\\nfunc max(x, y int) int {\\n\\tif x > y {\\n\\t\\treturn x\\n\\t} else {\\n\\t\\treturn y\\n\\t}\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3921616,
                "title": "python-100-tc-and-100-sc-binary-search-hash-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom collections import defaultdict\\nfrom bisect import bisect_left, bisect_right\\nclass RangeFreqQuery:\\n\\n    def __init__(self, arr: List[int]):\\n        self.dp=defaultdict(list)\\n        l=len(arr)\\n        for i in range(l):\\n            self.dp[arr[i]].append(i)\\n    def query(self, left: int, right: int, value: int) -> int:\\n        return bisect_right(self.dp[value],right)-bisect_left(self.dp[value],left)\\n        \\n\\n\\n# Your RangeFreqQuery object will be instantiated and called as such:\\n# obj = RangeFreqQuery(arr)\\n# param_1 = obj.query(left,right,value)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict\\nfrom bisect import bisect_left, bisect_right\\nclass RangeFreqQuery:\\n\\n    def __init__(self, arr: List[int]):\\n        self.dp=defaultdict(list)\\n        l=len(arr)\\n        for i in range(l):\\n            self.dp[arr[i]].append(i)\\n    def query(self, left: int, right: int, value: int) -> int:\\n        return bisect_right(self.dp[value],right)-bisect_left(self.dp[value],left)\\n        \\n\\n\\n# Your RangeFreqQuery object will be instantiated and called as such:\\n# obj = RangeFreqQuery(arr)\\n# param_1 = obj.query(left,right,value)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3910999,
                "title": "python-with-dict-and-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nUse a dict to store indices of a value in the array. These array are cleary of ascending order if we fill them from left to right. Then for each query, check how many occurences of `value` are in range `left` to `right` using `bisect`\\n\\n# Complexity\\n- Time complexity: $$O(log(n))$$\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom collections import defaultdict\\nfrom bisect import bisect_left as bl, bisect_right as br\\nclass RangeFreqQuery:\\n\\n    def __init__(self, arr: List[int]):\\n        # init a dict of sorted lists that store occurences of a number along the array\\n        # for example: 12, 33, 4, 56, 22, 2, 34, 33, 22, 12, 34, 56\\n        # 12: [0, 9], 33: [1, 7], 4: [2], 56: [3, 11], 22: [4, 8], 2: [5], 34: [6, 10]\\n        self.d = defaultdict(list)\\n        for i,num in enumerate(arr): self.d[num].append(i)\\n\\n\\n    def query(self, left: int, right: int, value: int) -> int:\\n        if value not in self.d: return 0\\n        return br(self.d[value], right) - bl(self.d[value], left) \\n\\n\\n# Your RangeFreqQuery object will be instantiated and called as such:\\n# obj = RangeFreqQuery(arr)\\n# param_1 = obj.query(left,right,value)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict\\nfrom bisect import bisect_left as bl, bisect_right as br\\nclass RangeFreqQuery:\\n\\n    def __init__(self, arr: List[int]):\\n        # init a dict of sorted lists that store occurences of a number along the array\\n        # for example: 12, 33, 4, 56, 22, 2, 34, 33, 22, 12, 34, 56\\n        # 12: [0, 9], 33: [1, 7], 4: [2], 56: [3, 11], 22: [4, 8], 2: [5], 34: [6, 10]\\n        self.d = defaultdict(list)\\n        for i,num in enumerate(arr): self.d[num].append(i)\\n\\n\\n    def query(self, left: int, right: int, value: int) -> int:\\n        if value not in self.d: return 0\\n        return br(self.d[value], right) - bl(self.d[value], left) \\n\\n\\n# Your RangeFreqQuery object will be instantiated and called as such:\\n# obj = RangeFreqQuery(arr)\\n# param_1 = obj.query(left,right,value)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3871267,
                "title": "swift-easy-solution-100-beat-time-space-new-way-to-find-frequency",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass RangeFreqQuery {\\n\\n     var arr = [Int]()\\n     var dict = [[Int]:Int]()\\n\\n    init(_ arr: [Int]) {\\n        self.arr = arr\\n    }\\n    \\n    func query(_ left: Int, _ right: Int, _ value: Int) -> Int {\\n        if let count = dict[[left,right,value]] {\\n          return count\\n        }else {\\n           let count = arr[left...right].reduce(0) {$0 + ($1 == value ? 1 : 0)}\\n           dict[[left,right,value]] = count\\n            return count\\n        }\\n    }\\n}\\n\\n/**\\n * Your RangeFreqQuery object will be instantiated and called as such:\\n * let obj = RangeFreqQuery(arr)\\n * let ret_1: Int = obj.query(left, right, value)\\n */\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass RangeFreqQuery {\\n\\n     var arr = [Int]()\\n     var dict = [[Int]:Int]()\\n\\n    init(_ arr: [Int]) {\\n        self.arr = arr\\n    }\\n    \\n    func query(_ left: Int, _ right: Int, _ value: Int) -> Int {\\n        if let count = dict[[left,right,value]] {\\n          return count\\n        }else {\\n           let count = arr[left...right].reduce(0) {$0 + ($1 == value ? 1 : 0)}\\n           dict[[left,right,value]] = count\\n            return count\\n        }\\n    }\\n}\\n\\n/**\\n * Your RangeFreqQuery object will be instantiated and called as such:\\n * let obj = RangeFreqQuery(arr)\\n * let ret_1: Int = obj.query(left, right, value)\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3853842,
                "title": "c-binary-search-with-map",
                "content": "# Approach\\nMake a map of vectors m<int, vector<int>>. Here key will be elements and vector will hold the indexes of the occurence of elements in arr. All the vectors in map will be sorted by default(why ?). Now we have to return the occurence of a element in range say [l,r]. Use binary search on the m[val] for l and r. In binary search always return position as greater than or equal to of the passed key.\\n\\nSuppose in arr\\n[1,2,3,5,3,6,3,2,3,3,2,3]\\n\\nfor val = 3 array of indexes of occurence will be\\nidxArr = [2,4,6,8,9,11]\\n\\nNow we have to find occurence of 3 in range [3,10]\\nbs for 3 will return 1 (as idxArr[1] > 3)\\nbs for 10 will return 5 (as idxArr[5] > 10)\\n\\nanswer will be -> (5 - 1) = 4\\n\\n# Complexity\\n- Time complexity:\\nO(logN)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass RangeFreqQuery {\\npublic:\\n    map<int,vector<int>> ma;\\n    int f;\\n    int l, r;\\n\\n    int bs(vector<int> &arr, int s, int e, int len, int val, int *found){\\n        if(s < 0 || e >= len || s > e){\\n            return s;\\n        }\\n        \\n        int m = (s + e) / 2;\\n        \\n        if (arr[m] == val){\\n            *found = 1;\\n            return m;\\n        }\\n\\n        if(arr[m] > val){\\n            return bs(arr, s, m - 1, len, val, found);\\n        }\\n        \\n        return bs(arr, m + 1, e, len, val, found);\\n    }\\n\\n    RangeFreqQuery(vector<int>& arr) {\\n        int len = arr.size();\\n        for(int i = 0; i < len; i++){\\n            ma[arr[i]].push_back(i);\\n        }\\n    }\\n    \\n\\n    int query(int left, int right, int value) {\\n        int len = ma[value].size();\\n        f = 0;\\n        l = bs(ma[value], 0, len - 1, len, left, &f);\\n        f = 0;\\n        r = bs(ma[value], 0, len - 1, len, right, &f);\\n\\n        return r - l + f;\\n    }\\n};\\n\\n/**\\n * Your RangeFreqQuery object will be instantiated and called as such:\\n * RangeFreqQuery* obj = new RangeFreqQuery(arr);\\n * int param_1 = obj->query(left,right,value);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass RangeFreqQuery {\\npublic:\\n    map<int,vector<int>> ma;\\n    int f;\\n    int l, r;\\n\\n    int bs(vector<int> &arr, int s, int e, int len, int val, int *found){\\n        if(s < 0 || e >= len || s > e){\\n            return s;\\n        }\\n        \\n        int m = (s + e) / 2;\\n        \\n        if (arr[m] == val){\\n            *found = 1;\\n            return m;\\n        }\\n\\n        if(arr[m] > val){\\n            return bs(arr, s, m - 1, len, val, found);\\n        }\\n        \\n        return bs(arr, m + 1, e, len, val, found);\\n    }\\n\\n    RangeFreqQuery(vector<int>& arr) {\\n        int len = arr.size();\\n        for(int i = 0; i < len; i++){\\n            ma[arr[i]].push_back(i);\\n        }\\n    }\\n    \\n\\n    int query(int left, int right, int value) {\\n        int len = ma[value].size();\\n        f = 0;\\n        l = bs(ma[value], 0, len - 1, len, left, &f);\\n        f = 0;\\n        r = bs(ma[value], 0, len - 1, len, right, &f);\\n\\n        return r - l + f;\\n    }\\n};\\n\\n/**\\n * Your RangeFreqQuery object will be instantiated and called as such:\\n * RangeFreqQuery* obj = new RangeFreqQuery(arr);\\n * int param_1 = obj->query(left,right,value);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3804780,
                "title": "the-shortest-solution-with-numpy-just-for-fun",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nnumpy has some optimize.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nbrute force\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport numpy as np\\nclass RangeFreqQuery:\\n\\n    def __init__(self, arr: List[int]):\\n        self.arr = np.array(arr, dtype=np.uint16)\\n        \\n\\n    def query(self, left: int, right: int, value: int) -> int:\\n        return (self.arr[left:right+1] == value).sum()\\n        \\n\\n\\n# Your RangeFreqQuery object will be instantiated and called as such:\\n# obj = RangeFreqQuery(arr)\\n# param_1 = obj.query(left,right,value)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport numpy as np\\nclass RangeFreqQuery:\\n\\n    def __init__(self, arr: List[int]):\\n        self.arr = np.array(arr, dtype=np.uint16)\\n        \\n\\n    def query(self, left: int, right: int, value: int) -> int:\\n        return (self.arr[left:right+1] == value).sum()\\n        \\n\\n\\n# Your RangeFreqQuery object will be instantiated and called as such:\\n# obj = RangeFreqQuery(arr)\\n# param_1 = obj.query(left,right,value)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3796900,
                "title": "map-binary-search-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass RangeFreqQuery {\\n    unordered_map<int, vector<int>> numToPos;\\npublic:\\n    RangeFreqQuery(vector<int>& arr) {\\n        for(int i=0; i<arr.size(); i++){\\n            numToPos[arr[i]].push_back(i);\\n        }\\n    }\\n    \\n    int query(int left, int right, int value) {\\n        if(numToPos.find(value) == numToPos.end()) return 0;\\n\\n        int l = 0, r = numToPos[value].size()-1;\\n        if(right < numToPos[value][l] || numToPos[value][r] < left)\\n         return 0;\\n\\n        int leftIdx, rightIdx;\\n        while(l <= r){\\n            int m = l + (r-l)/2;\\n            \\n            if(left <= numToPos[value][m] ){\\n                 leftIdx = m;\\n                 r  = m-1;\\n            }\\n            else l = m+1;\\n        }\\n        l=0, r = numToPos[value].size()-1;\\n        while(l <= r){\\n            int m = l + (r-l)/2;\\n        \\n            if(numToPos[value][m] <= right) {\\n               rightIdx = m;\\n               l = m+1;\\n            }\\n            else r = m-1;\\n        }\\n        return (rightIdx - leftIdx + 1);\\n    }\\n};\\n\\n/**\\n * Your RangeFreqQuery object will be instantiated and called as such:\\n * RangeFreqQuery* obj = new RangeFreqQuery(arr);\\n * int param_1 = obj->query(left,right,value);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass RangeFreqQuery {\\n    unordered_map<int, vector<int>> numToPos;\\npublic:\\n    RangeFreqQuery(vector<int>& arr) {\\n        for(int i=0; i<arr.size(); i++){\\n            numToPos[arr[i]].push_back(i);\\n        }\\n    }\\n    \\n    int query(int left, int right, int value) {\\n        if(numToPos.find(value) == numToPos.end()) return 0;\\n\\n        int l = 0, r = numToPos[value].size()-1;\\n        if(right < numToPos[value][l] || numToPos[value][r] < left)\\n         return 0;\\n\\n        int leftIdx, rightIdx;\\n        while(l <= r){\\n            int m = l + (r-l)/2;\\n            \\n            if(left <= numToPos[value][m] ){\\n                 leftIdx = m;\\n                 r  = m-1;\\n            }\\n            else l = m+1;\\n        }\\n        l=0, r = numToPos[value].size()-1;\\n        while(l <= r){\\n            int m = l + (r-l)/2;\\n        \\n            if(numToPos[value][m] <= right) {\\n               rightIdx = m;\\n               l = m+1;\\n            }\\n            else r = m-1;\\n        }\\n        return (rightIdx - leftIdx + 1);\\n    }\\n};\\n\\n/**\\n * Your RangeFreqQuery object will be instantiated and called as such:\\n * RangeFreqQuery* obj = new RangeFreqQuery(arr);\\n * int param_1 = obj->query(left,right,value);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3745084,
                "title": "simple-cpp-solution-using-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass RangeFreqQuery {\\npublic:\\nvector<vector<int>> freq;\\n    RangeFreqQuery(vector<int>& arr) {\\n        int ma=*max_element(arr.begin(),arr.end());\\n        freq=vector<vector<int>>(ma+1,vector<int>(0,0));\\n        for(int i=0;i<arr.size();i++)\\n        freq[arr[i]].push_back(i);\\n    }\\n    \\n    int query(int left, int right, int value) {\\n        if(value>=freq.size()||freq[value].size()==0)return 0;\\n        if(left>freq[value][freq[value].size()-1]||right<freq[value][0])return 0;\\n        int t1=-1,t2=-1;\\n        int start=0,end=freq[value].size()-1;\\n        if(freq[value][0]>=left)t1=0;\\n        else{\\n        while(start<=end){\\n            int mid=(start+end)/2;\\n            if(freq[value][mid]>=left && freq[value][mid-1]<left){t1=mid;break;}\\n            if(freq[value][mid]>=left)end=mid-1;\\n            else\\n            start=mid+1;\\n        }\\n        }\\n        if(freq[value][freq[value].size()-1]<=right)t2=freq[value].size()-1;\\n        else{\\n            start=0,end=freq[value].size()-1;\\n            while(start<=end){\\n                 int mid=(start+end)/2;\\n            if(freq[value][mid]<=right && freq[value][mid+1]>right){t2=mid;break;}\\n            if(freq[value][mid]>right)end=mid-1;\\n            else\\n            start=mid+1;\\n            }\\n        }\\n        return t2-t1+1;\\n    }\\n};\\n\\n/**\\n * Your RangeFreqQuery object will be instantiated and called as such:\\n * RangeFreqQuery* obj = new RangeFreqQuery(arr);\\n * int param_1 = obj->query(left,right,value);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass RangeFreqQuery {\\npublic:\\nvector<vector<int>> freq;\\n    RangeFreqQuery(vector<int>& arr) {\\n        int ma=*max_element(arr.begin(),arr.end());\\n        freq=vector<vector<int>>(ma+1,vector<int>(0,0));\\n        for(int i=0;i<arr.size();i++)\\n        freq[arr[i]].push_back(i);\\n    }\\n    \\n    int query(int left, int right, int value) {\\n        if(value>=freq.size()||freq[value].size()==0)return 0;\\n        if(left>freq[value][freq[value].size()-1]||right<freq[value][0])return 0;\\n        int t1=-1,t2=-1;\\n        int start=0,end=freq[value].size()-1;\\n        if(freq[value][0]>=left)t1=0;\\n        else{\\n        while(start<=end){\\n            int mid=(start+end)/2;\\n            if(freq[value][mid]>=left && freq[value][mid-1]<left){t1=mid;break;}\\n            if(freq[value][mid]>=left)end=mid-1;\\n            else\\n            start=mid+1;\\n        }\\n        }\\n        if(freq[value][freq[value].size()-1]<=right)t2=freq[value].size()-1;\\n        else{\\n            start=0,end=freq[value].size()-1;\\n            while(start<=end){\\n                 int mid=(start+end)/2;\\n            if(freq[value][mid]<=right && freq[value][mid+1]>right){t2=mid;break;}\\n            if(freq[value][mid]>right)end=mid-1;\\n            else\\n            start=mid+1;\\n            }\\n        }\\n        return t2-t1+1;\\n    }\\n};\\n\\n/**\\n * Your RangeFreqQuery object will be instantiated and called as such:\\n * RangeFreqQuery* obj = new RangeFreqQuery(arr);\\n * int param_1 = obj->query(left,right,value);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3744251,
                "title": "c-segment-tree-clean-implementation",
                "content": "## Code\\n```\\n\\n// T.C - O(n) - Constructing Tree (Max - 4 * n nodes)\\n//       O(log n) - For Querying (Finding frequency)\\n\\n// S.C - O(n^2) - Segment Tree (vector of unordered maps) \\n\\nclass SegmentTree{\\npublic:\\n    vector<unordered_map<int,int>> range;\\n    int n;\\n    \\n    SegmentTree(vector<int> &arr){\\n        n = size(arr);\\n        range.resize(4*n);\\n        construct(0, n-1, arr, 0);\\n    }\\n    \\n    void construct(int l, int r, vector<int>& arr, int i){\\n        if(l == r) {\\n            range[i][arr[l]]++;\\n            return;\\n        }\\n        int mid = l + (r-l) / 2;\\n        construct(l, mid, arr, 2 * i + 1);\\n        construct(mid+1, r, arr, 2 * i + 2);\\n        for(auto &[k,v] : range[2 * i + 1]) range[i][k] += v;\\n        for(auto &[k,v] : range[2 * i + 2]) range[i][k] += v;\\n    }\\n    \\n    int query(int l, int r, int s, int e, int i, int val){\\n        if(s > r or e < l) return 0;\\n        if(l <= s and r >= e) {\\n            return range[i][val];\\n        }\\n        int mid = s + (e - s) / 2;\\n        return query(l, r, s, mid, 2 * i + 1, val) + query(l, r, mid+1, e, 2 * i + 2, val);\\n    }\\n    \\n};\\n\\n\\nclass RangeFreqQuery {\\npublic:\\n    \\n    SegmentTree* st;\\n    int n;\\n    \\n    RangeFreqQuery(vector<int>& arr) {\\n        n = size(arr);\\n        st = new SegmentTree(arr);\\n    }\\n    \\n    int query(int left, int right, int value) {\\n        return st->query(left, right, 0, n - 1, 0, value);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Segment Tree"
                ],
                "code": "```\\n\\n// T.C - O(n) - Constructing Tree (Max - 4 * n nodes)\\n//       O(log n) - For Querying (Finding frequency)\\n\\n// S.C - O(n^2) - Segment Tree (vector of unordered maps) \\n\\nclass SegmentTree{\\npublic:\\n    vector<unordered_map<int,int>> range;\\n    int n;\\n    \\n    SegmentTree(vector<int> &arr){\\n        n = size(arr);\\n        range.resize(4*n);\\n        construct(0, n-1, arr, 0);\\n    }\\n    \\n    void construct(int l, int r, vector<int>& arr, int i){\\n        if(l == r) {\\n            range[i][arr[l]]++;\\n            return;\\n        }\\n        int mid = l + (r-l) / 2;\\n        construct(l, mid, arr, 2 * i + 1);\\n        construct(mid+1, r, arr, 2 * i + 2);\\n        for(auto &[k,v] : range[2 * i + 1]) range[i][k] += v;\\n        for(auto &[k,v] : range[2 * i + 2]) range[i][k] += v;\\n    }\\n    \\n    int query(int l, int r, int s, int e, int i, int val){\\n        if(s > r or e < l) return 0;\\n        if(l <= s and r >= e) {\\n            return range[i][val];\\n        }\\n        int mid = s + (e - s) / 2;\\n        return query(l, r, s, mid, 2 * i + 1, val) + query(l, r, mid+1, e, 2 * i + 2, val);\\n    }\\n    \\n};\\n\\n\\nclass RangeFreqQuery {\\npublic:\\n    \\n    SegmentTree* st;\\n    int n;\\n    \\n    RangeFreqQuery(vector<int>& arr) {\\n        n = size(arr);\\n        st = new SegmentTree(arr);\\n    }\\n    \\n    int query(int left, int right, int value) {\\n        return st->query(left, right, 0, n - 1, 0, value);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3728260,
                "title": "java-mapping-binary-search",
                "content": "\\n\\n# Code\\n```\\nclass RangeFreqQuery {\\n\\n    List<Integer> locations[];\\n    public RangeFreqQuery(int[] arr) {\\n        locations = new List[10001];\\n        for (int i = 0; i<arr.length; i++){\\n            int val = arr[i];\\n            if (locations[val] == null)  locations[val] = new ArrayList();\\n            locations[val].add(i);\\n        }\\n    }\\n    \\n    public int query(int left, int right, int value) {\\n        if (locations[value] == null) return 0;\\n        int startFrom = Collections.binarySearch(locations[value],left);\\n        if (startFrom < 0) startFrom = -(startFrom+1); \\n        int endsAt = Collections.binarySearch(locations[value],right);\\n        if (endsAt< 0) endsAt = -(endsAt+1) - 1;  \\n        return endsAt < startFrom ? 0 : endsAt == startFrom ? 1 : endsAt - startFrom + 1;\\n    }\\n}\\n\\n/**\\n * Your RangeFreqQuery object will be instantiated and called as such:\\n * RangeFreqQuery obj = new RangeFreqQuery(arr);\\n * int param_1 = obj.query(left,right,value);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass RangeFreqQuery {\\n\\n    List<Integer> locations[];\\n    public RangeFreqQuery(int[] arr) {\\n        locations = new List[10001];\\n        for (int i = 0; i<arr.length; i++){\\n            int val = arr[i];\\n            if (locations[val] == null)  locations[val] = new ArrayList();\\n            locations[val].add(i);\\n        }\\n    }\\n    \\n    public int query(int left, int right, int value) {\\n        if (locations[value] == null) return 0;\\n        int startFrom = Collections.binarySearch(locations[value],left);\\n        if (startFrom < 0) startFrom = -(startFrom+1); \\n        int endsAt = Collections.binarySearch(locations[value],right);\\n        if (endsAt< 0) endsAt = -(endsAt+1) - 1;  \\n        return endsAt < startFrom ? 0 : endsAt == startFrom ? 1 : endsAt - startFrom + 1;\\n    }\\n}\\n\\n/**\\n * Your RangeFreqQuery object will be instantiated and called as such:\\n * RangeFreqQuery obj = new RangeFreqQuery(arr);\\n * int param_1 = obj.query(left,right,value);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3684372,
                "title": "java-easy-solution-0-sec",
                "content": "# Intuition\\n![upvote.png](https://assets.leetcode.com/users/images/78db8fe5-aadf-426a-acf1-5c6e83bd6506_1687770841.1735418.png)\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass RangeFreqQuery {\\n    //Use map\\'s key to store arr\\'s value, map\\'s value to keep <value\\'s location, cummulative arr\\'s value count>\\n    HashMap<Integer, TreeMap<Integer, Integer>> map;\\n    public RangeFreqQuery(int[] arr) {\\n        //O(nlog(n))\\n        map = new HashMap<>();\\n        for(int i = 0; i < arr.length; i++){\\n            map.putIfAbsent(arr[i], new TreeMap<>());\\n            TreeMap<Integer, Integer> tree = map.get(arr[i]);\\n            //i = value\\'s location\\n            //tree.size() = cummulative arr\\'s value count - 1\\n            tree.put(i, tree.size());\\n        }\\n    }\\n    \\n    public int query(int left, int right, int value) {\\n        //O(log(n))\\n        \\n        //check if value exist in map\\n        if(!map.containsKey(value)){\\n            return 0;\\n        }\\n        TreeMap<Integer, Integer> tree = map.get(value);\\n        \\n        //check if there exist position >= left and position <= right\\n        //if not, return 0\\n        if(tree.ceilingKey(left) == null || tree.floorKey(right) == null){\\n            return 0;\\n        }\\n        //get leftMost position\\'s cummulative count\\n        int leftMost = tree.get(tree.ceilingKey(left));\\n        //get rightMost position\\'s cummulative count\\n        int rightMost = tree.get(tree.floorKey(right));\\n        \\n        return rightMost - leftMost + 1;\\n    }\\n}\\n\\n/**\\n * Your RangeFreqQuery object will be instantiated and called as such:\\n * RangeFreqQuery obj = new RangeFreqQuery(arr);\\n * int param_1 = obj.query(left,right,value);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass RangeFreqQuery {\\n    //Use map\\'s key to store arr\\'s value, map\\'s value to keep <value\\'s location, cummulative arr\\'s value count>\\n    HashMap<Integer, TreeMap<Integer, Integer>> map;\\n    public RangeFreqQuery(int[] arr) {\\n        //O(nlog(n))\\n        map = new HashMap<>();\\n        for(int i = 0; i < arr.length; i++){\\n            map.putIfAbsent(arr[i], new TreeMap<>());\\n            TreeMap<Integer, Integer> tree = map.get(arr[i]);\\n            //i = value\\'s location\\n            //tree.size() = cummulative arr\\'s value count - 1\\n            tree.put(i, tree.size());\\n        }\\n    }\\n    \\n    public int query(int left, int right, int value) {\\n        //O(log(n))\\n        \\n        //check if value exist in map\\n        if(!map.containsKey(value)){\\n            return 0;\\n        }\\n        TreeMap<Integer, Integer> tree = map.get(value);\\n        \\n        //check if there exist position >= left and position <= right\\n        //if not, return 0\\n        if(tree.ceilingKey(left) == null || tree.floorKey(right) == null){\\n            return 0;\\n        }\\n        //get leftMost position\\'s cummulative count\\n        int leftMost = tree.get(tree.ceilingKey(left));\\n        //get rightMost position\\'s cummulative count\\n        int rightMost = tree.get(tree.floorKey(right));\\n        \\n        return rightMost - leftMost + 1;\\n    }\\n}\\n\\n/**\\n * Your RangeFreqQuery object will be instantiated and called as such:\\n * RangeFreqQuery obj = new RangeFreqQuery(arr);\\n * int param_1 = obj.query(left,right,value);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3681305,
                "title": "python-segment-tree-solution",
                "content": "# Intuition\\nThis is not the best aproach, i only implemented segment tree only to learn it.\\n\\n# Complexity\\n- Time complexity:$$O(nlogn)$$ is the segment tree creation, $$O(logn)$$ to compute for single querry input\\n- Space complexity:$$O(nlogn)$$, because i keep count data for each node in parent nodes\\n# Code\\n```\\nclass RangeFreqQuery:\\n    def __init__(self, arr: List[int]):\\n\\n        N = len(arr)\\n\\n        self.init_list = arr\\n        self.segment_tree = [{} for _ in range(2 * len(arr))]\\n\\n        for i in range(len(arr)):\\n            self.segment_tree[i+N] = {arr[i]:1}\\n            cur_val = arr[i]\\n            j = (i+N)//2\\n\\n            while j:\\n                parent = self.segment_tree[j]\\n                parent[cur_val] = 1 + parent.get(cur_val, 0)\\n                j //= 2\\n\\n        \\n\\n    def query(self, left: int, right: int, value: int) -> int:\\n        res = 0\\n\\n        left += len(self.init_list)\\n        right += len(self.init_list)\\n\\n        while left<right:\\n            if left&1:\\n                res += self.segment_tree[left].get(value, 0)\\n                left+=1\\n            if right%2==0:\\n                res += self.segment_tree[right].get(value, 0)\\n                right -= 1\\n\\n            left //= 2\\n            right //= 2\\n\\n        if left == right:\\n            res += self.segment_tree[left].get(value, 0)\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass RangeFreqQuery:\\n    def __init__(self, arr: List[int]):\\n\\n        N = len(arr)\\n\\n        self.init_list = arr\\n        self.segment_tree = [{} for _ in range(2 * len(arr))]\\n\\n        for i in range(len(arr)):\\n            self.segment_tree[i+N] = {arr[i]:1}\\n            cur_val = arr[i]\\n            j = (i+N)//2\\n\\n            while j:\\n                parent = self.segment_tree[j]\\n                parent[cur_val] = 1 + parent.get(cur_val, 0)\\n                j //= 2\\n\\n        \\n\\n    def query(self, left: int, right: int, value: int) -> int:\\n        res = 0\\n\\n        left += len(self.init_list)\\n        right += len(self.init_list)\\n\\n        while left<right:\\n            if left&1:\\n                res += self.segment_tree[left].get(value, 0)\\n                left+=1\\n            if right%2==0:\\n                res += self.segment_tree[right].get(value, 0)\\n                right -= 1\\n\\n            left //= 2\\n            right //= 2\\n\\n        if left == right:\\n            res += self.segment_tree[left].get(value, 0)\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3667997,
                "title": "segment-tree-java-solution",
                "content": "Try to create A segement tree which is constructed as a Node of HashMap ,\\nOn each query try to find the appropriate range and add the counts.\\n\\nclass RangeFreqQuery {\\n\\n    SegmentTree tr;\\n    public RangeFreqQuery(int[] arr) \\n    {\\n        tr=new SegmentTree(arr);\\n     \\n        \\n    }\\n    \\n    public int query(int left, int right, int value)\\n    {\\n        return tr.getCountUtil(left,right,value);\\n    }\\n}\\nclass SegmentTree\\n{\\n    int ori[];\\n    HashMap<Integer,Integer> nr[];\\n    SegmentTree(int ar[])\\n    {\\n        nr=new HashMap[ar.length*4];\\n        ori=Arrays.copyOfRange(ar,0,ar.length);\\n         formTree(0,ori.length-1,0);\\n    }\\n    \\n\\t// Segment Tree Construction\\n    HashMap<Integer,Integer> formTree(int l,int r,int index)\\n    {\\n       \\n        if(l==r)\\n        {\\n            \\n            HashMap<Integer,Integer> h=new HashMap();\\n            h.put(ori[l],1);\\n            nr[index] = h;\\n        \\n            return h;\\n            \\n        }\\n        int mid=l+(r-l)/2;\\n\\t\\t// combine Left and right childrens and form a new Map\\n        nr[index] = combineMap(formTree(l,mid,2*index+1),formTree(mid+1,r,2*index+2));\\n   \\n        return nr[index];\\n    }\\n\\t\\n\\t// l and r are the range given in query \\n    int getCountUtil(int l,int r,int val)\\n    {\\n        return getCount(0,ori.length-1,l,r,val,0);\\n    }\\n\\t\\n\\t// l,r are original array range a,b are range of the query input\\n    int getCount(int l,int r,int a,int b,int val,int index)\\n    {\\n        \\n        if(a<=l&&r<=b)\\n        {\\n            return nr[index].getOrDefault(val,0);\\n        }\\n        if(b<l||a>r)\\n            return 0;\\n        \\n        int mid=l+(r-l)/2;\\n        int h1=getCount(l,mid,a,b,val,2*index+1);\\n       int h2=getCount(mid+1,r,a,b,val,2*index+2);\\n        return h1+h2;\\n    }\\n\\t\\n\\t// function to merge two Maps (In this case left and right nodes of Segment Tree)\\n    HashMap<Integer,Integer> combineMap(HashMap<Integer,Integer> h1,HashMap<Integer,Integer> h2)\\n    {\\n        HashMap<Integer,Integer> gj=new HashMap();\\n        for(Map.Entry<Integer,Integer> e:h1.entrySet())\\n        {\\n            gj.put(e.getKey(),e.getValue());\\n        }\\n         for(Map.Entry<Integer,Integer> e:h2.entrySet())\\n        {\\n            gj.put(e.getKey(),gj.getOrDefault(e.getKey(),0)+e.getValue());\\n        }\\n        //h1.putAll(h2);\\n        return gj;\\n    }\\n}\\n\\nTime Complexity - \\nQuery - O(LogN)\\nConstructTree - O(NLogN)",
                "solutionTags": [],
                "code": "Try to create A segement tree which is constructed as a Node of HashMap ,\\nOn each query try to find the appropriate range and add the counts.\\n\\nclass RangeFreqQuery {\\n\\n    SegmentTree tr;\\n    public RangeFreqQuery(int[] arr) \\n    {\\n        tr=new SegmentTree(arr);\\n     \\n        \\n    }\\n    \\n    public int query(int left, int right, int value)\\n    {\\n        return tr.getCountUtil(left,right,value);\\n    }\\n}\\nclass SegmentTree\\n{\\n    int ori[];\\n    HashMap<Integer,Integer> nr[];\\n    SegmentTree(int ar[])\\n    {\\n        nr=new HashMap[ar.length*4];\\n        ori=Arrays.copyOfRange(ar,0,ar.length);\\n         formTree(0,ori.length-1,0);\\n    }\\n    \\n\\t// Segment Tree Construction\\n    HashMap<Integer,Integer> formTree(int l,int r,int index)\\n    {\\n       \\n        if(l==r)\\n        {\\n            \\n            HashMap<Integer,Integer> h=new HashMap();\\n            h.put(ori[l],1);\\n            nr[index] = h;\\n        \\n            return h;\\n            \\n        }\\n        int mid=l+(r-l)/2;\\n\\t\\t// combine Left and right childrens and form a new Map\\n        nr[index] = combineMap(formTree(l,mid,2*index+1),formTree(mid+1,r,2*index+2));\\n   \\n        return nr[index];\\n    }\\n\\t\\n\\t// l and r are the range given in query \\n    int getCountUtil(int l,int r,int val)\\n    {\\n        return getCount(0,ori.length-1,l,r,val,0);\\n    }\\n\\t\\n\\t// l,r are original array range a,b are range of the query input\\n    int getCount(int l,int r,int a,int b,int val,int index)\\n    {\\n        \\n        if(a<=l&&r<=b)\\n        {\\n            return nr[index].getOrDefault(val,0);\\n        }\\n        if(b<l||a>r)\\n            return 0;\\n        \\n        int mid=l+(r-l)/2;\\n        int h1=getCount(l,mid,a,b,val,2*index+1);\\n       int h2=getCount(mid+1,r,a,b,val,2*index+2);\\n        return h1+h2;\\n    }\\n\\t\\n\\t// function to merge two Maps (In this case left and right nodes of Segment Tree)\\n    HashMap<Integer,Integer> combineMap(HashMap<Integer,Integer> h1,HashMap<Integer,Integer> h2)\\n    {\\n        HashMap<Integer,Integer> gj=new HashMap();\\n        for(Map.Entry<Integer,Integer> e:h1.entrySet())\\n        {\\n            gj.put(e.getKey(),e.getValue());\\n        }\\n         for(Map.Entry<Integer,Integer> e:h2.entrySet())\\n        {\\n            gj.put(e.getKey(),gj.getOrDefault(e.getKey(),0)+e.getValue());\\n        }\\n        //h1.putAll(h2);\\n        return gj;\\n    }\\n}\\n\\nTime Complexity - \\nQuery - O(LogN)\\nConstructTree - O(NLogN)",
                "codeTag": "Java"
            },
            {
                "id": 3667206,
                "title": "caching-bisect",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass RangeFreqQuery:\\n\\n    def __init__(self, arr: List[int]):\\n        self.arr=arr\\n        self.dic=dict()\\n        self.map=dict()\\n        for i in range(len(self.arr)):\\n            if self.arr[i] in  self.map:self.map[self.arr[i]].append(i)\\n            else:self.map[self.arr[i]]=[i]\\n            \\n    def query(self, left: int, right: int, val: int) -> int:\\n        if f\"{left}-{right}-{val}\" in self.dic:return self.dic.get(f\"{left}-{right}-{val}\")\\n        if not val in self.map:return 0\\n        first,last=bisect.bisect_left(self.map[val],left),bisect.bisect_right(self.map[val],right)\\n        self.dic[f\"{left}-{right}-{val}\"]=len(self.map[val][first:last])\\n        return len(self.map[val][first:last])\\n\\n# Your RangeFreqQuery object will be instantiated and called as such:\\n# obj = RangeFreqQuery(arr)\\n# param_1 = obj.query(left,right,value)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "Binary Search"
                ],
                "code": "```\\nclass RangeFreqQuery:\\n\\n    def __init__(self, arr: List[int]):\\n        self.arr=arr\\n        self.dic=dict()\\n        self.map=dict()\\n        for i in range(len(self.arr)):\\n            if self.arr[i] in  self.map:self.map[self.arr[i]].append(i)\\n            else:self.map[self.arr[i]]=[i]\\n            \\n    def query(self, left: int, right: int, val: int) -> int:\\n        if f\"{left}-{right}-{val}\" in self.dic:return self.dic.get(f\"{left}-{right}-{val}\")\\n        if not val in self.map:return 0\\n        first,last=bisect.bisect_left(self.map[val],left),bisect.bisect_right(self.map[val],right)\\n        self.dic[f\"{left}-{right}-{val}\"]=len(self.map[val][first:last])\\n        return len(self.map[val][first:last])\\n\\n# Your RangeFreqQuery object will be instantiated and called as such:\\n# obj = RangeFreqQuery(arr)\\n# param_1 = obj.query(left,right,value)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3634760,
                "title": "java-using-list",
                "content": "# Code\\n```\\nclass RangeFreqQuery {\\n    List<Integer>[] range;\\n    public RangeFreqQuery(int[] arr) {\\n        range = new ArrayList[10001];\\n        for(int i = 0; i < arr.length; i++){\\n            if(range[arr[i]] == null)\\n                range[arr[i]] = new ArrayList<>();\\n            range[arr[i]].add(i);\\n        }\\n    }\\n    \\n    public int query(int left, int right, int value) {\\n        List<Integer> arr = range[value];\\n        if(arr == null){\\n            return 0;\\n        }\\n        int l = Collections.binarySearch(arr,left);\\n        if(l < 0){\\n            l = (int)Math.abs(l + 1);\\n        }\\n        int r = Collections.binarySearch(arr,right);\\n        if(r < 0){\\n            r = (int)Math.abs(r + 1)-1;\\n        }\\n        return r - l +1;\\n    }\\n}\\n\\n/**\\n * Your RangeFreqQuery object will be instantiated and called as such:\\n * RangeFreqQuery* obj = new RangeFreqQuery(arr);\\n * int param_1 = obj->query(left,right,value);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass RangeFreqQuery {\\n    List<Integer>[] range;\\n    public RangeFreqQuery(int[] arr) {\\n        range = new ArrayList[10001];\\n        for(int i = 0; i < arr.length; i++){\\n            if(range[arr[i]] == null)\\n                range[arr[i]] = new ArrayList<>();\\n            range[arr[i]].add(i);\\n        }\\n    }\\n    \\n    public int query(int left, int right, int value) {\\n        List<Integer> arr = range[value];\\n        if(arr == null){\\n            return 0;\\n        }\\n        int l = Collections.binarySearch(arr,left);\\n        if(l < 0){\\n            l = (int)Math.abs(l + 1);\\n        }\\n        int r = Collections.binarySearch(arr,right);\\n        if(r < 0){\\n            r = (int)Math.abs(r + 1)-1;\\n        }\\n        return r - l +1;\\n    }\\n}\\n\\n/**\\n * Your RangeFreqQuery object will be instantiated and called as such:\\n * RangeFreqQuery* obj = new RangeFreqQuery(arr);\\n * int param_1 = obj->query(left,right,value);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3615488,
                "title": "java-segment-tree",
                "content": "A segment tree is constructed from the elements, from bottom up counting the occurrences. \\n\\n```\\n  class TreeNode {\\n        HashMap<Integer, Integer> occurrences;\\n        int startIndex;\\n        int endIndex;\\n        TreeNode left;\\n        TreeNode right;\\n\\n        public TreeNode() {\\n        }\\n\\n        public TreeNode(HashMap<Integer, Integer> occurrences, int startIndex, int endIndex) {\\n            this.occurrences = occurrences;\\n            this.startIndex = startIndex;\\n            this.endIndex = endIndex;\\n        }\\n\\n        public TreeNode(HashMap<Integer, Integer> occurrences,\\n                        int startIndex,\\n                        int endIndex,\\n                        TreeNode left,\\n                        TreeNode right) {\\n            this.occurrences = occurrences;\\n            this.startIndex = startIndex;\\n            this.endIndex = endIndex;\\n            this.left = left;\\n            this.right = right;\\n        }\\n\\n        @Override\\n        public String toString() {\\n            return String.format(\"Range: %d-%d\", this.startIndex, this.endIndex);\\n        }\\n    }\\n\\n    \\n\\n      class RangeFreqQuery {\\n\\n        private TreeNode rootNode;\\n        private HashSet<Integer> availableIntegers;\\n\\n        public RangeFreqQuery(int[] arr) {\\n            this.availableIntegers = new HashSet<>();\\n            this.rootNode = this.constructTree(arr);\\n        }\\n\\n        private TreeNode constructTree(int[] numbers) {\\n            List<TreeNode> treeNodes = new ArrayList<>();\\n\\n            for (int i = 0; i < numbers.length; i++) {\\n                HashMap<Integer, Integer> occurrences = new HashMap<>();\\n                occurrences.put(numbers[i], 1);\\n                treeNodes.add(new TreeNode(occurrences, i, i));\\n                this.availableIntegers.add(numbers[i]);\\n            }\\n\\n            this.groupAndReplace(treeNodes, (left, right) -> new TreeNode(\\n                    mergeOccurrences(left.occurrences, right.occurrences),\\n                    left.startIndex,\\n                    right.endIndex,\\n                    left,\\n                    right\\n            ));\\n\\n            return treeNodes.get(0);\\n        }\\n\\n        private <T> HashMap<T, Integer> mergeOccurrences(HashMap<T, Integer>... occurrences) {\\n            HashMap<T, Integer> merge = new HashMap<>();\\n\\n            for (HashMap<T, Integer> occurrence : occurrences) {\\n                occurrence.forEach((key, value) -> {\\n                    if (!merge.containsKey(key))\\n                        merge.put(key, value);\\n                    else\\n                        merge.put(key, merge.get(key) + value);\\n\\n                });\\n            }\\n\\n\\n            return merge;\\n        }\\n\\n        @FunctionalInterface\\n        private interface MyFunction<T> {\\n            T apply(T a, T b);\\n        }\\n\\n        private <T> void groupAndReplace(List<T> list, MyFunction<T> myFunction) {\\n            while (list.size() > 1) {\\n                int size = list.size();\\n                int index = 0;\\n                for (int i = 1; i < size; i += 2) {\\n\\n                    T group = myFunction.apply(list.get(i - 1), list.get(i));\\n                    list.set(index++, group);\\n                }\\n                if (size % 2 != 0) {\\n                    list.set(index++, list.get(size - 1));\\n                }\\n                list.subList(index, size).clear();\\n            }\\n        }\\n\\n        public int query(int left, int right, int value) {\\n\\n            if (!this.availableIntegers.contains(value))\\n                return 0;\\n\\n            return this.getOccurrencesOfInRange(this.rootNode, left, right, value);\\n        }\\n\\n        public int getOccurrencesOfInRange(TreeNode treeNode, int start, int end, int value) {\\n\\n            if (treeNode.startIndex == start && treeNode.endIndex == end)\\n                return treeNode.occurrences.getOrDefault(value, 0);\\n\\n            int occurrencesLeft = 0;\\n            if (treeNode.left != null && treeNode.left.startIndex <= end && treeNode.left.endIndex >= start) {\\n                occurrencesLeft += getOccurrencesOfInRange(treeNode.left, start, Math.min(end, treeNode.left.endIndex), value);\\n            }\\n\\n            int occurrencesRight = 0;\\n            if (treeNode.right != null && treeNode.right.startIndex <= end && treeNode.right.endIndex >= start) {\\n                occurrencesRight += getOccurrencesOfInRange(treeNode.right, Math.max(start, treeNode.right.startIndex), end, value);\\n            }\\n\\n            return occurrencesLeft + occurrencesRight;\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Segment Tree"
                ],
                "code": "```\\n  class TreeNode {\\n        HashMap<Integer, Integer> occurrences;\\n        int startIndex;\\n        int endIndex;\\n        TreeNode left;\\n        TreeNode right;\\n\\n        public TreeNode() {\\n        }\\n\\n        public TreeNode(HashMap<Integer, Integer> occurrences, int startIndex, int endIndex) {\\n            this.occurrences = occurrences;\\n            this.startIndex = startIndex;\\n            this.endIndex = endIndex;\\n        }\\n\\n        public TreeNode(HashMap<Integer, Integer> occurrences,\\n                        int startIndex,\\n                        int endIndex,\\n                        TreeNode left,\\n                        TreeNode right) {\\n            this.occurrences = occurrences;\\n            this.startIndex = startIndex;\\n            this.endIndex = endIndex;\\n            this.left = left;\\n            this.right = right;\\n        }\\n\\n        @Override\\n        public String toString() {\\n            return String.format(\"Range: %d-%d\", this.startIndex, this.endIndex);\\n        }\\n    }\\n\\n    \\n\\n      class RangeFreqQuery {\\n\\n        private TreeNode rootNode;\\n        private HashSet<Integer> availableIntegers;\\n\\n        public RangeFreqQuery(int[] arr) {\\n            this.availableIntegers = new HashSet<>();\\n            this.rootNode = this.constructTree(arr);\\n        }\\n\\n        private TreeNode constructTree(int[] numbers) {\\n            List<TreeNode> treeNodes = new ArrayList<>();\\n\\n            for (int i = 0; i < numbers.length; i++) {\\n                HashMap<Integer, Integer> occurrences = new HashMap<>();\\n                occurrences.put(numbers[i], 1);\\n                treeNodes.add(new TreeNode(occurrences, i, i));\\n                this.availableIntegers.add(numbers[i]);\\n            }\\n\\n            this.groupAndReplace(treeNodes, (left, right) -> new TreeNode(\\n                    mergeOccurrences(left.occurrences, right.occurrences),\\n                    left.startIndex,\\n                    right.endIndex,\\n                    left,\\n                    right\\n            ));\\n\\n            return treeNodes.get(0);\\n        }\\n\\n        private <T> HashMap<T, Integer> mergeOccurrences(HashMap<T, Integer>... occurrences) {\\n            HashMap<T, Integer> merge = new HashMap<>();\\n\\n            for (HashMap<T, Integer> occurrence : occurrences) {\\n                occurrence.forEach((key, value) -> {\\n                    if (!merge.containsKey(key))\\n                        merge.put(key, value);\\n                    else\\n                        merge.put(key, merge.get(key) + value);\\n\\n                });\\n            }\\n\\n\\n            return merge;\\n        }\\n\\n        @FunctionalInterface\\n        private interface MyFunction<T> {\\n            T apply(T a, T b);\\n        }\\n\\n        private <T> void groupAndReplace(List<T> list, MyFunction<T> myFunction) {\\n            while (list.size() > 1) {\\n                int size = list.size();\\n                int index = 0;\\n                for (int i = 1; i < size; i += 2) {\\n\\n                    T group = myFunction.apply(list.get(i - 1), list.get(i));\\n                    list.set(index++, group);\\n                }\\n                if (size % 2 != 0) {\\n                    list.set(index++, list.get(size - 1));\\n                }\\n                list.subList(index, size).clear();\\n            }\\n        }\\n\\n        public int query(int left, int right, int value) {\\n\\n            if (!this.availableIntegers.contains(value))\\n                return 0;\\n\\n            return this.getOccurrencesOfInRange(this.rootNode, left, right, value);\\n        }\\n\\n        public int getOccurrencesOfInRange(TreeNode treeNode, int start, int end, int value) {\\n\\n            if (treeNode.startIndex == start && treeNode.endIndex == end)\\n                return treeNode.occurrences.getOrDefault(value, 0);\\n\\n            int occurrencesLeft = 0;\\n            if (treeNode.left != null && treeNode.left.startIndex <= end && treeNode.left.endIndex >= start) {\\n                occurrencesLeft += getOccurrencesOfInRange(treeNode.left, start, Math.min(end, treeNode.left.endIndex), value);\\n            }\\n\\n            int occurrencesRight = 0;\\n            if (treeNode.right != null && treeNode.right.startIndex <= end && treeNode.right.endIndex >= start) {\\n                occurrencesRight += getOccurrencesOfInRange(treeNode.right, Math.max(start, treeNode.right.startIndex), end, value);\\n            }\\n\\n            return occurrencesLeft + occurrencesRight;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3613094,
                "title": "c-easy-approach-using-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsing a hash table to record the index of each element, then it\\'s easy to use binary-search to count the frequency.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#include <unordered_map>\\n#include <vector>\\n#include <algorithm>\\n\\nusing namespace std;\\n\\n\\nclass RangeFreqQuery \\n{\\npublic:\\n    RangeFreqQuery(vector<int>& arr) \\n    {\\n        int n = arr.size();\\n        for (int i=0; i<n; ++i)\\n        {\\n            _map[arr[i]].push_back(i);\\n        }\\n    }\\n    \\n    int query(int left, int right, int value) \\n    {\\n        auto low = lower_bound(_map[value].begin(), _map[value].end(), left);\\n        auto high = upper_bound(_map[value].begin(), _map[value].end(), right);\\n        // cout << distance(_map[value].begin(), low) << \" \" << distance(_map[value].begin(), high) << endl;\\n        return distance(low, high);\\n    }\\n\\nprivate:\\n    unordered_map<int, vector<int>> _map {};\\n};\\n\\n/**\\n * Your RangeFreqQuery object will be instantiated and called as such:\\n * RangeFreqQuery* obj = new RangeFreqQuery(arr);\\n * int param_1 = obj->query(left,right,value);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Binary Search"
                ],
                "code": "```\\n#include <unordered_map>\\n#include <vector>\\n#include <algorithm>\\n\\nusing namespace std;\\n\\n\\nclass RangeFreqQuery \\n{\\npublic:\\n    RangeFreqQuery(vector<int>& arr) \\n    {\\n        int n = arr.size();\\n        for (int i=0; i<n; ++i)\\n        {\\n            _map[arr[i]].push_back(i);\\n        }\\n    }\\n    \\n    int query(int left, int right, int value) \\n    {\\n        auto low = lower_bound(_map[value].begin(), _map[value].end(), left);\\n        auto high = upper_bound(_map[value].begin(), _map[value].end(), right);\\n        // cout << distance(_map[value].begin(), low) << \" \" << distance(_map[value].begin(), high) << endl;\\n        return distance(low, high);\\n    }\\n\\nprivate:\\n    unordered_map<int, vector<int>> _map {};\\n};\\n\\n/**\\n * Your RangeFreqQuery object will be instantiated and called as such:\\n * RangeFreqQuery* obj = new RangeFreqQuery(arr);\\n * int param_1 = obj->query(left,right,value);\\n */\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3552487,
                "title": "java-segment-trees-with-comments",
                "content": "# Code\\n```\\nclass RangeFreqQuery {\\n    //Segement tree is represented as a list\\n    //of map for this question unlike an array\\n    //for other segment tree question.\\n\\n    List<Map<Integer, Integer>> segmentTree;\\n    int size;\\n    int[] arr;\\n\\n    //Initialization\\n    public RangeFreqQuery(int[] arr) {\\n        this.arr = arr;\\n        this.size = arr.length;\\n        this.segmentTree = new ArrayList<>();\\n\\n        //each index in segment tree is initialized\\n        //with an emtpy map.\\n        for (int i=0; i<4*this.size; i++) {\\n            this.segmentTree.add(new HashMap<>());\\n        }\\n        \\n        //construct the segment tree.\\n        constructSegmentTree(0, this.size-1, 0);\\n    }\\n\\n    private void constructSegmentTree(int arrStart, int arrEnd, int segTreeIndex) {\\n\\n        //Each index of segment tree will\\n        //be a map consisting of no. of frequencies\\n        //of all the elements in the range [arrStart, arrEnd]\\n        //on a leaf node, we\\'re encoutering a new element, so its freq is one.\\n        if (arrStart == arrEnd) {\\n            this.segmentTree.get(segTreeIndex).put(this.arr[arrStart], 1);\\n            return;\\n        }\\n\\n        int mid = (arrStart + (arrEnd-arrStart)/2);\\n        int leftChildIndex = 2*segTreeIndex + 1;\\n        int rightChildIndex = 2*segTreeIndex + 2;\\n\\n        constructSegmentTree(arrStart, mid, leftChildIndex);\\n        constructSegmentTree(mid+1, arrEnd, rightChildIndex);\\n\\n        //merge the left and right maps into one map.\\n        //can be done more efficiently using Stream api probably.\\n        //eg: left -> [13=1, 23=3, 0=1]\\n        //right -> [1=2, 13=2, 2=1]\\n        //merged -> [13=3, 23=2, 0=1, 1=2, 2=1]\\n        this.segmentTree.set(segTreeIndex, mergeMaps(\\n            this.segmentTree.get(leftChildIndex),\\n            this.segmentTree.get(rightChildIndex)\\n        ));\\n\\n    }\\n\\n    //Merges two given maps, by adding the frequencies if same key appears in both maps.\\n    private Map<Integer, Integer> mergeMaps(Map<Integer, Integer> map1, Map<Integer, Integer> map2) {\\n        \\n        Map<Integer, Integer> map3 = new HashMap<>(map1);\\n        \\n        for (Map.Entry<Integer, Integer> entry: map2.entrySet()) {\\n            map3.put(entry.getKey(),\\n                map3.getOrDefault(entry.getKey(), 0) + entry.getValue()\\n            );\\n        }\\n\\n        return map3;\\n    }\\n    \\n    public int query(int left, int right, int value) {\\n        return queryForRange(0, this.size-1, left, right, 0, value);\\n    }\\n\\n    private int queryForRange(int arrStart, int arrEnd, int rangeStart, int rangeEnd, int segTreeIndex, int value) {\\n        \\n        //no overlap - doesn\\'t contribute so return 0\\n        if (arrEnd < rangeStart || arrStart > rangeEnd) {\\n            return 0;\\n        }\\n\\n        //full overlap - so return the frequency at segTreeIndex.\\n        if (arrStart >= rangeStart && arrEnd <= rangeEnd) {\\n            return this.segmentTree.get(segTreeIndex).getOrDefault(value, 0);\\n        }\\n\\n        //partial overlap\\n        int mid = (arrStart + (arrEnd - arrStart)/2);\\n        int leftChildIndex = 2*segTreeIndex + 1;\\n        int rightChildIndex = 2*segTreeIndex + 2;\\n\\n        int leftQuery = queryForRange(arrStart, mid, rangeStart, rangeEnd, leftChildIndex, value);\\n        int rightQuery = queryForRange(mid+1, arrEnd, rangeStart, rangeEnd, rightChildIndex, value);\\n\\n        //add frequency found in left and right.\\n        return (leftQuery + rightQuery);\\n    }\\n}\\n\\n/**\\n * Your RangeFreqQuery object will be instantiated and called as such:\\n * RangeFreqQuery obj = new RangeFreqQuery(arr);\\n * int param_1 = obj.query(left,right,value);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass RangeFreqQuery {\\n    //Segement tree is represented as a list\\n    //of map for this question unlike an array\\n    //for other segment tree question.\\n\\n    List<Map<Integer, Integer>> segmentTree;\\n    int size;\\n    int[] arr;\\n\\n    //Initialization\\n    public RangeFreqQuery(int[] arr) {\\n        this.arr = arr;\\n        this.size = arr.length;\\n        this.segmentTree = new ArrayList<>();\\n\\n        //each index in segment tree is initialized\\n        //with an emtpy map.\\n        for (int i=0; i<4*this.size; i++) {\\n            this.segmentTree.add(new HashMap<>());\\n        }\\n        \\n        //construct the segment tree.\\n        constructSegmentTree(0, this.size-1, 0);\\n    }\\n\\n    private void constructSegmentTree(int arrStart, int arrEnd, int segTreeIndex) {\\n\\n        //Each index of segment tree will\\n        //be a map consisting of no. of frequencies\\n        //of all the elements in the range [arrStart, arrEnd]\\n        //on a leaf node, we\\'re encoutering a new element, so its freq is one.\\n        if (arrStart == arrEnd) {\\n            this.segmentTree.get(segTreeIndex).put(this.arr[arrStart], 1);\\n            return;\\n        }\\n\\n        int mid = (arrStart + (arrEnd-arrStart)/2);\\n        int leftChildIndex = 2*segTreeIndex + 1;\\n        int rightChildIndex = 2*segTreeIndex + 2;\\n\\n        constructSegmentTree(arrStart, mid, leftChildIndex);\\n        constructSegmentTree(mid+1, arrEnd, rightChildIndex);\\n\\n        //merge the left and right maps into one map.\\n        //can be done more efficiently using Stream api probably.\\n        //eg: left -> [13=1, 23=3, 0=1]\\n        //right -> [1=2, 13=2, 2=1]\\n        //merged -> [13=3, 23=2, 0=1, 1=2, 2=1]\\n        this.segmentTree.set(segTreeIndex, mergeMaps(\\n            this.segmentTree.get(leftChildIndex),\\n            this.segmentTree.get(rightChildIndex)\\n        ));\\n\\n    }\\n\\n    //Merges two given maps, by adding the frequencies if same key appears in both maps.\\n    private Map<Integer, Integer> mergeMaps(Map<Integer, Integer> map1, Map<Integer, Integer> map2) {\\n        \\n        Map<Integer, Integer> map3 = new HashMap<>(map1);\\n        \\n        for (Map.Entry<Integer, Integer> entry: map2.entrySet()) {\\n            map3.put(entry.getKey(),\\n                map3.getOrDefault(entry.getKey(), 0) + entry.getValue()\\n            );\\n        }\\n\\n        return map3;\\n    }\\n    \\n    public int query(int left, int right, int value) {\\n        return queryForRange(0, this.size-1, left, right, 0, value);\\n    }\\n\\n    private int queryForRange(int arrStart, int arrEnd, int rangeStart, int rangeEnd, int segTreeIndex, int value) {\\n        \\n        //no overlap - doesn\\'t contribute so return 0\\n        if (arrEnd < rangeStart || arrStart > rangeEnd) {\\n            return 0;\\n        }\\n\\n        //full overlap - so return the frequency at segTreeIndex.\\n        if (arrStart >= rangeStart && arrEnd <= rangeEnd) {\\n            return this.segmentTree.get(segTreeIndex).getOrDefault(value, 0);\\n        }\\n\\n        //partial overlap\\n        int mid = (arrStart + (arrEnd - arrStart)/2);\\n        int leftChildIndex = 2*segTreeIndex + 1;\\n        int rightChildIndex = 2*segTreeIndex + 2;\\n\\n        int leftQuery = queryForRange(arrStart, mid, rangeStart, rangeEnd, leftChildIndex, value);\\n        int rightQuery = queryForRange(mid+1, arrEnd, rangeStart, rangeEnd, rightChildIndex, value);\\n\\n        //add frequency found in left and right.\\n        return (leftQuery + rightQuery);\\n    }\\n}\\n\\n/**\\n * Your RangeFreqQuery object will be instantiated and called as such:\\n * RangeFreqQuery obj = new RangeFreqQuery(arr);\\n * int param_1 = obj.query(left,right,value);\\n */\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3525002,
                "title": "java-array-and-binary-search",
                "content": "\\n# Approach\\n1. Use a List[10_001] to add each number\\'s positions. List[5] will contain an ArrayList<> with all positions of number 5\\n2. For each query, get the list positions of value/target. \\n    - If it\\'s null, return 0.\\n    - Else perform binary search on left, right and return their difference.\\n\\n# Complexity\\n- Time complexity:$$O(n + q)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass RangeFreqQuery {\\n    List[] positions;\\n    public RangeFreqQuery(int[] arr) {\\n        positions = new List[10_001];\\n        for (int i = 0; i < arr.length; i++) {\\n            if(positions[arr[i]] == null) {\\n                positions[arr[i]] = new ArrayList<Integer>();\\n            }\\n            positions[arr[i]].add(i);\\n        }\\n    }\\n    \\n    public int query(int left, int right, int value) {\\n        List<Integer> pos = positions[value];\\n        if (pos == null || pos.get(0) > right || pos.get(pos.size() -1) < left) {\\n            return 0;\\n        }\\n        int leftIndex = binarySearch(pos, left);\\n        int rightIndex = binarySearch(pos, right);\\n        if (rightIndex < pos.size() && pos.get(rightIndex) == right) {\\n            rightIndex++;\\n        }\\n        return Math.max(0, (rightIndex - leftIndex)); \\n    }\\n\\n    private int binarySearch(List<Integer> arr, int target) {\\n        int low = 0, high = arr.size() - 1, pivot;\\n        while (low <= high) {\\n            pivot = low + (high - low) / 2;\\n            if (arr.get(pivot) == target) {\\n                return pivot;\\n            } else if (arr.get(pivot) < target) {\\n                low = pivot + 1;\\n            } else {\\n                high = pivot - 1;\\n            }\\n        }\\n        return low;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass RangeFreqQuery {\\n    List[] positions;\\n    public RangeFreqQuery(int[] arr) {\\n        positions = new List[10_001];\\n        for (int i = 0; i < arr.length; i++) {\\n            if(positions[arr[i]] == null) {\\n                positions[arr[i]] = new ArrayList<Integer>();\\n            }\\n            positions[arr[i]].add(i);\\n        }\\n    }\\n    \\n    public int query(int left, int right, int value) {\\n        List<Integer> pos = positions[value];\\n        if (pos == null || pos.get(0) > right || pos.get(pos.size() -1) < left) {\\n            return 0;\\n        }\\n        int leftIndex = binarySearch(pos, left);\\n        int rightIndex = binarySearch(pos, right);\\n        if (rightIndex < pos.size() && pos.get(rightIndex) == right) {\\n            rightIndex++;\\n        }\\n        return Math.max(0, (rightIndex - leftIndex)); \\n    }\\n\\n    private int binarySearch(List<Integer> arr, int target) {\\n        int low = 0, high = arr.size() - 1, pivot;\\n        while (low <= high) {\\n            pivot = low + (high - low) / 2;\\n            if (arr.get(pivot) == target) {\\n                return pivot;\\n            } else if (arr.get(pivot) < target) {\\n                low = pivot + 1;\\n            } else {\\n                high = pivot - 1;\\n            }\\n        }\\n        return low;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3508435,
                "title": "my-simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass RangeFreqQuery {\\n\\n    Map<Integer, List<Integer>> map;\\n\\n    public RangeFreqQuery(int[] arr) {\\n        map =  new HashMap();\\n        for(int i = 0; i < arr.length; i++) {\\n            int num = arr[i];\\n            List<Integer> temp = map.getOrDefault(num, new ArrayList<Integer>());\\n            temp.add(i);\\n            map.put(num, temp);\\n        }\\n    }\\n    \\n    public int query(int left, int right, int value) {\\n        return upperBound(map.getOrDefault(value, new ArrayList<Integer>()), right) - lowerBound(map.getOrDefault(value, new ArrayList<Integer>()), left);\\n    }\\n\\n    private int lowerBound(List<Integer> a, int x) {\\n        int l=-1, r=a.size();\\n        while(l+1<r) {\\n            int m=(l+r)>>>1;\\n            if(a.get(m)>=x) r=m;\\n            else l=m;\\n        }\\n        return r;\\n    }\\n\\n    private int upperBound(List<Integer> a, int x) {// x is the key or target value\\n        int l=-1,r=a.size();\\n        while(l+1<r) {\\n            int m=(l+r)>>>1;\\n            if(a.get(m)<=x) l=m;\\n            else r=m;\\n        }\\n        return l+1;\\n    }\\n}\\n\\n/**\\n * Your RangeFreqQuery object will be instantiated and called as such:\\n * RangeFreqQuery obj = new RangeFreqQuery(arr);\\n * int param_1 = obj.query(left,right,value);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass RangeFreqQuery {\\n\\n    Map<Integer, List<Integer>> map;\\n\\n    public RangeFreqQuery(int[] arr) {\\n        map =  new HashMap();\\n        for(int i = 0; i < arr.length; i++) {\\n            int num = arr[i];\\n            List<Integer> temp = map.getOrDefault(num, new ArrayList<Integer>());\\n            temp.add(i);\\n            map.put(num, temp);\\n        }\\n    }\\n    \\n    public int query(int left, int right, int value) {\\n        return upperBound(map.getOrDefault(value, new ArrayList<Integer>()), right) - lowerBound(map.getOrDefault(value, new ArrayList<Integer>()), left);\\n    }\\n\\n    private int lowerBound(List<Integer> a, int x) {\\n        int l=-1, r=a.size();\\n        while(l+1<r) {\\n            int m=(l+r)>>>1;\\n            if(a.get(m)>=x) r=m;\\n            else l=m;\\n        }\\n        return r;\\n    }\\n\\n    private int upperBound(List<Integer> a, int x) {// x is the key or target value\\n        int l=-1,r=a.size();\\n        while(l+1<r) {\\n            int m=(l+r)>>>1;\\n            if(a.get(m)<=x) l=m;\\n            else r=m;\\n        }\\n        return l+1;\\n    }\\n}\\n\\n/**\\n * Your RangeFreqQuery object will be instantiated and called as such:\\n * RangeFreqQuery obj = new RangeFreqQuery(arr);\\n * int param_1 = obj.query(left,right,value);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3488894,
                "title": "python3-binary-search",
                "content": "\\n\\n# Code\\n```\\nclass RangeFreqQuery:\\n\\n    def __init__(self, arr: List[int]):\\n        \\n        self.d=defaultdict(list)\\n\\n        for i,val in enumerate(arr):\\n            self.d[val].append(i)\\n\\n        \\n    def query(self, left: int, right: int, value: int) -> int:\\n\\n        lst=self.d[value]\\n\\n        l=bisect_left(lst,left)\\n        r=bisect_right(lst,right)\\n\\n        return r-l\\n\\n\\n\\n            \\n\\n\\n\\n\\n            \\n\\n\\n        \\n\\n\\n# Your RangeFreqQuery object will be instantiated and called as such:\\n# obj = RangeFreqQuery(arr)\\n# param_1 = obj.query(left,right,value)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass RangeFreqQuery:\\n\\n    def __init__(self, arr: List[int]):\\n        \\n        self.d=defaultdict(list)\\n\\n        for i,val in enumerate(arr):\\n            self.d[val].append(i)\\n\\n        \\n    def query(self, left: int, right: int, value: int) -> int:\\n\\n        lst=self.d[value]\\n\\n        l=bisect_left(lst,left)\\n        r=bisect_right(lst,right)\\n\\n        return r-l\\n\\n\\n\\n            \\n\\n\\n\\n\\n            \\n\\n\\n        \\n\\n\\n# Your RangeFreqQuery object will be instantiated and called as such:\\n# obj = RangeFreqQuery(arr)\\n# param_1 = obj.query(left,right,value)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3439074,
                "title": "segment-tree-solution-c",
                "content": "# Intuition\\nHere we will use map inside the segment array storing the frequencies of elements. Just little modification to the standard segment tree solution.\\n\\n# Code\\n```\\nclass RangeFreqQuery {\\nprivate: \\n    vector<map<int,int>> seg;\\n    int n;\\npublic:\\n\\n    void build(vector<int> &arr, int idx, int s, int e) {\\n\\n        if(s==e) {\\n            // incrementing the count of element\\n            seg[idx][arr[s]]++;\\n        }\\n        else{\\n            int mid = (s+e) >> 1;\\n            build(arr, idx*2+1, s, mid);\\n            build(arr, idx*2+2, mid+1, e);\\n\\n            // adding the frequencies from childs\\n            for(auto it: seg[idx*2+1]){\\n                seg[idx][it.first] += it.second;\\n            }\\n            for(auto it: seg[idx*2+2]){\\n                seg[idx][it.first] += it.second;\\n            }\\n        }\\n\\n    }\\n    int find(int idx, int s, int e, int a, int b, int value) {\\n\\n        if(a <= s && e <= b) return seg[idx][value];\\n        else if(e < a || s > b) return 0;\\n        else {\\n            int mid = (s+e) >> 1;\\n\\n            return find(idx*2+1, s, mid, a, b, value) + find(idx*2+2, mid+1, e, a, b, value);\\n        }\\n\\n    }\\n    RangeFreqQuery(vector<int>& arr) {\\n        n = arr.size();\\n        seg.clear();\\n        seg.resize(4 * n);\\n\\n        build(arr, 0, 0, n-1);\\n    }\\n    \\n    int query(int left, int right, int value) {\\n        return find(0, 0, n-1, left, right, value);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Segment Tree"
                ],
                "code": "```\\nclass RangeFreqQuery {\\nprivate: \\n    vector<map<int,int>> seg;\\n    int n;\\npublic:\\n\\n    void build(vector<int> &arr, int idx, int s, int e) {\\n\\n        if(s==e) {\\n            // incrementing the count of element\\n            seg[idx][arr[s]]++;\\n        }\\n        else{\\n            int mid = (s+e) >> 1;\\n            build(arr, idx*2+1, s, mid);\\n            build(arr, idx*2+2, mid+1, e);\\n\\n            // adding the frequencies from childs\\n            for(auto it: seg[idx*2+1]){\\n                seg[idx][it.first] += it.second;\\n            }\\n            for(auto it: seg[idx*2+2]){\\n                seg[idx][it.first] += it.second;\\n            }\\n        }\\n\\n    }\\n    int find(int idx, int s, int e, int a, int b, int value) {\\n\\n        if(a <= s && e <= b) return seg[idx][value];\\n        else if(e < a || s > b) return 0;\\n        else {\\n            int mid = (s+e) >> 1;\\n\\n            return find(idx*2+1, s, mid, a, b, value) + find(idx*2+2, mid+1, e, a, b, value);\\n        }\\n\\n    }\\n    RangeFreqQuery(vector<int>& arr) {\\n        n = arr.size();\\n        seg.clear();\\n        seg.resize(4 * n);\\n\\n        build(arr, 0, 0, n-1);\\n    }\\n    \\n    int query(int left, int right, int value) {\\n        return find(0, 0, n-1, left, right, value);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3434178,
                "title": "c-binary-search-array-of-indexes",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass RangeFreqQuery {\\npublic:\\n\\n    unordered_map<int,vector<int>> mp;\\n    RangeFreqQuery(vector<int>& arr) {\\n        int n = arr.size();\\n        for(int i=0;i<n;i++){\\n            mp[arr[i]].push_back(i);\\n        }\\n    }\\n\\n    // 3 5 9 13 14 16\\n    int bs1(vector<int>& ss, int ele){\\n        int n = ss.size();\\n        int lo = 0;\\n        int hi = n-1;\\n        int ans = hi;\\n        while(lo<=hi){\\n            int mid = lo+(hi-lo)/2;\\n            if(ss[mid] >= ele){\\n                hi = mid-1;\\n                ans = mid;\\n            }\\n            else{//ss[mid] < ele\\n                lo = mid+1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n\\n\\n     // 3 5 9 13 14 16\\n     //TTTTTTTTFFFFFFFF\\n    int bs2(vector<int>& ss, int ele){\\n        int n = ss.size();\\n        int lo = 0;\\n        int hi = n-1;\\n        int ans = lo;\\n        while(lo<=hi){\\n            int mid = lo+(hi-lo)/2;\\n            if(ss[mid] <= ele){\\n                lo = mid+1;\\n                ans = mid;\\n            }\\n            else{//ss[mid] > ele\\n                hi = mid-1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n    \\n    int query(int left, int right, int value) {\\n        // vector<int> ss = mp[value];\\n        if(mp.find(value) == mp.end()){\\n            return 0;\\n        }\\n        int fi = bs1(mp[value], left);\\n\\n        int li = bs2(mp[value],  right);\\n        \\n        // if I dont find left at first Idx and right < mp[value][0]\\n\\n        if(left < mp[value][0] and right < mp[value][0]){\\n            return 0;\\n        }\\n        int size = mp[value].size();\\n        if(left > mp[value][size-1] and right > mp[value][size-1]){\\n            return 0;\\n        }\\n        \\n        return (li-fi+1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass RangeFreqQuery {\\npublic:\\n\\n    unordered_map<int,vector<int>> mp;\\n    RangeFreqQuery(vector<int>& arr) {\\n        int n = arr.size();\\n        for(int i=0;i<n;i++){\\n            mp[arr[i]].push_back(i);\\n        }\\n    }\\n\\n    // 3 5 9 13 14 16\\n    int bs1(vector<int>& ss, int ele){\\n        int n = ss.size();\\n        int lo = 0;\\n        int hi = n-1;\\n        int ans = hi;\\n        while(lo<=hi){\\n            int mid = lo+(hi-lo)/2;\\n            if(ss[mid] >= ele){\\n                hi = mid-1;\\n                ans = mid;\\n            }\\n            else{//ss[mid] < ele\\n                lo = mid+1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n\\n\\n     // 3 5 9 13 14 16\\n     //TTTTTTTTFFFFFFFF\\n    int bs2(vector<int>& ss, int ele){\\n        int n = ss.size();\\n        int lo = 0;\\n        int hi = n-1;\\n        int ans = lo;\\n        while(lo<=hi){\\n            int mid = lo+(hi-lo)/2;\\n            if(ss[mid] <= ele){\\n                lo = mid+1;\\n                ans = mid;\\n            }\\n            else{//ss[mid] > ele\\n                hi = mid-1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n    \\n    int query(int left, int right, int value) {\\n        // vector<int> ss = mp[value];\\n        if(mp.find(value) == mp.end()){\\n            return 0;\\n        }\\n        int fi = bs1(mp[value], left);\\n\\n        int li = bs2(mp[value],  right);\\n        \\n        // if I dont find left at first Idx and right < mp[value][0]\\n\\n        if(left < mp[value][0] and right < mp[value][0]){\\n            return 0;\\n        }\\n        int size = mp[value].size();\\n        if(left > mp[value][size-1] and right > mp[value][size-1]){\\n            return 0;\\n        }\\n        \\n        return (li-fi+1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3415040,
                "title": "java-hashmap-binary-search",
                "content": "# Code\\n```\\nclass RangeFreqQuery {\\n    HashMap<Integer, List<Integer>> map = new HashMap<>();\\n    public RangeFreqQuery(int[] arr) {\\n        for (int i = 0; i < arr.length; i++) {\\n            int v = arr[i];\\n            if ( ! map.containsKey(v)) {\\n                map.put(v, new ArrayList<>());\\n            }\\n            map.get(v).add(i);\\n        }\\n    }\\n    \\n    public int query(int left, int right, int value) {\\n        return search(value, right)-search(value, left-1);\\n    }\\n\\n    private int search(int v, int indx) {\\n        if (indx == -1 || ! map.containsKey(v)) {\\n            return 0;\\n        }\\n        List<Integer> list = map.get(v);\\n        int l = 0;\\n        int r = list.size()-1;\\n\\n        while (l <= r) {\\n            int mid = (l+r) / 2;\\n            if (list.get(mid) == indx) {\\n                return mid+1;\\n            }\\n            if (list.get(mid) < indx) {\\n                l = mid+1;\\n            } else {\\n                r = mid-1;\\n            }\\n        }\\n        return l;\\n    }\\n}\\n\\n/**\\n * Your RangeFreqQuery object will be instantiated and called as such:\\n * RangeFreqQuery obj = new RangeFreqQuery(arr);\\n * int param_1 = obj.query(left,right,value);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass RangeFreqQuery {\\n    HashMap<Integer, List<Integer>> map = new HashMap<>();\\n    public RangeFreqQuery(int[] arr) {\\n        for (int i = 0; i < arr.length; i++) {\\n            int v = arr[i];\\n            if ( ! map.containsKey(v)) {\\n                map.put(v, new ArrayList<>());\\n            }\\n            map.get(v).add(i);\\n        }\\n    }\\n    \\n    public int query(int left, int right, int value) {\\n        return search(value, right)-search(value, left-1);\\n    }\\n\\n    private int search(int v, int indx) {\\n        if (indx == -1 || ! map.containsKey(v)) {\\n            return 0;\\n        }\\n        List<Integer> list = map.get(v);\\n        int l = 0;\\n        int r = list.size()-1;\\n\\n        while (l <= r) {\\n            int mid = (l+r) / 2;\\n            if (list.get(mid) == indx) {\\n                return mid+1;\\n            }\\n            if (list.get(mid) < indx) {\\n                l = mid+1;\\n            } else {\\n                r = mid-1;\\n            }\\n        }\\n        return l;\\n    }\\n}\\n\\n/**\\n * Your RangeFreqQuery object will be instantiated and called as such:\\n * RangeFreqQuery obj = new RangeFreqQuery(arr);\\n * int param_1 = obj.query(left,right,value);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3413939,
                "title": "c-hash-table-binary-search",
                "content": "# Code\\n```\\nclass RangeFreqQuery {\\n    unordered_map<int, vector<int>> Map;\\npublic:\\n    RangeFreqQuery(vector<int>& arr) {\\n        for(int i = 0; i < arr.size(); i++) {\\n            Map[arr[i]].push_back(i);\\n        }\\n    }\\n    \\n    int query(int left, int right, int value) {\\n        return upper_bound(Map[value].begin(), Map[value].end(), right) - lower_bound(Map[value].begin(), Map[value].end(), left); \\n    }\\n};\\n\\n/**\\n * Your RangeFreqQuery object will be instantiated and called as such:\\n * RangeFreqQuery* obj = new RangeFreqQuery(arr);\\n * int param_1 = obj->query(left,right,value);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Binary Search",
                    "Design"
                ],
                "code": "```\\nclass RangeFreqQuery {\\n    unordered_map<int, vector<int>> Map;\\npublic:\\n    RangeFreqQuery(vector<int>& arr) {\\n        for(int i = 0; i < arr.size(); i++) {\\n            Map[arr[i]].push_back(i);\\n        }\\n    }\\n    \\n    int query(int left, int right, int value) {\\n        return upper_bound(Map[value].begin(), Map[value].end(), right) - lower_bound(Map[value].begin(), Map[value].end(), left); \\n    }\\n};\\n\\n/**\\n * Your RangeFreqQuery object will be instantiated and called as such:\\n * RangeFreqQuery* obj = new RangeFreqQuery(arr);\\n * int param_1 = obj->query(left,right,value);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3400019,
                "title": "c-segment-tree-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBuild a segment tree and store frequency count of each element at node.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBuild a segment tree and store frequency count of each element at node.\\n\\n# Complexity\\n- Time complexity:\\n    Building SegTree : O(n)\\n    Query: O(logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: \\n    O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Node {\\npublic:\\n unordered_map<int, int> freqCount;\\n};\\nclass SegmentTree {\\n    vector<Node*> segTree;\\n    vector<int>& arr;\\n    public:\\n    SegmentTree(int size, vector<int>& arr) : segTree(size), arr(arr) {\\n        for (int index = 0; index < size; index++) {\\n            segTree[index] = new Node();\\n        }\\n    }\\n    void buildSegmentTree(int index, int low, int high) {\\n        if(low == high) {\\n            segTree[index]->freqCount[arr[low]]++;\\n            return;\\n        }\\n        int mid = (low + high) >> 1;\\n        buildSegmentTree(2*index+1, low, mid);\\n        buildSegmentTree(2*index+2, mid+1, high);\\n\\n        //merge\\n        for(auto pair : segTree[2*index+1]->freqCount) {\\n            segTree[index]->freqCount[pair.first] += pair.second;;\\n        }\\n        for(auto pair : segTree[2*index+2]->freqCount) {\\n            segTree[index]->freqCount[pair.first] += pair.second;;\\n        }\\n    }\\n    \\n    int query(int index, int low, int high, int left, int right, int value) {\\n        //[low, high][left,right] || [left,right][low, high]\\n        if(high < left || right < low) {\\n            return 0;\\n        }\\n        if(low >= left && high <= right) {\\n            return segTree[index]->freqCount[value];\\n        }\\n        int mid = (low + high) >> 1;\\n        int leftCount = query(2*index + 1, low, mid, left, right, value);\\n        int rightCount = query(2*index + 2, mid+1, high, left, right, value);\\n        return leftCount + rightCount;\\n    }\\n\\n};\\nclass RangeFreqQuery {\\n    SegmentTree* tree;\\n    int n;\\nprivate:\\npublic:\\n    RangeFreqQuery(vector<int>& arr) {\\n        n = arr.size(); \\n        tree = new SegmentTree(4*n, arr);\\n        tree->buildSegmentTree(0, 0, n-1);\\n    }\\n\\n    int query(int left, int right, int value) {\\n        return tree->query(0, 0, n-1, left, right, value);\\n    }\\n};\\n\\n/**\\n * Your RangeFreqQuery object will be instantiated and called as such:\\n * RangeFreqQuery* obj = new RangeFreqQuery(arr);\\n * int param_1 = obj->query(left,right,value);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Node {\\npublic:\\n unordered_map<int, int> freqCount;\\n};\\nclass SegmentTree {\\n    vector<Node*> segTree;\\n    vector<int>& arr;\\n    public:\\n    SegmentTree(int size, vector<int>& arr) : segTree(size), arr(arr) {\\n        for (int index = 0; index < size; index++) {\\n            segTree[index] = new Node();\\n        }\\n    }\\n    void buildSegmentTree(int index, int low, int high) {\\n        if(low == high) {\\n            segTree[index]->freqCount[arr[low]]++;\\n            return;\\n        }\\n        int mid = (low + high) >> 1;\\n        buildSegmentTree(2*index+1, low, mid);\\n        buildSegmentTree(2*index+2, mid+1, high);\\n\\n        //merge\\n        for(auto pair : segTree[2*index+1]->freqCount) {\\n            segTree[index]->freqCount[pair.first] += pair.second;;\\n        }\\n        for(auto pair : segTree[2*index+2]->freqCount) {\\n            segTree[index]->freqCount[pair.first] += pair.second;;\\n        }\\n    }\\n    \\n    int query(int index, int low, int high, int left, int right, int value) {\\n        //[low, high][left,right] || [left,right][low, high]\\n        if(high < left || right < low) {\\n            return 0;\\n        }\\n        if(low >= left && high <= right) {\\n            return segTree[index]->freqCount[value];\\n        }\\n        int mid = (low + high) >> 1;\\n        int leftCount = query(2*index + 1, low, mid, left, right, value);\\n        int rightCount = query(2*index + 2, mid+1, high, left, right, value);\\n        return leftCount + rightCount;\\n    }\\n\\n};\\nclass RangeFreqQuery {\\n    SegmentTree* tree;\\n    int n;\\nprivate:\\npublic:\\n    RangeFreqQuery(vector<int>& arr) {\\n        n = arr.size(); \\n        tree = new SegmentTree(4*n, arr);\\n        tree->buildSegmentTree(0, 0, n-1);\\n    }\\n\\n    int query(int left, int right, int value) {\\n        return tree->query(0, 0, n-1, left, right, value);\\n    }\\n};\\n\\n/**\\n * Your RangeFreqQuery object will be instantiated and called as such:\\n * RangeFreqQuery* obj = new RangeFreqQuery(arr);\\n * int param_1 = obj->query(left,right,value);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3358782,
                "title": "c-using-unordered-map-binarysearch",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:  \\n-                   RangeFreqQuery :  O(n)\\n-                   query          :  O(log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass RangeFreqQuery {\\npublic:\\n\\n    unordered_map<int, vector<int>> Map; // a[i] -> indices \\n\\n    RangeFreqQuery(vector<int>& a) {\\n        for(int i = 0; i < a.size(); i++)\\n            Map[a[i]].push_back(i);\\n    }\\n    \\n    int smallerThan(vector<int> &a, int x)\\n    {\\n        int idx = -1;\\n        int beg = 0, end = a.size() - 1;\\n        while(beg <= end)\\n        {\\n            int mid = (beg + end) / 2;\\n            if(a[mid] < x)\\n            {\\n                idx = mid;\\n                beg = mid + 1;\\n            }\\n            else end = mid - 1;\\n        }\\n\\n        return idx + 1;\\n    }\\n\\n    int greaterThan(vector<int> &a, int x)\\n    {\\n        int idx = a.size();\\n        int beg = 0, end = a.size() - 1;\\n        while(beg <= end)\\n        {\\n            int mid = (beg + end) / 2;\\n            if(a[mid] > x)\\n            {\\n                idx = mid;\\n                end = mid - 1;\\n            }\\n            else beg = mid + 1;\\n        }\\n\\n        return a.size() - idx;\\n    }\\n\\n    int query(int l, int r, int value) {\\n        return Map[value].size() - (smallerThan(Map[value], l) + greaterThan(Map[value], r));\\n    }\\n};\\n\\n/**\\n * Your RangeFreqQuery object will be instantiated and called as such:\\n * RangeFreqQuery* obj = new RangeFreqQuery(arr);\\n * int param_1 = obj->query(left,right,value);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass RangeFreqQuery {\\npublic:\\n\\n    unordered_map<int, vector<int>> Map; // a[i] -> indices \\n\\n    RangeFreqQuery(vector<int>& a) {\\n        for(int i = 0; i < a.size(); i++)\\n            Map[a[i]].push_back(i);\\n    }\\n    \\n    int smallerThan(vector<int> &a, int x)\\n    {\\n        int idx = -1;\\n        int beg = 0, end = a.size() - 1;\\n        while(beg <= end)\\n        {\\n            int mid = (beg + end) / 2;\\n            if(a[mid] < x)\\n            {\\n                idx = mid;\\n                beg = mid + 1;\\n            }\\n            else end = mid - 1;\\n        }\\n\\n        return idx + 1;\\n    }\\n\\n    int greaterThan(vector<int> &a, int x)\\n    {\\n        int idx = a.size();\\n        int beg = 0, end = a.size() - 1;\\n        while(beg <= end)\\n        {\\n            int mid = (beg + end) / 2;\\n            if(a[mid] > x)\\n            {\\n                idx = mid;\\n                end = mid - 1;\\n            }\\n            else beg = mid + 1;\\n        }\\n\\n        return a.size() - idx;\\n    }\\n\\n    int query(int l, int r, int value) {\\n        return Map[value].size() - (smallerThan(Map[value], l) + greaterThan(Map[value], r));\\n    }\\n};\\n\\n/**\\n * Your RangeFreqQuery object will be instantiated and called as such:\\n * RangeFreqQuery* obj = new RangeFreqQuery(arr);\\n * int param_1 = obj->query(left,right,value);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3327652,
                "title": "segment-tree-iterative-version-just-for-fun",
                "content": "Use segment tree iterative version. Just for. fun.\\n\\n# Code\\n```\\nclass RangeFreqQuery {\\n\\nstruct SegmentTree{\\n    \\n    //<number,#>\\n    vector<unordered_map<int,int>> tree;\\n    int n;\\n    \\n    SegmentTree(vector<int> &arr){\\n        n = arr.size();\\n        tree.resize(n * 2);\\n        buildTree(arr);\\n    }\\n\\n    void buildTree(vector<int> &arr){\\n        \\n        for(int i=n,j=0;i<tree.size();i++,j++)\\n            tree[i][arr[j]] = 1;\\n\\n        for(int i=n-1;i>0;i--){\\n            for(const auto &[number,count]:tree[2*i])\\n                tree[i][number]+=count;\\n            for(const auto &[number,count]:tree[2*i+1])\\n                tree[i][number]+=count;\\n        }\\n    }\\n\\n    int query(int left,int right,int value){\\n\\n        int ans{};\\n    \\n        left += n; right += n;\\n        \\n        //[left,right]        \\n        while(left<=right){\\n\\n            if(left % 2 == 1){\\n                if(tree[left].count(value)){\\n                    ans+=tree[left][value];\\n                }\\n                left++;\\n            }\\n\\n            if(right %2 == 0){\\n                if(tree[right].count(value)){\\n                    ans+=tree[right][value];\\n                }\\n                right--;\\n            }\\n\\n            left>>=1;\\n            right>>=1;\\n        }\\n        return ans;\\n    }\\n};\\n\\n    SegmentTree t;\\n\\npublic:\\n    RangeFreqQuery(vector<int>& arr):t{arr}{\\n    }\\n    \\n    int query(int left, int right, int value) {\\n        return t.query(left,right,value);\\n    }\\n};\\n\\n/**\\n * Your RangeFreqQuery object will be instantiated and called as such:\\n * RangeFreqQuery* obj = new RangeFreqQuery(arr);\\n * int param_1 = obj->query(left,right,value);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass RangeFreqQuery {\\n\\nstruct SegmentTree{\\n    \\n    //<number,#>\\n    vector<unordered_map<int,int>> tree;\\n    int n;\\n    \\n    SegmentTree(vector<int> &arr){\\n        n = arr.size();\\n        tree.resize(n * 2);\\n        buildTree(arr);\\n    }\\n\\n    void buildTree(vector<int> &arr){\\n        \\n        for(int i=n,j=0;i<tree.size();i++,j++)\\n            tree[i][arr[j]] = 1;\\n\\n        for(int i=n-1;i>0;i--){\\n            for(const auto &[number,count]:tree[2*i])\\n                tree[i][number]+=count;\\n            for(const auto &[number,count]:tree[2*i+1])\\n                tree[i][number]+=count;\\n        }\\n    }\\n\\n    int query(int left,int right,int value){\\n\\n        int ans{};\\n    \\n        left += n; right += n;\\n        \\n        //[left,right]        \\n        while(left<=right){\\n\\n            if(left % 2 == 1){\\n                if(tree[left].count(value)){\\n                    ans+=tree[left][value];\\n                }\\n                left++;\\n            }\\n\\n            if(right %2 == 0){\\n                if(tree[right].count(value)){\\n                    ans+=tree[right][value];\\n                }\\n                right--;\\n            }\\n\\n            left>>=1;\\n            right>>=1;\\n        }\\n        return ans;\\n    }\\n};\\n\\n    SegmentTree t;\\n\\npublic:\\n    RangeFreqQuery(vector<int>& arr):t{arr}{\\n    }\\n    \\n    int query(int left, int right, int value) {\\n        return t.query(left,right,value);\\n    }\\n};\\n\\n/**\\n * Your RangeFreqQuery object will be instantiated and called as such:\\n * RangeFreqQuery* obj = new RangeFreqQuery(arr);\\n * int param_1 = obj->query(left,right,value);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3316392,
                "title": "python-binary-search-solution-with-explanation",
                "content": "```python\\n\\'\\'\\'\\nWe can use a hash map (int -> list) to keep track of where values occur, the index array is in the incremental order\\nwhen we check if the value appear in the [left, right], use binary search to find the left bound of left, and right bound of right\\ne.g. left = 9, right = 12, index array = [2, 3, 6, 8, 10, 11, 15, 17]\\nleft bound is at 10(index 4), right bound is at 11(index 5), so frequency is 5 - 4 + 1 = 2\\nsc is O(n)\\ntc of __init__ is O(n)\\ntc of query is O(logn)\\n\\'\\'\\'\\nfrom collections import defaultdict\\nclass RangeFreqQuery:\\n    def __init__(self, arr: List[int]):\\n        self.vauleToIndexes = defaultdict(list)\\n        for idx, n in enumerate(arr):\\n            self.vauleToIndexes[n].append(idx)\\n\\n    def query(self, left: int, right: int, value: int) -> int:\\n        index = self.vauleToIndexes[value]\\n        lb, rb = self.findLeftBound(index, left), self.findRightBound(index, right)\\n        return rb - lb + 1\\n\\n    def findLeftBound(self, arr, target):\\n        l, r = 0, len(arr)\\n        while l < r:\\n            m = (l + r) // 2\\n            if arr[m] >= target:\\n                r = m\\n            else: l = m + 1\\n        return l\\n\\n    def findRightBound(self, arr, target):\\n        l, r = 0, len(arr)\\n        while l < r:\\n            m = (l + r) // 2\\n            if arr[m] <= target:\\n                l = m + 1\\n            else: r = m\\n        return l - 1\\n```",
                "solutionTags": [
                    "Python",
                    "Hash Table",
                    "Binary Search"
                ],
                "code": "```python\\n\\'\\'\\'\\nWe can use a hash map (int -> list) to keep track of where values occur, the index array is in the incremental order\\nwhen we check if the value appear in the [left, right], use binary search to find the left bound of left, and right bound of right\\ne.g. left = 9, right = 12, index array = [2, 3, 6, 8, 10, 11, 15, 17]\\nleft bound is at 10(index 4), right bound is at 11(index 5), so frequency is 5 - 4 + 1 = 2\\nsc is O(n)\\ntc of __init__ is O(n)\\ntc of query is O(logn)\\n\\'\\'\\'\\nfrom collections import defaultdict\\nclass RangeFreqQuery:\\n    def __init__(self, arr: List[int]):\\n        self.vauleToIndexes = defaultdict(list)\\n        for idx, n in enumerate(arr):\\n            self.vauleToIndexes[n].append(idx)\\n\\n    def query(self, left: int, right: int, value: int) -> int:\\n        index = self.vauleToIndexes[value]\\n        lb, rb = self.findLeftBound(index, left), self.findRightBound(index, right)\\n        return rb - lb + 1\\n\\n    def findLeftBound(self, arr, target):\\n        l, r = 0, len(arr)\\n        while l < r:\\n            m = (l + r) // 2\\n            if arr[m] >= target:\\n                r = m\\n            else: l = m + 1\\n        return l\\n\\n    def findRightBound(self, arr, target):\\n        l, r = 0, len(arr)\\n        while l < r:\\n            m = (l + r) // 2\\n            if arr[m] <= target:\\n                l = m + 1\\n            else: r = m\\n        return l - 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3283694,
                "title": "binary-search-java",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n1. Take a map to store indices of each value of array.\\n2. Since we are iterating array, indices will be stored in ascending order.\\n3. For a query, we can do binary search to find the number of indices between L and R.\\n\\n\\n# Code\\n```\\nclass RangeFreqQuery {\\n    Map<Integer, List<Integer>> map;\\n    public RangeFreqQuery(int[] arr) {\\n        map = new HashMap<>();\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            if(!map.containsKey(arr[i])) map.put(arr[i], new ArrayList<>());\\n            map.get(arr[i]).add(i);\\n\\n        }\\n\\n        \\n    }\\n    \\n    public int query(int left, int right, int value) {\\n     if(!map.containsKey(value))  return 0;\\n     List<Integer> list = map.get(value);\\n     int s= Collections.binarySearch(list, left);\\n     int e= Collections.binarySearch(list, right);\\n     if(s<0) s=(s+1)*(-1);\\n    if(e<0) e=(e+2)*(-1);\\n    return e-s+1;   \\n    }\\n}\\n\\n/**\\n * Your RangeFreqQuery object will be instantiated and called as such:\\n * RangeFreqQuery obj = new RangeFreqQuery(arr);\\n * int param_1 = obj.query(left,right,value);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass RangeFreqQuery {\\n    Map<Integer, List<Integer>> map;\\n    public RangeFreqQuery(int[] arr) {\\n        map = new HashMap<>();\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            if(!map.containsKey(arr[i])) map.put(arr[i], new ArrayList<>());\\n            map.get(arr[i]).add(i);\\n\\n        }\\n\\n        \\n    }\\n    \\n    public int query(int left, int right, int value) {\\n     if(!map.containsKey(value))  return 0;\\n     List<Integer> list = map.get(value);\\n     int s= Collections.binarySearch(list, left);\\n     int e= Collections.binarySearch(list, right);\\n     if(s<0) s=(s+1)*(-1);\\n    if(e<0) e=(e+2)*(-1);\\n    return e-s+1;   \\n    }\\n}\\n\\n/**\\n * Your RangeFreqQuery object will be instantiated and called as such:\\n * RangeFreqQuery obj = new RangeFreqQuery(arr);\\n * int param_1 = obj.query(left,right,value);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3282522,
                "title": "java-segment-tree-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class RangeFreqQuery {\\n    int[] ar;\\n    Map[] tree;\\n    public RangeFreqQuery(int[] arr) {\\n        ar = arr;\\n        tree = new Map[4 * arr.length];\\n        buildTree(1, 0, ar.length - 1);\\n    }\\n    public void buildTree(int node, int lo, int hi) {\\n        if(lo == hi) {\\n            tree[node] = new HashMap<>();\\n            tree[node].put(ar[lo], 1);\\n            return;\\n        }\\n\\n        int mid = lo + ((hi - lo) >> 1);\\n        int leftNode = node << 1;\\n        int rightNode = 1 + (node << 1);\\n\\n        buildTree(leftNode, lo, mid);\\n        buildTree(rightNode, mid + 1, hi);\\n\\n        tree[node] = merge(leftNode, rightNode);\\n    }\\n    private Map<Integer, Integer> merge(int leftNode, int rightNode) {\\n        Map<Integer, Integer> left = tree[leftNode];\\n        Map<Integer, Integer> right = tree[rightNode];\\n        Map<Integer, Integer> map = new HashMap<>();\\n        \\n        for(Map.Entry<Integer, Integer> e : left.entrySet())\\n            map.put(e.getKey(), \\n                    map.getOrDefault(e.getKey(), 0) + e.getValue());\\n        \\n        for(Map.Entry<Integer, Integer> e : right.entrySet())\\n            map.put(e.getKey(), \\n                    map.getOrDefault(e.getKey(), 0) + e.getValue());\\n        \\n        return map;\\n    }\\n    public int query(int node, int lo, int hi, int start, int end, int val) {\\n        if(lo > end || hi < start)\\n            return 0;\\n        if(lo == hi) {\\n            return tree[node].containsKey(val) ? 1 : 0;\\n        }\\n        if(lo >= start && hi <= end) {\\n            if(tree[node].containsKey(val))\\n                return (int) tree[node].get(val);\\n            else\\n                return 0;\\n        }\\n\\n        int mid = lo + ((hi - lo) >> 1);\\n        int leftNode = node << 1;\\n        int rightNode = 1 + (node << 1);\\n\\n        int la = query(leftNode, lo, mid, start, end, val);\\n        int ra = query(rightNode, mid + 1, hi, start, end, val);\\n        return la + ra;\\n    }\\n    public int query(int left, int right, int value) {\\n        return query(1, 0, ar.length - 1, left, right, value);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Segment Tree"
                ],
                "code": "```\\npublic class RangeFreqQuery {\\n    int[] ar;\\n    Map[] tree;\\n    public RangeFreqQuery(int[] arr) {\\n        ar = arr;\\n        tree = new Map[4 * arr.length];\\n        buildTree(1, 0, ar.length - 1);\\n    }\\n    public void buildTree(int node, int lo, int hi) {\\n        if(lo == hi) {\\n            tree[node] = new HashMap<>();\\n            tree[node].put(ar[lo], 1);\\n            return;\\n        }\\n\\n        int mid = lo + ((hi - lo) >> 1);\\n        int leftNode = node << 1;\\n        int rightNode = 1 + (node << 1);\\n\\n        buildTree(leftNode, lo, mid);\\n        buildTree(rightNode, mid + 1, hi);\\n\\n        tree[node] = merge(leftNode, rightNode);\\n    }\\n    private Map<Integer, Integer> merge(int leftNode, int rightNode) {\\n        Map<Integer, Integer> left = tree[leftNode];\\n        Map<Integer, Integer> right = tree[rightNode];\\n        Map<Integer, Integer> map = new HashMap<>();\\n        \\n        for(Map.Entry<Integer, Integer> e : left.entrySet())\\n            map.put(e.getKey(), \\n                    map.getOrDefault(e.getKey(), 0) + e.getValue());\\n        \\n        for(Map.Entry<Integer, Integer> e : right.entrySet())\\n            map.put(e.getKey(), \\n                    map.getOrDefault(e.getKey(), 0) + e.getValue());\\n        \\n        return map;\\n    }\\n    public int query(int node, int lo, int hi, int start, int end, int val) {\\n        if(lo > end || hi < start)\\n            return 0;\\n        if(lo == hi) {\\n            return tree[node].containsKey(val) ? 1 : 0;\\n        }\\n        if(lo >= start && hi <= end) {\\n            if(tree[node].containsKey(val))\\n                return (int) tree[node].get(val);\\n            else\\n                return 0;\\n        }\\n\\n        int mid = lo + ((hi - lo) >> 1);\\n        int leftNode = node << 1;\\n        int rightNode = 1 + (node << 1);\\n\\n        int la = query(leftNode, lo, mid, start, end, val);\\n        int ra = query(rightNode, mid + 1, hi, start, end, val);\\n        return la + ra;\\n    }\\n    public int query(int left, int right, int value) {\\n        return query(1, 0, ar.length - 1, left, right, value);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3257107,
                "title": "segment-tree-python-with-hashmap-in-each-node",
                "content": "```\\nclass RangeFreqQuery:\\n\\n    def __init__(self, arr: List[int]):\\n        self.arr = arr\\n        self.tree = [0]*4*len(arr)\\n        self.build(1,0,len(self.arr)-1)\\n    \\n    def build(self,seg,l,r):\\n        if l == r:\\n            self.tree[seg] = {self.arr[l]:1}\\n            return\\n        mid = (l+r)//2\\n        self.build(2*seg,l,mid)\\n        self.build(2*seg+1,mid+1,r)\\n        self.tree[seg] = {}\\n        for k,v in self.tree[2*seg].items():\\n            self.tree[seg][k] = v + self.tree[2*seg+1].get(k,0)\\n        for k,v in self.tree[2*seg+1].items():\\n            if k not in self.tree[seg]:\\n                self.tree[seg][k] = v \\n        return \\n    \\n    def freq_tree(self,seg,tl,tr,l,r,key):\\n        if l == tl and r == tr:\\n            return self.tree[seg].get(key,0)\\n        if l > r:\\n            return 0 \\n        mid = (tl+tr)//2\\n        return self.freq_tree(2*seg,tl,mid,l,min(r,mid),key) + self.freq_tree(2*seg+1,mid+1,tr,max(l,mid+1),r,key)\\n        \\n    def query(self, left: int, right: int, value: int) -> int:\\n        return self.freq_tree(1,0,len(self.arr)-1,left,right,value)",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```\\nclass RangeFreqQuery:\\n\\n    def __init__(self, arr: List[int]):\\n        self.arr = arr\\n        self.tree = [0]*4*len(arr)\\n        self.build(1,0,len(self.arr)-1)\\n    \\n    def build(self,seg,l,r):\\n        if l == r:\\n            self.tree[seg] = {self.arr[l]:1}\\n            return\\n        mid = (l+r)//2\\n        self.build(2*seg,l,mid)\\n        self.build(2*seg+1,mid+1,r)\\n        self.tree[seg] = {}\\n        for k,v in self.tree[2*seg].items():\\n            self.tree[seg][k] = v + self.tree[2*seg+1].get(k,0)\\n        for k,v in self.tree[2*seg+1].items():\\n            if k not in self.tree[seg]:\\n                self.tree[seg][k] = v \\n        return \\n    \\n    def freq_tree(self,seg,tl,tr,l,r,key):\\n        if l == tl and r == tr:\\n            return self.tree[seg].get(key,0)\\n        if l > r:\\n            return 0 \\n        mid = (tl+tr)//2\\n        return self.freq_tree(2*seg,tl,mid,l,min(r,mid),key) + self.freq_tree(2*seg+1,mid+1,tr,max(l,mid+1),r,key)\\n        \\n    def query(self, left: int, right: int, value: int) -> int:\\n        return self.freq_tree(1,0,len(self.arr)-1,left,right,value)",
                "codeTag": "Java"
            },
            {
                "id": 3204872,
                "title": "store-positions-as-array",
                "content": "```\\nimport bisect\\n\\nclass RangeFreqQuery:\\n    def __init__(self, arr: List[int]):\\n        self.pos = {}\\n        for i, el in enumerate(arr):\\n            if el not in self.pos:\\n                self.pos[el] = []\\n            self.pos[el].append(i)\\n\\n    def query(self, left: int, right: int, value: int) -> int:\\n        if value not in self.pos:\\n            return 0\\n        return bisect.bisect_right(self.pos[value], right) - bisect.bisect_left(self.pos[value], left)\\n```",
                "solutionTags": [],
                "code": "```\\nimport bisect\\n\\nclass RangeFreqQuery:\\n    def __init__(self, arr: List[int]):\\n        self.pos = {}\\n        for i, el in enumerate(arr):\\n            if el not in self.pos:\\n                self.pos[el] = []\\n            self.pos[el].append(i)\\n\\n    def query(self, left: int, right: int, value: int) -> int:\\n        if value not in self.pos:\\n            return 0\\n        return bisect.bisect_right(self.pos[value], right) - bisect.bisect_left(self.pos[value], left)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3177800,
                "title": "c",
                "content": "```\\nusing LL = long long ;\\nclass RangeFreqQuery {\\n    unordered_map<int, vector<int>>Map ;\\n    unordered_map<LL, int>Map2 ;\\npublic:\\n    RangeFreqQuery(vector<int>& arr) {\\n        for(int i = 0; i < arr.size(); i++)\\n            Map[arr[i]].push_back(i) ;\\n    }\\n    int BF1(vector<int>data, int lower){\\n        int left = 0, right = data.size()-1 ;\\n        if(data[right] < lower)\\n            return -1 ;\\n        while(left < right){\\n            int mid = left + (right-left)/2 ;\\n            if(data[mid] >= lower)\\n                right = mid ;\\n            else\\n                left = mid + 1 ;\\n        }\\n        return left ;\\n    }\\n    \\n    int BF2(vector<int>data, int upper){\\n        int left = 0, right = data.size()-1 ;\\n        if(data[0] > upper)\\n            return -1 ;\\n        while(left < right){\\n            int mid = right - (right-left)/2 ;\\n            if(data[mid] > upper)\\n                right = mid - 1 ;\\n            else\\n                left = mid  ;\\n        }\\n        return left ;\\n    }\\n    \\n    int query(int left, int right, int value) {\\n        LL hash = (LL)left * 10000000000 + (LL)right *100000 + value ;\\n        if(Map2.find(hash)!= Map2.end())\\n            return Map2[hash] ;\\n\\n        if(Map.find(value) == Map.end())\\n            return 0 ;\\n        int l = BF1(Map[value], left ) ;\\n        int r = BF2(Map[value], right) ;\\n\\n        int ans = 0 ;\\n        if(l != -1 && r != -1)    \\n            ans =  r - l + 1 ;\\n        Map2[hash] = ans ;\\n        return ans ;\\n    }\\n};\\n\\n/**\\n * Your RangeFreqQuery object will be instantiated and called as such:\\n * RangeFreqQuery* obj = new RangeFreqQuery(arr);\\n * int param_1 = obj->query(left,right,value);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nusing LL = long long ;\\nclass RangeFreqQuery {\\n    unordered_map<int, vector<int>>Map ;\\n    unordered_map<LL, int>Map2 ;\\npublic:\\n    RangeFreqQuery(vector<int>& arr) {\\n        for(int i = 0; i < arr.size(); i++)\\n            Map[arr[i]].push_back(i) ;\\n    }\\n    int BF1(vector<int>data, int lower){\\n        int left = 0, right = data.size()-1 ;\\n        if(data[right] < lower)\\n            return -1 ;\\n        while(left < right){\\n            int mid = left + (right-left)/2 ;\\n            if(data[mid] >= lower)\\n                right = mid ;\\n            else\\n                left = mid + 1 ;\\n        }\\n        return left ;\\n    }\\n    \\n    int BF2(vector<int>data, int upper){\\n        int left = 0, right = data.size()-1 ;\\n        if(data[0] > upper)\\n            return -1 ;\\n        while(left < right){\\n            int mid = right - (right-left)/2 ;\\n            if(data[mid] > upper)\\n                right = mid - 1 ;\\n            else\\n                left = mid  ;\\n        }\\n        return left ;\\n    }\\n    \\n    int query(int left, int right, int value) {\\n        LL hash = (LL)left * 10000000000 + (LL)right *100000 + value ;\\n        if(Map2.find(hash)!= Map2.end())\\n            return Map2[hash] ;\\n\\n        if(Map.find(value) == Map.end())\\n            return 0 ;\\n        int l = BF1(Map[value], left ) ;\\n        int r = BF2(Map[value], right) ;\\n\\n        int ans = 0 ;\\n        if(l != -1 && r != -1)    \\n            ans =  r - l + 1 ;\\n        Map2[hash] = ans ;\\n        return ans ;\\n    }\\n};\\n\\n/**\\n * Your RangeFreqQuery object will be instantiated and called as such:\\n * RangeFreqQuery* obj = new RangeFreqQuery(arr);\\n * int param_1 = obj->query(left,right,value);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3172613,
                "title": "easy-hashmap-binary-search-swift",
                "content": "# Notes :\\nFor left Binary Search We are allowed to take  `var l = 0, r = arr.count `;\\nFor right one We can start with  `var l = -1, r = arr.count - 1`\\n\\nThen If there is no left index in the array, **leftBS** function will return `arr.count` (kinda out of bounds);\\nAnd If there is no right index in the array, **rightBS** function will return `-1`.\\n\\nAfter checking that condition We can `return 0` in query.\\n `if r < l {return 0} ` \\n\\n# Complexity\\n- Time complexity: O(logn) for every query\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass RangeFreqQuery {\\n    var hashMap = [Int: [Int]]()\\n\\n    init(_ arr: [Int]) {\\n        var map = [Int: [Int]]()\\n        arr.enumerated().forEach {map[$0.1, default: []].append($0.0) }\\n        hashMap = map\\n    }\\n    \\n    func query(_ left: Int, _ right: Int, _ value: Int) -> Int {\\n        guard let indices = hashMap[value] else {return 0}\\n        let l = leftBS(left, indices)\\n        let r = rightBS(right, indices)\\n        if r < l {return 0} \\n        return r - l + 1\\n    }\\n\\n    func leftBS(_ left: Int, _ arr: [Int]) -> Int {\\n        var l = 0, r = arr.count \\n        while l < r {\\n            let mid = (l+r)/2\\n            if arr[mid] >= left {\\n                r = mid\\n            } else {\\n                l = mid + 1\\n            }\\n        }\\n        return l\\n    }\\n\\n    func rightBS(_ right: Int, _ arr: [Int]) -> Int {\\n        var l = -1, r = arr.count - 1\\n        while l < r {\\n            let mid = (l+r+1)/2\\n            if arr[mid] <= right {\\n                l = mid\\n            } else {\\n                r = mid - 1\\n            }\\n        }\\n        return l\\n    }\\n}\\n\\n/**\\n * Your RangeFreqQuery object will be instantiated and called as such:\\n * let obj = RangeFreqQuery(arr)\\n * let ret_1: Int = obj.query(left, right, value)\\n */\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass RangeFreqQuery {\\n    var hashMap = [Int: [Int]]()\\n\\n    init(_ arr: [Int]) {\\n        var map = [Int: [Int]]()\\n        arr.enumerated().forEach {map[$0.1, default: []].append($0.0) }\\n        hashMap = map\\n    }\\n    \\n    func query(_ left: Int, _ right: Int, _ value: Int) -> Int {\\n        guard let indices = hashMap[value] else {return 0}\\n        let l = leftBS(left, indices)\\n        let r = rightBS(right, indices)\\n        if r < l {return 0} \\n        return r - l + 1\\n    }\\n\\n    func leftBS(_ left: Int, _ arr: [Int]) -> Int {\\n        var l = 0, r = arr.count \\n        while l < r {\\n            let mid = (l+r)/2\\n            if arr[mid] >= left {\\n                r = mid\\n            } else {\\n                l = mid + 1\\n            }\\n        }\\n        return l\\n    }\\n\\n    func rightBS(_ right: Int, _ arr: [Int]) -> Int {\\n        var l = -1, r = arr.count - 1\\n        while l < r {\\n            let mid = (l+r+1)/2\\n            if arr[mid] <= right {\\n                l = mid\\n            } else {\\n                r = mid - 1\\n            }\\n        }\\n        return l\\n    }\\n}\\n\\n/**\\n * Your RangeFreqQuery object will be instantiated and called as such:\\n * let obj = RangeFreqQuery(arr)\\n * let ret_1: Int = obj.query(left, right, value)\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3157069,
                "title": "one-liner-binary-search-over-array-index-of-value",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor every value, store the positions of the value in the array.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(log(n))$$ - For every query. If there are $Q$ such queries then $$O(Q*log(n))$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n# Code\\n```\\nclass RangeFreqQuery {\\npublic:\\n    unordered_map<int, vector<int>>mp;\\n    RangeFreqQuery(vector<int>& arr) {\\n        for(int i=0;i<arr.size();i++) {\\n            mp[arr[i]].push_back(i);\\n        }\\n    }\\n    \\n    int query(int left, int right, int value) {\\n        return upper_bound(mp[value].begin(), mp[value].end(), right) - lower_bound(mp[value].begin(), mp[value].end(), left);\\n    }\\n};\\n\\n/**\\n * Your RangeFreqQuery object will be instantiated and called as such:\\n * RangeFreqQuery* obj = new RangeFreqQuery(arr);\\n * int param_1 = obj->query(left,right,value);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass RangeFreqQuery {\\npublic:\\n    unordered_map<int, vector<int>>mp;\\n    RangeFreqQuery(vector<int>& arr) {\\n        for(int i=0;i<arr.size();i++) {\\n            mp[arr[i]].push_back(i);\\n        }\\n    }\\n    \\n    int query(int left, int right, int value) {\\n        return upper_bound(mp[value].begin(), mp[value].end(), right) - lower_bound(mp[value].begin(), mp[value].end(), left);\\n    }\\n};\\n\\n/**\\n * Your RangeFreqQuery object will be instantiated and called as such:\\n * RangeFreqQuery* obj = new RangeFreqQuery(arr);\\n * int param_1 = obj->query(left,right,value);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3149360,
                "title": "java-segtree",
                "content": "```\\nclass RangeFreqQuery {\\n\\n   class SegmentTreeNode{\\n        int low;\\n        int high;\\n        SegmentTreeNode lchild;\\n        SegmentTreeNode rchild;\\n        public SegmentTreeNode(int l, int h){\\n            this.low = l;\\n            this.high =h;\\n            lchild = null;\\n            rchild = null;\\n        }\\n    }\\n\\n    class SegmentTree{\\n        SegmentTreeNode root;\\n\\n        SegmentTree(int[] arr){\\n            SegmentTreeNode rootNode = create(null, arr, 0, arr.length-1);\\n            root = rootNode;\\n        }\\n\\n        SegmentTreeNode create(SegmentTreeNode root, int[] arr, int low, int high){\\n            if(low == high){\\n                return new SegmentTreeNode(low, high);\\n            }\\n            root = new SegmentTreeNode(low, high);\\n            int mid = (low+high)/2;\\n            root.lchild = create(root.lchild,arr, low, mid);\\n            root.rchild = create(root.rchild,arr, mid+1, high);\\n            return root;\\n        }\\n\\n        int getFreq(int[] arr, int low, int high, int val){\\n            SegmentTreeNode rootNode = root;\\n            return getFreqUtil(rootNode, arr, low, high, val);\\n        }\\n\\n        private int getFreqUtil(SegmentTreeNode node, int[] arr, int low, int high, int val){\\n        \\n            if(low == high){\\n                if(arr[low] == val)\\n                    return 1;\\n                return 0;\\n            }\\n            int mid = (node.low + node.high)/2;\\n            if(low > mid)\\n                return getFreqUtil(node.rchild, arr, low, high, val);\\n            if(high <= mid)\\n                return getFreqUtil(node.lchild, arr, low, high, val);\\n            else return getFreqUtil(node.lchild, arr, low, mid, val) + getFreqUtil(node.rchild, arr, mid+1, high, val);\\n        }\\n    }\\n\\n    SegmentTree segmentTree;\\n    int[] arr;\\n    public RangeFreqQuery(int[] arr) {\\n        segmentTree = new SegmentTree(arr);\\n        this.arr = arr;\\n    }\\n\\n    public int query(int left, int right, int value) {\\n       return segmentTree.getFreq(arr, left, right, value);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass RangeFreqQuery {\\n\\n   class SegmentTreeNode{\\n        int low;\\n        int high;\\n        SegmentTreeNode lchild;\\n        SegmentTreeNode rchild;\\n        public SegmentTreeNode(int l, int h){\\n            this.low = l;\\n            this.high =h;\\n            lchild = null;\\n            rchild = null;\\n        }\\n    }\\n\\n    class SegmentTree{\\n        SegmentTreeNode root;\\n\\n        SegmentTree(int[] arr){\\n            SegmentTreeNode rootNode = create(null, arr, 0, arr.length-1);\\n            root = rootNode;\\n        }\\n\\n        SegmentTreeNode create(SegmentTreeNode root, int[] arr, int low, int high){\\n            if(low == high){\\n                return new SegmentTreeNode(low, high);\\n            }\\n            root = new SegmentTreeNode(low, high);\\n            int mid = (low+high)/2;\\n            root.lchild = create(root.lchild,arr, low, mid);\\n            root.rchild = create(root.rchild,arr, mid+1, high);\\n            return root;\\n        }\\n\\n        int getFreq(int[] arr, int low, int high, int val){\\n            SegmentTreeNode rootNode = root;\\n            return getFreqUtil(rootNode, arr, low, high, val);\\n        }\\n\\n        private int getFreqUtil(SegmentTreeNode node, int[] arr, int low, int high, int val){\\n        \\n            if(low == high){\\n                if(arr[low] == val)\\n                    return 1;\\n                return 0;\\n            }\\n            int mid = (node.low + node.high)/2;\\n            if(low > mid)\\n                return getFreqUtil(node.rchild, arr, low, high, val);\\n            if(high <= mid)\\n                return getFreqUtil(node.lchild, arr, low, high, val);\\n            else return getFreqUtil(node.lchild, arr, low, mid, val) + getFreqUtil(node.rchild, arr, mid+1, high, val);\\n        }\\n    }\\n\\n    SegmentTree segmentTree;\\n    int[] arr;\\n    public RangeFreqQuery(int[] arr) {\\n        segmentTree = new SegmentTree(arr);\\n        this.arr = arr;\\n    }\\n\\n    public int query(int left, int right, int value) {\\n       return segmentTree.getFreq(arr, left, right, value);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3092134,
                "title": "c-hashmap-binary-search",
                "content": "# Code\\n```\\nclass RangeFreqQuery {\\npublic:\\n    map<int,vector<int>> mp;\\n\\n    RangeFreqQuery(vector<int>& arr) {\\n        for (int i = 0; i < arr.size(); ++ i) mp[arr[i]].push_back(i);\\n    }\\n    \\n    int query(int left, int right, int value) {\\n        auto leftIt = lower_bound(mp[value].begin(), mp[value].end(), left), rightIt = upper_bound(mp[value].begin(), mp[value].end(), right);\\n        return distance(leftIt, rightIt);\\n    }\\n};\\n```\\n**Please upvote if u like the solution :)**",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Binary Search"
                ],
                "code": "```\\nclass RangeFreqQuery {\\npublic:\\n    map<int,vector<int>> mp;\\n\\n    RangeFreqQuery(vector<int>& arr) {\\n        for (int i = 0; i < arr.size(); ++ i) mp[arr[i]].push_back(i);\\n    }\\n    \\n    int query(int left, int right, int value) {\\n        auto leftIt = lower_bound(mp[value].begin(), mp[value].end(), left), rightIt = upper_bound(mp[value].begin(), mp[value].end(), right);\\n        return distance(leftIt, rightIt);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3082789,
                "title": "using-hashmap-and-treemap-in-hashmap-prefix-sum-solution",
                "content": "# Intuition\\nused a hashmap and TreeMap in the value of HashMap\\n# Approach\\nTreeMap stores the indices and prefix frequency\\n# Complexity\\n- Time complexity:\\nfor storing all the elements in hashMap O(N) and query function O(log n)\\n- Space complexity:\\nO(N)\\n# Code\\n```\\nclass RangeFreqQuery {\\n    HashMap<Integer,TreeMap<Integer,Integer>> map = null;\\n    public RangeFreqQuery(int[] arr) {\\n        int n = arr.length;\\n        int i; int x;\\n        map = new HashMap<>();\\n\\n        //storing the numbers as keys of hashmap and in values using treemap which stores indices of elements in keys and prefix freq in its values\\n        for(i=0;i<n;i++){\\n            x = arr[i];\\n            if(!map.containsKey(x)){\\n                TreeMap<Integer,Integer> index = new TreeMap<>();\\n                index.put(i,1);\\n                map.put(x,index);\\n            }\\n            else{\\n                TreeMap<Integer,Integer> tr = map.get(x);\\n                int index = tr.lastKey();\\n                int val = tr.get(index);\\n                tr.put(i,val+1);\\n            }\\n        }\\n    }\\n    \\n    //for query it will not take each time O(N), using treeMap it takes O(log n)\\n    public int query(int left, int right, int value) {\\n        if(map.containsKey(value)){\\n            TreeMap<Integer,Integer> result = map.get(value);\\n            int left_range = -1;\\n            if(right<result.firstKey()||left>result.lastKey()) return 0;\\n            if(left<=result.firstKey()){\\n                int right_range = result.floorKey(right);\\n                return result.get(right_range);\\n            }\\n            else\\n                left_range = result.floorKey(left-1);\\n            \\n            int right_range = result.floorKey(right);\\n            return result.get(right_range) - result.get(left_range);\\n        }\\n        return 0;\\n    }\\n}\\n\\n/**\\n * Your RangeFreqQuery object will be instantiated and called as such:\\n * RangeFreqQuery obj = new RangeFreqQuery(arr);\\n * int param_1 = obj.query(left,right,value);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass RangeFreqQuery {\\n    HashMap<Integer,TreeMap<Integer,Integer>> map = null;\\n    public RangeFreqQuery(int[] arr) {\\n        int n = arr.length;\\n        int i; int x;\\n        map = new HashMap<>();\\n\\n        //storing the numbers as keys of hashmap and in values using treemap which stores indices of elements in keys and prefix freq in its values\\n        for(i=0;i<n;i++){\\n            x = arr[i];\\n            if(!map.containsKey(x)){\\n                TreeMap<Integer,Integer> index = new TreeMap<>();\\n                index.put(i,1);\\n                map.put(x,index);\\n            }\\n            else{\\n                TreeMap<Integer,Integer> tr = map.get(x);\\n                int index = tr.lastKey();\\n                int val = tr.get(index);\\n                tr.put(i,val+1);\\n            }\\n        }\\n    }\\n    \\n    //for query it will not take each time O(N), using treeMap it takes O(log n)\\n    public int query(int left, int right, int value) {\\n        if(map.containsKey(value)){\\n            TreeMap<Integer,Integer> result = map.get(value);\\n            int left_range = -1;\\n            if(right<result.firstKey()||left>result.lastKey()) return 0;\\n            if(left<=result.firstKey()){\\n                int right_range = result.floorKey(right);\\n                return result.get(right_range);\\n            }\\n            else\\n                left_range = result.floorKey(left-1);\\n            \\n            int right_range = result.floorKey(right);\\n            return result.get(right_range) - result.get(left_range);\\n        }\\n        return 0;\\n    }\\n}\\n\\n/**\\n * Your RangeFreqQuery object will be instantiated and called as such:\\n * RangeFreqQuery obj = new RangeFreqQuery(arr);\\n * int param_1 = obj.query(left,right,value);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3072802,
                "title": "python-binary-search-o-logn",
                "content": "# Code\\n```\\nfrom collections import defaultdict\\nfrom bisect import bisect_right\\nclass RangeFreqQuery:\\n\\n    def __init__(self, arr: List[int]):\\n        self.index = defaultdict(list)\\n        for i, num in enumerate(arr):\\n            self.index[num].append(i)\\n\\n    def query(self, left: int, right: int, value: int) -> int:\\n        i = bisect_right(self.index[value], left-1)\\n        j = bisect_right(self.index[value], right)\\n        return j - i\\n\\n        \\n\\n\\n# Your RangeFreqQuery object will be instantiated and called as such:\\n# obj = RangeFreqQuery(arr)\\n# param_1 = obj.query(left,right,value)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict\\nfrom bisect import bisect_right\\nclass RangeFreqQuery:\\n\\n    def __init__(self, arr: List[int]):\\n        self.index = defaultdict(list)\\n        for i, num in enumerate(arr):\\n            self.index[num].append(i)\\n\\n    def query(self, left: int, right: int, value: int) -> int:\\n        i = bisect_right(self.index[value], left-1)\\n        j = bisect_right(self.index[value], right)\\n        return j - i\\n\\n        \\n\\n\\n# Your RangeFreqQuery object will be instantiated and called as such:\\n# obj = RangeFreqQuery(arr)\\n# param_1 = obj.query(left,right,value)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3044658,
                "title": "easy-to-understand-by-segment-tree",
                "content": "# Intuition\\nAssign meaning to node of segment tree.We can optimise it by change the data copying process.\\n\\n# Approach\\nsegment tree.\\n\\n# Complexity\\n- Time complexity:\\nnot good , still passed, with less logic.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass RangeFreqQuery {\\npublic:\\n    vector<int> grid;\\n    int n;\\n    vector<unordered_map<int,int>> segArr;\\n    RangeFreqQuery(vector<int>& arr) {\\n        n = arr.size();\\n        grid = arr;\\n        vector<unordered_map<int,int>> segArrTemp(4*n);\\n        segArr = segArrTemp;\\n        build(0,n-1,0);\\n    }\\n\\n    void build(int l,int r,int index){\\n       if(l==r){\\n           segArr[index][grid[l]] = 1 ;\\n           return;\\n       }\\n       int mid = (l+r)/2;\\n       build(l,mid,2*index+1);\\n       build(mid+1,r,2*index+2);\\n       unordered_map<int,int> localBuild;\\n       localBuild = segArr[2*index+2];\\n       for(auto it = segArr[2*index+1].begin();it!=segArr[2*index+1].end();it++){\\n           int key = it->first;\\n           int value = it->second;\\n           localBuild[key]+=value;\\n       }\\n       segArr[index] = localBuild;\\n    }\\n    \\n    int query(int left, int right, int value) {\\n        return query(0,n-1,left,right,value,0);\\n    }\\n\\n    int query(int l,int r,int left,int right,int value,int index){\\n        if(l>right || r < left){\\n            return 0;\\n        }\\n        if(l>=left && r<=right){\\n            return segArr[index][value];\\n        }\\n        int mid = (l+r)/2;\\n        int a = query(l,mid,left,right,value,2*index+1);\\n        int b = query(mid+1,r,left,right,value,2*index+2);\\n        return a+b;\\n    }\\n};\\n\\n/**\\n * Your RangeFreqQuery object will be instantiated and called as such:\\n * RangeFreqQuery* obj = new RangeFreqQuery(arr);\\n * int param_1 = obj->query(left,right,value);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass RangeFreqQuery {\\npublic:\\n    vector<int> grid;\\n    int n;\\n    vector<unordered_map<int,int>> segArr;\\n    RangeFreqQuery(vector<int>& arr) {\\n        n = arr.size();\\n        grid = arr;\\n        vector<unordered_map<int,int>> segArrTemp(4*n);\\n        segArr = segArrTemp;\\n        build(0,n-1,0);\\n    }\\n\\n    void build(int l,int r,int index){\\n       if(l==r){\\n           segArr[index][grid[l]] = 1 ;\\n           return;\\n       }\\n       int mid = (l+r)/2;\\n       build(l,mid,2*index+1);\\n       build(mid+1,r,2*index+2);\\n       unordered_map<int,int> localBuild;\\n       localBuild = segArr[2*index+2];\\n       for(auto it = segArr[2*index+1].begin();it!=segArr[2*index+1].end();it++){\\n           int key = it->first;\\n           int value = it->second;\\n           localBuild[key]+=value;\\n       }\\n       segArr[index] = localBuild;\\n    }\\n    \\n    int query(int left, int right, int value) {\\n        return query(0,n-1,left,right,value,0);\\n    }\\n\\n    int query(int l,int r,int left,int right,int value,int index){\\n        if(l>right || r < left){\\n            return 0;\\n        }\\n        if(l>=left && r<=right){\\n            return segArr[index][value];\\n        }\\n        int mid = (l+r)/2;\\n        int a = query(l,mid,left,right,value,2*index+1);\\n        int b = query(mid+1,r,left,right,value,2*index+2);\\n        return a+b;\\n    }\\n};\\n\\n/**\\n * Your RangeFreqQuery object will be instantiated and called as such:\\n * RangeFreqQuery* obj = new RangeFreqQuery(arr);\\n * int param_1 = obj->query(left,right,value);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3027208,
                "title": "ruby-692-ms",
                "content": "```ruby\\nclass RangeFreqQuery\\n\\n    def initialize a\\n        @h = h = Hash.new { _1[_2] = [] }\\n        a.each_with_index { h[_1] << _2 }\\n    end\\n\\n    def query l, r, v\\n        i = (a = @h[v]).bsearch { _1 >= l }\\n        return 0 if !i || i > r\\n        i = a.bsearch_index { _1 >= l }\\n        j = a.bsearch_index { _1 >  r }\\n        j ? j - i : a.size - i\\n    end\\n\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\nclass RangeFreqQuery\\n\\n    def initialize a\\n        @h = h = Hash.new { _1[_2] = [] }\\n        a.each_with_index { h[_1] << _2 }\\n    end\\n\\n    def query l, r, v\\n        i = (a = @h[v]).bsearch { _1 >= l }\\n        return 0 if !i || i > r\\n        i = a.bsearch_index { _1 >= l }\\n        j = a.bsearch_index { _1 >  r }\\n        j ? j - i : a.size - i\\n    end\\n\\nend\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3010810,
                "title": "java-segment-tree-hashmap",
                "content": "\\n# Code\\n```\\n\\nclass SegmentTree {\\n\\tprivate final Node[] heap;\\n\\tprivate final int[] array;\\n\\n\\tpublic SegmentTree(int[] array) {\\n\\t\\tthis.array = array;\\n\\t\\tint size = (int) (2 * Math.pow(2.0, Math.floor((Math.log(array.length) / Math.log(2.0)) + 1)));\\n\\t\\theap = new Node[size];\\n\\t\\tbuild(1, 0, array.length);\\n\\t}\\n\\n\\tprivate void build(int v, int from, int size) {\\n\\t\\theap[v] = new Node();\\n\\t\\theap[v].from = from;\\n\\t\\theap[v].to = from + size - 1;\\n\\n\\t\\tif (size == 1) {\\n\\t\\t\\theap[v].map.put(array[from], heap[v].map.getOrDefault(array[from], 0) + 1);\\n\\t\\t} else {\\n\\t\\t\\tbuild(2 * v, from, size / 2);\\n\\t\\t\\tbuild(2 * v + 1, from + size / 2, size - size / 2);\\n\\n\\t\\t\\tfor (Map.Entry<Integer, Integer> entry : heap[2 * v].map.entrySet()) {\\n\\t\\t\\t\\theap[v].map.put(entry.getKey(), heap[v].map.getOrDefault(entry.getKey(), 0) + entry.getValue());\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor (Map.Entry<Integer, Integer> entry : heap[2 * v + 1].map.entrySet()) {\\n\\t\\t\\t\\theap[v].map.put(entry.getKey(), heap[v].map.getOrDefault(entry.getKey(), 0) + entry.getValue());\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tpublic int rsq(int from, int to, int value) {\\n\\t\\treturn rsq(1, from, to, value);\\n\\t}\\n\\n\\tprivate int rsq(int v, int from, int to, int value) {\\n\\t\\tNode n = heap[v];\\n\\n\\t\\tif (n.pendingVal != null && contains(n.from, n.to, from, to)) {\\n\\t\\t\\treturn (to - from + 1) * n.pendingVal;\\n\\t\\t}\\n\\n\\t\\tif (contains(from, to, n.from, n.to)) {\\n\\t\\t\\treturn heap[v].map.getOrDefault(value, 0);\\n\\t\\t}\\n\\n\\t\\tif (intersects(from, to, n.from, n.to)) {\\n\\t\\t\\tint leftSum = rsq(2 * v, from, to, value);\\n\\t\\t\\tint rightSum = rsq(2 * v + 1, from, to, value);\\n\\n\\t\\t\\treturn leftSum + rightSum;\\n\\t\\t}\\n\\t\\treturn 0;\\n\\t}\\n\\n\\t//Test if the range1 contains range2\\n\\tprivate boolean contains(int from1, int to1, int from2, int to2) {\\n\\t\\treturn from2 >= from1 && to2 <= to1;\\n\\t}\\n\\n\\t//check inclusive intersection, test if range1[from1, to1] intersects range2[from2, to2]\\n\\tprivate boolean intersects(int from1, int to1, int from2, int to2) {\\n\\t\\treturn from1 <= from2 && to1 >= from2   //  (.[..)..] or (.[...]..)\\n\\t\\t\\t\\t|| from1 >= from2 && from1 <= to2; // [.(..]..) or [..(..)..\\n\\t}\\n\\n\\t//The Node class represents a partition range of the array.\\n\\tstatic class Node {\\n\\t\\tMap<Integer, Integer> map = new HashMap<>();\\n\\t\\t//Here We store the value that will be propagated lazily\\n\\t\\tInteger pendingVal = null;\\n\\t\\tint from;\\n\\t\\tint to;\\n\\n\\t\\tint size() {\\n\\t\\t\\treturn to - from + 1;\\n\\t\\t}\\n\\n\\t}\\n}\\n\\nclass RangeFreqQuery {\\n\\n    private final SegmentTree segmentTree;\\n\\n\\tpublic RangeFreqQuery(int[] arr) {\\n\\t\\tsegmentTree = new SegmentTree(arr);\\n\\t}\\n\\n\\tpublic int query(int left, int right, int value) {\\n\\t\\treturn segmentTree.rsq(left, right, value);\\n\\t}\\n}\\n\\n/**\\n * Your RangeFreqQuery object will be instantiated and called as such:\\n * RangeFreqQuery obj = new RangeFreqQuery(arr);\\n * int param_1 = obj.query(left,right,value);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Segment Tree"
                ],
                "code": "```\\n\\nclass SegmentTree {\\n\\tprivate final Node[] heap;\\n\\tprivate final int[] array;\\n\\n\\tpublic SegmentTree(int[] array) {\\n\\t\\tthis.array = array;\\n\\t\\tint size = (int) (2 * Math.pow(2.0, Math.floor((Math.log(array.length) / Math.log(2.0)) + 1)));\\n\\t\\theap = new Node[size];\\n\\t\\tbuild(1, 0, array.length);\\n\\t}\\n\\n\\tprivate void build(int v, int from, int size) {\\n\\t\\theap[v] = new Node();\\n\\t\\theap[v].from = from;\\n\\t\\theap[v].to = from + size - 1;\\n\\n\\t\\tif (size == 1) {\\n\\t\\t\\theap[v].map.put(array[from], heap[v].map.getOrDefault(array[from], 0) + 1);\\n\\t\\t} else {\\n\\t\\t\\tbuild(2 * v, from, size / 2);\\n\\t\\t\\tbuild(2 * v + 1, from + size / 2, size - size / 2);\\n\\n\\t\\t\\tfor (Map.Entry<Integer, Integer> entry : heap[2 * v].map.entrySet()) {\\n\\t\\t\\t\\theap[v].map.put(entry.getKey(), heap[v].map.getOrDefault(entry.getKey(), 0) + entry.getValue());\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor (Map.Entry<Integer, Integer> entry : heap[2 * v + 1].map.entrySet()) {\\n\\t\\t\\t\\theap[v].map.put(entry.getKey(), heap[v].map.getOrDefault(entry.getKey(), 0) + entry.getValue());\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tpublic int rsq(int from, int to, int value) {\\n\\t\\treturn rsq(1, from, to, value);\\n\\t}\\n\\n\\tprivate int rsq(int v, int from, int to, int value) {\\n\\t\\tNode n = heap[v];\\n\\n\\t\\tif (n.pendingVal != null && contains(n.from, n.to, from, to)) {\\n\\t\\t\\treturn (to - from + 1) * n.pendingVal;\\n\\t\\t}\\n\\n\\t\\tif (contains(from, to, n.from, n.to)) {\\n\\t\\t\\treturn heap[v].map.getOrDefault(value, 0);\\n\\t\\t}\\n\\n\\t\\tif (intersects(from, to, n.from, n.to)) {\\n\\t\\t\\tint leftSum = rsq(2 * v, from, to, value);\\n\\t\\t\\tint rightSum = rsq(2 * v + 1, from, to, value);\\n\\n\\t\\t\\treturn leftSum + rightSum;\\n\\t\\t}\\n\\t\\treturn 0;\\n\\t}\\n\\n\\t//Test if the range1 contains range2\\n\\tprivate boolean contains(int from1, int to1, int from2, int to2) {\\n\\t\\treturn from2 >= from1 && to2 <= to1;\\n\\t}\\n\\n\\t//check inclusive intersection, test if range1[from1, to1] intersects range2[from2, to2]\\n\\tprivate boolean intersects(int from1, int to1, int from2, int to2) {\\n\\t\\treturn from1 <= from2 && to1 >= from2   //  (.[..)..] or (.[...]..)\\n\\t\\t\\t\\t|| from1 >= from2 && from1 <= to2; // [.(..]..) or [..(..)..\\n\\t}\\n\\n\\t//The Node class represents a partition range of the array.\\n\\tstatic class Node {\\n\\t\\tMap<Integer, Integer> map = new HashMap<>();\\n\\t\\t//Here We store the value that will be propagated lazily\\n\\t\\tInteger pendingVal = null;\\n\\t\\tint from;\\n\\t\\tint to;\\n\\n\\t\\tint size() {\\n\\t\\t\\treturn to - from + 1;\\n\\t\\t}\\n\\n\\t}\\n}\\n\\nclass RangeFreqQuery {\\n\\n    private final SegmentTree segmentTree;\\n\\n\\tpublic RangeFreqQuery(int[] arr) {\\n\\t\\tsegmentTree = new SegmentTree(arr);\\n\\t}\\n\\n\\tpublic int query(int left, int right, int value) {\\n\\t\\treturn segmentTree.rsq(left, right, value);\\n\\t}\\n}\\n\\n/**\\n * Your RangeFreqQuery object will be instantiated and called as such:\\n * RangeFreqQuery obj = new RangeFreqQuery(arr);\\n * int param_1 = obj.query(left,right,value);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3005020,
                "title": "c-binary-search-similar-to-snap-shot-array",
                "content": "https://leetcode.com/problems/snapshot-array/\\n```\\nclass RangeFreqQuery {\\npublic:\\n    // similar to snap shot\\n    // treat each i as a snap shot\\n    // for each possible value have a list of snap shots\\n    unordered_map<int, vector<int>> a;\\n    RangeFreqQuery(vector<int>& arr) {\\n       for (int i = 0; i < arr.size(); ++i){\\n           a[arr[i]].push_back(i);\\n       }\\n    }\\n    \\n    int query(int left, int right, int value) {\\n        auto it = upper_bound(a[value].begin(), a[value].end(), left - 1);\\n        int freqLeft = it == a[value].begin() ? 0 : --it - a[value].begin() + 1;\\n        auto rightIt = upper_bound(a[value].begin(), a[value].end(), right);\\n        int freqRight = rightIt == a[value].begin() ? 0 : --rightIt - a[value].begin() + 1;\\n        return freqRight - freqLeft;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass RangeFreqQuery {\\npublic:\\n    // similar to snap shot\\n    // treat each i as a snap shot\\n    // for each possible value have a list of snap shots\\n    unordered_map<int, vector<int>> a;\\n    RangeFreqQuery(vector<int>& arr) {\\n       for (int i = 0; i < arr.size(); ++i){\\n           a[arr[i]].push_back(i);\\n       }\\n    }\\n    \\n    int query(int left, int right, int value) {\\n        auto it = upper_bound(a[value].begin(), a[value].end(), left - 1);\\n        int freqLeft = it == a[value].begin() ? 0 : --it - a[value].begin() + 1;\\n        auto rightIt = upper_bound(a[value].begin(), a[value].end(), right);\\n        int freqRight = rightIt == a[value].begin() ? 0 : --rightIt - a[value].begin() + 1;\\n        return freqRight - freqLeft;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2950433,
                "title": "java-segment-tree-oops-97",
                "content": "\\n# Approach\\nNo eager building of segment tree... building it based on queries\\n\\n\\nThanks for dropping-by... Pls upvote if it helps... :-)\\n# Code\\n```\\nclass RangeFreqQuery {\\n    private SegmentTree tree;\\n\\n    public RangeFreqQuery(int[] arr) {\\n        tree=new SegmentTree(arr);\\n    }\\n    \\n    public int query(int left, int right, int value) {\\n        return tree.query(left,right,value);\\n    }\\n}\\n\\nclass SegmentTree {\\n    TreeNode root;\\n    int[] arr;\\n\\n    SegmentTree(int[] arr) {\\n        int n=arr.length;\\n        this.arr=arr;\\n        root=new TreeNode(0,n-1);\\n    }\\n\\n    public int query(int l, int r, int val) {\\n        return query(root,l,r,val);\\n    }\\n\\n    private int query(TreeNode root, int l, int r, int val) {\\n        //Base\\n        if(r < root.start || root.end < l) //no overlap\\n            return 0;\\n        else if(l <= root.start && root.end <= r) { //complete overlap\\n            if(root.map != null)\\n                return root.map.getOrDefault(val,0);\\n            \\n            createMap(root,l,r);\\n            return root.map.getOrDefault(val,0);\\n        }\\n\\n        //partial overlap\\n        if(root.left == null) { //building tree while querying\\n            int mid=root.start+(root.end-root.start)/2;\\n            root.left=new TreeNode(root.start,mid);\\n            root.right=new TreeNode(mid+1,root.end);\\n\\n            //creating map for left & right child too\\n            createMap(root.left,root.start,mid);\\n            createMap(root.right,mid+1,root.end);\\n        }\\n        \\n        int left=query(root.left,l,r,val);\\n        int right=query(root.right,l,r,val);\\n        return left+right;\\n    }\\n\\n    private void createMap(TreeNode node, int l, int r) {\\n        node.map=new HashMap<>();\\n        for(int i=l; i<=r; i++) {\\n            node.map.put(arr[i], node.map.getOrDefault(arr[i],0)+1);\\n        }\\n    }\\n}\\n\\nclass TreeNode {\\n    int start;\\n    int end;\\n    TreeNode left;\\n    TreeNode right;\\n    Map<Integer,Integer> map;\\n\\n    TreeNode(int start, int end) {\\n        this.start=start;\\n        this.end=end;\\n    }\\n}\\n\\n\\n/**\\n * Your RangeFreqQuery object will be instantiated and called as such:\\n * RangeFreqQuery obj = new RangeFreqQuery(arr);\\n * int param_1 = obj.query(left,right,value);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass RangeFreqQuery {\\n    private SegmentTree tree;\\n\\n    public RangeFreqQuery(int[] arr) {\\n        tree=new SegmentTree(arr);\\n    }\\n    \\n    public int query(int left, int right, int value) {\\n        return tree.query(left,right,value);\\n    }\\n}\\n\\nclass SegmentTree {\\n    TreeNode root;\\n    int[] arr;\\n\\n    SegmentTree(int[] arr) {\\n        int n=arr.length;\\n        this.arr=arr;\\n        root=new TreeNode(0,n-1);\\n    }\\n\\n    public int query(int l, int r, int val) {\\n        return query(root,l,r,val);\\n    }\\n\\n    private int query(TreeNode root, int l, int r, int val) {\\n        //Base\\n        if(r < root.start || root.end < l) //no overlap\\n            return 0;\\n        else if(l <= root.start && root.end <= r) { //complete overlap\\n            if(root.map != null)\\n                return root.map.getOrDefault(val,0);\\n            \\n            createMap(root,l,r);\\n            return root.map.getOrDefault(val,0);\\n        }\\n\\n        //partial overlap\\n        if(root.left == null) { //building tree while querying\\n            int mid=root.start+(root.end-root.start)/2;\\n            root.left=new TreeNode(root.start,mid);\\n            root.right=new TreeNode(mid+1,root.end);\\n\\n            //creating map for left & right child too\\n            createMap(root.left,root.start,mid);\\n            createMap(root.right,mid+1,root.end);\\n        }\\n        \\n        int left=query(root.left,l,r,val);\\n        int right=query(root.right,l,r,val);\\n        return left+right;\\n    }\\n\\n    private void createMap(TreeNode node, int l, int r) {\\n        node.map=new HashMap<>();\\n        for(int i=l; i<=r; i++) {\\n            node.map.put(arr[i], node.map.getOrDefault(arr[i],0)+1);\\n        }\\n    }\\n}\\n\\nclass TreeNode {\\n    int start;\\n    int end;\\n    TreeNode left;\\n    TreeNode right;\\n    Map<Integer,Integer> map;\\n\\n    TreeNode(int start, int end) {\\n        this.start=start;\\n        this.end=end;\\n    }\\n}\\n\\n\\n/**\\n * Your RangeFreqQuery object will be instantiated and called as such:\\n * RangeFreqQuery obj = new RangeFreqQuery(arr);\\n * int param_1 = obj.query(left,right,value);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2946226,
                "title": "segment-tree-solution-c",
                "content": "# Code\\n```\\nclass RangeFreqQuery {\\npublic:\\n    vector<unordered_map<int,int>>tree;\\n    int n=0;\\n    void build(vector<int>& arr,int index,int s,int e)\\n    {\\n        if(s>e)\\n        return;\\n        if(s==e)\\n        {\\n            tree[index].insert({arr[s],1});\\n            return;\\n        }\\n        int mid=(s+e)/2;\\n        build(arr,2*index+1,s,mid);\\n         build(arr,2*index+2,mid+1,e);\\n        for(auto it:tree[2*index+1])\\n        tree[index][it.first]+=it.second;\\n        for(auto it:tree[2*index+2])\\n         tree[index][it.first]+=it.second;\\n    }\\n    RangeFreqQuery(vector<int>& arr) {\\n     n=arr.size();\\n        tree.resize(4*n+1);\\n        build(arr,0,0,n-1);\\n    }\\n    int solve(int ind, int s ,int e,int qs,int qe,int value)\\n    {\\n        if(qe<s ||e<qs)\\n        return 0;\\n        if(qs<=s && qe>=e)\\n        {\\n            if(tree[ind].find(value)!=tree[ind].end())\\n            {\\n\\n                return tree[ind][value];\\n            }\\n            return 0;\\n        }\\n        int mid=(s+e)/2;\\n        int left=solve(2*ind+1,s,mid,qs,qe,value);\\n         int right=solve(2*ind+2,mid+1,e,qs,qe,value);\\n         return left+right;\\n    }\\n    int query(int left, int right, int value) {\\n       return solve(0,0,n-1,left,right,value);\\n    }\\n};\\n\\n/**\\n * Your RangeFreqQuery object will be instantiated and called as such:\\n * RangeFreqQuery* obj = new RangeFreqQuery(arr);\\n * int param_1 = obj->query(left,right,value);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass RangeFreqQuery {\\npublic:\\n    vector<unordered_map<int,int>>tree;\\n    int n=0;\\n    void build(vector<int>& arr,int index,int s,int e)\\n    {\\n        if(s>e)\\n        return;\\n        if(s==e)\\n        {\\n            tree[index].insert({arr[s],1});\\n            return;\\n        }\\n        int mid=(s+e)/2;\\n        build(arr,2*index+1,s,mid);\\n         build(arr,2*index+2,mid+1,e);\\n        for(auto it:tree[2*index+1])\\n        tree[index][it.first]+=it.second;\\n        for(auto it:tree[2*index+2])\\n         tree[index][it.first]+=it.second;\\n    }\\n    RangeFreqQuery(vector<int>& arr) {\\n     n=arr.size();\\n        tree.resize(4*n+1);\\n        build(arr,0,0,n-1);\\n    }\\n    int solve(int ind, int s ,int e,int qs,int qe,int value)\\n    {\\n        if(qe<s ||e<qs)\\n        return 0;\\n        if(qs<=s && qe>=e)\\n        {\\n            if(tree[ind].find(value)!=tree[ind].end())\\n            {\\n\\n                return tree[ind][value];\\n            }\\n            return 0;\\n        }\\n        int mid=(s+e)/2;\\n        int left=solve(2*ind+1,s,mid,qs,qe,value);\\n         int right=solve(2*ind+2,mid+1,e,qs,qe,value);\\n         return left+right;\\n    }\\n    int query(int left, int right, int value) {\\n       return solve(0,0,n-1,left,right,value);\\n    }\\n};\\n\\n/**\\n * Your RangeFreqQuery object will be instantiated and called as such:\\n * RangeFreqQuery* obj = new RangeFreqQuery(arr);\\n * int param_1 = obj->query(left,right,value);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2933224,
                "title": "fenwick-tree",
                "content": "There are many better approach but incase you want to use fenwick tree take a look below\\n```\\nclass RangeFreqQuery:\\n\\n    def __init__(self, arr: List[int]):\\n        self.nums=arr\\n        self.n=len(arr)\\n        self.tree=[defaultdict(int) for i in range(self.n+1)]\\n        [self.fenwickTree(i+1,arr[i]) for i in range(self.n)]\\n    def fenwickTree(self,i,val):\\n        while i<=self.n:\\n            self.tree[i][val]+=1\\n            i+=(i&-i)\\n    def update(self,i,val):\\n        ans=0\\n        while i:\\n            ans+=self.tree[i][val]\\n            i-=(i&-i)\\n        return ans\\n            \\n\\n    def query(self, left: int, right: int, value: int) -> int:\\n        print(self.tree)\\n        return self.update(right+1,value)-self.update(left,value)\\n        # return 0\\n\\n\\n# Your RangeFreqQuery object will be instantiated and called as such:\\n# obj = RangeFreqQuery(arr)\\n# param_1 = obj.query(left,right,value)\\n```\\n",
                "solutionTags": [
                    "Python3",
                    "Tree"
                ],
                "code": "```\\nclass RangeFreqQuery:\\n\\n    def __init__(self, arr: List[int]):\\n        self.nums=arr\\n        self.n=len(arr)\\n        self.tree=[defaultdict(int) for i in range(self.n+1)]\\n        [self.fenwickTree(i+1,arr[i]) for i in range(self.n)]\\n    def fenwickTree(self,i,val):\\n        while i<=self.n:\\n            self.tree[i][val]+=1\\n            i+=(i&-i)\\n    def update(self,i,val):\\n        ans=0\\n        while i:\\n            ans+=self.tree[i][val]\\n            i-=(i&-i)\\n        return ans\\n            \\n\\n    def query(self, left: int, right: int, value: int) -> int:\\n        print(self.tree)\\n        return self.update(right+1,value)-self.update(left,value)\\n        # return 0\\n\\n\\n# Your RangeFreqQuery object will be instantiated and called as such:\\n# obj = RangeFreqQuery(arr)\\n# param_1 = obj.query(left,right,value)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2917936,
                "title": "runtime-1300-ms-faster-than-100-of-python3-online-submissions",
                "content": "# Code\\n```\\nfrom collections import defaultdict\\nfrom bisect import bisect_left, bisect_right\\nclass RangeFreqQuery:\\n\\n    def __init__(self, arr: List[int]):\\n        self.cache = dict()\\n        self.dct = defaultdict(list)\\n        for i in range(len(arr)):\\n            self.dct[arr[i]].append(i)\\n        \\n\\n    def query(self, left: int, right: int, value: int) -> int:\\n        key = (left, right, value)\\n        if key in self.cache:\\n            return self.cache[key]\\n        count = bisect_right(self.dct[value], right) - bisect_left(self.dct[value], left)\\n        self.cache[key] = count\\n        return count\\n\\n\\n# Your RangeFreqQuery object will be instantiated and called as such:\\n# obj = RangeFreqQuery(arr)\\n# param_1 = obj.query(left,right,value)\\n```\\n![image.png](https://assets.leetcode.com/users/images/1761baeb-0f91-4e96-8ed0-dca7afdcfb79_1671193009.1347382.png)\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict\\nfrom bisect import bisect_left, bisect_right\\nclass RangeFreqQuery:\\n\\n    def __init__(self, arr: List[int]):\\n        self.cache = dict()\\n        self.dct = defaultdict(list)\\n        for i in range(len(arr)):\\n            self.dct[arr[i]].append(i)\\n        \\n\\n    def query(self, left: int, right: int, value: int) -> int:\\n        key = (left, right, value)\\n        if key in self.cache:\\n            return self.cache[key]\\n        count = bisect_right(self.dct[value], right) - bisect_left(self.dct[value], left)\\n        self.cache[key] = count\\n        return count\\n\\n\\n# Your RangeFreqQuery object will be instantiated and called as such:\\n# obj = RangeFreqQuery(arr)\\n# param_1 = obj.query(left,right,value)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2905347,
                "title": "java-fenwick-tree-logn-count",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nn(logn) initially to construct tree. logn to search\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass RangeFreqQuery {\\n    private final Map<Integer, Integer>[] tree;\\n    \\n    public RangeFreqQuery(int[] arr) {\\n        tree = new Map[arr.length + 1];\\n        for (int i = 0; i < tree.length; i++) {\\n            tree[i] = new HashMap<>();\\n        }\\n        for (int i = 0; i < arr.length; i++) {\\n            updateTree(i + 1, arr[i]);\\n        }\\n    }\\n\\n    private void updateTree(int idx, int val) {\\n        while (idx < tree.length) {\\n            Map<Integer, Integer> numToCount = tree[idx];\\n            numToCount.put(val, numToCount.getOrDefault(val, 0) + 1);\\n            idx += (idx & -idx);\\n        }\\n    }\\n    \\n    public int query(int left, int right, int value) {\\n        return count(right + 1, value) - count(left, value);\\n    }\\n\\n    private int count(int idx, int value) {\\n        int count = 0;\\n        while (idx >= 1) {\\n            count += tree[idx].getOrDefault(value, 0);\\n            idx -= (idx & -idx);\\n        }\\n        return count;\\n    }\\n}\\n\\n/**\\n * Your RangeFreqQuery object will be instantiated and called as such:\\n * RangeFreqQuery obj = new RangeFreqQuery(arr);\\n * int param_1 = obj.query(left,right,value);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass RangeFreqQuery {\\n    private final Map<Integer, Integer>[] tree;\\n    \\n    public RangeFreqQuery(int[] arr) {\\n        tree = new Map[arr.length + 1];\\n        for (int i = 0; i < tree.length; i++) {\\n            tree[i] = new HashMap<>();\\n        }\\n        for (int i = 0; i < arr.length; i++) {\\n            updateTree(i + 1, arr[i]);\\n        }\\n    }\\n\\n    private void updateTree(int idx, int val) {\\n        while (idx < tree.length) {\\n            Map<Integer, Integer> numToCount = tree[idx];\\n            numToCount.put(val, numToCount.getOrDefault(val, 0) + 1);\\n            idx += (idx & -idx);\\n        }\\n    }\\n    \\n    public int query(int left, int right, int value) {\\n        return count(right + 1, value) - count(left, value);\\n    }\\n\\n    private int count(int idx, int value) {\\n        int count = 0;\\n        while (idx >= 1) {\\n            count += tree[idx].getOrDefault(value, 0);\\n            idx -= (idx & -idx);\\n        }\\n        return count;\\n    }\\n}\\n\\n/**\\n * Your RangeFreqQuery object will be instantiated and called as such:\\n * RangeFreqQuery obj = new RangeFreqQuery(arr);\\n * int param_1 = obj.query(left,right,value);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2869971,
                "title": "clear-java-solution-with-hashmap-of-treemap",
                "content": "\\n# Complexity\\n- Time complexity:\\nRangeFreqQuery : O(N Log N)\\nquery : O(Log N)\\n\\n\\n# Code\\n```\\nclass RangeFreqQuery {\\n    Map<Integer,TreeMap<Integer,Integer>> valRangeFrequecies = new HashMap<>();\\n    public RangeFreqQuery(int[] arr) {\\n        int len = arr.length;\\n        Map<Integer,Integer> freqMap = new HashMap<>();\\n        int i;\\n        for(i=0;i<len;i++){\\n            freqMap.put(arr[i],freqMap.getOrDefault(arr[i],0) + 1);\\n\\n            if(valRangeFrequecies.containsKey(arr[i])==false){\\n                TreeMap<Integer,Integer> rangeMap = new TreeMap<>();\\n                rangeMap.put(i,1);\\n                valRangeFrequecies.put(arr[i],rangeMap);\\n            }\\n            else{\\n                (valRangeFrequecies.get(arr[i])).put(i,freqMap.get(arr[i]));\\n            }\\n        }\\n    }\\n    \\n    public int query(int left, int right, int value) {\\n\\n        if(valRangeFrequecies.containsKey(value)){\\n                TreeMap<Integer,Integer> rangeMap = valRangeFrequecies.get(value);\\n                int rightFreq = 0;\\n                int leftFreq = 0;\\n                if(rangeMap.floorKey(right)!=null){\\n                    rightFreq = rangeMap.get(rangeMap.floorKey(right));\\n                }\\n                  if(rangeMap.floorKey(left-1)!=null){\\n                    leftFreq = rangeMap.get(rangeMap.floorKey(left-1));\\n                }\\n                return(rightFreq - leftFreq);\\n        }\\n        else{\\n            return 0;\\n        }\\n        \\n    }\\n}\\n\\n/**\\n * Your RangeFreqQuery object will be instantiated and called as such:\\n * RangeFreqQuery obj = new RangeFreqQuery(arr);\\n * int param_1 = obj.query(left,right,value);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass RangeFreqQuery {\\n    Map<Integer,TreeMap<Integer,Integer>> valRangeFrequecies = new HashMap<>();\\n    public RangeFreqQuery(int[] arr) {\\n        int len = arr.length;\\n        Map<Integer,Integer> freqMap = new HashMap<>();\\n        int i;\\n        for(i=0;i<len;i++){\\n            freqMap.put(arr[i],freqMap.getOrDefault(arr[i],0) + 1);\\n\\n            if(valRangeFrequecies.containsKey(arr[i])==false){\\n                TreeMap<Integer,Integer> rangeMap = new TreeMap<>();\\n                rangeMap.put(i,1);\\n                valRangeFrequecies.put(arr[i],rangeMap);\\n            }\\n            else{\\n                (valRangeFrequecies.get(arr[i])).put(i,freqMap.get(arr[i]));\\n            }\\n        }\\n    }\\n    \\n    public int query(int left, int right, int value) {\\n\\n        if(valRangeFrequecies.containsKey(value)){\\n                TreeMap<Integer,Integer> rangeMap = valRangeFrequecies.get(value);\\n                int rightFreq = 0;\\n                int leftFreq = 0;\\n                if(rangeMap.floorKey(right)!=null){\\n                    rightFreq = rangeMap.get(rangeMap.floorKey(right));\\n                }\\n                  if(rangeMap.floorKey(left-1)!=null){\\n                    leftFreq = rangeMap.get(rangeMap.floorKey(left-1));\\n                }\\n                return(rightFreq - leftFreq);\\n        }\\n        else{\\n            return 0;\\n        }\\n        \\n    }\\n}\\n\\n/**\\n * Your RangeFreqQuery object will be instantiated and called as such:\\n * RangeFreqQuery obj = new RangeFreqQuery(arr);\\n * int param_1 = obj.query(left,right,value);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2849491,
                "title": "binary-search-c-solution",
                "content": "```\\ntypedef struct {\\n    int* a;\\n    int size;\\n} RangeFreqQuery;\\n\\nint cmp(const void *a, const void *b){ return (*(int*)a - *(int*)b); }\\nRangeFreqQuery* rangeFreqQueryCreate(int* arr, int arrSize) {\\n    RangeFreqQuery* obj = (RangeFreqQuery*)calloc(1, sizeof(RangeFreqQuery));\\n    obj->size = arrSize + 1;    \\n    obj->a = (int*)calloc(obj->size, sizeof(int));\\n    for(int i = 0; i < arrSize; i++)\\n        obj->a[i] = arr[i] << 17 | i;\\n    obj->a[arrSize] = 10001 << 17;/* add a max value for the next element */\\n    qsort(obj->a, obj->size-1, sizeof(int), cmp);\\n     \\n    return obj;\\n}\\n\\nint bSearch1(int* a, int size, int target){\\n    int l = 0, r = size - 1, m;\\n    while(l < r){\\n        m = l + ((r - l)>>1);\\n        if(a[m] < target)\\n            l = m + 1;\\n        else\\n            r = m;\\n    }\\n    return l;\\n}\\nint bSearch2(int* a, int size, int target){\\n    int l = 0, r = size - 1, m;\\n    while(l < r){\\n        m = l + ((r - l)>>1);\\n        if(a[m] <= target)\\n            l = m + 1;\\n        else\\n            r = m;\\n    }\\n    return l;\\n}\\nint rangeFreqQueryQuery(RangeFreqQuery* obj, int left, int right, int value) {\\n    int l = bSearch1(obj->a, obj->size, value << 17 | left);/* find the first element >= target */\\n    int r = bSearch2(obj->a, obj->size, value << 17 | right);/* find the first element > target */\\n    return r-l;\\n}\\n\\nvoid rangeFreqQueryFree(RangeFreqQuery* obj) {\\n    free(obj->a);\\n    free(obj);\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\ntypedef struct {\\n    int* a;\\n    int size;\\n} RangeFreqQuery;\\n\\nint cmp(const void *a, const void *b){ return (*(int*)a - *(int*)b); }\\nRangeFreqQuery* rangeFreqQueryCreate(int* arr, int arrSize) {\\n    RangeFreqQuery* obj = (RangeFreqQuery*)calloc(1, sizeof(RangeFreqQuery));\\n    obj->size = arrSize + 1;    \\n    obj->a = (int*)calloc(obj->size, sizeof(int));\\n    for(int i = 0; i < arrSize; i++)\\n        obj->a[i] = arr[i] << 17 | i;\\n    obj->a[arrSize] = 10001 << 17;/* add a max value for the next element */\\n    qsort(obj->a, obj->size-1, sizeof(int), cmp);\\n     \\n    return obj;\\n}\\n\\nint bSearch1(int* a, int size, int target){\\n    int l = 0, r = size - 1, m;\\n    while(l < r){\\n        m = l + ((r - l)>>1);\\n        if(a[m] < target)\\n            l = m + 1;\\n        else\\n            r = m;\\n    }\\n    return l;\\n}\\nint bSearch2(int* a, int size, int target){\\n    int l = 0, r = size - 1, m;\\n    while(l < r){\\n        m = l + ((r - l)>>1);\\n        if(a[m] <= target)\\n            l = m + 1;\\n        else\\n            r = m;\\n    }\\n    return l;\\n}\\nint rangeFreqQueryQuery(RangeFreqQuery* obj, int left, int right, int value) {\\n    int l = bSearch1(obj->a, obj->size, value << 17 | left);/* find the first element >= target */\\n    int r = bSearch2(obj->a, obj->size, value << 17 | right);/* find the first element > target */\\n    return r-l;\\n}\\n\\nvoid rangeFreqQueryFree(RangeFreqQuery* obj) {\\n    free(obj->a);\\n    free(obj);\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2823954,
                "title": "c-easy-solution",
                "content": "\\n# Code\\n```\\nclass RangeFreqQuery {\\npublic:\\n   unordered_map<int,vector<int>> m;\\n    RangeFreqQuery(vector<int>& arr) {\\n       for(int i=0;i<arr.size();i++){\\n           m[arr[i]].push_back(i);\\n       }\\n       \\n    }\\n    \\n    int query(int left, int right, int value) {\\n        int lower=lower_bound(m[value].begin(),m[value].end(),left)-m[value].begin();\\n        int upper=upper_bound(m[value].begin(),m[value].end(),right)-m[value].begin();\\n       \\n        return upper-lower;\\n    }\\n};\\n\\n/**\\n * Your RangeFreqQuery object will be instantiated and called as such:\\n * RangeFreqQuery* obj = new RangeFreqQuery(arr);\\n * int param_1 = obj->query(left,right,value);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Binary Search",
                    "Segment Tree"
                ],
                "code": "```\\nclass RangeFreqQuery {\\npublic:\\n   unordered_map<int,vector<int>> m;\\n    RangeFreqQuery(vector<int>& arr) {\\n       for(int i=0;i<arr.size();i++){\\n           m[arr[i]].push_back(i);\\n       }\\n       \\n    }\\n    \\n    int query(int left, int right, int value) {\\n        int lower=lower_bound(m[value].begin(),m[value].end(),left)-m[value].begin();\\n        int upper=upper_bound(m[value].begin(),m[value].end(),right)-m[value].begin();\\n       \\n        return upper-lower;\\n    }\\n};\\n\\n/**\\n * Your RangeFreqQuery object will be instantiated and called as such:\\n * RangeFreqQuery* obj = new RangeFreqQuery(arr);\\n * int param_1 = obj->query(left,right,value);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2805848,
                "title": "c-segment-tree",
                "content": "Using simple segment tree concept\\n```\\nclass RangeFreqQuery {\\npublic:\\n    vector<unordered_map<int,int>> freq;\\n    int size=0;\\n    void buildTree(vector<int>& arr,int i,int j,int pos){\\n        if(i==j){\\n            freq[pos][arr[j]]+=1;\\n            return;\\n        }\\n        int mid=(i+j)/2;\\n        int left=(pos*2)+1;\\n        int right=(pos*2)+2;\\n        buildTree(arr,i,mid,left);\\n        buildTree(arr,mid+1,j,right);\\n        //copy the left tree\\n        for(auto it : freq[left]){\\n            freq[pos][it.first]+=it.second;\\n        }\\n        //copy the right tree\\n        for(auto it : freq[right]){\\n            freq[pos][it.first]+=it.second;\\n        }\\n    }\\n    RangeFreqQuery(vector<int>& arr) {\\n        size=arr.size();\\n        for(int i=0;i<=(4*size)+1;i++){\\n            unordered_map<int,int> a;\\n            freq.push_back(a);\\n        }\\n        buildTree(arr,0,size-1,0);\\n    }\\n    int query_helper(int i,int j,int qs,int qe,int pos,int val){\\n        if(i==j){\\n            if((i>=qs and i<=qe) or (j>=qs and j<=qe)){\\n                return freq[pos][val];\\n            }\\n            return 0;\\n        }\\n        if(qs>j or qe<i){\\n            return 0;\\n        }else if(i>=qs and j<=qe){\\n            return freq[pos][val];\\n        }else{\\n            int mid=(i+j)/2;\\n            int left=(pos*2)+1;\\n            int right=(pos*2)+2;\\n            return query_helper(i,mid,qs,qe,left,val)+\\n                query_helper(mid+1,j,qs,qe,right,val);\\n        }\\n    }\\n    int query(int left, int right, int value) {\\n        return query_helper(0,size-1,left,right,0,value);\\n    }\\n};\\n\\n/**\\n * Your RangeFreqQuery object will be instantiated and called as such:\\n * RangeFreqQuery* obj = new RangeFreqQuery(arr);\\n * int param_1 = obj->query(left,right,value);\\n */\\n```",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```\\nclass RangeFreqQuery {\\npublic:\\n    vector<unordered_map<int,int>> freq;\\n    int size=0;\\n    void buildTree(vector<int>& arr,int i,int j,int pos){\\n        if(i==j){\\n            freq[pos][arr[j]]+=1;\\n            return;\\n        }\\n        int mid=(i+j)/2;\\n        int left=(pos*2)+1;\\n        int right=(pos*2)+2;\\n        buildTree(arr,i,mid,left);\\n        buildTree(arr,mid+1,j,right);\\n        //copy the left tree\\n        for(auto it : freq[left]){\\n            freq[pos][it.first]+=it.second;\\n        }\\n        //copy the right tree\\n        for(auto it : freq[right]){\\n            freq[pos][it.first]+=it.second;\\n        }\\n    }\\n    RangeFreqQuery(vector<int>& arr) {\\n        size=arr.size();\\n        for(int i=0;i<=(4*size)+1;i++){\\n            unordered_map<int,int> a;\\n            freq.push_back(a);\\n        }\\n        buildTree(arr,0,size-1,0);\\n    }\\n    int query_helper(int i,int j,int qs,int qe,int pos,int val){\\n        if(i==j){\\n            if((i>=qs and i<=qe) or (j>=qs and j<=qe)){\\n                return freq[pos][val];\\n            }\\n            return 0;\\n        }\\n        if(qs>j or qe<i){\\n            return 0;\\n        }else if(i>=qs and j<=qe){\\n            return freq[pos][val];\\n        }else{\\n            int mid=(i+j)/2;\\n            int left=(pos*2)+1;\\n            int right=(pos*2)+2;\\n            return query_helper(i,mid,qs,qe,left,val)+\\n                query_helper(mid+1,j,qs,qe,right,val);\\n        }\\n    }\\n    int query(int left, int right, int value) {\\n        return query_helper(0,size-1,left,right,0,value);\\n    }\\n};\\n\\n/**\\n * Your RangeFreqQuery object will be instantiated and called as such:\\n * RangeFreqQuery* obj = new RangeFreqQuery(arr);\\n * int param_1 = obj->query(left,right,value);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2805623,
                "title": "golang-sgmt-tree",
                "content": "```\\ntype RangeFreqQuery struct {\\n\\ttr []map[int]int\\n}\\n\\nfunc Constructor(arr []int) RangeFreqQuery {\\n\\ttr := BuildSegTree(arr)\\n\\treturn RangeFreqQuery{tr: tr}\\n}\\n\\n\\nfunc (this *RangeFreqQuery) Query(left int, right int, value int) int {\\n\\treturn OpT(this.tr, left, right, value)\\n}\\n\\nfunc BuildSegTree(arr []int) []map[int]int {\\n\\tarrTree := make([]map[int]int, 4*len(arr))\\n\\tfor i := range arrTree {\\n\\t\\tarrTree[i] = make(map[int]int)\\n\\t}\\n\\tbuildSegTree(arr, &arrTree, 1, 0, len(arr)-1)\\n\\treturn arrTree\\n}\\n\\nfunc buildSegTree(arr []int, arrTree *[]map[int]int, v, tl, tr int) {\\n\\tif tl == tr {\\n\\t\\t(*arrTree)[v][arr[tl]]+=1\\n\\t\\treturn\\n\\t}\\n\\ttm := (tl + tr) / 2\\n\\n\\tbuildSegTree(arr, arrTree, left(v), tl, tm)\\n\\tbuildSegTree(arr, arrTree, right(v), tm+1, tr)\\n\\n\\tlm := (*arrTree)[left(v)]\\n\\trm :=  (*arrTree)[right(v)]\\n\\tcm := (*arrTree)[v]\\n\\n\\tfor k := range lm {\\n\\t\\tcm[k] += lm[k]\\n\\t}\\n\\n\\tfor k := range rm {\\n\\t\\tcm[k] += rm[k]\\n\\t}\\n}\\n\\nfunc left(i int) int {\\n\\treturn 2 * i\\n}\\n\\nfunc right(i int) int {\\n\\treturn (2 * i) + 1\\n}\\n\\nfunc min(x, y int) int {\\n\\tif x < y {\\n\\t\\treturn x\\n\\t}\\n\\treturn y\\n}\\n\\nfunc max(x, y int) int {\\n\\tif x > y {\\n\\t\\treturn x\\n\\t}\\n\\treturn y\\n}\\n\\nfunc OpT(arrTree []map[int]int, l, r, v int) int {\\n\\treturn opT(arrTree, 1, 0, (len(arrTree)/4)-1, l, r, v)\\n}\\n\\nfunc opT(arrTree []map[int]int, v, tl, tr, l, r, vx int) int {\\n\\tif l > r {\\n\\t\\treturn 0\\n\\t}\\n\\tif l == tl && r == tr {\\n\\t\\treturn arrTree[v][vx]\\n\\t}\\n\\ttm := (tl + tr) / 2\\n\\treturn opT(arrTree, left(v), tl, tm, l, min(r, tm), vx) +\\n\\t\\topT(arrTree, right(v), tm+1, tr, max(l, tm+1), r, vx)\\n}\\n```",
                "solutionTags": [],
                "code": "```\\ntype RangeFreqQuery struct {\\n\\ttr []map[int]int\\n}\\n\\nfunc Constructor(arr []int) RangeFreqQuery {\\n\\ttr := BuildSegTree(arr)\\n\\treturn RangeFreqQuery{tr: tr}\\n}\\n\\n\\nfunc (this *RangeFreqQuery) Query(left int, right int, value int) int {\\n\\treturn OpT(this.tr, left, right, value)\\n}\\n\\nfunc BuildSegTree(arr []int) []map[int]int {\\n\\tarrTree := make([]map[int]int, 4*len(arr))\\n\\tfor i := range arrTree {\\n\\t\\tarrTree[i] = make(map[int]int)\\n\\t}\\n\\tbuildSegTree(arr, &arrTree, 1, 0, len(arr)-1)\\n\\treturn arrTree\\n}\\n\\nfunc buildSegTree(arr []int, arrTree *[]map[int]int, v, tl, tr int) {\\n\\tif tl == tr {\\n\\t\\t(*arrTree)[v][arr[tl]]+=1\\n\\t\\treturn\\n\\t}\\n\\ttm := (tl + tr) / 2\\n\\n\\tbuildSegTree(arr, arrTree, left(v), tl, tm)\\n\\tbuildSegTree(arr, arrTree, right(v), tm+1, tr)\\n\\n\\tlm := (*arrTree)[left(v)]\\n\\trm :=  (*arrTree)[right(v)]\\n\\tcm := (*arrTree)[v]\\n\\n\\tfor k := range lm {\\n\\t\\tcm[k] += lm[k]\\n\\t}\\n\\n\\tfor k := range rm {\\n\\t\\tcm[k] += rm[k]\\n\\t}\\n}\\n\\nfunc left(i int) int {\\n\\treturn 2 * i\\n}\\n\\nfunc right(i int) int {\\n\\treturn (2 * i) + 1\\n}\\n\\nfunc min(x, y int) int {\\n\\tif x < y {\\n\\t\\treturn x\\n\\t}\\n\\treturn y\\n}\\n\\nfunc max(x, y int) int {\\n\\tif x > y {\\n\\t\\treturn x\\n\\t}\\n\\treturn y\\n}\\n\\nfunc OpT(arrTree []map[int]int, l, r, v int) int {\\n\\treturn opT(arrTree, 1, 0, (len(arrTree)/4)-1, l, r, v)\\n}\\n\\nfunc opT(arrTree []map[int]int, v, tl, tr, l, r, vx int) int {\\n\\tif l > r {\\n\\t\\treturn 0\\n\\t}\\n\\tif l == tl && r == tr {\\n\\t\\treturn arrTree[v][vx]\\n\\t}\\n\\ttm := (tl + tr) / 2\\n\\treturn opT(arrTree, left(v), tl, tm, l, min(r, tm), vx) +\\n\\t\\topT(arrTree, right(v), tm+1, tr, max(l, tm+1), r, vx)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2795628,
                "title": "python-dictionary-binary-search-super-easy-to-understand",
                "content": "All we have to count is in a particular subarray, how many times a value occurs. \\n\\nSo, we can have a HashMap that we will use to keep track of at what index a value appears in the given array. So for example, if the array that we are given is - \\n\\n\\t\\t[12, 33, 4, 56, 22, 2, 34, 33, 22, 12, 34, 56]\\n\\t\\t\\n\\t\\tThen we will create a HashMap like - \\n\\t\\t\\n\\t\\t\\t{\\n\\t\\t\\t\\t12: [0, 9], \\n\\t\\t\\t\\t33: [1, 7], \\n\\t\\t\\t\\t4: [2], \\n\\t\\t\\t\\t56: [3, 11], \\n\\t\\t\\t\\t22: [4, 8], \\n\\t\\t\\t\\t2: [5], \\n\\t\\t\\t\\t34: [6, 10]\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\nHence, for each element, we have a list of indices at which it appears in the given array. And ofcourse each list will be in a sorted order.\\n\\nNow, when we call the \"query\" method with some \"left\", \"right\" and \"value\" arguments, then all that we have to do is for that \"value\", take its list from the dictionary, and apply Binary Search.\\n\\n\\tHow are we going to use Binary Search here?\\n\\t\\n\\tSuppose, \\n\\t\\t\\t\\tleft = 0\\n\\t\\t\\t\\tright = 11\\n\\t\\t\\t\\tvalue = 33\\n\\t\\n\\tIt means, in the subarray starting at index 0 and ending at index 11 (both included), how many times \"33\" appears.\\n\\t\\n\\tWe know that for \"33\", the list in the dictionary is ->  [1, 7]\\n\\t\\n\\tAnd if you see, the smallest index in this list is \"1\" and it is greater than the left value i.e., 0.\\n\\tSimilarly, the largest index is \"7\" and it is smaller than the right value i.e, 11\\n\\t\\n\\tHence, both these indices lie in this subarray. In other words, 33 occurs twice in this subarray.\\n\\t\\n\\nAnd that\\'s the whole idea of Binary Search here. We will first search for the smallest index in the list that is >= left\\nAnd then, we will search for the largest index in the list that is <= right\\n\\n\\tOnce we find these two indices, count = (rightIndex - leftIndex + 1)\\n\\t\\nAlso, if the leftmostIndex comes as -1, that simply means not even a single occurance of \"value\" is there in the subarray. So we can straight away return 0 in that case instead of extra unnecessary computations.\\n\\n```\\nclass RangeFreqQuery:\\n\\n    def __init__(self, arr: List[int]):\\n        # For every element, keep a list of indices at which it is present in the array\\n        self.dict = defaultdict(list) \\n        for i,num in enumerate(arr): self.dict[num].append(i)\\n        \\n\\n    def query(self, left: int, right: int, value: int) -> int:\\n        \\n        # The list in which we have to count the occurances of \\'value\\'\\n        indices = self.dict[value]\\n        \\n        # Now, first, we will find the smallest index that is >= left\\n        start = 0\\n        end = len(indices) - 1\\n        leftmostIndex = -1\\n        \\n        while start <= end:\\n            mid = start + (end - start) // 2\\n            \\n            if indices[mid] >= left:\\n                leftmostIndex = mid\\n                end = mid - 1\\n            else: start = mid + 1\\n        \\n        # If leftmost index is -1, that means this subarray does not have a single \"value\"\\n        if leftmostIndex == -1: return 0\\n        \\n        # Next, we will find the largest index that is <= right\\n        start = 0\\n        end = len(indices) - 1\\n        rightmostIndex = -1\\n        \\n        while start <= end:\\n            mid = start + (end - start) // 2\\n            \\n            if indices[mid] <= right:\\n                rightmostIndex = mid\\n                start = mid + 1\\n            else: end = mid - 1\\n                \\n        # And once we get the two indices, just return how many times \"value\" occurs between these indices\\n        # That is, (leftindex - rightindex + 1)\\n        return rightmostIndex - leftmostIndex + 1\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass RangeFreqQuery:\\n\\n    def __init__(self, arr: List[int]):\\n        # For every element, keep a list of indices at which it is present in the array\\n        self.dict = defaultdict(list) \\n        for i,num in enumerate(arr): self.dict[num].append(i)\\n        \\n\\n    def query(self, left: int, right: int, value: int) -> int:\\n        \\n        # The list in which we have to count the occurances of \\'value\\'\\n        indices = self.dict[value]\\n        \\n        # Now, first, we will find the smallest index that is >= left\\n        start = 0\\n        end = len(indices) - 1\\n        leftmostIndex = -1\\n        \\n        while start <= end:\\n            mid = start + (end - start) // 2\\n            \\n            if indices[mid] >= left:\\n                leftmostIndex = mid\\n                end = mid - 1\\n            else: start = mid + 1\\n        \\n        # If leftmost index is -1, that means this subarray does not have a single \"value\"\\n        if leftmostIndex == -1: return 0\\n        \\n        # Next, we will find the largest index that is <= right\\n        start = 0\\n        end = len(indices) - 1\\n        rightmostIndex = -1\\n        \\n        while start <= end:\\n            mid = start + (end - start) // 2\\n            \\n            if indices[mid] <= right:\\n                rightmostIndex = mid\\n                start = mid + 1\\n            else: end = mid - 1\\n                \\n        # And once we get the two indices, just return how many times \"value\" occurs between these indices\\n        # That is, (leftindex - rightindex + 1)\\n        return rightmostIndex - leftmostIndex + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2792115,
                "title": "java-segment-tree-hashmap",
                "content": "![image](https://assets.leetcode.com/users/images/5f7fb3d4-1b66-452e-808b-f60a4223e166_1667893932.1480944.png)\\n\\n```\\nclass RangeFreqQuery {\\n    //Declaring tree of array of map \\n    Map<Integer,Integer>[] tree;\\n    int n=0;\\n    //combine the freq of element of both left and right subtree\\n    Map<Integer,Integer> countCombineFreq( Map<Integer,Integer> left, Map<Integer,Integer> right){\\n         Map<Integer,Integer> ans=new HashMap<>(left);\\n        for(int key:right.keySet()){\\n            if(ans.containsKey(key)){\\n                ans.put(key,ans.get(key)+right.get(key));\\n            }\\n            else{\\n                ans.put(key,right.get(key));\\n            }\\n        }\\n        return ans;\\n    }\\n    void buildTree(int[] arr,int index,int s,int e){\\n        if(s==e){\\n            Map<Integer,Integer> temp=new HashMap<>();\\n            temp.put(arr[s],1);\\n            tree[index]=temp;\\n            return;\\n        }\\n        int mid=(s+e)/2;\\n        buildTree(arr,2*index,s,mid);\\n        buildTree(arr,2*index+1,mid+1,e);\\n        tree[index]=countCombineFreq(tree[2*index],tree[2*index+1]);\\n    }\\n    public RangeFreqQuery(int[] arr) {\\n        n=arr.length;\\n        tree=new HashMap[4*n+1];\\n        buildTree(arr,1,0,arr.length-1);\\n    }\\n    int query_freq(int index,int s,int e,int l,int r,int val){\\n        //no overlap condition\\n        if(s>r || l>e)\\n            return 0;\\n        //full overlap condition\\n        if(s>=l && r>=e){\\n            return tree[index].getOrDefault(val,0);\\n        }\\n        //partial overlap condition\\n        int mid=(s+e)/2;\\n        int left=query_freq(2*index,s,mid,l,r,val);\\n        int right=query_freq(2*index+1,mid+1,e,l,r,val);\\n        return left+right;\\n    }\\n    public int query(int left, int right, int value) {\\n       return query_freq(1,0,n-1,left,right,value);\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass RangeFreqQuery {\\n    //Declaring tree of array of map \\n    Map<Integer,Integer>[] tree;\\n    int n=0;\\n    //combine the freq of element of both left and right subtree\\n    Map<Integer,Integer> countCombineFreq( Map<Integer,Integer> left, Map<Integer,Integer> right){\\n         Map<Integer,Integer> ans=new HashMap<>(left);\\n        for(int key:right.keySet()){\\n            if(ans.containsKey(key)){\\n                ans.put(key,ans.get(key)+right.get(key));\\n            }\\n            else{\\n                ans.put(key,right.get(key));\\n            }\\n        }\\n        return ans;\\n    }\\n    void buildTree(int[] arr,int index,int s,int e){\\n        if(s==e){\\n            Map<Integer,Integer> temp=new HashMap<>();\\n            temp.put(arr[s],1);\\n            tree[index]=temp;\\n            return;\\n        }\\n        int mid=(s+e)/2;\\n        buildTree(arr,2*index,s,mid);\\n        buildTree(arr,2*index+1,mid+1,e);\\n        tree[index]=countCombineFreq(tree[2*index],tree[2*index+1]);\\n    }\\n    public RangeFreqQuery(int[] arr) {\\n        n=arr.length;\\n        tree=new HashMap[4*n+1];\\n        buildTree(arr,1,0,arr.length-1);\\n    }\\n    int query_freq(int index,int s,int e,int l,int r,int val){\\n        //no overlap condition\\n        if(s>r || l>e)\\n            return 0;\\n        //full overlap condition\\n        if(s>=l && r>=e){\\n            return tree[index].getOrDefault(val,0);\\n        }\\n        //partial overlap condition\\n        int mid=(s+e)/2;\\n        int left=query_freq(2*index,s,mid,l,r,val);\\n        int right=query_freq(2*index+1,mid+1,e,l,r,val);\\n        return left+right;\\n    }\\n    public int query(int left, int right, int value) {\\n       return query_freq(1,0,n-1,left,right,value);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2769016,
                "title": "python-solution",
                "content": "```\\nclass RangeFreqQuery:\\n  def __init__(self, arr: List[int]):\\n    self.valueToIndices = defaultdict(list)\\n    for i, a in enumerate(arr):\\n      self.valueToIndices[a].append(i)\\n\\n  def query(self, left: int, right: int, value: int) -> int:\\n    indices = self.valueToIndices[value]\\n    i = bisect_left(indices, left)\\n    j = bisect_right(indices, right)\\n    return j - i\\n```",
                "solutionTags": [],
                "code": "```\\nclass RangeFreqQuery:\\n  def __init__(self, arr: List[int]):\\n    self.valueToIndices = defaultdict(list)\\n    for i, a in enumerate(arr):\\n      self.valueToIndices[a].append(i)\\n\\n  def query(self, left: int, right: int, value: int) -> int:\\n    indices = self.valueToIndices[value]\\n    i = bisect_left(indices, left)\\n    j = bisect_right(indices, right)\\n    return j - i\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2723042,
                "title": "python-simple-binary-search-using-bisect-left-and-right",
                "content": "```\\nclass RangeFreqQuery:\\n\\n    def __init__(self, arr: List[int]):\\n        self.count = defaultdict(list)\\n        for i, a in enumerate(arr):\\n            self.count[a].append(i)\\n\\n    def query(self, left: int, right: int, value: int) -> int:\\n        return bisect_right(self.count[value], right) - bisect_left(self.count[value], left)\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass RangeFreqQuery:\\n\\n    def __init__(self, arr: List[int]):\\n        self.count = defaultdict(list)\\n        for i, a in enumerate(arr):\\n            self.count[a].append(i)\\n\\n    def query(self, left: int, right: int, value: int) -> int:\\n        return bisect_right(self.count[value], right) - bisect_left(self.count[value], left)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2719992,
                "title": "python3-using-segment-tree-with-explanation",
                "content": "```\\nclass RangeFreqQuery:\\n\\n    def __init__(self, arr: List[int]):\\n\\t\\t# makes n size of arr and creates array for segment tree\\n\\t\\t# segmenet tree is dictionary of count of values that are within that segment / range\\n        self.n = len(arr)\\n        self.segTree = [defaultdict(int) for i in range(2 * self.n)]\\n        \\n\\t\\t# initiate leaf nodes which will populate the dictionary with a single value\\n        for i in range(self.n):\\n            self.segTree[self.n + i][arr[i]] += 1\\n        \\n\\t\\t# populates parent nodes by adding together the values held within the range of the child nodes\\n\\t\\t# this way the parent\\'s dictionary accounts for values within the range of both children\\n        for i in range(self.n - 1, 0, -1):\\n            l = self.segTree[2 * i]\\n            r = self.segTree[2 * i + 1]\\n            keys = set(list(l.keys()) + list(r.keys()))\\n            for k in keys:\\n                self.segTree[i][k] = l[k] + r[k]\\n\\n\\t# creates result of query\\n    def query(self, left: int, right: int, value: int) -> int:\\n        l = left + self.n\\n        r = right + self.n\\n        tot = 0\\n        \\n\\t\\t# checks nodes that would be included in the range\\n        while (l <= r):\\n            if (l % 2 == 1):\\n                tot += self.segTree[l][value] # adds the number of appearances of the value inside the range\\n                l += 1\\n            if (r % 2 == 0):\\n                tot += self.segTree[r][value] # adds the number of appearances of the value inside the range\\n                r -= 1\\n            l = l // 2\\n            r = r // 2\\n        \\n        return tot\\n\\n\\n# Your RangeFreqQuery object will be instantiated and called as such:\\n# obj = RangeFreqQuery(arr)\\n# param_1 = obj.query(left,right,value)\\n```",
                "solutionTags": [
                    "Python",
                    "Tree"
                ],
                "code": "```\\nclass RangeFreqQuery:\\n\\n    def __init__(self, arr: List[int]):\\n\\t\\t# makes n size of arr and creates array for segment tree\\n\\t\\t# segmenet tree is dictionary of count of values that are within that segment / range\\n        self.n = len(arr)\\n        self.segTree = [defaultdict(int) for i in range(2 * self.n)]\\n        \\n\\t\\t# initiate leaf nodes which will populate the dictionary with a single value\\n        for i in range(self.n):\\n            self.segTree[self.n + i][arr[i]] += 1\\n        \\n\\t\\t# populates parent nodes by adding together the values held within the range of the child nodes\\n\\t\\t# this way the parent\\'s dictionary accounts for values within the range of both children\\n        for i in range(self.n - 1, 0, -1):\\n            l = self.segTree[2 * i]\\n            r = self.segTree[2 * i + 1]\\n            keys = set(list(l.keys()) + list(r.keys()))\\n            for k in keys:\\n                self.segTree[i][k] = l[k] + r[k]\\n\\n\\t# creates result of query\\n    def query(self, left: int, right: int, value: int) -> int:\\n        l = left + self.n\\n        r = right + self.n\\n        tot = 0\\n        \\n\\t\\t# checks nodes that would be included in the range\\n        while (l <= r):\\n            if (l % 2 == 1):\\n                tot += self.segTree[l][value] # adds the number of appearances of the value inside the range\\n                l += 1\\n            if (r % 2 == 0):\\n                tot += self.segTree[r][value] # adds the number of appearances of the value inside the range\\n                r -= 1\\n            l = l // 2\\n            r = r // 2\\n        \\n        return tot\\n\\n\\n# Your RangeFreqQuery object will be instantiated and called as such:\\n# obj = RangeFreqQuery(arr)\\n# param_1 = obj.query(left,right,value)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2716453,
                "title": "java-javascript-c-solution",
                "content": "**Java**\\n```\\nimport java.util.ArrayList;\\nimport java.util.HashMap;\\nimport java.util.List;\\nimport java.util.Map;\\n\\npublic class RangeFreqQuery {\\n\\n    Map<Integer, List<Integer>> mapValueToIndexes;\\n\\n    public RangeFreqQuery(int[] input) {\\n        mapValueToIndexes = new HashMap<>();\\n        for (int i = 0; i < input.length; ++i) {\\n            mapValueToIndexes.putIfAbsent(input[i], new ArrayList<>());\\n            mapValueToIndexes.get(input[i]).add(i);\\n        }\\n    }\\n\\n    public int query(int start, int end, int value) {\\n        if (!mapValueToIndexes.containsKey(value)) {\\n            return 0;\\n        }\\n        int indexStart = binarySearchBoundary(mapValueToIndexes.get(value), start, true);\\n        int indexEnd = binarySearchBoundary(mapValueToIndexes.get(value), end, false);\\n        return indexEnd - indexStart + 1;\\n    }\\n\\n    private int binarySearchBoundary(List<Integer> listIndexes, int target, boolean upperBoundSearch) {\\n        int left = 0;\\n        int right = listIndexes.size() - 1;\\n\\n        while (left <= right) {\\n            int middle = left + (right - left) / 2;\\n            if (listIndexes.get(middle) == target) {\\n                return middle;\\n            }\\n            if (listIndexes.get(middle) < target) {\\n                left = middle + 1;\\n            } else {\\n                right = middle - 1;\\n            }\\n        }\\n        return upperBoundSearch ? left : right;\\n    }\\n}\\n```\\n**JavaScript**\\n```\\nclass RangeFreqQuery {\\n\\n    /**\\n     * @param {number[]} input\\n     */\\n    constructor(input) {\\n        this.mapValueToIndexes = new Map();//Map<number, number[]> \\n        for (let i = 0; i < input.length; ++i) {\\n            if (!this.mapValueToIndexes.has(input[i])) {\\n                this.mapValueToIndexes.set(input[i], []);\\n            }\\n            this.mapValueToIndexes.get(input[i]).push(i);\\n        }\\n    }\\n\\n    /** \\n     * @param {number} start \\n     * @param {number} end \\n     * @param {number} value\\n     * @return {number}\\n     */\\n    query(start, end, value) {\\n        if (!this.mapValueToIndexes.has(value)) {\\n            return 0;\\n        }\\n        let indexStart = this.binarySearchBoundary(this.mapValueToIndexes.get(value), start, true);\\n        let indexEnd = this.binarySearchBoundary(this.mapValueToIndexes.get(value), end, false);\\n        return indexEnd - indexStart + 1;\\n    }\\n\\n    /** \\n     * @param {number} listIndexes \\n     * @param {number} target \\n     * @param {boolean} upperBoundSearch\\n     * @return {number}\\n     */\\n    binarySearchBoundary(listIndexes, target, upperBoundSearch) {\\n        let left = 0;\\n        let right = listIndexes.length - 1;\\n\\n        while (left <= right) {\\n            let middle = left + Math.floor((right - left) / 2);\\n            if (listIndexes[middle] === target) {\\n                return middle;\\n            }\\n            if (listIndexes[middle] < target) {\\n                left = middle + 1;\\n            } else {\\n                right = middle - 1;\\n            }\\n        }\\n        return upperBoundSearch ? left : right;\\n    }\\n}\\n```\\n**C++**\\n```\\n#include <vector>\\n#include <unordered_map>\\nusing namespace std;\\n\\nclass RangeFreqQuery {\\n    \\n    unordered_map<int, vector<int>>mapValueToIndexes;\\n    \\npublic:\\n    explicit RangeFreqQuery(const vector<int>& input) {\\n        for (int i = 0; i < input.size(); ++i) {\\n            mapValueToIndexes[input[i]].push_back(i);\\n        }\\n    }\\n\\n    int query(int start, int end, int value) {\\n\\n        //C++20: mapValueToIndexes.contains(value), done the old way for compatibility.\\n        if (mapValueToIndexes.find(value) == mapValueToIndexes.end()) {\\n            return 0;\\n        }\\n        int indexStart = binarySearchBoundary(mapValueToIndexes[value], start, true);\\n        int indexEnd = binarySearchBoundary(mapValueToIndexes[value], end, false);\\n        return indexEnd - indexStart + 1;\\n    }\\n\\nprivate:\\n    int binarySearchBoundary(const vector<int>& listIndexes, int target, bool upperBoundSearch) const {\\n        int left = 0;\\n        int right = listIndexes.size() - 1;\\n\\n        while (left <= right) {\\n            int middle = left + (right - left) / 2;\\n            if (listIndexes[middle] == target) {\\n                return middle;\\n            }\\n            if (listIndexes[middle] < target) {\\n                left = middle + 1;\\n            } else {\\n                right = middle - 1;\\n            }\\n        }\\n        return upperBoundSearch ? left : right;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "C",
                    "JavaScript",
                    "Binary Search"
                ],
                "code": "```\\nimport java.util.ArrayList;\\nimport java.util.HashMap;\\nimport java.util.List;\\nimport java.util.Map;\\n\\npublic class RangeFreqQuery {\\n\\n    Map<Integer, List<Integer>> mapValueToIndexes;\\n\\n    public RangeFreqQuery(int[] input) {\\n        mapValueToIndexes = new HashMap<>();\\n        for (int i = 0; i < input.length; ++i) {\\n            mapValueToIndexes.putIfAbsent(input[i], new ArrayList<>());\\n            mapValueToIndexes.get(input[i]).add(i);\\n        }\\n    }\\n\\n    public int query(int start, int end, int value) {\\n        if (!mapValueToIndexes.containsKey(value)) {\\n            return 0;\\n        }\\n        int indexStart = binarySearchBoundary(mapValueToIndexes.get(value), start, true);\\n        int indexEnd = binarySearchBoundary(mapValueToIndexes.get(value), end, false);\\n        return indexEnd - indexStart + 1;\\n    }\\n\\n    private int binarySearchBoundary(List<Integer> listIndexes, int target, boolean upperBoundSearch) {\\n        int left = 0;\\n        int right = listIndexes.size() - 1;\\n\\n        while (left <= right) {\\n            int middle = left + (right - left) / 2;\\n            if (listIndexes.get(middle) == target) {\\n                return middle;\\n            }\\n            if (listIndexes.get(middle) < target) {\\n                left = middle + 1;\\n            } else {\\n                right = middle - 1;\\n            }\\n        }\\n        return upperBoundSearch ? left : right;\\n    }\\n}\\n```\n```\\nclass RangeFreqQuery {\\n\\n    /**\\n     * @param {number[]} input\\n     */\\n    constructor(input) {\\n        this.mapValueToIndexes = new Map();//Map<number, number[]> \\n        for (let i = 0; i < input.length; ++i) {\\n            if (!this.mapValueToIndexes.has(input[i])) {\\n                this.mapValueToIndexes.set(input[i], []);\\n            }\\n            this.mapValueToIndexes.get(input[i]).push(i);\\n        }\\n    }\\n\\n    /** \\n     * @param {number} start \\n     * @param {number} end \\n     * @param {number} value\\n     * @return {number}\\n     */\\n    query(start, end, value) {\\n        if (!this.mapValueToIndexes.has(value)) {\\n            return 0;\\n        }\\n        let indexStart = this.binarySearchBoundary(this.mapValueToIndexes.get(value), start, true);\\n        let indexEnd = this.binarySearchBoundary(this.mapValueToIndexes.get(value), end, false);\\n        return indexEnd - indexStart + 1;\\n    }\\n\\n    /** \\n     * @param {number} listIndexes \\n     * @param {number} target \\n     * @param {boolean} upperBoundSearch\\n     * @return {number}\\n     */\\n    binarySearchBoundary(listIndexes, target, upperBoundSearch) {\\n        let left = 0;\\n        let right = listIndexes.length - 1;\\n\\n        while (left <= right) {\\n            let middle = left + Math.floor((right - left) / 2);\\n            if (listIndexes[middle] === target) {\\n                return middle;\\n            }\\n            if (listIndexes[middle] < target) {\\n                left = middle + 1;\\n            } else {\\n                right = middle - 1;\\n            }\\n        }\\n        return upperBoundSearch ? left : right;\\n    }\\n}\\n```\n```\\n#include <vector>\\n#include <unordered_map>\\nusing namespace std;\\n\\nclass RangeFreqQuery {\\n    \\n    unordered_map<int, vector<int>>mapValueToIndexes;\\n    \\npublic:\\n    explicit RangeFreqQuery(const vector<int>& input) {\\n        for (int i = 0; i < input.size(); ++i) {\\n            mapValueToIndexes[input[i]].push_back(i);\\n        }\\n    }\\n\\n    int query(int start, int end, int value) {\\n\\n        //C++20: mapValueToIndexes.contains(value), done the old way for compatibility.\\n        if (mapValueToIndexes.find(value) == mapValueToIndexes.end()) {\\n            return 0;\\n        }\\n        int indexStart = binarySearchBoundary(mapValueToIndexes[value], start, true);\\n        int indexEnd = binarySearchBoundary(mapValueToIndexes[value], end, false);\\n        return indexEnd - indexStart + 1;\\n    }\\n\\nprivate:\\n    int binarySearchBoundary(const vector<int>& listIndexes, int target, bool upperBoundSearch) const {\\n        int left = 0;\\n        int right = listIndexes.size() - 1;\\n\\n        while (left <= right) {\\n            int middle = left + (right - left) / 2;\\n            if (listIndexes[middle] == target) {\\n                return middle;\\n            }\\n            if (listIndexes[middle] < target) {\\n                left = middle + 1;\\n            } else {\\n                right = middle - 1;\\n            }\\n        }\\n        return upperBoundSearch ? left : right;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2702945,
                "title": "clean-python3-bisect",
                "content": "Please upvote if it helps :)\\n```\\nclass RangeFreqQuery:\\n\\n    def __init__(self, arr: List[int]):\\n        self.indices = defaultdict(list)\\n        for i, x in enumerate(arr):\\n            self.indices[x].append(i)\\n\\n    def query(self, left: int, right: int, value: int) -> int:\\n        left_ins = bisect_left(self.indices[value], left)\\n        right_ins = bisect_right(self.indices[value], right)\\n        return right_ins - left_ins",
                "solutionTags": [
                    "Python3"
                ],
                "code": "Please upvote if it helps :)\\n```\\nclass RangeFreqQuery:\\n\\n    def __init__(self, arr: List[int]):\\n        self.indices = defaultdict(list)\\n        for i, x in enumerate(arr):\\n            self.indices[x].append(i)\\n\\n    def query(self, left: int, right: int, value: int) -> int:\\n        left_ins = bisect_left(self.indices[value], left)\\n        right_ins = bisect_right(self.indices[value], right)\\n        return right_ins - left_ins",
                "codeTag": "Java"
            },
            {
                "id": 2697542,
                "title": "python-simple-binary-search",
                "content": "\\n\\n    def __init__(self, arr):\\n        self.dict1 = defaultdict(list)\\n        \\n        for i, j in enumerate(arr):\\n            self.dict1[j].append(i)\\n\\n    def query(self, left, right, value):\\n        ans = self.dict1[value]\\n        \\n        left = bisect.bisect_left(ans,left)\\n        right = bisect.bisect_right(ans,right)\\n        \\n        return right - left",
                "solutionTags": [],
                "code": "\\n\\n    def __init__(self, arr):\\n        self.dict1 = defaultdict(list)\\n        \\n        for i, j in enumerate(arr):\\n            self.dict1[j].append(i)\\n\\n    def query(self, left, right, value):\\n        ans = self.dict1[value]\\n        \\n        left = bisect.bisect_left(ans,left)\\n        right = bisect.bisect_right(ans,right)\\n        \\n        return right - left",
                "codeTag": "Python3"
            },
            {
                "id": 2671179,
                "title": "python-solution-faster-92",
                "content": "\\tclass RangeFreqQuery:\\n\\n\\t\\tdef __init__(self, A):\\n\\t\\t\\tself.count = collections.defaultdict(list)\\n\\t\\t\\tfor i, a in enumerate(A):\\n\\t\\t\\t\\tself.count[a].append(i)\\n\\n\\t\\tdef query(self, left, right, a):\\n\\t\\t\\ti = bisect.bisect(self.count[a], left - 1)\\n\\t\\t\\tj = bisect.bisect(self.count[a], right)\\n\\t\\t\\treturn j - i",
                "solutionTags": [],
                "code": "\\tclass RangeFreqQuery:\\n\\n\\t\\tdef __init__(self, A):\\n\\t\\t\\tself.count = collections.defaultdict(list)\\n\\t\\t\\tfor i, a in enumerate(A):\\n\\t\\t\\t\\tself.count[a].append(i)\\n\\n\\t\\tdef query(self, left, right, a):\\n\\t\\t\\ti = bisect.bisect(self.count[a], left - 1)\\n\\t\\t\\tj = bisect.bisect(self.count[a], right)\\n\\t\\t\\treturn j - i",
                "codeTag": "Java"
            },
            {
                "id": 2665742,
                "title": "c-segment-tree",
                "content": "```\\nclass RangeFreqQuery {\\npublic:\\n    vector<map<int, int >> seg ;\\n    int len; \\n    map<int, int > build(int ind, int low,  int high , vector<int>&arr )\\n    {\\n        if(low==high )\\n        {\\n            map<int, int > m  ; \\n            m[arr[low]]=1 ; \\n            seg[ind] = m ; \\n            return m ;   \\n        }\\n        int mid = (low+high)/2 ; \\n       map<int, int >left =  build(2*ind+1, low , mid , arr ) ; \\n        map<int , int > right = build(2*ind+2 , mid+1, high , arr )  ; \\n        \\n        for(auto it: left) \\n        {\\n        \\n                right[it.first]+=it.second ;\\n        }\\n        seg[ind]= right ; \\n        return right ;\\n    }\\n    \\n      int query(int ind, int low, int high , int l , int r ,  int val)\\n        {\\n          // no overlap\\n          // l r low high or low high l r \\n          if(r<low || high<l )\\n          return  0 ; \\n\\n        // complete overlap\\n        // l low high r \\n        if(low>=l && high<=r)\\n        return seg[ind][val] ; \\n\\n        // partial overlap\\n        int mid =low+ (high-low)/2; \\n        int left  =query(2*ind+1 , low , mid ,l ,r ,val ) ; \\n        int right= query(2*ind+2 , mid+1, high , l, r , val ) ; \\n        return  left+right ; \\n\\n        }\\n    \\n    \\n    \\n    \\n    RangeFreqQuery(vector<int>& arr) {\\n         len = arr.size() ; \\n        seg.resize(4*len+1); \\n        \\n        build(0 , 0 , len-1  , arr  ) ;\\n    }\\n    \\n    int query(int left, int right, int value) {\\n        \\n    return query(0 , 0 , len-1  , left ,right , value  ) ;   \\n    }\\n};\\n\\n/**\\n * Your RangeFreqQuery object will be instantiated and called as such:\\n * RangeFreqQuery* obj = new RangeFreqQuery(arr);\\n * int param_1 = obj->query(left,right,value);\\n */\\n```",
                "solutionTags": [
                    "C",
                    "Tree"
                ],
                "code": "```\\nclass RangeFreqQuery {\\npublic:\\n    vector<map<int, int >> seg ;\\n    int len; \\n    map<int, int > build(int ind, int low,  int high , vector<int>&arr )\\n    {\\n        if(low==high )\\n        {\\n            map<int, int > m  ; \\n            m[arr[low]]=1 ; \\n            seg[ind] = m ; \\n            return m ;   \\n        }\\n        int mid = (low+high)/2 ; \\n       map<int, int >left =  build(2*ind+1, low , mid , arr ) ; \\n        map<int , int > right = build(2*ind+2 , mid+1, high , arr )  ; \\n        \\n        for(auto it: left) \\n        {\\n        \\n                right[it.first]+=it.second ;\\n        }\\n        seg[ind]= right ; \\n        return right ;\\n    }\\n    \\n      int query(int ind, int low, int high , int l , int r ,  int val)\\n        {\\n          // no overlap\\n          // l r low high or low high l r \\n          if(r<low || high<l )\\n          return  0 ; \\n\\n        // complete overlap\\n        // l low high r \\n        if(low>=l && high<=r)\\n        return seg[ind][val] ; \\n\\n        // partial overlap\\n        int mid =low+ (high-low)/2; \\n        int left  =query(2*ind+1 , low , mid ,l ,r ,val ) ; \\n        int right= query(2*ind+2 , mid+1, high , l, r , val ) ; \\n        return  left+right ; \\n\\n        }\\n    \\n    \\n    \\n    \\n    RangeFreqQuery(vector<int>& arr) {\\n         len = arr.size() ; \\n        seg.resize(4*len+1); \\n        \\n        build(0 , 0 , len-1  , arr  ) ;\\n    }\\n    \\n    int query(int left, int right, int value) {\\n        \\n    return query(0 , 0 , len-1  , left ,right , value  ) ;   \\n    }\\n};\\n\\n/**\\n * Your RangeFreqQuery object will be instantiated and called as such:\\n * RangeFreqQuery* obj = new RangeFreqQuery(arr);\\n * int param_1 = obj->query(left,right,value);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2651131,
                "title": "rust-solution-using-binary-search",
                "content": "```\\nuse std::collections::*;\\n\\ntype Target = usize;\\ntype UseValue = usize;\\nfn lower_bound(arr: &Vec<Target>, x: &UseValue) -> usize {\\n    let mut low = 0;\\n    let mut high = arr.len();\\n    while low != high {\\n        let mid = (low + high) / 2;\\n        // NEEDS TO EDIT\\n        match arr[mid].cmp(x) {\\n            std::cmp::Ordering::Less => {\\n                low = mid + 1;\\n            }\\n            std::cmp::Ordering::Equal | std::cmp::Ordering::Greater => {\\n                high = mid;\\n            }\\n        }\\n    }\\n    low\\n}\\n\\nstruct RangeFreqQuery {\\n    map:HashMap<i32, Vec<usize>>\\n}\\n\\nimpl RangeFreqQuery {\\n    fn new(arr: Vec<i32>) -> Self {\\n        let mut map = HashMap::new();\\n        for i in 0..arr.len() {\\n            map.entry(arr[i]).or_insert(vec![]).push(i);\\n        }\\n        RangeFreqQuery { map }\\n    }\\n    \\n    fn query(&self, left: i32, right: i32, value: i32) -> i32 {\\n        let l = left as usize;\\n        let r = right as usize;\\n        if let Some(arr) = self.map.get(&value) {\\n            let ri = lower_bound(arr, &r);\\n            let ri = if r < arr[0] {\\n                return 0\\n            } else if arr.len() == ri {\\n                ri\\n            } else if arr[ri] == r {\\n                ri + 1\\n            } else {\\n                ri\\n            };\\n\\n            let li = lower_bound(arr, &l);\\n            if l < arr[0] {\\n                ri as i32\\n            } else if arr.len() == li {\\n                0\\n            } else if arr[li] == l {\\n                (ri - li) as i32\\n            } else {\\n                (ri - li) as i32\\n            }\\n        } else {\\n            0\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Binary Tree"
                ],
                "code": "```\\nuse std::collections::*;\\n\\ntype Target = usize;\\ntype UseValue = usize;\\nfn lower_bound(arr: &Vec<Target>, x: &UseValue) -> usize {\\n    let mut low = 0;\\n    let mut high = arr.len();\\n    while low != high {\\n        let mid = (low + high) / 2;\\n        // NEEDS TO EDIT\\n        match arr[mid].cmp(x) {\\n            std::cmp::Ordering::Less => {\\n                low = mid + 1;\\n            }\\n            std::cmp::Ordering::Equal | std::cmp::Ordering::Greater => {\\n                high = mid;\\n            }\\n        }\\n    }\\n    low\\n}\\n\\nstruct RangeFreqQuery {\\n    map:HashMap<i32, Vec<usize>>\\n}\\n\\nimpl RangeFreqQuery {\\n    fn new(arr: Vec<i32>) -> Self {\\n        let mut map = HashMap::new();\\n        for i in 0..arr.len() {\\n            map.entry(arr[i]).or_insert(vec![]).push(i);\\n        }\\n        RangeFreqQuery { map }\\n    }\\n    \\n    fn query(&self, left: i32, right: i32, value: i32) -> i32 {\\n        let l = left as usize;\\n        let r = right as usize;\\n        if let Some(arr) = self.map.get(&value) {\\n            let ri = lower_bound(arr, &r);\\n            let ri = if r < arr[0] {\\n                return 0\\n            } else if arr.len() == ri {\\n                ri\\n            } else if arr[ri] == r {\\n                ri + 1\\n            } else {\\n                ri\\n            };\\n\\n            let li = lower_bound(arr, &l);\\n            if l < arr[0] {\\n                ri as i32\\n            } else if arr.len() == li {\\n                0\\n            } else if arr[li] == l {\\n                (ri - li) as i32\\n            } else {\\n                (ri - li) as i32\\n            }\\n        } else {\\n            0\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2642519,
                "title": "python-simple-hashing-binary-search-solution-beats-98",
                "content": "```\\nclass RangeFreqQuery:\\n\\n    def __init__(self, arr: List[int]):\\n        self.valToIndexHash = defaultdict(list)\\n        for idx, num in enumerate(arr):\\n            self.valToIndexHash[num].append(idx)\\n\\n    def query(self, left: int, right: int, value: int) -> int:\\n        if value in self.valToIndexHash:\\n            left = bisect_left(self.valToIndexHash[value], left)\\n            right = bisect_right(self.valToIndexHash[value], right)\\n            return right - left\\n        return 0\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Search"
                ],
                "code": "```\\nclass RangeFreqQuery:\\n\\n    def __init__(self, arr: List[int]):\\n        self.valToIndexHash = defaultdict(list)\\n        for idx, num in enumerate(arr):\\n            self.valToIndexHash[num].append(idx)\\n\\n    def query(self, left: int, right: int, value: int) -> int:\\n        if value in self.valToIndexHash:\\n            left = bisect_left(self.valToIndexHash[value], left)\\n            right = bisect_right(self.valToIndexHash[value], right)\\n            return right - left\\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2617491,
                "title": "easy-to-understand",
                "content": "```\\nclass RangeFreqQuery {\\npublic:\\n    RangeFreqQuery(vector<int>& arr) \\n    {\\n        for(int i=0; i<arr.size(); ++i)\\n        {\\n            num_to_pos[arr[i]].push_back(i);\\n        }\\n    }\\n    \\n    int query(int left, int right, int value) \\n    {\\n        auto& occ = num_to_pos[value];\\n        if(occ.empty())\\n        {\\n            return 0;\\n        }\\n        auto left_it = std::lower_bound(occ.begin(), occ.end(), left);\\n        if(left_it == occ.end())\\n        {\\n            return 0;\\n        }\\n        auto right_it = std::lower_bound(left_it, occ.end(), right);\\n        return (right_it - left_it) + (right_it != occ.end() ? *right_it == right : 0);\\n    }\\nprivate:\\n    unordered_map<int, vector<int>> num_to_pos;\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass RangeFreqQuery {\\npublic:\\n    RangeFreqQuery(vector<int>& arr) \\n    {\\n        for(int i=0; i<arr.size(); ++i)\\n        {\\n            num_to_pos[arr[i]].push_back(i);\\n        }\\n    }\\n    \\n    int query(int left, int right, int value) \\n    {\\n        auto& occ = num_to_pos[value];\\n        if(occ.empty())\\n        {\\n            return 0;\\n        }\\n        auto left_it = std::lower_bound(occ.begin(), occ.end(), left);\\n        if(left_it == occ.end())\\n        {\\n            return 0;\\n        }\\n        auto right_it = std::lower_bound(left_it, occ.end(), right);\\n        return (right_it - left_it) + (right_it != occ.end() ? *right_it == right : 0);\\n    }\\nprivate:\\n    unordered_map<int, vector<int>> num_to_pos;\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1921776,
                "content": [
                    {
                        "username": "itsgosho",
                        "content": "Excellent problem to implement your first segment tree."
                    },
                    {
                        "username": "TKR_6",
                        "content": "Forever TLE !\\n"
                    }
                ]
            },
            {
                "id": 1883181,
                "content": [
                    {
                        "username": "itsgosho",
                        "content": "Excellent problem to implement your first segment tree."
                    },
                    {
                        "username": "TKR_6",
                        "content": "Forever TLE !\\n"
                    }
                ]
            }
        ]
    },
    {
        "title": "Sum of k-Mirror Numbers",
        "question_content": "<p>A <strong>k-mirror number</strong> is a <strong>positive</strong> integer <strong>without leading zeros</strong> that reads the same both forward and backward in base-10 <strong>as well as</strong> in base-k.</p>\n\n<ul>\n\t<li>For example, <code>9</code> is a 2-mirror number. The representation of <code>9</code> in base-10 and base-2 are <code>9</code> and <code>1001</code> respectively, which read the same both forward and backward.</li>\n\t<li>On the contrary, <code>4</code> is not a 2-mirror number. The representation of <code>4</code> in base-2 is <code>100</code>, which does not read the same both forward and backward.</li>\n</ul>\n\n<p>Given the base <code>k</code> and the number <code>n</code>, return <em>the <strong>sum</strong> of the</em> <code>n</code> <em><strong>smallest</strong> k-mirror numbers</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> k = 2, n = 5\n<strong>Output:</strong> 25\n<strong>Explanation:\n</strong>The 5 smallest 2-mirror numbers and their representations in base-2 are listed as follows:\n  base-10    base-2\n    1          1\n    3          11\n    5          101\n    7          111\n    9          1001\nTheir sum = 1 + 3 + 5 + 7 + 9 = 25. \n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> k = 3, n = 7\n<strong>Output:</strong> 499\n<strong>Explanation:\n</strong>The 7 smallest 3-mirror numbers are and their representations in base-3 are listed as follows:\n  base-10    base-3\n    1          1\n    2          2\n    4          11\n    8          22\n    121        11111\n    151        12121\n    212        21212\nTheir sum = 1 + 2 + 4 + 8 + 121 + 151 + 212 = 499.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> k = 7, n = 17\n<strong>Output:</strong> 20379000\n<strong>Explanation:</strong> The 17 smallest 7-mirror numbers are:\n1, 2, 3, 4, 5, 6, 8, 121, 171, 242, 292, 16561, 65656, 2137312, 4602064, 6597956, 6958596\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= k &lt;= 9</code></li>\n\t<li><code>1 &lt;= n &lt;= 30</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 1589048,
                "title": "python3-enumerate-k-symmetric-numbers",
                "content": "Please check out this [commit](https://github.com/gaosanyong/leetcode/commit/b5ca73e6f7d317e9f30f7e67a499b0bf489ec019) for the solutions of weekly 268. \\n\\n```\\nclass Solution:\\n    def kMirror(self, k: int, n: int) -> int:\\n        \\n        def fn(x):\\n            \"\"\"Return next k-symmetric number.\"\"\"\\n            n = len(x)//2\\n            for i in range(n, len(x)): \\n                if int(x[i])+1 < k: \\n                    x[i] = x[~i] = str(int(x[i])+1)\\n                    for ii in range(n, i): x[ii] = x[~ii] = \\'0\\'\\n                    return x\\n            return [\"1\"] + [\"0\"]*(len(x)-1) + [\"1\"]\\n                \\n        x = [\"0\"]\\n        ans = 0\\n        for _ in range(n): \\n            while True: \\n                x = fn(x)\\n                val = int(\"\".join(x), k)\\n                if str(val)[::-1] == str(val): break\\n            ans += val\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def kMirror(self, k: int, n: int) -> int:\\n        \\n        def fn(x):\\n            \"\"\"Return next k-symmetric number.\"\"\"\\n            n = len(x)//2\\n            for i in range(n, len(x)): \\n                if int(x[i])+1 < k: \\n                    x[i] = x[~i] = str(int(x[i])+1)\\n                    for ii in range(n, i): x[ii] = x[~ii] = \\'0\\'\\n                    return x\\n            return [\"1\"] + [\"0\"]*(len(x)-1) + [\"1\"]\\n                \\n        x = [\"0\"]\\n        ans = 0\\n        for _ in range(n): \\n            while True: \\n                x = fn(x)\\n                val = int(\"\".join(x), k)\\n                if str(val)[::-1] == str(val): break\\n            ans += val\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1589104,
                "title": "brute-force",
                "content": "This is brute-force: we generate mirrored base-k numbers by adding the same digit to the left and right of the previously generated ones. For each mirrored number, we convert it to base-10 and check if it is also mirrored.\\n\\nMy thinking was that we will need to generate less base-k palindromes than base-10 ones. However, for base-k we need to store palindromes as strings (32-bit integers in base-2 can have up to 31 digits).\\n\\nI also tried to do it in the opposite way - generate base-10 mirrored numbers, and convert them to base-k. This way, we can use integers to store mirrored numbers, and the solution is ~5 times faster.\\n\\n> Based on my experiments, we need to generate a similar number of palindromes - about 700K - for base7 and base-10. So, the base-10 solution is faster because we store palindromes as integers.\\n\\n> Update: we can check if a number is base-k palindrome without converting it to a string. For that, we determine the position and value of the rigthmost digit, and compare it with leftmost digit. Then, we remove both digits and repeat till we \"eat\" the whole palindrome. With that, the runtime was improved to 70 ms.\\n\\n#### Solution 1: Generate base-10 numbers\\n**C++**\\n```cpp\\nvector<long long> mirror1{0}, mirror2{0};\\nlong long isMirror(long long num, int base) {\\n    long long mul = 1;\\n    while (mul * base <= num)\\n        mul *= base;\\n    for (; num; mul /= base * base) {\\n        if (num / mul != num % base)\\n            return false;\\n        num = (num - (num / mul) * mul - num % base) / base;\\n    }\\n    return true;\\n}\\nlong long generate(int dig, int n, int k, long long first_mul) {\\n    vector<long long> mirror;\\n    long long res = 0;\\n    for (int i = 0; n > 0 && i < 10; ++i)\\n        for (int j = 0; n > 0 && j < mirror1.size(); ++j) {\\n            mirror.push_back(first_mul * i + mirror1[j] * 10 + i); \\n            if (i != 0 && isMirror(mirror.back(), k)) {\\n                res += mirror.back();\\n                --n;\\n            }\\n        }\\n    swap(mirror1, mirror2);\\n    swap(mirror2, mirror);\\n    return res + (n == 0 ? 0 : generate(dig + 1, n, k, first_mul * 10));\\n}\\nlong long kMirror(int k, int n) {\\n    long long res = 0;\\n    for (int i = 1; n > 0 && i < 10; ++i) {\\n        mirror2.push_back(i);\\n        if (isMirror(i, k)) {\\n            res += i;\\n            --n;\\n        }\\n    }\\n    return res + generate(2, n, k, 10);\\n}\\n```\\n\\n#### Solution 2: Generate base-k numbers\\n**C++**\\n```cpp\\nvector<string> mirror1{\"\"}, mirror2;\\nlong long toBase10(string &num, int k) {\\n    long long res = 0;\\n    for (int i = 0; i < num.size(); ++i)\\n        res = res * k + (num[i] - \\'0\\');\\n    return res;\\n}\\nbool IsMirror(long long num) {\\n    auto s = to_string(num);\\n    for(int i = 0; i < s.size() / 2; ++i) {\\n        if (s[i] != s[s.size() - i - 1])\\n            return false;\\n    }\\n    return true;\\n}\\nlong long dfs(int dig, int n, int k) {\\n    vector<string> mirror;\\n    long long res = 0;\\n    if (n == 0)\\n        return 0;\\n    for (int i = 0; n > 0 && i < k; ++i) {\\n        for (int j = 0; n > 0 && j < mirror1.size(); ++j) {\\n            mirror.push_back(to_string(i) + mirror1[j] + to_string(i));    \\n            long long n10 = toBase10(mirror.back(), k);\\n            if (i != 0 && IsMirror(n10)) {\\n                res += n10;\\n                --n;\\n            }\\n        }\\n    }\\n    swap(mirror1, mirror2);\\n    swap(mirror2, mirror);\\n    return res + dfs(dig + 1, n, k);\\n}\\nlong long kMirror(int k, int n) {\\n    for (int i = 0; i < k; ++i)\\n        mirror2.push_back(to_string(i));\\n    return min(k - 1, n) * (min(k - 1, n) + 1) / 2 + dfs(2, n - min(k - 1, n), k);\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```cpp\\nvector<long long> mirror1{0}, mirror2{0};\\nlong long isMirror(long long num, int base) {\\n    long long mul = 1;\\n    while (mul * base <= num)\\n        mul *= base;\\n    for (; num; mul /= base * base) {\\n        if (num / mul != num % base)\\n            return false;\\n        num = (num - (num / mul) * mul - num % base) / base;\\n    }\\n    return true;\\n}\\nlong long generate(int dig, int n, int k, long long first_mul) {\\n    vector<long long> mirror;\\n    long long res = 0;\\n    for (int i = 0; n > 0 && i < 10; ++i)\\n        for (int j = 0; n > 0 && j < mirror1.size(); ++j) {\\n            mirror.push_back(first_mul * i + mirror1[j] * 10 + i); \\n            if (i != 0 && isMirror(mirror.back(), k)) {\\n                res += mirror.back();\\n                --n;\\n            }\\n        }\\n    swap(mirror1, mirror2);\\n    swap(mirror2, mirror);\\n    return res + (n == 0 ? 0 : generate(dig + 1, n, k, first_mul * 10));\\n}\\nlong long kMirror(int k, int n) {\\n    long long res = 0;\\n    for (int i = 1; n > 0 && i < 10; ++i) {\\n        mirror2.push_back(i);\\n        if (isMirror(i, k)) {\\n            res += i;\\n            --n;\\n        }\\n    }\\n    return res + generate(2, n, k, 10);\\n}\\n```\n```cpp\\nvector<string> mirror1{\"\"}, mirror2;\\nlong long toBase10(string &num, int k) {\\n    long long res = 0;\\n    for (int i = 0; i < num.size(); ++i)\\n        res = res * k + (num[i] - \\'0\\');\\n    return res;\\n}\\nbool IsMirror(long long num) {\\n    auto s = to_string(num);\\n    for(int i = 0; i < s.size() / 2; ++i) {\\n        if (s[i] != s[s.size() - i - 1])\\n            return false;\\n    }\\n    return true;\\n}\\nlong long dfs(int dig, int n, int k) {\\n    vector<string> mirror;\\n    long long res = 0;\\n    if (n == 0)\\n        return 0;\\n    for (int i = 0; n > 0 && i < k; ++i) {\\n        for (int j = 0; n > 0 && j < mirror1.size(); ++j) {\\n            mirror.push_back(to_string(i) + mirror1[j] + to_string(i));    \\n            long long n10 = toBase10(mirror.back(), k);\\n            if (i != 0 && IsMirror(n10)) {\\n                res += n10;\\n                --n;\\n            }\\n        }\\n    }\\n    swap(mirror1, mirror2);\\n    swap(mirror2, mirror);\\n    return res + dfs(dig + 1, n, k);\\n}\\nlong long kMirror(int k, int n) {\\n    for (int i = 0; i < k; ++i)\\n        mirror2.push_back(to_string(i));\\n    return min(k - 1, n) * (min(k - 1, n) + 1) / 2 + dfs(2, n - min(k - 1, n), k);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1589068,
                "title": "print-table-precalculate-o-1",
                "content": "You need a fast computer to do things this way:\\n```\\nclass Solution {\\npublic:\\n    vector<vector<long long>> a = vector<vector<long long>>(12);\\n    long long kMirror(int k, int n) {\\n        a[2] = {1,3,5,7,9,33,99,313,585,717,7447,9009,15351,32223,39993,53235,53835,73737,585585,1758571,1934391,1979791,3129213,5071705,5259525,5841485,13500531,719848917,910373019,939474939,1290880921};\\n        a[3] = {1,2,4,8,121,151,212,242,484,656,757,29092,48884,74647,75457,76267,92929,93739,848848,1521251,2985892,4022204,4219124,4251524,4287824,5737375,7875787,7949497,27711772,83155138,112969211};\\n        a[4] = {1,2,3,5,55,373,393,666,787,939,7997,53235,55255,55655,57675,506605,1801081,2215122,3826283,3866683,5051505,5226225,5259525,5297925,5614165,5679765,53822835,623010326,954656459,51717171715};\\n        \\n        a[5] = {1,2,3,4,6,88,252,282,626,676,1221,15751,18881,10088001,10400401,27711772,30322303,47633674,65977956,808656808,831333138,831868138,836131638,836181638,2512882152,2596886952,2893553982,6761551676,12114741121,12185058121};\\n        a[6] = {1,2,3,4,5,7,55,111,141,191,343,434,777,868,1441,7667,7777,22022,39893,74647,168861,808808,909909,1867681,3097903,4232324,4265624,4298924,4516154,4565654,4598954};\\n        a[7] = {1,2,3,4,5,6,8,121,171,242,292,16561,65656,2137312,4602064,6597956,6958596,9470749,61255216,230474032,466828664,485494584,638828836,657494756,858474858,25699499652,40130703104,45862226854,61454945416,64454545446};\\n        \\n        a[8] = {1,2,3,4,5,6,7,9,121,292,333,373,414,585,3663,8778,13131,13331,26462,26662,30103,30303,207702,628826,660066,1496941,1935391,1970791,4198914,55366355,130535031};\\n        a[9] = {1,2,3,4,5,6,7,8,191,282,373,464,555,646,656,6886,25752,27472,42324,50605,626626,1540451,1713171,1721271,1828281,1877781,1885881,2401042,2434342,2442442,2450542};\\n        long long ans = 0;\\n        for (int i = 0; i < n; i++) {\\n            ans += a[k][i];\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\\nCode to generate data:\\n```\\n\\n#include <bits/stdc++.h>\\n#include<ext/pb_ds/tree_policy.hpp>\\n#include<ext/pb_ds/assoc_container.hpp> \\n#include <stdio.h> \\n#include <math.h> \\n#include <vector>\\n#include <algorithm>\\nusing namespace std;\\nusing namespace __gnu_pbds;\\nusing namespace __gnu_cxx;\\nstruct Node {\\n    vector<Node*> next = vector<Node*>(2, NULL);\\n};\\nlong long M = 20;\\nbool mirror(long long ori10,long long k) {\\n    //prlong longf(\"%d \", ori10);\\n    \\n    long long y = ori10;\\n    long long orik = 0;\\n    long long revk = 0;\\n    long long p = 1;\\n    while (y != 0) {\\n        orik = orik + y%k * p;\\n        revk = revk * 10 + y%k;\\n        p *= 10;\\n        y = y/k;\\n    }\\n    if (orik != revk) return false;\\n\\n    long long x = ori10;\\n    long long rev10 = 0;\\n    while (x != 0) {\\n        rev10 = rev10 * 10 + x % 10;\\n        x = x/10;\\n    }\\n    if (ori10 != rev10) return false;\\n    return true;\\n}\\n\\nclass Solution {\\npublic:\\n   void calc() {\\n        long long n = 0;\\n        long long cur = 1;\\n        long long k;\\n        cin >> k;\\n        cin >> cur;\\n        while (n <= 30) {\\n            if (mirror(cur, k)) {\\n                cout << n << \" \" << cur <<\"\\\\n\";\\n                n++;\\n            }\\n            cur ++;\\n        }\\n   }\\n};\\nint main()\\n{\\n    Solution *solu = new Solution();\\n    \\n    solu->calc();\\n\\n    \\n\\n     return 0;\\n}\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<long long>> a = vector<vector<long long>>(12);\\n    long long kMirror(int k, int n) {\\n        a[2] = {1,3,5,7,9,33,99,313,585,717,7447,9009,15351,32223,39993,53235,53835,73737,585585,1758571,1934391,1979791,3129213,5071705,5259525,5841485,13500531,719848917,910373019,939474939,1290880921};\\n        a[3] = {1,2,4,8,121,151,212,242,484,656,757,29092,48884,74647,75457,76267,92929,93739,848848,1521251,2985892,4022204,4219124,4251524,4287824,5737375,7875787,7949497,27711772,83155138,112969211};\\n        a[4] = {1,2,3,5,55,373,393,666,787,939,7997,53235,55255,55655,57675,506605,1801081,2215122,3826283,3866683,5051505,5226225,5259525,5297925,5614165,5679765,53822835,623010326,954656459,51717171715};\\n        \\n        a[5] = {1,2,3,4,6,88,252,282,626,676,1221,15751,18881,10088001,10400401,27711772,30322303,47633674,65977956,808656808,831333138,831868138,836131638,836181638,2512882152,2596886952,2893553982,6761551676,12114741121,12185058121};\\n        a[6] = {1,2,3,4,5,7,55,111,141,191,343,434,777,868,1441,7667,7777,22022,39893,74647,168861,808808,909909,1867681,3097903,4232324,4265624,4298924,4516154,4565654,4598954};\\n        a[7] = {1,2,3,4,5,6,8,121,171,242,292,16561,65656,2137312,4602064,6597956,6958596,9470749,61255216,230474032,466828664,485494584,638828836,657494756,858474858,25699499652,40130703104,45862226854,61454945416,64454545446};\\n        \\n        a[8] = {1,2,3,4,5,6,7,9,121,292,333,373,414,585,3663,8778,13131,13331,26462,26662,30103,30303,207702,628826,660066,1496941,1935391,1970791,4198914,55366355,130535031};\\n        a[9] = {1,2,3,4,5,6,7,8,191,282,373,464,555,646,656,6886,25752,27472,42324,50605,626626,1540451,1713171,1721271,1828281,1877781,1885881,2401042,2434342,2442442,2450542};\\n        long long ans = 0;\\n        for (int i = 0; i < n; i++) {\\n            ans += a[k][i];\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1589683,
                "title": "c-enumerate-palindromes",
                "content": "Palindromes can be enumerated by reflecting a string on the last character or the end of string. For example,\\n\\nString | Generated palindromes\\n-- | --\\n1 | 1, 11\\n2 | 2, 22\\n13 | 131, 1331\\n123 | 12321, 123321\\n\\nNotice that the length of generated palindrome are `2*m - 1` and `2*m`, where `m` is the length of string. \\n\\nWe loop through the strings with same length in lexicographical order, and check all the generated palindromes that has odd number of digit, followed by that of even number of digit.\\n\\n**Complexity**\\nTime: `O(F(n))`, where `F(n)` represents the size of all palindrome numbers of base 10 smaller than `n`th k-mirror number.\\nMemory: `O(1)`.\\n\\n**Code**\\n```\\nclass Solution {\\npublic:\\n    long long get_palin_num(long long num, bool odd) {\\n        long long x = num;\\n        if (odd) x /= 10;\\n        \\n        while (x) {\\n            num = num * 10 + x % 10;\\n            x /= 10;\\n        }\\n        return num;\\n    }\\n    \\n    string to_base(long long num, int &base) {\\n        string res = \"\";\\n        while (num) {\\n            res += num % base + \\'0\\';\\n            num /= base;\\n        }\\n        return res;\\n    }\\n    \\n    bool is_palin(long long &num, int &base) {\\n        string s = to_base(num, base);\\n        int lo = 0, hi = s.size() - 1;\\n        while (lo < hi) {\\n            if (s[lo++] != s[hi--]) return false;\\n        }\\n        return true;\\n    }\\n    \\n    long long kMirror(int k, int n) {\\n        long long sum = 0, num = 0;\\n        for (long long num_digit=1; n; num_digit*=10) {\\n            // odd number of digits\\n            for (long long cur=num_digit; n && cur < num_digit*10; ++cur) {\\n                num = get_palin_num(cur, true);\\n                if (is_palin(num, k)) {\\n                    sum += num;\\n                    --n;\\n                }\\n            }\\n            // even number of digits\\n            for (long long cur=num_digit; n && cur < num_digit*10; ++cur) {\\n                num = get_palin_num(cur, false);\\n                if (is_palin(num, k)) {\\n                    sum += num;\\n                    --n;\\n                }\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Enumeration"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long get_palin_num(long long num, bool odd) {\\n        long long x = num;\\n        if (odd) x /= 10;\\n        \\n        while (x) {\\n            num = num * 10 + x % 10;\\n            x /= 10;\\n        }\\n        return num;\\n    }\\n    \\n    string to_base(long long num, int &base) {\\n        string res = \"\";\\n        while (num) {\\n            res += num % base + \\'0\\';\\n            num /= base;\\n        }\\n        return res;\\n    }\\n    \\n    bool is_palin(long long &num, int &base) {\\n        string s = to_base(num, base);\\n        int lo = 0, hi = s.size() - 1;\\n        while (lo < hi) {\\n            if (s[lo++] != s[hi--]) return false;\\n        }\\n        return true;\\n    }\\n    \\n    long long kMirror(int k, int n) {\\n        long long sum = 0, num = 0;\\n        for (long long num_digit=1; n; num_digit*=10) {\\n            // odd number of digits\\n            for (long long cur=num_digit; n && cur < num_digit*10; ++cur) {\\n                num = get_palin_num(cur, true);\\n                if (is_palin(num, k)) {\\n                    sum += num;\\n                    --n;\\n                }\\n            }\\n            // even number of digits\\n            for (long long cur=num_digit; n && cur < num_digit*10; ++cur) {\\n                num = get_palin_num(cur, false);\\n                if (is_palin(num, k)) {\\n                    sum += num;\\n                    --n;\\n                }\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1589016,
                "title": "java-backtrack",
                "content": "```\\nclass Solution {\\n    public long kMirror(int k, int n) {\\n        int len = 1;\\n        List<Long> res = new ArrayList<>();\\n        while(res.size() < n){\\n            char[] arr = new char[len];    \\n            dfs(arr, (k+\"\").charAt(0), 0, res);\\n            len++;\\n        }\\n        \\n        while(res.size() > n) res.remove(res.size() -1);\\n        long sum = 0;\\n        for(Long s: res) {\\n            sum += s;\\n        }\\n        return sum;\\n    }   \\n    \\n    \\n    void dfs(char[] arr, char k, int index, List<Long> res){\\n        if(index >= (arr.length+1)/2) {\\n            String s = new String(arr);\\n            long num10 = Long.parseLong(s, k-\\'0\\');\\n            String s10 = num10 +\"\";\\n            boolean valid = true;\\n            for(int left = 0, right = s10.length() -1; left < right; left++,right--){\\n                if(s10.charAt(left) != s10.charAt(right)) {\\n                    valid = false;\\n                    break;\\n                }\\n            }\\n            if(valid) res.add(num10);\\n            return ;\\n        }\\n        for(char i = \\'0\\'; i < k; i++){\\n            if(index == 0 && i == \\'0\\') continue;\\n            arr[index] = i;\\n            arr[arr.length -1 - index] = i;\\n            dfs(arr, k, index+1, res);\\n        }\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public long kMirror(int k, int n) {\\n        int len = 1;\\n        List<Long> res = new ArrayList<>();\\n        while(res.size() < n){\\n            char[] arr = new char[len];    \\n            dfs(arr, (k+\"\").charAt(0), 0, res);\\n            len++;\\n        }\\n        \\n        while(res.size() > n) res.remove(res.size() -1);\\n        long sum = 0;\\n        for(Long s: res) {\\n            sum += s;\\n        }\\n        return sum;\\n    }   \\n    \\n    \\n    void dfs(char[] arr, char k, int index, List<Long> res){\\n        if(index >= (arr.length+1)/2) {\\n            String s = new String(arr);\\n            long num10 = Long.parseLong(s, k-\\'0\\');\\n            String s10 = num10 +\"\";\\n            boolean valid = true;\\n            for(int left = 0, right = s10.length() -1; left < right; left++,right--){\\n                if(s10.charAt(left) != s10.charAt(right)) {\\n                    valid = false;\\n                    break;\\n                }\\n            }\\n            if(valid) res.add(num10);\\n            return ;\\n        }\\n        for(char i = \\'0\\'; i < k; i++){\\n            if(index == 0 && i == \\'0\\') continue;\\n            arr[index] = i;\\n            arr[arr.length -1 - index] = i;\\n            dfs(arr, k, index+1, res);\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1590615,
                "title": "java-generate-k-based-palindromes-with-comments",
                "content": "##### Solution 1 - Brute force (TLE)\\n* Check each number from 1 to Long.MAX_VALUE\\n* TLE\\n\\n```\\nclass Solution {\\n    public long kMirror(int k, int n) {\\n        long res = 0;\\n        long cnt = 0;\\n        for (long i = 1; i < Long.MAX_VALUE; i++) {\\n            if (iskmirror(k,i) && iskmirror(10,i)) {\\n                res += i;\\n                cnt++;\\n                if (cnt == n) {\\n                    return res;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    boolean iskmirror(long k, long n) {\\n        long num = 0;\\n        long tmp = n;\\n        while (n != 0) {\\n            num = num * k + n % k;\\n            n = n / k;\\n        }\\n        return tmp == num;\\n    }\\n}\\n```\\n\\n##### Solution 2 - Generate all k-based palindromes (Accepted)\\n* Backtrack to generate all k-based palindromes and check if it\\'s 10-based mirror number\\n* Using String to check if a number is a palindrome will be faster than using long\\n* Store the generated numbers in each level including numbers with prevaling 0s (i.e. storing \"00\" to be used to generate \"1001\"). When you include the number as a result, exclude thoses numbers with prevaling 0s.\\n\\n\\n```\\nclass Solution {\\n    public long kMirror(int k, int n) {\\n        long res = 0;\\n        // Maintain 2 lists for odd-lenth numbers & even-length numbers\\n        List<String> list1 = new ArrayList<>(), list2 = new ArrayList<>();\\n        \\n        list1.add(\"\");\\n        list2.add(\"0\");\\n        for (int i = 1; i < k && n > 0; i++){\\n            list2.add(Integer.toString(i));\\n            res += i;\\n            n--;\\n        }     \\n        \\n        return res + constructMirrorNumbers(2, k, n, list1, list2);\\n    }\\n    \\n    long constructMirrorNumbers(int len, int k, int n, List<String> list1, List<String> list2) { \\n        // Found n smallest numbers\\n        if (n == 0)\\n            return 0;\\n        \\n        long res = 0;\\n        List<String> cur = new ArrayList<>();\\n        for (int i = 0; i < k && n > 0; i++) {\\n            // To construct numbers of length len, use list1 if len is even and list2 if len is odd\\n            List<String> list = len % 2 == 0 ? list1 : list2;\\n            for (int j = 0; j < list.size() && n > 0 ; j++) {\\n                String s = i + list.get(j) + i;\\n                cur.add(s);\\n                long num = Long.parseLong(s, k);\\n                // Not consider numbers with leading zeros\\n                if (i != 0 && isMirror(Long.toString(num))) {\\n                    n--;\\n                    res += num;\\n                }\\n            }\\n        }\\n        \\n        //replace the list with the current list\\n        if (len % 2 == 0) {\\n            list1 = cur;\\n        } else {\\n            list2 = cur;\\n        }\\n        \\n        return res + constructMirrorNumbers(len+1, k, n, list1, list2);\\n    }\\n    \\n    boolean isMirror(String s) {\\n        int len = s.length();\\n        int middle = len / 2 - 1;\\n        for (int i = 0; i <= middle; i++) {\\n            if (s.charAt(i) != s.charAt(len-1-i)) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long kMirror(int k, int n) {\\n        long res = 0;\\n        long cnt = 0;\\n        for (long i = 1; i < Long.MAX_VALUE; i++) {\\n            if (iskmirror(k,i) && iskmirror(10,i)) {\\n                res += i;\\n                cnt++;\\n                if (cnt == n) {\\n                    return res;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    boolean iskmirror(long k, long n) {\\n        long num = 0;\\n        long tmp = n;\\n        while (n != 0) {\\n            num = num * k + n % k;\\n            n = n / k;\\n        }\\n        return tmp == num;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public long kMirror(int k, int n) {\\n        long res = 0;\\n        // Maintain 2 lists for odd-lenth numbers & even-length numbers\\n        List<String> list1 = new ArrayList<>(), list2 = new ArrayList<>();\\n        \\n        list1.add(\"\");\\n        list2.add(\"0\");\\n        for (int i = 1; i < k && n > 0; i++){\\n            list2.add(Integer.toString(i));\\n            res += i;\\n            n--;\\n        }     \\n        \\n        return res + constructMirrorNumbers(2, k, n, list1, list2);\\n    }\\n    \\n    long constructMirrorNumbers(int len, int k, int n, List<String> list1, List<String> list2) { \\n        // Found n smallest numbers\\n        if (n == 0)\\n            return 0;\\n        \\n        long res = 0;\\n        List<String> cur = new ArrayList<>();\\n        for (int i = 0; i < k && n > 0; i++) {\\n            // To construct numbers of length len, use list1 if len is even and list2 if len is odd\\n            List<String> list = len % 2 == 0 ? list1 : list2;\\n            for (int j = 0; j < list.size() && n > 0 ; j++) {\\n                String s = i + list.get(j) + i;\\n                cur.add(s);\\n                long num = Long.parseLong(s, k);\\n                // Not consider numbers with leading zeros\\n                if (i != 0 && isMirror(Long.toString(num))) {\\n                    n--;\\n                    res += num;\\n                }\\n            }\\n        }\\n        \\n        //replace the list with the current list\\n        if (len % 2 == 0) {\\n            list1 = cur;\\n        } else {\\n            list2 = cur;\\n        }\\n        \\n        return res + constructMirrorNumbers(len+1, k, n, list1, list2);\\n    }\\n    \\n    boolean isMirror(String s) {\\n        int len = s.length();\\n        int middle = len / 2 - 1;\\n        for (int i = 0; i <= middle; i++) {\\n            if (s.charAt(i) != s.charAt(len-1-i)) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1589255,
                "title": "python3-easy-python-brute-force-with-comment",
                "content": "```python\\nclass Solution:\\n    def kMirror(self, k: int, n: int) -> int:\\n\\n        def numberToBase(n, b):\\n            if n == 0:\\n                return [0]\\n            digits = []\\n            while n:\\n                digits.append(n % b)\\n                n //= b\\n            return digits[::-1]\\n        \\n        # not used\\n        def baseToNumber(arr, b):\\n            ans = 0\\n            for x in arr:\\n                ans = ans * b + int(x)\\n            return ans\\n        \\n        def is_mirror(s):\\n            l, r = 0, len(s)-1\\n            while l <= r:\\n                if s[l] != s[r]:\\n                    return False\\n                l += 1\\n                r -= 1\\n            return True\\n        \\n        def gen():\\n            \\'\\'\\'\\n            generate for value with different length\\n            when i == 0: num\\uFF1A[1, 10)\\n            size of num: 1, 2 -> 1 or 11\\n            when i == 1: [10, 100)\\n            size of num: 3, 4 -> 10 or 101\\n            when i == 2: [100, 1000)\\n            size of num: 5, 6 -> 10001 or 100001\\n            \\n            the num will be increasing\\n            \\'\\'\\'\\n            for i in range(30):\\n                for num in range(10**i, 10**(i+1)):\\n                    s = str(num) + str(num)[::-1][1:]\\n                    yield int(s)\\n                for num in range(10**i, 10**(i+1)):\\n                    s = str(num) + str(num)[::-1]\\n                    yield int(s)\\n        \\n        ans = 0\\n        left = n\\n        for num in gen():\\n            base = numberToBase(num, k)\\n\\t\\t\\t# if is_mirror(base):\\n            if base == base[::-1]:\\n                ans += num\\n                left -= 1\\n            if left == 0:\\n                break\\n\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def kMirror(self, k: int, n: int) -> int:\\n\\n        def numberToBase(n, b):\\n            if n == 0:\\n                return [0]\\n            digits = []\\n            while n:\\n                digits.append(n % b)\\n                n //= b\\n            return digits[::-1]\\n        \\n        # not used\\n        def baseToNumber(arr, b):\\n            ans = 0\\n            for x in arr:\\n                ans = ans * b + int(x)\\n            return ans\\n        \\n        def is_mirror(s):\\n            l, r = 0, len(s)-1\\n            while l <= r:\\n                if s[l] != s[r]:\\n                    return False\\n                l += 1\\n                r -= 1\\n            return True\\n        \\n        def gen():\\n            \\'\\'\\'\\n            generate for value with different length\\n            when i == 0: num\\uFF1A[1, 10)\\n            size of num: 1, 2 -> 1 or 11\\n            when i == 1: [10, 100)\\n            size of num: 3, 4 -> 10 or 101\\n            when i == 2: [100, 1000)\\n            size of num: 5, 6 -> 10001 or 100001\\n            \\n            the num will be increasing\\n            \\'\\'\\'\\n            for i in range(30):\\n                for num in range(10**i, 10**(i+1)):\\n                    s = str(num) + str(num)[::-1][1:]\\n                    yield int(s)\\n                for num in range(10**i, 10**(i+1)):\\n                    s = str(num) + str(num)[::-1]\\n                    yield int(s)\\n        \\n        ans = 0\\n        left = n\\n        for num in gen():\\n            base = numberToBase(num, k)\\n\\t\\t\\t# if is_mirror(base):\\n            if base == base[::-1]:\\n                ans += num\\n                left -= 1\\n            if left == 0:\\n                break\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1590635,
                "title": "c-2081-sum-of-k-mirror-numbers",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    long long kMirror(int k, int n) {\\n        \\n        auto palin = [](int n, bool odd) {\\n            long long ans = n; \\n            if (odd) n /= 10; \\n            for (; n; n /= 10) ans = 10*ans + n % 10; \\n            return ans; \\n        }; \\n        \\n        auto is_mirror = [&](long long x) {\\n            long long rev = 0; \\n            for (auto tmp = x; tmp; tmp /= k) rev = k*rev + tmp % k; \\n            return x == rev; \\n        }; \\n        \\n        long long ans = 0, palin0 = 0, palin1 = 0; \\n        int odd = 1, even = 1; \\n        while (n--) {\\n            for (; true; ++odd) {\\n                palin1 = palin(odd, true); \\n                if (is_mirror(palin1)) break; \\n            }\\n            for (; palin0 < palin1; ++even) {\\n                palin0 = palin(even, false); \\n                if (is_mirror(palin0)) break; \\n            }\\n            if (palin0 < palin1) {\\n                ans += palin0; \\n                ++even; \\n            } else {\\n                ans += palin1; \\n                ++odd; \\n            }\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long kMirror(int k, int n) {\\n        \\n        auto palin = [](int n, bool odd) {\\n            long long ans = n; \\n            if (odd) n /= 10; \\n            for (; n; n /= 10) ans = 10*ans + n % 10; \\n            return ans; \\n        }; \\n        \\n        auto is_mirror = [&](long long x) {\\n            long long rev = 0; \\n            for (auto tmp = x; tmp; tmp /= k) rev = k*rev + tmp % k; \\n            return x == rev; \\n        }; \\n        \\n        long long ans = 0, palin0 = 0, palin1 = 0; \\n        int odd = 1, even = 1; \\n        while (n--) {\\n            for (; true; ++odd) {\\n                palin1 = palin(odd, true); \\n                if (is_mirror(palin1)) break; \\n            }\\n            for (; palin0 < palin1; ++even) {\\n                palin0 = palin(even, false); \\n                if (is_mirror(palin0)) break; \\n            }\\n            if (palin0 < palin1) {\\n                ans += palin0; \\n                ++even; \\n            } else {\\n                ans += palin1; \\n                ++odd; \\n            }\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1589770,
                "title": "comparison-between-generating-palindromes-with-base-k-vs-base-10",
                "content": "There are already posts explaining the solution. In this post, I\\'m just putting out the differences between using base 10 to generate palindromes, and using base k to generate palindromes. In both the approaches, palindromes are generated by using `long long` rather than `string`. You can find the code at the end - just click on `[C++] Code for reference` to show the code.\\n\\nI\\'m counting the number of palindrome numbers generated in each approach. The counts are for `n = 30` and `k = 2, 3, ..., 9`.\\n\\nHere are the results.\\n![image](https://assets.leetcode.com/users/images/aea4068a-a6ff-4875-8c09-5ac6a3975450_1637488402.9985316.png)\\n\\nAs we can see, for `k = 2, 4, 6, 7`, base k approach generated less number of palindromes while for `k = 3, 5, 8, 9`, base 10 approach generated less number of palindromes. But considering the totals, base k approach generated less number of palindromes on a whole. (For my C++ submissions, the runtimes are 216ms for base 10 and 124ms for base k)\\n\\nI have no clue why this is the case. Any explanations are welcome.\\n\\n<details><summary>[C++] Code for reference</summary>\\n\\nThe following is the code for the base 10 approach.\\n```\\nclass Solution {\\n    int base;\\n    \\n    long long getPalindromeNumber(long long seed, bool isOdd) {\\n        long long num = seed;\\n        if (isOdd) {\\n            seed /= 10;\\n        }\\n        while (seed) {\\n            num = num * 10 + (seed % 10);\\n            seed /= 10;\\n        }\\n        return num;\\n    }\\n    \\n    bool isBaseKPalindrome(long long num) {\\n        long long seed = num, reversed = 0;\\n        while (seed) {\\n            reversed = reversed * base + (seed % base);\\n            seed /= base;\\n        }\\n        return num == reversed;\\n    }\\n    \\npublic:\\n    long long kMirror(int k, int n) {\\n        base = k;\\n        \\n        long long out = 0, cnt = 0;\\n        \\n        long long start = 1, end = 10;\\n        long long seed, num;\\n        while (n) {\\n            for (bool isOdd : {true, false}) {\\n                for (seed = start; seed < end && n; ++seed) {\\n                    num = getPalindromeNumber(seed, isOdd);\\n                    if (isBaseKPalindrome(num)) {\\n                        out += num;\\n                        --n;\\n                    }\\n                    ++cnt;\\n                }\\n            }\\n            start = end;\\n            end *= 10;\\n        }\\n        \\n        std::cout << cnt << std::endl;\\n        \\n        return out;\\n    }\\n};\\n```\\n\\nBase k approach is the same code with base values of `10` and `k` flipped in the corresponding places. The following image shows the diff between the codes of the two approaches.\\n![image](https://assets.leetcode.com/users/images/14a27f21-f9a0-4340-a088-29c3ad0b1dce_1637490847.4063296.png)\\n\\n</details>",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int base;\\n    \\n    long long getPalindromeNumber(long long seed, bool isOdd) {\\n        long long num = seed;\\n        if (isOdd) {\\n            seed /= 10;\\n        }\\n        while (seed) {\\n            num = num * 10 + (seed % 10);\\n            seed /= 10;\\n        }\\n        return num;\\n    }\\n    \\n    bool isBaseKPalindrome(long long num) {\\n        long long seed = num, reversed = 0;\\n        while (seed) {\\n            reversed = reversed * base + (seed % base);\\n            seed /= base;\\n        }\\n        return num == reversed;\\n    }\\n    \\npublic:\\n    long long kMirror(int k, int n) {\\n        base = k;\\n        \\n        long long out = 0, cnt = 0;\\n        \\n        long long start = 1, end = 10;\\n        long long seed, num;\\n        while (n) {\\n            for (bool isOdd : {true, false}) {\\n                for (seed = start; seed < end && n; ++seed) {\\n                    num = getPalindromeNumber(seed, isOdd);\\n                    if (isBaseKPalindrome(num)) {\\n                        out += num;\\n                        --n;\\n                    }\\n                    ++cnt;\\n                }\\n            }\\n            start = end;\\n            end *= 10;\\n        }\\n        \\n        std::cout << cnt << std::endl;\\n        \\n        return out;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1589045,
                "title": "python3-try-all-base10-palindromes-with-base-k-with-explanation",
                "content": "The first key observation is mirror numbers are literally just palindromes. \\n\\nIf we attempt every integer 1,2,...,Z (where Z is some integer), then we will clearly TLE.\\n\\nTherefore, we can severely minimize our search by figuring out with pinpoint precision which integers are palindromes. Then, with every palindrome integer, we check if the base k equivalent is also a palindrome. If so, add the base10 palindrome to our res until we found n of them.\\n\\nTo figure out the first R palindromes (R is an arbitrary number), we would start off with palindromes of length 1, then 2, then 3, ..., so on and so forth. Let\\'s talk about constructing them.\\n\\nPalindromes:\\nlength 1: 1,2,3,4,5,6,7,8,9\\nlength 2: 11,22,33,...,88,99\\n\\nLength k where k >2:\\nFor each digit in [1,2,3,...,9] = D, we can construct the next palindromes by first taking a digit d in D, making a new number by starting it and ending it with d, then for each past result of length k-2 (going lowest to greatest), smash those palindromes between the 2 d\\'s. Keep in mind now however, in k = 1, k=2, we ommited 0, but now we must include them since they\\'ll also lead to palindromes.\\n\\nPutting it all together, we get the following code:\\n\\n```\\nclass Solution:\\n    def kMirror(self, k: int, n: int) -> int:\\n        def toBaseB(a,b):\\n            if a == 0:\\n                return \"0\"\\n            d = []\\n            while a:\\n                d.append(str(a%b))\\n                a//=b\\n            return \\'\\'.join(d[::-1])\\n\\n        @cache\\n        def F(d,zero):\\n            if d == 0:\\n                return []\\n            if d == 1:\\n                return [str(i) for i in range(10)] if zero else [str(i) for i in range(1,10)]\\n            elif d == 2:\\n                res = [str(i) for i in range(11,100, 11)] \\n                if zero:\\n                    res = [\"00\"] + res\\n                return res\\n            else:\\n                combos = []\\n                choices = [str(i) for i in range(10)] if zero else [str(i) for i in range(1,10)]\\n                for c in choices:\\n                    for mid in F(d-2, True):\\n                        combos.append(\"{}{}{}\".format(c,mid,c))\\n                return combos\\n        d = 1\\n        res = 0\\n        while n:\\n            for a in F(d,False):\\n                if n == 0:\\n                    return res\\n                try_ = toBaseB(int(a), k)\\n                if try_[::-1] == try_:\\n                    res += int(a)\\n                    n -= 1\\n            d += 1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def kMirror(self, k: int, n: int) -> int:\\n        def toBaseB(a,b):\\n            if a == 0:\\n                return \"0\"\\n            d = []\\n            while a:\\n                d.append(str(a%b))\\n                a//=b\\n            return \\'\\'.join(d[::-1])\\n\\n        @cache\\n        def F(d,zero):\\n            if d == 0:\\n                return []\\n            if d == 1:\\n                return [str(i) for i in range(10)] if zero else [str(i) for i in range(1,10)]\\n            elif d == 2:\\n                res = [str(i) for i in range(11,100, 11)] \\n                if zero:\\n                    res = [\"00\"] + res\\n                return res\\n            else:\\n                combos = []\\n                choices = [str(i) for i in range(10)] if zero else [str(i) for i in range(1,10)]\\n                for c in choices:\\n                    for mid in F(d-2, True):\\n                        combos.append(\"{}{}{}\".format(c,mid,c))\\n                return combos\\n        d = 1\\n        res = 0\\n        while n:\\n            for a in F(d,False):\\n                if n == 0:\\n                    return res\\n                try_ = toBaseB(int(a), k)\\n                if try_[::-1] == try_:\\n                    res += int(a)\\n                    n -= 1\\n            d += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1897595,
                "title": "sum-of-k-mirror-number",
                "content": "**Easy to understand solution **\\n\\n```\\nclass Solution {\\n  \\nprivate:\\n  bool isPalindrome(string s){\\n\\tint n = s.size();\\n\\tfor(int i =0;  i <= n/2 ; i++){\\n\\t\\tif(s[i] != s[n-i-1]){\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t}\\n   \\n return true;\\n}\\n  \\nprivate:\\n  string base_converter(long long num,  int &k){\\n    string res=\"\";\\n    while(num!=0){\\n      res+= (char)((num%k) + \\'0\\');\\n      num = num/k;\\n    }\\n    return res;\\n}\\n  \\nprivate:\\n long long generate_all(long long num , bool odd)\\n {\\n   \\n\\tlong long dupnum = num;\\n\\tif(odd) dupnum = dupnum/10;\\n\\twhile(dupnum != 0 ){\\n\\t\\tnum = (num*10) + (dupnum%10);\\n\\t\\tdupnum = dupnum/10;\\n\\t}\\n\\treturn num;\\n }\\npublic:\\n \\n    long long kMirror(int k, int n) {\\n       \\n long long sum =0;\\n        for(int i = 1 ;n ; i = i * 10){\\n\\n\\t\\t// odd number generate\\n\\n\\t\\tfor(int j = i ; j < i*10 && n; j++){\\n            \\n\\n            long long  num = generate_all(j , true);\\n\\n            string res = base_converter(num , k);\\n            if(isPalindrome(res)){\\n            \\tsum+=num;\\n            \\tn--;\\n            }\\n\\n\\t\\t}\\n\\t\\t// even number generate\\n\\t\\tfor(int j = i; j <  i * 10 && n; j++){\\n           \\n            long long  num = generate_all(j , false);\\n\\n            string res = base_converter(num , k);\\n            if(isPalindrome(res)){\\n            \\tsum+=num;\\n            \\tn--;\\n            }\\n\\t\\t}\\n\\t}\\n     return sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n  \\nprivate:\\n  bool isPalindrome(string s){\\n\\tint n = s.size();\\n\\tfor(int i =0;  i <= n/2 ; i++){\\n\\t\\tif(s[i] != s[n-i-1]){\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t}\\n   \\n return true;\\n}\\n  \\nprivate:\\n  string base_converter(long long num,  int &k){\\n    string res=\"\";\\n    while(num!=0){\\n      res+= (char)((num%k) + \\'0\\');\\n      num = num/k;\\n    }\\n    return res;\\n}\\n  \\nprivate:\\n long long generate_all(long long num , bool odd)\\n {\\n   \\n\\tlong long dupnum = num;\\n\\tif(odd) dupnum = dupnum/10;\\n\\twhile(dupnum != 0 ){\\n\\t\\tnum = (num*10) + (dupnum%10);\\n\\t\\tdupnum = dupnum/10;\\n\\t}\\n\\treturn num;\\n }\\npublic:\\n \\n    long long kMirror(int k, int n) {\\n       \\n long long sum =0;\\n        for(int i = 1 ;n ; i = i * 10){\\n\\n\\t\\t// odd number generate\\n\\n\\t\\tfor(int j = i ; j < i*10 && n; j++){\\n            \\n\\n            long long  num = generate_all(j , true);\\n\\n            string res = base_converter(num , k);\\n            if(isPalindrome(res)){\\n            \\tsum+=num;\\n            \\tn--;\\n            }\\n\\n\\t\\t}\\n\\t\\t// even number generate\\n\\t\\tfor(int j = i; j <  i * 10 && n; j++){\\n           \\n            long long  num = generate_all(j , false);\\n\\n            string res = base_converter(num , k);\\n            if(isPalindrome(res)){\\n            \\tsum+=num;\\n            \\tn--;\\n            }\\n\\t\\t}\\n\\t}\\n     return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1599992,
                "title": "python-clean-and-elegant-generator-based-solution",
                "content": "```\\nfrom itertools import islice, count\\n\\nclass Solution:\\n    def kMirror(self, k: int, N: int) -> int:\\n        return sum(islice((n for n in mirror10() if iskm(n, k)), N)) # islice(seq, n) is just like seq[:n], but works for Iterator\\n\\ndef mirror10(): # generator for base-10 mirror numbers\\n    yield from range(1, 10)\\n    for l in count(start=1): # i.e. range(1, inf)\\n        for n in range(10**(l - 1), 10**l): # e.g. n = 10 to 99 when l = 2\\n            yield int(str(n) + str(n)[::-1]) # e.g. 12 21\\n        for n in range(10**(l - 1), 10**l):\\n            yield from (int(str(n) + str(t) + str(n)[::-1]) for t in range(10))  # e.g. 12 0 21\\n                \\ndef iskm(n, k): # True iff n is a k-mirror number\\n    digits = []\\n    while n > 0:\\n        n, r = divmod(n, k)\\n        digits.append(r)\\n    return digits == digits[::-1]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom itertools import islice, count\\n\\nclass Solution:\\n    def kMirror(self, k: int, N: int) -> int:\\n        return sum(islice((n for n in mirror10() if iskm(n, k)), N)) # islice(seq, n) is just like seq[:n], but works for Iterator\\n\\ndef mirror10(): # generator for base-10 mirror numbers\\n    yield from range(1, 10)\\n    for l in count(start=1): # i.e. range(1, inf)\\n        for n in range(10**(l - 1), 10**l): # e.g. n = 10 to 99 when l = 2\\n            yield int(str(n) + str(n)[::-1]) # e.g. 12 21\\n        for n in range(10**(l - 1), 10**l):\\n            yield from (int(str(n) + str(t) + str(n)[::-1]) for t in range(10))  # e.g. 12 0 21\\n                \\ndef iskm(n, k): # True iff n is a k-mirror number\\n    digits = []\\n    while n > 0:\\n        n, r = divmod(n, k)\\n        digits.append(r)\\n    return digits == digits[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1589370,
                "title": "c-solution-generate-palindromes-in-order-with-explanation-note-to-string-is-slow",
                "content": "Note:\\n1. to_string is slow, change string operations to integer operations speed up more than 10 times\\n2. prevent recalculation\\n\\nIdea:\\n1. \"check\" is used to check whether \"c\" is a palindrome in base \"k\"\\n2. Start from 1 to 10\\n3. Then 11,22,33,44,55,66,77,88,99 (the single for loop in while)\\n4. Then 101,111,......,191 (the double for loop in while)\\n202,212,......,292\\n303,313,......,393\\n404,414,......,494\\n505,515,......,595\\n606,616,......,696\\n707,717,......,797\\n808,818,......,898\\n909,919,......,999\\n5. generate palindrome with increasing number of digits\\n6. each while loop deals with 2 digits\\n```\\nclass Solution \\n{\\n    public:\\n    bool check(long long c,int k)\\n    {\\n        string s;\\n        while(c)\\n        {\\n            s+=(char)(c%k+\\'0\\'); // change to_string to this speed up more than 10 times\\n            c/=k;\\n        }\\n        // check if s is palindrome\\n        int p1=0,p2=(int)s.length()-1;\\n        while(p1<p2)\\n            if(s[p1++]!=s[p2--])\\n                return false;\\n        \\n        return true;\\n    }\\n    long long kMirror(int k, int n) \\n    {\\n        long long result=0,c=0;\\n        for(int i=1;i<10;i++) // 1,2,......,9\\n        {\\n            if(check(i,k)) // if single digit in base 10 is also palindromes in base k\\n            {\\n                result+=i;\\n                if(--n==0) return result;\\n            }\\n        }\\n        while(n)\\n        {\\n            int start=pow(10,c),last=start*10;\\n            for(int i=start;i<last;i++) // 11,22,.........,99 / 1001,1111,......,9999\\n            {\\n                int p=i,t=0;\\n                while(p)\\n                {\\n                    t=t*10+p%10;\\n                    p/=10;\\n                }\\n                long long current=1ll*i*last;\\n                current+=t; // eg. i=123, then current=123321\\n                if(check(current,k))\\n                {\\n                    result+=current;\\n                    if(--n==0) return result;\\n                }\\n            }\\n            for(int i=start;i<last;i++) // 101,111,......191,202,212,......,989,999 / 10001,10101,......99999\\n            {\\n                int p=i,t=0;\\n                while(p)\\n                {\\n                    t=t*10+p%10;\\n                    p/=10;\\n                }\\n                long long r=1ll*i*10;\\n                for(int j=0;j<10;j++)\\n                {\\n                    long long current=(r+j)*last+t; // eg. i=123, j=4, then current=1234321\\n                    if(check(current,k))\\n                    {\\n                        result+=current;\\n                        if(--n==0) return result;\\n                    }\\n                }\\n            }\\n            c++;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\n    public:\\n    bool check(long long c,int k)\\n    {\\n        string s;\\n        while(c)\\n        {\\n            s+=(char)(c%k+\\'0\\'); // change to_string to this speed up more than 10 times\\n            c/=k;\\n        }\\n        // check if s is palindrome\\n        int p1=0,p2=(int)s.length()-1;\\n        while(p1<p2)\\n            if(s[p1++]!=s[p2--])\\n                return false;\\n        \\n        return true;\\n    }\\n    long long kMirror(int k, int n) \\n    {\\n        long long result=0,c=0;\\n        for(int i=1;i<10;i++) // 1,2,......,9\\n        {\\n            if(check(i,k)) // if single digit in base 10 is also palindromes in base k\\n            {\\n                result+=i;\\n                if(--n==0) return result;\\n            }\\n        }\\n        while(n)\\n        {\\n            int start=pow(10,c),last=start*10;\\n            for(int i=start;i<last;i++) // 11,22,.........,99 / 1001,1111,......,9999\\n            {\\n                int p=i,t=0;\\n                while(p)\\n                {\\n                    t=t*10+p%10;\\n                    p/=10;\\n                }\\n                long long current=1ll*i*last;\\n                current+=t; // eg. i=123, then current=123321\\n                if(check(current,k))\\n                {\\n                    result+=current;\\n                    if(--n==0) return result;\\n                }\\n            }\\n            for(int i=start;i<last;i++) // 101,111,......191,202,212,......,989,999 / 10001,10101,......99999\\n            {\\n                int p=i,t=0;\\n                while(p)\\n                {\\n                    t=t*10+p%10;\\n                    p/=10;\\n                }\\n                long long r=1ll*i*10;\\n                for(int j=0;j<10;j++)\\n                {\\n                    long long current=(r+j)*last+t; // eg. i=123, j=4, then current=1234321\\n                    if(check(current,k))\\n                    {\\n                        result+=current;\\n                        if(--n==0) return result;\\n                    }\\n                }\\n            }\\n            c++;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1589244,
                "title": "short-python-solution",
                "content": "```python\\nresult = set()\\narr = {\"\"}\\nwhile len(result) < n + 1:\\n\\ttemp = set()\\n\\tfor x in arr:\\n\\t\\tfor i in range(k):\\n\\t\\t\\ta = x + str(i) + x[ : : -1]\\n\\t\\t\\tb = x + str(i) + str(i) + x[ : : -1]\\n\\t\\t\\ts1, s2 = str(int(a, k)), str(int(b, k))\\n\\t\\t\\tif s1 == s1[ : : -1]:\\n\\t\\t\\t\\tresult.add(int(a, k))\\n\\t\\t\\tif s2 == s2[ : : -1]:\\n\\t\\t\\t\\tresult.add(int(b, k))\\n\\t\\t\\tif b[0] != \"0\":\\n\\t\\t\\t\\ttemp.add(x + str(i))\\n\\tarr = temp\\nreturn sum(sorted(result)[1 : n + 1])\\n```",
                "solutionTags": [],
                "code": "```python\\nresult = set()\\narr = {\"\"}\\nwhile len(result) < n + 1:\\n\\ttemp = set()\\n\\tfor x in arr:\\n\\t\\tfor i in range(k):\\n\\t\\t\\ta = x + str(i) + x[ : : -1]\\n\\t\\t\\tb = x + str(i) + str(i) + x[ : : -1]\\n\\t\\t\\ts1, s2 = str(int(a, k)), str(int(b, k))\\n\\t\\t\\tif s1 == s1[ : : -1]:\\n\\t\\t\\t\\tresult.add(int(a, k))\\n\\t\\t\\tif s2 == s2[ : : -1]:\\n\\t\\t\\t\\tresult.add(int(b, k))\\n\\t\\t\\tif b[0] != \"0\":\\n\\t\\t\\t\\ttemp.add(x + str(i))\\n\\tarr = temp\\nreturn sum(sorted(result)[1 : n + 1])\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1589107,
                "title": "python3-generating-all-palindromes",
                "content": "![image](https://assets.leetcode.com/users/images/db265c98-ff43-431d-8b97-7cbc47e40bd3_1637515355.7147493.png)\\n\\n\\n```\\n    def kMirror(self, k: int, n: int) -> int:\\n        @cache \\n        def helper(start, n):            \\n            if n == 1:\\n                return [str(i) for i in range(start, k)]\\n            if n == 2: \\n                return [str(i) + str(i) for i in range(start, k)]\\n            else: \\n                arr = []\\n                for elem in [str(i) for i in range(start, k)]:\\n                    for center in helper(0, n - 2):\\n                        arr.append(elem + center + elem[::-1])\\n\\n                return arr\\n            \\n        digits = 1\\n        counter = 0\\n        ans = 0 \\n        while True:\\n            for num in helper(1, digits):\\n                numBase = str(int(num, k))\\n                if numBase == numBase[::-1]:\\n                    ans += int(numBase)\\n                    counter += 1\\n                    if counter == n: \\n                        return ans\\n                \\n            digits += 1                \\n                                        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n    def kMirror(self, k: int, n: int) -> int:\\n        @cache \\n        def helper(start, n):            \\n            if n == 1:\\n                return [str(i) for i in range(start, k)]\\n            if n == 2: \\n                return [str(i) + str(i) for i in range(start, k)]\\n            else: \\n                arr = []\\n                for elem in [str(i) for i in range(start, k)]:\\n                    for center in helper(0, n - 2):\\n                        arr.append(elem + center + elem[::-1])\\n\\n                return arr\\n            \\n        digits = 1\\n        counter = 0\\n        ans = 0 \\n        while True:\\n            for num in helper(1, digits):\\n                numBase = str(int(num, k))\\n                if numBase == numBase[::-1]:\\n                    ans += int(numBase)\\n                    counter += 1\\n                    if counter == n: \\n                        return ans\\n                \\n            digits += 1                \\n                                        \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1589095,
                "title": "java-iterative-solution-generate-palindromes-in-new-base-and-convert-to-decimal",
                "content": "The key idea is that to generate a palindrome number of length `n`, you can use the nearest lowerst set of palindrome numbers as base of length `len` where `len < n` and `len % 2 == 0`\\nNow if `n` is odd, add single digit number in mid\\nelse add double digint numbers in mid.\\n\\n```\\nclass Solution {\\n    int num;\\n    long sum;\\n    int base;\\n    \\n    public long kMirror(int k, int n) {\\n        base = k;\\n        sum = 0l;\\n        num = n;\\n\\n        List<String> one = new ArrayList<>();\\n        one.add(\"0\");\\n        for(int i = 1; i < k && num > 0; i++) {\\n            one.add(Integer.toString(i));\\n            if (n > 0) {\\n                sum += i;\\n                num--;\\n            }\\n        }\\n        \\n        List<String> two = new ArrayList<>();\\n        two.add(\"00\");\\n        for(int i = 1; i < k && num > 0; i++) {\\n            two.add(Integer.toString(i + i * 10));\\n            if (n > 0) {\\n                int decimal = i + i * k;\\n                if (palindrome(decimal)) {\\n                    sum += decimal;\\n                    num--;\\n                }\\n            }\\n        }\\n        \\n        List<List<String>> nums = new ArrayList<>();\\n        nums.add(one);\\n        nums.add(two);\\n\\n        int count = 3;\\n        while(num > 0) {\\n            List<String> newNums = new ArrayList<>();\\n            StringBuilder sb = new StringBuilder();\\n            for(int i = 0; i < count; i++) {\\n                sb.append(\"0\");\\n            }\\n            newNums.add(sb.toString());\\n\\n            addNextDigitCount(nums, newNums, count);\\n            \\n            count++;\\n            nums.add(newNums);\\n        }\\n        \\n        return sum;\\n    }\\n    \\n    private void addNextDigitCount(List<List<String>> nums, List<String> newNums, int count) {\\n        List<String> baseStrs;\\n        List<String> appendStrs;\\n        \\n        if (count % 2 != 0) {\\n            baseStrs = nums.get(count - 2);\\n            appendStrs = nums.get(0);\\n        } else {\\n            baseStrs = nums.get(count - 3);\\n            appendStrs = nums.get(1);\\n        }\\n        \\n        for(int i = 1; i < baseStrs.size() && num > 0; i++) {\\n            String base = baseStrs.get(i);\\n            String part1 = base.substring(0, (count - 1) / 2);\\n            String part2 = base.substring((count - 1) / 2);\\n\\n            for(int j = 0; j < appendStrs.size() && num > 0; j++) {\\n                String append = appendStrs.get(j);\\n\\t\\t\\t\\t\\n                StringBuilder sb = new StringBuilder(part1);\\n                sb.append(append);\\n                sb.append(part2);\\n                newNums.add(sb.toString());\\n\\n                long decimal = decimalValue(sb.toString());\\n                \\n                if (palindrome(decimal)) {\\n                    sum += decimal;\\n                    num--;\\n                }\\n            }\\n        }\\n    }\\n    \\n    private boolean palindrome(long num) {\\n        String str = Long.toString(num);\\n        StringBuilder sb = new StringBuilder(str);\\n        return str.equals(sb.reverse().toString());\\n    }\\n    \\n    private long decimalValue(String str) {\\n        long x = 0;\\n        int pow = 0;\\n        for(int i = str.length() - 1; i >= 0; i--) {\\n            int d = str.charAt(i) - \\'0\\';\\n            \\n            x += (d * (long)Math.pow(base, pow));\\n            pow++;\\n        }\\n        \\n        return x;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int num;\\n    long sum;\\n    int base;\\n    \\n    public long kMirror(int k, int n) {\\n        base = k;\\n        sum = 0l;\\n        num = n;\\n\\n        List<String> one = new ArrayList<>();\\n        one.add(\"0\");\\n        for(int i = 1; i < k && num > 0; i++) {\\n            one.add(Integer.toString(i));\\n            if (n > 0) {\\n                sum += i;\\n                num--;\\n            }\\n        }\\n        \\n        List<String> two = new ArrayList<>();\\n        two.add(\"00\");\\n        for(int i = 1; i < k && num > 0; i++) {\\n            two.add(Integer.toString(i + i * 10));\\n            if (n > 0) {\\n                int decimal = i + i * k;\\n                if (palindrome(decimal)) {\\n                    sum += decimal;\\n                    num--;\\n                }\\n            }\\n        }\\n        \\n        List<List<String>> nums = new ArrayList<>();\\n        nums.add(one);\\n        nums.add(two);\\n\\n        int count = 3;\\n        while(num > 0) {\\n            List<String> newNums = new ArrayList<>();\\n            StringBuilder sb = new StringBuilder();\\n            for(int i = 0; i < count; i++) {\\n                sb.append(\"0\");\\n            }\\n            newNums.add(sb.toString());\\n\\n            addNextDigitCount(nums, newNums, count);\\n            \\n            count++;\\n            nums.add(newNums);\\n        }\\n        \\n        return sum;\\n    }\\n    \\n    private void addNextDigitCount(List<List<String>> nums, List<String> newNums, int count) {\\n        List<String> baseStrs;\\n        List<String> appendStrs;\\n        \\n        if (count % 2 != 0) {\\n            baseStrs = nums.get(count - 2);\\n            appendStrs = nums.get(0);\\n        } else {\\n            baseStrs = nums.get(count - 3);\\n            appendStrs = nums.get(1);\\n        }\\n        \\n        for(int i = 1; i < baseStrs.size() && num > 0; i++) {\\n            String base = baseStrs.get(i);\\n            String part1 = base.substring(0, (count - 1) / 2);\\n            String part2 = base.substring((count - 1) / 2);\\n\\n            for(int j = 0; j < appendStrs.size() && num > 0; j++) {\\n                String append = appendStrs.get(j);\\n\\t\\t\\t\\t\\n                StringBuilder sb = new StringBuilder(part1);\\n                sb.append(append);\\n                sb.append(part2);\\n                newNums.add(sb.toString());\\n\\n                long decimal = decimalValue(sb.toString());\\n                \\n                if (palindrome(decimal)) {\\n                    sum += decimal;\\n                    num--;\\n                }\\n            }\\n        }\\n    }\\n    \\n    private boolean palindrome(long num) {\\n        String str = Long.toString(num);\\n        StringBuilder sb = new StringBuilder(str);\\n        return str.equals(sb.reverse().toString());\\n    }\\n    \\n    private long decimalValue(String str) {\\n        long x = 0;\\n        int pow = 0;\\n        for(int i = str.length() - 1; i >= 0; i--) {\\n            int d = str.charAt(i) - \\'0\\';\\n            \\n            x += (d * (long)Math.pow(base, pow));\\n            pow++;\\n        }\\n        \\n        return x;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1610873,
                "title": "java-simple-bfs-solution-with-explanation",
                "content": "\\nApproach : \\nIf we consider to generate all values in base k, then we would hit TLE, instead try to generate all mirror based numbers in base k and check whether they are mirrored in decimal as well, if so we add it and do a BFS on those base k mirrored numbers.\\n\\neg. a) if the length of the digits of a number is even(say 1221) and base is 5,\\nthen you can generate only 12021, 12121, 12221, 12321, 12421 numbers in the next bfs.\\nSo we can loop on it like 12 [0-4] 21.\\n      b) if the length of the digits of a number is odd(say 121) and base is 5, \\nthen irrespective of the base, you can only generate 1221 in the next bfs.\\nSo we can just take the middle digit and add it at the middle itself like\\n12 [2] 1.\\n\\nAlso, keeping track of sum and count at all steps and if the count reaches n, then we break up and return the sum\\n\\n\\n```\\nclass Solution {\\n    public long kMirror(int k, int n) {\\n        Queue<String> queue = new LinkedList<>();\\n        int count = 0;\\n        long sum = 0l;\\n        for(int i = 1; i < k; i++){\\n            queue.add(String.valueOf(i));\\n            count++;\\n            sum += i;\\n            if(count == n) return sum;\\n        }\\n        \\n        x:while(true){\\n            int size = queue.size();\\n            while(size-- > 0){\\n                String s = queue.poll();\\n                if(s.length()%2 == 0){\\n                    for(int i = 0; i < k; i++){\\n                        String newStr = s.substring(0,s.length()/2)\\n                        + i\\n                        + s.substring(s.length()/2,s.length());\\n                        long deci = convert(newStr,k);\\n                        if(isPalindrome(deci)){\\n                            count++;\\n                            sum += deci;\\n                        }\\n                        queue.add(newStr);\\n                        if(count == n) break x;\\n                    }\\n                }\\n                else{\\n                   String newStr = s.substring(0,s.length()/2) +\\n                    s.charAt(s.length()/2) +\\n                    s.substring(s.length()/2,s.length());  \\n                    long deci = convert(newStr,k);\\n                    if(isPalindrome(deci)){\\n                        count++;\\n                        sum += deci;\\n                    }\\n                    queue.add(newStr);\\n                }\\n                if(count == n) break x;\\n            }\\n        }\\n        \\n        return sum;\\n    }\\n    \\n    private long convert(String str,int k){\\n        return Long.parseLong(str,k);\\n    }\\n    \\n    private boolean isPalindrome(long n){\\n         long temp = n, sum = 0l, r = 0l;   \\n         while(n>0){    \\n               r=n%10;\\n               sum=(sum*10)+r;    \\n               n=n/10;    \\n          }\\n        \\n        return sum == temp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public long kMirror(int k, int n) {\\n        Queue<String> queue = new LinkedList<>();\\n        int count = 0;\\n        long sum = 0l;\\n        for(int i = 1; i < k; i++){\\n            queue.add(String.valueOf(i));\\n            count++;\\n            sum += i;\\n            if(count == n) return sum;\\n        }\\n        \\n        x:while(true){\\n            int size = queue.size();\\n            while(size-- > 0){\\n                String s = queue.poll();\\n                if(s.length()%2 == 0){\\n                    for(int i = 0; i < k; i++){\\n                        String newStr = s.substring(0,s.length()/2)\\n                        + i\\n                        + s.substring(s.length()/2,s.length());\\n                        long deci = convert(newStr,k);\\n                        if(isPalindrome(deci)){\\n                            count++;\\n                            sum += deci;\\n                        }\\n                        queue.add(newStr);\\n                        if(count == n) break x;\\n                    }\\n                }\\n                else{\\n                   String newStr = s.substring(0,s.length()/2) +\\n                    s.charAt(s.length()/2) +\\n                    s.substring(s.length()/2,s.length());  \\n                    long deci = convert(newStr,k);\\n                    if(isPalindrome(deci)){\\n                        count++;\\n                        sum += deci;\\n                    }\\n                    queue.add(newStr);\\n                }\\n                if(count == n) break x;\\n            }\\n        }\\n        \\n        return sum;\\n    }\\n    \\n    private long convert(String str,int k){\\n        return Long.parseLong(str,k);\\n    }\\n    \\n    private boolean isPalindrome(long n){\\n         long temp = n, sum = 0l, r = 0l;   \\n         while(n>0){    \\n               r=n%10;\\n               sum=(sum*10)+r;    \\n               n=n/10;    \\n          }\\n        \\n        return sum == temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1596457,
                "title": "java-in-30-lines",
                "content": "```\\nclass Solution {\\n    private static final int MAX_DIGITS = 20; // Number of K powers to pre-generate.\\n    \\n    public long kMirror(int k, int n) {\\n        long[] kpow = new long[MAX_DIGITS];\\n        for(long i = 0, j = 1; i<MAX_DIGITS; i++, j*=k) kpow[(int)i] = j; // Generate k^i for future use.\\n        long sum = 0; // The answer to return.\\n        int count = 0; // Number of answers found.\\n        for(int digits = 1; digits < MAX_DIGITS * 2 ; digits++) { // Loop by number of digits of answers.\\n            int digitsToIterate = (digits + 1) / 2; // The left side of k based numbers increases 1 by 1.\\n            int digitsToFill = digits / 2; // The right side of k based number needs to be filled.\\n            for(long i = kpow[digitsToIterate-1]; i < kpow[digitsToIterate]; i++) { // Iterate the left side.\\n                long number = i * kpow[digitsToFill]; // Shift the left side into a number without the right half.\\n                for(int j = 0; j < digitsToFill; j++) { // Filll in the right half.\\n                    number += kpow[j] * ((i / kpow[digitsToIterate - j - 1]) % k);\\n                }\\n                if(!is10Mirror(number)) continue; // Check if the number is symmetric in decimal form.\\n                sum += number; // Increase the sum.\\n                if(++count == n) return sum; // Increase the count and potentially return.\\n            }\\n        }\\n        throw new IllegalStateException(\"Reached unreachable.\"); // This should never happen.\\n    }\\n    \\n    private static boolean is10Mirror(long number) { // Check if a number is symmetric in decimal form.\\n        String s = String.valueOf(number);\\n        for(int i = 0, j = s.length() - 1; i<j; i++, j--) if(s.charAt(i) != s.charAt(j)) return false;\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private static final int MAX_DIGITS = 20; // Number of K powers to pre-generate.\\n    \\n    public long kMirror(int k, int n) {\\n        long[] kpow = new long[MAX_DIGITS];\\n        for(long i = 0, j = 1; i<MAX_DIGITS; i++, j*=k) kpow[(int)i] = j; // Generate k^i for future use.\\n        long sum = 0; // The answer to return.\\n        int count = 0; // Number of answers found.\\n        for(int digits = 1; digits < MAX_DIGITS * 2 ; digits++) { // Loop by number of digits of answers.\\n            int digitsToIterate = (digits + 1) / 2; // The left side of k based numbers increases 1 by 1.\\n            int digitsToFill = digits / 2; // The right side of k based number needs to be filled.\\n            for(long i = kpow[digitsToIterate-1]; i < kpow[digitsToIterate]; i++) { // Iterate the left side.\\n                long number = i * kpow[digitsToFill]; // Shift the left side into a number without the right half.\\n                for(int j = 0; j < digitsToFill; j++) { // Filll in the right half.\\n                    number += kpow[j] * ((i / kpow[digitsToIterate - j - 1]) % k);\\n                }\\n                if(!is10Mirror(number)) continue; // Check if the number is symmetric in decimal form.\\n                sum += number; // Increase the sum.\\n                if(++count == n) return sum; // Increase the count and potentially return.\\n            }\\n        }\\n        throw new IllegalStateException(\"Reached unreachable.\"); // This should never happen.\\n    }\\n    \\n    private static boolean is10Mirror(long number) { // Check if a number is symmetric in decimal form.\\n        String s = String.valueOf(number);\\n        for(int i = 0, j = s.length() - 1; i<j; i++, j--) if(s.charAt(i) != s.charAt(j)) return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1594490,
                "title": "c-easy-to-understand-code-detailed-explanation",
                "content": "Inspired  by `ye15`\\'s post ([link](https://leetcode.com/problems/sum-of-k-mirror-numbers/discuss/1589048/Python3-enumerate-k-symmetric-numbers))\\n\\nAt first, we know we can brute force base k-symmetric number from smallest to larger numbers since the constraint given suggests that. But how we generate those numbers, in order?\\n\\nLook at the first example, there is actually obvious hint.\\n\\n```\\n1 --> 11 --> 101 --> 111 --> 1001\\n```\\n\\nObserve that we can recursively generate next base k-symmetric number by the following procedure:\\n\\n1. For current number, we scan from the closest-to-center index (because if we want to find next smallest number, we need to check MSB/LSB pair at last) of either half (for convenience, we may choose the right half), and check the corresponding index in another half.\\n\\nLet\\'s denote the pair index i and j, like following (Assume we have string \"33322222333\" now):\\n\\n```\\n 01234567890\\n\\n\"33322222333\"\\n      x          // x = {j, i}\\n     j i\\n    j   i\\n      .\\n      .\\n      .\\n```\\n2. If we found char at index i is not (k-1) yet, we know we can increment the bit by one, and reset all inner bits to 0, and this will be the next base k-symmetric number. For \"33322222333\", assume it\\'s in base 4, we will find \"33322322333\" is the next one. For \"2332\", we will find \"3003\".\\n\\n3. If we fail to find any until we scan to end of string, we know that it\\'s time to extend the string length by one. For \"1111\", next will be \"10001\". And that\\'s all! We can create our own generating function now.\\n\\nAnd the rest of the problem is we need to find if our base k-symmetric number is also base 10-symmetric. And that\\'s easy (`isDeciSym` below does that).\\n\\n```c++\\nclass Solution {\\n\\t// generate next k-symmetric number from current number x\\n    string genKsym(string x, int k) {\\n        int N = x.size();\\n        for (int i = N/2; i < N; i++) {\\n            if (x[i]-\\'0\\' < k-1) {\\n                x[i] = x[N+(~i)] = static_cast<char>(x[i]+1); // i and (N+(~i)) are center-symmetric indices.\\n                for (int j = N/2; j < i; j++) x[j] = x[N+(~j)] = \\'0\\'; // set inner bits to zero\\n                return x;\\n            }\\n        }\\n        string res = \"1\" + string(N-1, \\'0\\') + \"1\"; // extend one bit and reset\\n        return res;\\n    }\\n\\t// transform base k string to decimal long long\\n    long long baseKtoDeci(string x, long long k) {\\n        long long res = 0;\\n        int N = x.size();\\n        for (long long i = N-1, multp = 1; ~i; i--, multp *= k) {\\n            res += multp * (x[i]-\\'0\\');\\n        }\\n        return res;\\n    }\\n\\t// check if num is 10-symmetric\\n    bool isDeciSym(long long num) {\\n        string s;\\n        while (num) {\\n            char c = num % 10;\\n            s += c;\\n            num /= 10;\\n        }\\n        int N = s.size();\\n        for (int i = 0, j = N-1; i < j; i++, j--) {\\n            if (s[i] != s[j]) return false;\\n        }\\n        return true;\\n    }\\npublic:\\n    long long kMirror(int k, int n) {\\n        long long res = 0;\\n        \\n        string x = \"0\";\\n        while (n--) {\\n            while (true) {\\n                x = genKsym(x, k);\\n                long long val = baseKtoDeci(x, k);\\n                if (isDeciSym(val)) {\\n                    res += val;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n1 --> 11 --> 101 --> 111 --> 1001\\n```\n```\\n 01234567890\\n\\n\"33322222333\"\\n      x          // x = {j, i}\\n     j i\\n    j   i\\n      .\\n      .\\n      .\\n```\n```c++\\nclass Solution {\\n\\t// generate next k-symmetric number from current number x\\n    string genKsym(string x, int k) {\\n        int N = x.size();\\n        for (int i = N/2; i < N; i++) {\\n            if (x[i]-\\'0\\' < k-1) {\\n                x[i] = x[N+(~i)] = static_cast<char>(x[i]+1); // i and (N+(~i)) are center-symmetric indices.\\n                for (int j = N/2; j < i; j++) x[j] = x[N+(~j)] = \\'0\\'; // set inner bits to zero\\n                return x;\\n            }\\n        }\\n        string res = \"1\" + string(N-1, \\'0\\') + \"1\"; // extend one bit and reset\\n        return res;\\n    }\\n\\t// transform base k string to decimal long long\\n    long long baseKtoDeci(string x, long long k) {\\n        long long res = 0;\\n        int N = x.size();\\n        for (long long i = N-1, multp = 1; ~i; i--, multp *= k) {\\n            res += multp * (x[i]-\\'0\\');\\n        }\\n        return res;\\n    }\\n\\t// check if num is 10-symmetric\\n    bool isDeciSym(long long num) {\\n        string s;\\n        while (num) {\\n            char c = num % 10;\\n            s += c;\\n            num /= 10;\\n        }\\n        int N = s.size();\\n        for (int i = 0, j = N-1; i < j; i++, j--) {\\n            if (s[i] != s[j]) return false;\\n        }\\n        return true;\\n    }\\npublic:\\n    long long kMirror(int k, int n) {\\n        long long res = 0;\\n        \\n        string x = \"0\";\\n        while (n--) {\\n            while (true) {\\n                x = genKsym(x, k);\\n                long long val = baseKtoDeci(x, k);\\n                if (isDeciSym(val)) {\\n                    res += val;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1589609,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    long long kMirror(int k, int n) {\\n        auto is_kmirror = [k] (long long num) {\\n            string s;\\n            for (; num; num /= k) s += char(num % k);\\n            return !s.compare({s.rbegin(), s.rend()});\\n        };\\n        \\n        auto next_mirror = [s = string(\"0\")] () mutable {\\n            for (int i = s.size() / 2, j = i - (~s.size() & 1); i < s.size(); i++, j--) {\\n                if (s[i] != \\'9\\') {\\n                    s[i] = s[j] = s[i] + 1;\\n                    return stoll(s);\\n                } else {\\n                    s[i] = s[j] = \\'0\\';\\n                }\\n            }\\n            s[0] = \\'1\\';\\n            s += \\'1\\';\\n            return stoll(s);\\n        };\\n        \\n        long long ans = 0;\\n        for (int i = 0; i < n; i++) {\\n            long long num = next_mirror();\\n            for (; !is_kmirror(num); num = next_mirror());\\n            ans += num;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long kMirror(int k, int n) {\\n        auto is_kmirror = [k] (long long num) {\\n            string s;\\n            for (; num; num /= k) s += char(num % k);\\n            return !s.compare({s.rbegin(), s.rend()});\\n        };\\n        \\n        auto next_mirror = [s = string(\"0\")] () mutable {\\n            for (int i = s.size() / 2, j = i - (~s.size() & 1); i < s.size(); i++, j--) {\\n                if (s[i] != \\'9\\') {\\n                    s[i] = s[j] = s[i] + 1;\\n                    return stoll(s);\\n                } else {\\n                    s[i] = s[j] = \\'0\\';\\n                }\\n            }\\n            s[0] = \\'1\\';\\n            s += \\'1\\';\\n            return stoll(s);\\n        };\\n        \\n        long long ans = 0;\\n        for (int i = 0; i < n; i++) {\\n            long long num = next_mirror();\\n            for (; !is_kmirror(num); num = next_mirror());\\n            ans += num;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1589361,
                "title": "python-iterate-all-mirror-numbers-in-base-k",
                "content": "Iterate all mirror numbers in base k and check if it\\'s still mirror number in base 10.\\n\\n```\\nfrom functools import lru_cache\\n\\n\\nclass Solution:\\n    @lru_cache\\n    def kMirror(self, k: int, n: int) -> int:\\n        def gen(p, k, start=1):\\n            if p == 1:\\n                yield from range(start, k)\\n            elif p == 2:\\n                for i in range(start, k):\\n                    yield i * (k+1)\\n            else:\\n                for i in range(start, k):\\n                    for j in gen(p-2, k, start=0):\\n                        yield i * k**(p-1) + j * k + i\\n                        \\n        def is_mirror(x):\\n            x_ = str(x)\\n            return x_ == x_[::-1]\\n        \\n        p = 1\\n        sum_ = 0\\n        cnt = 0\\n        while True:\\n            for x in gen(p, k):\\n                if is_mirror(x):\\n                    sum_ += x\\n                    cnt += 1\\n                    if cnt == n:\\n                        return sum_\\n            p += 1\\n        return sum_\\n```",
                "solutionTags": [],
                "code": "```\\nfrom functools import lru_cache\\n\\n\\nclass Solution:\\n    @lru_cache\\n    def kMirror(self, k: int, n: int) -> int:\\n        def gen(p, k, start=1):\\n            if p == 1:\\n                yield from range(start, k)\\n            elif p == 2:\\n                for i in range(start, k):\\n                    yield i * (k+1)\\n            else:\\n                for i in range(start, k):\\n                    for j in gen(p-2, k, start=0):\\n                        yield i * k**(p-1) + j * k + i\\n                        \\n        def is_mirror(x):\\n            x_ = str(x)\\n            return x_ == x_[::-1]\\n        \\n        p = 1\\n        sum_ = 0\\n        cnt = 0\\n        while True:\\n            for x in gen(p, k):\\n                if is_mirror(x):\\n                    sum_ += x\\n                    cnt += 1\\n                    if cnt == n:\\n                        return sum_\\n            p += 1\\n        return sum_\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1589322,
                "title": "javascript-build-number-via-base-1540ms",
                "content": "```\\nconst isPalindrome = (s) => { let n = s.length; let i = 0; let j = n - 1; while (i < j) { if (s[i++] != s[j--]) return false; } return true; };\\n\\nconst int = parseInt;\\nconst kMirror = (k, n) => {\\n    let res = 0;\\n    for (let len = 1; ; len++) {\\n        let min = 10 ** ((len - 1) >> 1), max = 10 ** ((len + 1) >> 1);\\n        for (let base = min; base < max; base++) {\\n            let x = base;\\n            for (let i = len & 1 ? int(base / 10) : base; i > 0; i = int(i / 10)) {\\n                x = x * 10 + i % 10;\\n            }\\n            let s = x.toString(k);\\n            if (isPalindrome(s)) {\\n                res += x;\\n                n--;\\n                if (!n) return res;\\n            }\\n        }\\n    }\\n};\\n```\\nAnother cheating way 72ms: write a brute force solution and get the dataset\\n```\\n// each 2-9 base with n = 30\\nlet a = [[], [],\\n[1, 3, 5, 7, 9, 33, 99, 313, 585, 717, 7447, 9009, 15351, 32223, 39993, 53235, 53835, 73737, 585585, 1758571, 1934391, 1979791, 3129213, 5071705, 5259525, 5841485, 13500531, 719848917, 910373019, 939474939],\\n[1, 2, 4, 8, 121, 151, 212, 242, 484, 656, 757, 29092, 48884, 74647, 75457, 76267, 92929, 93739, 848848, 1521251, 2985892, 4022204, 4219124, 4251524, 4287824, 5737375, 7875787, 7949497, 27711772, 83155138],\\n[1, 2, 3, 5, 55, 373, 393, 666, 787, 939, 7997, 53235, 55255, 55655, 57675, 506605, 1801081, 2215122, 3826283, 3866683, 5051505, 5226225, 5259525, 5297925, 5614165, 5679765, 53822835, 623010326, 954656459, 51717171715],\\n[1, 2, 3, 4, 6, 88, 252, 282, 626, 676, 1221, 15751, 18881, 10088001, 10400401, 27711772, 30322303, 47633674, 65977956, 808656808, 831333138, 831868138, 836131638, 836181638, 2512882152, 2596886952, 2893553982, 6761551676, 12114741121, 12185058121],\\n[1, 2, 3, 4, 5, 7, 55, 111, 141, 191, 343, 434, 777, 868, 1441, 7667, 7777, 22022, 39893, 74647, 168861, 808808, 909909, 1867681, 3097903, 4232324, 4265624, 4298924, 4516154, 4565654],\\n[1, 2, 3, 4, 5, 6, 8, 121, 171, 242, 292, 16561, 65656, 2137312, 4602064, 6597956, 6958596, 9470749, 61255216, 230474032, 466828664, 485494584, 638828836, 657494756, 858474858, 25699499652, 40130703104, 45862226854, 61454945416, 64454545446],\\n[1, 2, 3, 4, 5, 6, 7, 9, 121, 292, 333, 373, 414, 585, 3663, 8778, 13131, 13331, 26462, 26662, 30103, 30303, 207702, 628826, 660066, 1496941, 1935391, 1970791, 4198914, 55366355],\\n[1, 2, 3, 4, 5, 6, 7, 8, 191, 282, 373, 464, 555, 646, 656, 6886, 25752, 27472, 42324, 50605, 626626, 1540451, 1713171, 1721271, 1828281, 1877781, 1885881, 2401042, 2434342, 2442442]];\\n\\nconst kMirror = (k, n) => {\\n    let res = 0;\\n    for (let i = 0; i < n; i++) res += a[k][i];\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Math"
                ],
                "code": "```\\nconst isPalindrome = (s) => { let n = s.length; let i = 0; let j = n - 1; while (i < j) { if (s[i++] != s[j--]) return false; } return true; };\\n\\nconst int = parseInt;\\nconst kMirror = (k, n) => {\\n    let res = 0;\\n    for (let len = 1; ; len++) {\\n        let min = 10 ** ((len - 1) >> 1), max = 10 ** ((len + 1) >> 1);\\n        for (let base = min; base < max; base++) {\\n            let x = base;\\n            for (let i = len & 1 ? int(base / 10) : base; i > 0; i = int(i / 10)) {\\n                x = x * 10 + i % 10;\\n            }\\n            let s = x.toString(k);\\n            if (isPalindrome(s)) {\\n                res += x;\\n                n--;\\n                if (!n) return res;\\n            }\\n        }\\n    }\\n};\\n```\n```\\n// each 2-9 base with n = 30\\nlet a = [[], [],\\n[1, 3, 5, 7, 9, 33, 99, 313, 585, 717, 7447, 9009, 15351, 32223, 39993, 53235, 53835, 73737, 585585, 1758571, 1934391, 1979791, 3129213, 5071705, 5259525, 5841485, 13500531, 719848917, 910373019, 939474939],\\n[1, 2, 4, 8, 121, 151, 212, 242, 484, 656, 757, 29092, 48884, 74647, 75457, 76267, 92929, 93739, 848848, 1521251, 2985892, 4022204, 4219124, 4251524, 4287824, 5737375, 7875787, 7949497, 27711772, 83155138],\\n[1, 2, 3, 5, 55, 373, 393, 666, 787, 939, 7997, 53235, 55255, 55655, 57675, 506605, 1801081, 2215122, 3826283, 3866683, 5051505, 5226225, 5259525, 5297925, 5614165, 5679765, 53822835, 623010326, 954656459, 51717171715],\\n[1, 2, 3, 4, 6, 88, 252, 282, 626, 676, 1221, 15751, 18881, 10088001, 10400401, 27711772, 30322303, 47633674, 65977956, 808656808, 831333138, 831868138, 836131638, 836181638, 2512882152, 2596886952, 2893553982, 6761551676, 12114741121, 12185058121],\\n[1, 2, 3, 4, 5, 7, 55, 111, 141, 191, 343, 434, 777, 868, 1441, 7667, 7777, 22022, 39893, 74647, 168861, 808808, 909909, 1867681, 3097903, 4232324, 4265624, 4298924, 4516154, 4565654],\\n[1, 2, 3, 4, 5, 6, 8, 121, 171, 242, 292, 16561, 65656, 2137312, 4602064, 6597956, 6958596, 9470749, 61255216, 230474032, 466828664, 485494584, 638828836, 657494756, 858474858, 25699499652, 40130703104, 45862226854, 61454945416, 64454545446],\\n[1, 2, 3, 4, 5, 6, 7, 9, 121, 292, 333, 373, 414, 585, 3663, 8778, 13131, 13331, 26462, 26662, 30103, 30303, 207702, 628826, 660066, 1496941, 1935391, 1970791, 4198914, 55366355],\\n[1, 2, 3, 4, 5, 6, 7, 8, 191, 282, 373, 464, 555, 646, 656, 6886, 25752, 27472, 42324, 50605, 626626, 1540451, 1713171, 1721271, 1828281, 1877781, 1885881, 2401042, 2434342, 2442442]];\\n\\nconst kMirror = (k, n) => {\\n    let res = 0;\\n    for (let i = 0; i < n; i++) res += a[k][i];\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1589297,
                "title": "java-gen-next-palindrome-num-and-check-for-base-k",
                "content": "Just sharing my codes and that\\'s all. Somehow was able to solve this but didn\\'t make it in time for the contest. It generates the next palindrome number and skips checking numbers that can\\'t possibly be a palindrome. It is enough to pass with around 1500 ms (25% speed). I also noticed that Math.log10() function doesn\\'t give the correct result for number of length if the number is wayyyyyy too large such as (999999999999999998), but I had to use it otherwise converting it to string and then get the length gives TLE.\\n\\nI just started leetcoding a month ago with not much prior coding experience so pls go easy on my messy code. \\n\\n```\\nclass Solution {\\n    public long kMirror(int k, int n) {\\n        int count = 0;\\n        long ans = 0L;\\n        long cur = 0L;\\n        while (count < n){\\n            int len = cur == 0? 1 : (int)Math.log10(cur) + 1;\\n            int offset = (int) Math.pow(10, len / 2);\\n            cur = palindromeGenerator(cur + offset, len);\\n            if (convert(k, cur)){\\n                ans += cur;\\n                count++;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n    private long palindromeGenerator(long num, int length) {\\n        if (num < 10) return num;\\n\\n        int numOfDigits = (int)Math.log10(num) + 1;\\n        if (numOfDigits > length)\\n            return ((long) Math.pow(10, numOfDigits - 1) + 1);\\n\\n        num = num - num % (long) Math.pow(10, numOfDigits / 2);\\n        long temp = num;\\n        for (int j = 0; j < numOfDigits / 2; j++) {\\n            long digit = (long) Math.pow(10, numOfDigits - j - 1);\\n            num += (int) ((temp / digit) * Math.pow(10, j));\\n            temp = temp % digit;\\n        }\\n\\n        return num;\\n    }\\n\\n    private boolean convert(int base, long num){\\n        StringBuilder sb = new StringBuilder();\\n        while(num > 0){\\n            sb.append(num % base);\\n            num /= base;\\n        }\\n\\n        return verify(sb.toString());\\n    }\\n\\n    private boolean verify(String s){\\n        int l = 0;\\n        int r = s.length()-1;\\n        while(l < r) if (s.charAt(l++) != s.charAt(r--)) return false;\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public long kMirror(int k, int n) {\\n        int count = 0;\\n        long ans = 0L;\\n        long cur = 0L;\\n        while (count < n){\\n            int len = cur == 0? 1 : (int)Math.log10(cur) + 1;\\n            int offset = (int) Math.pow(10, len / 2);\\n            cur = palindromeGenerator(cur + offset, len);\\n            if (convert(k, cur)){\\n                ans += cur;\\n                count++;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n    private long palindromeGenerator(long num, int length) {\\n        if (num < 10) return num;\\n\\n        int numOfDigits = (int)Math.log10(num) + 1;\\n        if (numOfDigits > length)\\n            return ((long) Math.pow(10, numOfDigits - 1) + 1);\\n\\n        num = num - num % (long) Math.pow(10, numOfDigits / 2);\\n        long temp = num;\\n        for (int j = 0; j < numOfDigits / 2; j++) {\\n            long digit = (long) Math.pow(10, numOfDigits - j - 1);\\n            num += (int) ((temp / digit) * Math.pow(10, j));\\n            temp = temp % digit;\\n        }\\n\\n        return num;\\n    }\\n\\n    private boolean convert(int base, long num){\\n        StringBuilder sb = new StringBuilder();\\n        while(num > 0){\\n            sb.append(num % base);\\n            num /= base;\\n        }\\n\\n        return verify(sb.toString());\\n    }\\n\\n    private boolean verify(String s){\\n        int l = 0;\\n        int r = s.length()-1;\\n        while(l < r) if (s.charAt(l++) != s.charAt(r--)) return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1589235,
                "title": "python-enumerate-with-explanation",
                "content": "There are two ways to enumerate: using base 10 or using base k. It\\'s obvious that enumerate using base k is a better choice. \\n\\nNow we take a look at how to generate next palindrome k-based number. \\n\\nFor each k-based number, the first k-mirror number would be from 1 to k - 1. We say that as our base case.\\n\\nFor each k-based palindrome number of length n, we can insert a number in the middle to make it a palindrome number of length n+1. \\n\\nAnd there are two cases here:\\n- n % 2 == 1. We can only insert a number that is the same as the middle one. i.e. 121 -> 1221. otherwise, it won\\'t be palindrome.\\n- n % 2 == 0. We can insert any number from 0-9. i.e 1221-> 12021, 12121, 12221, ......\\n\\nAfter we find the patten here, we can right the code:\\n\\n```\\nclass Solution:\\n    def isMirrorBase10(self, temp, k):\\n        num = int(temp, k)\\n        if str(num) == str(num)[::-1]:\\n            return True, num\\n        else:\\n            return False, num\\n\\n    def kMirror(self, k: int, n: int) -> int:\\n        if n < k:\\n            total = 0\\n            for i in range(1, n+1):\\n                total += i\\n            return total\\n        baseCase = [str(i) for i in range(1, k)] #base case from 1 to k - 1\\n        index = 0\\n        total = 0\\n        for i in range(1, k):\\n            total += i\\n        cnt = k - 1\\n        while True:\\n            # current = baseCase.pop(0) #don\\'t use this, lead to TLE, since pop requires O(n)\\n            current = baseCase[index]\\n            midIndex = len(current) // 2\\n            if len(current) % 2 == 1:\\n                temp = current[0:midIndex + 1] + current[midIndex] + current[midIndex + 1:]\\n                baseCase.append(temp)\\n                flag, num = self.isMirrorBase10(temp, k)\\n                if flag:\\n                    total += num\\n                    cnt += 1\\n                    if cnt >= n:\\n                        return total\\n            else:\\n                for i in range(0, k):\\n                    temp = current[0:midIndex] + str(i) + current[midIndex:]\\n                    baseCase.append(temp)\\n                    flag, num = self.isMirrorBase10(temp, k)\\n                    if flag:\\n                        total += num\\n                        cnt += 1\\n                        if cnt >= n:\\n                            return total\\n            index += 1\\n        return total\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isMirrorBase10(self, temp, k):\\n        num = int(temp, k)\\n        if str(num) == str(num)[::-1]:\\n            return True, num\\n        else:\\n            return False, num\\n\\n    def kMirror(self, k: int, n: int) -> int:\\n        if n < k:\\n            total = 0\\n            for i in range(1, n+1):\\n                total += i\\n            return total\\n        baseCase = [str(i) for i in range(1, k)] #base case from 1 to k - 1\\n        index = 0\\n        total = 0\\n        for i in range(1, k):\\n            total += i\\n        cnt = k - 1\\n        while True:\\n            # current = baseCase.pop(0) #don\\'t use this, lead to TLE, since pop requires O(n)\\n            current = baseCase[index]\\n            midIndex = len(current) // 2\\n            if len(current) % 2 == 1:\\n                temp = current[0:midIndex + 1] + current[midIndex] + current[midIndex + 1:]\\n                baseCase.append(temp)\\n                flag, num = self.isMirrorBase10(temp, k)\\n                if flag:\\n                    total += num\\n                    cnt += 1\\n                    if cnt >= n:\\n                        return total\\n            else:\\n                for i in range(0, k):\\n                    temp = current[0:midIndex] + str(i) + current[midIndex:]\\n                    baseCase.append(temp)\\n                    flag, num = self.isMirrorBase10(temp, k)\\n                    if flag:\\n                        total += num\\n                        cnt += 1\\n                        if cnt >= n:\\n                            return total\\n            index += 1\\n        return total\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1589162,
                "title": "intuitive-generating-next-palindromic-bit-by-even-odd-length-golang",
                "content": "we only want palindromic base k bits, the base 10 decimal we can manually verify.\\n\\nif we are at bit size of even length, then the next combinations would be from inserting a bit from 0 to k-1 in the middle.\\n\\nif we are at bit size of odd length, then the next combinations would be simply mirroring the middle bit.\\n\\nwe do not need to sort the integers since we are generating them in order using the queue to maintain insertion order (fifo)\\n\\n```\\n\\nfunc kMirror(k int, n int) int64 {\\n    queue := make([]string, 0)\\n    for i := 1; i<k; i++ {\\n        queue = append(queue, fmt.Sprint(i))\\n    }\\n    cnt := 0\\n    var sum int64\\n    for cnt < n {\\n        cur := queue[0]\\n        queue = queue[1:]\\n        x, _ := strconv.ParseInt(cur, k, 64)\\n        str := fmt.Sprint(x)\\n        ok := true\\n        for i := 0; i<len(str)/2; i++ {\\n            if str[i] != str[len(str)-1-i] {\\n                ok = false\\n                break\\n            }\\n        }\\n        if ok {\\n            cnt++\\n            val, _ := strconv.ParseInt(str, 10, 64)\\n            sum += val\\n        }\\n        // find the nexts\\n        a := len(cur)\\n        if a % 2 == 0 {  // even\\n            for i := 0; i<k; i++ {\\n                queue = append(queue, cur[:a/2] + fmt.Sprint(i) + cur[a/2:])\\n            }\\n        } else {  // odd\\n            queue = append(queue, cur[:a/2] + string(cur[a/2]) + cur[a/2:])\\n        }\\n    }\\n    \\n    return sum\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nfunc kMirror(k int, n int) int64 {\\n    queue := make([]string, 0)\\n    for i := 1; i<k; i++ {\\n        queue = append(queue, fmt.Sprint(i))\\n    }\\n    cnt := 0\\n    var sum int64\\n    for cnt < n {\\n        cur := queue[0]\\n        queue = queue[1:]\\n        x, _ := strconv.ParseInt(cur, k, 64)\\n        str := fmt.Sprint(x)\\n        ok := true\\n        for i := 0; i<len(str)/2; i++ {\\n            if str[i] != str[len(str)-1-i] {\\n                ok = false\\n                break\\n            }\\n        }\\n        if ok {\\n            cnt++\\n            val, _ := strconv.ParseInt(str, 10, 64)\\n            sum += val\\n        }\\n        // find the nexts\\n        a := len(cur)\\n        if a % 2 == 0 {  // even\\n            for i := 0; i<k; i++ {\\n                queue = append(queue, cur[:a/2] + fmt.Sprint(i) + cur[a/2:])\\n            }\\n        } else {  // odd\\n            queue = append(queue, cur[:a/2] + string(cur[a/2]) + cur[a/2:])\\n        }\\n    }\\n    \\n    return sum\\n}\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1589140,
                "title": "python-itertools-product-saved-my-day",
                "content": "Python brute force. Using itertools.product can greatly reduce the coding complexity.\\n\\n```python\\ndigits = [str(i) for i in range(10)]\\nclass Solution:\\n    def convert_baseK_to_base10(self, s, k):\\n        ret = 0\\n        for c in s:\\n            ret *= k\\n            ret += int(c)\\n        return ret\\n\\n    \\n    def is_mirror_base10_number(self, s):\\n        k = len(s) // 2\\n        return len(s) == 1 or s[:k] == s[-k:][::-1]\\n        \\n            \\n    def get_this_length_ret(self, length_, k):\\n        \"\"\"\\n        Get mirror numbers with lenght of length_\\n        \"\"\"\\n        if length_ == 1:return list(range(1, k))\\n\\t\\t# construct all possible candidates for left mirror, then the right will be the reverse of the candidate.\\n        left = (\"\".join(candidate) for candidate in list(itertools.product(digits[:k], repeat = length_ // 2)))\\n       \\n        if length_ % 2 == 0:\\n            ret = [element + element[::-1] for element in left]\\n        else:\\n            ret = [element + str(i) + element[::-1] for element in left \\n                                                    for i in range(k)]\\n        # check whether base k is valid\\n        ret = [self.convert_baseK_to_base10(element, k) for element in ret \\n                                        if element[0] != \"0\"]\\n        # check whether base 10 is valid\\n        ret = [element for element in ret \\n                       if self.is_mirror_base10_number(str(element))]\\n        return ret\\n            \\n    def kMirror(self, k: int, n: int) -> int:\\n        ret = []\\n\\t\\t# construct number with a specified length. \\n        for length_ in range(1, 1000000):\\n            ret += self.get_this_length_ret(length_, k)\\n            if len(ret) >= n:\\n                return sum(sorted(ret)[:n])\\n```",
                "solutionTags": [],
                "code": "```python\\ndigits = [str(i) for i in range(10)]\\nclass Solution:\\n    def convert_baseK_to_base10(self, s, k):\\n        ret = 0\\n        for c in s:\\n            ret *= k\\n            ret += int(c)\\n        return ret\\n\\n    \\n    def is_mirror_base10_number(self, s):\\n        k = len(s) // 2\\n        return len(s) == 1 or s[:k] == s[-k:][::-1]\\n        \\n            \\n    def get_this_length_ret(self, length_, k):\\n        \"\"\"\\n        Get mirror numbers with lenght of length_\\n        \"\"\"\\n        if length_ == 1:return list(range(1, k))\\n\\t\\t# construct all possible candidates for left mirror, then the right will be the reverse of the candidate.\\n        left = (\"\".join(candidate) for candidate in list(itertools.product(digits[:k], repeat = length_ // 2)))\\n       \\n        if length_ % 2 == 0:\\n            ret = [element + element[::-1] for element in left]\\n        else:\\n            ret = [element + str(i) + element[::-1] for element in left \\n                                                    for i in range(k)]\\n        # check whether base k is valid\\n        ret = [self.convert_baseK_to_base10(element, k) for element in ret \\n                                        if element[0] != \"0\"]\\n        # check whether base 10 is valid\\n        ret = [element for element in ret \\n                       if self.is_mirror_base10_number(str(element))]\\n        return ret\\n            \\n    def kMirror(self, k: int, n: int) -> int:\\n        ret = []\\n\\t\\t# construct number with a specified length. \\n        for length_ in range(1, 1000000):\\n            ret += self.get_this_length_ret(length_, k)\\n            if len(ret) >= n:\\n                return sum(sorted(ret)[:n])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3961238,
                "title": "python-itertools-product-base-k-generation",
                "content": "# Intuition\\nGenerate all base-k palindromes in order, then convert them to base 10 to check if they are also palidromes there\\n\\n# Approach\\nPalindromes come in two forms- even length and odd length. \\n\\nTo generate an even palindrome, first generate the first half of the palindrome, then mirror it around the middle. For k = 3, the palidromes of length 4 are\\n```\\n1001\\n1111\\n1221\\n2002\\n2112\\n2222\\n```\\nSo the values that have to be generated are:\\n```\\n10\\n11\\n12\\n20\\n21\\n22\\n```\\n\\n\\nItertools product can be used to generate these:\\n```py\\nfor product in itertools.product(range(k), repeat=<length of sequence>):\\n```\\nand skipping over values with leading 0\\'s\\n\\nOdd values can be generated in a similar method by removing the middle value of the front or the back\\n\\n\\n# Code\\n```\\nfrom itertools import product\\n\\nclass Solution:\\n    def kMirror(self, k: int, n: int) -> int:\\n\\n        sumOf = 0\\n        length = 1\\n\\n        while n:\\n            gen_len = (1 + length) // 2\\n            for x in product(range(k), repeat=gen_len):\\n                if x[0] == 0: continue\\n\\n                string_product = \\'\\'.join(str(val) for val in x)\\n\\n                curr = \\'\\'\\n                if length % 2 == 0:\\n                    curr = string_product + string_product[::-1]\\n                else:\\n                    curr = string_product[:-1] + string_product[::-1]\\n\\n                base10 = int(curr, k)\\n                \\n                if str(base10) == str(base10)[::-1]:\\n                    n -= 1\\n                    sumOf += base10\\n                    if n == 0:\\n                        break\\n            length += 1\\n\\n\\n        return sumOf\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Enumeration"
                ],
                "code": "```\\n1001\\n1111\\n1221\\n2002\\n2112\\n2222\\n```\n```\\n10\\n11\\n12\\n20\\n21\\n22\\n```\n```py\\nfor product in itertools.product(range(k), repeat=<length of sequence>):\\n```\n```\\nfrom itertools import product\\n\\nclass Solution:\\n    def kMirror(self, k: int, n: int) -> int:\\n\\n        sumOf = 0\\n        length = 1\\n\\n        while n:\\n            gen_len = (1 + length) // 2\\n            for x in product(range(k), repeat=gen_len):\\n                if x[0] == 0: continue\\n\\n                string_product = \\'\\'.join(str(val) for val in x)\\n\\n                curr = \\'\\'\\n                if length % 2 == 0:\\n                    curr = string_product + string_product[::-1]\\n                else:\\n                    curr = string_product[:-1] + string_product[::-1]\\n\\n                base10 = int(curr, k)\\n                \\n                if str(base10) == str(base10)[::-1]:\\n                    n -= 1\\n                    sumOf += base10\\n                    if n == 0:\\n                        break\\n            length += 1\\n\\n\\n        return sumOf\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3706238,
                "title": "0-ms-100-0-mb-100-im-boss-very-fast-solution-low-memory-d",
                "content": "Ez for me\\n\\n# Code\\n```\\nfunc reverse(x string) string{\\n    new := \"\"\\n    for i, _ := range x{\\n        new += string(x[len(x)-1-i])\\n    }\\n    return new\\n}\\nfunc kMirror(k int, n int) int64 {\\n    count := 1\\n    sum := 0\\n    counter_2 := 0\\n    for true{\\n        tr := strconv.Itoa(count) \\n        len_tr := len(tr)\\n        if len_tr>3 && tr[1]!= tr[len_tr-2]{\\n            count += 10\\n            continue\\n        } \\n        if len_tr>5 && tr[2]!= tr[len_tr-3]{\\n            count += 100\\n            continue\\n        } \\n        if len_tr>7 && tr[3]!= tr[len_tr-4]{\\n            count += 1000\\n            continue\\n        }\\n        if len_tr>9 && tr[4]!= tr[len_tr-5]{\\n            count += 10000\\n            continue\\n        } \\n        \\n        if string(tr[len_tr-1])==\"0\" || len_tr>1 && tr[0]!= tr[len_tr-1] || len_tr>3 && tr[1]!= tr[len_tr-2] || len_tr>5 && tr[2]!= tr[len_tr-3] || len_tr>7 && tr[3]!= tr[len_tr-4] || len_tr>9 && tr[4]!= tr[len_tr-5] {\\n            count += 1\\n            continue\\n        }\\n        num_enemy := strconv.FormatInt(int64(count), k)\\n        len_enemy := len(num_enemy)\\n        if string(num_enemy[len_enemy-1])==\"0\" || len_enemy>1 && num_enemy[0]!=num_enemy[len_enemy-1] || len_enemy>3 && num_enemy[1]!=num_enemy[len_enemy-2] || len_enemy>5 && num_enemy[2]!=num_enemy[len_enemy-3] || len_enemy>7 && num_enemy[3]!=num_enemy[len_enemy-4] || len_enemy>9 && num_enemy[4]!=num_enemy[len_enemy-5] {\\n           count += 1\\n           continue\\n        }\\n        if tr==reverse(tr) {\\n            if num_enemy==reverse(num_enemy){\\n            counter_2 += 1\\n            sum += count\\n            }\\n            if counter_2==n{\\n                break\\n            }\\n            \\n        }\\n        count += 1\\n    }\\n    return int64(sum)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc reverse(x string) string{\\n    new := \"\"\\n    for i, _ := range x{\\n        new += string(x[len(x)-1-i])\\n    }\\n    return new\\n}\\nfunc kMirror(k int, n int) int64 {\\n    count := 1\\n    sum := 0\\n    counter_2 := 0\\n    for true{\\n        tr := strconv.Itoa(count) \\n        len_tr := len(tr)\\n        if len_tr>3 && tr[1]!= tr[len_tr-2]{\\n            count += 10\\n            continue\\n        } \\n        if len_tr>5 && tr[2]!= tr[len_tr-3]{\\n            count += 100\\n            continue\\n        } \\n        if len_tr>7 && tr[3]!= tr[len_tr-4]{\\n            count += 1000\\n            continue\\n        }\\n        if len_tr>9 && tr[4]!= tr[len_tr-5]{\\n            count += 10000\\n            continue\\n        } \\n        \\n        if string(tr[len_tr-1])==\"0\" || len_tr>1 && tr[0]!= tr[len_tr-1] || len_tr>3 && tr[1]!= tr[len_tr-2] || len_tr>5 && tr[2]!= tr[len_tr-3] || len_tr>7 && tr[3]!= tr[len_tr-4] || len_tr>9 && tr[4]!= tr[len_tr-5] {\\n            count += 1\\n            continue\\n        }\\n        num_enemy := strconv.FormatInt(int64(count), k)\\n        len_enemy := len(num_enemy)\\n        if string(num_enemy[len_enemy-1])==\"0\" || len_enemy>1 && num_enemy[0]!=num_enemy[len_enemy-1] || len_enemy>3 && num_enemy[1]!=num_enemy[len_enemy-2] || len_enemy>5 && num_enemy[2]!=num_enemy[len_enemy-3] || len_enemy>7 && num_enemy[3]!=num_enemy[len_enemy-4] || len_enemy>9 && num_enemy[4]!=num_enemy[len_enemy-5] {\\n           count += 1\\n           continue\\n        }\\n        if tr==reverse(tr) {\\n            if num_enemy==reverse(num_enemy){\\n            counter_2 += 1\\n            sum += count\\n            }\\n            if counter_2==n{\\n                break\\n            }\\n            \\n        }\\n        count += 1\\n    }\\n    return int64(sum)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3704202,
                "title": "69th-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def kMirror(self, k: int, n: int) -> int:\\n        \\n        # start from single digit base k\\n        cands = [str(i) for i in range(1, k)]\\n        ans = 0\\n        \\n        while n > 0:\\n            # check current canddiates to see if base 10 is also mirroring\\n            for cand in cands:\\n                b10 = str(int(cand, k))\\n                if b10 == b10[::-1]:\\n                    ans += int(b10)\\n                    n -= 1\\n                    if n == 0: return ans\\n\\n            new_cands = []\\n            for cand in cands:\\n                m = len(cand)\\n                for i in range(k):\\n                    if m % 2 == 0:\\n                        new_cands.append(cand[:m//2] + str(i) + cand[m//2:])\\n                    else:\\n                        left, right = cand[:m//2+1], cand[m//2+1:]\\n                        if str(i) == left[-1]:\\n                            new_cands.append(left + str(i) + right)\\n            cands = new_cands\\n\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def kMirror(self, k: int, n: int) -> int:\\n        \\n        # start from single digit base k\\n        cands = [str(i) for i in range(1, k)]\\n        ans = 0\\n        \\n        while n > 0:\\n            # check current canddiates to see if base 10 is also mirroring\\n            for cand in cands:\\n                b10 = str(int(cand, k))\\n                if b10 == b10[::-1]:\\n                    ans += int(b10)\\n                    n -= 1\\n                    if n == 0: return ans\\n\\n            new_cands = []\\n            for cand in cands:\\n                m = len(cand)\\n                for i in range(k):\\n                    if m % 2 == 0:\\n                        new_cands.append(cand[:m//2] + str(i) + cand[m//2:])\\n                    else:\\n                        left, right = cand[:m//2+1], cand[m//2+1:]\\n                        if str(i) == left[-1]:\\n                            new_cands.append(left + str(i) + right)\\n            cands = new_cands\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3618682,
                "title": "java-time-beat-100-space-beat-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    private long ret;\\n    private int count;\\n    private int k;\\n    private int n;\\n\\n    public long kMirror(int k, int n) {\\n        ret = 0;\\n        count = 0;\\n        this.k = k;\\n        this.n = n;\\n\\n        for (int digit = 1; count < n; digit++) {\\n            travelTenMirrorNumber((long)Math.pow(10, digit - 1), 1, 0);\\n        }\\n\\n        return ret;\\n    }\\n\\n    private void travelTenMirrorNumber(long highFactor, long lowFactor, long sum) {\\n        if (highFactor < lowFactor) {\\n            if (isKMirror(k, sum)) {\\n                ret += sum;\\n                count++;\\n            }\\n        } else {\\n            int digit = lowFactor == 1 ? 1 : 0;\\n            while (count < n && digit < 10) {\\n                travelTenMirrorNumber(highFactor / 10, lowFactor * 10, sum + digit++ * (highFactor == lowFactor ? highFactor : highFactor + lowFactor));\\n            }\\n        }\\n    }\\n\\n    private boolean isKMirror(int k, long num) {\\n        long high = (long)Math.pow(k, (int)(Math.log(num)/Math.log(k)));\\n        long low = k;\\n        while (num > 0) {\\n            if (num / high != num % low) {\\n                return false;\\n            }\\n            num = num % high / low;\\n            high /= k * k;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    private long ret;\\n    private int count;\\n    private int k;\\n    private int n;\\n\\n    public long kMirror(int k, int n) {\\n        ret = 0;\\n        count = 0;\\n        this.k = k;\\n        this.n = n;\\n\\n        for (int digit = 1; count < n; digit++) {\\n            travelTenMirrorNumber((long)Math.pow(10, digit - 1), 1, 0);\\n        }\\n\\n        return ret;\\n    }\\n\\n    private void travelTenMirrorNumber(long highFactor, long lowFactor, long sum) {\\n        if (highFactor < lowFactor) {\\n            if (isKMirror(k, sum)) {\\n                ret += sum;\\n                count++;\\n            }\\n        } else {\\n            int digit = lowFactor == 1 ? 1 : 0;\\n            while (count < n && digit < 10) {\\n                travelTenMirrorNumber(highFactor / 10, lowFactor * 10, sum + digit++ * (highFactor == lowFactor ? highFactor : highFactor + lowFactor));\\n            }\\n        }\\n    }\\n\\n    private boolean isKMirror(int k, long num) {\\n        long high = (long)Math.pow(k, (int)(Math.log(num)/Math.log(k)));\\n        long low = k;\\n        while (num > 0) {\\n            if (num / high != num % low) {\\n                return false;\\n            }\\n            num = num % high / low;\\n            high /= k * k;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3301701,
                "title": "c-concise-2800ms",
                "content": "slow, but works.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long kMirror(int k, int n) {\\n        vector<long long> v;\\n        for(int i=1;v.size()<=n+3;i++){\\n            for(const auto& xp : genPalin(i)){\\n                if(isPalinK(xp, k)) v.push_back(xp);\\n            }\\n        }\\n        sort(v.begin(), v.end());\\n        return accumulate(begin(v), begin(v)+n, 0LL);\\n    }\\n\\n    array<long long, 2> genPalin(long long x){\\n        long long reverse = 0, factor = 1;\\n        for(auto y = x; y; y/=10, factor*=10)\\n            reverse =  reverse*10 +y%10;\\n        return {(x/10)*factor+reverse, x*factor+reverse}; \\n    }\\n\\n    bool isPalinK(long long x, int base){\\n        long long reverse = 0;\\n        for(auto y = x; y; y/=base)\\n            reverse = reverse*base + y%base;\\n        return reverse == x;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long kMirror(int k, int n) {\\n        vector<long long> v;\\n        for(int i=1;v.size()<=n+3;i++){\\n            for(const auto& xp : genPalin(i)){\\n                if(isPalinK(xp, k)) v.push_back(xp);\\n            }\\n        }\\n        sort(v.begin(), v.end());\\n        return accumulate(begin(v), begin(v)+n, 0LL);\\n    }\\n\\n    array<long long, 2> genPalin(long long x){\\n        long long reverse = 0, factor = 1;\\n        for(auto y = x; y; y/=10, factor*=10)\\n            reverse =  reverse*10 +y%10;\\n        return {(x/10)*factor+reverse, x*factor+reverse}; \\n    }\\n\\n    bool isPalinK(long long x, int base){\\n        long long reverse = 0;\\n        for(auto y = x; y; y/=base)\\n            reverse = reverse*base + y%base;\\n        return reverse == x;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3250862,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn k_mirror(k: i32, n: i32) -> i64 {\\n        fn to_number(vec: &[i32], base: i32) -> i64 {\\n            vec.iter().rev().fold(0, |acc, &v| acc * base as i64 + v as i64)\\n        }\\n\\n        fn next(vec: &mut Vec<i32>, base: i32) {\\n            let mut i = (vec.len() as i32 - 1) / 2;\\n            let mut j = vec.len() as i32 / 2;\\n            while j != vec.len() as i32 {\\n                if vec[i as usize] + 1 == base {\\n                    vec[i as usize] = 0;\\n                    vec[j as usize] = 0;\\n                    i -= 1;\\n                    j += 1;\\n                } else {\\n                    vec[i as usize] += 1;\\n                    vec[j as usize] = vec[i as usize];\\n                    return;\\n                }\\n            }\\n            vec.push(1);\\n            vec[0] = 1;\\n        }\\n\\n        let mut basek = vec![1];\\n        let mut base10 = vec![1];\\n        let mut ret = 0;\\n        let mut i = 0;\\n        while i != n {\\n            let bk = to_number(&basek, k);\\n            let b10 = to_number(&base10, 10);\\n            match bk.cmp(&b10) {\\n                std::cmp::Ordering::Less => next(&mut basek, k),\\n                std::cmp::Ordering::Greater => next(&mut base10, 10),\\n                std::cmp::Ordering::Equal => {\\n                    ret += bk;\\n                    next(&mut basek, k);\\n                    i += 1;\\n                }\\n            }\\n        }\\n        ret\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn k_mirror(k: i32, n: i32) -> i64 {\\n        fn to_number(vec: &[i32], base: i32) -> i64 {\\n            vec.iter().rev().fold(0, |acc, &v| acc * base as i64 + v as i64)\\n        }\\n\\n        fn next(vec: &mut Vec<i32>, base: i32) {\\n            let mut i = (vec.len() as i32 - 1) / 2;\\n            let mut j = vec.len() as i32 / 2;\\n            while j != vec.len() as i32 {\\n                if vec[i as usize] + 1 == base {\\n                    vec[i as usize] = 0;\\n                    vec[j as usize] = 0;\\n                    i -= 1;\\n                    j += 1;\\n                } else {\\n                    vec[i as usize] += 1;\\n                    vec[j as usize] = vec[i as usize];\\n                    return;\\n                }\\n            }\\n            vec.push(1);\\n            vec[0] = 1;\\n        }\\n\\n        let mut basek = vec![1];\\n        let mut base10 = vec![1];\\n        let mut ret = 0;\\n        let mut i = 0;\\n        while i != n {\\n            let bk = to_number(&basek, k);\\n            let b10 = to_number(&base10, 10);\\n            match bk.cmp(&b10) {\\n                std::cmp::Ordering::Less => next(&mut basek, k),\\n                std::cmp::Ordering::Greater => next(&mut base10, 10),\\n                std::cmp::Ordering::Equal => {\\n                    ret += bk;\\n                    next(&mut basek, k);\\n                    i += 1;\\n                }\\n            }\\n        }\\n        ret\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2860996,
                "title": "python-short-solution-maintain-half-to-generate-all-possible-palindromes",
                "content": "the solution for serching in **k-base** integer:\\n\\n```\\ndef kMirror(self, k: int, n: int) -> int:\\n\\ts, cans = 0, [str(x) for x in range(1, k)]\\n\\th = [str(x)+str(i) for x in cans for i in range(k)]\\n\\tcans += [e for e in h if e==e[::-1]]   # length-1 and length-2 requires seperate  investigation\\n\\twhile(n):\\n\\t\\tfor x in cans:\\n\\t\\t\\tnx = int(x, k)\\n\\t\\t\\tif str(nx)==str(nx)[::-1]:\\n\\t\\t\\t\\ts += nx\\n\\t\\t\\t\\tn -= 1\\n\\t\\t\\tif n==0:\\n\\t\\t\\t\\treturn s\\n\\t\\tcans = [e+e[:-1][::-1] for e in h] # odd-length palindrome\\n\\t\\tcans += [e+e[::-1] for e in h]     # even-lenth palindrome \\n\\t\\th = [e+str(i) for e in h for i in range(k)]  # incremente the half number\\n```\\n\\nthe solution for serching in **10-base** integer:\\n\\n```\\ndef kMirror(self, k: int, n: int) -> int:\\n\\tdef valid(x, k):\\n\\t\\tans = \\'\\'\\n\\t\\twhile(x):\\n\\t\\t\\tans += str(x%k)\\n\\t\\t\\tx //= k\\n\\t\\treturn ans==ans[::-1]\\n\\n\\tdef gen_palindrome(t, odd):\\n\\t\\tans = t\\n\\t\\tif odd:\\n\\t\\t\\tt = t//10\\n\\t\\twhile(t):\\n\\t\\t\\tans = ans*10+t%10\\n\\t\\t\\tt //= 10\\n\\t\\treturn ans\\n\\n\\tdef check(lo, odd, s, m):\\n\\t\\tfor x in range(lo, lo*10):\\n\\t\\t\\tx = gen_palindrome(x, odd)\\n\\t\\t\\tif valid(x, k):\\n\\t\\t\\t\\tm -= 1\\n\\t\\t\\t\\ts += x\\n\\t\\t\\tif m==0:\\n\\t\\t\\t\\tbreak\\n\\t\\treturn s, m\\n\\n\\tleft, s = 1, 0\\n\\twhile(n):\\n\\t\\ts, n = check(left, True, s, n)\\n\\t\\ts, n = check(left, False, s, n)\\n\\t\\tleft *= 10\\n\\treturn s\\n```",
                "solutionTags": [],
                "code": "```\\ndef kMirror(self, k: int, n: int) -> int:\\n\\ts, cans = 0, [str(x) for x in range(1, k)]\\n\\th = [str(x)+str(i) for x in cans for i in range(k)]\\n\\tcans += [e for e in h if e==e[::-1]]   # length-1 and length-2 requires seperate  investigation\\n\\twhile(n):\\n\\t\\tfor x in cans:\\n\\t\\t\\tnx = int(x, k)\\n\\t\\t\\tif str(nx)==str(nx)[::-1]:\\n\\t\\t\\t\\ts += nx\\n\\t\\t\\t\\tn -= 1\\n\\t\\t\\tif n==0:\\n\\t\\t\\t\\treturn s\\n\\t\\tcans = [e+e[:-1][::-1] for e in h] # odd-length palindrome\\n\\t\\tcans += [e+e[::-1] for e in h]     # even-lenth palindrome \\n\\t\\th = [e+str(i) for e in h for i in range(k)]  # incremente the half number\\n```\n```\\ndef kMirror(self, k: int, n: int) -> int:\\n\\tdef valid(x, k):\\n\\t\\tans = \\'\\'\\n\\t\\twhile(x):\\n\\t\\t\\tans += str(x%k)\\n\\t\\t\\tx //= k\\n\\t\\treturn ans==ans[::-1]\\n\\n\\tdef gen_palindrome(t, odd):\\n\\t\\tans = t\\n\\t\\tif odd:\\n\\t\\t\\tt = t//10\\n\\t\\twhile(t):\\n\\t\\t\\tans = ans*10+t%10\\n\\t\\t\\tt //= 10\\n\\t\\treturn ans\\n\\n\\tdef check(lo, odd, s, m):\\n\\t\\tfor x in range(lo, lo*10):\\n\\t\\t\\tx = gen_palindrome(x, odd)\\n\\t\\t\\tif valid(x, k):\\n\\t\\t\\t\\tm -= 1\\n\\t\\t\\t\\ts += x\\n\\t\\t\\tif m==0:\\n\\t\\t\\t\\tbreak\\n\\t\\treturn s, m\\n\\n\\tleft, s = 1, 0\\n\\twhile(n):\\n\\t\\ts, n = check(left, True, s, n)\\n\\t\\ts, n = check(left, False, s, n)\\n\\t\\tleft *= 10\\n\\treturn s\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2825779,
                "title": "easy-to-understand-simple-c-code",
                "content": "```\\nclass Solution {\\npublic:\\n     long long makePalindromeBase10(long long n, bool isOddSize) {\\n        long long x = n;\\n        // strip the lsb number \\n        // abc will be made palindrome as abcba make last element as pivot\\n        // for odd size no strippng abc will be made palindrome as abccba \\n        if (isOddSize) x = x/10;\\n        while(x) {\\n            n = n*10 + (x%10);\\n            x = x/10;\\n        }\\n        return n;\\n    }\\n    // function to convert a number to new base in string\\n    void convertToBase(long long n, int base, string &baseStr) {\\n        while(n) {\\n            baseStr += n%base + \\'0\\';\\n            n = n/base;\\n        }\\n    }\\n    // function to check palindrome\\n    bool isPalindrome(string &baseStr) {\\n        int l = 0; int r = baseStr.length()-1;\\n        while(l < r) {\\n            if (baseStr[l++] != baseStr[r--]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    long long kMirror(int k, int n) {\\n        long long sum = 0;\\n        long long numDigit = 1;\\n        while (n) {\\n            // check for current series from number to next 10\\'s i.e 1 to 10 or 10 to 100 so on..\\n            int maxDigitNum = numDigit*10;\\n            // check for odd digits, means previous iteration digitsize + 1;\\n            // try for smaller palindrome which is odd size as lsb is made pivot\\n            for (long long i = numDigit; n && (i < maxDigitNum); i++) {\\n                long long num = makePalindromeBase10(i,true);\\n                string baseStr;\\n                convertToBase(num,k,baseStr);\\n                if (isPalindrome(baseStr)) {\\n                    sum += num;\\n                    n--;\\n                }\\n            }\\n            \\n            // now Check for even digits, means previous iteration digitsize + 2;\\n            // check for odd digits, means previous iteration digitsize + 1;\\n            // try for bigger palindrome which is even size as middle 2 numbers are pivot\\n            for (long long i = numDigit; n && (i < maxDigitNum); i++) {\\n                long long num = makePalindromeBase10(i,false);\\n                string baseStr;\\n                convertToBase(num,k,baseStr);\\n                if (isPalindrome(baseStr)) {\\n                    sum += num;\\n                    n--;\\n                }\\n            }\\n            numDigit = maxDigitNum;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n     long long makePalindromeBase10(long long n, bool isOddSize) {\\n        long long x = n;\\n        // strip the lsb number \\n        // abc will be made palindrome as abcba make last element as pivot\\n        // for odd size no strippng abc will be made palindrome as abccba \\n        if (isOddSize) x = x/10;\\n        while(x) {\\n            n = n*10 + (x%10);\\n            x = x/10;\\n        }\\n        return n;\\n    }\\n    // function to convert a number to new base in string\\n    void convertToBase(long long n, int base, string &baseStr) {\\n        while(n) {\\n            baseStr += n%base + \\'0\\';\\n            n = n/base;\\n        }\\n    }\\n    // function to check palindrome\\n    bool isPalindrome(string &baseStr) {\\n        int l = 0; int r = baseStr.length()-1;\\n        while(l < r) {\\n            if (baseStr[l++] != baseStr[r--]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    long long kMirror(int k, int n) {\\n        long long sum = 0;\\n        long long numDigit = 1;\\n        while (n) {\\n            // check for current series from number to next 10\\'s i.e 1 to 10 or 10 to 100 so on..\\n            int maxDigitNum = numDigit*10;\\n            // check for odd digits, means previous iteration digitsize + 1;\\n            // try for smaller palindrome which is odd size as lsb is made pivot\\n            for (long long i = numDigit; n && (i < maxDigitNum); i++) {\\n                long long num = makePalindromeBase10(i,true);\\n                string baseStr;\\n                convertToBase(num,k,baseStr);\\n                if (isPalindrome(baseStr)) {\\n                    sum += num;\\n                    n--;\\n                }\\n            }\\n            \\n            // now Check for even digits, means previous iteration digitsize + 2;\\n            // check for odd digits, means previous iteration digitsize + 1;\\n            // try for bigger palindrome which is even size as middle 2 numbers are pivot\\n            for (long long i = numDigit; n && (i < maxDigitNum); i++) {\\n                long long num = makePalindromeBase10(i,false);\\n                string baseStr;\\n                convertToBase(num,k,baseStr);\\n                if (isPalindrome(baseStr)) {\\n                    sum += num;\\n                    n--;\\n                }\\n            }\\n            numDigit = maxDigitNum;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2699452,
                "title": "python3",
                "content": "class Solution:\\n\\n    def kMirror(self, k: int, n: int) -> int:\\n        def nextBaseKPalindrome(x):\\n            lenX = len(x)\\n            n = lenX//2\\n            for i in range(n,lenX):\\n                if int(x[i])+1<k:\\n                    x[i] = x[~i] = str(int(x[i])+1)\\n                    for j in range(n,i):\\n                        x[j] = x[~j] = \\'0\\'\\n                    return x\\n            return [\\'1\\'] + (lenX-1)*[\\'0\\'] + [\\'1\\']\\n        \\n        def isPalindrome(y):\\n            val,z = 0,y\\n            while z:\\n                val = val*10+ z%10\\n                z//=10\\n            return val == y\\n        \\n        x = [\\'0\\']\\n        res = 0\\n        \\n        for _ in range(n):\\n            while True:\\n                x = nextBaseKPalindrome(x)\\n                decimalValue = int(\\'\\'.join(x),k)\\n                if isPalindrome(decimalValue):\\n                    res+=decimalValue\\n                    break\\n        return res",
                "solutionTags": [],
                "code": "class Solution:\\n\\n    def kMirror(self, k: int, n: int) -> int:\\n        def nextBaseKPalindrome(x):\\n            lenX = len(x)\\n            n = lenX//2\\n            for i in range(n,lenX):\\n                if int(x[i])+1<k:\\n                    x[i] = x[~i] = str(int(x[i])+1)\\n                    for j in range(n,i):\\n                        x[j] = x[~j] = \\'0\\'\\n                    return x\\n            return [\\'1\\'] + (lenX-1)*[\\'0\\'] + [\\'1\\']\\n        \\n        def isPalindrome(y):\\n            val,z = 0,y\\n            while z:\\n                val = val*10+ z%10\\n                z//=10\\n            return val == y\\n        \\n        x = [\\'0\\']\\n        res = 0\\n        \\n        for _ in range(n):\\n            while True:\\n                x = nextBaseKPalindrome(x)\\n                decimalValue = int(\\'\\'.join(x),k)\\n                if isPalindrome(decimalValue):\\n                    res+=decimalValue\\n                    break\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 2671178,
                "title": "python-solution-faster-90",
                "content": "\\tclass Solution:\\n\\t\\tdef kMirror(self, k: int, n: int) -> int:\\n\\n\\t\\t\\tdef fn(x):\\n\\t\\t\\t\\t\"\"\"Return next k-symmetric number.\"\"\"\\n\\t\\t\\t\\tn = len(x)//2\\n\\t\\t\\t\\tfor i in range(n, len(x)): \\n\\t\\t\\t\\t\\tif int(x[i])+1 < k: \\n\\t\\t\\t\\t\\t\\tx[i] = x[~i] = str(int(x[i])+1)\\n\\t\\t\\t\\t\\t\\tfor ii in range(n, i): x[ii] = x[~ii] = \\'0\\'\\n\\t\\t\\t\\t\\t\\treturn x\\n\\t\\t\\t\\treturn [\"1\"] + [\"0\"]*(len(x)-1) + [\"1\"]\\n\\n\\t\\t\\tx = [\"0\"]\\n\\t\\t\\tans = 0\\n\\t\\t\\tfor _ in range(n): \\n\\t\\t\\t\\twhile True: \\n\\t\\t\\t\\t\\tx = fn(x)\\n\\t\\t\\t\\t\\tval = int(\"\".join(x), k)\\n\\t\\t\\t\\t\\tif str(val)[::-1] == str(val): break\\n\\t\\t\\t\\tans += val\\n\\t\\t\\treturn ans",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef kMirror(self, k: int, n: int) -> int:\\n\\n\\t\\t\\tdef fn(x):\\n\\t\\t\\t\\t\"\"\"Return next k-symmetric number.\"\"\"\\n\\t\\t\\t\\tn = len(x)//2\\n\\t\\t\\t\\tfor i in range(n, len(x)): \\n\\t\\t\\t\\t\\tif int(x[i])+1 < k: \\n\\t\\t\\t\\t\\t\\tx[i] = x[~i] = str(int(x[i])+1)\\n\\t\\t\\t\\t\\t\\tfor ii in range(n, i): x[ii] = x[~ii] = \\'0\\'\\n\\t\\t\\t\\t\\t\\treturn x\\n\\t\\t\\t\\treturn [\"1\"] + [\"0\"]*(len(x)-1) + [\"1\"]\\n\\n\\t\\t\\tx = [\"0\"]\\n\\t\\t\\tans = 0\\n\\t\\t\\tfor _ in range(n): \\n\\t\\t\\t\\twhile True: \\n\\t\\t\\t\\t\\tx = fn(x)\\n\\t\\t\\t\\t\\tval = int(\"\".join(x), k)\\n\\t\\t\\t\\t\\tif str(val)[::-1] == str(val): break\\n\\t\\t\\t\\tans += val\\n\\t\\t\\treturn ans",
                "codeTag": "Java"
            },
            {
                "id": 2658257,
                "title": "javascript-solution-with-nested-generators-100-faster-in-space-and-time",
                "content": "Generators are great ways of iterating through a sequence that you don\\'t know how long it is or what is in it, but \"calculate as you go\"\\n\\nSo why not have generators walking us through the base 10 and base K space of mirrored numbers? \\n\\nPsuedocode:\\n\\n```\\nInitalize iterators for base 10 and base k mirror digits\\n\\nWhile I don\\'t have N mirrors that are equal:\\n  are my current iterators equal?\\n     Great, add it to the sum and count\\n  is the current base10 mirror less than the current base k mirror?\\n    get the next base 10\\n  otherwise\\n    get the next base K\\n```\\n\\n```\\n/**\\n * @param {number} k\\n * @param {number} n\\n * @return {number}\\n */\\nvar kMirror = function(k, n) {\\n    var innerBaseMirrorGen = function*(base, baseNum, nDigits, dIdx) {\\n        const mid = (nDigits - 1) / 2\\n        if (mid === dIdx) {\\n            // odd number of digits with the middle column - iterate through the bases\\n            let m = Math.pow(base, dIdx)\\n            for (let i = 0; i < base; i++) {\\n                yield baseNum + (i * m)\\n            }\\n        } else if (nDigits % 2 === 0 && nDigits / 2 === dIdx) {\\n            // even case where we crossed the middle\\n            yield baseNum\\n        } else {\\n            // default case were we increase mirrors of digits\\n\\t\\t\\t// eg base: 10 baseNum: 0, nDigits: 3 -> 101, 202, 303, etc.\\n\\t\\t\\t// eg base: 10, baseNum 310013, nDigits: 6, dIdx: 2 -> 310013, 311113, 312213, etc.\\n            const ma = Math.pow(base, mid + (mid - dIdx))\\n            const mb = Math.pow(base, mid - (mid - dIdx))\\n            for (let i = baseNum === 0 ? 1 : 0; i < base; i++) {\\n                yield* innerBaseMirrorGen(base, baseNum + (i * ma) + (i * mb), nDigits, dIdx + 1)\\n            }\\n        }\\n    }\\n    \\n    var base10Mirrors = function*() {\\n        let nDigits = 1\\n        while (true) {\\n            yield* innerBaseMirrorGen(10, 0, nDigits, 0)\\n            nDigits++\\n        }\\n    }\\n    \\n    var baseKMirrors = function*() {\\n        let nDigits = 1\\n        while (true) {\\n            yield* innerBaseMirrorGen(k, 0, nDigits, 0)\\n            nDigits++\\n        }\\n    }\\n    \\n    let foundCount = -1 // generations start at 0, simply handle it by starting with -1\\n    let sum = 0\\n    const base10MirrorSeq = base10Mirrors()\\n    const baseKMirrorSeq = baseKMirrors()\\n    let base10Iter = base10MirrorSeq.next().value\\n    let baseKIter = baseKMirrorSeq.next().value\\n    \\n    do {\\n        if (base10Iter === baseKIter) {\\n            sum += base10Iter\\n            foundCount++\\n            base10Iter = base10MirrorSeq.next().value\\n            baseKIter = baseKMirrorSeq.next().value\\n        } else if (base10Iter < baseKIter) {\\n            base10Iter = base10MirrorSeq.next().value\\n        } else {\\n            baseKIter = baseKMirrorSeq.next().value\\n        }\\n    } while (foundCount < n)\\n        \\n    return sum\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nInitalize iterators for base 10 and base k mirror digits\\n\\nWhile I don\\'t have N mirrors that are equal:\\n  are my current iterators equal?\\n     Great, add it to the sum and count\\n  is the current base10 mirror less than the current base k mirror?\\n    get the next base 10\\n  otherwise\\n    get the next base K\\n```\n```\\n/**\\n * @param {number} k\\n * @param {number} n\\n * @return {number}\\n */\\nvar kMirror = function(k, n) {\\n    var innerBaseMirrorGen = function*(base, baseNum, nDigits, dIdx) {\\n        const mid = (nDigits - 1) / 2\\n        if (mid === dIdx) {\\n            // odd number of digits with the middle column - iterate through the bases\\n            let m = Math.pow(base, dIdx)\\n            for (let i = 0; i < base; i++) {\\n                yield baseNum + (i * m)\\n            }\\n        } else if (nDigits % 2 === 0 && nDigits / 2 === dIdx) {\\n            // even case where we crossed the middle\\n            yield baseNum\\n        } else {\\n            // default case were we increase mirrors of digits\\n\\t\\t\\t// eg base: 10 baseNum: 0, nDigits: 3 -> 101, 202, 303, etc.\\n\\t\\t\\t// eg base: 10, baseNum 310013, nDigits: 6, dIdx: 2 -> 310013, 311113, 312213, etc.\\n            const ma = Math.pow(base, mid + (mid - dIdx))\\n            const mb = Math.pow(base, mid - (mid - dIdx))\\n            for (let i = baseNum === 0 ? 1 : 0; i < base; i++) {\\n                yield* innerBaseMirrorGen(base, baseNum + (i * ma) + (i * mb), nDigits, dIdx + 1)\\n            }\\n        }\\n    }\\n    \\n    var base10Mirrors = function*() {\\n        let nDigits = 1\\n        while (true) {\\n            yield* innerBaseMirrorGen(10, 0, nDigits, 0)\\n            nDigits++\\n        }\\n    }\\n    \\n    var baseKMirrors = function*() {\\n        let nDigits = 1\\n        while (true) {\\n            yield* innerBaseMirrorGen(k, 0, nDigits, 0)\\n            nDigits++\\n        }\\n    }\\n    \\n    let foundCount = -1 // generations start at 0, simply handle it by starting with -1\\n    let sum = 0\\n    const base10MirrorSeq = base10Mirrors()\\n    const baseKMirrorSeq = baseKMirrors()\\n    let base10Iter = base10MirrorSeq.next().value\\n    let baseKIter = baseKMirrorSeq.next().value\\n    \\n    do {\\n        if (base10Iter === baseKIter) {\\n            sum += base10Iter\\n            foundCount++\\n            base10Iter = base10MirrorSeq.next().value\\n            baseKIter = baseKMirrorSeq.next().value\\n        } else if (base10Iter < baseKIter) {\\n            base10Iter = base10MirrorSeq.next().value\\n        } else {\\n            baseKIter = baseKMirrorSeq.next().value\\n        }\\n    } while (foundCount < n)\\n        \\n    return sum\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2290346,
                "title": "swift-generate-base-10-numbers-then-check-base-k",
                "content": "# Idea:\\n- generate base 10 palindromic numbers by digit (this will keep order, and make sure to pick first n numbers)\\n  - check from digit 1, 2, 3, 4, ...\\n  - by pass d, generate possible  `2d` and `2d-1`  digits number\\n\\t  - ex: d = 1, generate digits 1 and digits 2 numbers\\n\\t  - d = 2, generate digits 3 and digits 4 numbers\\n\\t  - d = 3, generate digits 4, and digits 5 numbers\\n\\t  - ...\\n\\t- in generate function, use `odd` and `even` array to keep track current odd digits and even digits generated numbers\\n\\t\\t- by build `odd` digits array, it can re-use previous `even` array results, ex: `digits 3` can generate from `digits 2` \\n\\t\\t\\t- digits 2: 11, 22, 33, 44, ...\\n\\t\\t\\t- digits 3: 101, 111, ... , 191, 202, 212, ...\\n\\t\\t- by build `even` digits array, it can use `current odd` array results, ex: `digits 4` can generate from `digits 3`\\n\\t\\t\\t- digits 3: 101, 111, ... , 191, 202, 212, ...\\n\\t\\t\\t- digits 4: 1001, 1111, ... , 1991, 2002, 2112, ...\\n\\t\\t- d=1 will be unique, we give the default odd and even array when d=1. It is because d=1 will never use `0` number\\n- for each base 10 numbers, check if its valid base k mirror number\\n  - use normal 2 pointer method to check backward and foreward in same time\\xA0\\n  - in the meanwhile, keep track if we find all  `n` numbers\\n\\n# Complexity\\n- Time Complexity: `O(pow(10*d))`\\n\\t- d will be the half digits of the final number(largest n number)\\n- Space Complexity: `O(d)`\\n\\n# Code\\n\\n ```\\nclass Solution {\\n    func kMirror(_ k: Int, _ n: Int) -> Int {\\n        var d = 1\\n\\n        // count of remain wait for being found number\\n        var n = n\\n\\n        // sum of finded numbers\\n        var sum = 0\\n\\n        // odd digits palindromic base10 numbers\\n        var odd = [Int]()\\n        // even digits palindromic base10 numbers\\n        var even = [Int]()\\n\\n        while n > 0 {\\n            // check 2d and 2d-1\\n            // generated palindromic base10 numbers\\n            genBaseTen(d, &odd, &even)\\n            let baseTen = odd+even\\n            // print(baseTen)\\n            for num in baseTen {\\n                // check if number is also baseK mirror number\\n                if checkBaseK(num, k) {\\n                    sum += num\\n                    n -= 1\\n                    if n == 0 { return sum }\\n                }\\n            }\\n\\n            // update d for next searching\\n            d += 1\\n        }\\n\\n        return sum\\n    }\\n\\n    // generate palindromic base 10 numbers\\n    // with 2d and 2d-1 digits\\n    // return generate number by sorted\\n    func genBaseTen(_ d: Int,\\n                    _ odd: inout [Int],\\n                    _ even: inout [Int]) {\\n        if d == 1 {\\n            odd = [1, 2, 3, 4, 5, 6, 7, 8, 9]\\n            even = [11, 22, 33, 44, 55, 66, 77, 88, 99]\\n        } else {\\n            var newOdd = [Int]()\\n            var newEven = [Int]()\\n\\n            // half digits at previous even digit number\\n            let tenHalf = Int(pow(10.0, Double(d-1)))\\n            let tenD = Int(pow(10.0, Double(d)))\\n            let tenD1 = Int(pow(10.0, Double(d+1)))\\n\\n            for num in even {\\n                // insert i to mid of num\\n                for i in 0...9 {\\n                    // generate 2d-1 digits palindromic\\n                    // base10 numbers\\n                    // can generate based on previous even array\\n                    // ex: digit 3 array can\\n                    // based on digit 2 numbers\\n                    let tempOdd = num / tenHalf * tenD\\n                    + i * tenHalf\\n                    + num % tenHalf\\n                    newOdd.append(tempOdd)\\n\\n                    // generate 2d digits palindromic\\n                    // base10 numbers\\n                    // can generate based on current odd array\\n                    // duplicate odd\\'s mid digit\\n                    let tempEven = num / tenHalf * tenD1\\n                    + i * tenD\\n                    + i * tenHalf\\n                    + num % tenHalf\\n                    newEven.append(tempEven)\\n                }\\n            }\\n\\n            odd = newOdd\\n            even = newEven\\n        }\\n    }\\n\\n    // check current base10 number is\\n    // also a k-mirror number or not\\n    func checkBaseK(_ num: Int, _ k: Int) -> Bool {\\n        // convert to base k string\\n        var str = Array(String(num, radix: k))\\n        var s = 0\\n        var e = str.count-1\\n        while s <= e {\\n            if str[s] != str[e] {\\n                return false\\n            }\\n            s += 1\\n            e -= 1\\n        }\\n        return true\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func kMirror(_ k: Int, _ n: Int) -> Int {\\n        var d = 1\\n\\n        // count of remain wait for being found number\\n        var n = n\\n\\n        // sum of finded numbers\\n        var sum = 0\\n\\n        // odd digits palindromic base10 numbers\\n        var odd = [Int]()\\n        // even digits palindromic base10 numbers\\n        var even = [Int]()\\n\\n        while n > 0 {\\n            // check 2d and 2d-1\\n            // generated palindromic base10 numbers\\n            genBaseTen(d, &odd, &even)\\n            let baseTen = odd+even\\n            // print(baseTen)\\n            for num in baseTen {\\n                // check if number is also baseK mirror number\\n                if checkBaseK(num, k) {\\n                    sum += num\\n                    n -= 1\\n                    if n == 0 { return sum }\\n                }\\n            }\\n\\n            // update d for next searching\\n            d += 1\\n        }\\n\\n        return sum\\n    }\\n\\n    // generate palindromic base 10 numbers\\n    // with 2d and 2d-1 digits\\n    // return generate number by sorted\\n    func genBaseTen(_ d: Int,\\n                    _ odd: inout [Int],\\n                    _ even: inout [Int]) {\\n        if d == 1 {\\n            odd = [1, 2, 3, 4, 5, 6, 7, 8, 9]\\n            even = [11, 22, 33, 44, 55, 66, 77, 88, 99]\\n        } else {\\n            var newOdd = [Int]()\\n            var newEven = [Int]()\\n\\n            // half digits at previous even digit number\\n            let tenHalf = Int(pow(10.0, Double(d-1)))\\n            let tenD = Int(pow(10.0, Double(d)))\\n            let tenD1 = Int(pow(10.0, Double(d+1)))\\n\\n            for num in even {\\n                // insert i to mid of num\\n                for i in 0...9 {\\n                    // generate 2d-1 digits palindromic\\n                    // base10 numbers\\n                    // can generate based on previous even array\\n                    // ex: digit 3 array can\\n                    // based on digit 2 numbers\\n                    let tempOdd = num / tenHalf * tenD\\n                    + i * tenHalf\\n                    + num % tenHalf\\n                    newOdd.append(tempOdd)\\n\\n                    // generate 2d digits palindromic\\n                    // base10 numbers\\n                    // can generate based on current odd array\\n                    // duplicate odd\\'s mid digit\\n                    let tempEven = num / tenHalf * tenD1\\n                    + i * tenD\\n                    + i * tenHalf\\n                    + num % tenHalf\\n                    newEven.append(tempEven)\\n                }\\n            }\\n\\n            odd = newOdd\\n            even = newEven\\n        }\\n    }\\n\\n    // check current base10 number is\\n    // also a k-mirror number or not\\n    func checkBaseK(_ num: Int, _ k: Int) -> Bool {\\n        // convert to base k string\\n        var str = Array(String(num, radix: k))\\n        var s = 0\\n        var e = str.count-1\\n        while s <= e {\\n            if str[s] != str[e] {\\n                return false\\n            }\\n            s += 1\\n            e -= 1\\n        }\\n        return true\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2213710,
                "title": "friendlier-than-others-seems-to-me",
                "content": "The most problematic point for me was the generation of mirror numbers, so I made it with not the most optimal speed, frankly bad memory usage but understandable for people like me:)\\n\\nI originally generated mirror decimal numbers - I don\\'t know why, really. Then I checked each of them on base k (bringing them to that base by stepwise division and writing down the residuals, yep\\uD83D\\uDE1E)\\n\\nNeedless to say, it wasn\\'t great. However, by some miracle it was able to pass all the test cases **twice**.. But repeating that success didn\\'t work out for me (below are two consecutive runs of the same code without edits):\\n![image](https://assets.leetcode.com/users/images/61208d92-6190-4bbe-9dcb-cb06f75c335c_1656503176.93325.jpeg)\\n\\nThe idea: each next mirror number (greater than 9) was obtained using an explicit loop, adding to the string representation of the numbers of the pre-previous length of the numbers from \\'0\\' to \\'9\\' at the beginning and end, respectively\\n\\n\\tclass Solution:\\n\\t\\tdef kMirror(self, k: int, n: int) -> int:\\n\\n\\t\\t\\tdef k_based_checker(num):\\n\\t\\t\\t\\tnew_num = \\'\\' #The conversion to the base k \\n\\t\\t\\t\\twhile num > 0:\\n\\t\\t\\t\\t\\tnew_num = str(num % k) + new_num\\n\\t\\t\\t\\t\\tnum //= k\\n\\t\\t\\t\\treturn all([new_num[i] == new_num[~i] for i in range(len(new_num)//2)]) #Checking mirroring\\n\\n\\n\\t\\t\\tres = 0\\n\\t\\t\\tbase = [\\'\\'] #the initial basis for obtaining two-digit numbers: 11, 22..\\n\\t\\t\\tnxt = [\\'0\\',\\'1\\',\\'2\\',\\'3\\',\\'4\\',\\'5\\',\\'6\\',\\'7\\',\\'8\\',\\'9\\'] \\n\\t\\t\\t#Then two-digit numbers are sent here, \\n\\t\\t\\t#and single-digit numbers go into the base to generate three-digit etc \\n\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t\\t#check for mirroring of k representations of the first 9 numbers\\n\\t\\t\\t#which are mirrored in the default decimal representation:\\n\\t\\t\\tfor i in range(1, 10):   \\n\\t\\t\\t\\tif k_based_checker(i):\\n\\t\\t\\t\\t\\tres += i\\n\\t\\t\\t\\t\\tn -= 1\\n\\t\\t\\t\\t\\tif not n:\\n\\t\\t\\t\\t\\t\\treturn res\\n\\n\\t\\t\\twhile n:\\n\\t\\t\\t\\tnew = []\\n\\t\\t\\t\\tfor s in range(10): \\n\\t\\t\\t\\t#Here we use leading zeros and the subsequent check s != \\'0\\'\\n\\t\\t\\t\\t#to make mirror numbers of greater length, such as 10101 from unnecessary 010\\n\\t\\t\\t\\t#Not very elegant, exactly\\n\\t\\t\\t\\t\\ts = str(s)\\n\\t\\t\\t\\t\\tfor b in base:\\n\\t\\t\\t\\t\\t\\ttmp = s + b + s\\n\\t\\t\\t\\t\\t\\tnew.append(tmp)\\n\\t\\t\\t\\t\\t\\tif s != \\'0\\': \\n\\t\\t\\t\\t\\t\\t\\ttmp = int(tmp)\\n\\t\\t\\t\\t\\t\\t\\tif k_based_checker(tmp):\\n\\t\\t\\t\\t\\t\\t\\t\\tn -= 1\\n\\t\\t\\t\\t\\t\\t\\t\\tres += tmp\\n\\t\\t\\t\\t\\t\\t\\t\\tif not n:\\n\\t\\t\\t\\t\\t\\t\\t\\t\\treturn res\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t#previous (not current) numbers we need to create the next ones,\\n\\t\\t\\t\\t#because two characters are added, and after 99 we want to get 101, not 1001\\t\\t\\t\\t\\t\\n\\t\\t\\t\\tnxt, base = new, nxt \\n\\n\\t\\t\\treturn res\\n\\nThen I figured out that you can use int() to convert numbers with a random base to decimal, which of course is orders of magnitude faster; here, for example, is the result for k = 7, len(num) = 10 ** 5 (although I may have messed up somewhere):\\n![image](https://assets.leetcode.com/users/images/4607c5e1-728e-4fa2-a0c9-480b0b3832f3_1656504681.7295327.jpeg)\\n\\nSo...I did the same thing, but generating mirror numbers directly on base k, just using range(k) instead of range(10). And, you know, it worked much better! It\\'s still a horribly irrational use of memory instead of intelligent generation, but now the solution goes not at the very edge of the time limit, but like this\\n![image](https://assets.leetcode.com/users/images/88cf2000-c401-4eda-a6ba-00170bb3310f_1656504995.672454.jpeg)\\n\\nI will not give up trying to find a better and clearer solution, but now here it is, my hard-won result\\n\\n\\tclass Solution:\\n\\t\\tdef kMirror(self, k: int, n: int) -> int:\\n\\n\\t\\t\\tdef deci_checker(num):\\n\\t\\t\\t\\tnew_num = str(int(num, k))\\n\\t\\t\\t\\treturn int(new_num) * all([new_num[i] == new_num[~i] for i in range(len(new_num)//2)])\\n\\n\\n\\t\\t\\tres = sum(range(1, (min(k, n+1))))\\n\\n\\t\\t\\tn -= k - 1\\n\\t\\t\\tif n <= 0:\\n\\t\\t\\t\\treturn res\\n\\n\\t\\t\\tbase = [\\'\\']\\n\\t\\t\\tnxt = [str(i) for i in range(k)]\\n\\n\\t\\t\\twhile n:\\n\\t\\t\\t\\tnew = []\\n\\t\\t\\t\\tfor s in range(k):\\n\\t\\t\\t\\t\\ts = str(s)\\n\\t\\t\\t\\t\\tfor b in base:\\n\\t\\t\\t\\t\\t\\ttmp = s + b + s\\n\\t\\t\\t\\t\\t\\tnew.append(tmp)\\n\\t\\t\\t\\t\\t\\tif s != \\'0\\':\\n\\t\\t\\t\\t\\t\\t\\ttmp = deci_checker(tmp)\\n\\t\\t\\t\\t\\t\\t\\tif tmp:\\n\\t\\t\\t\\t\\t\\t\\t\\tn -= 1\\n\\t\\t\\t\\t\\t\\t\\t\\tres += tmp\\n\\t\\t\\t\\t\\t\\t\\t\\tif not n:\\n\\t\\t\\t\\t\\t\\t\\t\\t\\treturn res\\n\\t\\t\\t\\tnxt, base = new, nxt\\n\\n\\t\\t\\treturn res\\n\\nThat\\'s all folks! Good luck and good mood everyone",
                "solutionTags": [
                    "Python"
                ],
                "code": "The most problematic point for me was the generation of mirror numbers, so I made it with not the most optimal speed, frankly bad memory usage but understandable for people like me:)\\n\\nI originally generated mirror decimal numbers - I don\\'t know why, really. Then I checked each of them on base k (bringing them to that base by stepwise division and writing down the residuals, yep\\uD83D\\uDE1E)\\n\\nNeedless to say, it wasn\\'t great. However, by some miracle it was able to pass all the test cases **twice**.. But repeating that success didn\\'t work out for me (below are two consecutive runs of the same code without edits):\\n![image](https://assets.leetcode.com/users/images/61208d92-6190-4bbe-9dcb-cb06f75c335c_1656503176.93325.jpeg)\\n\\nThe idea: each next mirror number (greater than 9) was obtained using an explicit loop, adding to the string representation of the numbers of the pre-previous length of the numbers from \\'0\\' to \\'9\\' at the beginning and end, respectively\\n\\n\\tclass Solution:\\n\\t\\tdef kMirror(self, k: int, n: int) -> int:\\n\\n\\t\\t\\tdef k_based_checker(num):\\n\\t\\t\\t\\tnew_num = \\'\\' #The conversion to the base k \\n\\t\\t\\t\\twhile num > 0:\\n\\t\\t\\t\\t\\tnew_num = str(num % k) + new_num\\n\\t\\t\\t\\t\\tnum //= k\\n\\t\\t\\t\\treturn all([new_num[i] == new_num[~i] for i in range(len(new_num)//2)]) #Checking mirroring\\n\\n\\n\\t\\t\\tres = 0\\n\\t\\t\\tbase = [\\'\\'] #the initial basis for obtaining two-digit numbers: 11, 22..\\n\\t\\t\\tnxt = [\\'0\\',\\'1\\',\\'2\\',\\'3\\',\\'4\\',\\'5\\',\\'6\\',\\'7\\',\\'8\\',\\'9\\'] \\n\\t\\t\\t#Then two-digit numbers are sent here, \\n\\t\\t\\t#and single-digit numbers go into the base to generate three-digit etc \\n\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t\\t#check for mirroring of k representations of the first 9 numbers\\n\\t\\t\\t#which are mirrored in the default decimal representation:\\n\\t\\t\\tfor i in range(1, 10):   \\n\\t\\t\\t\\tif k_based_checker(i):\\n\\t\\t\\t\\t\\tres += i\\n\\t\\t\\t\\t\\tn -= 1\\n\\t\\t\\t\\t\\tif not n:\\n\\t\\t\\t\\t\\t\\treturn res\\n\\n\\t\\t\\twhile n:\\n\\t\\t\\t\\tnew = []\\n\\t\\t\\t\\tfor s in range(10): \\n\\t\\t\\t\\t#Here we use leading zeros and the subsequent check s != \\'0\\'\\n\\t\\t\\t\\t#to make mirror numbers of greater length, such as 10101 from unnecessary 010\\n\\t\\t\\t\\t#Not very elegant, exactly\\n\\t\\t\\t\\t\\ts = str(s)\\n\\t\\t\\t\\t\\tfor b in base:\\n\\t\\t\\t\\t\\t\\ttmp = s + b + s\\n\\t\\t\\t\\t\\t\\tnew.append(tmp)\\n\\t\\t\\t\\t\\t\\tif s != \\'0\\': \\n\\t\\t\\t\\t\\t\\t\\ttmp = int(tmp)\\n\\t\\t\\t\\t\\t\\t\\tif k_based_checker(tmp):\\n\\t\\t\\t\\t\\t\\t\\t\\tn -= 1\\n\\t\\t\\t\\t\\t\\t\\t\\tres += tmp\\n\\t\\t\\t\\t\\t\\t\\t\\tif not n:\\n\\t\\t\\t\\t\\t\\t\\t\\t\\treturn res\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t#previous (not current) numbers we need to create the next ones,\\n\\t\\t\\t\\t#because two characters are added, and after 99 we want to get 101, not 1001\\t\\t\\t\\t\\t\\n\\t\\t\\t\\tnxt, base = new, nxt \\n\\n\\t\\t\\treturn res\\n\\nThen I figured out that you can use int() to convert numbers with a random base to decimal, which of course is orders of magnitude faster; here, for example, is the result for k = 7, len(num) = 10 ** 5 (although I may have messed up somewhere):\\n![image](https://assets.leetcode.com/users/images/4607c5e1-728e-4fa2-a0c9-480b0b3832f3_1656504681.7295327.jpeg)\\n\\nSo...I did the same thing, but generating mirror numbers directly on base k, just using range(k) instead of range(10). And, you know, it worked much better! It\\'s still a horribly irrational use of memory instead of intelligent generation, but now the solution goes not at the very edge of the time limit, but like this\\n![image](https://assets.leetcode.com/users/images/88cf2000-c401-4eda-a6ba-00170bb3310f_1656504995.672454.jpeg)\\n\\nI will not give up trying to find a better and clearer solution, but now here it is, my hard-won result\\n\\n\\tclass Solution:\\n\\t\\tdef kMirror(self, k: int, n: int) -> int:\\n\\n\\t\\t\\tdef deci_checker(num):\\n\\t\\t\\t\\tnew_num = str(int(num, k))\\n\\t\\t\\t\\treturn int(new_num) * all([new_num[i] == new_num[~i] for i in range(len(new_num)//2)])\\n\\n\\n\\t\\t\\tres = sum(range(1, (min(k, n+1))))\\n\\n\\t\\t\\tn -= k - 1\\n\\t\\t\\tif n <= 0:\\n\\t\\t\\t\\treturn res\\n\\n\\t\\t\\tbase = [\\'\\']\\n\\t\\t\\tnxt = [str(i) for i in range(k)]\\n\\n\\t\\t\\twhile n:\\n\\t\\t\\t\\tnew = []\\n\\t\\t\\t\\tfor s in range(k):\\n\\t\\t\\t\\t\\ts = str(s)\\n\\t\\t\\t\\t\\tfor b in base:\\n\\t\\t\\t\\t\\t\\ttmp = s + b + s\\n\\t\\t\\t\\t\\t\\tnew.append(tmp)\\n\\t\\t\\t\\t\\t\\tif s != \\'0\\':\\n\\t\\t\\t\\t\\t\\t\\ttmp = deci_checker(tmp)\\n\\t\\t\\t\\t\\t\\t\\tif tmp:\\n\\t\\t\\t\\t\\t\\t\\t\\tn -= 1\\n\\t\\t\\t\\t\\t\\t\\t\\tres += tmp\\n\\t\\t\\t\\t\\t\\t\\t\\tif not n:\\n\\t\\t\\t\\t\\t\\t\\t\\t\\treturn res\\n\\t\\t\\t\\tnxt, base = new, nxt\\n\\n\\t\\t\\treturn res\\n\\nThat\\'s all folks! Good luck and good mood everyone",
                "codeTag": "Java"
            },
            {
                "id": 2090378,
                "title": "extremely-clean-python3-with-comments",
                "content": "the core idea here is to generate base 10 palindromes using reflecting the first half, considering for overlaps. for instance, 12 can generate the palindrome 121, 1221, with overlap of 1 and 0 resp. if we enumerate this way, we are guarenteed to find the smallest palindromes in base 10. \\n\\nAll thats left is to check for whether this number is a palindrome in base k\\n\\n```\\nclass Solution:\\n    def kMirror(self, k: int, n: int) -> int:\\n        numadded = res = 0\\n        digitlen = 1 # this is the number of digits we want to consider in the pre mirror of the palindrome\\n        while(numadded < n):\\n            for overlap in [1,0]:\\n                for candidate in range(10**(digitlen - 1), 10**digitlen): # check all half candidates of length 1, 2, ... etc\\n                    # construct palindrome from first half, considering overlap\\n                    palindrome_ten = candidate\\n                    candidate //= 10 ** overlap # removes necessary digits\\n                    while(candidate): # append digits\\n                        palindrome_ten = palindrome_ten * 10 + candidate % 10\\n                        candidate //= 10\\n                    # check palindrome in base k\\n                    old_palindrome_ten, base_k = palindrome_ten, 0\\n                    while(old_palindrome_ten):\\n                        base_k = (base_k + old_palindrome_ten % k) * k\\n                        old_palindrome_ten //= k\\n                    # record value\\n                    if(palindrome_ten * k == base_k):\\n                        res += palindrome_ten\\n                        numadded += 1\\n                    if(numadded >= n):\\n                        return res\\n            digitlen += 1\\n            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def kMirror(self, k: int, n: int) -> int:\\n        numadded = res = 0\\n        digitlen = 1 # this is the number of digits we want to consider in the pre mirror of the palindrome\\n        while(numadded < n):\\n            for overlap in [1,0]:\\n                for candidate in range(10**(digitlen - 1), 10**digitlen): # check all half candidates of length 1, 2, ... etc\\n                    # construct palindrome from first half, considering overlap\\n                    palindrome_ten = candidate\\n                    candidate //= 10 ** overlap # removes necessary digits\\n                    while(candidate): # append digits\\n                        palindrome_ten = palindrome_ten * 10 + candidate % 10\\n                        candidate //= 10\\n                    # check palindrome in base k\\n                    old_palindrome_ten, base_k = palindrome_ten, 0\\n                    while(old_palindrome_ten):\\n                        base_k = (base_k + old_palindrome_ten % k) * k\\n                        old_palindrome_ten //= k\\n                    # record value\\n                    if(palindrome_ten * k == base_k):\\n                        res += palindrome_ten\\n                        numadded += 1\\n                    if(numadded >= n):\\n                        return res\\n            digitlen += 1\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1995921,
                "title": "c-object-oriented-approach-to-generate-the-palindromes",
                "content": "### [C++] Object-Oriented approach to Generate the Palindromes\\n\\n#### Overall Approach:\\n * generate base-10 palindrome numbers x from 1 up, and test whether it\\'s a base-k palindrome\\n integer.\\n\\n##### How to generate palindrome numbers?\\nObservations after manually generating some palindromes.\\n* len-1 and len-2 palindromes can be generated from the same core 1~9, if we ignore `0` as the\\n  first palin-number.\\n* len-3 and len-4 palindromes can be generated from the same core 10~99:\\n  len 3: 10-->101    99-->999\\n  len 4: 10-->1001,  99-->9999\\n* len-5 and len-6 palindromes can be generated from the same core 100~999:\\n  len-5: 100-->10001\\n  len-6: 100-->100001\\n\\n##### How to test if a number is a palindrome number in base k?\\n* straightforward --> see annotated code.\\n\\n\\n\\n```\\n// 2081. Sum of k-Mirror Numbers\\n// Idea:\\n//  * generate base-10 palindrome numbers x from 1 up, and test whether it\\'s a base-k palindrome\\n//  integer.\\n// How to generate palindrome numbers?\\n// Observations after manually generating some palindromes.\\n// * len-1 and len-2 palindromes can be generated from the same core 1~9, if we ignore `0` as the\\n//   first palin-number.\\n// * len-3 and len-4 palindromes can be generated from the same core 10~99:\\n//   len 3: 10-->101    99-->999\\n//   len 4: 10-->1001,  99-->9999\\n// * len-5 and len-6 palindromes can be generated from the same core 100~999:\\n//   len-5: 100-->10001\\n//   len-6: 100-->100001\\n//\\n// How to test if a number is a palindrome number in base k?\\n// * straightforward --> see annotated code.\\nclass Solution {\\n    using llong = long long;\\n\\n    /// \\\\brief Check whether a number is a palindrome number in base k.\\n    template<typename T>\\n    static inline bool IsBaseKPalindromeNumber(T n, short k) {\\n        // this is not thread-safe.\\n        // but in Debug Mode, array is much faster than vector.\\n        static short v[100];\\n        // vector<short>& v = auxVec; // digits\\n        // v.clear();\\n        auto x = n;\\n        int d = 0; // position of the next digit\\n        while (x > 0) {\\n            // v.emplace_back(x % k);\\n            v[d] = x % k;\\n            x /= k;\\n            ++d;\\n        }\\n        // check if v is a palindrome\\n        for (int i = 0, j = d - 1; i < j; ++i, --j) {\\n            if (v[i] != v[j]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\npublic:\\n    /// \\\\brief the core for generating a series of palindrome numbers in Base 10.\\n    struct PalindromeGeneratorCore {\\n        /// \\\\brief tells whether the palindrome length is odd or even.\\n        /// starts with \"odd\", then followed by \"even\" , then \"odd\"... and so on.\\n        bool _isOdd = true;\\n        /// the core number for generating palindromes.\\n        int _coreNum = 1;\\n        /// the magnitude of the core number.\\n        /// e.g.\\n        /// if _coreNum is 1~9, its magnitude min is 1, and max is 9.\\n        /// if _coreNum is 10~99, its magnitude min is 10, and max is 99.\\n        /// if _coreNum is 100~999, its magnitude min is 100, and max is 999.\\n        int _coreMagnitudeMin = 1; // 10, 100\\n        int _coreMagnitudeMax = 9; // 99, 999\\n\\n        /// \\\\brief Generate the next palindrome number in Base 10\\n        llong NextPalindromeNumber() { //\\n            // TODO: optimize this logic. we don\\'t have to convert to string every time.\\n            auto s = to_string(_coreNum);\\n            auto reversed = s; // 123\\n            reverse(reversed.begin(), reversed.end()); // 321\\n            auto x = _isOdd ? //\\n                    s + reversed.substr(1) // 123_21\\n                            : s + reversed; // 123_321\\n            // prepare for generating the next palindrome number.\\n            ++_coreNum;\\n            if (_coreNum > _coreMagnitudeMax) {\\n                if (_isOdd) { // Odd==>Even. Odd core 9->9 ==> even core 1->11.\\n                    _isOdd = false;\\n                } else { // already in Even state.\\n                    // this time we\\'ll increase the magnitude min/max\\n                    _isOdd = true;\\n                    _coreMagnitudeMin *= 10;\\n                    _coreMagnitudeMax = _coreMagnitudeMax * 10 + 9;\\n                }\\n                _coreNum = _coreMagnitudeMin; // reset the core to min magnitude.\\n            }\\n            return stoll(x);\\n        }\\n    };\\n\\npublic:\\n    long long kMirror(int k, int n) {\\n        //\\n        // IsBaseKPalindromeNumber(100, 3);\\n        llong sum = 0;\\n        PalindromeGeneratorCore genCore;\\n        int count = 0;\\n        // vector<short> auxVec(100);\\n        while (count < n) {\\n            auto x = genCore.NextPalindromeNumber();\\n            if (IsBaseKPalindromeNumber(x, (short)k)) {\\n                sum += x;\\n                ++count;\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n\\nvoid testPalindromeGenerator() {\\n    Solution::PalindromeGeneratorCore genCore;\\n    for (int i = 0; i < 1000; ++i) {\\n        cout << genCore.NextPalindromeNumber() << \", \";\\n    }\\n    cout << endl;\\n}\\n\\nvoid testBaseKPalindromeSum() {\\n    Solution solver;\\n    cout << solver.kMirror(3, 7) << endl;\\n    cout << solver.kMirror(7, 17) << endl;\\n    cout << solver.kMirror(7, 30) << endl;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n// 2081. Sum of k-Mirror Numbers\\n// Idea:\\n//  * generate base-10 palindrome numbers x from 1 up, and test whether it\\'s a base-k palindrome\\n//  integer.\\n// How to generate palindrome numbers?\\n// Observations after manually generating some palindromes.\\n// * len-1 and len-2 palindromes can be generated from the same core 1~9, if we ignore `0` as the\\n//   first palin-number.\\n// * len-3 and len-4 palindromes can be generated from the same core 10~99:\\n//   len 3: 10-->101    99-->999\\n//   len 4: 10-->1001,  99-->9999\\n// * len-5 and len-6 palindromes can be generated from the same core 100~999:\\n//   len-5: 100-->10001\\n//   len-6: 100-->100001\\n//\\n// How to test if a number is a palindrome number in base k?\\n// * straightforward --> see annotated code.\\nclass Solution {\\n    using llong = long long;\\n\\n    /// \\\\brief Check whether a number is a palindrome number in base k.\\n    template<typename T>\\n    static inline bool IsBaseKPalindromeNumber(T n, short k) {\\n        // this is not thread-safe.\\n        // but in Debug Mode, array is much faster than vector.\\n        static short v[100];\\n        // vector<short>& v = auxVec; // digits\\n        // v.clear();\\n        auto x = n;\\n        int d = 0; // position of the next digit\\n        while (x > 0) {\\n            // v.emplace_back(x % k);\\n            v[d] = x % k;\\n            x /= k;\\n            ++d;\\n        }\\n        // check if v is a palindrome\\n        for (int i = 0, j = d - 1; i < j; ++i, --j) {\\n            if (v[i] != v[j]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\npublic:\\n    /// \\\\brief the core for generating a series of palindrome numbers in Base 10.\\n    struct PalindromeGeneratorCore {\\n        /// \\\\brief tells whether the palindrome length is odd or even.\\n        /// starts with \"odd\", then followed by \"even\" , then \"odd\"... and so on.\\n        bool _isOdd = true;\\n        /// the core number for generating palindromes.\\n        int _coreNum = 1;\\n        /// the magnitude of the core number.\\n        /// e.g.\\n        /// if _coreNum is 1~9, its magnitude min is 1, and max is 9.\\n        /// if _coreNum is 10~99, its magnitude min is 10, and max is 99.\\n        /// if _coreNum is 100~999, its magnitude min is 100, and max is 999.\\n        int _coreMagnitudeMin = 1; // 10, 100\\n        int _coreMagnitudeMax = 9; // 99, 999\\n\\n        /// \\\\brief Generate the next palindrome number in Base 10\\n        llong NextPalindromeNumber() { //\\n            // TODO: optimize this logic. we don\\'t have to convert to string every time.\\n            auto s = to_string(_coreNum);\\n            auto reversed = s; // 123\\n            reverse(reversed.begin(), reversed.end()); // 321\\n            auto x = _isOdd ? //\\n                    s + reversed.substr(1) // 123_21\\n                            : s + reversed; // 123_321\\n            // prepare for generating the next palindrome number.\\n            ++_coreNum;\\n            if (_coreNum > _coreMagnitudeMax) {\\n                if (_isOdd) { // Odd==>Even. Odd core 9->9 ==> even core 1->11.\\n                    _isOdd = false;\\n                } else { // already in Even state.\\n                    // this time we\\'ll increase the magnitude min/max\\n                    _isOdd = true;\\n                    _coreMagnitudeMin *= 10;\\n                    _coreMagnitudeMax = _coreMagnitudeMax * 10 + 9;\\n                }\\n                _coreNum = _coreMagnitudeMin; // reset the core to min magnitude.\\n            }\\n            return stoll(x);\\n        }\\n    };\\n\\npublic:\\n    long long kMirror(int k, int n) {\\n        //\\n        // IsBaseKPalindromeNumber(100, 3);\\n        llong sum = 0;\\n        PalindromeGeneratorCore genCore;\\n        int count = 0;\\n        // vector<short> auxVec(100);\\n        while (count < n) {\\n            auto x = genCore.NextPalindromeNumber();\\n            if (IsBaseKPalindromeNumber(x, (short)k)) {\\n                sum += x;\\n                ++count;\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n\\nvoid testPalindromeGenerator() {\\n    Solution::PalindromeGeneratorCore genCore;\\n    for (int i = 0; i < 1000; ++i) {\\n        cout << genCore.NextPalindromeNumber() << \", \";\\n    }\\n    cout << endl;\\n}\\n\\nvoid testBaseKPalindromeSum() {\\n    Solution solver;\\n    cout << solver.kMirror(3, 7) << endl;\\n    cout << solver.kMirror(7, 17) << endl;\\n    cout << solver.kMirror(7, 30) << endl;\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1730900,
                "title": "java-clear-3-simple-steps",
                "content": "1. Generate base-10 mirror nums\\n2. Convert to base-k num\\n3. Check if this base-k is a mirror num\\n\\n~~~java\\n\\nclass Solution {\\n    public long kMirror(int k, int n) {\\n        \\n        long curr = 1L;\\n        long sum = 0;\\n        while (n > 0) {\\n            String currStr = String.valueOf(curr);\\n            String kBase = baseK(curr, k);\\n            if (isMirror(kBase)) {\\n                sum += curr;\\n                n--;\\n            }\\n            curr = Long.parseLong(next(currStr));\\n        }\\n        \\n        return sum;\\n    }\\n    \\n    private String next(String num) {\\n        int n = num.length();\\n        String half = num.substring(0, (n + 1) / 2);\\n        long halfNum = Long.parseLong(half);\\n        \\n        StringBuilder sb = new StringBuilder();\\n        \\n        // 99 | 99 => 10001\\n        if (half.length() != String.valueOf(halfNum + 1).length()) {\\n            sb.append(\"1\");\\n            for (int i = 0; i < n - 1; i++) {\\n                sb.append(\"0\");\\n            }\\n            sb.append(\"1\");\\n            return sb.toString();\\n        }\\n        \\n        // 123 | 21 => 124 | 21\\n        String halfPlusOne = String.valueOf(halfNum + 1);\\n        sb.append(halfPlusOne);\\n        int start = (n % 2 == 0) ? halfPlusOne.length() - 1 : halfPlusOne.length() - 2;\\n        for (int i = start; i >= 0; i--) {\\n            sb.append(halfPlusOne.charAt(i));\\n        }\\n        return sb.toString();\\n    }\\n    \\n    private String baseK(long num, int k) {\\n        StringBuilder sb = new StringBuilder();\\n        while (num != 0) {\\n            sb.append(num % k);\\n            num /= k;\\n        }\\n        return sb.reverse().toString();\\n    }\\n    \\n    private boolean isMirror(String num) {\\n        int i = 0, j = num.length() - 1;\\n        while (i < j) {\\n            if (num.charAt(i++) != num.charAt(j--)) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n\\n\\n~~~",
                "solutionTags": [],
                "code": "class Solution {\\n    public long kMirror(int k, int n) {\\n        \\n        long curr = 1L;\\n        long sum = 0;\\n        while (n > 0) {\\n            String currStr = String.valueOf(curr);\\n            String kBase = baseK(curr, k);\\n            if (isMirror(kBase)) {\\n                sum += curr;\\n                n--;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1675996,
                "title": "readable-generator-pattern-solution-c-79",
                "content": "* We enumerate the palindrome numbers in order, for both base-10 and base-k. We always advance the enumeration for the smaller sequence.\\n* The enumeration follows a simple pattern: `number * pow(k, log(k, number)) + reverse(number)`, then `number` is incremented. \\n\\n```\\ninline int64_t Reverse(int64_t i, int k) {\\n    int64_t result = 0;\\n    while (i > 0) {\\n        result *= k;\\n        result += i % k;\\n        i /= k;\\n    }\\n    return result;\\n}\\n\\nstruct Enumerator {\\n    Enumerator(int k_) : curr(1), k(k_), power(k_), n(1) {}\\n    \\n    inline int64_t Next() {\\n        int64_t result = curr;\\n        if (n % 2 == 0) {\\n            result *= power;\\n            result += Reverse(curr, k);\\n        } else {\\n            result *= power / k;\\n            result += Reverse(curr / k, k);\\n        }\\n        if (++curr == power) {\\n            if (n++ % 2 == 0) {\\n                power *= k;\\n            }\\n            curr = power / k;\\n        }\\n        return result;\\n    }\\n    \\n    int64_t curr;\\n    int64_t k;\\n    int64_t power;\\n    int n;\\n};\\n\\nclass Solution {\\npublic:\\n    long long kMirror(int k, int n) {\\n        if (n == 0) {\\n            return 0;\\n        }\\n        Enumerator ek(k);\\n        Enumerator e10(10);\\n        int64_t a = ek.Next(), b = e10.Next();\\n        int64_t result = 0;\\n        while (n > 0) {\\n            if (a < b) {\\n                a = ek.Next();\\n            } else if (a > b) {\\n                b = e10.Next();\\n            } else {\\n                result += a;\\n                --n;\\n                a = ek.Next();\\n                b = e10.Next();\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\ninline int64_t Reverse(int64_t i, int k) {\\n    int64_t result = 0;\\n    while (i > 0) {\\n        result *= k;\\n        result += i % k;\\n        i /= k;\\n    }\\n    return result;\\n}\\n\\nstruct Enumerator {\\n    Enumerator(int k_) : curr(1), k(k_), power(k_), n(1) {}\\n    \\n    inline int64_t Next() {\\n        int64_t result = curr;\\n        if (n % 2 == 0) {\\n            result *= power;\\n            result += Reverse(curr, k);\\n        } else {\\n            result *= power / k;\\n            result += Reverse(curr / k, k);\\n        }\\n        if (++curr == power) {\\n            if (n++ % 2 == 0) {\\n                power *= k;\\n            }\\n            curr = power / k;\\n        }\\n        return result;\\n    }\\n    \\n    int64_t curr;\\n    int64_t k;\\n    int64_t power;\\n    int n;\\n};\\n\\nclass Solution {\\npublic:\\n    long long kMirror(int k, int n) {\\n        if (n == 0) {\\n            return 0;\\n        }\\n        Enumerator ek(k);\\n        Enumerator e10(10);\\n        int64_t a = ek.Next(), b = e10.Next();\\n        int64_t result = 0;\\n        while (n > 0) {\\n            if (a < b) {\\n                a = ek.Next();\\n            } else if (a > b) {\\n                b = e10.Next();\\n            } else {\\n                result += a;\\n                --n;\\n                a = ek.Next();\\n                b = e10.Next();\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1658017,
                "title": "java-simple-solution-with-backtracking",
                "content": "```\\nclass Solution {\\n    public long kMirror(int k, int n) {\\n        List<Long> res = new ArrayList<>();\\n        int len = 1;\\n        while(res.size()<n)\\n        {\\n            char[] nums = new char[len];\\n            dfs(0, nums, len, res, k);\\n            len++;\\n        }\\n        \\n        while(res.size()>n)\\n        {\\n            res.remove(res.size()-1);\\n        }\\n        \\n        long sum = 0;\\n        for(long num : res)\\n        {\\n            sum+=num;\\n        }\\n        \\n        return sum;\\n    }\\n    \\n    public void dfs(int ind, char[] nums, int len, List<Long> res, int k)\\n    {\\n        if(ind>=(len+1)/2)\\n        {\\n            long valInBase10 = getValInBase10(nums, k);\\n            if(isKMirror(nums, valInBase10))\\n            {\\n                res.add(valInBase10);\\n            }\\n            return;\\n        }\\n        \\n        for(int i = 0; i < k; i++)\\n        {\\n            if(ind==0&&i==0)continue;\\n            nums[ind] = (char)(\\'0\\'+i);\\n            nums[nums.length-1-ind] = (char)(\\'0\\'+i);\\n            dfs(ind+1, nums, len, res, k);\\n        }\\n    }\\n    \\n    public boolean isKMirror(char[] nums, long valInBase10)\\n    {\\n        int l = 0, r = nums.length-1;\\n        while(l<r)\\n        {\\n            if(nums[l]!=nums[r])return false;\\n            l++;\\n            r--;\\n        }\\n        \\n        char[] str10 = Long.toString(valInBase10).toCharArray();\\n        l = 0;\\n        r = str10.length-1;\\n        while(l<r)\\n        {\\n            if(str10[l]!=str10[r])return false;\\n            l++;\\n            r--;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    public long getValInBase10(char[] nums, int k)\\n    {\\n        long res = 0;\\n        long fac = 1;\\n        for(int i = nums.length-1; i>=0; i--)\\n        {\\n            res += fac * (nums[i]-\\'0\\');\\n            fac *= k;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public long kMirror(int k, int n) {\\n        List<Long> res = new ArrayList<>();\\n        int len = 1;\\n        while(res.size()<n)\\n        {\\n            char[] nums = new char[len];\\n            dfs(0, nums, len, res, k);\\n            len++;\\n        }\\n        \\n        while(res.size()>n)\\n        {\\n            res.remove(res.size()-1);\\n        }\\n        \\n        long sum = 0;\\n        for(long num : res)\\n        {\\n            sum+=num;\\n        }\\n        \\n        return sum;\\n    }\\n    \\n    public void dfs(int ind, char[] nums, int len, List<Long> res, int k)\\n    {\\n        if(ind>=(len+1)/2)\\n        {\\n            long valInBase10 = getValInBase10(nums, k);\\n            if(isKMirror(nums, valInBase10))\\n            {\\n                res.add(valInBase10);\\n            }\\n            return;\\n        }\\n        \\n        for(int i = 0; i < k; i++)\\n        {\\n            if(ind==0&&i==0)continue;\\n            nums[ind] = (char)(\\'0\\'+i);\\n            nums[nums.length-1-ind] = (char)(\\'0\\'+i);\\n            dfs(ind+1, nums, len, res, k);\\n        }\\n    }\\n    \\n    public boolean isKMirror(char[] nums, long valInBase10)\\n    {\\n        int l = 0, r = nums.length-1;\\n        while(l<r)\\n        {\\n            if(nums[l]!=nums[r])return false;\\n            l++;\\n            r--;\\n        }\\n        \\n        char[] str10 = Long.toString(valInBase10).toCharArray();\\n        l = 0;\\n        r = str10.length-1;\\n        while(l<r)\\n        {\\n            if(str10[l]!=str10[r])return false;\\n            l++;\\n            r--;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    public long getValInBase10(char[] nums, int k)\\n    {\\n        long res = 0;\\n        long fac = 1;\\n        for(int i = nums.length-1; i>=0; i--)\\n        {\\n            res += fac * (nums[i]-\\'0\\');\\n            fac *= k;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1654437,
                "title": "golang-solution-not-fast",
                "content": "```go\\nfunc kMirror(k int, n int) int64 {\\n\\tdecimal := []int{1,2,3,4,5,6,7,8,9}\\n\\tmirrorNumbers := make([]int, 0, 1024)\\n\\tfor len(mirrorNumbers) < n {\\n\\t\\tvalues := make([]int, 0, len(decimal)*2)\\n\\t\\tfor _, v := range decimal {\\n\\t\\t\\tv1, v2 := v, v*10+v%10\\n\\t\\t\\tv /= 10\\n\\t\\t\\tfor v != 0 {\\n\\t\\t\\t\\tv1 = v1 * 10 + v%10\\n\\t\\t\\t\\tv2 = v2 * 10 + v%10\\n\\t\\t\\t\\tv /= 10\\n\\t\\t\\t}\\n\\t\\t\\tvalues = append(values, v1, v2)\\n\\t\\t}\\n\\t\\tfor _, v := range values {\\n\\t\\t\\tvOriginal := v\\n\\t\\t\\tvKBitBytes := make([]byte, 0, 4096)\\n\\t\\t\\tfor v != 0 {\\n\\t\\t\\t\\tvKBitBytes = append(vKBitBytes, byte(v%k))\\n\\t\\t\\t\\tv /= k\\n\\t\\t\\t}\\n\\t\\t\\tif isPalindrome(vKBitBytes) {\\n\\t\\t\\t\\tmirrorNumbers = append(mirrorNumbers, vOriginal)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tnextDecimal := make([]int, 0, len(decimal)*10)\\n\\t\\tfor _, v := range decimal {\\n\\t\\t\\tfor lowestBit := 0; lowestBit < 10; lowestBit++ {\\n\\t\\t\\t\\tnextDecimal = append(nextDecimal, v*10+lowestBit)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tdecimal = nextDecimal\\n\\t}\\n\\tsort.Ints(mirrorNumbers)\\n\\tmirrorSummary := int64(0)\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tmirrorSummary += int64(mirrorNumbers[i])\\n\\t}\\n\\treturn mirrorSummary\\n}\\n\\nfunc isPalindrome(s []byte) bool {\\n\\tfor i := 0; i < len(s)/2; i++ {\\n\\t\\tif s[i] != s[len(s)-1-i] {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t}\\n\\treturn true\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc kMirror(k int, n int) int64 {\\n\\tdecimal := []int{1,2,3,4,5,6,7,8,9}\\n\\tmirrorNumbers := make([]int, 0, 1024)\\n\\tfor len(mirrorNumbers) < n {\\n\\t\\tvalues := make([]int, 0, len(decimal)*2)\\n\\t\\tfor _, v := range decimal {\\n\\t\\t\\tv1, v2 := v, v*10+v%10\\n\\t\\t\\tv /= 10\\n\\t\\t\\tfor v != 0 {\\n\\t\\t\\t\\tv1 = v1 * 10 + v%10\\n\\t\\t\\t\\tv2 = v2 * 10 + v%10\\n\\t\\t\\t\\tv /= 10\\n\\t\\t\\t}\\n\\t\\t\\tvalues = append(values, v1, v2)\\n\\t\\t}\\n\\t\\tfor _, v := range values {\\n\\t\\t\\tvOriginal := v\\n\\t\\t\\tvKBitBytes := make([]byte, 0, 4096)\\n\\t\\t\\tfor v != 0 {\\n\\t\\t\\t\\tvKBitBytes = append(vKBitBytes, byte(v%k))\\n\\t\\t\\t\\tv /= k\\n\\t\\t\\t}\\n\\t\\t\\tif isPalindrome(vKBitBytes) {\\n\\t\\t\\t\\tmirrorNumbers = append(mirrorNumbers, vOriginal)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tnextDecimal := make([]int, 0, len(decimal)*10)\\n\\t\\tfor _, v := range decimal {\\n\\t\\t\\tfor lowestBit := 0; lowestBit < 10; lowestBit++ {\\n\\t\\t\\t\\tnextDecimal = append(nextDecimal, v*10+lowestBit)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tdecimal = nextDecimal\\n\\t}\\n\\tsort.Ints(mirrorNumbers)\\n\\tmirrorSummary := int64(0)\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tmirrorSummary += int64(mirrorNumbers[i])\\n\\t}\\n\\treturn mirrorSummary\\n}\\n\\nfunc isPalindrome(s []byte) bool {\\n\\tfor i := 0; i < len(s)/2; i++ {\\n\\t\\tif s[i] != s[len(s)-1-i] {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t}\\n\\treturn true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1625541,
                "title": "java-concise-backtrack-solution-with-palindrome",
                "content": "```\\nclass Solution {\\n    public long kMirror(int k, int n) {\\n        \\n        List<Long> result = new ArrayList<>();\\n        int len = 1;\\n        \\n        while (result.size() < n)\\n            backtrack(result, new char[len++], k, n, 0);\\n        \\n        long sum = 0;\\n        \\n        for (Long num : result)\\n            sum += num;\\n        \\n        return sum;\\n    }\\n    \\n    private void backtrack(List<Long> result, char[] arr, int k, int n, int index)\\n    {\\n        if (result.size() == n)\\n            return;\\n        \\n        if (index >= (arr.length+1)/2)\\n        {\\n            Long number = Long.parseLong(String.valueOf(arr), k); // Number in base-10\\n            \\n            if (isPalindrome(number))\\n                result.add(number);\\n            \\n            return;\\n        }\\n        \\n        // Generate base-k palindrome number in arr.length without leading zeros\\n        for (char i = 0; i < k; i++)\\n        {\\n            if (index == 0 && i == 0) // Leading zeros\\n                continue;\\n            \\n            char c = (char)(i + \\'0\\');\\n            arr[index] = c;\\n            arr[arr.length -1 - index] = c;\\n            \\n            backtrack(result, arr, k, n, index+1);\\n        }\\n    }\\n    \\n    private boolean isPalindrome(Long number)\\n    {\\n        String strNum = String.valueOf(number);\\n        \\n        int left = 0, right = strNum.length() - 1;\\n        \\n        while (left < right)\\n        {\\n            if (strNum.charAt(left) == strNum.charAt(right))\\n            {\\n                left++;\\n                right--;\\n            }\\n            else\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public long kMirror(int k, int n) {\\n        \\n        List<Long> result = new ArrayList<>();\\n        int len = 1;\\n        \\n        while (result.size() < n)\\n            backtrack(result, new char[len++], k, n, 0);\\n        \\n        long sum = 0;\\n        \\n        for (Long num : result)\\n            sum += num;\\n        \\n        return sum;\\n    }\\n    \\n    private void backtrack(List<Long> result, char[] arr, int k, int n, int index)\\n    {\\n        if (result.size() == n)\\n            return;\\n        \\n        if (index >= (arr.length+1)/2)\\n        {\\n            Long number = Long.parseLong(String.valueOf(arr), k); // Number in base-10\\n            \\n            if (isPalindrome(number))\\n                result.add(number);\\n            \\n            return;\\n        }\\n        \\n        // Generate base-k palindrome number in arr.length without leading zeros\\n        for (char i = 0; i < k; i++)\\n        {\\n            if (index == 0 && i == 0) // Leading zeros\\n                continue;\\n            \\n            char c = (char)(i + \\'0\\');\\n            arr[index] = c;\\n            arr[arr.length -1 - index] = c;\\n            \\n            backtrack(result, arr, k, n, index+1);\\n        }\\n    }\\n    \\n    private boolean isPalindrome(Long number)\\n    {\\n        String strNum = String.valueOf(number);\\n        \\n        int left = 0, right = strNum.length() - 1;\\n        \\n        while (left < right)\\n        {\\n            if (strNum.charAt(left) == strNum.charAt(right))\\n            {\\n                left++;\\n                right--;\\n            }\\n            else\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1624027,
                "title": "what-is-c-s-version-of-long-parselong-for-an-arbitrary-base",
                "content": "Many posts require this method in java and there doesn\\'t see to be an equivalent in C#\\n\\n```\\nprivate long convert(String str,int k){\\n        return Long.parseLong(str,k);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nprivate long convert(String str,int k){\\n        return Long.parseLong(str,k);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1620838,
                "title": "c-solution",
                "content": "TLE Check all nums up to max Int64\\n```\\npublic class Solution {\\n    public long KMirror(int k, int n) {\\n        long rc = 0, r = 0;\\n        for (long i = 1; rc < n; ++i) {\\n            if (IsPalindrome(i.ToString()) && IsPalindrome(DecimalToArbitrarySystem(i, k))) {\\n                rc++;\\n                r += i;\\n            }\\n        }\\n        \\n        return r;\\n    }\\n    \\n    public string DecimalToArbitrarySystem(long decimalNumber, int radix)\\n    {\\n        const int BitsInLong = 64;\\n        const string Digits = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\\n\\n        if (radix < 2 || radix > Digits.Length)\\n            throw new ArgumentException(\"The radix must be >= 2 and <= \" + Digits.Length.ToString());\\n\\n        if (decimalNumber == 0)\\n            return \"0\";\\n\\n        int index = BitsInLong - 1;\\n        long currentNumber = Math.Abs(decimalNumber);\\n        char[] charArray = new char[BitsInLong];\\n\\n        while (currentNumber != 0)\\n        {\\n            int remainder = (int)(currentNumber % radix);\\n            charArray[index--] = Digits[remainder];\\n            currentNumber = currentNumber / radix;\\n        }\\n\\n        string result = new String(charArray, index + 1, BitsInLong - index - 1);\\n        if (decimalNumber < 0)\\n        {\\n            result = \"-\" + result;\\n        }\\n\\n        return result;\\n    }\\n    \\n    public bool IsPalindrome(string s) {\\n        int l = 0, r = s.Length - 1;\\n        while (l < r) {\\n            if (s[l++] != s[r--]) return false;\\n        }\\n        return true;\\n    }\\n}\\n```\\n\\nGenerate Base K/Base 10 Number\\n```\\npublic class Solution { // Generate Palindromes\\n    public long KMirror(int k, int n) {\\n        List<long> vn = new List<long>();\\n        int len = 1;\\n        while (vn.Count < n) {\\n            char[] cur = new char[len];\\n            MakePalindrome(cur, k.ToString()[0], 0, vn);\\n            len++;\\n        }\\n        \\n        while (vn.Count > n) vn.RemoveAt(vn.Count - 1);\\n        long res = 0;\\n        foreach (long v in vn) res += v;\\n        return res;\\n    }\\n    \\n    public void MakePalindrome(char[] cur, char k, int idx, List<long> vn) {\\n        if (idx >= (cur.Length + 1) / 2) { // past the mid point for generating, now need to check\\n            string s = new string(cur);\\n            long num10 = ToDecimal(s, k - \\'0\\');\\n            string s10 = num10.ToString();\\n            \\n            bool v = true;\\n            for (int i = 0, j = s10.Length - 1; i < j; ++i, --j) {\\n                if (s10[i] != s10[j]) {\\n                    v = false;\\n                    break;\\n                }\\n            }\\n            \\n            if (v) \\n                vn.Add(num10);\\n            \\n        } else { // keep generating outside in, this generates many palindromes for each char i value\\n            for (char i = \\'0\\'; i < k; ++i) {\\n                if (idx == 0 && i == \\'0\\') continue;\\n                cur[idx] = i;\\n                cur[cur.Length - 1 - idx] = i;\\n                MakePalindrome(cur, k, idx + 1, vn);\\n            }\\n        }\\n    }\\n    \\n    public long ToDecimal(string s, int k) {\\n        long res = 0;\\n        long power = 1;\\n        for (int i = s.Length - 1; i >= 0; --i) {\\n            res += (s[i] - \\'0\\') * power;\\n            power *= k;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public long KMirror(int k, int n) {\\n        long rc = 0, r = 0;\\n        for (long i = 1; rc < n; ++i) {\\n            if (IsPalindrome(i.ToString()) && IsPalindrome(DecimalToArbitrarySystem(i, k))) {\\n                rc++;\\n                r += i;\\n            }\\n        }\\n        \\n        return r;\\n    }\\n    \\n    public string DecimalToArbitrarySystem(long decimalNumber, int radix)\\n    {\\n        const int BitsInLong = 64;\\n        const string Digits = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\\n\\n        if (radix < 2 || radix > Digits.Length)\\n            throw new ArgumentException(\"The radix must be >= 2 and <= \" + Digits.Length.ToString());\\n\\n        if (decimalNumber == 0)\\n            return \"0\";\\n\\n        int index = BitsInLong - 1;\\n        long currentNumber = Math.Abs(decimalNumber);\\n        char[] charArray = new char[BitsInLong];\\n\\n        while (currentNumber != 0)\\n        {\\n            int remainder = (int)(currentNumber % radix);\\n            charArray[index--] = Digits[remainder];\\n            currentNumber = currentNumber / radix;\\n        }\\n\\n        string result = new String(charArray, index + 1, BitsInLong - index - 1);\\n        if (decimalNumber < 0)\\n        {\\n            result = \"-\" + result;\\n        }\\n\\n        return result;\\n    }\\n    \\n    public bool IsPalindrome(string s) {\\n        int l = 0, r = s.Length - 1;\\n        while (l < r) {\\n            if (s[l++] != s[r--]) return false;\\n        }\\n        return true;\\n    }\\n}\\n```\n```\\npublic class Solution { // Generate Palindromes\\n    public long KMirror(int k, int n) {\\n        List<long> vn = new List<long>();\\n        int len = 1;\\n        while (vn.Count < n) {\\n            char[] cur = new char[len];\\n            MakePalindrome(cur, k.ToString()[0], 0, vn);\\n            len++;\\n        }\\n        \\n        while (vn.Count > n) vn.RemoveAt(vn.Count - 1);\\n        long res = 0;\\n        foreach (long v in vn) res += v;\\n        return res;\\n    }\\n    \\n    public void MakePalindrome(char[] cur, char k, int idx, List<long> vn) {\\n        if (idx >= (cur.Length + 1) / 2) { // past the mid point for generating, now need to check\\n            string s = new string(cur);\\n            long num10 = ToDecimal(s, k - \\'0\\');\\n            string s10 = num10.ToString();\\n            \\n            bool v = true;\\n            for (int i = 0, j = s10.Length - 1; i < j; ++i, --j) {\\n                if (s10[i] != s10[j]) {\\n                    v = false;\\n                    break;\\n                }\\n            }\\n            \\n            if (v) \\n                vn.Add(num10);\\n            \\n        } else { // keep generating outside in, this generates many palindromes for each char i value\\n            for (char i = \\'0\\'; i < k; ++i) {\\n                if (idx == 0 && i == \\'0\\') continue;\\n                cur[idx] = i;\\n                cur[cur.Length - 1 - idx] = i;\\n                MakePalindrome(cur, k, idx + 1, vn);\\n            }\\n        }\\n    }\\n    \\n    public long ToDecimal(string s, int k) {\\n        long res = 0;\\n        long power = 1;\\n        for (int i = s.Length - 1; i >= 0; --i) {\\n            res += (s[i] - \\'0\\') * power;\\n            power *= k;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1603622,
                "title": "scala-very-ugly-brutal-force",
                "content": "```scala\\n\\n  def kMirror(k: Int, _n: Int): Long = {\\n    type l   = Long\\n    type int = Int\\n    var sum   = 0L\\n    var count = 0\\n    val n     = _n\\n    import scala.collection.mutable.{TreeSet, HashMap}\\n\\n    val pans   = new HashMap[int, TreeSet[String]]\\n    val d1, d2 = new TreeSet[String]\\n    d1 ++= Set[String](\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\")\\n    d2 ++= Set[String](\"00\", \"11\", \"22\", \"33\", \"44\", \"55\", \"66\", \"77\", \"88\", \"99\")\\n    pans += (1 -> d1)\\n    pans += (2 -> d2)\\n\\n    def bk(_num: l): String = {\\n      var r   = \"\"\\n      var num = _num\\n      while (num > 0) {\\n        r = (num % k).toString + r\\n        num /= k\\n      }\\n      r\\n    }\\n\\n    def f(set: TreeSet[String]): Unit = {\\n\\n      var s = 0L\\n      set.foreach(x => {\\n        if (!x.startsWith(\"0\")) {\\n          val bb = bk(x.toLong)\\n       \\n          if (bb.equals(bb.reverse) && count < n) {\\n            sum += x.toLong; count += 1; \\n          }\\n        }\\n\\n        if (count == n) return\\n      })\\n    }\\n\\n    def gen(wid: int): TreeSet[String] = {\\n      val tmp = new TreeSet[String]\\n      pans(wid - 2).foreach(x => {\\n        (0 to 9).foreach(y => {\\n          tmp += (y + x + y)\\n        })\\n      })\\n\\n      pans += (wid -> tmp)\\n      tmp\\n    }\\n\\n    val a1 = f(d1)\\n    if (count == n) return sum\\n    val a2 = f(d2)\\n    if (count == n) return sum\\n\\n    var len = 3\\n    while (count < n) {\\n      f(gen(len))\\n      len += 1\\n      pans -= (len - 3)\\n    }\\n    sum\\n  }\\n```",
                "solutionTags": [],
                "code": "```scala\\n\\n  def kMirror(k: Int, _n: Int): Long = {\\n    type l   = Long\\n    type int = Int\\n    var sum   = 0L\\n    var count = 0\\n    val n     = _n\\n    import scala.collection.mutable.{TreeSet, HashMap}\\n\\n    val pans   = new HashMap[int, TreeSet[String]]\\n    val d1, d2 = new TreeSet[String]\\n    d1 ++= Set[String](\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\")\\n    d2 ++= Set[String](\"00\", \"11\", \"22\", \"33\", \"44\", \"55\", \"66\", \"77\", \"88\", \"99\")\\n    pans += (1 -> d1)\\n    pans += (2 -> d2)\\n\\n    def bk(_num: l): String = {\\n      var r   = \"\"\\n      var num = _num\\n      while (num > 0) {\\n        r = (num % k).toString + r\\n        num /= k\\n      }\\n      r\\n    }\\n\\n    def f(set: TreeSet[String]): Unit = {\\n\\n      var s = 0L\\n      set.foreach(x => {\\n        if (!x.startsWith(\"0\")) {\\n          val bb = bk(x.toLong)\\n       \\n          if (bb.equals(bb.reverse) && count < n) {\\n            sum += x.toLong; count += 1; \\n          }\\n        }\\n\\n        if (count == n) return\\n      })\\n    }\\n\\n    def gen(wid: int): TreeSet[String] = {\\n      val tmp = new TreeSet[String]\\n      pans(wid - 2).foreach(x => {\\n        (0 to 9).foreach(y => {\\n          tmp += (y + x + y)\\n        })\\n      })\\n\\n      pans += (wid -> tmp)\\n      tmp\\n    }\\n\\n    val a1 = f(d1)\\n    if (count == n) return sum\\n    val a2 = f(d2)\\n    if (count == n) return sum\\n\\n    var len = 3\\n    while (count < n) {\\n      f(gen(len))\\n      len += 1\\n      pans -= (len - 3)\\n    }\\n    sum\\n  }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1592593,
                "title": "c-iterative-solution-using-an-even-queue-and-an-odd-queue",
                "content": "```\\nclass Solution {\\npublic:\\n  long long reverseNum(long long num, int base) {\\n    long long result = 0;\\n    while (num > 0) {\\n      result = result * base + (num % base);\\n      num /= base;\\n    }\\n    return result;\\n  }  \\n  \\n  bool isPalindrome(long long num, int base) {\\n    return num == reverseNum(num, base);\\n  }\\n  \\n  long long kMirror(int k, int n) {\\n    int tot = 0;\\n    long long cur = 1;\\n    long long result = 0;\\n    \\n    // Maintain a queue of even length palindromes and one of odd length palindromes\\n    queue<long long> evenQ, oddQ;\\n    for (int i = 1; i < k; ++i) {\\n      oddQ.push(i);\\n    }\\n    \\n    // Represents the number of digits in cur\\n    long long powerOfK = 1;\\n    while (tot < n) {\\n      if (cur >= powerOfK) {\\n        powerOfK *= k;\\n        \\n        // Empty the even queue\\n        while (tot < n && !evenQ.empty()) {\\n          result += evenQ.front();\\n          evenQ.pop();\\n          tot++;\\n        }\\n        \\n        // Empty the odd queue\\n        while (tot < n && !oddQ.empty()) {\\n          result += oddQ.front();\\n          oddQ.pop();\\n          tot++;\\n        }\\n      }\\n      \\n      long long numReversed = reverseNum(cur, k);\\n      // Generate an even length palindrome by concatenating the reverse of the number\\n      long long evenPalindrome = cur * powerOfK + numReversed;\\n      if (isPalindrome(evenPalindrome, 10)) {\\n        evenQ.push(evenPalindrome);\\n      }\\n      \\n      for (int i = 0; i < k; ++i) {\\n        // Generate an odd length palindrome by concatenating a base k digit and \\n        // the reverse of the number\\n        long long oddPalindrome = (cur * powerOfK * k) + (i * powerOfK) + numReversed;\\n        if (isPalindrome(oddPalindrome, 10)) {\\n          oddQ.push(oddPalindrome);\\n        }\\n      }\\n      \\n      cur++;\\n    }\\n    \\n    return result;\\n  }\\n};\\n```",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  long long reverseNum(long long num, int base) {\\n    long long result = 0;\\n    while (num > 0) {\\n      result = result * base + (num % base);\\n      num /= base;\\n    }\\n    return result;\\n  }  \\n  \\n  bool isPalindrome(long long num, int base) {\\n    return num == reverseNum(num, base);\\n  }\\n  \\n  long long kMirror(int k, int n) {\\n    int tot = 0;\\n    long long cur = 1;\\n    long long result = 0;\\n    \\n    // Maintain a queue of even length palindromes and one of odd length palindromes\\n    queue<long long> evenQ, oddQ;\\n    for (int i = 1; i < k; ++i) {\\n      oddQ.push(i);\\n    }\\n    \\n    // Represents the number of digits in cur\\n    long long powerOfK = 1;\\n    while (tot < n) {\\n      if (cur >= powerOfK) {\\n        powerOfK *= k;\\n        \\n        // Empty the even queue\\n        while (tot < n && !evenQ.empty()) {\\n          result += evenQ.front();\\n          evenQ.pop();\\n          tot++;\\n        }\\n        \\n        // Empty the odd queue\\n        while (tot < n && !oddQ.empty()) {\\n          result += oddQ.front();\\n          oddQ.pop();\\n          tot++;\\n        }\\n      }\\n      \\n      long long numReversed = reverseNum(cur, k);\\n      // Generate an even length palindrome by concatenating the reverse of the number\\n      long long evenPalindrome = cur * powerOfK + numReversed;\\n      if (isPalindrome(evenPalindrome, 10)) {\\n        evenQ.push(evenPalindrome);\\n      }\\n      \\n      for (int i = 0; i < k; ++i) {\\n        // Generate an odd length palindrome by concatenating a base k digit and \\n        // the reverse of the number\\n        long long oddPalindrome = (cur * powerOfK * k) + (i * powerOfK) + numReversed;\\n        if (isPalindrome(oddPalindrome, 10)) {\\n          oddQ.push(oddPalindrome);\\n        }\\n      }\\n      \\n      cur++;\\n    }\\n    \\n    return result;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1591319,
                "title": "recursive-generator-backtracking-python-solution",
                "content": "```\\nclass Solution:\\n    def kMirror(self, k: int, n: int) -> int:\\n        def backtrack(uptonow: str, remaining_count: int):\\n            \\'\\'\\'Generator for yielding next base k symmetric string\\'\\'\\'\\n            if not uptonow:\\n                yield from itertools.chain.from_iterable(backtrack(str(i), remaining_count - 1) for i in range(1, k))\\n            elif not remaining_count:\\n                yield uptonow\\n            elif remaining_count > len(uptonow):\\n                yield from itertools.chain.from_iterable(\\n                    backtrack(uptonow + str(i), remaining_count - 1) for i in range(k))\\n            else:\\n                yield from backtrack(uptonow + uptonow[remaining_count - 1], remaining_count - 1)\\n\\n        def generate_next_symmetric_base_k():\\n            \\'\\'\\'Generating Symmetric base k string with different lengths\\'\\'\\'\\n            number_length = 1\\n            while True:\\n                yield from backtrack(remaining_count=number_length, uptonow=\\'\\')\\n                number_length += 1\\n\\n        res = 0\\n        base_k_symmetric_generator = generate_next_symmetric_base_k()\\n        for _ in range(n):\\n            while True:\\n                next_symmetric_base_k = next(base_k_symmetric_generator)\\n                base10 = int(next_symmetric_base_k, k)\\n                base10_string = str(base10)\\n                if base10_string == base10_string[::-1]:\\n                    break\\n            res += base10\\n\\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def kMirror(self, k: int, n: int) -> int:\\n        def backtrack(uptonow: str, remaining_count: int):\\n            \\'\\'\\'Generator for yielding next base k symmetric string\\'\\'\\'\\n            if not uptonow:\\n                yield from itertools.chain.from_iterable(backtrack(str(i), remaining_count - 1) for i in range(1, k))\\n            elif not remaining_count:\\n                yield uptonow\\n            elif remaining_count > len(uptonow):\\n                yield from itertools.chain.from_iterable(\\n                    backtrack(uptonow + str(i), remaining_count - 1) for i in range(k))\\n            else:\\n                yield from backtrack(uptonow + uptonow[remaining_count - 1], remaining_count - 1)\\n\\n        def generate_next_symmetric_base_k():\\n            \\'\\'\\'Generating Symmetric base k string with different lengths\\'\\'\\'\\n            number_length = 1\\n            while True:\\n                yield from backtrack(remaining_count=number_length, uptonow=\\'\\')\\n                number_length += 1\\n\\n        res = 0\\n        base_k_symmetric_generator = generate_next_symmetric_base_k()\\n        for _ in range(n):\\n            while True:\\n                next_symmetric_base_k = next(base_k_symmetric_generator)\\n                base10 = int(next_symmetric_base_k, k)\\n                base10_string = str(base10)\\n                if base10_string == base10_string[::-1]:\\n                    break\\n            res += base10\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1590641,
                "title": "python3-two-palindrome-generators",
                "content": "Initialize 2 generators with bases K and 10. Get values from each. Add value to cache if it\\'s present in output from both. Get next element from generator with smaller value (or from one with base K if equal). Return sum of values in cache:\\n```\\nclass Solution:\\n    def kMirror(self, k: int, n: int) -> int:\\n        def createPalindromeBase(b: int):\\n            l = 1\\n            while True:\\n                for i in range(b ** ((l - 1) // 2), b ** ((l + 1) // 2)):\\n                    n = i\\n                    pal = i\\n                    if l % 2 == 1:\\n                        n //= b\\n                    while n:\\n                        pal = pal * b + (n % b)\\n                        n //= b\\n                    yield pal\\n                l += 1\\n\\n        pk = createPalindromeBase(k)\\n        p10 = createPalindromeBase(10)\\n\\n        numbers = []\\n        n10 = next(p10)\\n        nk = next(pk)\\n\\n        while numbers.__len__() < n:\\n            if n10 == nk:\\n                numbers.append(n10)\\n            if n10 < nk:\\n                n10 = next(p10)\\n            else:\\n                nk = next(pk)\\n        return sum(numbers)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def kMirror(self, k: int, n: int) -> int:\\n        def createPalindromeBase(b: int):\\n            l = 1\\n            while True:\\n                for i in range(b ** ((l - 1) // 2), b ** ((l + 1) // 2)):\\n                    n = i\\n                    pal = i\\n                    if l % 2 == 1:\\n                        n //= b\\n                    while n:\\n                        pal = pal * b + (n % b)\\n                        n //= b\\n                    yield pal\\n                l += 1\\n\\n        pk = createPalindromeBase(k)\\n        p10 = createPalindromeBase(10)\\n\\n        numbers = []\\n        n10 = next(p10)\\n        nk = next(pk)\\n\\n        while numbers.__len__() < n:\\n            if n10 == nk:\\n                numbers.append(n10)\\n            if n10 < nk:\\n                n10 = next(p10)\\n            else:\\n                nk = next(pk)\\n        return sum(numbers)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1590622,
                "title": "python-iterator-faster-than-100-1400-ms-14-5mb-memory",
                "content": "This solution takes advantage of the itertools.product generator and iterates through the possibilities efficiently. It looks in the base 2 <= k <= 9 to look for a mirror, and then checks in base 10 if that value is a mirror. We construct the mirrors in the k base directly, with different logic for whether the length of the mirror is even or odd. \\n\\n\\n```\\nclass Solution:\\n    def kMirror(self, k: int, n: int) -> int:\\n        import itertools \\n        \\n        def check(value,k):\\n            base_10_num = int(value,k)\\n            base_10_num_str = str(base_10_num)\\n            return base_10_num_str == base_10_num_str[::-1],base_10_num\\n        \\n        def generate_combos(k,length,allowed):\\n            tot_sum = 0\\n            count = 0\\n            if length == 1:\\n                for val in [str(x) for x in range(1,k)]:\\n                    boolean,value = check(val,k)\\n                    if boolean:\\n                        count += 1\\n                        tot_sum += value\\n                    if count == allowed:\\n                        return count,tot_sum\\n                return count,tot_sum\\n            else:\\n                values = [str(x) for x in range(0,k)]\\n                if length % 2 == 0: \\n                    for val in itertools.product(values,repeat=length//2):\\n                        new_val = \"\".join(val)\\n                        if new_val[0] != \"0\":\\n                            val_to_check = new_val + new_val[::-1]\\n                            boolean,value = check(val_to_check,k)\\n                            if boolean:\\n                                count += 1\\n                                tot_sum += value\\n                            if count == allowed:\\n                                return count,tot_sum\\n                    return count,tot_sum\\n                else:\\n                    for val in itertools.product(values,repeat=length//2):\\n                        new_val = \"\".join(val)\\n                        if new_val[0] != \"0\":\\n                            for i in values:\\n                                val_to_check = new_val + i + new_val[::-1]\\n                                boolean,value = check(val_to_check,k)\\n                                if boolean:\\n                                    count += 1\\n                                    tot_sum += value\\n                                if count == allowed:\\n                                    return count,tot_sum\\n                return count,tot_sum\\n                    \\n        \\n        count = 0\\n        length = 1\\n        sum_ans = 0\\n        remaining = n\\n        while True:\\n            found,new_sum = generate_combos(k,length,remaining)\\n            remaining -= found\\n            sum_ans += new_sum\\n            if remaining == 0:\\n                return sum_ans\\n            length += 1",
                "solutionTags": [],
                "code": "This solution takes advantage of the itertools.product generator and iterates through the possibilities efficiently. It looks in the base 2 <= k <= 9 to look for a mirror, and then checks in base 10 if that value is a mirror. We construct the mirrors in the k base directly, with different logic for whether the length of the mirror is even or odd. \\n\\n\\n```\\nclass Solution:\\n    def kMirror(self, k: int, n: int) -> int:\\n        import itertools \\n        \\n        def check(value,k):\\n            base_10_num = int(value,k)\\n            base_10_num_str = str(base_10_num)\\n            return base_10_num_str == base_10_num_str[::-1],base_10_num\\n        \\n        def generate_combos(k,length,allowed):\\n            tot_sum = 0\\n            count = 0\\n            if length == 1:\\n                for val in [str(x) for x in range(1,k)]:\\n                    boolean,value = check(val,k)\\n                    if boolean:\\n                        count += 1\\n                        tot_sum += value\\n                    if count == allowed:\\n                        return count,tot_sum\\n                return count,tot_sum\\n            else:\\n                values = [str(x) for x in range(0,k)]\\n                if length % 2 == 0: \\n                    for val in itertools.product(values,repeat=length//2):\\n                        new_val = \"\".join(val)\\n                        if new_val[0] != \"0\":\\n                            val_to_check = new_val + new_val[::-1]\\n                            boolean,value = check(val_to_check,k)\\n                            if boolean:\\n                                count += 1\\n                                tot_sum += value\\n                            if count == allowed:\\n                                return count,tot_sum\\n                    return count,tot_sum\\n                else:\\n                    for val in itertools.product(values,repeat=length//2):\\n                        new_val = \"\".join(val)\\n                        if new_val[0] != \"0\":\\n                            for i in values:\\n                                val_to_check = new_val + i + new_val[::-1]\\n                                boolean,value = check(val_to_check,k)\\n                                if boolean:\\n                                    count += 1\\n                                    tot_sum += value\\n                                if count == allowed:\\n                                    return count,tot_sum\\n                return count,tot_sum\\n                    \\n        \\n        count = 0\\n        length = 1\\n        sum_ans = 0\\n        remaining = n\\n        while True:\\n            found,new_sum = generate_combos(k,length,remaining)\\n            remaining -= found\\n            sum_ans += new_sum\\n            if remaining == 0:\\n                return sum_ans\\n            length += 1",
                "codeTag": "Java"
            },
            {
                "id": 1590172,
                "title": "2081-sum-of-k-mirror-numbers",
                "content": "---\\n\\n- Contest - https://leetcode.com/contest/weekly-contest-268/\\n  - Q1 Answer\\n    - https://leetcode.com/problems/two-furthest-houses-with-different-colors/discuss/1589851/2078.-Two-Furthest-Houses-With-Different-Colors\\n  - Q2 Answer\\n    - https://leetcode.com/problems/watering-plants/discuss/1589904/2079.-Watering-Plants\\n  - Q3 Answer\\n    - https://leetcode.com/problems/range-frequency-queries/discuss/1589775/2080.-Range-Frequency-Queries\\n  - Q4 Answer\\n    - below\\n      - Solution is simple, if we put aside the support functions\\n      - Last 2 test cases look time\\n        - https://leetcode.com/problems/sum-of-k-mirror-numbers/discuss/1590172/2081.-Sum-of-k-Mirror-Numbers\\n\\n---\\n\\nHope it is simple to understand.\\n\\n---\\n\\n**Solution**\\n\\n```\\n// Global cache - Across all test cases\\nlet LIMIT = 64454545446 + 1;                                 // based on last test case\\nlet palinSet = generatePalindromesSet(1, LIMIT);             // 10 base palindromes as Set()\\nlet kPalinArrObj = {};                                       // k base palindromes as Object of k to palindrome Array\\n\\nvar kMirror = function (k, n) {\\n    if (kPalinArrObj[k] === undefined) {\\n        kPalinArrObj[k] = generatePalindromesArr(1, LIMIT, k).sort( (a, b) => a - b );\\n    }\\n    let kPalinArr = kPalinArrObj[k];\\n\\n    let sum = 0,\\n        count = 0;\\n    for (let num of kPalinArr) {\\n        if (palinSet.has(num)) {\\n            count++;\\n            sum += num;\\n            if (count >= n) break;\\n        }\\n    }\\n\\n    return sum;\\n};\\n```\\n\\n\\n---\\n\\n**Support functions**\\n\\n- Credit:\\n  - GFG wesbite\\n    - See [**Generate all palindromic numbers less than n**](https://www.google.com/search?q=Generate+all+palindromic+numbers+less+than+n&sxsrf=AOaemvLvl4IcFvWNW_zhJ4o6MgKITZtIyQ%3A1637509379868&source=hp&ei=A2maYZK3MuaUr7wPn-aiwA8&iflsig=ALs-wAMAAAAAYZp3E90zN_fJSGcmlGcHKRKBP355SpJN&ved=0ahUKEwjSxJrn5an0AhVmyosBHR-zCPgQ4dUDCAc&uact=5&oq=Generate+all+palindromic+numbers+less+than+n&gs_lcp=Cgdnd3Mtd2l6EAMyBQgAEIAEUABYAGDZAWgAcAB4AIABkQGIAZEBkgEDMC4xmAEAoAECoAEB&sclient=gws-wiz)\\n\\n\\n\\n\\n\\n\\n\\n\\n---\\n\\n```\\nfunction createPalindrome(input, base, isOdd) {\\n    let n = input;\\n    let palin = input;\\n\\n    if (isOdd == 1) n = parseInt(n / base, 10);\\n\\n    while (n > 0) {\\n        palin = palin * base + (n % base);\\n        n = parseInt(n / base, 10);\\n    }\\n    return palin;\\n}\\n\\nfunction generatePalindromesArr(lo = 1, hi = 101, base = 10) {\\n    let a = [];\\n\\n    for (let j = 0; j < 2; j++) {\\n        for (let i = 1; ; i++) {\\n            let number = createPalindrome(i, base, j % 2);\\n            if (number > hi) break;\\n            a.push(number);\\n        }\\n    }\\n\\n    return a;\\n}\\n```\\n\\n---\\n\\n**Support function based on above function** -  Same as above, but Set() for lookup\\n\\n---\\n\\n```\\nfunction generatePalindromesSet(lo = 1, hi = 101, base = 10) {\\n    let a = new Set();\\n\\n    for (let j = 0; j < 2; j++) {\\n        for (let i = 1; ; i++) {\\n            let number = createPalindrome(i, base, j % 2);\\n            if (number > hi) break;\\n            a.add(number);\\n        }\\n    }\\n\\n    return a;\\n}\\n```\\n\\n---\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// Global cache - Across all test cases\\nlet LIMIT = 64454545446 + 1;                                 // based on last test case\\nlet palinSet = generatePalindromesSet(1, LIMIT);             // 10 base palindromes as Set()\\nlet kPalinArrObj = {};                                       // k base palindromes as Object of k to palindrome Array\\n\\nvar kMirror = function (k, n) {\\n    if (kPalinArrObj[k] === undefined) {\\n        kPalinArrObj[k] = generatePalindromesArr(1, LIMIT, k).sort( (a, b) => a - b );\\n    }\\n    let kPalinArr = kPalinArrObj[k];\\n\\n    let sum = 0,\\n        count = 0;\\n    for (let num of kPalinArr) {\\n        if (palinSet.has(num)) {\\n            count++;\\n            sum += num;\\n            if (count >= n) break;\\n        }\\n    }\\n\\n    return sum;\\n};\\n```\n```\\nfunction createPalindrome(input, base, isOdd) {\\n    let n = input;\\n    let palin = input;\\n\\n    if (isOdd == 1) n = parseInt(n / base, 10);\\n\\n    while (n > 0) {\\n        palin = palin * base + (n % base);\\n        n = parseInt(n / base, 10);\\n    }\\n    return palin;\\n}\\n\\nfunction generatePalindromesArr(lo = 1, hi = 101, base = 10) {\\n    let a = [];\\n\\n    for (let j = 0; j < 2; j++) {\\n        for (let i = 1; ; i++) {\\n            let number = createPalindrome(i, base, j % 2);\\n            if (number > hi) break;\\n            a.push(number);\\n        }\\n    }\\n\\n    return a;\\n}\\n```\n```\\nfunction generatePalindromesSet(lo = 1, hi = 101, base = 10) {\\n    let a = new Set();\\n\\n    for (let j = 0; j < 2; j++) {\\n        for (let i = 1; ; i++) {\\n            let number = createPalindrome(i, base, j % 2);\\n            if (number > hi) break;\\n            a.add(number);\\n        }\\n    }\\n\\n    return a;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1590101,
                "title": "python-3-traverse-k-base-numbers-and-iterative-building-3020ms",
                "content": "```\\nclass Solution:\\n    def kMirror(self, k: int, n: int) -> int:\\n        \\n        # start from single digit base k\\n        cands = [str(i) for i in range(1, k)]\\n        ans = 0\\n        \\n        while n > 0:\\n            # check current canddiates to see if base 10 is also mirroring\\n            for cand in cands:\\n                b10 = str(int(cand, k))\\n                if b10 == b10[::-1]:\\n                    ans += int(b10)\\n                    n -= 1\\n                    if n == 0: return ans\\n\\n            # construct new candidates \\n            # if previous cand length is even just insert number between 0 and k - 1 into the middle\\n            # if previous cand length is odd just insert number after len//2+1 and should be the same with left part end digit\\n            new_cands = []\\n            for cand in cands:\\n                m = len(cand)\\n                for i in range(k):\\n                    if m % 2 == 0:\\n                        new_cands.append(cand[:m//2] + str(i) + cand[m//2:])\\n                    else:\\n                        left, right = cand[:m//2+1], cand[m//2+1:]\\n                        if str(i) == left[-1]:\\n                            new_cands.append(left + str(i) + right)\\n            cands = new_cands\\n\\n            \\n        \\n        return ans",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def kMirror(self, k: int, n: int) -> int:\\n        \\n        # start from single digit base k\\n        cands = [str(i) for i in range(1, k)]\\n        ans = 0\\n        \\n        while n > 0:\\n            # check current canddiates to see if base 10 is also mirroring\\n            for cand in cands:\\n                b10 = str(int(cand, k))\\n                if b10 == b10[::-1]:\\n                    ans += int(b10)\\n                    n -= 1\\n                    if n == 0: return ans\\n\\n            # construct new candidates \\n            # if previous cand length is even just insert number between 0 and k - 1 into the middle\\n            # if previous cand length is odd just insert number after len//2+1 and should be the same with left part end digit\\n            new_cands = []\\n            for cand in cands:\\n                m = len(cand)\\n                for i in range(k):\\n                    if m % 2 == 0:\\n                        new_cands.append(cand[:m//2] + str(i) + cand[m//2:])\\n                    else:\\n                        left, right = cand[:m//2+1], cand[m//2+1:]\\n                        if str(i) == left[-1]:\\n                            new_cands.append(left + str(i) + right)\\n            cands = new_cands\\n\\n            \\n        \\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 1589773,
                "title": "c-generate-all-k-base-palindrome-and-use-pre-allocate-array-for-acceleration",
                "content": "There is a little bit trick, use pre-allocate array rather than using new vector in check function.\\nIt makes runtime from 1000ms to 100ms\\n```c++\\n#define ll unsigned long long\\nint nax = 30;\\nint a[10000]; // pre-alloc make it faster\\nclass Solution {\\npublic:\\n    long long kMirror(int k, int n) {\\n        ll ans = 0;\\n        int cnt = 0;\\n        vector<int> logs{0, 0, 63, 39, 31, 27, 24, 22, 21, 19}; // power num that won\\'t exceet max int64\\n        nax = logs[k];\\n         \\n        vector<ll> pow(nax, 1);\\n        for (int i = 1; i < nax; i++)\\n            pow[i] = pow[i-1]*k;\\n        \\n        for (int l = 1; l <= nax && cnt < n; l++) {\\n            int len = (l+1)/2;\\n            vector<int> res(len);\\n            res[len-1] = 1;\\n            while (true) {\\n                if (res[len-1] >= k) break;\\n                \\n                ll val = 0;\\n                int offset = l%2;\\n                for (int i = 0; i < len; i++) { // first half\\n                    val += pow[i] * res[len-i-1];\\n                }\\n                \\n                for (int i = 0, b = len; i < l-len; i++, b++) { //second half\\n                    val += pow[b] * res[i+offset];\\n                }\\n                \\n                if (check(val, l)) {\\n                    ans += val;\\n                    cnt++;\\n                }\\n                \\n                if (cnt >= n) break;\\n                \\n                // next\\n                res[0]++;\\n                for (int i = 0; i < len-1; i++) {\\n                    if (res[i] >= k) {\\n                        res[i] = 0;\\n                        res[i+1]++;\\n                    } else\\n                        break;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    bool check(ll val, int l) {\\n        int len = 0;\\n        while (val) {\\n            a[len] = val%10;\\n            val/=10;\\n            len++;\\n        }\\n       \\n        for (int i = 0; i < len/2; i++)\\n            if (a[i] != a[len-i-1]) return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```c++\\n#define ll unsigned long long\\nint nax = 30;\\nint a[10000]; // pre-alloc make it faster\\nclass Solution {\\npublic:\\n    long long kMirror(int k, int n) {\\n        ll ans = 0;\\n        int cnt = 0;\\n        vector<int> logs{0, 0, 63, 39, 31, 27, 24, 22, 21, 19}; // power num that won\\'t exceet max int64\\n        nax = logs[k];\\n         \\n        vector<ll> pow(nax, 1);\\n        for (int i = 1; i < nax; i++)\\n            pow[i] = pow[i-1]*k;\\n        \\n        for (int l = 1; l <= nax && cnt < n; l++) {\\n            int len = (l+1)/2;\\n            vector<int> res(len);\\n            res[len-1] = 1;\\n            while (true) {\\n                if (res[len-1] >= k) break;\\n                \\n                ll val = 0;\\n                int offset = l%2;\\n                for (int i = 0; i < len; i++) { // first half\\n                    val += pow[i] * res[len-i-1];\\n                }\\n                \\n                for (int i = 0, b = len; i < l-len; i++, b++) { //second half\\n                    val += pow[b] * res[i+offset];\\n                }\\n                \\n                if (check(val, l)) {\\n                    ans += val;\\n                    cnt++;\\n                }\\n                \\n                if (cnt >= n) break;\\n                \\n                // next\\n                res[0]++;\\n                for (int i = 0; i < len-1; i++) {\\n                    if (res[i] >= k) {\\n                        res[i] = 0;\\n                        res[i+1]++;\\n                    } else\\n                        break;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    bool check(ll val, int l) {\\n        int len = 0;\\n        while (val) {\\n            a[len] = val%10;\\n            val/=10;\\n            len++;\\n        }\\n       \\n        for (int i = 0; i < len/2; i++)\\n            if (a[i] != a[len-i-1]) return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1589765,
                "title": "python-faster-than-100-easy-to-understand-with-explanation",
                "content": "* generates base-k palindrome numbers sequentially from small to large\\n\\t* odd-numbered layer generates even-numbered layer, repeat the center number\\n\\t\\t* 1**0**1, 1**1**1 --> 1**00**1, 1**11**1\\n\\t* even-numbered layer generates odd-numbered layer, enumerate all numbers as the center number\\n\\t\\t* 1001, 1111 --> 10**0**01, 10**1**01, 11**0**11, 11**1**11\\n```\\nclass Solution(object):\\n    def kMirror(self, k, n):\\n        def isPalindrome(num):\\n            num = str(num)\\n            return num[::-1] == num\\n\\n        hd = collections.defaultdict(list)\\n        ret = 0\\n        for i in range(1, k):\\n            hd[1].append(str(i))\\n            ret += i\\n            n -= 1\\n            if n == 0:\\n                return ret\\n        length = 2\\n        #  generates base-k palindrome numbers sequentially from small to large\\n        while n > 0:\\n            if length % 2 == 0:\\n                # 101, 111 --> 1001, 1111\\n                # Repeat the center number, generate the longer base-k palindrome number\\n                j = length // 2 - 1\\n                for sn in hd[length - 1]:\\n                    num = sn[:j] + sn[j] * 2 + sn[length - 1 - j:]\\n                    hd[length].append(num)\\n                    if isPalindrome(int(num, k)):\\n                        ret += int(num, k)\\n                        n -= 1\\n                        if n == 0:\\n                            return ret\\n            else:\\n                # 1001, 1111 --> 10001, 10101, 11011, 11111\\n                # Enumerate all numbers as the center number, generate the longer base-k palindrome number\\n                j = length // 2\\n                for sn in hd[length - 1]:\\n                    for i in range(k):\\n                        num = sn[:j] + str(i) + sn[length - 1 - j:]\\n                        hd[length].append(num)\\n                        if isPalindrome(int(num, k)):\\n                            ret += int(num, k)\\n                            n -= 1\\n                            if n == 0:\\n                                return ret\\n            length += 1\\n```\\n\\n**If you have any questoins, feel free to ask. If you like the solution and explanation, please upvote!**\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def kMirror(self, k, n):\\n        def isPalindrome(num):\\n            num = str(num)\\n            return num[::-1] == num\\n\\n        hd = collections.defaultdict(list)\\n        ret = 0\\n        for i in range(1, k):\\n            hd[1].append(str(i))\\n            ret += i\\n            n -= 1\\n            if n == 0:\\n                return ret\\n        length = 2\\n        #  generates base-k palindrome numbers sequentially from small to large\\n        while n > 0:\\n            if length % 2 == 0:\\n                # 101, 111 --> 1001, 1111\\n                # Repeat the center number, generate the longer base-k palindrome number\\n                j = length // 2 - 1\\n                for sn in hd[length - 1]:\\n                    num = sn[:j] + sn[j] * 2 + sn[length - 1 - j:]\\n                    hd[length].append(num)\\n                    if isPalindrome(int(num, k)):\\n                        ret += int(num, k)\\n                        n -= 1\\n                        if n == 0:\\n                            return ret\\n            else:\\n                # 1001, 1111 --> 10001, 10101, 11011, 11111\\n                # Enumerate all numbers as the center number, generate the longer base-k palindrome number\\n                j = length // 2\\n                for sn in hd[length - 1]:\\n                    for i in range(k):\\n                        num = sn[:j] + str(i) + sn[length - 1 - j:]\\n                        hd[length].append(num)\\n                        if isPalindrome(int(num, k)):\\n                            ret += int(num, k)\\n                            n -= 1\\n                            if n == 0:\\n                                return ret\\n            length += 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1589600,
                "title": "javascript-brute-force-explained",
                "content": "**Explanation**\\nThis is a bruteforce approach to the problem where we start at 1 and keep finding the next base-10 palindrome, then for each palindrome we check if the number is also a palindrome in base-k;, if that is the case then we add the current base 10 number to the answer and eventually stop when we have added N numbers and return the answer at that point.\\n\\n**Some notes about this implementation:**\\n* Because base-k numbers can get much larger than the largest Number value in JavaScript(if the were treated as base 10) we can deal with them as strings and use the relatively simple two pointer approach to figure out if they are palindromes.\\n* We keep the base 10 number as a number because we need to constantly update its value; you could probably improve my helper function for nextPalindrome to always keep the base 10 number as a String and not need the number palindrome helper function\\n* Better answers very likely exist but I just wanted to share an approach I found intuitive\\n\\n\\n\\n```\\nlet kMirror =(k, n)=> {\\n    let c=1;\\n    let ans=0;\\n    while(0<n){\\n       if(isPalindrome(c)){\\n            let  x = toBase(c,k);\\n            let cont=true\\n            for (let i = 0, j = x.length - 1; i < j; i++, j--) {\\n\\t\\t\\t\\tif (x[i] !== x[j]){\\n\\t\\t\\t\\tcont=false\\n\\t\\t\\t} }\\n\\t\\t\\tif(cont){\\n\\t\\t\\t\\t ans+=c;\\n\\t\\t\\t\\t n--; }\\n               c++\\n        }else{\\n            c=(nextPalindromeNumber(c))\\n        }\\n    }\\n    return ans;\\n};\\n\\nlet isPalindrome =(x)=> {\\n    if(x<0) return false;\\n    let n=x;\\n    let rev=0;\\n    while(n){\\n        var last= n%10;\\n        rev= rev*10+last;\\n        n= Math.floor(n/10);\\n    }\\n    return rev===x;\\n};\\n\\nlet nextPalindromeNumber= (n)=> {\\n    let digits = [];\\n    let m = n;\\n    while (m > 0) {\\n        digits.unshift(m % 10);\\n        m = Math.trunc(m / 10);\\n    }\\n    let carryFlag = false;\\n    let midPoint = Math.floor(digits.length / 2);\\n\\n    for (let i = 0; i < digits.length; i++) {\\n        let copyFrom = digits[i];\\n        let copyTo = digits[digits.length - 1 - i] + carryFlag;\\n        if (copyTo === 10) {\\n            digits[digits.length - 1 - i] = 0;\\n            carryFlag = true;\\n        }\\n        else {\\n            let digit = (i < midPoint) ? copyFrom : copyTo;\\n            carryFlag = copyTo > digit;\\n            digits[i] = digits[digits.length - 1 - i] = digit;\\n        }\\n    }\\n    return Number(digits.join(\"\"))\\n}\\nlet toBase=(num,base)=> {\\n    let ans = \"\";\\n    while(num > 0){\\n        ans = \"\" + num %base + ans;\\n        num = Math.floor(num/base);\\n    }\\n        return ans;        \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nlet kMirror =(k, n)=> {\\n    let c=1;\\n    let ans=0;\\n    while(0<n){\\n       if(isPalindrome(c)){\\n            let  x = toBase(c,k);\\n            let cont=true\\n            for (let i = 0, j = x.length - 1; i < j; i++, j--) {\\n\\t\\t\\t\\tif (x[i] !== x[j]){\\n\\t\\t\\t\\tcont=false\\n\\t\\t\\t} }\\n\\t\\t\\tif(cont){\\n\\t\\t\\t\\t ans+=c;\\n\\t\\t\\t\\t n--; }\\n               c++\\n        }else{\\n            c=(nextPalindromeNumber(c))\\n        }\\n    }\\n    return ans;\\n};\\n\\nlet isPalindrome =(x)=> {\\n    if(x<0) return false;\\n    let n=x;\\n    let rev=0;\\n    while(n){\\n        var last= n%10;\\n        rev= rev*10+last;\\n        n= Math.floor(n/10);\\n    }\\n    return rev===x;\\n};\\n\\nlet nextPalindromeNumber= (n)=> {\\n    let digits = [];\\n    let m = n;\\n    while (m > 0) {\\n        digits.unshift(m % 10);\\n        m = Math.trunc(m / 10);\\n    }\\n    let carryFlag = false;\\n    let midPoint = Math.floor(digits.length / 2);\\n\\n    for (let i = 0; i < digits.length; i++) {\\n        let copyFrom = digits[i];\\n        let copyTo = digits[digits.length - 1 - i] + carryFlag;\\n        if (copyTo === 10) {\\n            digits[digits.length - 1 - i] = 0;\\n            carryFlag = true;\\n        }\\n        else {\\n            let digit = (i < midPoint) ? copyFrom : copyTo;\\n            carryFlag = copyTo > digit;\\n            digits[i] = digits[digits.length - 1 - i] = digit;\\n        }\\n    }\\n    return Number(digits.join(\"\"))\\n}\\nlet toBase=(num,base)=> {\\n    let ans = \"\";\\n    while(num > 0){\\n        ans = \"\" + num %base + ans;\\n        num = Math.floor(num/base);\\n    }\\n        return ans;        \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1589588,
                "title": "python3-palindrome-generation-with-comments-easy-to-understand",
                "content": "\\nWe are going to generate a batch of palindrome numbers in base 10 incrementally increasing the digits. We check each number if it is palindrome in the base K as well. \\n\\nWe basically use the previous generated palindromes for the next 2 iterations (+1 and +2 digits). We cut each palindrome in half and append a string in the middle to remain palindrome. Example if the number was 1221 we cut it to 12 | 21 and append 12x21 (+1 digits) or 12xx21 (+2 digits)\\n\\n\\n```\\nclass Solution:\\n    def kMirror(self, k: int, n: int) -> int:\\n        count = 0\\n        sum = 0\\n        prevPalindromes = []\\n        digits = 1\\n        while count < n:\\n            # generate a new batch of palindromes with predigined number of digits\\n            palindromes = self.getPalindromes(prevPalindromes, digits)\\n            for palindrome in palindromes:\\n                base10 = int(palindrome)\\n                baseK = self.toBase(base10, k)\\n                # check if the number is palindrome in base K\\n                if baseK[::-1] == baseK:\\n                    sum += base10\\n                    count += 1\\n                    if count == n:\\n                        break\\n            digits += 1\\n            # we are keeping even-digit palindromes for next 2 iterations\\n            if digits % 2 == 1:\\n                prevPalindromes = palindromes\\n        return sum\\n            \\n    # generates palindromes with given number of digits and the palindromes from previous iteration\\n    def getPalindromes(self, prevPalindromes : List[int], digits: int) -> List[int]:\\n        \\n        #initial cases\\n        if len(prevPalindromes) == 0:\\n            if digits == 1:\\n                return [str(i) for i in range(1, 10)]\\n            if digits == 2:\\n                return [str(i) for i in range(11, 100, 11)]\\n            \\n        #calculate the half point where we need to cut the previous palindromes and append new string (appends)\\n        halfPoint = (digits -1) // 2\\n        \\n        #generate new appends based if we need to get odd or even length\\n        if digits % 2 == 0:\\n            appends = [str(i) for i in range(11, 100, 11)]\\n            appends.insert(0,\\'00\\')\\n        else:\\n            appends = [str(i) for i in range(10)]\\n        \\n        result = []\\n        for prevPalindrome in prevPalindromes:\\n            for append in appends:\\n                # from previous palindrome ex. 1221 cut it and generate new palindromes 12xx21                 \\n                result.append(prevPalindrome[:halfPoint]+append+prevPalindrome[halfPoint:2*halfPoint])           \\n        return result\\n    \\n    # convert a number to a given base\\n    def toBase(self, number: int, base: int) -> str:\\n        result = \"\"\\n        while number != 0:\\n            result = str(number % base) + result\\n            number = number // base\\n        return result\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def kMirror(self, k: int, n: int) -> int:\\n        count = 0\\n        sum = 0\\n        prevPalindromes = []\\n        digits = 1\\n        while count < n:\\n            # generate a new batch of palindromes with predigined number of digits\\n            palindromes = self.getPalindromes(prevPalindromes, digits)\\n            for palindrome in palindromes:\\n                base10 = int(palindrome)\\n                baseK = self.toBase(base10, k)\\n                # check if the number is palindrome in base K\\n                if baseK[::-1] == baseK:\\n                    sum += base10\\n                    count += 1\\n                    if count == n:\\n                        break\\n            digits += 1\\n            # we are keeping even-digit palindromes for next 2 iterations\\n            if digits % 2 == 1:\\n                prevPalindromes = palindromes\\n        return sum\\n            \\n    # generates palindromes with given number of digits and the palindromes from previous iteration\\n    def getPalindromes(self, prevPalindromes : List[int], digits: int) -> List[int]:\\n        \\n        #initial cases\\n        if len(prevPalindromes) == 0:\\n            if digits == 1:\\n                return [str(i) for i in range(1, 10)]\\n            if digits == 2:\\n                return [str(i) for i in range(11, 100, 11)]\\n            \\n        #calculate the half point where we need to cut the previous palindromes and append new string (appends)\\n        halfPoint = (digits -1) // 2\\n        \\n        #generate new appends based if we need to get odd or even length\\n        if digits % 2 == 0:\\n            appends = [str(i) for i in range(11, 100, 11)]\\n            appends.insert(0,\\'00\\')\\n        else:\\n            appends = [str(i) for i in range(10)]\\n        \\n        result = []\\n        for prevPalindrome in prevPalindromes:\\n            for append in appends:\\n                # from previous palindrome ex. 1221 cut it and generate new palindromes 12xx21                 \\n                result.append(prevPalindrome[:halfPoint]+append+prevPalindrome[halfPoint:2*halfPoint])           \\n        return result\\n    \\n    # convert a number to a given base\\n    def toBase(self, number: int, base: int) -> str:\\n        result = \"\"\\n        while number != 0:\\n            result = str(number % base) + result\\n            number = number // base\\n        return result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1589549,
                "title": "python3-generating-palindromes-without-using-strings-beat-100",
                "content": "We define a `get_mirrors` generator function to generate panlindromes in base `k`.\\n\\nThe idea is that we can generate a panlindrome of any length by only generating the first half, starting from 10...0 to (k-1)(k-1)...(k-1). Then the remaining half can be added by doing divisions and modulos.\\n\\nUsing two generators one for base k and ther other for base 10, we keep calling `next` on either generator depending on which number is larger.\\n\\n```\\ndef get_mirrors(k):\\n    length = 1\\n    cur = 0\\n    max_cur = k ** ((length + 1) // 2)\\n    while True:\\n        cur += 1\\n        if cur == max_cur:\\n            length += 1\\n            max_cur = k ** ((length + 1) // 2)\\n            cur = max_cur // k\\n        num = cur\\n        to_reverse = cur if length % 2 == 0 else cur // k\\n        while to_reverse > 0:\\n            num = num * k + to_reverse % k\\n            to_reverse //= k\\n        yield num\\n\\n\\nclass Solution:\\n    def kMirror(self, k: int, n: int) -> int:\\n        mirrors_k = get_mirrors(k)\\n        mirrors_10 = get_mirrors(10)\\n        mirror_k, mirror_10 = next(mirrors_k), next(mirrors_10)\\n        total = 0\\n        while n > 0:\\n            if mirror_k == mirror_10:\\n                total += mirror_k\\n                n -= 1\\n                mirror_k, mirror_10 = next(mirrors_k), next(mirrors_10)\\n            elif mirror_k > mirror_10:\\n                mirror_10 = next(mirrors_10)\\n            else:\\n                mirror_k = next(mirrors_k)\\n        return total\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```\\ndef get_mirrors(k):\\n    length = 1\\n    cur = 0\\n    max_cur = k ** ((length + 1) // 2)\\n    while True:\\n        cur += 1\\n        if cur == max_cur:\\n            length += 1\\n            max_cur = k ** ((length + 1) // 2)\\n            cur = max_cur // k\\n        num = cur\\n        to_reverse = cur if length % 2 == 0 else cur // k\\n        while to_reverse > 0:\\n            num = num * k + to_reverse % k\\n            to_reverse //= k\\n        yield num\\n\\n\\nclass Solution:\\n    def kMirror(self, k: int, n: int) -> int:\\n        mirrors_k = get_mirrors(k)\\n        mirrors_10 = get_mirrors(10)\\n        mirror_k, mirror_10 = next(mirrors_k), next(mirrors_10)\\n        total = 0\\n        while n > 0:\\n            if mirror_k == mirror_10:\\n                total += mirror_k\\n                n -= 1\\n                mirror_k, mirror_10 = next(mirrors_k), next(mirrors_10)\\n            elif mirror_k > mirror_10:\\n                mirror_10 = next(mirrors_10)\\n            else:\\n                mirror_k = next(mirrors_k)\\n        return total\\n\\n\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565636,
                "content": [
                    {
                        "username": "non_deterministic",
                        "content": "I felt time limit/constraints were too tight. Same is also suggested by the fact that a lot of users had to precompute and use the hard-coded values. Opening this thread to invite thoughts on the same."
                    },
                    {
                        "username": "selder02",
                        "content": "In my opinion, the purpose of the time limit should be to exclude algorithms with the wrong asymptotic complexity, like O(N^2) instead of O(N). Or in this case, it should exclude algorithms that simply iterate over all numbers and check whether they are palindromic in both bases.\\n\\nBut instead, the time limit discriminates against some solutions simply because they have small constant factors of overhead compared to others. This is unfair. The spirit of the problem should be to come up with a good algorithm, not to hunt down factors of 1.5."
                    },
                    {
                        "username": "lz2657",
                        "content": "Anyone one the same boat as me?\\n\\nhttps://leetcode.com/discuss/general-discussion/951105/New-Contest-Rule-(effective-from-December-2020)/779933\\nHere\\'s the latest(?) contest rule about hardcoding."
                    }
                ]
            },
            {
                "id": 1567695,
                "content": [
                    {
                        "username": "non_deterministic",
                        "content": "I felt time limit/constraints were too tight. Same is also suggested by the fact that a lot of users had to precompute and use the hard-coded values. Opening this thread to invite thoughts on the same."
                    },
                    {
                        "username": "selder02",
                        "content": "In my opinion, the purpose of the time limit should be to exclude algorithms with the wrong asymptotic complexity, like O(N^2) instead of O(N). Or in this case, it should exclude algorithms that simply iterate over all numbers and check whether they are palindromic in both bases.\\n\\nBut instead, the time limit discriminates against some solutions simply because they have small constant factors of overhead compared to others. This is unfair. The spirit of the problem should be to come up with a good algorithm, not to hunt down factors of 1.5."
                    },
                    {
                        "username": "lz2657",
                        "content": "Anyone one the same boat as me?\\n\\nhttps://leetcode.com/discuss/general-discussion/951105/New-Contest-Rule-(effective-from-December-2020)/779933\\nHere\\'s the latest(?) contest rule about hardcoding."
                    }
                ]
            },
            {
                "id": 1567694,
                "content": [
                    {
                        "username": "non_deterministic",
                        "content": "I felt time limit/constraints were too tight. Same is also suggested by the fact that a lot of users had to precompute and use the hard-coded values. Opening this thread to invite thoughts on the same."
                    },
                    {
                        "username": "selder02",
                        "content": "In my opinion, the purpose of the time limit should be to exclude algorithms with the wrong asymptotic complexity, like O(N^2) instead of O(N). Or in this case, it should exclude algorithms that simply iterate over all numbers and check whether they are palindromic in both bases.\\n\\nBut instead, the time limit discriminates against some solutions simply because they have small constant factors of overhead compared to others. This is unfair. The spirit of the problem should be to come up with a good algorithm, not to hunt down factors of 1.5."
                    },
                    {
                        "username": "lz2657",
                        "content": "Anyone one the same boat as me?\\n\\nhttps://leetcode.com/discuss/general-discussion/951105/New-Contest-Rule-(effective-from-December-2020)/779933\\nHere\\'s the latest(?) contest rule about hardcoding."
                    }
                ]
            }
        ]
    },
    {
        "title": "The Number of Rich Customers",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1995885,
                "content": [
                    {
                        "username": "timode-6",
                        "content": "```\\nselect count(distinct customer_id) as rich_count from store where amount > 500\\n```"
                    },
                    {
                        "username": "koppakaalekhya",
                        "content": "select count(c.customer_id)  as rich_count from (select count(customer_id) as customer_id, sum(amount) as amount  from Store \\nwhere amount > 500\\ngroup by customer_id) as c;"
                    },
                    {
                        "username": "peter_troitsky",
                        "content": "Output and Expected are the same. What\\'s wrong with leetcode, every task...\\nimport pandas as pd\\n\\ndef count_rich_customers(store: pd.DataFrame) -> pd.DataFrame:\\n    df = store.query(\\'amount > 500\\')\\n    df = df.groupby(\\'customer_id\\').agg({\\'amount\\': \\'count\\'})\\n    n = df.count().astype(int)\\n    return pd.DataFrame({\\'rich_count\\': [n]})"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "You can construct the DataFrame expected by the testrunner like so\\n```\\nans = pd.DataFrame({\\'column_name\\': values})\\n```\\nwhen creating a dataframe with a single value, remember to wrap it in a list. It is still a Series."
                    }
                ]
            },
            {
                "id": 1872415,
                "content": [
                    {
                        "username": "timode-6",
                        "content": "```\\nselect count(distinct customer_id) as rich_count from store where amount > 500\\n```"
                    },
                    {
                        "username": "koppakaalekhya",
                        "content": "select count(c.customer_id)  as rich_count from (select count(customer_id) as customer_id, sum(amount) as amount  from Store \\nwhere amount > 500\\ngroup by customer_id) as c;"
                    },
                    {
                        "username": "peter_troitsky",
                        "content": "Output and Expected are the same. What\\'s wrong with leetcode, every task...\\nimport pandas as pd\\n\\ndef count_rich_customers(store: pd.DataFrame) -> pd.DataFrame:\\n    df = store.query(\\'amount > 500\\')\\n    df = df.groupby(\\'customer_id\\').agg({\\'amount\\': \\'count\\'})\\n    n = df.count().astype(int)\\n    return pd.DataFrame({\\'rich_count\\': [n]})"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "You can construct the DataFrame expected by the testrunner like so\\n```\\nans = pd.DataFrame({\\'column_name\\': values})\\n```\\nwhen creating a dataframe with a single value, remember to wrap it in a list. It is still a Series."
                    }
                ]
            },
            {
                "id": 2037521,
                "content": [
                    {
                        "username": "timode-6",
                        "content": "```\\nselect count(distinct customer_id) as rich_count from store where amount > 500\\n```"
                    },
                    {
                        "username": "koppakaalekhya",
                        "content": "select count(c.customer_id)  as rich_count from (select count(customer_id) as customer_id, sum(amount) as amount  from Store \\nwhere amount > 500\\ngroup by customer_id) as c;"
                    },
                    {
                        "username": "peter_troitsky",
                        "content": "Output and Expected are the same. What\\'s wrong with leetcode, every task...\\nimport pandas as pd\\n\\ndef count_rich_customers(store: pd.DataFrame) -> pd.DataFrame:\\n    df = store.query(\\'amount > 500\\')\\n    df = df.groupby(\\'customer_id\\').agg({\\'amount\\': \\'count\\'})\\n    n = df.count().astype(int)\\n    return pd.DataFrame({\\'rich_count\\': [n]})"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "You can construct the DataFrame expected by the testrunner like so\\n```\\nans = pd.DataFrame({\\'column_name\\': values})\\n```\\nwhen creating a dataframe with a single value, remember to wrap it in a list. It is still a Series."
                    }
                ]
            },
            {
                "id": 2027415,
                "content": [
                    {
                        "username": "timode-6",
                        "content": "```\\nselect count(distinct customer_id) as rich_count from store where amount > 500\\n```"
                    },
                    {
                        "username": "koppakaalekhya",
                        "content": "select count(c.customer_id)  as rich_count from (select count(customer_id) as customer_id, sum(amount) as amount  from Store \\nwhere amount > 500\\ngroup by customer_id) as c;"
                    },
                    {
                        "username": "peter_troitsky",
                        "content": "Output and Expected are the same. What\\'s wrong with leetcode, every task...\\nimport pandas as pd\\n\\ndef count_rich_customers(store: pd.DataFrame) -> pd.DataFrame:\\n    df = store.query(\\'amount > 500\\')\\n    df = df.groupby(\\'customer_id\\').agg({\\'amount\\': \\'count\\'})\\n    n = df.count().astype(int)\\n    return pd.DataFrame({\\'rich_count\\': [n]})"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "You can construct the DataFrame expected by the testrunner like so\\n```\\nans = pd.DataFrame({\\'column_name\\': values})\\n```\\nwhen creating a dataframe with a single value, remember to wrap it in a list. It is still a Series."
                    }
                ]
            }
        ]
    },
    {
        "title": "Substrings That Begin and End With the Same Letter",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1933443,
                "content": [
                    {
                        "username": "stefan1096",
                        "content": "Downvoted,this should be marked as easy"
                    }
                ]
            }
        ]
    },
    {
        "title": "Drop Type 1 Orders for Customers With Type 0 Orders",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1576223,
                "content": [
                    {
                        "username": "AbhilashMuthyala",
                        "content": "\\twith cust as (\\n\\tSelect distinct customer_id from Orders\\n\\twhere order_type = 0\\n\\t\\t)\\n\\tSelect * from Orders\\n\\twhere (customer_id not in (select * from cust)) or (customer_id in (select * from cust) and order_type = 0)"
                    },
                    {
                        "username": "vinayakam19",
                        "content": "using cte\\n\\n `with type_0_orders as (select *, RANK() OVER(PARTITION BY customer_id ORDER BY order_type asc) as value_rank from Orders)\\n\\nselect order_id, customer_id, order_type from type_0_orders where value_rank = 1;`"
                    },
                    {
                        "username": "baobui258",
                        "content": "```\\n# Write your MySQL query statement below\\nwith order_no_0 as (\\n    select\\n        customer_id\\n    from\\n        Orders\\n    group by customer_id\\n    having count(*) = sum(order_type)\\n)\\nselect * \\nfrom \\n    Orders \\nwhere \\n    customer_id in (select customer_id from order_no_0) or order_type = 0\\n```"
                    }
                ]
            },
            {
                "id": 1810589,
                "content": [
                    {
                        "username": "AbhilashMuthyala",
                        "content": "\\twith cust as (\\n\\tSelect distinct customer_id from Orders\\n\\twhere order_type = 0\\n\\t\\t)\\n\\tSelect * from Orders\\n\\twhere (customer_id not in (select * from cust)) or (customer_id in (select * from cust) and order_type = 0)"
                    },
                    {
                        "username": "vinayakam19",
                        "content": "using cte\\n\\n `with type_0_orders as (select *, RANK() OVER(PARTITION BY customer_id ORDER BY order_type asc) as value_rank from Orders)\\n\\nselect order_id, customer_id, order_type from type_0_orders where value_rank = 1;`"
                    },
                    {
                        "username": "baobui258",
                        "content": "```\\n# Write your MySQL query statement below\\nwith order_no_0 as (\\n    select\\n        customer_id\\n    from\\n        Orders\\n    group by customer_id\\n    having count(*) = sum(order_type)\\n)\\nselect * \\nfrom \\n    Orders \\nwhere \\n    customer_id in (select customer_id from order_no_0) or order_type = 0\\n```"
                    }
                ]
            },
            {
                "id": 1693189,
                "content": [
                    {
                        "username": "AbhilashMuthyala",
                        "content": "\\twith cust as (\\n\\tSelect distinct customer_id from Orders\\n\\twhere order_type = 0\\n\\t\\t)\\n\\tSelect * from Orders\\n\\twhere (customer_id not in (select * from cust)) or (customer_id in (select * from cust) and order_type = 0)"
                    },
                    {
                        "username": "vinayakam19",
                        "content": "using cte\\n\\n `with type_0_orders as (select *, RANK() OVER(PARTITION BY customer_id ORDER BY order_type asc) as value_rank from Orders)\\n\\nselect order_id, customer_id, order_type from type_0_orders where value_rank = 1;`"
                    },
                    {
                        "username": "baobui258",
                        "content": "```\\n# Write your MySQL query statement below\\nwith order_no_0 as (\\n    select\\n        customer_id\\n    from\\n        Orders\\n    group by customer_id\\n    having count(*) = sum(order_type)\\n)\\nselect * \\nfrom \\n    Orders \\nwhere \\n    customer_id in (select customer_id from order_no_0) or order_type = 0\\n```"
                    }
                ]
            }
        ]
    }
]