[
    {
        "title": "Find Largest Value in Each Tree Row",
        "question_content": "Given the root of a binary tree, return an array of the largest value in each row of the tree (0-indexed).\n&nbsp;\nExample 1:\n\nInput: root = [1,3,2,5,3,null,9]\nOutput: [1,3,9]\n\nExample 2:\n\nInput: root = [1,2,3]\nOutput: [1,3]\n\n&nbsp;\nConstraints:\n\n\tThe number of nodes in the tree will be in the range [0, 104].\n\t-231 <= Node.val <= 231 - 1",
        "solutions": [
            {
                "id": 98971,
                "title": "9ms-java-dfs-solution",
                "content": "**Just a simple pre-order traverse idea. Use depth to expand result list size and put the max value in the appropriate position.**\\n\\n```\\npublic class Solution {\\n    public List<Integer> largestValues(TreeNode root) {\\n        List<Integer> res = new ArrayList<Integer>();\\n        helper(root, res, 0);\\n        return res;\\n    }\\n    private void helper(TreeNode root, List<Integer> res, int d){\\n        if(root == null){\\n            return;\\n        }\\n       //expand list size\\n        if(d == res.size()){\\n            res.add(root.val);\\n        }\\n        else{\\n        //or set value\\n            res.set(d, Math.max(res.get(d), root.val));\\n        }\\n        helper(root.left, res, d+1);\\n        helper(root.right, res, d+1);\\n    }\\n}\\n````",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public List<Integer> largestValues(TreeNode root) {\\n        List<Integer> res = new ArrayList<Integer>();\\n        helper(root, res, 0);\\n        return res;\\n    }\\n    private void helper(TreeNode root, List<Integer> res, int d){\\n        if(root == null){\\n            return;\\n        }\\n       //expand list size\\n        if(d == res.size()){\\n            res.add(root.val);\\n        }\\n        else{\\n        //or set value\\n            res.set(d, Math.max(res.get(d), root.val));\\n        }\\n        helper(root.left, res, d+1);\\n        helper(root.right, res, d+1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 99000,
                "title": "python-bfs",
                "content": "    def findValueMostElement(self, root):\\n        maxes = []\\n        row = [root]\\n        while any(row):\\n            maxes.append(max(node.val for node in row))\\n            row = [kid for node in row for kid in (node.left, node.right) if kid]\\n        return maxes",
                "solutionTags": [],
                "code": "    def findValueMostElement(self, root):\\n        maxes = []\\n        row = [root]\\n        while any(row):\\n            maxes.append(max(node.val for node in row))\\n            row = [kid for node in row for kid in (node.left, node.right) if kid]\\n        return maxes",
                "codeTag": "Python3"
            },
            {
                "id": 99035,
                "title": "c-a-different-approach-12ms-beats-100",
                "content": "```\\nclass Solution {\\n    vector<int> solution;\\npublic:\\n    void helper(TreeNode* node, int cl) {\\n        if (node == NULL) {\\n            return;\\n        }\\n        if (solution.size() < cl + 1) {\\n            solution.push_back(node->val);\\n        } else {\\n            if (solution[cl] < node->val) {\\n                solution[cl] = node->val;\\n            }\\n        }\\n        helper(node->left, cl+1);\\n        helper(node->right, cl+1);\\n    }\\n    //vector<int> largestValues(TreeNode* root) {\\n    vector<int> findValueMostElement(TreeNode* root) {\\n        if(root == NULL) {\\n            return solution;\\n        }\\n        \\n        helper(root, 0);\\n        return solution;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    vector<int> solution;\\npublic:\\n    void helper(TreeNode* node, int cl) {\\n        if (node == NULL) {\\n            return;\\n        }\\n        if (solution.size() < cl + 1) {\\n            solution.push_back(node->val);\\n        } else {\\n            if (solution[cl] < node->val) {\\n                solution[cl] = node->val;\\n            }\\n        }\\n        helper(node->left, cl+1);\\n        helper(node->right, cl+1);\\n    }\\n    //vector<int> largestValues(TreeNode* root) {\\n    vector<int> findValueMostElement(TreeNode* root) {\\n        if(root == NULL) {\\n            return solution;\\n        }\\n        \\n        helper(root, 0);\\n        return solution;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 98976,
                "title": "java-bfs",
                "content": "```\\n    public int[] findValueMostElement(TreeNode root) {\\n        Queue<TreeNode> queue = new LinkedList<TreeNode>();\\n        List<Integer> res = new ArrayList<Integer>();\\n        queue.add(root);\\n        int queueSize = root == null ? 0 : 1;\\n        while (queueSize > 0) {\\n            int largestElement = Integer.MIN_VALUE;\\n            for (int i=0;i<queueSize;i++) {\\n                TreeNode cur = queue.poll();\\n                largestElement = Math.max(cur.val, largestElement);\\n                if (cur.left != null) queue.add(cur.left);\\n                if (cur.right != null) queue.add(cur.right);\\n            }\\n            res.add(largestElement);\\n            queueSize = queue.size();\\n        }\\n        int[] resArray = new int[res.size()];\\n        for (int i=0;i<res.size();i++) resArray[i] = res.get(i);\\n        return resArray;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int[] findValueMostElement(TreeNode root) {\\n        Queue<TreeNode> queue = new LinkedList<TreeNode>();\\n        List<Integer> res = new ArrayList<Integer>();\\n        queue.add(root);\\n        int queueSize = root == null ? 0 : 1;\\n        while (queueSize > 0) {\\n            int largestElement = Integer.MIN_VALUE;\\n            for (int i=0;i<queueSize;i++) {\\n                TreeNode cur = queue.poll();\\n                largestElement = Math.max(cur.val, largestElement);\\n                if (cur.left != null) queue.add(cur.left);\\n                if (cur.right != null) queue.add(cur.right);\\n            }\\n            res.add(largestElement);\\n            queueSize = queue.size();\\n        }\\n        int[] resArray = new int[res.size()];\\n        for (int i=0;i<res.size();i++) resArray[i] = res.get(i);\\n        return resArray;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 99006,
                "title": "c-clean-code-dfs-preorder-postorder",
                "content": "**PreOrder**\\n```\\nclass Solution {\\npublic:\\n    vector<int> largestValues(TreeNode* root) {\\n        vector<int> maxs;\\n        find(root, 0, maxs);\\n        return maxs;\\n    }\\n\\nprivate:\\n    void find(TreeNode* node, int row, vector<int>& maxs) {\\n        if (!node) {\\n            return;\\n        }\\n\\n        if (row >= maxs.size()) {\\n            maxs.push_back(node->val);\\n        }\\n        else {\\n            maxs[row] = max(maxs[row], node->val);\\n        }\\n\\n        find(node->left, row + 1, maxs);\\n        find(node->right, row + 1, maxs);\\n    }\\n};\\n```\\n\\n**Post Order**\\nIn preorder solution the vector have been constantly resized, and each time add 1 because we don't know how deep the tree is. If change to post order, we can resize the vector only at leaf node, this should improve the performance.\\n```\\nclass Solution {\\npublic:\\n    vector<int> largestValues(TreeNode* root) {\\n        vector<int> res;\\n        dfs(root, 1, res);\\n        return res;\\n    }\\n\\nprivate:\\n    void dfs(TreeNode* node, int depth, vector<int>& res) {\\n        if (!node) {\\n            return;\\n        }\\n        dfs(node->left, depth + 1, res);\\n        dfs(node->right, depth + 1, res);\\n        if (depth > res.size()) {\\n            res.resize(depth, INT_MIN);\\n        }\\n        res[depth - 1] = max(res[depth - 1], node->val);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> largestValues(TreeNode* root) {\\n        vector<int> maxs;\\n        find(root, 0, maxs);\\n        return maxs;\\n    }\\n\\nprivate:\\n    void find(TreeNode* node, int row, vector<int>& maxs) {\\n        if (!node) {\\n            return;\\n        }\\n\\n        if (row >= maxs.size()) {\\n            maxs.push_back(node->val);\\n        }\\n        else {\\n            maxs[row] = max(maxs[row], node->val);\\n        }\\n\\n        find(node->left, row + 1, maxs);\\n        find(node->right, row + 1, maxs);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> largestValues(TreeNode* root) {\\n        vector<int> res;\\n        dfs(root, 1, res);\\n        return res;\\n    }\\n\\nprivate:\\n    void dfs(TreeNode* node, int depth, vector<int>& res) {\\n        if (!node) {\\n            return;\\n        }\\n        dfs(node->left, depth + 1, res);\\n        dfs(node->right, depth + 1, res);\\n        if (depth > res.size()) {\\n            res.resize(depth, INT_MIN);\\n        }\\n        res[depth - 1] = max(res[depth - 1], node->val);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 99018,
                "title": "python-bfs-dfs",
                "content": "    class Solution(object):\\n        def largestValues(self, root):\\n            ans = []\\n            if root is None:\\n                return ans\\n            queue  = [root]\\n            while queue:\\n                ans.append(max(x.val for x in queue))\\n                new_queue = []\\n                for node in queue:\\n                    if node.left:\\n                        new_queue.append(node.left)\\n                    if node.right:\\n                        new_queue.append(node.right)\\n                queue = new_queue\\n            return ans\\n\\n    class Solution(object):\\n        def largestValues(self, root):\\n            self.ans = []\\n            self.helper(root, 0)\\n            return self.ans\\n        \\n        def helper(self, node, level):\\n            if not node:\\n                return\\n            if len(self.ans) == level:\\n                self.ans.append(node.val)\\n            else:\\n                self.ans[level] = max(self.ans[level], node.val)\\n            self.helper(node.left, level+1)\\n            self.helper(node.right, level+1)",
                "solutionTags": [],
                "code": "    class Solution(object):\\n        def largestValues(self, root):\\n            ans = []\\n            if root is None:\\n                return ans\\n            queue  = [root]\\n            while queue:\\n                ans.append(max(x.val for x in queue))\\n                new_queue = []\\n                for node in queue:\\n                    if node.left:\\n                        new_queue.append(node.left)\\n                    if node.right:\\n                        new_queue.append(node.right)\\n                queue = new_queue\\n            return ans\\n\\n    class Solution(object):\\n        def largestValues(self, root):\\n            self.ans = []\\n            self.helper(root, 0)\\n            return self.ans\\n        \\n        def helper(self, node, level):\\n            if not node:\\n                return\\n            if len(self.ans) == level:\\n                self.ans.append(node.val)\\n            else:\\n                self.ans[level] = max(self.ans[level], node.val)\\n            self.helper(node.left, level+1)\\n            self.helper(node.right, level+1)",
                "codeTag": "Java"
            },
            {
                "id": 880711,
                "title": "cpp-easy-solution-using-queue-also-attached-other-7-similar-code-problems",
                "content": "**Find Largest Value in Each Tree Row(Leetcode 515)----**\\n```\\nclass Solution {\\npublic:\\n    vector<int> largestValues(TreeNode* root) {\\n        queue<TreeNode*>q;\\n        vector<int>temp;\\n       vector<vector<int>>ans;\\n        if(root==NULL) return temp;\\n        q.push(root);\\n        while(q.empty()!=true)\\n        {   vector<int>v;\\n            int n=q.size();\\n            for(int i=0;i<n;i++)\\n            {   TreeNode* t=q.front();q.pop();\\n                v.push_back(t->val);\\n                if(t->left) q.push(t->left);\\n                if(t->right) q.push(t->right);\\n            }\\n            ans.push_back(v);\\n         int ma=v[0];\\n         for(int i=1;i<v.size();i++)\\n             ma=max(ma,v[i]);\\n         temp.push_back(ma);\\n        }\\n        return temp;\\n    }\\n};\\n```\\n\\n**Binary tree level order traversal(Leetcode 102)------**\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> levelOrder(TreeNode* root) {\\n       queue<TreeNode*>q;\\n       vector<vector<int>>ans;\\n        if(root==NULL) return ans;\\n        q.push(root);\\n        while(q.empty()!=true)\\n        {   vector<int>v;\\n            int n=q.size();\\n            for(int i=0;i<n;i++)\\n            {   TreeNode* t=q.front();q.pop();\\n                v.push_back(t->val);\\n                if(t->left) q.push(t->left);\\n                if(t->right) q.push(t->right);\\n            }\\n            ans.push_back(v);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n\\n**Binary order level order traversal II (Leetcode 107)-------**\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> levelOrderBottom(TreeNode* root) {\\n       queue<TreeNode*>q;\\n       vector<vector<int>>ans;\\n        if(root==NULL) return ans;\\n        q.push(root);\\n        while(q.empty()!=true)\\n        {   vector<int>v;\\n            int n=q.size();\\n            for(int i=0;i<n;i++)\\n            {   TreeNode* t=q.front();q.pop();\\n                v.push_back(t->val);\\n                if(t->left) q.push(t->left);\\n                if(t->right) q.push(t->right);\\n            }\\n            ans.push_back(v);\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```\\n**Average of Levels in Binary Tree(Leetcode 637)-----**\\n```\\nclass Solution {\\npublic:\\n    vector<double> averageOfLevels(TreeNode* root) {\\n       queue<TreeNode*>q;\\n        vector<double>temp;\\n       vector<vector<int>>ans;\\n        if(root==NULL) return temp;\\n        q.push(root);\\n        while(q.empty()!=true)\\n        {   vector<int>v;\\n            int n=q.size();\\n            for(int i=0;i<n;i++)\\n            {   TreeNode* t=q.front();q.pop();\\n                v.push_back(t->val);\\n                if(t->left) q.push(t->left);\\n                if(t->right) q.push(t->right);\\n            }\\n            ans.push_back(v);\\n         double total=0;\\n         for(int j=0;j<v.size();j++)\\n             total+=v[j];\\n         double r=total/v.size();\\n         temp.push_back(r);\\n        }\\n        return temp;\\n    }\\n};\\n```\\n\\n**N-ary Tree Level Order Traversal(Leetcode 429)------**\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> levelOrder(Node* root) {\\n       queue<Node*>q;\\n       vector<vector<int>>ans;\\n        if(root==NULL) return ans;\\n        q.push(root);\\n        while(q.empty()!=true)\\n        {   vector<int>v;\\n            int n=q.size();\\n            for(int i=0;i<n;i++)\\n            {   Node* t=q.front();q.pop();\\n                v.push_back(t->val);\\n                for(int j=0;j<t->children.size();j++)\\n                   q.push(t->children[j]);\\n            }\\n            ans.push_back(v);\\n        }\\n        return ans; \\n    }\\n};\\n```\\n\\n**Binary Tree Zigzag Level Order Traversal(Leetcode 103)-----**\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n        queue<TreeNode*>q;\\n       vector<vector<int>>ans;\\n        if(root==NULL) return ans;\\n        q.push(root);\\n        int j=0;\\n        while(q.empty()!=true)\\n        {   vector<int>v;\\n            int n=q.size();\\n            for(int i=0;i<n;i++)\\n            {   TreeNode* t=q.front();q.pop();\\n                v.push_back(t->val);\\n                if(t->left) q.push(t->left);\\n                if(t->right) q.push(t->right);\\n            }\\n         if(j%2==1)\\n             reverse(v.begin(),v.end());\\n         j++;\\n            ans.push_back(v);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Binary Tree Right Side View(Leetcode 199)-----**\\n```\\nclass Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n       queue<TreeNode*>q;\\n        vector<int>temp;\\n       vector<vector<int>>ans;\\n        if(root==NULL) return temp;\\n        q.push(root);\\n        while(q.empty()!=true)\\n        {   vector<int>v;\\n            int n=q.size();\\n            for(int i=0;i<n;i++)\\n            {   TreeNode* t=q.front();q.pop();\\n                v.push_back(t->val);\\n                if(t->left) q.push(t->left);\\n                if(t->right) q.push(t->right);\\n            }\\n            ans.push_back(v);\\n         temp.push_back(v[v.size()-1]);\\n        }\\n        return temp;\\n    }\\n};\\n```\\n\\n**Even odd tree (Leetcode 1609)-------**\\n```\\nclass Solution {\\npublic:\\n    bool isEvenOddTree(TreeNode* root) {\\n        queue<TreeNode*>q;\\n        vector<vector<int>>ans;\\n        if(root==NULL) return true;\\n        q.push(root);\\n        int j=0;\\n        while(q.empty()!=true)\\n        {   vector<int>v;\\n            int n=q.size();\\n            for(int i=0;i<n;i++)\\n            {   TreeNode* t=q.front();q.pop();\\n                v.push_back(t->val);\\n                if(t->left) q.push(t->left);\\n                if(t->right) q.push(t->right);\\n            }\\n         if(j%2==0)\\n         {\\n             for(int k=0;k<v.size()-1;k++)\\n             {\\n                 if(v[k]%2==0)\\n                     return false;\\n                 if(v[k]>=v[k+1])\\n                     return false;\\n             }\\n             if(v[v.size()-1]%2==0)\\n                 return false;\\n         }\\n         else\\n         {\\n              for(int k=0;k<v.size()-1;k++)\\n             {\\n                 if(v[k]%2==1)\\n                     return false;\\n                 if(v[k]<=v[k+1])\\n                     return false;\\n             }\\n             if(v[v.size()-1]%2==1)\\n                 return false;\\n         }\\n         j++;\\n            ans.push_back(v);\\n        }\\n        return true;\\n    }\\n};\\n```\\n**If u find this post usefull please upvote it :)**\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> largestValues(TreeNode* root) {\\n        queue<TreeNode*>q;\\n        vector<int>temp;\\n       vector<vector<int>>ans;\\n        if(root==NULL) return temp;\\n        q.push(root);\\n        while(q.empty()!=true)\\n        {   vector<int>v;\\n            int n=q.size();\\n            for(int i=0;i<n;i++)\\n            {   TreeNode* t=q.front();q.pop();\\n                v.push_back(t->val);\\n                if(t->left) q.push(t->left);\\n                if(t->right) q.push(t->right);\\n            }\\n            ans.push_back(v);\\n         int ma=v[0];\\n         for(int i=1;i<v.size();i++)\\n             ma=max(ma,v[i]);\\n         temp.push_back(ma);\\n        }\\n        return temp;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> levelOrder(TreeNode* root) {\\n       queue<TreeNode*>q;\\n       vector<vector<int>>ans;\\n        if(root==NULL) return ans;\\n        q.push(root);\\n        while(q.empty()!=true)\\n        {   vector<int>v;\\n            int n=q.size();\\n            for(int i=0;i<n;i++)\\n            {   TreeNode* t=q.front();q.pop();\\n                v.push_back(t->val);\\n                if(t->left) q.push(t->left);\\n                if(t->right) q.push(t->right);\\n            }\\n            ans.push_back(v);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> levelOrderBottom(TreeNode* root) {\\n       queue<TreeNode*>q;\\n       vector<vector<int>>ans;\\n        if(root==NULL) return ans;\\n        q.push(root);\\n        while(q.empty()!=true)\\n        {   vector<int>v;\\n            int n=q.size();\\n            for(int i=0;i<n;i++)\\n            {   TreeNode* t=q.front();q.pop();\\n                v.push_back(t->val);\\n                if(t->left) q.push(t->left);\\n                if(t->right) q.push(t->right);\\n            }\\n            ans.push_back(v);\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<double> averageOfLevels(TreeNode* root) {\\n       queue<TreeNode*>q;\\n        vector<double>temp;\\n       vector<vector<int>>ans;\\n        if(root==NULL) return temp;\\n        q.push(root);\\n        while(q.empty()!=true)\\n        {   vector<int>v;\\n            int n=q.size();\\n            for(int i=0;i<n;i++)\\n            {   TreeNode* t=q.front();q.pop();\\n                v.push_back(t->val);\\n                if(t->left) q.push(t->left);\\n                if(t->right) q.push(t->right);\\n            }\\n            ans.push_back(v);\\n         double total=0;\\n         for(int j=0;j<v.size();j++)\\n             total+=v[j];\\n         double r=total/v.size();\\n         temp.push_back(r);\\n        }\\n        return temp;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> levelOrder(Node* root) {\\n       queue<Node*>q;\\n       vector<vector<int>>ans;\\n        if(root==NULL) return ans;\\n        q.push(root);\\n        while(q.empty()!=true)\\n        {   vector<int>v;\\n            int n=q.size();\\n            for(int i=0;i<n;i++)\\n            {   Node* t=q.front();q.pop();\\n                v.push_back(t->val);\\n                for(int j=0;j<t->children.size();j++)\\n                   q.push(t->children[j]);\\n            }\\n            ans.push_back(v);\\n        }\\n        return ans; \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n        queue<TreeNode*>q;\\n       vector<vector<int>>ans;\\n        if(root==NULL) return ans;\\n        q.push(root);\\n        int j=0;\\n        while(q.empty()!=true)\\n        {   vector<int>v;\\n            int n=q.size();\\n            for(int i=0;i<n;i++)\\n            {   TreeNode* t=q.front();q.pop();\\n                v.push_back(t->val);\\n                if(t->left) q.push(t->left);\\n                if(t->right) q.push(t->right);\\n            }\\n         if(j%2==1)\\n             reverse(v.begin(),v.end());\\n         j++;\\n            ans.push_back(v);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n       queue<TreeNode*>q;\\n        vector<int>temp;\\n       vector<vector<int>>ans;\\n        if(root==NULL) return temp;\\n        q.push(root);\\n        while(q.empty()!=true)\\n        {   vector<int>v;\\n            int n=q.size();\\n            for(int i=0;i<n;i++)\\n            {   TreeNode* t=q.front();q.pop();\\n                v.push_back(t->val);\\n                if(t->left) q.push(t->left);\\n                if(t->right) q.push(t->right);\\n            }\\n            ans.push_back(v);\\n         temp.push_back(v[v.size()-1]);\\n        }\\n        return temp;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isEvenOddTree(TreeNode* root) {\\n        queue<TreeNode*>q;\\n        vector<vector<int>>ans;\\n        if(root==NULL) return true;\\n        q.push(root);\\n        int j=0;\\n        while(q.empty()!=true)\\n        {   vector<int>v;\\n            int n=q.size();\\n            for(int i=0;i<n;i++)\\n            {   TreeNode* t=q.front();q.pop();\\n                v.push_back(t->val);\\n                if(t->left) q.push(t->left);\\n                if(t->right) q.push(t->right);\\n            }\\n         if(j%2==0)\\n         {\\n             for(int k=0;k<v.size()-1;k++)\\n             {\\n                 if(v[k]%2==0)\\n                     return false;\\n                 if(v[k]>=v[k+1])\\n                     return false;\\n             }\\n             if(v[v.size()-1]%2==0)\\n                 return false;\\n         }\\n         else\\n         {\\n              for(int k=0;k<v.size()-1;k++)\\n             {\\n                 if(v[k]%2==1)\\n                     return false;\\n                 if(v[k]<=v[k+1])\\n                     return false;\\n             }\\n             if(v[v.size()-1]%2==1)\\n                 return false;\\n         }\\n         j++;\\n            ans.push_back(v);\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 99045,
                "title": "1-liner-python-divide-and-conquer",
                "content": "Do it for the left and right subtree, then combine their results by taking the maximum of left and right for each level (and prepend the root's value).\\n\\nFirst a more readable version:\\n\\n    def largestValues(self, root):\\n        if not root:\\n            return []\\n        left = self.largestValues(root.left)\\n        right = self.largestValues(root.right)\\n        return [root.val] + map(max, left, right)\\n\\nAnd here's the 1-liner:\\n\\n    def largestValues(self, root):\\n        return [root.val] + map(max, *map(self.largestValues, (root.left, root.right))) if root else []\\n\\nEdit: In case you're interested in complexities, there's a little discussion about it [here](https://discuss.leetcode.com/topic/31162/mergesort-solution/37).",
                "solutionTags": [],
                "code": "Do it for the left and right subtree, then combine their results by taking the maximum of left and right for each level (and prepend the root's value).\\n\\nFirst a more readable version:\\n\\n    def largestValues(self, root):\\n        if not root:\\n            return []\\n        left = self.largestValues(root.left)\\n        right = self.largestValues(root.right)\\n        return [root.val] + map(max, left, right)\\n\\nAnd here's the 1-liner:\\n\\n    def largestValues(self, root):\\n        return [root.val] + map(max, *map(self.largestValues, (root.left, root.right))) if root else []\\n\\nEdit: In case you're interested in complexities, there's a little discussion about it [here](https://discuss.leetcode.com/topic/31162/mergesort-solution/37).",
                "codeTag": "Python3"
            },
            {
                "id": 558328,
                "title": "php-not-working",
                "content": "I get the following error even when I haven\\'t written any code yet. How do I report a bug?\\n\\n```\\nLine 7: PHP Fatal error:  Uncaught TypeError: Argument 1 passed to Serializer::serializeArray() must be of the type array, null given, called in /leetcode/precompiled/serializer.php on line 79 and defined in serializer.php\\nStack trace:\\n#0 serializer.php: Serializer-&gt;serializeArray(NULL, \\'integer\\')\\n#1 solution.php: Serializer-&gt;serialize(NULL, \\'list&lt;integer&gt;\\')\\n#2 {main}\\n```",
                "solutionTags": [],
                "code": "```\\nLine 7: PHP Fatal error:  Uncaught TypeError: Argument 1 passed to Serializer::serializeArray() must be of the type array, null given, called in /leetcode/precompiled/serializer.php on line 79 and defined in serializer.php\\nStack trace:\\n#0 serializer.php: Serializer-&gt;serializeArray(NULL, \\'integer\\')\\n#1 solution.php: Serializer-&gt;serialize(NULL, \\'list&lt;integer&gt;\\')\\n#2 {main}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1368671,
                "title": "java-easy-approach-with-expanation-recursive-preorder",
                "content": "```\\nclass Solution\\n{\\n    private List<Integer> ansList= new ArrayList<>();//global ArrayList\\n    public List<Integer> largestValues(TreeNode root) \\n    {\\n        if(root == null)//when we are provided with the null graph \\n            return ansList;\\n        \\n        maxLevVal(root, 0);//root node depth is 0\\n        return ansList;//containing the list maximum element at each level \\n    }\\n    \\n    public void maxLevVal(TreeNode root, int depth)\\n    {//preorder traversal is used because we are first dealing with the parent and then with their children(Root Left Right)\\n        if(root == null) //base case when we reach to the null node \\n            return;\\n        \\n        //Root\\n        if(ansList.size() <= depth) //first adding all the data at same depth while traversing \\n            ansList.add(root.val);\\n        else\\n        {//ansList.size() > depth\\n            int max= Math.max(ansList.get(depth), root.val);\\n            ansList.set(depth, max);//overiding the value, if we found element greater than the element present in the ArrayList index (depth)\\n        }\\n        maxLevVal(root.left, depth+ 1);//recursively traversing the left subtree and paralley calculating the depth //left\\n        maxLevVal(root.right, depth+ 1);//recursively traversing the right subtree and paralley calculating the depth//right\\n        return;\\n    }\\n}//Please do Upvote, it helps a lot\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution\\n{\\n    private List<Integer> ansList= new ArrayList<>();//global ArrayList\\n    public List<Integer> largestValues(TreeNode root) \\n    {\\n        if(root == null)//when we are provided with the null graph \\n            return ansList;\\n        \\n        maxLevVal(root, 0);//root node depth is 0\\n        return ansList;//containing the list maximum element at each level \\n    }\\n    \\n    public void maxLevVal(TreeNode root, int depth)\\n    {//preorder traversal is used because we are first dealing with the parent and then with their children(Root Left Right)\\n        if(root == null) //base case when we reach to the null node \\n            return;\\n        \\n        //Root\\n        if(ansList.size() <= depth) //first adding all the data at same depth while traversing \\n            ansList.add(root.val);\\n        else\\n        {//ansList.size() > depth\\n            int max= Math.max(ansList.get(depth), root.val);\\n            ansList.set(depth, max);//overiding the value, if we found element greater than the element present in the ArrayList index (depth)\\n        }\\n        maxLevVal(root.left, depth+ 1);//recursively traversing the left subtree and paralley calculating the depth //left\\n        maxLevVal(root.right, depth+ 1);//recursively traversing the right subtree and paralley calculating the depth//right\\n        return;\\n    }\\n}//Please do Upvote, it helps a lot\\n```",
                "codeTag": "Java"
            },
            {
                "id": 99026,
                "title": "verbose-java-solution-binary-tree-level-order-traversal-again",
                "content": "Alright, two binary tree level order traversal problems in one contest. This time, mission is to find the ```max``` of each level...\\n\\n```\\npublic class Solution {\\n    public int[] findValueMostElement(TreeNode root) {\\n        List<Integer> res = new ArrayList<>();\\n        if (root == null) return new int[0];\\n        \\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.add(root);\\n        \\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            int max = Integer.MIN_VALUE;\\n            for (int i = 0; i < size; i++) {\\n                TreeNode node = queue.poll();\\n                max = Math.max(max, node.val);\\n                if (node.left != null) queue.add(node.left);\\n                if (node.right != null) queue.add(node.right);\\n            }\\n            res.add(max);\\n        }\\n        \\n        int[] result = new int[res.size()];\\n        for (int i = 0; i < res.size(); i++) {\\n            result[i] = res.get(i);\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```max```\n```\\npublic class Solution {\\n    public int[] findValueMostElement(TreeNode root) {\\n        List<Integer> res = new ArrayList<>();\\n        if (root == null) return new int[0];\\n        \\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.add(root);\\n        \\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            int max = Integer.MIN_VALUE;\\n            for (int i = 0; i < size; i++) {\\n                TreeNode node = queue.poll();\\n                max = Math.max(max, node.val);\\n                if (node.left != null) queue.add(node.left);\\n                if (node.right != null) queue.add(node.right);\\n            }\\n            res.add(max);\\n        }\\n        \\n        int[] result = new int[res.size()];\\n        for (int i = 0; i < res.size(); i++) {\\n            result[i] = res.get(i);\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 98977,
                "title": "c-simple-solution-concise-code-morris-traversal",
                "content": "Recursion\\nO(n) space\\nO(n) time\\n```\\nclass Solution {\\n    void dfs(TreeNode* cur, vector<int>& res, int height) {\\n        if (!cur)\\n            return;\\n        if (height >= res.size())\\n            res.push_back(cur->val);\\n        else\\n            res[height] = max(res[height], cur->val);\\n        dfs(cur->left, res, height + 1);\\n        dfs(cur->right, res, height + 1);\\n    }\\npublic:\\n    vector<int> largestValues(TreeNode* root) {\\n        vector<int> res;\\n        int height = 0;\\n        dfs(root, res, height);\\n        return res;\\n    }\\n};\\n```\\n\\nMorris Traversal\\nO(1) space\\nO(n) time\\n[Morris Traversal](http://yongblog.us/2017/01/28/Morris-Traversal/)\\n[Get Height by Morris Traversal](http://yongblog.us/2017/02/06/Get-Height-of-Binary-Tree-by-MorrisTraversal/)\\n```\\nclass Solution {\\npublic:\\n    vector<int> largestValues(TreeNode* root) {\\n        vector<int> res;\\n        TreeNode* cur = root, *prev = NULL;\\n        int deep = 0;\\n        while (cur) {\\n            if (cur->left == NULL) {\\n                //\\n                if (deep >= res.size())\\n                    res.push_back(cur->val);\\n                else\\n                    res[deep] = max(res[deep], cur->val);\\n                cur = cur->right;\\n                deep++;\\n            } else {\\n                prev = cur->left;\\n                int move = 1;\\n                while (prev->right && prev->right != cur) {\\n                    prev = prev->right;\\n                    move++;\\n                }\\n                if (prev->right == NULL) {\\n                    if (deep >= res.size())\\n                        res.push_back(cur->val);\\n                    prev->right = cur;\\n                    cur = cur->left;\\n                    deep++;\\n                } else {\\n                    // back to parent node, remove connection\\n                    prev->right = NULL;\\n                    deep -= move + 1;\\n                    //\\n                    if (deep >= res.size())\\n                        res.push_back(cur->val);\\n                    else\\n                        res[deep] = max(res[deep], cur->val);\\n                    cur = cur->right;\\n                    deep++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    void dfs(TreeNode* cur, vector<int>& res, int height) {\\n        if (!cur)\\n            return;\\n        if (height >= res.size())\\n            res.push_back(cur->val);\\n        else\\n            res[height] = max(res[height], cur->val);\\n        dfs(cur->left, res, height + 1);\\n        dfs(cur->right, res, height + 1);\\n    }\\npublic:\\n    vector<int> largestValues(TreeNode* root) {\\n        vector<int> res;\\n        int height = 0;\\n        dfs(root, res, height);\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> largestValues(TreeNode* root) {\\n        vector<int> res;\\n        TreeNode* cur = root, *prev = NULL;\\n        int deep = 0;\\n        while (cur) {\\n            if (cur->left == NULL) {\\n                //\\n                if (deep >= res.size())\\n                    res.push_back(cur->val);\\n                else\\n                    res[deep] = max(res[deep], cur->val);\\n                cur = cur->right;\\n                deep++;\\n            } else {\\n                prev = cur->left;\\n                int move = 1;\\n                while (prev->right && prev->right != cur) {\\n                    prev = prev->right;\\n                    move++;\\n                }\\n                if (prev->right == NULL) {\\n                    if (deep >= res.size())\\n                        res.push_back(cur->val);\\n                    prev->right = cur;\\n                    cur = cur->left;\\n                    deep++;\\n                } else {\\n                    // back to parent node, remove connection\\n                    prev->right = NULL;\\n                    deep -= move + 1;\\n                    //\\n                    if (deep >= res.size())\\n                        res.push_back(cur->val);\\n                    else\\n                        res[deep] = max(res[deep], cur->val);\\n                    cur = cur->right;\\n                    deep++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 957815,
                "title": "c-easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> largestValues(TreeNode* root) {\\n        if(root==NULL) \\n\\t\\t\\treturn {};\\n        vector<int> res;\\n        queue<TreeNode*> q;\\n        q.push(root); \\n        while (!q.empty())\\n        {\\n            int size = q.size(); \\n            int maxi=INT_MIN;\\n            for(int i=0;i<size;i++){\\n                TreeNode* tmp=q.front();\\n                if(tmp->left)\\n                    q.push(tmp->left);\\n                if(tmp->right)\\n                    q.push(tmp->right);\\n                if(maxi<tmp->val)\\n                    maxi=tmp->val;\\n                q.pop();\\n            }\\n            res.push_back(maxi);\\n        }\\n        return res;\\n    }\\n};\\n```\\n**Feel free to ask any question in the comment section.**\\nI hope that you\\'ve found the solution useful.\\nIn that case, **please do upvote and encourage me** to on my quest to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> largestValues(TreeNode* root) {\\n        if(root==NULL) \\n\\t\\t\\treturn {};\\n        vector<int> res;\\n        queue<TreeNode*> q;\\n        q.push(root); \\n        while (!q.empty())\\n        {\\n            int size = q.size(); \\n            int maxi=INT_MIN;\\n            for(int i=0;i<size;i++){\\n                TreeNode* tmp=q.front();\\n                if(tmp->left)\\n                    q.push(tmp->left);\\n                if(tmp->right)\\n                    q.push(tmp->right);\\n                if(maxi<tmp->val)\\n                    maxi=tmp->val;\\n                q.pop();\\n            }\\n            res.push_back(maxi);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 99097,
                "title": "c-bfs-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findValueMostElement(TreeNode* root) {\\n        if(root == nullptr) return {};\\n        queue<TreeNode*> q;\\n        queue<int> level;\\n        \\n        q.push(root);\\n        level.push(0);\\n        vector<int> mac;\\n        \\n        int m=-1;\\n        while(q.size()){\\n            TreeNode *r = q.front(); q.pop();\\n            int l = level.front(); level.pop();\\n            if(r->left) {\\n                q.push(r->left);\\n                level.push(l+1);\\n            }\\n            \\n            if(r->right){\\n                q.push(r->right);\\n                level.push(l+1);\\n            }\\n            \\n            if(l > m){\\n                m = l;\\n                mac.push_back(r->val);\\n            } else {\\n                mac[l] = std::max(mac[l], r->val);\\n            }\\n        }\\n        \\n        return mac;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> findValueMostElement(TreeNode* root) {\\n        if(root == nullptr) return {}",
                "codeTag": "Java"
            },
            {
                "id": 1301375,
                "title": "simple-0ms-bfs-and-dfs-explained",
                "content": "------------DFS-------------\\n\\nApproach: On every index of the answer array, there will be maximum of element of that level, considering level 0 as 0th index, now when going down I increase the level and in the same way decrease when coming up. And check the element on the corresponing index of the array.\\n\\n```\\n    public void largestVals(TreeNode root, int level, ArrayList<Integer> answer){\\n        \\n        if(root == null) return;\\n        \\n        if(answer.size() - 1 < level){\\n            \\n            answer.add(root.val);\\n            \\n        }else{\\n            \\n            if(answer.get(level)  < root.val){\\n                \\n                answer.set(level, root.val);\\n            }\\n            \\n        }\\n        \\n        if(root.left != null){\\n            largestVals(root.left, level + 1, answer);\\n        }\\n        \\n        if(root.right != null) {\\n            \\n            largestVals(root.right, level  + 1, answer);\\n        }\\n        \\n    }\\n    \\n    public List<Integer> largestValues(TreeNode root) {\\n        ArrayList<Integer> answer = new ArrayList<>();\\n        \\n        if(root == null) return answer;\\n        \\n        largestVals(root, 0, answer);\\n        return answer;        \\n        \\n    }\\n\\n```\\n\\n\\n--------------------BFS-------------\\n\\nApproach: Add level by level and for every level add first element and change further if found greater\\n\\n```\\n    public List<Integer> largestValues(TreeNode root) {\\n        \\n        ArrayList<Integer> answer = new ArrayList<>();\\n        \\n        if(root == null) return answer;\\n        \\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.add(root);\\n        \\n        int max = Integer.MIN_VALUE;\\n        \\n        while(queue.size() > 0){\\n\\t\\t\\n            max = Integer.MIN_VALUE;\\n            int size = queue.size();\\n\\n            for(int ele = 0; ele < size; ele++){\\n\\n                TreeNode node = queue.remove();\\n\\n                if(node.val > max) max = node.val;\\n\\n                if(node.left != null)\\n                queue.add(node.left);\\n\\n                if(node.right != null)\\n                queue.add(node.right);\\n\\n            }\\n            \\n            answer.add(max);\\n            \\n        }\\n        \\n        return answer;\\n        \\n    }\\n\\n```\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\n    public void largestVals(TreeNode root, int level, ArrayList<Integer> answer){\\n        \\n        if(root == null) return;\\n        \\n        if(answer.size() - 1 < level){\\n            \\n            answer.add(root.val);\\n            \\n        }else{\\n            \\n            if(answer.get(level)  < root.val){\\n                \\n                answer.set(level, root.val);\\n            }\\n            \\n        }\\n        \\n        if(root.left != null){\\n            largestVals(root.left, level + 1, answer);\\n        }\\n        \\n        if(root.right != null) {\\n            \\n            largestVals(root.right, level  + 1, answer);\\n        }\\n        \\n    }\\n    \\n    public List<Integer> largestValues(TreeNode root) {\\n        ArrayList<Integer> answer = new ArrayList<>();\\n        \\n        if(root == null) return answer;\\n        \\n        largestVals(root, 0, answer);\\n        return answer;        \\n        \\n    }\\n\\n```\n```\\n    public List<Integer> largestValues(TreeNode root) {\\n        \\n        ArrayList<Integer> answer = new ArrayList<>();\\n        \\n        if(root == null) return answer;\\n        \\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.add(root);\\n        \\n        int max = Integer.MIN_VALUE;\\n        \\n        while(queue.size() > 0){\\n\\t\\t\\n            max = Integer.MIN_VALUE;\\n            int size = queue.size();\\n\\n            for(int ele = 0; ele < size; ele++){\\n\\n                TreeNode node = queue.remove();\\n\\n                if(node.val > max) max = node.val;\\n\\n                if(node.left != null)\\n                queue.add(node.left);\\n\\n                if(node.right != null)\\n                queue.add(node.right);\\n\\n            }\\n            \\n            answer.add(max);\\n            \\n        }\\n        \\n        return answer;\\n        \\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3481708,
                "title": "easy-o-n-bfs-solution-c-code-please-upvote",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> largestValues(TreeNode* root) {\\n        int i,j,k,c=0;\\n        queue<TreeNode*>q;\\n        vector<int>ans;\\n    \\n        if(!root)\\n        return ans;\\n\\n        q.push(root);\\n\\n        while(!q.empty()){\\n            int levelsize=q.size();\\n            int m=INT_MIN;\\n\\n            while(levelsize-->0){\\n                TreeNode* curr=q.front();\\n                q.pop();\\n                \\n                m=max(m,curr->val);\\n\\n                if(curr->left){\\n                    q.push(curr->left);\\n                }\\n\\n                if(curr->right){\\n                    q.push(curr->right);\\n                }\\n            }\\n\\n        ans.push_back(m);\\n            \\n         }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> largestValues(TreeNode* root) {\\n        int i,j,k,c=0;\\n        queue<TreeNode*>q;\\n        vector<int>ans;\\n    \\n        if(!root)\\n        return ans;\\n\\n        q.push(root);\\n\\n        while(!q.empty()){\\n            int levelsize=q.size();\\n            int m=INT_MIN;\\n\\n            while(levelsize-->0){\\n                TreeNode* curr=q.front();\\n                q.pop();\\n                \\n                m=max(m,curr->val);\\n\\n                if(curr->left){\\n                    q.push(curr->left);\\n                }\\n\\n                if(curr->right){\\n                    q.push(curr->right);\\n                }\\n            }\\n\\n        ans.push_back(m);\\n            \\n         }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1453773,
                "title": "using-the-concept-of-level-order-traversal-c",
                "content": "Concept : Perform a level order traversal using Queue and for each level of the tree keep track of the maximum value of that level.\\nOnce that level is completed, push the last known value to the vector `answer`\\n```\\nclass Solution {\\npublic:\\n    vector<int> largestValues(TreeNode* root) {\\n        vector<int> answer;\\n        queue<TreeNode*> q;\\n        if(!root) return answer;\\n        q.push(root);\\n        while(!q.empty())\\n        {\\n            const int size = q.size();\\n            int maxi = INT_MIN;\\n            for(int i = 0; i < size; i++)\\n            {\\n                auto curr = q.front();\\n                q.pop();\\n                maxi = max(maxi, curr->val);\\n                if(curr->left) q.push(curr->left);\\n                if(curr->right) q.push(curr->right);\\n            }\\n            answer.push_back(maxi);\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> largestValues(TreeNode* root) {\\n        vector<int> answer;\\n        queue<TreeNode*> q;\\n        if(!root) return answer;\\n        q.push(root);\\n        while(!q.empty())\\n        {\\n            const int size = q.size();\\n            int maxi = INT_MIN;\\n            for(int i = 0; i < size; i++)\\n            {\\n                auto curr = q.front();\\n                q.pop();\\n                maxi = max(maxi, curr->val);\\n                if(curr->left) q.push(curr->left);\\n                if(curr->right) q.push(curr->right);\\n            }\\n            answer.push_back(maxi);\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1371250,
                "title": "python-dfs-and-bfs",
                "content": "dfs\\n\\n```python\\ndef largestValues(self, root: TreeNode) -> List[int]:\\n\\tres = []\\n\\tdef dfs(node=root, level=0):\\n\\t\\tif not node:\\n\\t\\t\\treturn\\n\\t\\tif len(res)-1 < level:\\n\\t\\t\\tres.append(node.val)\\n\\t\\telse:\\n\\t\\t\\tres[level] = max(node.val, res[level])\\n\\t\\tdfs(node.left, level+1)\\n\\t\\tdfs(node.right, level+1)\\n\\tdfs()\\n\\treturn res\\n```\\n\\nbfs\\n\\n```python\\n    def largestValues(self, root: TreeNode) -> List[int]:\\n        queue = deque([root])\\n        res = []\\n        while queue:\\n            max_ = float(\\'-inf\\')\\n            for _ in range(len(queue)):\\n                node = queue.popleft()\\n                if not node:\\n                    continue\\n                max_ = max(max_, node.val)\\n                queue.extend([node.left, node.right])\\n            if max_ != float(\\'-inf\\'):\\n                res.append(max_)\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```python\\ndef largestValues(self, root: TreeNode) -> List[int]:\\n\\tres = []\\n\\tdef dfs(node=root, level=0):\\n\\t\\tif not node:\\n\\t\\t\\treturn\\n\\t\\tif len(res)-1 < level:\\n\\t\\t\\tres.append(node.val)\\n\\t\\telse:\\n\\t\\t\\tres[level] = max(node.val, res[level])\\n\\t\\tdfs(node.left, level+1)\\n\\t\\tdfs(node.right, level+1)\\n\\tdfs()\\n\\treturn res\\n```\n```python\\n    def largestValues(self, root: TreeNode) -> List[int]:\\n        queue = deque([root])\\n        res = []\\n        while queue:\\n            max_ = float(\\'-inf\\')\\n            for _ in range(len(queue)):\\n                node = queue.popleft()\\n                if not node:\\n                    continue\\n                max_ = max(max_, node.val)\\n                queue.extend([node.left, node.right])\\n            if max_ != float(\\'-inf\\'):\\n                res.append(max_)\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1318704,
                "title": "c-easy-to-understand-o-n-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    /*\\n        Approach:\\n        We traverse the tree in preorder and update the answer vector according to\\n        the largest value in the current depth.\\n    */\\n    \\n    void updateAns(TreeNode *root, vector<int> &ans, int currIndex)\\n    {\\n        if(!root) return;\\n        \\n        if(currIndex == ans.size())\\n        {\\n            ans.push_back(root->val);\\n        }\\n        \\n        if(root->val > ans[currIndex])\\n        {\\n            ans[currIndex] = root->val;\\n        }\\n        \\n        updateAns(root->left, ans, currIndex + 1);\\n        updateAns(root->right, ans, currIndex + 1);\\n    }\\n    \\n    vector<int> largestValues(TreeNode* root) \\n    {\\n        vector<int> ans;\\n        \\n        if(!root) return ans;\\n        \\n        updateAns(root, ans, 0);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    /*\\n        Approach:\\n        We traverse the tree in preorder and update the answer vector according to\\n        the largest value in the current depth.\\n    */\\n    \\n    void updateAns(TreeNode *root, vector<int> &ans, int currIndex)\\n    {\\n        if(!root) return;\\n        \\n        if(currIndex == ans.size())\\n        {\\n            ans.push_back(root->val);\\n        }\\n        \\n        if(root->val > ans[currIndex])\\n        {\\n            ans[currIndex] = root->val;\\n        }\\n        \\n        updateAns(root->left, ans, currIndex + 1);\\n        updateAns(root->right, ans, currIndex + 1);\\n    }\\n    \\n    vector<int> largestValues(TreeNode* root) \\n    {\\n        vector<int> ans;\\n        \\n        if(!root) return ans;\\n        \\n        updateAns(root, ans, 0);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2739267,
                "title": "beats-100-java-bfs-level-order-traversal",
                "content": "# **UPVOTE IF YOU UNDERSTAND ! **\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<Integer> largestValues(TreeNode root) {\\n        List <Integer> list =new LinkedList<>();\\n        if(root==null) return list;\\n        Queue <TreeNode> q= new LinkedList<>();\\n        q.add(root);\\n        while(!q.isEmpty()){\\n            int size=q.size();\\n            int max=Integer.MIN_VALUE;\\n            for (int i = 0; i < size; i++) {\\n                TreeNode node= q.poll();\\n                if(node.left!=null) q.add(node.left);\\n                if(node.right!=null) q.add(node.right);\\n                max= Math.max(max, node.val);\\n            }\\n            list.add(max);\\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<Integer> largestValues(TreeNode root) {\\n        List <Integer> list =new LinkedList<>();\\n        if(root==null) return list;\\n        Queue <TreeNode> q= new LinkedList<>();\\n        q.add(root);\\n        while(!q.isEmpty()){\\n            int size=q.size();\\n            int max=Integer.MIN_VALUE;\\n            for (int i = 0; i < size; i++) {\\n                TreeNode node= q.poll();\\n                if(node.left!=null) q.add(node.left);\\n                if(node.right!=null) q.add(node.right);\\n                max= Math.max(max, node.val);\\n            }\\n            list.add(max);\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2139619,
                "title": "bfs-dfs-short-and-concise-c",
                "content": "# BFS\\n```\\nclass Solution {\\npublic:\\n    vector<int> largestValues(TreeNode* root) {\\n        if(!root) return {};\\n        \\n        vector<int> ans;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        \\n        while(!q.empty()) {\\n            int n = q.size();\\n            \\n            int mx = INT_MIN;\\n            while(n--) {\\n                TreeNode* temp = q.front(); q.pop();\\n                mx = max(mx, temp -> val);\\n                \\n                if(temp -> left) q.push(temp -> left);\\n                if(temp -> right) q.push(temp -> right);\\n            }\\n            ans.push_back(mx);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n# DFS\\n```\\nclass Solution {\\npublic:\\n    void dfs(TreeNode* root, int level, vector<int> &ans) {\\n        if(!root) return;\\n        \\n        if(level == ans.size()) ans.push_back(root -> val);\\n        ans[level] = max(ans[level], root -> val);\\n        \\n        dfs(root -> left, level + 1, ans);\\n        dfs(root -> right, level + 1, ans);\\n    }\\n    \\n    vector<int> largestValues(TreeNode* root) {\\n        vector<int> ans;\\n        dfs(root, 0, ans);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> largestValues(TreeNode* root) {\\n        if(!root) return {};\\n        \\n        vector<int> ans;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        \\n        while(!q.empty()) {\\n            int n = q.size();\\n            \\n            int mx = INT_MIN;\\n            while(n--) {\\n                TreeNode* temp = q.front(); q.pop();\\n                mx = max(mx, temp -> val);\\n                \\n                if(temp -> left) q.push(temp -> left);\\n                if(temp -> right) q.push(temp -> right);\\n            }\\n            ans.push_back(mx);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void dfs(TreeNode* root, int level, vector<int> &ans) {\\n        if(!root) return;\\n        \\n        if(level == ans.size()) ans.push_back(root -> val);\\n        ans[level] = max(ans[level], root -> val);\\n        \\n        dfs(root -> left, level + 1, ans);\\n        dfs(root -> right, level + 1, ans);\\n    }\\n    \\n    vector<int> largestValues(TreeNode* root) {\\n        vector<int> ans;\\n        dfs(root, 0, ans);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1640843,
                "title": "python3-dfs-recursive-and-iterative-easy-understanding",
                "content": "### Idea\\n- Here just traverse follows pre-order traversal\\n- we initialize 2 variables `max_array` and `self.n`. `max_array` contains the max value of each row. `self.n` keeps track of the current deepest row we travel so far.\\n- in `dfs` function  we traverse in `pre-order-traversal`.\\n- if the `cur_row` - current row, is deeper than the deepest row we visted at `self.n`, we update it. If not, we just compare the current value at this node with the max value of this row saved in the `max_array`\\n\\n### Analysis\\n- Time Complexity: `O(n)`. Seen we have to visit all the nodes so O(n).\\n\\n### Code\\n1. Recursive - DFS - preorder-traversal\\n```\\ndef largestValues(self, root: Optional[TreeNode]) -> List[int]:\\n    max_array, self.n = [], 0\\n\\n    def dfs(cur_node: Optional[TreeNode], cur_row: int):\\n        if not cur_node:\\n            return\\n\\n        if cur_row == self.n:\\n            self.n += 1\\n            max_array.append(cur_node.val)\\n\\n        max_array[cur_row] = max(max_array[cur_row], cur_node.val)\\n\\n        dfs(cur_node.left, cur_row + 1)\\n        dfs(cur_node.right, cur_row + 1)\\n\\n    dfs(root, 0)\\n    return max_array\\n```\\n\\n2. Iterative - DFS (Stack)\\n```\\ndef largestValues(self, root: Optional[TreeNode]) -> List[int]:\\n    max_array, self.n = [], 0\\n\\n    def dfs(cur_node: Optional[TreeNode], cur_row: int):\\n        if not cur_node:\\n            return\\n\\n        if cur_row == self.n:\\n            self.n += 1\\n            max_array.append(cur_node.val)\\n\\n        max_array[cur_row] = max(max_array[cur_row], cur_node.val)\\n\\n        dfs(cur_node.left, cur_row + 1)\\n        dfs(cur_node.right, cur_row + 1)\\n\\n    dfs(root, 0)\\n    return max_array\\n```",
                "solutionTags": [
                    "Python",
                    "Stack",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\ndef largestValues(self, root: Optional[TreeNode]) -> List[int]:\\n    max_array, self.n = [], 0\\n\\n    def dfs(cur_node: Optional[TreeNode], cur_row: int):\\n        if not cur_node:\\n            return\\n\\n        if cur_row == self.n:\\n            self.n += 1\\n            max_array.append(cur_node.val)\\n\\n        max_array[cur_row] = max(max_array[cur_row], cur_node.val)\\n\\n        dfs(cur_node.left, cur_row + 1)\\n        dfs(cur_node.right, cur_row + 1)\\n\\n    dfs(root, 0)\\n    return max_array\\n```\n```\\ndef largestValues(self, root: Optional[TreeNode]) -> List[int]:\\n    max_array, self.n = [], 0\\n\\n    def dfs(cur_node: Optional[TreeNode], cur_row: int):\\n        if not cur_node:\\n            return\\n\\n        if cur_row == self.n:\\n            self.n += 1\\n            max_array.append(cur_node.val)\\n\\n        max_array[cur_row] = max(max_array[cur_row], cur_node.val)\\n\\n        dfs(cur_node.left, cur_row + 1)\\n        dfs(cur_node.right, cur_row + 1)\\n\\n    dfs(root, 0)\\n    return max_array\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 706785,
                "title": "clean-js-fast-code",
                "content": "```\\nvar largestValues = function(root) {\\n    let res = [];\\n    if(!root) return res;\\n    function trav(node, level){\\n        if(!node) return;\\n        if(res[level] == undefined || res[level] < node.val ) res[level] =node.val;\\n        if(node.left) trav(node.left, level+1);\\n        if(node.right) trav(node.right, level+1);\\n    }\\n    trav(root, 0);\\n    return res;\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar largestValues = function(root) {\\n    let res = [];\\n    if(!root) return res;\\n    function trav(node, level){\\n        if(!node) return;\\n        if(res[level] == undefined || res[level] < node.val ) res[level] =node.val;\\n        if(node.left) trav(node.left, level+1);\\n        if(node.right) trav(node.right, level+1);\\n    }\\n    trav(root, 0);\\n    return res;\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 349153,
                "title": "python-dfs-neat-solution",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution(object):\\n    def __init__(self):\\n        self.dic = {}\\n        \\n    def largestValues(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[int]\\n        \"\"\"\\n        def dfs(node, level):\\n            if node is None:\\n                return\\n            \\n            dfs(node.left, level+1)\\n            dfs(node.right, level+1)\\n            if level in self.dic:\\n                self.dic[level].append(node.val)\\n            else:\\n                self.dic[level] = [node.val]\\n        dfs(root,0)\\n        return [max(l) for l in self.dic.values()]\\n        \\n```",
                "solutionTags": [],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution(object):\\n    def __init__(self):\\n        self.dic = {}\\n        \\n    def largestValues(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[int]\\n        \"\"\"\\n        def dfs(node, level):\\n            if node is None:\\n                return\\n            \\n            dfs(node.left, level+1)\\n            dfs(node.right, level+1)\\n            if level in self.dic:\\n                self.dic[level].append(node.val)\\n            else:\\n                self.dic[level] = [node.val]\\n        dfs(root,0)\\n        return [max(l) for l in self.dic.values()]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1965769,
                "title": "python-easy-to-understand-bfs-solution-with-deque",
                "content": "```\\ndef largestValues(self, root: Optional[TreeNode]) -> List[int]:\\n        \\n        ans = []\\n        \\n        q = deque([root])\\n        \\n        if root:\\n        \\n            while q:\\n\\n                cur_max = -float(\\'inf\\')\\n\\n                for _ in range(len(q)):\\n\\n                    cur = q.popleft()\\n\\n                    cur_max = max(cur.val,cur_max)\\n\\n                    if cur.left:\\n                        q.append(cur.left)\\n                    if cur.right:\\n                        q.append(cur.right)\\n\\n                ans.append(cur_max)\\n\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\ndef largestValues(self, root: Optional[TreeNode]) -> List[int]:\\n        \\n        ans = []\\n        \\n        q = deque([root])\\n        \\n        if root:\\n        \\n            while q:\\n\\n                cur_max = -float(\\'inf\\')\\n\\n                for _ in range(len(q)):\\n\\n                    cur = q.popleft()\\n\\n                    cur_max = max(cur.val,cur_max)\\n\\n                    if cur.left:\\n                        q.append(cur.left)\\n                    if cur.right:\\n                        q.append(cur.right)\\n\\n                ans.append(cur_max)\\n\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1630341,
                "title": "java-solution-bfs-and-custom-class-is-used-here-to-make-it-more-easy-to-read",
                "content": "```\\nclass Solution {\\n    class Pair{\\n        TreeNode v;\\n        int level;\\n        Pair(TreeNode v,int level){\\n            this.v=v;\\n            this.level=level;\\n        }\\n    }\\n    public List<Integer> largestValues(TreeNode root) {\\n        List<Integer> list =new ArrayList<>();\\n        if(root==null){\\n            return new ArrayList<>();\\n        }\\n        ArrayDeque <Pair> q=new ArrayDeque<>();\\n        int level=0;\\n        int max=Integer.MIN_VALUE;\\n        q.add(new Pair(root,0));\\n        \\n        while(q.size()!=0){\\n            Pair rem=q.remove();\\n            if(level==rem.level){\\n                max=Math.max(rem.v.val,max);\\n            }\\n            else if(level!=rem.level){\\n                list.add(max);\\n                max=rem.v.val;\\n                level++;\\n            }\\n            \\n            if(rem.v.left!=null){\\n                q.add(new Pair(rem.v.left,rem.level+1));\\n            }\\n            if(rem.v.right!=null){\\n                q.add(new Pair(rem.v.right,rem.level+1));\\n            }\\n        }\\n        list.add(max); //as last lyer would be added\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\n    class Pair{\\n        TreeNode v;\\n        int level;\\n        Pair(TreeNode v,int level){\\n            this.v=v;\\n            this.level=level;\\n        }\\n    }\\n    public List<Integer> largestValues(TreeNode root) {\\n        List<Integer> list =new ArrayList<>();\\n        if(root==null){\\n            return new ArrayList<>();\\n        }\\n        ArrayDeque <Pair> q=new ArrayDeque<>();\\n        int level=0;\\n        int max=Integer.MIN_VALUE;\\n        q.add(new Pair(root,0));\\n        \\n        while(q.size()!=0){\\n            Pair rem=q.remove();\\n            if(level==rem.level){\\n                max=Math.max(rem.v.val,max);\\n            }\\n            else if(level!=rem.level){\\n                list.add(max);\\n                max=rem.v.val;\\n                level++;\\n            }\\n            \\n            if(rem.v.left!=null){\\n                q.add(new Pair(rem.v.left,rem.level+1));\\n            }\\n            if(rem.v.right!=null){\\n                q.add(new Pair(rem.v.right,rem.level+1));\\n            }\\n        }\\n        list.add(max); //as last lyer would be added\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1231822,
                "title": "bfs-easy-js-solution",
                "content": "```\\n/*\\n1. Use BFS to traverse nodes in level-order.\\n2. For each level, keep track of the maximum value and push it to the result array.\\n3. Return the result array.\\n*/\\nvar largestValues = function(root) {\\n    // If given root is null, return an empty array\\n    if (!root) {\\n        return [];\\n    }\\n    // result array\\n    let res = [];\\n    // queue stores nodes to be traversed\\n    let queue = [];\\n    // the first node to be traversed is the root\\n    queue.push(root);\\n    \\n    // while there are nodes to be traversed\\n    while (queue.length > 0) {\\n        // number of nodes in one level\\n        let queueLen = queue.length;\\n        let max = -Infinity;\\n        for (let i = 0; i < queueLen; i++) {\\n            let node = queue.shift();\\n            max = Math.max(max, node.val);\\n            // push nodes in next level into queue\\n            if (node.left) queue.push(node.left);\\n            if (node.right) queue.push(node.right);\\n        }\\n        res.push(max);\\n    }\\n    return res;\\n    // T.C: O(N), we traverse every node once\\n    // S.C: O(N), the bottom level can contain at most N/2 nodes, and hence so can queue\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/*\\n1. Use BFS to traverse nodes in level-order.\\n2. For each level, keep track of the maximum value and push it to the result array.\\n3. Return the result array.\\n*/\\nvar largestValues = function(root) {\\n    // If given root is null, return an empty array\\n    if (!root) {\\n        return [];\\n    }\\n    // result array\\n    let res = [];\\n    // queue stores nodes to be traversed\\n    let queue = [];\\n    // the first node to be traversed is the root\\n    queue.push(root);\\n    \\n    // while there are nodes to be traversed\\n    while (queue.length > 0) {\\n        // number of nodes in one level\\n        let queueLen = queue.length;\\n        let max = -Infinity;\\n        for (let i = 0; i < queueLen; i++) {\\n            let node = queue.shift();\\n            max = Math.max(max, node.val);\\n            // push nodes in next level into queue\\n            if (node.left) queue.push(node.left);\\n            if (node.right) queue.push(node.right);\\n        }\\n        res.push(max);\\n    }\\n    return res;\\n    // T.C: O(N), we traverse every node once\\n    // S.C: O(N), the bottom level can contain at most N/2 nodes, and hence so can queue\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1045448,
                "title": "java-preorder-solution-beats-100-0ms-o-n",
                "content": "\\n    public List<Integer> largestValues(TreeNode root) {\\n\\n\\t\\tList<Integer> ans = new ArrayList<Integer>();\\n\\t\\tlargestValues(root, ans, 0);\\n\\t\\treturn ans;\\n\\t}\\n\\n\\tpublic void largestValues(TreeNode root, List<Integer> ans, int height) {\\n\\n\\t\\tif (root == null)\\n\\t\\t\\treturn;\\n\\n\\t\\tif (height == ans.size())\\n\\t\\t\\tans.add(root.val);\\n\\t\\telse\\n\\t\\t\\tans.set(height, Math.max(ans.get(height), root.val));\\n\\n\\t\\tlargestValues(root.left, ans, height + 1);\\n\\t\\tlargestValues(root.right, ans, height + 1);\\n\\t}\\n",
                "solutionTags": [],
                "code": "\\n    public List<Integer> largestValues(TreeNode root) {\\n\\n\\t\\tList<Integer> ans = new ArrayList<Integer>();\\n\\t\\tlargestValues(root, ans, 0);\\n\\t\\treturn ans;\\n\\t}\\n\\n\\tpublic void largestValues(TreeNode root, List<Integer> ans, int height) {\\n\\n\\t\\tif (root == null)\\n\\t\\t\\treturn;\\n\\n\\t\\tif (height == ans.size())\\n\\t\\t\\tans.add(root.val);\\n\\t\\telse\\n\\t\\t\\tans.set(height, Math.max(ans.get(height), root.val));\\n\\n\\t\\tlargestValues(root.left, ans, height + 1);\\n\\t\\tlargestValues(root.right, ans, height + 1);\\n\\t}\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3083689,
                "title": "java-bfs-easy-solution",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- BFS traversal and take the max at each level\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> largestValues(TreeNode root) {\\n        Queue<TreeNode> q = new LinkedList<>();\\n        List<Integer> res = new ArrayList<>();\\n        if (root == null) {\\n            return res;\\n        }\\n        q.add(root);\\n        while (!q.isEmpty()) {\\n            \\n            int currentLevelSize = q.size();\\n            int maxVal = Integer.MIN_VALUE;\\n\\n            while (currentLevelSize > 0) {\\n                currentLevelSize--;\\n                TreeNode node = q.poll();\\n                maxVal = Math.max(maxVal, node.val);\\n\\n                if (node.left != null) {\\n                    q.offer(node.left);\\n                }\\n                if (node.right != null) {\\n                    q.offer(node.right);\\n                }                  \\n            }\\n            res.add(maxVal);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> largestValues(TreeNode root) {\\n        Queue<TreeNode> q = new LinkedList<>();\\n        List<Integer> res = new ArrayList<>();\\n        if (root == null) {\\n            return res;\\n        }\\n        q.add(root);\\n        while (!q.isEmpty()) {\\n            \\n            int currentLevelSize = q.size();\\n            int maxVal = Integer.MIN_VALUE;\\n\\n            while (currentLevelSize > 0) {\\n                currentLevelSize--;\\n                TreeNode node = q.poll();\\n                maxVal = Math.max(maxVal, node.val);\\n\\n                if (node.left != null) {\\n                    q.offer(node.left);\\n                }\\n                if (node.right != null) {\\n                    q.offer(node.right);\\n                }                  \\n            }\\n            res.add(maxVal);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2887765,
                "title": "c-bfs-dfs-approaches",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst Thoughts after understanding the problem is it is a simple bfs apporach problem\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nApproaches Are Bfs And Dfs\\n\\nI as usual started with Bfs approach but it will not give fruitful result as expected beated only 5% users in tc although 95% in space complexity but as main concern to tc. So then i try for DFS approach and resulting in beating 56% users in tc :)\\n\\nOne more catch in this problem is root can be null so i got one failed submit in bfs approach SED LYF\\uD83D\\uDE11\\uD83D\\uDE11\\uD83D\\uDE11\\n\\n\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n//For Dfs Approach\\n    vector<int>res;\\n    void dfs(TreeNode*ptr,int idx){\\n        if(ptr==NULL)return;\\n\\n        if(res.size()<idx+1)res.push_back(ptr->val);\\n        else{\\n            if(ptr->val>res[idx])res[idx]=ptr->val;\\n        }\\n\\n        dfs(ptr->left,idx+1);\\n        dfs(ptr->right,idx+1);\\n\\n    }\\n\\n    vector<int> largestValues(TreeNode* root) {\\n\\n            // For Bfs Approach\\n        // vector<int>res;\\n        // queue<TreeNode*>q;\\n        // if(root)\\n        // q.push(root);\\n        // while(q.size()){\\n        //     int mx=INT_MIN;\\n        //     int n=q.size();\\n        //     for(int i=0;i<n;i++){\\n        //         auto top=q.front();\\n        //         q.pop();\\n        //         top->val>mx?mx=top->val:mx;\\n        //         if(top->left)q.push(top->left);\\n        //         if(top->right)q.push(top->right);\\n        //     }\\n        //     res.push_back(mx);\\n        // }\\n        // return res;\\n\\n        dfs(root,0);\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n//For Dfs Approach\\n    vector<int>res;\\n    void dfs(TreeNode*ptr,int idx){\\n        if(ptr==NULL)return;\\n\\n        if(res.size()<idx+1)res.push_back(ptr->val);\\n        else{\\n            if(ptr->val>res[idx])res[idx]=ptr->val;\\n        }\\n\\n        dfs(ptr->left,idx+1);\\n        dfs(ptr->right,idx+1);\\n\\n    }\\n\\n    vector<int> largestValues(TreeNode* root) {\\n\\n            // For Bfs Approach\\n        // vector<int>res;\\n        // queue<TreeNode*>q;\\n        // if(root)\\n        // q.push(root);\\n        // while(q.size()){\\n        //     int mx=INT_MIN;\\n        //     int n=q.size();\\n        //     for(int i=0;i<n;i++){\\n        //         auto top=q.front();\\n        //         q.pop();\\n        //         top->val>mx?mx=top->val:mx;\\n        //         if(top->left)q.push(top->left);\\n        //         if(top->right)q.push(top->right);\\n        //     }\\n        //     res.push_back(mx);\\n        // }\\n        // return res;\\n\\n        dfs(root,0);\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1775636,
                "title": "bfs-queue-level-order-traversal",
                "content": "\\t\\tvector<int> largestValues(TreeNode* root) {\\n        //bfs \\n        //level order traversal\\n        vector<int>res;\\n        if(root==NULL) return res;\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        \\n        while(!q.empty()){\\n            int mi=INT_MIN;\\n            int x=q.size();\\n            for(int i=0;i<x;i++){\\n                if(q.front()->val>mi)\\n                    mi=q.front()->val;\\n                if(q.front()->left)\\n                q.push(q.front()->left);\\n                \\n                if(q.front()->right)\\n                    q.push(q.front()->right);\\n                q.pop();\\n                    \\n            }\\n            res.push_back(mi);\\n        }\\n        return res;\\n    }",
                "solutionTags": [
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "\\t\\tvector<int> largestValues(TreeNode* root) {\\n        //bfs \\n        //level order traversal\\n        vector<int>res;\\n        if(root==NULL) return res;\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        \\n        while(!q.empty()){\\n            int mi=INT_MIN;\\n            int x=q.size();\\n            for(int i=0;i<x;i++){\\n                if(q.front()->val>mi)\\n                    mi=q.front()->val;\\n                if(q.front()->left)\\n                q.push(q.front()->left);\\n                \\n                if(q.front()->right)\\n                    q.push(q.front()->right);\\n                q.pop();\\n                    \\n            }\\n            res.push_back(mi);\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1673520,
                "title": "preorder-traversal-4ms-cpp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> largestValues(TreeNode* root) {\\n        vector<int> maxs;\\n        find(root, 0, maxs);\\n        return maxs;\\n    }\\n    void find(TreeNode* node, int row, vector<int>& maxs) {\\n        if (!node) {\\n            return;\\n        }\\n\\n        if (row >= maxs.size()) {\\n            maxs.push_back(node->val);\\n        }\\n        else {\\n            maxs[row] = max(maxs[row], node->val);\\n        }\\n\\n        find(node->left, row + 1, maxs);\\n        find(node->right, row + 1, maxs);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> largestValues(TreeNode* root) {\\n        vector<int> maxs;\\n        find(root, 0, maxs);\\n        return maxs;\\n    }\\n    void find(TreeNode* node, int row, vector<int>& maxs) {\\n        if (!node) {\\n            return;\\n        }\\n\\n        if (row >= maxs.size()) {\\n            maxs.push_back(node->val);\\n        }\\n        else {\\n            maxs[row] = max(maxs[row], node->val);\\n        }\\n\\n        find(node->left, row + 1, maxs);\\n        find(node->right, row + 1, maxs);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1416116,
                "title": "bfs-and-dfs-c-easy",
                "content": "DFS solution\\n\\n\\n* maintaining the level\\n* pushing the value and storing the max\\n\\n```\\nvoid helper(TreeNode* root,vector<int>& ans,int level)\\n    {\\n        if(root==NULL)return;\\n        if(level>=ans.size())\\n        {\\n            ans.push_back(root->val);\\n        }\\n       else\\n        {\\n            ans[level]=max(root->val,ans[level]);\\n        }\\n        helper(root->left,ans,level+1);\\n        helper(root->right,ans,level+1);\\n    }\\n    \\n    \\n    vector<int> largestValues(TreeNode* root) {\\n        if(root==NULL)return {};\\n        vector<int> ans;\\n        helper(root,ans,0);\\n        return ans;\\n    }\\n```\\n\\n\\nBFS is too easy\\n\\n```\\nvector<int> largestValues(TreeNode* root) {\\n        if(!root)return {};\\n        vector<int> ans;\\n        queue<TreeNode*> qu;\\n        qu.push(root);\\n        while(!qu.empty())\\n        {\\n            int size=qu.size();\\n            int m=INT_MIN;\\n            while(size--)\\n            {\\n                TreeNode* temp=qu.front();\\n                qu.pop();\\n                if(temp->left)qu.push(temp->left);\\n                if(temp->right)qu.push(temp->right);\\n                if(temp->val>m)\\n                {\\n                    m=temp->val;\\n                }\\n            }\\n            ans.push_back(m);\\n        }\\n        return ans;\\n\\t\\t\\t\\t}\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nvoid helper(TreeNode* root,vector<int>& ans,int level)\\n    {\\n        if(root==NULL)return;\\n        if(level>=ans.size())\\n        {\\n            ans.push_back(root->val);\\n        }\\n       else\\n        {\\n            ans[level]=max(root->val,ans[level]);\\n        }\\n        helper(root->left,ans,level+1);\\n        helper(root->right,ans,level+1);\\n    }\\n    \\n    \\n    vector<int> largestValues(TreeNode* root) {\\n        if(root==NULL)return {};\\n        vector<int> ans;\\n        helper(root,ans,0);\\n        return ans;\\n    }\\n```\n```\\nvector<int> largestValues(TreeNode* root) {\\n        if(!root)return {};\\n        vector<int> ans;\\n        queue<TreeNode*> qu;\\n        qu.push(root);\\n        while(!qu.empty())\\n        {\\n            int size=qu.size();\\n            int m=INT_MIN;\\n            while(size--)\\n            {\\n                TreeNode* temp=qu.front();\\n                qu.pop();\\n                if(temp->left)qu.push(temp->left);\\n                if(temp->right)qu.push(temp->right);\\n                if(temp->val>m)\\n                {\\n                    m=temp->val;\\n                }\\n            }\\n            ans.push_back(m);\\n        }\\n        return ans;\\n\\t\\t\\t\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1059860,
                "title": "python-bfs-level-order-traversal-w-commet",
                "content": "```py\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\n\\'\\'\\'\\nw: BFS based level-order traveseral\\nh: we traverse the tree level by level and record the max for each level\\n\\'\\'\\'\\nimport collections\\nclass Solution:\\n    def largestValues(self, root: TreeNode) -> List[int]:\\n        if not root:\\n            return []\\n        res = []\\n        queue = collections.deque([root])\\n        \\n        while queue:\\n            size = len(queue)\\n            max_ = -float(\\'inf\\')\\n            for _ in range(size):\\n                node = queue.popleft()\\n                max_ = max(max_, node.val)\\n                if node.left:\\n                    queue.append(node.left)\\n                if node.right:\\n                    queue.append(node.right)\\n            res.append(max_)\\n            \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```py\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\n\\'\\'\\'\\nw: BFS based level-order traveseral\\nh: we traverse the tree level by level and record the max for each level\\n\\'\\'\\'\\nimport collections\\nclass Solution:\\n    def largestValues(self, root: TreeNode) -> List[int]:\\n        if not root:\\n            return []\\n        res = []\\n        queue = collections.deque([root])\\n        \\n        while queue:\\n            size = len(queue)\\n            max_ = -float(\\'inf\\')\\n            for _ in range(size):\\n                node = queue.popleft()\\n                max_ = max(max_, node.val)\\n                if node.left:\\n                    queue.append(node.left)\\n                if node.right:\\n                    queue.append(node.right)\\n            res.append(max_)\\n            \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 695348,
                "title": "python3-preorder-traversal-solution",
                "content": "```\\nclass Solution:\\n    \\n    def get_result(self,root,level):\\n        if root==None:\\n            return\\n        try:\\n            self.result[level] = max(self.result[level],root.val)\\n        except:\\n            self.result[level] = root.val\\n        self.get_result(root.left,level+1)\\n        self.get_result(root.right,level+1)\\n    \\n    def largestValues(self, root: TreeNode) -> List[int]:\\n        self.result = {}\\n        self.get_result(root,0)\\n        return self.result.values()\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    \\n    def get_result(self,root,level):\\n        if root==None:\\n            return\\n        try:\\n            self.result[level] = max(self.result[level],root.val)\\n        except:\\n            self.result[level] = root.val\\n        self.get_result(root.left,level+1)\\n        self.get_result(root.right,level+1)\\n    \\n    def largestValues(self, root: TreeNode) -> List[int]:\\n        self.result = {}\\n        self.get_result(root,0)\\n        return self.result.values()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 206364,
                "title": "java-dfs-beat-100",
                "content": "DFS with its level(root\\'s level is 0), and the retsult list. \\nWhen  level == the size of result  list, meaning the cur node is the first met node in this level, so just add it; \\nelse, comapre the cur val with the max in this level.\\n\\n```\\n public List<Integer> largestValues(TreeNode root) {\\n        List<Integer> ret = new ArrayList();\\n        dfs(root, 0, ret);\\n        return ret;\\n    }\\n    \\n    private void dfs(TreeNode root, int level, List<Integer> ret){\\n        if(root == null) return;\\n        if(level == ret.size()){\\n            ret.add(root.val);\\n        }else{\\n            if(root.val > ret.get(level)){\\n                ret.set(level, root.val);\\n            }\\n        }\\n        dfs(root.left, level+1, ret);\\n        dfs(root.right, level+1, ret);\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\n public List<Integer> largestValues(TreeNode root) {\\n        List<Integer> ret = new ArrayList();\\n        dfs(root, 0, ret);\\n        return ret;\\n    }\\n    \\n    private void dfs(TreeNode root, int level, List<Integer> ret){\\n        if(root == null) return;\\n        if(level == ret.size()){\\n            ret.add(root.val);\\n        }else{\\n            if(root.val > ret.get(level)){\\n                ret.set(level, root.val);\\n            }\\n        }\\n        dfs(root.left, level+1, ret);\\n        dfs(root.right, level+1, ret);\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 99096,
                "title": "5-lines-java-dfs-solution",
                "content": "``` java\\npublic class Solution {\\n    public int[] findValueMostElement(TreeNode root) {\\n        return dfs(root, 0, new ArrayList<>()).stream().mapToInt(TreeSet::last).toArray();\\n    }\\n    private ArrayList<TreeSet<Integer>> dfs(TreeNode root, int depth, ArrayList<TreeSet<Integer>> list) {\\n        if (root==null) return list;\\n        if (list.size()<=depth) list.add(new TreeSet<>());\\n        list.get(depth).add(root.val);\\n        return dfs(root.right, depth+1, dfs(root.left, depth+1, list));\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "``` java\\npublic class Solution {\\n    public int[] findValueMostElement(TreeNode root) {\\n        return dfs(root, 0, new ArrayList<>()).stream().mapToInt(TreeSet::last).toArray();\\n    }\\n    private ArrayList<TreeSet<Integer>> dfs(TreeNode root, int depth, ArrayList<TreeSet<Integer>> list) {\\n        if (root==null) return list;\\n        if (list.size()<=depth) list.add(new TreeSet<>());\\n        list.get(depth).add(root.val);\\n        return dfs(root.right, depth+1, dfs(root.left, depth+1, list));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 99098,
                "title": "standard-travel-by-level-java-bfs",
                "content": "Use a queue to travel the tree level by level. \\n```\\npublic class Solution {\\n    public int[] findValueMostElement(TreeNode root) {\\n        if(root==null) return new int[0];\\n        List<Integer> res = new LinkedList<>();\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.add(root);\\n        while(!q.isEmpty()){\\n            int max = q.peek().val;\\n            int size = q.size();\\n            for(int i = 0; i<size; i++){\\n                TreeNode cur = q.poll();\\n                max = Math.max(max, cur.val);\\n                if(cur.left!=null) q.add(cur.left);\\n                if(cur.right!=null) q.add(cur.right);\\n            }\\n            res.add(max);\\n        }\\n        return res.stream().mapToInt(k->k).toArray();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int[] findValueMostElement(TreeNode root) {\\n        if(root==null) return new int[0];\\n        List<Integer> res = new LinkedList<>();\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.add(root);\\n        while(!q.isEmpty()){\\n            int max = q.peek().val;\\n            int size = q.size();\\n            for(int i = 0; i<size; i++){\\n                TreeNode cur = q.poll();\\n                max = Math.max(max, cur.val);\\n                if(cur.left!=null) q.add(cur.left);\\n                if(cur.right!=null) q.add(cur.right);\\n            }\\n            res.add(max);\\n        }\\n        return res.stream().mapToInt(k->k).toArray();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4024062,
                "title": "simple-level-order-traversal-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> largestValues(TreeNode* root) {\\n        vector<int> res;\\n        if(root==NULL){return res;}\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int x=q.size(),m=INT_MIN;\\n            for(int i=0;i<x;i++){\\n                TreeNode* curr=q.front();\\n                q.pop();\\n                m=max(m,curr->val);\\n                if(curr->left){\\n                    q.push(curr->left);\\n                }\\n                if(curr->right){\\n                    q.push(curr->right);\\n                }\\n            }\\n            res.push_back(m);\\n        }\\n        root->left=NULL;root->right=NULL;\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Queue",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> largestValues(TreeNode* root) {\\n        vector<int> res;\\n        if(root==NULL){return res;}\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int x=q.size(),m=INT_MIN;\\n            for(int i=0;i<x;i++){\\n                TreeNode* curr=q.front();\\n                q.pop();\\n                m=max(m,curr->val);\\n                if(curr->left){\\n                    q.push(curr->left);\\n                }\\n                if(curr->right){\\n                    q.push(curr->right);\\n                }\\n            }\\n            res.push_back(m);\\n        }\\n        root->left=NULL;root->right=NULL;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3955286,
                "title": "c-two-approaches-simply-explained-level-order-traversal-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can use level order traversal and update max at each level. Add this max to result vector.\\n\\nFor recursion we can keep track of max level and current level. If we are at a new level then add value to vector.\\nIf the level has already been visited we update our value in vector\\n\\n\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(H) for recursion\\n- O(W) for level order traversal\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code: Recursion\\n```\\n\\nclass Solution {\\npublic:\\n\\n    vector <int> res;\\n    void traverse(TreeNode* root, int currlevel, int &maxlevel){\\n        if(!root) return;\\n        if(currlevel > maxlevel){ // new level\\n            maxlevel = currlevel; //update maxlevel\\n            res.push_back(root->val); //add value to vector\\n        }\\n        //otherwise level already visited (entry in vector exists)\\n        res[currlevel] = max(res[currlevel], root->val); \\n        //update value in vector\\n        traverse(root->left, currlevel+1, maxlevel); //recurse\\n        traverse(root->right, currlevel+1, maxlevel);\\n    }\\n    vector<int> largestValues(TreeNode* root) {\\n        res.clear();\\n        int maxlevel = -1;\\n        traverse(root, 0, maxlevel);\\n        return res;\\n    }\\n};\\n```\\n\\n\\n# Code : Level Order Traversal\\n```/**\\n\\nclass Solution {\\npublic:\\n    vector<int> largestValues(TreeNode* root) {\\n        vector <int> res;\\n        queue <TreeNode*> q;\\n        if(!root) return res;\\n        q.push(root);\\n        while(!q.empty()){\\n            int sz = q.size();\\n            int maxx = INT_MIN; //initialise maximum\\n            TreeNode* n;\\n            while(sz--){ //iterating at particular level\\n                n = q.front();\\n                q.pop();\\n                maxx = max(maxx, n->val); //update maximum\\n                if(n->left) q.push(n->left);\\n                if(n->right) q.push(n->right);\\n\\n            }\\n\\n            res.push_back(maxx); ///add maximum to vector\\n        }\\n\\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n\\n    vector <int> res;\\n    void traverse(TreeNode* root, int currlevel, int &maxlevel){\\n        if(!root) return;\\n        if(currlevel > maxlevel){ // new level\\n            maxlevel = currlevel; //update maxlevel\\n            res.push_back(root->val); //add value to vector\\n        }\\n        //otherwise level already visited (entry in vector exists)\\n        res[currlevel] = max(res[currlevel], root->val); \\n        //update value in vector\\n        traverse(root->left, currlevel+1, maxlevel); //recurse\\n        traverse(root->right, currlevel+1, maxlevel);\\n    }\\n    vector<int> largestValues(TreeNode* root) {\\n        res.clear();\\n        int maxlevel = -1;\\n        traverse(root, 0, maxlevel);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3359030,
                "title": "simple-bfs-solution-c",
                "content": "# Intuition\\nThe approach used in the code is to traverse the binary tree level by level using a queue. At each level, we keep track of the maximum value encountered and add it to the output vector.\\n\\nTo implement this, we start by adding the root node to the queue. Then we enter a loop that continues until the queue is empty. In each iteration of the loop, we process all the nodes at the current level. We keep track of the maximum value encountered at the current level by initializing a max variable to INT_MIN (which is the smallest possible integer value). We then iterate through all the nodes at the current level by popping nodes off the queue one by one. For each node, we update max if the node\\'s value is greater than the current max value. Finally, we add max to the output vector and push the node\\'s left and right children (if they exist) onto the queue.\\n\\nOnce we have processed all the nodes at the current level, we move on to the next level by adding the maximum value encountered at the current level to the output vector. We also reset max to INT_MIN to compute the maximum value at the next level correctly.\\n\\nThe resulting output vector contains the maximum value at each level of the binary tree.\\n\\n# Approach\\nThe approach used in the code is a Breadth First Search (BFS) algorithm that traverses the binary tree level by level.\\n\\nTo implement this, we use a queue data structure to keep track of the nodes at each level. We start by adding the root node to the queue. Then, we enter a loop that continues until the queue is empty. In each iteration of the loop, we process all the nodes at the current level. We keep track of the maximum value encountered at the current level by initializing a max variable to INT_MIN (which is the smallest possible integer value). We then iterate through all the nodes at the current level by popping nodes off the queue one by one. For each node, we update max if the node\\'s value is greater than the current max value. Finally, we add max to the output vector and push the node\\'s left and right children (if they exist) onto the queue.\\n\\nOnce we have processed all the nodes at the current level, we move on to the next level by adding the maximum value encountered at the current level to the output vector. We also reset max to INT_MIN to compute the maximum value at the next level correctly.\\n\\nThe resulting output vector contains the maximum value at each level of the binary tree.\\n\\nOverall, this approach has a time complexity of O(N), where N is the number of nodes in the binary tree, since we visit each node exactly once. The space complexity of the algorithm is O(M), where M is the maximum number of nodes at any level of the binary tree, since this is the maximum number of nodes that will be stored in the queue at any given time.\\n# Complexity\\n- Time complexity:O(n)\\n\\n- Space complexity:O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> largestValues(TreeNode* root){\\n        queue<TreeNode*>q;\\n        vector<int>op;\\n        if(!root) return op;\\n        q.push(root);\\n        int max=INT_MIN;\\n        while(!q.empty()){\\n            int size=q.size();\\n            for(int i=0; i<size; i++){\\n                TreeNode* t = q.front();\\n                q.pop();\\n                if(t->val>max){\\n                    max=t->val;\\n                }\\n                if(t->left){\\n                    q.push(t->left);\\n                }\\n                if(t->right){\\n                    q.push(t->right);\\n                }\\n            }\\n            op.push_back(max);\\n            max=INT_MIN;          // reset max for next level\\n        }\\n        return op;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> largestValues(TreeNode* root){\\n        queue<TreeNode*>q;\\n        vector<int>op;\\n        if(!root) return op;\\n        q.push(root);\\n        int max=INT_MIN;\\n        while(!q.empty()){\\n            int size=q.size();\\n            for(int i=0; i<size; i++){\\n                TreeNode* t = q.front();\\n                q.pop();\\n                if(t->val>max){\\n                    max=t->val;\\n                }\\n                if(t->left){\\n                    q.push(t->left);\\n                }\\n                if(t->right){\\n                    q.push(t->right);\\n                }\\n            }\\n            op.push_back(max);\\n            max=INT_MIN;          // reset max for next level\\n        }\\n        return op;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3289080,
                "title": "515-space-96-7-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Check if the root is None, return an empty list if so.\\n2. Initialize an empty list named result that will hold the maximum values for each level of the binary tree.\\n3. Initialize a deque named queue and add the root to the queue.\\n4. Start a while loop that runs until the queue is not empty.\\n5. Get the current size of the queue using len(queue) and assign it to a variable level_size.\\n6. Initialize a variable named max_val to negative infinity.\\n7. Start a for loop that runs level_size number of times.\\n8. Pop the leftmost element from the queue and assign it to a variable named node.\\n9. Get the maximum value between max_val and node.val and assign it to max_val.\\n10. Check if node has a left child, if it does, add it to the queue.\\n11. Check if node has a right child, if it does, add it to the queue.\\n12. Append max_val to result after the for loop ends.\\n13. Return result.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def largestValues(self, root: TreeNode) -> List[int]:\\n        if not root:\\n            return []\\n        \\n        result = []\\n        queue = deque([root])\\n        \\n        while queue:\\n            level_size = len(queue)\\n            max_val = float(\\'-inf\\')\\n            \\n            for _ in range(level_size):\\n                node = queue.popleft()\\n                max_val = max(max_val, node.val)\\n                \\n                if node.left:\\n                    queue.append(node.left)\\n                if node.right:\\n                    queue.append(node.right)\\n            \\n            result.append(max_val)\\n        \\n        return result\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Tree",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def largestValues(self, root: TreeNode) -> List[int]:\\n        if not root:\\n            return []\\n        \\n        result = []\\n        queue = deque([root])\\n        \\n        while queue:\\n            level_size = len(queue)\\n            max_val = float(\\'-inf\\')\\n            \\n            for _ in range(level_size):\\n                node = queue.popleft()\\n                max_val = max(max_val, node.val)\\n                \\n                if node.left:\\n                    queue.append(node.left)\\n                if node.right:\\n                    queue.append(node.right)\\n            \\n            result.append(max_val)\\n        \\n        return result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3225642,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> largestValues(TreeNode* root) {\\n        if(root == NULL)\\n            return {};\\n        queue<TreeNode*> q;\\n        vector<int> ans;\\n        q.push(root);\\n        while(!q.empty())\\n        {\\n            int max = INT_MIN;\\n            for(int level=q.size();level>0;level--)\\n            {\\n                TreeNode* node = q.front();\\n                q.pop();\\n                if(node->val > max)\\n                    max = node->val;\\n                if(node->left!=NULL)\\n                    q.push(node->left);\\n                if(node->right!=NULL)\\n                    q.push(node->right);\\n            }\\n            ans.push_back(max);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> largestValues(TreeNode* root) {\\n        if(root == NULL)\\n            return {};\\n        queue<TreeNode*> q;\\n        vector<int> ans;\\n        q.push(root);\\n        while(!q.empty())\\n        {\\n            int max = INT_MIN;\\n            for(int level=q.size();level>0;level--)\\n            {\\n                TreeNode* node = q.front();\\n                q.pop();\\n                if(node->val > max)\\n                    max = node->val;\\n                if(node->left!=NULL)\\n                    q.push(node->left);\\n                if(node->right!=NULL)\\n                    q.push(node->right);\\n            }\\n            ans.push_back(max);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3210080,
                "title": "5-line-code-c-simple-level-order-tree",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> largestValues(TreeNode* root) {\\n        if(root == NULL)return {};\\n        vector<int> ans;\\n        int mx,n;\\n        queue<TreeNode*> q;\\n        TreeNode* p;\\n        q.push(root);\\n        while(!q.empty()){\\n            n = q.size();\\n            mx = INT_MIN;\\n            while(n--){\\n                p = q.front();q.pop();\\n                mx = max(mx,p->val);\\n                if(p->left)q.push(p->left);\\n                if(p->right)q.push(p->right);\\n            }\\n            ans.push_back(mx);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> largestValues(TreeNode* root) {\\n        if(root == NULL)return {};\\n        vector<int> ans;\\n        int mx,n;\\n        queue<TreeNode*> q;\\n        TreeNode* p;\\n        q.push(root);\\n        while(!q.empty()){\\n            n = q.size();\\n            mx = INT_MIN;\\n            while(n--){\\n                p = q.front();q.pop();\\n                mx = max(mx,p->val);\\n                if(p->left)q.push(p->left);\\n                if(p->right)q.push(p->right);\\n            }\\n            ans.push_back(mx);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3163037,
                "title": "java-easy-to-understand-solution",
                "content": "\\n\\n# Code\\n```\\n\\nclass Solution {\\n    public List<Integer> largestValues(TreeNode root) {\\n        List<Integer> list = new ArrayList<>();\\n        helper(root, list, 0);\\n        return list;\\n    }\\n    public static void helper(TreeNode root, List<Integer> list, int level){\\n        if(root == null){\\n            return;\\n        }\\n        if(level == list.size()){\\n            list.add(root.val);\\n        }else{\\n            list.set(level, Math.max(list.get(level), root.val));\\n        }\\n        helper(root.left, list, level+1);\\n        helper(root.right, list, level+1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n    public List<Integer> largestValues(TreeNode root) {\\n        List<Integer> list = new ArrayList<>();\\n        helper(root, list, 0);\\n        return list;\\n    }\\n    public static void helper(TreeNode root, List<Integer> list, int level){\\n        if(root == null){\\n            return;\\n        }\\n        if(level == list.size()){\\n            list.add(root.val);\\n        }else{\\n            list.set(level, Math.max(list.get(level), root.val));\\n        }\\n        helper(root.left, list, level+1);\\n        helper(root.right, list, level+1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3138536,
                "title": "c-solution-97-64-time-90-34-space-preorder-tree-traversal",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(log2(n))\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> largestValues(TreeNode* root);\\n\\n    void preorderTraversal(TreeNode *node, vector<int> &mem,\\n       int depth);\\n};\\n/***************************************************************/\\nvector<int> Solution::largestValues(TreeNode* root) {\\n        vector<int> mem;\\n    if (root != nullptr) {\\n        preorderTraversal(root, mem, 0);\\n    }\\n    return mem;\\n}\\n/***************************************************************/\\nvoid Solution::preorderTraversal(TreeNode *node, vector<int> \\n        &mem, int depth) {\\n    if (mem.size() < depth+1) {\\n        mem.emplace_back(node->val);\\n    } else if (mem[depth] < node->val) {\\n        mem[depth] = node->val;\\n    }\\n    if (node->left != nullptr) {\\n        preorderTraversal(node->left, mem, depth+1);\\n    }\\n    if (node->right != nullptr) {\\n        preorderTraversal(node->right, mem, depth+1);\\n    }\\n    return;\\n}\\n/**************************************************************/\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> largestValues(TreeNode* root);\\n\\n    void preorderTraversal(TreeNode *node, vector<int> &mem,\\n       int depth);\\n};\\n/***************************************************************/\\nvector<int> Solution::largestValues(TreeNode* root) {\\n        vector<int> mem;\\n    if (root != nullptr) {\\n        preorderTraversal(root, mem, 0);\\n    }\\n    return mem;\\n}\\n/***************************************************************/\\nvoid Solution::preorderTraversal(TreeNode *node, vector<int> \\n        &mem, int depth) {\\n    if (mem.size() < depth+1) {\\n        mem.emplace_back(node->val);\\n    } else if (mem[depth] < node->val) {\\n        mem[depth] = node->val;\\n    }\\n    if (node->left != nullptr) {\\n        preorderTraversal(node->left, mem, depth+1);\\n    }\\n    if (node->right != nullptr) {\\n        preorderTraversal(node->right, mem, depth+1);\\n    }\\n    return;\\n}\\n/**************************************************************/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3131350,
                "title": "level-order-traversal-python",
                "content": "# Intuition\\nYou can try to think this question as level order traversal. And for each level you need find the node with Highest Value.\\n\\n# Approach\\nMaintain a dictionary to maintain the level of the tree. If you see a new level append the currNode value but if we have came across the level previously then check if the currnode value is greater than what we came across earlier.\\nSo, now the dictionary is containing all the max nodes per level.\\nIterate through it and return all the node value.\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def largestValues(self, root: Optional[TreeNode]) -> List[int]:\\n        levelMap = {}\\n        def dfs(node, level):\\n            if not node:\\n                return \\n            if level not in levelMap:\\n                levelMap[level] = node.val\\n            else:\\n                if node.val >=  levelMap[level]:\\n                    levelMap[level] = node.val\\n            \\n            dfs(node.left, level + 1)\\n            dfs(node.right, level + 1)\\n        dfs(root, 1)\\n        res = []\\n        for i, v in levelMap.items():\\n            res.append(v)\\n        return(res)\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def largestValues(self, root: Optional[TreeNode]) -> List[int]:\\n        levelMap = {}\\n        def dfs(node, level):\\n            if not node:\\n                return \\n            if level not in levelMap:\\n                levelMap[level] = node.val\\n            else:\\n                if node.val >=  levelMap[level]:\\n                    levelMap[level] = node.val\\n            \\n            dfs(node.left, level + 1)\\n            dfs(node.right, level + 1)\\n        dfs(root, 1)\\n        res = []\\n        for i, v in levelMap.items():\\n            res.append(v)\\n        return(res)\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2934554,
                "title": "c-0ms-faster-than-100-bfs-self-explanatory-easy-approach-clean-code",
                "content": "\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    vector<int> largestValues(TreeNode* root) {\\n        \\n       vector<int>level;\\n\\n       if(root == NULL) return level;\\n       queue<TreeNode*>q;\\n       q.push(root);\\n\\n       while(!q.empty())\\n       {\\n           \\n           int n = q.size();\\n           int maxi = INT_MIN;\\n           \\n           for(int i = 0;i<n;++i)\\n           {\\n               auto temp = q.front();\\n               int val = temp->val;\\n               q.pop();\\n               \\n\\n               if(temp->left!=NULL) q.push(temp->left);\\n               if(temp->right!=NULL) q.push(temp->right);\\n            \\n               maxi = max(maxi,val);\\n           }\\n\\n            level.push_back(maxi);\\n        \\n       }\\n\\n       return level; \\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    vector<int> largestValues(TreeNode* root) {\\n        \\n       vector<int>level;\\n\\n       if(root == NULL) return level;\\n       queue<TreeNode*>q;\\n       q.push(root);\\n\\n       while(!q.empty())\\n       {\\n           \\n           int n = q.size();\\n           int maxi = INT_MIN;\\n           \\n           for(int i = 0;i<n;++i)\\n           {\\n               auto temp = q.front();\\n               int val = temp->val;\\n               q.pop();\\n               \\n\\n               if(temp->left!=NULL) q.push(temp->left);\\n               if(temp->right!=NULL) q.push(temp->right);\\n            \\n               maxi = max(maxi,val);\\n           }\\n\\n            level.push_back(maxi);\\n        \\n       }\\n\\n       return level; \\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2450751,
                "title": "java-bfs-dfs",
                "content": "```\\nclass Solution {\\n    public List<Integer> largestValues(TreeNode root) {\\n        //bfs t = O(n) s = O(n)\\n        List<Integer> res = new ArrayList<>();\\n        if(root == null) return res;\\n        Queue<TreeNode> q = new ArrayDeque<>();\\n        q.add(root);\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            int max = Integer.MIN_VALUE;\\n            for(int i = 0; i < size; i ++){\\n                 TreeNode node = q.poll();\\n                 max = Math.max(max, node.val);\\n                 if(node.left != null) q.add(node.left);\\n                 if(node.right != null) q.add(node.right);\\n            }\\n            res.add(max);\\n\\t\\t}\\n        return res;\\n\\t}\\n}\\n        \\nclass Solution {\\n    List<Integer> res = new ArrayList<>();\\n    public List<Integer> largestValues(TreeNode root) {\\n        //dfs\\n        if(root == null) return res;\\n        dfs(root, 0);\\n        return res;\\n    }\\n    private void dfs(TreeNode root, int level){\\n        if(root == null) return;\\n        if(level == res.size()){\\n            res.add(root.val);\\n        }\\n        res.set(level, Math.max(res.get(level), root.val));\\n        dfs(root.left, level + 1);\\n        dfs(root.right, level + 1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> largestValues(TreeNode root) {\\n        //bfs t = O(n) s = O(n)\\n        List<Integer> res = new ArrayList<>();\\n        if(root == null) return res;\\n        Queue<TreeNode> q = new ArrayDeque<>();\\n        q.add(root);\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            int max = Integer.MIN_VALUE;\\n            for(int i = 0; i < size; i ++){\\n                 TreeNode node = q.poll();\\n                 max = Math.max(max, node.val);\\n                 if(node.left != null) q.add(node.left);\\n                 if(node.right != null) q.add(node.right);\\n            }\\n            res.add(max);\\n\\t\\t}\\n        return res;\\n\\t}\\n}\\n        \\nclass Solution {\\n    List<Integer> res = new ArrayList<>();\\n    public List<Integer> largestValues(TreeNode root) {\\n        //dfs\\n        if(root == null) return res;\\n        dfs(root, 0);\\n        return res;\\n    }\\n    private void dfs(TreeNode root, int level){\\n        if(root == null) return;\\n        if(level == res.size()){\\n            res.add(root.val);\\n        }\\n        res.set(level, Math.max(res.get(level), root.val));\\n        dfs(root.left, level + 1);\\n        dfs(root.right, level + 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2342236,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public List<Integer> largestValues(TreeNode root) {\\n        List<Integer> list=new ArrayList<>();\\n        if(root==null)return list;\\n        Queue<TreeNode> q=new LinkedList<>();\\n        q.add(root);\\n        while(!q.isEmpty()){\\n            int levelnum=q.size();\\n            int max=Integer.MIN_VALUE;\\n            for(int i=0;i<levelnum;i++){\\n                if(q.peek().left!=null)q.add(q.peek().left);\\n                if(q.peek().right!=null)q.add(q.peek().right);\\n                max=Math.max(max,q.poll().val);\\n            }\\n            list.add(max);\\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> largestValues(TreeNode root) {\\n        List<Integer> list=new ArrayList<>();\\n        if(root==null)return list;\\n        Queue<TreeNode> q=new LinkedList<>();\\n        q.add(root);\\n        while(!q.isEmpty()){\\n            int levelnum=q.size();\\n            int max=Integer.MIN_VALUE;\\n            for(int i=0;i<levelnum;i++){\\n                if(q.peek().left!=null)q.add(q.peek().left);\\n                if(q.peek().right!=null)q.add(q.peek().right);\\n                max=Math.max(max,q.poll().val);\\n            }\\n            list.add(max);\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2258032,
                "title": "python-bfs",
                "content": "```\\ndef largestValues(self, root: Optional[TreeNode]) -> List[int]:\\n        \\n        if root == None:\\n            return None\\n        \\n        qu = [root]\\n        max_el = []\\n        \\n        while len(qu) != 0:\\n            \\n            a = len(qu)\\n            maxm = float(\\'-Inf\\')\\n            \\n            for i in range(a):\\n                \\n                node = qu[0]\\n                qu.pop(0)\\n                if node and node.val > maxm:\\n                    maxm = node.val\\n                if node and node.left:\\n                    qu.append(node.left)\\n                if node and node.right:\\n                    qu.append(node.right)\\n            max_el.append(maxm)\\n        \\n        return max_el",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\ndef largestValues(self, root: Optional[TreeNode]) -> List[int]:\\n        \\n        if root == None:\\n            return None\\n        \\n        qu = [root]\\n        max_el = []\\n        \\n        while len(qu) != 0:\\n            \\n            a = len(qu)\\n            maxm = float(\\'-Inf\\')\\n            \\n            for i in range(a):\\n                \\n                node = qu[0]\\n                qu.pop(0)\\n                if node and node.val > maxm:\\n                    maxm = node.val\\n                if node and node.left:\\n                    qu.append(node.left)\\n                if node and node.right:\\n                    qu.append(node.right)\\n            max_el.append(maxm)\\n        \\n        return max_el",
                "codeTag": "Python3"
            },
            {
                "id": 2049474,
                "title": "python-bfs",
                "content": "```\\n    def largestValues(self, root: Optional[TreeNode]) -> List[int]:\\n        queue = []\\n        result = []\\n        if not root:\\n            return result\\n        result.append(root.val)\\n        queue.append(root)\\n        while queue:\\n            lvl = []\\n            for i in range(len(queue)):\\n                item = queue.pop(0)\\n                \\n                if item.left:\\n                    queue.append(item.left)\\n                    lvl.append(item.left.val)\\n                \\n                if item.right:\\n                    queue.append(item.right)\\n                    lvl.append(item.right.val)\\n            if len(lvl) >= 1:\\n                result.append(max(lvl))\\n        \\n        return result\\n````",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\n    def largestValues(self, root: Optional[TreeNode]) -> List[int]:\\n        queue = []\\n        result = []\\n        if not root:\\n            return result\\n        result.append(root.val)\\n        queue.append(root)\\n        while queue:\\n            lvl = []\\n            for i in range(len(queue)):\\n                item = queue.pop(0)\\n                \\n                if item.left:\\n                    queue.append(item.left)\\n                    lvl.append(item.left.val)\\n                \\n                if item.right:\\n                    queue.append(item.right)\\n                    lvl.append(item.right.val)\\n            if len(lvl) >= 1:\\n                result.append(max(lvl))\\n        \\n        return result\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1722652,
                "title": "simple-c-bfs-solution",
                "content": "Iterate the tree using a level-order traversal (breadth-first-search) and at each level identify the maximum number and push it into the solution array.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> largestValues(TreeNode* root) {\\n        if(root == NULL)\\n            return {};\\n        queue<TreeNode*> q;\\n        vector<int> ans;\\n        q.push(root);\\n        while(!q.empty())\\n        {\\n            int max = INT_MIN;\\n            for(int level=q.size();level>0;level--)\\n            {\\n                TreeNode* node = q.front();\\n                q.pop();\\n                if(node->val > max)\\n                    max = node->val;\\n                if(node->left!=NULL)\\n                    q.push(node->left);\\n                if(node->right!=NULL)\\n                    q.push(node->right);\\n            }\\n            ans.push_back(max);\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> largestValues(TreeNode* root) {\\n        if(root == NULL)\\n            return {}",
                "codeTag": "Java"
            },
            {
                "id": 1620422,
                "title": "python-3-easy-dfs-recursive-solution-faster-than-94",
                "content": "```\\nclass Solution:\\n    def largestValues(self, root: Optional[TreeNode]) -> List[int]:\\n        res = []\\n\\n        def helper(root, depth):\\n            if root is None:\\n                return\\n            \\n            if depth == len(res):\\n                res.append(root.val)\\n            else:\\n                res[depth] = max(res[depth], root.val)\\n            \\n            helper(root.left, depth + 1)\\n            helper(root.right, depth + 1)\\n        \\n        helper(root, 0)\\n        return res",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def largestValues(self, root: Optional[TreeNode]) -> List[int]:\\n        res = []\\n\\n        def helper(root, depth):\\n            if root is None:\\n                return\\n            \\n            if depth == len(res):\\n                res.append(root.val)\\n            else:\\n                res[depth] = max(res[depth], root.val)\\n            \\n            helper(root.left, depth + 1)\\n            helper(root.right, depth + 1)\\n        \\n        helper(root, 0)\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 1578156,
                "title": "c-level-order-traversal-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> largestValues(TreeNode* root) {\\n        vector<int> ans;\\n        if(!root)\\n            return ans;\\n        \\n        queue<TreeNode*> mq;\\n        mq.push(root);\\n        \\n        while(mq.size() > 0){\\n            int n = mq.size();\\n            int max = INT_MIN;\\n            for(int i = 0; i < n; i++){\\n                root = mq.front();\\n                mq.pop();\\n                if(root->val > max)\\n                    max = root->val;\\n                \\n                if(root->left != NULL)\\n                    mq.push(root->left);\\n                if(root->right != NULL)\\n                    mq.push(root->right);\\n            }\\n            ans.push_back(max);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> largestValues(TreeNode* root) {\\n        vector<int> ans;\\n        if(!root)\\n            return ans;\\n        \\n        queue<TreeNode*> mq;\\n        mq.push(root);\\n        \\n        while(mq.size() > 0){\\n            int n = mq.size();\\n            int max = INT_MIN;\\n            for(int i = 0; i < n; i++){\\n                root = mq.front();\\n                mq.pop();\\n                if(root->val > max)\\n                    max = root->val;\\n                \\n                if(root->left != NULL)\\n                    mq.push(root->left);\\n                if(root->right != NULL)\\n                    mq.push(root->right);\\n            }\\n            ans.push_back(max);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1500412,
                "title": "c-using-level-order-traversal",
                "content": "class Solution {\\npublic:\\n    vector<int> largestValues(TreeNode* root) {\\n        vector<int>res;\\n        if(root == NULL){\\n            return res;\\n            \\n        }\\n        queue <TreeNode*>q;\\n        q.push(root);\\n        while(q.empty() == false){\\n            int count = q.size();\\n            int large = INT_MIN;\\n            for(int i =0; i < count;i++){\\n                TreeNode* curr = q.front();\\n                q.pop();\\n                large = max(large,curr->val);\\n                if(curr->left != NULL){\\n                    q.push(curr->left);\\n                    \\n                }\\n                if(curr->right != NULL){\\n                    q.push(curr->right);\\n                    \\n                }\\n                \\n            }\\n            res.push_back(large);\\n        }\\n        return res;\\n        \\n        \\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> largestValues(TreeNode* root) {\\n        vector<int>res;\\n        if(root == NULL){\\n            return res;\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1394862,
                "title": "java-solution-faster-than-96",
                "content": "```\\nclass Solution {\\n    public List<Integer> largestValues(TreeNode root) {\\n        \\n   \\n        List<Integer> res = new ArrayList<>() ;\\n             if(root==null)return res ;\\n        Queue<TreeNode> q = new LinkedList<>() ;\\n        \\n        res.add(root.val) ;\\n        q.add(root) ;\\n        \\n        while(!q.isEmpty()){\\n            \\n            int size = q.size() ;\\n            boolean flag = false ;\\n            int max = Integer.MIN_VALUE;\\n            for(int i=0 ; i<size ;i++){\\n                TreeNode curr = q.remove() ;\\n              \\n                if(curr.left!=null){\\n                      if(curr.left.val>=max){max=curr.left.val ; flag = true ;}\\n                    q.add(curr.left) ;\\n                }\\n                if(curr.right!=null){\\n                      if(curr.right.val>=max){max=curr.right.val ; flag = true ;}\\n                    q.add(curr.right) ;\\n                }\\n            }\\n            if(flag) \\n            res.add(max) ;\\n        }\\n        \\n        \\n        return res ;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> largestValues(TreeNode root) {\\n        \\n   \\n        List<Integer> res = new ArrayList<>() ;\\n             if(root==null)return res ;\\n        Queue<TreeNode> q = new LinkedList<>() ;\\n        \\n        res.add(root.val) ;\\n        q.add(root) ;\\n        \\n        while(!q.isEmpty()){\\n            \\n            int size = q.size() ;\\n            boolean flag = false ;\\n            int max = Integer.MIN_VALUE;\\n            for(int i=0 ; i<size ;i++){\\n                TreeNode curr = q.remove() ;\\n              \\n                if(curr.left!=null){\\n                      if(curr.left.val>=max){max=curr.left.val ; flag = true ;}\\n                    q.add(curr.left) ;\\n                }\\n                if(curr.right!=null){\\n                      if(curr.right.val>=max){max=curr.right.val ; flag = true ;}\\n                    q.add(curr.right) ;\\n                }\\n            }\\n            if(flag) \\n            res.add(max) ;\\n        }\\n        \\n        \\n        return res ;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1167794,
                "title": "c-100-fast-level-order-traversal-beginner-friendly",
                "content": "**PLZ UPVOTE IF YOU LIKED IT**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    vector<int> largestValues(TreeNode* root) {\\n        if(root==NULL)return ans;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        \\n        while(q.size()!=NULL){\\n            int size=q.size();\\n            int x=INT_MIN;\\n            for(int i=0;i<size;i++){\\n                TreeNode* temp=q.front();\\n                q.pop();\\n                if(temp->left)q.push(temp->left);\\n                if(temp->right)q.push(temp->right);\\n                if(temp->val>x)x=temp->val;\\n            }\\n            ans.push_back(x);\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> ans;\\n    vector<int> largestValues(TreeNode* root) {\\n        if(root==NULL)return ans;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        \\n        while(q.size()!=NULL){\\n            int size=q.size();\\n            int x=INT_MIN;\\n            for(int i=0;i<size;i++){\\n                TreeNode* temp=q.front();\\n                q.pop();\\n                if(temp->left)q.push(temp->left);\\n                if(temp->right)q.push(temp->right);\\n                if(temp->val>x)x=temp->val;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1109531,
                "title": "easy-python-recursive-beats-99",
                "content": "```\\nclass Solution(object):\\n    def largestValues(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[int]\\n        \"\"\"\\n        \\n        res = []\\n        \\n        def helper(node, level):\\n            if not node:\\n                return\\n            if len(res) <= level:\\n                res.append(node.val)\\n            res[level] = max(res[level], node.val)\\n            helper(node.left, level + 1)\\n            helper(node.right, level + 1)\\n            \\n        helper(root, 0)\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def largestValues(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[int]\\n        \"\"\"\\n        \\n        res = []\\n        \\n        def helper(node, level):\\n            if not node:\\n                return\\n            if len(res) <= level:\\n                res.append(node.val)\\n            res[level] = max(res[level], node.val)\\n            helper(node.left, level + 1)\\n            helper(node.right, level + 1)\\n            \\n        helper(root, 0)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1073340,
                "title": "c-both-dfs-and-bfs",
                "content": "# DFS Using Recursion\\n```\\n// Recursive\\n//Idea Calculate max at each deapth/height\\nclass Solution {\\npublic:\\n    vector<int> largestValues(TreeNode* root) {\\n        if(!root) return {};\\n        vector<int> res;\\n        maxAtEachDepth(root, 0, res);\\n        return res;        \\n    }\\n    \\n    void maxAtEachDepth(TreeNode* root, int depth, vector<int> &res)\\n    {\\n        if(!root) return;\\n        if(res.size() > depth)\\n            res[depth] = max(res[depth], root->val);\\n        else\\n            res.push_back(root->val);\\n        \\n        maxAtEachDepth(root->left, depth+1, res);\\n        maxAtEachDepth(root->right, depth+1, res);\\n    }\\n};\\n```\\n\\n\\n# BFS Using Iteration\\n```\\nclass Solution {\\npublic:\\n    vector<int> largestValues(TreeNode* root) {\\n        if(!root) return {};\\n        \\n        vector<int> res;\\n        int mx = INT_MIN;\\n        TreeNode* temp;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        q.push(nullptr);\\n        \\n        while(!q.empty())\\n        {\\n            temp = q.front();\\n            q.pop();\\n            if(!temp)\\n            {\\n                res.push_back(mx);\\n                mx = INT_MIN;\\n                if(q.empty())\\n                    return res;\\n                q.push(nullptr);\\n                continue;\\n            }\\n            \\n            mx = max(mx, temp->val);\\n            if(temp->left)  q.push(temp->left);\\n            if(temp->right) q.push(temp->right);\\n        }\\n\\t\\treturn res;\\n    }\\n};\\n\\t\\t```",
                "solutionTags": [
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\n// Recursive\\n//Idea Calculate max at each deapth/height\\nclass Solution {\\npublic:\\n    vector<int> largestValues(TreeNode* root) {\\n        if(!root) return {};\\n        vector<int> res;\\n        maxAtEachDepth(root, 0, res);\\n        return res;        \\n    }\\n    \\n    void maxAtEachDepth(TreeNode* root, int depth, vector<int> &res)\\n    {\\n        if(!root) return;\\n        if(res.size() > depth)\\n            res[depth] = max(res[depth], root->val);\\n        else\\n            res.push_back(root->val);\\n        \\n        maxAtEachDepth(root->left, depth+1, res);\\n        maxAtEachDepth(root->right, depth+1, res);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> largestValues(TreeNode* root) {\\n        if(!root) return {};\\n        \\n        vector<int> res;\\n        int mx = INT_MIN;\\n        TreeNode* temp;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        q.push(nullptr);\\n        \\n        while(!q.empty())\\n        {\\n            temp = q.front();\\n            q.pop();\\n            if(!temp)\\n            {\\n                res.push_back(mx);\\n                mx = INT_MIN;\\n                if(q.empty())\\n                    return res;\\n                q.push(nullptr);\\n                continue;\\n            }\\n            \\n            mx = max(mx, temp->val);\\n            if(temp->left)  q.push(temp->left);\\n            if(temp->right) q.push(temp->right);\\n        }\\n\\t\\treturn res;\\n    }\\n};\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 979427,
                "title": "c-solutions-dfs-bfs",
                "content": "DFS method (faster, 8ms) :\\n```\\nclass Solution {\\npublic:\\n    vector<int> res;\\n    vector<int> largestValues(TreeNode* root) {\\n        dfs(root, 0);\\n        return res;\\n    }\\n    \\n    void dfs(TreeNode* root, int level){\\n        if(!root) return;\\n        \\n        if(res.size() == level){\\n            res.push_back(root->val);\\n        }\\n        else{\\n            res[level] = max(res[level], root->val);\\n        }\\n        \\n        dfs(root->left, level+1);\\n        dfs(root->right, level+1);\\n    }\\n};\\n```\\n\\nBFS method (16ms):\\n```\\nclass Solution {\\npublic:\\n    vector<int> largestValues(TreeNode* root) {\\n        if(!root) return {};\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        \\n        vector<int> res;\\n        \\n        while(!q.empty()){\\n            int s = q.size();\\n            int row_max = INT_MIN;\\n            while(s--){\\n                TreeNode* curr = q.front();\\n                q.pop();\\n                \\n                row_max = max(curr->val, row_max);\\n                \\n                if(curr->left) q.push(curr->left);\\n                if(curr->right) q.push(curr->right);\\n            }\\n            \\n            res.push_back(row_max);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> res;\\n    vector<int> largestValues(TreeNode* root) {\\n        dfs(root, 0);\\n        return res;\\n    }\\n    \\n    void dfs(TreeNode* root, int level){\\n        if(!root) return;\\n        \\n        if(res.size() == level){\\n            res.push_back(root->val);\\n        }\\n        else{\\n            res[level] = max(res[level], root->val);\\n        }\\n        \\n        dfs(root->left, level+1);\\n        dfs(root->right, level+1);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> largestValues(TreeNode* root) {\\n        if(!root) return {};\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        \\n        vector<int> res;\\n        \\n        while(!q.empty()){\\n            int s = q.size();\\n            int row_max = INT_MIN;\\n            while(s--){\\n                TreeNode* curr = q.front();\\n                q.pop();\\n                \\n                row_max = max(curr->val, row_max);\\n                \\n                if(curr->left) q.push(curr->left);\\n                if(curr->right) q.push(curr->right);\\n            }\\n            \\n            res.push_back(row_max);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 913550,
                "title": "c-o-n-dfs-solution-100-faster",
                "content": "Here\\'s the video with the explanation :\\n\\nhttps://www.youtube.com/watch?v=b59lL1IkqGk&feature=youtu.be\\n\\n```\\nclass Solution\\n{\\npublic:\\n    vector<int> largestValues(TreeNode *root)\\n    {\\n        vector<int> largest_val;\\n        helper(root, largest_val, 0);\\n\\n        return largest_val;\\n    }\\n\\n    void helper(TreeNode *root, vector<int> largest_val, int height)\\n    {\\n        if (root == NULL)\\n            return root;\\n\\n        if (largest_val.size() == height)\\n            largest_val.push_back(root->val);\\n        else\\n            largest_val[height] = max(largest_val[height], root->val);\\n\\n        helper(root->left, largest_val, int height + 1);\\n        helper(root->right, largest_val, int height + 1);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    vector<int> largestValues(TreeNode *root)\\n    {\\n        vector<int> largest_val;\\n        helper(root, largest_val, 0);\\n\\n        return largest_val;\\n    }\\n\\n    void helper(TreeNode *root, vector<int> largest_val, int height)\\n    {\\n        if (root == NULL)\\n            return root;\\n\\n        if (largest_val.size() == height)\\n            largest_val.push_back(root->val);\\n        else\\n            largest_val[height] = max(largest_val[height], root->val);\\n\\n        helper(root->left, largest_val, int height + 1);\\n        helper(root->right, largest_val, int height + 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 892343,
                "title": "java-soln-easy-to-understand-level-order-traversal",
                "content": "class Solution {\\n    public List<Integer> largestValues(TreeNode root) {\\n             \\n        List<Integer>result=new ArrayList<>();\\n        if(root==null)\\n            return result;\\n        \\n        Queue <TreeNode> q=new LinkedList<>();\\n        q.add(root);\\n        \\n        while(!q.isEmpty())\\n        {\\n            \\n            int max=Integer.MIN_VALUE;\\n            int size=q.size();\\n            \\n            for(int i=0;i<size;i++)\\n            {\\n                \\n                TreeNode curr=q.remove();\\n            \\n                if(curr.val >= max)\\n                {\\n                    max=curr.val;\\n                }\\n                if(curr.left!=null)\\n                    q.add(curr.left);\\n            \\n           \\n                if(curr.right!=null)\\n                    q.add(curr.right);\\n            }  \\n            result.add(max);  \\n        }\\n        \\n        return result;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Queue"
                ],
                "code": "class Solution {\\n    public List<Integer> largestValues(TreeNode root) {\\n             \\n        List<Integer>result=new ArrayList<>();\\n        if(root==null)\\n            return result;\\n        \\n        Queue <TreeNode> q=new LinkedList<>();\\n        q.add(root);\\n        \\n        while(!q.isEmpty())\\n        {\\n            \\n            int max=Integer.MIN_VALUE;\\n            int size=q.size();\\n            \\n            for(int i=0;i<size;i++)\\n            {\\n                \\n                TreeNode curr=q.remove();\\n            \\n                if(curr.val >= max)\\n                {\\n                    max=curr.val;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 875758,
                "title": "python-solution-using-bfs-96-52-ms",
                "content": "```\\nfrom collections import deque\\nclass Solution:\\n    def largestValues(self, root: TreeNode) -> List[int]:\\n        if not root:\\n            return []\\n        level={}\\n        q=deque()\\n        q.append((root,0))\\n        while q:\\n            a,b=q.popleft()\\n            level[b]=level.get(b,[])+[a.val]\\n            if a.left:\\n                q.append((a.left,b+1))\\n            if a.right:\\n                q.append((a.right,b+1))\\n        ans=[]\\n        for i in range(max(level)+1):\\n            ans.append(max(level[i]))\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import deque\\nclass Solution:\\n    def largestValues(self, root: TreeNode) -> List[int]:\\n        if not root:\\n            return []\\n        level={}\\n        q=deque()\\n        q.append((root,0))\\n        while q:\\n            a,b=q.popleft()\\n            level[b]=level.get(b,[])+[a.val]\\n            if a.left:\\n                q.append((a.left,b+1))\\n            if a.right:\\n                q.append((a.right,b+1))\\n        ans=[]\\n        for i in range(max(level)+1):\\n            ans.append(max(level[i]))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 754222,
                "title": "java-using-level-order-traversal",
                "content": "```\\n  public List<Integer> largestValues(TreeNode root) {\\n        List<Integer> maxSums = new ArrayList<>();\\n\\n        if(root == null)\\n            return maxSums;\\n\\n        Queue<TreeNode> queue = new ArrayDeque<>();\\n        queue.add(root);\\n\\n        while(!queue.isEmpty()){\\n           int size = queue.size();\\n           int max = Integer.MIN_VALUE;\\n           while(size-- > 0){\\n               TreeNode current = queue.poll();\\n               max = Math.max(max, current.val);\\n\\n               if(current.left != null)\\n                queue.add(current.left);\\n\\n               if(current.right != null)\\n                queue.add(current.right);\\n           }\\n           maxSums.add(max);\\n       }\\n       return maxSums;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n  public List<Integer> largestValues(TreeNode root) {\\n        List<Integer> maxSums = new ArrayList<>();\\n\\n        if(root == null)\\n            return maxSums;\\n\\n        Queue<TreeNode> queue = new ArrayDeque<>();\\n        queue.add(root);\\n\\n        while(!queue.isEmpty()){\\n           int size = queue.size();\\n           int max = Integer.MIN_VALUE;\\n           while(size-- > 0){\\n               TreeNode current = queue.poll();\\n               max = Math.max(max, current.val);\\n\\n               if(current.left != null)\\n                queue.add(current.left);\\n\\n               if(current.right != null)\\n                queue.add(current.right);\\n           }\\n           maxSums.add(max);\\n       }\\n       return maxSums;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 562357,
                "title": "easy-javascript-solution-bfs",
                "content": "```\\nvar largestValues = function(root) {\\n    if(!root) return []\\n    let queue = [];\\n    let results = [];\\n    queue.push(root)\\n    while(queue.length){\\n        const length = queue.length;\\n        let max = -Infinity;\\n        for(let i=0; i<length; i++){\\n            let node = queue.shift();\\n            if(max < node.val) max = node.val\\n            if(node.left) queue.push(node.left)\\n            if(node.right) queue.push(node.right)\\n        }\\n        results.push(max);\\n    }\\n    return results\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search",
                    "Iterator"
                ],
                "code": "```\\nvar largestValues = function(root) {\\n    if(!root) return []\\n    let queue = [];\\n    let results = [];\\n    queue.push(root)\\n    while(queue.length){\\n        const length = queue.length;\\n        let max = -Infinity;\\n        for(let i=0; i<length; i++){\\n            let node = queue.shift();\\n            if(max < node.val) max = node.val\\n            if(node.left) queue.push(node.left)\\n            if(node.right) queue.push(node.right)\\n        }\\n        results.push(max);\\n    }\\n    return results\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 544039,
                "title": "javascript-solutions-recursively-and-iteratively",
                "content": "Iteratively (80ms)\\n```\\nfunction largestValues(root) {\\n    if (!root) return [];\\n    \\n    let result = [];\\n    let queue = [root];\\n    while(queue.length > 0) {\\n        const levelSize = queue.length;\\n        let max = -Infinity;\\n        \\n        for (let i = 0; i < levelSize; i++) {\\n            const node = queue.pop();\\n            max = Math.max(node.val, max);\\n            if (node.left) {\\n                queue.unshift(node.left)\\n            }\\n            if (node.right) {\\n                queue.unshift(node.right);\\n            }\\n        }\\n        result.push(max);\\n    }\\n    \\n    return result;\\n}\\n```\\n\\nRecursively (68ms)\\n```\\nfunction largestValues(root) {\\n    if (!root) return [];\\n    let result = [];\\n    \\n    function traverse(node, level) {\\n        if (result[level] === undefined) {\\n            result.push(node.val);\\n        } else if (node.val > result[level]) {\\n            result[level] = node.val;\\n        }\\n        \\n        if (node.left) {\\n            traverse(node.left, level + 1);\\n        }\\n        if (node.right) {\\n            traverse(node.right, level + 1);\\n        }\\n    }\\n    \\n    traverse(root, 0);\\n    \\n    return result;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nfunction largestValues(root) {\\n    if (!root) return [];\\n    \\n    let result = [];\\n    let queue = [root];\\n    while(queue.length > 0) {\\n        const levelSize = queue.length;\\n        let max = -Infinity;\\n        \\n        for (let i = 0; i < levelSize; i++) {\\n            const node = queue.pop();\\n            max = Math.max(node.val, max);\\n            if (node.left) {\\n                queue.unshift(node.left)\\n            }\\n            if (node.right) {\\n                queue.unshift(node.right);\\n            }\\n        }\\n        result.push(max);\\n    }\\n    \\n    return result;\\n}\\n```\n```\\nfunction largestValues(root) {\\n    if (!root) return [];\\n    let result = [];\\n    \\n    function traverse(node, level) {\\n        if (result[level] === undefined) {\\n            result.push(node.val);\\n        } else if (node.val > result[level]) {\\n            result[level] = node.val;\\n        }\\n        \\n        if (node.left) {\\n            traverse(node.left, level + 1);\\n        }\\n        if (node.right) {\\n            traverse(node.right, level + 1);\\n        }\\n    }\\n    \\n    traverse(root, 0);\\n    \\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 541750,
                "title": "javascript-solution-87",
                "content": "```\\nvar largestValues = function(root) {\\n    let result = [];\\n    \\n    levelOrderMax(root, result);\\n    \\n    return result\\n};\\n\\nvar levelOrderMax = (node, result, depth = 0) => {\\n    if (!node) return;\\n    \\n    if (result[depth] === undefined || node.val > result[depth]) {\\n        result[depth] = node.val;\\n    }\\n    \\n    levelOrderMax(node.left, result, depth + 1);\\n    levelOrderMax(node.right, result, depth + 1);\\n}\\n```\\n\\nRuntime: 64 ms, faster than 87.26% of JavaScript online submissions for Find Largest Value in Each Tree Row.\\nMemory Usage: 38.3 MB, less than 100.00% of JavaScript online submissions for Find Largest Value in Each Tree Row.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar largestValues = function(root) {\\n    let result = [];\\n    \\n    levelOrderMax(root, result);\\n    \\n    return result\\n};\\n\\nvar levelOrderMax = (node, result, depth = 0) => {\\n    if (!node) return;\\n    \\n    if (result[depth] === undefined || node.val > result[depth]) {\\n        result[depth] = node.val;\\n    }\\n    \\n    levelOrderMax(node.left, result, depth + 1);\\n    levelOrderMax(node.right, result, depth + 1);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 271416,
                "title": "java-recursive-approach",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public List<Integer> largestValues(TreeNode root) {\\n        List<Integer> res = new ArrayList<>();\\n        findLevelLargest(root,res,0);\\n        return res;\\n    }\\n    \\n    private void findLevelLargest(TreeNode node, List<Integer> res,int level) {\\n        \\n        if ( node == null) return;\\n    \\n        if (res.size() < (level+1)){\\n            res.add(level,node.val);\\n         } else { \\n          if (node.val > res.get(level)) {  \\n            res.remove(level);  \\n            res.add(level, node.val);\\n          }\\n        }\\n        \\n        findLevelLargest(node.left,res,level+1);\\n        findLevelLargest(node.right,res,level+1);\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public List<Integer> largestValues(TreeNode root) {\\n        List<Integer> res = new ArrayList<>();\\n        findLevelLargest(root,res,0);\\n        return res;\\n    }\\n    \\n    private void findLevelLargest(TreeNode node, List<Integer> res,int level) {\\n        \\n        if ( node == null) return;\\n    \\n        if (res.size() < (level+1)){\\n            res.add(level,node.val);\\n         } else { \\n          if (node.val > res.get(level)) {  \\n            res.remove(level);  \\n            res.add(level, node.val);\\n          }\\n        }\\n        \\n        findLevelLargest(node.left,res,level+1);\\n        findLevelLargest(node.right,res,level+1);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 224301,
                "title": "c-8-ms-faster-than-99-23-using-pre-order-traversal-only",
                "content": "Atleast one node at `depth - 1` is always visited before the first node at `depth` ,\\nits either `push_back` or `compare`\\n\\n```\\nclass Solution {\\npublic:\\n    void preorder(TreeNode* root, int depth, vector<int>& max_val){\\n        if(root == NULL){\\n            return;\\n        }\\n        \\n        if(max_val.size() > depth){\\n            max_val[depth] = max(max_val[depth], root->val);\\n        }else{\\n            max_val.push_back(root->val);\\n        }\\n        preorder(root->left, depth+1, max_val);\\n        preorder(root->right, depth+1, max_val);\\n    }\\n    \\n    vector<int> largestValues(TreeNode* root) {\\n        vector<int> ans;\\n        preorder(root, 0, ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void preorder(TreeNode* root, int depth, vector<int>& max_val){\\n        if(root == NULL){\\n            return;\\n        }\\n        \\n        if(max_val.size() > depth){\\n            max_val[depth] = max(max_val[depth], root->val);\\n        }else{\\n            max_val.push_back(root->val);\\n        }\\n        preorder(root->left, depth+1, max_val);\\n        preorder(root->right, depth+1, max_val);\\n    }\\n    \\n    vector<int> largestValues(TreeNode* root) {\\n        vector<int> ans;\\n        preorder(root, 0, ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 99050,
                "title": "javascript-solution-using-bfs",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number[]}\\n */\\nvar largestValues = function(root) {\\n    var res = [];\\n    \\n    if (!root) { return res; }\\n    \\n    var queue = [];\\n    queue.push(root);\\n    \\n    while (queue.length > 0) {\\n        var size = queue.length;\\n        var max = Number.MIN_SAFE_INTEGER;\\n        for (var i = 0; i < size; i++) {\\n            var node = queue.shift();\\n            if (node.val >= max) { max = node.val; }\\n            if (node.left) { queue.push(node.left); }\\n            if (node.right) { queue.push(node.right); }\\n        }\\n        res.push(max);\\n    }\\n    \\n    return res;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number[]}\\n */\\nvar largestValues = function(root) {\\n    var res = [];\\n    \\n    if (!root) { return res; }\\n    \\n    var queue = [];\\n    queue.push(root);\\n    \\n    while (queue.length > 0) {\\n        var size = queue.length;\\n        var max = Number.MIN_SAFE_INTEGER;\\n        for (var i = 0; i < size; i++) {\\n            var node = queue.shift();\\n            if (node.val >= max) { max = node.val; }\\n            if (node.left) { queue.push(node.left); }\\n            if (node.right) { queue.push(node.right); }\\n        }\\n        res.push(max);\\n    }\\n    \\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4014651,
                "title": "bfs-single-pass",
                "content": "![image](https://assets.leetcode.com/users/images/ebf2a917-f676-453d-bdb3-60b20e76ee1c_1694098918.4094658.png)\\n![image](https://assets.leetcode.com/users/images/6f18cf10-4ab8-49b2-877c-dbe5acdb5874_1694098924.4784186.png)\\n![image](https://assets.leetcode.com/users/images/4f94f128-0623-489a-add7-99d5e8c64c17_1694098929.718191.png)\\n",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "![image](https://assets.leetcode.com/users/images/ebf2a917-f676-453d-bdb3-60b20e76ee1c_1694098918.4094658.png)\\n![image](https://assets.leetcode.com/users/images/6f18cf10-4ab8-49b2-877c-dbe5acdb5874_1694098924.4784186.png)\\n![image](https://assets.leetcode.com/users/images/4f94f128-0623-489a-add7-99d5e8c64c17_1694098929.718191.png)\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3974168,
                "title": "my-simple-bfs-solution",
                "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> largestValues(TreeNode* root) {\\n        vector<int> ans;\\n        \\n        if(!root) {\\n            return ans;\\n        }\\n\\n        queue<TreeNode*> q;\\n\\n        q.push(root);\\n\\n        while(!q.empty()) {\\n            int maxNo = INT_MIN;\\n            int size = q.size();\\n\\n            for(int i=0;i<size;i++) {\\n                TreeNode* curr = q.front();\\n                q.pop();\\n\\n                maxNo = max(maxNo,curr->val);\\n\\n                if(curr->left)\\n                    q.push(curr->left);\\n\\n                if(curr->right)\\n                    q.push(curr->right);\\n            }\\n\\n\\n            ans.push_back(maxNo);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> largestValues(TreeNode* root) {\\n        vector<int> ans;\\n        \\n        if(!root) {\\n            return ans;\\n        }\\n\\n        queue<TreeNode*> q;\\n\\n        q.push(root);\\n\\n        while(!q.empty()) {\\n            int maxNo = INT_MIN;\\n            int size = q.size();\\n\\n            for(int i=0;i<size;i++) {\\n                TreeNode* curr = q.front();\\n                q.pop();\\n\\n                maxNo = max(maxNo,curr->val);\\n\\n                if(curr->left)\\n                    q.push(curr->left);\\n\\n                if(curr->right)\\n                    q.push(curr->right);\\n            }\\n\\n\\n            ans.push_back(maxNo);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3956052,
                "title": "both-approaches-lot-and-recursion-in-c",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nusing LOT simply go through each level and find its maximum value and push it in ans vector\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->```\\nCode block\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> largestValues(TreeNode* root) {\\n        vector<int> ans;\\n        if(root == NULL) return ans;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        q.push(NULL);\\n\\n        while(!q.empty()){\\n           TreeNode* t = q.front();\\n           q.pop();\\n           int maxi = INT_MIN;\\n           while(t != NULL){\\n                maxi = max(maxi,t->val);\\n                if(t->left) q.push(t->left);\\n                if(t->right) q.push(t->right);\\n                t = q.front();\\n                q.pop();\\n           }\\n           ans.push_back(maxi);\\n           if(!q.empty()) q.push(NULL);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nusing recursion we will keep track of our current leve and the max level. if curr level increases then we will change our max level to that and push the first value of that level in the ans vector. after that we can check if the remaining values of the values are greater or not.\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->```\\n\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    void solve(TreeNode* root,int curr, int &maxl){\\n        if(root == NULL) return;\\n        if(curr > maxl){\\n            maxl = curr;\\n            ans.push_back(root->val);\\n        }\\n\\n        ans[curr] = max(ans[curr],root->val);\\n        solve(root->left,curr + 1,maxl);\\n        solve(root->right,curr+1,maxl); \\n    }\\n\\n    vector<int> largestValues(TreeNode* root){\\n        int maxl = -1;\\n        solve(root,0,maxl);\\n        return ans;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nCode block\\n```\n```\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nusing recursion we will keep track of our current leve and the max level. if curr level increases then we will change our max level to that and push the first value of that level in the ans vector. after that we can check if the remaining values of the values are greater or not.\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->```\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    void solve(TreeNode* root,int curr, int &maxl){\\n        if(root == NULL) return;\\n        if(curr > maxl){\\n            maxl = curr;\\n            ans.push_back(root->val);\\n        }\\n\\n        ans[curr] = max(ans[curr],root->val);\\n        solve(root->left,curr + 1,maxl);\\n        solve(root->right,curr+1,maxl); \\n    }\\n\\n    vector<int> largestValues(TreeNode* root){\\n        int maxl = -1;\\n        solve(root,0,maxl);\\n        return ans;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3854848,
                "title": "java-solved-using-bfs-clean-code",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<Integer> largestValues(TreeNode root) {\\n        List<Integer> ls = new ArrayList <> ();\\n        if(root==null){\\n            return ls;\\n        }\\n        Queue <TreeNode> q = new LinkedList<> ();\\n        q.add(root);\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            int max = Integer.MIN_VALUE;\\n            for(int i = 0 ; i < size ; i++){\\n                if(q.peek().left!=null){\\n                    q.add(q.peek().left);\\n                }\\n                if(q.peek().right!=null){\\n                    q.add(q.peek().right);\\n                }\\n                max = Math.max(max , q.remove().val);\\n            }\\n            ls.add(max);\\n        }\\n        return ls;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<Integer> largestValues(TreeNode root) {\\n        List<Integer> ls = new ArrayList <> ();\\n        if(root==null){\\n            return ls;\\n        }\\n        Queue <TreeNode> q = new LinkedList<> ();\\n        q.add(root);\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            int max = Integer.MIN_VALUE;\\n            for(int i = 0 ; i < size ; i++){\\n                if(q.peek().left!=null){\\n                    q.add(q.peek().left);\\n                }\\n                if(q.peek().right!=null){\\n                    q.add(q.peek().right);\\n                }\\n                max = Math.max(max , q.remove().val);\\n            }\\n            ls.add(max);\\n        }\\n        return ls;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3795191,
                "title": "find-the-largest-value-in-each-tree-row",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n![image.png](https://assets.leetcode.com/users/images/f42b11e8-669a-43b0-b033-b32969815b9c_1689914892.6863434.png)\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def largestValues(self, root: Optional[TreeNode]) -> List[int]:\\n        l=defaultdict(list)\\n        def traversal(root,h):\\n            if root is None:\\n                return\\n            l[h].append(root.val)\\n            traversal(root.left,h+1)\\n            traversal(root.right,h+1)\\n        traversal(root,0)\\n        res=[]\\n        for i in l.values():\\n            res.append(max(i))\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def largestValues(self, root: Optional[TreeNode]) -> List[int]:\\n        l=defaultdict(list)\\n        def traversal(root,h):\\n            if root is None:\\n                return\\n            l[h].append(root.val)\\n            traversal(root.left,h+1)\\n            traversal(root.right,h+1)\\n        traversal(root,0)\\n        res=[]\\n        for i in l.values():\\n            res.append(max(i))\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3694884,
                "title": "dfs-most-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<Integer> largestValues(TreeNode root) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        dfs(root, map, 1);\\n        return new ArrayList<>(map.values());\\n    }\\n\\n    public void dfs(TreeNode root, Map<Integer, Integer> map, int cnt) {\\n        if (root == null) {\\n            return;\\n        }\\n        if (!map.containsKey(cnt) || map.get(cnt) < root.val) {\\n            map.put(cnt, root.val);\\n        }\\n        dfs(root.left, map, cnt + 1);\\n        dfs(root.right, map, cnt + 1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<Integer> largestValues(TreeNode root) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        dfs(root, map, 1);\\n        return new ArrayList<>(map.values());\\n    }\\n\\n    public void dfs(TreeNode root, Map<Integer, Integer> map, int cnt) {\\n        if (root == null) {\\n            return;\\n        }\\n        if (!map.containsKey(cnt) || map.get(cnt) < root.val) {\\n            map.put(cnt, root.val);\\n        }\\n        dfs(root.left, map, cnt + 1);\\n        dfs(root.right, map, cnt + 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3440005,
                "title": "simple-bfs-queue-solution-c-96-efficient",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsing the Queue and BFS approach, check at each level which is the highest element and add it to the result list.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIterate the tree via BFS approach using a Queue. While removing the elements from the queue, check at each level which is the highest element and add that highest level element to the result list.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n### Please upvote if you like the approach\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public IList<int> LargestValues(TreeNode root) {\\n        List<int> result = new List<int>();\\n        if (root == null)\\n            return result;\\n        \\n        Queue<TreeNode> pq = new Queue<TreeNode>();\\n        pq.Enqueue(root);\\n        \\n        while (pq.Count > 0)\\n        {\\n            int count = pq.Count;\\n            int max = int.MinValue;\\n            \\n            while (count > 0)\\n            {\\n                TreeNode node = pq.Dequeue();\\n                max = Math.Max(max, node.val);\\n\\n                if (node.left != null)\\n                {\\n                    pq.Enqueue(node.left);\\n                }\\n\\n                if (node.right != null)\\n                {\\n                    pq.Enqueue(node.right);\\n                }\\n                \\n                count--;\\n            }\\n\\n            result.Add(max);\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Tree",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public IList<int> LargestValues(TreeNode root) {\\n        List<int> result = new List<int>();\\n        if (root == null)\\n            return result;\\n        \\n        Queue<TreeNode> pq = new Queue<TreeNode>();\\n        pq.Enqueue(root);\\n        \\n        while (pq.Count > 0)\\n        {\\n            int count = pq.Count;\\n            int max = int.MinValue;\\n            \\n            while (count > 0)\\n            {\\n                TreeNode node = pq.Dequeue();\\n                max = Math.Max(max, node.val);\\n\\n                if (node.left != null)\\n                {\\n                    pq.Enqueue(node.left);\\n                }\\n\\n                if (node.right != null)\\n                {\\n                    pq.Enqueue(node.right);\\n                }\\n                \\n                count--;\\n            }\\n\\n            result.Add(max);\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3385196,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    vector<int> largestValues(TreeNode* root) {\\n        vector<int> ans;\\n        if(!root) return ans;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int maxi = INT_MIN;\\n            int size = q.size();\\n            for(int i = 0; i < size; i++){\\n                TreeNode* node = q.front();\\n                q.pop();\\n                if(node->left != nullptr) q.push(node->left);\\n                if(node->right != nullptr) q.push(node->right);\\n                maxi = max(maxi, node->val);\\n            }\\n            ans.push_back(maxi);  \\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def largestValues(self, root: Optional[TreeNode]) -> List[int]:\\n        if not root:\\n            return []\\n        q = [root]\\n        maxArr = []\\n\\n        while q : \\n           size = len(q)\\n           maxVal = float(\\'-inf\\')           \\n           for i in range(size):\\n                curr = q.pop(0)\\n                maxVal = max(maxVal,curr.val)\\n                if curr.left:\\n                    q.append(curr.left)\\n                if curr.right:\\n                    q.append(curr.right)\\n           maxArr.append(maxVal)\\n        return maxArr\\n```\\n\\n```Java []\\nclass Solution {\\n    static Integer[] largest = new Integer[10_001];\\n    int largestIdx = 0;\\n    \\n    public List<Integer> largestValues(TreeNode root) {\\n        dfs(root, 0);\\n        return Arrays.asList(Arrays.copyOf(largest, largestIdx));\\n    }\\n    private void dfs(TreeNode node, int level) {\\n        if (node == null)  return;\\n        if (level >= largestIdx) {\\n            largestIdx = level + 1;\\n            largest[level] = node.val;\\n        } else\\n            largest[level] = Math.max(largest[level], node.val);\\n        dfs(node.left,  level + 1);\\n        dfs(node.right, level + 1);\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    vector<int> largestValues(TreeNode* root) {\\n        vector<int> ans;\\n        if(!root) return ans;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int maxi = INT_MIN;\\n            int size = q.size();\\n            for(int i = 0; i < size; i++){\\n                TreeNode* node = q.front();\\n                q.pop();\\n                if(node->left != nullptr) q.push(node->left);\\n                if(node->right != nullptr) q.push(node->right);\\n                maxi = max(maxi, node->val);\\n            }\\n            ans.push_back(maxi);  \\n        }\\n        return ans;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def largestValues(self, root: Optional[TreeNode]) -> List[int]:\\n        if not root:\\n            return []\\n        q = [root]\\n        maxArr = []\\n\\n        while q : \\n           size = len(q)\\n           maxVal = float(\\'-inf\\')           \\n           for i in range(size):\\n                curr = q.pop(0)\\n                maxVal = max(maxVal,curr.val)\\n                if curr.left:\\n                    q.append(curr.left)\\n                if curr.right:\\n                    q.append(curr.right)\\n           maxArr.append(maxVal)\\n        return maxArr\\n```\n```Java []\\nclass Solution {\\n    static Integer[] largest = new Integer[10_001];\\n    int largestIdx = 0;\\n    \\n    public List<Integer> largestValues(TreeNode root) {\\n        dfs(root, 0);\\n        return Arrays.asList(Arrays.copyOf(largest, largestIdx));\\n    }\\n    private void dfs(TreeNode node, int level) {\\n        if (node == null)  return;\\n        if (level >= largestIdx) {\\n            largestIdx = level + 1;\\n            largest[level] = node.val;\\n        } else\\n            largest[level] = Math.max(largest[level], node.val);\\n        dfs(node.left,  level + 1);\\n        dfs(node.right, level + 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3352946,
                "title": "python3-dfs-easy-understanding",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def largestValues(self, root: Optional[TreeNode]) -> List[int]:\\n        if not root: return []\\n        a, depth = {}, 0\\n        stack = [(root, depth)]\\n        while stack:\\n            node, depth = stack.pop()\\n            if depth in a and a[depth] < node.val: a[depth] = node.val\\n            if depth not in a: a[depth] = node.val\\n            if node.left: stack.append((node.left, 1 + depth))\\n            if node.right: stack.append((node.right, 1 + depth))\\n        return a.values()\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def largestValues(self, root: Optional[TreeNode]) -> List[int]:\\n        if not root: return []\\n        a, depth = {}, 0\\n        stack = [(root, depth)]\\n        while stack:\\n            node, depth = stack.pop()\\n            if depth in a and a[depth] < node.val: a[depth] = node.val\\n            if depth not in a: a[depth] = node.val\\n            if node.left: stack.append((node.left, 1 + depth))\\n            if node.right: stack.append((node.right, 1 + depth))\\n        return a.values()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3276792,
                "title": "java-easy-solution",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    LinkedList<TreeNode>q=new LinkedList<TreeNode>();\\n    List<Integer>l=new ArrayList<>();\\n    List<Integer>b=new ArrayList<>();\\n    public List<Integer> largestValues(TreeNode root) {\\n        if(root==null)return new ArrayList<>();\\n        level(root);\\n        return l;\\n    }\\n    public void level(TreeNode root)\\n    {\\n        TreeNode p=root;\\n        if(p==null)return;\\n        q.addLast(p);\\n        while(q.isEmpty()==false)\\n        {\\n            int n=q.size();\\n            for(int i=0;i<n;i++)\\n            {\\n                p=q.removeFirst();\\n                b.add(p.val);\\n                \\n                if(p.left!=null)q.addLast(p.left);\\n                if(p.right!=null)q.addLast(p.right);\\n\\n            }\\n            l.add(Collections.max(b));\\n            b=new ArrayList<>();\\n\\n\\n        }\\n    }\\n    \\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    LinkedList<TreeNode>q=new LinkedList<TreeNode>();\\n    List<Integer>l=new ArrayList<>();\\n    List<Integer>b=new ArrayList<>();\\n    public List<Integer> largestValues(TreeNode root) {\\n        if(root==null)return new ArrayList<>();\\n        level(root);\\n        return l;\\n    }\\n    public void level(TreeNode root)\\n    {\\n        TreeNode p=root;\\n        if(p==null)return;\\n        q.addLast(p);\\n        while(q.isEmpty()==false)\\n        {\\n            int n=q.size();\\n            for(int i=0;i<n;i++)\\n            {\\n                p=q.removeFirst();\\n                b.add(p.val);\\n                \\n                if(p.left!=null)q.addLast(p.left);\\n                if(p.right!=null)q.addLast(p.right);\\n\\n            }\\n            l.add(Collections.max(b));\\n            b=new ArrayList<>();\\n\\n\\n        }\\n    }\\n    \\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3244155,
                "title": "direct-bfs-c-short-code",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> largestValues(TreeNode* root) {\\n        queue<TreeNode*>q;\\n        vector<int>ans;\\n        if(!root)return ans;\\n        q.push(root);\\n        while(!q.empty()){\\n            int n=q.size();\\n            int maxi=INT_MIN;\\n            while(n--){\\n                auto node=q.front();\\n                q.pop();\\n                maxi=max(maxi,node->val);\\n                if(node->left)q.push(node->left);\\n                if(node->right)q.push(node->right);\\n            }\\n            ans.push_back(maxi);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> largestValues(TreeNode* root) {\\n        queue<TreeNode*>q;\\n        vector<int>ans;\\n        if(!root)return ans;\\n        q.push(root);\\n        while(!q.empty()){\\n            int n=q.size();\\n            int maxi=INT_MIN;\\n            while(n--){\\n                auto node=q.front();\\n                q.pop();\\n                maxi=max(maxi,node->val);\\n                if(node->left)q.push(node->left);\\n                if(node->right)q.push(node->right);\\n            }\\n            ans.push_back(maxi);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3157774,
                "title": "javascript-solution-bfs-iterative-approach-beats-94-34-easy-to-understand",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number[]}\\n */\\nvar largestValues = function(root) {\\n    if (root === null) return [];\\n\\n    const queue = [[root, 0]], largestValueByLevel = [];\\n    let currNode, currLevel;\\n    while (queue.length > 0){\\n        [currNode, currLevel] = queue.shift();\\n\\n        if (largestValueByLevel[currLevel] === undefined){\\n            largestValueByLevel[currLevel] = currNode.val;\\n        } else {\\n            largestValueByLevel[currLevel] = Math.max(largestValueByLevel[currLevel], currNode.val);\\n        }\\n\\n        if (currNode.left !== null) queue.push([currNode.left, currLevel+1]);\\n        if (currNode.right !== null) queue.push([currNode.right, currLevel+1]);      \\n    }\\n    return largestValueByLevel;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number[]}\\n */\\nvar largestValues = function(root) {\\n    if (root === null) return [];\\n\\n    const queue = [[root, 0]], largestValueByLevel = [];\\n    let currNode, currLevel;\\n    while (queue.length > 0){\\n        [currNode, currLevel] = queue.shift();\\n\\n        if (largestValueByLevel[currLevel] === undefined){\\n            largestValueByLevel[currLevel] = currNode.val;\\n        } else {\\n            largestValueByLevel[currLevel] = Math.max(largestValueByLevel[currLevel], currNode.val);\\n        }\\n\\n        if (currNode.left !== null) queue.push([currNode.left, currLevel+1]);\\n        if (currNode.right !== null) queue.push([currNode.right, currLevel+1]);      \\n    }\\n    return largestValueByLevel;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3017397,
                "title": "simple-clean-and-faster-solution-in-python-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def largestValues(self, root: Optional[TreeNode]) -> List[int]:\\n        self.max = {}\\n        self.find(root,lv=0)\\n        return list(self.max.values())\\n    \\n    def find(self,root,lv):\\n        if root == None:\\n            return\\n        if self.max.get(lv,None)!=None:\\n            self.max[lv] = max(self.max[lv],root.val)\\n        else:\\n            self.max[lv] = root.val\\n        self.find(root.left,lv+1)\\n        self.find(root.right,lv+1)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestValues(self, root: Optional[TreeNode]) -> List[int]:\\n        self.max = {}\\n        self.find(root,lv=0)\\n        return list(self.max.values())\\n    \\n    def find(self,root,lv):\\n        if root == None:\\n            return\\n        if self.max.get(lv,None)!=None:\\n            self.max[lv] = max(self.max[lv],root.val)\\n        else:\\n            self.max[lv] = root.val\\n        self.find(root.left,lv+1)\\n        self.find(root.right,lv+1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2965810,
                "title": "easy-level-order-traversal",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nlevel order traversal\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(width of tree)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> largestValues(TreeNode* root) {\\n        if(root==NULL)return {};\\n        queue<TreeNode*>q;\\n        vector<int>ans;\\n        q.push(root);\\n        \\n        while(!q.empty())\\n        {\\n            int t=INT_MIN;\\n            int n=q.size();\\n            while(n--)\\n            {\\n                TreeNode* c=q.front();\\n                q.pop();\\n                t=max(t,c->val);\\n                if(c->left)\\n                {\\n                    q.push(c->left);\\n                }\\n                if(c->right)\\n                {\\n                    q.push(c->right);\\n                }\\n            }\\n            ans.push_back(t);\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Queue"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> largestValues(TreeNode* root) {\\n        if(root==NULL)return {};\\n        queue<TreeNode*>q;\\n        vector<int>ans;\\n        q.push(root);\\n        \\n        while(!q.empty())\\n        {\\n            int t=INT_MIN;\\n            int n=q.size();\\n            while(n--)\\n            {\\n                TreeNode* c=q.front();\\n                q.pop();\\n                t=max(t,c->val);\\n                if(c->left)\\n                {\\n                    q.push(c->left);\\n                }\\n                if(c->right)\\n                {\\n                    q.push(c->right);\\n                }\\n            }\\n            ans.push_back(t);\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2943042,
                "title": "c-simple-bfs-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> largestValues(TreeNode* root) {\\n        vector<int>ans;\\n        if(!root) return ans;\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int size = q.size();\\n            int temp =q.front()->val;\\n            for(int i=0;i<size;i++){\\n                TreeNode* node = q.front();\\n                q.pop();\\n                temp = max(temp,node->val);\\n                \\n                if(node->left) q.push(node->left);\\n                if(node->right) q.push(node->right);\\n            }\\n            \\n            ans.push_back(temp);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Queue",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> largestValues(TreeNode* root) {\\n        vector<int>ans;\\n        if(!root) return ans;\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int size = q.size();\\n            int temp =q.front()->val;\\n            for(int i=0;i<size;i++){\\n                TreeNode* node = q.front();\\n                q.pop();\\n                temp = max(temp,node->val);\\n                \\n                if(node->left) q.push(node->left);\\n                if(node->right) q.push(node->right);\\n            }\\n            \\n            ans.push_back(temp);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2924316,
                "title": "leetcode-515",
                "content": "\\u4E00\\u822C\\u6765\\u8BF4\\uFF0C\\u4E0D\\u60F3\\u600E\\u4E48\\u5199\\u9898\\u89E3\\uFF0C\\u56E0\\u4E3A\\u4E0D\\u80FD\\u7A77\\u5C3D\\u6240\\u6709\\u7684\\u89E3\\u6CD5\\u3002\\u89E3\\u8FD9\\u4E2A\\u9898\\u8FC7\\u7A0B\\u4E2D\\uFF0C\\u6709\\u4E9B\\u6709\\u610F\\u601D\\u7684\\u5730\\u65B9\\uFF0C\\u987A\\u4FBF\\u5C31\\u8BB0\\u5F55\\u4E00\\u4E0B\\u3002\\u539F\\u9898\\u5728\\u8FD9\\u91CC\\uFF0C\\u6211\\u76F4\\u63A5\\u5199\\u7B54\\u6848\\u4E86\\u3002\\n\\n# bfs\\n\\n\\u7B80\\u5355\\u7684\\u76F4\\u89C9\\uFF0C\\u5C31\\u662F\\u5E7F\\u5EA6\\u4F18\\u5148\\u904D\\u5386\\u3002\\u62FF\\u5230\\u6BCF\\u5C42\\u7684\\u8282\\u70B9\\uFF0C\\u4FDD\\u6301\\u5728\\u6570\\u7EC4\\u91CC\\uFF0C\\u518D\\u6C42\\u51FA\\u6700\\u5927\\u7684\\u503C\\u3002\\n\\n```js\\nvar largestValues = function(root) {\\n    let arr = []\\n    if(!root) return arr\\n    let stack = [root]\\n    while(stack.length) {\\n        let temp = []\\n        let max = -Infinity\\n        while(stack.length) {\\n            let node = stack.pop()\\n            let v = node.val\\n            max = Math.max(v, max)\\n            node.left && temp.push(node.left)\\n            node.right && temp.push(node.right)\\n        }\\n\\n        arr.push(max)\\n\\n        stack = temp\\n    }\\n    \\n    return arr\\n};\\n```\\n\\u63D0\\u4EA4\\u540E\\uFF0C\\u901F\\u5EA6\\u633A\\u6162\\u7684\\uFF0C\\u600E\\u4E48\\u56DE\\u4E8B\\u5462\\uFF1F\\u5148\\u628A\\u8282\\u70B9\\u653E\\u5165\\uFF0C\\u518D\\u62FF\\u51FA\\u6765\\uFF0C\\u76F8\\u5F53\\u4E8E\\u628A\\u6574\\u4E2A\\u6811\\u904D\\u5386\\u4E86 2 \\u6B21\\u3002\\n\\n# dfs\\n\\n\\u6DF1\\u5EA6\\u4F18\\u5148\\u904D\\u5386\\u7684\\u65B9\\u5F0F\\uFF0C\\u6240\\u6709\\u7684\\u8282\\u70B9\\u53EA\\u904D\\u5386\\u4E00\\u6B21\\uFF0C\\u6240\\u4EE5\\u4F1A\\u66F4\\u5FEB\\u4E00\\u70B9\\u3002\\n\\n```js\\nvar largestValues = function(root) {\\n    let arr = []\\n    \\n    function fn(node, i) {\\n        if(!node) return\\n        \\n        arr[i] = Math.max(node.val, arr[i] ?? -Infinity)\\n        \\n        fn(node.left, i + 1)\\n        fn(node.right, i + 1)\\n    }\\n    \\n    fn(root,0)\\n    \\n    return arr\\n}\\n```\\n\\u8FD9\\u4E2A\\u7B54\\u6848\\uFF0C\\u4EE3\\u7801\\u66F4\\u7B80\\u6D01\\uFF0C\\u8FD0\\u884C\\u66F4\\u5FEB\\u3002\\u540C\\u65F6\\u7528\\u5230\\u4E86\\u65B0\\u7684\\u64CD\\u4F5C\\u7B26 ??\\uFF0C\\u662F\\u4E0D\\u662F\\u5F88\\u9177\\u3002\\n\\n\\u6807\\u9898\\uFF1Aleetcode 515 \\u9898\\u89E3\\n\\n\\u5185\\u5BB9\\u6765\\u81EA\\u66FE\\u5C0F\\u4E71\\u7684blog\\uFF1Ahttps://zengxiaoluan.com/leetcode-515/",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```js\\nvar largestValues = function(root) {\\n    let arr = []\\n    if(!root) return arr\\n    let stack = [root]\\n    while(stack.length) {\\n        let temp = []\\n        let max = -Infinity\\n        while(stack.length) {\\n            let node = stack.pop()\\n            let v = node.val\\n            max = Math.max(v, max)\\n            node.left && temp.push(node.left)\\n            node.right && temp.push(node.right)\\n        }\\n\\n        arr.push(max)\\n\\n        stack = temp\\n    }\\n    \\n    return arr\\n};\\n```\n```js\\nvar largestValues = function(root) {\\n    let arr = []\\n    \\n    function fn(node, i) {\\n        if(!node) return\\n        \\n        arr[i] = Math.max(node.val, arr[i] ?? -Infinity)\\n        \\n        fn(node.left, i + 1)\\n        fn(node.right, i + 1)\\n    }\\n    \\n    fn(root,0)\\n    \\n    return arr\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2892184,
                "title": "optimal-code-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> largestValues(TreeNode* root) \\n    {\\n       queue<TreeNode*> q;\\n       vector<int> ans;\\n       q.push(root);\\n       if(root==NULL)\\n       return ans;\\n       while(!q.empty())\\n       {\\n           int loop=q.size();\\n           int maxi=INT_MIN;\\n           while(loop--)\\n           {\\n               TreeNode* node=q.front();\\n               q.pop();\\n               maxi=max(maxi,node->val);\\n               if(node->left!=NULL)\\n               q.push(node->left);\\n               if(node->right!=NULL)\\n               q.push(node->right);\\n           }\\n           ans.push_back(maxi);\\n       }\\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> largestValues(TreeNode* root) \\n    {\\n       queue<TreeNode*> q;\\n       vector<int> ans;\\n       q.push(root);\\n       if(root==NULL)\\n       return ans;\\n       while(!q.empty())\\n       {\\n           int loop=q.size();\\n           int maxi=INT_MIN;\\n           while(loop--)\\n           {\\n               TreeNode* node=q.front();\\n               q.pop();\\n               maxi=max(maxi,node->val);\\n               if(node->left!=NULL)\\n               q.push(node->left);\\n               if(node->right!=NULL)\\n               q.push(node->right);\\n           }\\n           ans.push_back(maxi);\\n       }\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2873648,
                "title": "c-solution",
                "content": "\\t/**\\n\\t * Definition for a binary tree node.\\n\\t * struct TreeNode {\\n\\t *     int val;\\n\\t *     struct TreeNode *left;\\n\\t *     struct TreeNode *right;\\n\\t * };\\n\\t */\\n\\t/**\\n\\t * Note: The returned array must be malloced, assume caller calls free().\\n\\t */\\n\\tint max(int a,int b){\\n\\t\\treturn a>b?a:b;\\n\\t}\\n\\n\\tint maxdepth(struct TreeNode* root){\\n\\t\\tif(!root) return 0;\\n\\t\\tint left=maxdepth(root->left);\\n\\t\\tint right=maxdepth(root->right);\\n\\t\\tint temp=max(left,right);\\n\\t\\treturn temp+1;\\n\\t}\\n\\n\\tvoid findmin(struct TreeNode* root,int *arr,int d,int depth){\\n\\t\\tif(!root || d==depth) return;\\n\\t\\tarr[d]=max(arr[d],root->val);\\n\\t\\tfindmin(root->left,arr,d+1,depth);\\n\\t\\tfindmin(root->right,arr,d+1,depth);\\n\\n\\t}\\n\\n\\tint* largestValues(struct TreeNode* root, int* returnSize){\\n\\t\\tint depth=maxdepth(root);\\n\\t\\tprintf(\"depth : %d\\\\n\",depth);\\n\\t\\tint *arr=(int*)malloc(sizeof(int)*depth);\\n\\t\\tfor(int i=0;i<depth;i++){\\n\\t\\t\\tarr[i]=INT_MIN;\\n\\t\\t}\\n\\t\\t*returnSize=depth;\\n\\t\\tfindmin(root,arr,0,depth);\\n\\t\\treturn arr;\\n\\t}",
                "solutionTags": [
                    "C"
                ],
                "code": "\\t/**\\n\\t * Definition for a binary tree node.\\n\\t * struct TreeNode {\\n\\t *     int val;\\n\\t *     struct TreeNode *left;\\n\\t *     struct TreeNode *right;\\n\\t * };\\n\\t */\\n\\t/**\\n\\t * Note: The returned array must be malloced, assume caller calls free().\\n\\t */\\n\\tint max(int a,int b){\\n\\t\\treturn a>b?a:b;\\n\\t}\\n\\n\\tint maxdepth(struct TreeNode* root){\\n\\t\\tif(!root) return 0;\\n\\t\\tint left=maxdepth(root->left);\\n\\t\\tint right=maxdepth(root->right);\\n\\t\\tint temp=max(left,right);\\n\\t\\treturn temp+1;\\n\\t}\\n\\n\\tvoid findmin(struct TreeNode* root,int *arr,int d,int depth){\\n\\t\\tif(!root || d==depth) return;\\n\\t\\tarr[d]=max(arr[d],root->val);\\n\\t\\tfindmin(root->left,arr,d+1,depth);\\n\\t\\tfindmin(root->right,arr,d+1,depth);\\n\\n\\t}\\n\\n\\tint* largestValues(struct TreeNode* root, int* returnSize){\\n\\t\\tint depth=maxdepth(root);\\n\\t\\tprintf(\"depth : %d\\\\n\",depth);\\n\\t\\tint *arr=(int*)malloc(sizeof(int)*depth);\\n\\t\\tfor(int i=0;i<depth;i++){\\n\\t\\t\\tarr[i]=INT_MIN;\\n\\t\\t}\\n\\t\\t*returnSize=depth;\\n\\t\\tfindmin(root,arr,0,depth);\\n\\t\\treturn arr;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 2821186,
                "title": "c-easy-sol",
                "content": "vector<int> largestValues(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        vector<int>ans;\\n        if(root==NULL)\\n            return ans;\\n        while(!q.empty())\\n        {\\n            int maxi=INT_MIN;\\n            int size=q.size();\\n            while(size--)\\n            {\\n                TreeNode* temp=q.front();\\n                q.pop();\\n                if(temp!=NULL)\\n                {\\n                 if(temp->val>=maxi)\\n                {\\n                    maxi=temp->val;\\n                }\\n                if(temp->left)\\n                q.push(temp->left);\\n                if(temp->right)\\n                q.push(temp->right);   \\n                }\\n                \\n            }\\n            ans.push_back(maxi);\\n        }\\n        return ans;\\n    }",
                "solutionTags": [
                    "C",
                    "Queue"
                ],
                "code": "vector<int> largestValues(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        vector<int>ans;\\n        if(root==NULL)\\n            return ans;\\n        while(!q.empty())\\n        {\\n            int maxi=INT_MIN;\\n            int size=q.size();\\n            while(size--)\\n            {\\n                TreeNode* temp=q.front();\\n                q.pop();\\n                if(temp!=NULL)\\n                {\\n                 if(temp->val>=maxi)\\n                {\\n                    maxi=temp->val;\\n                }\\n                if(temp->left)\\n                q.push(temp->left);\\n                if(temp->right)\\n                q.push(temp->right);   \\n                }\\n                \\n            }\\n            ans.push_back(maxi);\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2809820,
                "title": "easiest-c-solution-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> largestValues(TreeNode* root) {\\n\\n        queue<TreeNode*> Q;\\n        vector<int> MAX;\\n        if(!root)\\n            return MAX;\\n        Q.push(root);\\n        while(!Q.empty())\\n        {\\n            int size=Q.size();\\n            int max=Q.front()->val;\\n            for(int i=0;i<size;i++)\\n            {\\n                TreeNode* Element=Q.front();\\n                if(Element->left)\\n                    Q.push(Element->left);\\n                if(Element->right)\\n                    Q.push(Element->right);\\n                if(max<Element->val)\\n                    max=Element->val;\\n                Q.pop();\\n            }\\n            MAX.push_back(max);\\n        }\\n        return MAX;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> largestValues(TreeNode* root) {\\n\\n        queue<TreeNode*> Q;\\n        vector<int> MAX;\\n        if(!root)\\n            return MAX;\\n        Q.push(root);\\n        while(!Q.empty())\\n        {\\n            int size=Q.size();\\n            int max=Q.front()->val;\\n            for(int i=0;i<size;i++)\\n            {\\n                TreeNode* Element=Q.front();\\n                if(Element->left)\\n                    Q.push(Element->left);\\n                if(Element->right)\\n                    Q.push(Element->right);\\n                if(max<Element->val)\\n                    max=Element->val;\\n                Q.pop();\\n            }\\n            MAX.push_back(max);\\n        }\\n        return MAX;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2802945,
                "title": "99-41-faster-python-solution-using-bfs-traversal",
                "content": "Runtime: 39 ms, faster than 99.41% of Python3 online submissions for Find Largest Value in Each Tree Row.\\nMemory Usage: 16.1 MB, less than 99.94% of Python3 online submissions for Find Largest Value in Each Tree Row.\\n\\nThis is a BFS traversal bases approach, for every level we will iterate through each node value and compare with (-inf) value. in python it\\'s easy to declare negative infinity.  \\n\\n```\\n        if not root:return None\\n        storage = deque([root])\\n        result = []\\n\\n        while storage:\\n            max_val = float(\\'-inf\\')\\n            for item in storage:\\n                if item.val > max_val:max_val = item.val\\n                    \\n            result.append(max_val)\\n           \\n\\n            for _ in range(len(storage)):\\n                catch = storage.popleft()\\n\\n                if catch.left: storage.append(catch.left)\\n                if catch.right:storage.append(catch.right)\\n                    \\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\n        if not root:return None\\n        storage = deque([root])\\n        result = []\\n\\n        while storage:\\n            max_val = float(\\'-inf\\')\\n            for item in storage:\\n                if item.val > max_val:max_val = item.val\\n                    \\n            result.append(max_val)\\n           \\n\\n            for _ in range(len(storage)):\\n                catch = storage.popleft()\\n\\n                if catch.left: storage.append(catch.left)\\n                if catch.right:storage.append(catch.right)\\n                    \\n        return result\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2780958,
                "title": "c-solution-find-largest-value-in-each-tree-row",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> largestValues(TreeNode* root) {\\n        if(root == NULL)\\n            return {};\\n        \\n        queue<TreeNode *> q;\\n        vector<int> ans;\\n        int maxi;\\n        q.push(root);\\n        \\n        while(!q.empty()){\\n            int size = q.size();\\n            maxi = INT_MIN;\\n            \\n            for(int i = 0 ; i < size ; i++){\\n                TreeNode *temp = q.front();\\n                q.pop();\\n                maxi = max(maxi , temp->val);\\n                \\n                if(temp->left)\\n                    q.push(temp->left);\\n                if(temp->right)\\n                    q.push(temp->right);\\n            }\\n            \\n            ans.push_back(maxi);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> largestValues(TreeNode* root) {\\n        if(root == NULL)\\n            return {};\\n        \\n        queue<TreeNode *> q;\\n        vector<int> ans;\\n        int maxi;\\n        q.push(root);\\n        \\n        while(!q.empty()){\\n            int size = q.size();\\n            maxi = INT_MIN;\\n            \\n            for(int i = 0 ; i < size ; i++){\\n                TreeNode *temp = q.front();\\n                q.pop();\\n                maxi = max(maxi , temp->val);\\n                \\n                if(temp->left)\\n                    q.push(temp->left);\\n                if(temp->right)\\n                    q.push(temp->right);\\n            }\\n            \\n            ans.push_back(maxi);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2779806,
                "title": "c-faster-than-all-easy",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n     vector<int> largestValues(TreeNode* root) {\\n        if(root == NULL)return {};\\n        vector<int> ans;\\n        queue<TreeNode*> q;\\n        TreeNode* node;\\n        int n,mx;\\n        q.push(root);\\n        while(!q.empty()){\\n            mx = INT_MIN;\\n            int n = q.size();\\n            while(n--){\\n                node = q.front();q.pop();\\n                mx = max(mx,node->val);\\n                if(node->left){\\n                    q.push(node->left);\\n                }if(node->right){\\n                    q.push(node->right);\\n                }\\n            }\\n            ans.push_back(mx);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n     vector<int> largestValues(TreeNode* root) {\\n        if(root == NULL)return {};\\n        vector<int> ans;\\n        queue<TreeNode*> q;\\n        TreeNode* node;\\n        int n,mx;\\n        q.push(root);\\n        while(!q.empty()){\\n            mx = INT_MIN;\\n            int n = q.size();\\n            while(n--){\\n                node = q.front();q.pop();\\n                mx = max(mx,node->val);\\n                if(node->left){\\n                    q.push(node->left);\\n                }if(node->right){\\n                    q.push(node->right);\\n                }\\n            }\\n            ans.push_back(mx);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2768228,
                "title": "javascript-level-order-traversal-bfs-two-queue-options",
                "content": "**Very basic iterative BFS approach:**\\nOption 1: using an array as a queue (with pop & unshift (O(n))), using for loop for each level: 37% speed.\\n```\\nfunction largestValues (root) {\\n    let ans = [];\\n    if(!root) return ans;\\n    let q = [ root ];\\n    \\n    while(q.length){\\n        let size = q.length;\\n        let max = -Infinity;\\n        for(let i = 0; i < size; i++){\\n            let cur = q.pop();\\n            \\n            max = Math.max(max, cur.val);\\n            \\n            if(cur.left) q.unshift(cur.left);\\n            if(cur.right) q.unshift(cur.right);\\n        }\\n        ans.push(max);\\n    }\\n    return ans;\\n};\\n```\\nOption 2: using JS DS library Queue (O(1) enqueue & dequeue), using while loop for each level: 15% speed...\\n```\\nfunction largestValues (root) {\\n    let ans = [];\\n    if(!root) return ans;\\n    let q = [ root ];\\n    \\n    while(q.length){\\n        let next = [], max = -Infinity;\\n        while(q.length){\\n            let cur = q.pop();\\n            \\n            max = Math.max(max, cur.val);\\n            \\n            if(cur.left) next.unshift(cur.left);\\n            if(cur.right) next.unshift(cur.right);\\n        }\\n        ans.push(max);\\n        q = next;\\n    }\\n    return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction largestValues (root) {\\n    let ans = [];\\n    if(!root) return ans;\\n    let q = [ root ];\\n    \\n    while(q.length){\\n        let size = q.length;\\n        let max = -Infinity;\\n        for(let i = 0; i < size; i++){\\n            let cur = q.pop();\\n            \\n            max = Math.max(max, cur.val);\\n            \\n            if(cur.left) q.unshift(cur.left);\\n            if(cur.right) q.unshift(cur.right);\\n        }\\n        ans.push(max);\\n    }\\n    return ans;\\n};\\n```\n```\\nfunction largestValues (root) {\\n    let ans = [];\\n    if(!root) return ans;\\n    let q = [ root ];\\n    \\n    while(q.length){\\n        let next = [], max = -Infinity;\\n        while(q.length){\\n            let cur = q.pop();\\n            \\n            max = Math.max(max, cur.val);\\n            \\n            if(cur.left) next.unshift(cur.left);\\n            if(cur.right) next.unshift(cur.right);\\n        }\\n        ans.push(max);\\n        q = next;\\n    }\\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2667847,
                "title": "90-time-and-space-beats-c-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> largestValues(TreeNode* root) {\\n        if(root == NULL)return {};\\n        vector<int> ans;\\n        queue<TreeNode*> q;\\n        TreeNode* node;\\n        int n,mx;\\n        q.push(root);\\n        while(!q.empty()){\\n            mx = INT_MIN;\\n            int n = q.size();\\n            while(n--){\\n                node = q.front();q.pop();\\n                mx = max(mx,node->val);\\n                if(node->left){\\n                    q.push(node->left);\\n                }if(node->right){\\n                    q.push(node->right);\\n                }\\n            }\\n            ans.push_back(mx);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> largestValues(TreeNode* root) {\\n        if(root == NULL)return {};\\n        vector<int> ans;\\n        queue<TreeNode*> q;\\n        TreeNode* node;\\n        int n,mx;\\n        q.push(root);\\n        while(!q.empty()){\\n            mx = INT_MIN;\\n            int n = q.size();\\n            while(n--){\\n                node = q.front();q.pop();\\n                mx = max(mx,node->val);\\n                if(node->left){\\n                    q.push(node->left);\\n                }if(node->right){\\n                    q.push(node->right);\\n                }\\n            }\\n            ans.push_back(mx);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2664844,
                "title": "simple-python-dfs-approach",
                "content": "```\\nclass Solution:\\n    def largestValues(self, root: Optional[TreeNode]) -> List[int]:\\n        ans = []\\n        def dfs(st):\\n            m = -inf\\n            new = []\\n            while(st):\\n                x = st.pop()\\n                m = max(m, x.val)\\n                if x.left:\\n                    new.append(x.left)\\n                if x.right:\\n                    new.append(x.right) \\n            ans.append(m)\\n            if new:\\n                dfs(new)\\n            else:\\n                return\\n            \\n        if not root:\\n            return []\\n        dfs([root])\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def largestValues(self, root: Optional[TreeNode]) -> List[int]:\\n        ans = []\\n        def dfs(st):\\n            m = -inf\\n            new = []\\n            while(st):\\n                x = st.pop()\\n                m = max(m, x.val)\\n                if x.left:\\n                    new.append(x.left)\\n                if x.right:\\n                    new.append(x.right) \\n            ans.append(m)\\n            if new:\\n                dfs(new)\\n            else:\\n                return\\n            \\n        if not root:\\n            return []\\n        dfs([root])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2627952,
                "title": "java-very-simple-and-easy-solution",
                "content": "```\\nclass Solution {\\n    public List<Integer> largestValues(TreeNode root) {\\n        if(root ==null){\\n            return new ArrayList<>();\\n        }\\n    ArrayList<Integer> ans = new ArrayList<>();\\n    LinkedList<TreeNode>que = new LinkedList<>();\\n      List<Integer>b = new ArrayList<>();\\n      que.addLast(root);\\n      while(que.size()>0){\\n          int n = que.size();\\n          while(n-->0){\\n              TreeNode node = que.removeFirst();\\n              b.add(node.val);\\n              if(node.left!=null){\\n                  que.addLast(node.left);\\n              } if(node.right!=null){\\n                  que.addLast(node.right);\\n              }\\n              \\n          }\\n          int max =Collections.max(b);\\n              ans.add(max);\\n               b= new ArrayList<>();\\n      }\\n      return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> largestValues(TreeNode root) {\\n        if(root ==null){\\n            return new ArrayList<>();\\n        }\\n    ArrayList<Integer> ans = new ArrayList<>();\\n    LinkedList<TreeNode>que = new LinkedList<>();\\n      List<Integer>b = new ArrayList<>();\\n      que.addLast(root);\\n      while(que.size()>0){\\n          int n = que.size();\\n          while(n-->0){\\n              TreeNode node = que.removeFirst();\\n              b.add(node.val);\\n              if(node.left!=null){\\n                  que.addLast(node.left);\\n              } if(node.right!=null){\\n                  que.addLast(node.right);\\n              }\\n              \\n          }\\n          int max =Collections.max(b);\\n              ans.add(max);\\n               b= new ArrayList<>();\\n      }\\n      return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2579970,
                "title": "java-solution-using-level-order-traversal",
                "content": "Performing the Level Order Traversal of the given tree and finding the maximum element in each tree row.\\n\\n```\\nclass Solution {\\n    public List<Integer> largestValues(TreeNode root)\\n    {\\n        List<Integer> l = new ArrayList<>();\\n        if(root == null)\\n            return l;\\n        \\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.offer(root);\\n        \\n        while(!q.isEmpty())\\n        {\\n            int size = q.size();\\n            int max = Integer.MIN_VALUE;\\n            for(int i=0;i<size;i++)\\n            {\\n                TreeNode p = q.poll();\\n                if(p.left != null)\\n                    q.offer(p.left);\\n                if(p.right != null)\\n                    q.offer(p.right);\\n                max = Math.max(max,p.val);   //Storing the max of each row...\\n            }\\n            l.add(max);\\n        }\\n        \\n        return l;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> largestValues(TreeNode root)\\n    {\\n        List<Integer> l = new ArrayList<>();\\n        if(root == null)\\n            return l;\\n        \\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.offer(root);\\n        \\n        while(!q.isEmpty())\\n        {\\n            int size = q.size();\\n            int max = Integer.MIN_VALUE;\\n            for(int i=0;i<size;i++)\\n            {\\n                TreeNode p = q.poll();\\n                if(p.left != null)\\n                    q.offer(p.left);\\n                if(p.right != null)\\n                    q.offer(p.right);\\n                max = Math.max(max,p.val);   //Storing the max of each row...\\n            }\\n            l.add(max);\\n        }\\n        \\n        return l;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2528864,
                "title": "java-soution-1ms-faster-then-100",
                "content": "```\\nimport java.util.AbstractList;\\n\\nclass Solution {\\n    public List<Integer> largestValues(TreeNode root) {\\n        List<Obj> list = new ArrayList<>(12);\\n        method(root,0,list);\\n        return new MyList(list);\\n    }\\n\\n    public void method(TreeNode node, int level, List<Obj> list) {\\n        if (node == null)\\n            return;\\n        if (level < list.size())\\n            list.get(level).setIfMax(node.val);\\n        else list.add(new Obj(node.val));\\n        method(node.left,level+1,list);\\n        method(node.right,level+1,list);\\n    }\\n\\n    static class MyList extends AbstractList<Integer> {\\n        private final List<Obj> list;\\n\\n        public Integer get(int index) {\\n            return list.get(index).val;\\n        }\\n\\n        public int size() {\\n            return list.size();\\n        }\\n\\n        public MyList(List<Obj> list) {\\n            this.list = list;\\n        }\\n    }\\n\\n    static class Obj {\\n        public int val;\\n\\n        public void setIfMax(int num) {\\n            if (val < num)\\n                val = num;\\n        }\\n\\n        public Obj(int val) {\\n            this.val = val;\\n        }\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.AbstractList;\\n\\nclass Solution {\\n    public List<Integer> largestValues(TreeNode root) {\\n        List<Obj> list = new ArrayList<>(12);\\n        method(root,0,list);\\n        return new MyList(list);\\n    }\\n\\n    public void method(TreeNode node, int level, List<Obj> list) {\\n        if (node == null)\\n            return;\\n        if (level < list.size())\\n            list.get(level).setIfMax(node.val);\\n        else list.add(new Obj(node.val));\\n        method(node.left,level+1,list);\\n        method(node.right,level+1,list);\\n    }\\n\\n    static class MyList extends AbstractList<Integer> {\\n        private final List<Obj> list;\\n\\n        public Integer get(int index) {\\n            return list.get(index).val;\\n        }\\n\\n        public int size() {\\n            return list.size();\\n        }\\n\\n        public MyList(List<Obj> list) {\\n            this.list = list;\\n        }\\n    }\\n\\n    static class Obj {\\n        public int val;\\n\\n        public void setIfMax(int num) {\\n            if (val < num)\\n                val = num;\\n        }\\n\\n        public Obj(int val) {\\n            this.val = val;\\n        }\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2520082,
                "title": "simple-bfs",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> largestValues(TreeNode* root) {\\n        vector<int> ans;\\n        if(!root)return ans;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int size = q.size();\\n            int maxx = INT_MIN ;\\n            for(int i =0 ;i<size;i++){\\n                TreeNode* node = q.front(); q.pop();\\n                maxx = max(maxx, node->val);\\n                if(node->left) q.push(node->left);\\n                if(node->right)q.push(node->right);\\n            }\\n            ans.push_back(maxx);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> largestValues(TreeNode* root) {\\n        vector<int> ans;\\n        if(!root)return ans;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int size = q.size();\\n            int maxx = INT_MIN ;\\n            for(int i =0 ;i<size;i++){\\n                TreeNode* node = q.front(); q.pop();\\n                maxx = max(maxx, node->val);\\n                if(node->left) q.push(node->left);\\n                if(node->right)q.push(node->right);\\n            }\\n            ans.push_back(maxx);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2488472,
                "title": "c-solution-15-ms-faster-than-81-86",
                "content": "~~~\\nvoid value(TreeNode *root,vector<int>&v){\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int high=-2147483648;\\n            int n=q.size();\\n            while(n--){\\n                TreeNode *tree=q.front();\\n                q.pop();\\n                if(tree->val>high)\\n                    high=tree->val;\\n                if(tree->left!=NULL)\\n                    q.push(tree->left);\\n                if(tree->right!=NULL)\\n                    q.push(tree->right); \\n            } \\n            v.push_back(high);\\n        }\\n        return ;\\n    }\\n    vector<int> largestValues(TreeNode* root) {\\n        if(root==NULL)\\n            return {};\\n        vector<int>v;\\n        value(root,v);\\n        return v;\\n    }\\n~~~",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "~~~\\nvoid value(TreeNode *root,vector<int>&v){\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int high=-2147483648;\\n            int n=q.size();\\n            while(n--){\\n                TreeNode *tree=q.front();\\n                q.pop();\\n                if(tree->val>high)\\n                    high=tree->val;\\n                if(tree->left!=NULL)\\n                    q.push(tree->left);\\n                if(tree->right!=NULL)\\n                    q.push(tree->right); \\n            } \\n            v.push_back(high);\\n        }\\n        return ;\\n    }\\n    vector<int> largestValues(TreeNode* root) {\\n        if(root==NULL)\\n            return {};\\n        vector<int>v;\\n        value(root,v);\\n        return v;\\n    }\\n~~~",
                "codeTag": "Unknown"
            },
            {
                "id": 2456301,
                "title": "bfs-level-order-java-commented",
                "content": "\\t/**\\n\\t * Definition for a binary tree node.\\n\\t * public class TreeNode {\\n\\t *     int val;\\n\\t *     TreeNode left;\\n\\t *     TreeNode right;\\n\\t *     TreeNode() {}\\n\\t *     TreeNode(int val) { this.val = val; }\\n\\t *     TreeNode(int val, TreeNode left, TreeNode right) {\\n\\t *         this.val = val;\\n\\t *         this.left = left;\\n\\t *         this.right = right;\\n\\t *     }\\n\\t * }\\n\\t */\\n\\tclass Solution {\\n\\t\\tpublic List<Integer> largestValues(TreeNode root) {\\n\\t\\t\\tList<Integer> ans = new ArrayList<>();\\n\\n\\t\\t\\tif(root == null) return ans;\\n\\n\\t\\t\\t//declare queue for level order traversal\\n\\t\\t\\tQueue<TreeNode> q = new LinkedList<>();\\n\\t\\t\\tq.offer(root);\\n\\n\\t\\t\\t// loop till queue is not empty\\n\\t\\t\\twhile(!q.isEmpty()) {\\n\\t\\t\\t\\tint size = q.size();\\n\\n\\t\\t\\t\\t// store max element for each tree row\\n\\t\\t\\t\\tint max = Integer.MIN_VALUE;\\n\\n\\t\\t\\t\\tfor(int i = 0;i<size;i++) {\\n\\t\\t\\t\\t\\tTreeNode node = q.peek();\\n\\n\\t\\t\\t\\t\\t// if there is left child, add it to the queue\\n\\t\\t\\t\\t\\tif(node.left != null) {\\n\\t\\t\\t\\t\\t\\tq.offer(node.left);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t// if there is right child, add it to the queue\\n\\t\\t\\t\\t\\tif(node.right != null) {\\n\\t\\t\\t\\t\\t\\tq.offer(node.right);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t// check if the curr node value is greater than max, if so update max, keep doing this for all elements\\n\\t\\t\\t\\t\\t// in the row\\n\\t\\t\\t\\t\\tmax = Math.max(max, node.val);\\n\\t\\t\\t\\t\\tq.poll();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// lastly add that max value in the ans list\\n\\t\\t\\t\\tans.add(max);\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "class Solution {\\n\\t\\tpublic List<Integer> largestValues(TreeNode root) {\\n\\t\\t\\tList<Integer> ans = new ArrayList<>();\\n\\n\\t\\t\\tif(root == null) return ans;\\n\\n\\t\\t\\t//declare queue for level order traversal\\n\\t\\t\\tQueue<TreeNode> q = new LinkedList<>();\\n\\t\\t\\tq.offer(root);\\n\\n\\t\\t\\t// loop till queue is not empty\\n\\t\\t\\twhile(!q.isEmpty()) {\\n\\t\\t\\t\\tint size = q.size();\\n\\n\\t\\t\\t\\t// store max element for each tree row\\n\\t\\t\\t\\tint max = Integer.MIN_VALUE;\\n\\n\\t\\t\\t\\tfor(int i = 0;i<size;i++) {\\n\\t\\t\\t\\t\\tTreeNode node = q.peek();\\n\\n\\t\\t\\t\\t\\t// if there is left child, add it to the queue\\n\\t\\t\\t\\t\\tif(node.left != null) {\\n\\t\\t\\t\\t\\t\\tq.offer(node.left);\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2379639,
                "title": "very-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int>res;\\n    vector<int> largestValues(TreeNode* root) {\\n        if(!root) return {};\\n        if(!root->left && !root->right) return {root->val};\\n        TreeNode*temp;\\n        int mx = INT_MIN;\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        \\n        while(!q.empty()){\\n            int sz = q.size();\\n            while(sz--){\\n                temp = q.front();\\n                if(temp->val > mx) mx = temp->val;\\n                q.pop();\\n                if(temp->left) q.push(temp->left);\\n                if(temp->right) q.push(temp->right);\\n            }\\n            res.push_back(mx);\\n            mx = INT_MIN;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>res;\\n    vector<int> largestValues(TreeNode* root) {\\n        if(!root) return {};\\n        if(!root->left && !root->right) return {root->val};\\n        TreeNode*temp;\\n        int mx = INT_MIN;\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        \\n        while(!q.empty()){\\n            int sz = q.size();\\n            while(sz--){\\n                temp = q.front();\\n                if(temp->val > mx) mx = temp->val;\\n                q.pop();\\n                if(temp->left) q.push(temp->left);\\n                if(temp->right) q.push(temp->right);\\n            }\\n            res.push_back(mx);\\n            mx = INT_MIN;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2373160,
                "title": "java-simple-solution",
                "content": "```\\npublic List<Integer> largestValues(TreeNode root) \\n    {\\n        List<Integer> ans= new ArrayList<>();\\n        largest(root , ans , 0);\\n        \\n        return ans;\\n        \\n    }\\n    \\n    private void largest(TreeNode currentnode , List<Integer> ans , int level)\\n    {\\n        if(currentnode == null)\\n            return;\\n        \\n        if(level==ans.size())\\n            ans.add(currentnode.val);\\n        else\\n            ans.set(level , Math.max(ans.get(level) , currentnode.val));\\n        \\n        largest(currentnode.left , ans , level+1);\\n        largest(currentnode.right , ans , level+1);\\n        \\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\npublic List<Integer> largestValues(TreeNode root) \\n    {\\n        List<Integer> ans= new ArrayList<>();\\n        largest(root , ans , 0);\\n        \\n        return ans;\\n        \\n    }\\n    \\n    private void largest(TreeNode currentnode , List<Integer> ans , int level)\\n    {\\n        if(currentnode == null)\\n            return;\\n        \\n        if(level==ans.size())\\n            ans.add(currentnode.val);\\n        else\\n            ans.set(level , Math.max(ans.get(level) , currentnode.val));\\n        \\n        largest(currentnode.left , ans , level+1);\\n        largest(currentnode.right , ans , level+1);\\n        \\n    }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2352573,
                "title": "c-solution-time-o-n-memory-o-h-easy-to-understand-recursion-dfs",
                "content": "```C#\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public IList<int> LargestValues(TreeNode root) {\\n        List<int> ans = new List<int>();\\n        Solve(root, 0);\\n        return ans;\\n        \\n        void Solve(TreeNode node, int depth) {\\n            if (node == null) return;\\n            if (ans.Count <= depth) ans.Add(node.val);\\n            else if (ans[depth] < node.val) ans[depth] = node.val;\\n            \\n            if (node.left != null) Solve(node.left, depth + 1);\\n            if (node.right != null) Solve(node.right, depth + 1);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```C#\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public IList<int> LargestValues(TreeNode root) {\\n        List<int> ans = new List<int>();\\n        Solve(root, 0);\\n        return ans;\\n        \\n        void Solve(TreeNode node, int depth) {\\n            if (node == null) return;\\n            if (ans.Count <= depth) ans.Add(node.val);\\n            else if (ans[depth] < node.val) ans[depth] = node.val;\\n            \\n            if (node.left != null) Solve(node.left, depth + 1);\\n            if (node.right != null) Solve(node.right, depth + 1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2349978,
                "title": "12ms-recursive-c-code-with-explanation",
                "content": "We can simply use the vector itself, to check whether the element present at the present level is the max element or not, With every recursive call we visit a node and we check if we are on the next level, which can be checked by the following \\n\\n```\\nif(ans.size() == level) ans.push_back(root->val);\\n```\\n\\t\\t\\nAnd now to check for the max element at any given level, we can simply use an if statement with the condition that, is the present element greater than the element which is at the ans[level] index. To check we use the following line of code \\n\\n```\\n  if(root->val > ans[level]) ans[level] = root->val;\\n```\\n\\n\\nHere is the complete Solution, Hope I was of help :)\\n\\n```\\nclass Solution {\\n    \\n    private :\\n    vector<int>ans;\\n    \\n    public:\\n    \\n    void f(TreeNode* root, int level){\\n        if(!root) return;\\n        \\n        if(ans.size() == level) ans.push_back(root->val);\\n        if(root->val > ans[level]) ans[level] = root->val;\\n        \\n        f(root->left, level + 1);\\n        f(root->right, level + 1);\\n    }\\n    \\n    \\n    vector<int> largestValues(TreeNode* root) {\\n        if(!root) return ans;\\n        f(root, 0);\\n        return ans;\\n    }\\n    \\n}; \\n```\\n\\t\\t\\n\\t\\t\\n",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nif(ans.size() == level) ans.push_back(root->val);\\n```\n```\\n  if(root->val > ans[level]) ans[level] = root->val;\\n```\n```\\nclass Solution {\\n    \\n    private :\\n    vector<int>ans;\\n    \\n    public:\\n    \\n    void f(TreeNode* root, int level){\\n        if(!root) return;\\n        \\n        if(ans.size() == level) ans.push_back(root->val);\\n        if(root->val > ans[level]) ans[level] = root->val;\\n        \\n        f(root->left, level + 1);\\n        f(root->right, level + 1);\\n    }\\n    \\n    \\n    vector<int> largestValues(TreeNode* root) {\\n        if(!root) return ans;\\n        f(root, 0);\\n        return ans;\\n    }\\n    \\n}; \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2314176,
                "title": "c-solution-dfs-level-order-traversal",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    void bfs(TreeNode* root, queue<TreeNode*> &q, vector<int> &temp)\\n    {\\n        TreeNode* tmp = NULL;\\n        int size = q.size();\\n        for(int i=0; i<size; i++)\\n        {\\n            tmp = q.front();\\n            q.pop();\\n            \\n            if(tmp->left != NULL)\\n            {\\n                q.push(tmp->left);\\n                temp.push_back(tmp->left->val);\\n            }\\n            \\n            if(tmp->right != NULL)\\n            {\\n                q.push(tmp->right);\\n                temp.push_back(tmp->right->val);\\n            }\\n            \\n        }\\n    }\\n    \\n    void level_order(TreeNode* root, vector<vector<int>> &v) {\\n        \\n        if(root == NULL) return;\\n        queue<TreeNode*> q;\\n        vector<int> tmp;\\n        \\n        q.push(root);\\n        tmp.push_back(root->val);\\n        v.push_back(tmp);\\n        tmp.clear();\\n        \\n        while(!q.empty())\\n        {\\n            bfs(root, q, tmp);\\n            if(tmp.size() != 0)\\n            {\\n                v.push_back(tmp);\\n                tmp.clear();\\n            }\\n        }\\n        \\n    }\\n    \\n    vector<int> largestValues(TreeNode* root) {\\n        vector<vector<int>> v;\\n        vector<int> res;\\n        level_order(root, v);\\n        long long int max = -5*2147483648;\\n        \\n        for(int i=0; i<v.size(); i++)\\n        {\\n            for(int j=0; j<v[i].size(); j++)\\n            {\\n                if(max < v[i][j])\\n                {\\n                    max = v[i][j];\\n                }\\n            }\\n            res.push_back((int)max);\\n            max = -5*2147483648;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void bfs(TreeNode* root, queue<TreeNode*> &q, vector<int> &temp)\\n    {\\n        TreeNode* tmp = NULL;\\n        int size = q.size();\\n        for(int i=0; i<size; i++)\\n        {\\n            tmp = q.front();\\n            q.pop();\\n            \\n            if(tmp->left != NULL)\\n            {\\n                q.push(tmp->left);\\n                temp.push_back(tmp->left->val);\\n            }\\n            \\n            if(tmp->right != NULL)\\n            {\\n                q.push(tmp->right);\\n                temp.push_back(tmp->right->val);\\n            }\\n            \\n        }\\n    }\\n    \\n    void level_order(TreeNode* root, vector<vector<int>> &v) {\\n        \\n        if(root == NULL) return;\\n        queue<TreeNode*> q;\\n        vector<int> tmp;\\n        \\n        q.push(root);\\n        tmp.push_back(root->val);\\n        v.push_back(tmp);\\n        tmp.clear();\\n        \\n        while(!q.empty())\\n        {\\n            bfs(root, q, tmp);\\n            if(tmp.size() != 0)\\n            {\\n                v.push_back(tmp);\\n                tmp.clear();\\n            }\\n        }\\n        \\n    }\\n    \\n    vector<int> largestValues(TreeNode* root) {\\n        vector<vector<int>> v;\\n        vector<int> res;\\n        level_order(root, v);\\n        long long int max = -5*2147483648;\\n        \\n        for(int i=0; i<v.size(); i++)\\n        {\\n            for(int j=0; j<v[i].size(); j++)\\n            {\\n                if(max < v[i][j])\\n                {\\n                    max = v[i][j];\\n                }\\n            }\\n            res.push_back((int)max);\\n            max = -5*2147483648;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2282038,
                "title": "bfs-with-queue",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * type TreeNode struct {\\n *     Val int\\n *     Left *TreeNode\\n *     Right *TreeNode\\n * }\\n */\\n\\nfunc largestValues(root *TreeNode) []int {\\n    var res []int\\n    \\n    if root == nil { return res }\\n    \\n    var queue []*TreeNode\\n    queue = append(queue, root)\\n    \\n    for len(queue) > 0 {\\n        length := len(queue)\\n        max := queue[0].Val\\n        \\n        for i := 0; i < length; i++ {\\n            if queue[i].Val > max {\\n                max = queue[i].Val\\n            }\\n            \\n            if queue[i].Left != nil {\\n                queue = append(queue, queue[i].Left)\\n            }\\n            \\n            if queue[i].Right != nil {\\n                queue = append(queue, queue[i].Right)\\n            }\\n        }\\n                \\n        res = append(res, max)\\n        \\n        if length == len(queue) {\\n            break\\n        }\\n        \\n        queue = queue[length:]\\n    }\\n    \\n    return res\\n}\\n\\n```",
                "solutionTags": [
                    "Go",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * type TreeNode struct {\\n *     Val int\\n *     Left *TreeNode\\n *     Right *TreeNode\\n * }\\n */\\n\\nfunc largestValues(root *TreeNode) []int {\\n    var res []int\\n    \\n    if root == nil { return res }\\n    \\n    var queue []*TreeNode\\n    queue = append(queue, root)\\n    \\n    for len(queue) > 0 {\\n        length := len(queue)\\n        max := queue[0].Val\\n        \\n        for i := 0; i < length; i++ {\\n            if queue[i].Val > max {\\n                max = queue[i].Val\\n            }\\n            \\n            if queue[i].Left != nil {\\n                queue = append(queue, queue[i].Left)\\n            }\\n            \\n            if queue[i].Right != nil {\\n                queue = append(queue, queue[i].Right)\\n            }\\n        }\\n                \\n        res = append(res, max)\\n        \\n        if length == len(queue) {\\n            break\\n        }\\n        \\n        queue = queue[length:]\\n    }\\n    \\n    return res\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2276988,
                "title": "c-solution-by-level-order",
                "content": "In this approch , we find out the level order traversal of the tree and store it in a matrix.\\nThen we run a loop in that matrix and keep on finding the max value and store it in the answer vector.\\n\\n```\\nclass Solution {\\npublic:\\n     vector<vector<int>> levelOrder(TreeNode* root) {\\n        vector<vector<int>>v;\\n        if(root==NULL){\\n            return v;\\n        }\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        TreeNode* front;\\n        while(!q.empty()){\\n            int size=q.size();\\n            vector<int>k;\\n            for(int i=0;i<size;i++){\\n                front=q.front();\\n                q.pop();\\n                k.push_back(front->val);\\n                if(front->left)\\n                    q.push(front->left);\\n                if(front->right)\\n                    q.push(front->right);\\n               \\n            }\\n             v.push_back(k);             \\n\\n        }\\n         return v;\\n    }\\n    vector<int> largestValues(TreeNode* root) {\\n        if(root==NULL){\\n            return {};\\n        }\\n        vector<vector<int>>mat;\\n        mat=levelOrder(root);\\n        vector<int>v;\\n        int maxi;\\n        for(int i=0;i<mat.size();i++){\\n            vector<int>x=mat[i];\\n            maxi=*max_element(x.begin(),x.end());\\n            v.push_back(maxi);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Tree",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     vector<vector<int>> levelOrder(TreeNode* root) {\\n        vector<vector<int>>v;\\n        if(root==NULL){\\n            return v;\\n        }\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        TreeNode* front;\\n        while(!q.empty()){\\n            int size=q.size();\\n            vector<int>k;\\n            for(int i=0;i<size;i++){\\n                front=q.front();\\n                q.pop();\\n                k.push_back(front->val);\\n                if(front->left)\\n                    q.push(front->left);\\n                if(front->right)\\n                    q.push(front->right);\\n               \\n            }\\n             v.push_back(k);             \\n\\n        }\\n         return v;\\n    }\\n    vector<int> largestValues(TreeNode* root) {\\n        if(root==NULL){\\n            return {};\\n        }\\n        vector<vector<int>>mat;\\n        mat=levelOrder(root);\\n        vector<int>v;\\n        int maxi;\\n        for(int i=0;i<mat.size();i++){\\n            vector<int>x=mat[i];\\n            maxi=*max_element(x.begin(),x.end());\\n            v.push_back(maxi);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2249817,
                "title": "java-fastest",
                "content": "Please upvote if you like!\\n```\\nclass Solution {\\n    public List<Integer> largestValues(TreeNode root) {\\n        List<Integer> list = new ArrayList();\\n        dfs(root, list, 0);\\n        return list;\\n    }\\n    \\n    public void dfs(TreeNode root, List<Integer> list, int level){\\n        if(root==null) return ;\\n        if(level==list.size()) list.add(root.val);\\n        else list.set(level, Math.max(list.get(level), root.val));\\n        \\n        dfs(root.left, list, level+1);\\n        dfs(root.right, list, level+1);\\n    }\\n}\\n```\\nPlease upvote if you like!",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> largestValues(TreeNode root) {\\n        List<Integer> list = new ArrayList();\\n        dfs(root, list, 0);\\n        return list;\\n    }\\n    \\n    public void dfs(TreeNode root, List<Integer> list, int level){\\n        if(root==null) return ;\\n        if(level==list.size()) list.add(root.val);\\n        else list.set(level, Math.max(list.get(level), root.val));\\n        \\n        dfs(root.left, list, level+1);\\n        dfs(root.right, list, level+1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2216703,
                "title": "java-100-speed-95-memory-with-comments",
                "content": "Please comment if you have any question!\\nPlease **Upvote** if this helps!\\n```\\nclass Solution {\\n    public List<Integer> largestValues(TreeNode root) {\\n        List<Integer> result = new ArrayList<>();\\n        if (root == null) {\\n            return result;\\n        }\\n        search(root, 0, result);\\n        return result;\\n    }\\n\\n    public static void search(TreeNode root, int depth, List<Integer> result) {\\n        if (root == null) {\\n            return;\\n        }\\n        if (depth >= result.size()) { // if this row of the tree has not been visited yet\\n            result.add(root.val); // add the value\\n        } else { // if this row has been visited already\\n            int cur = result.get(depth); // get the previous max value of the row\\n            int big = Math.max(cur, root.val); // compare\\n            if (cur != big) { // if the node we are visiting now has the max value\\n                result.remove(depth); // remove the previous\\n                result.add(depth, big); // add the max\\n            }\\n            \\n        }\\n        search(root.left, depth+1, result); // search left and right (the order does not matter)\\n        search(root.right, depth+1, result);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> largestValues(TreeNode root) {\\n        List<Integer> result = new ArrayList<>();\\n        if (root == null) {\\n            return result;\\n        }\\n        search(root, 0, result);\\n        return result;\\n    }\\n\\n    public static void search(TreeNode root, int depth, List<Integer> result) {\\n        if (root == null) {\\n            return;\\n        }\\n        if (depth >= result.size()) { // if this row of the tree has not been visited yet\\n            result.add(root.val); // add the value\\n        } else { // if this row has been visited already\\n            int cur = result.get(depth); // get the previous max value of the row\\n            int big = Math.max(cur, root.val); // compare\\n            if (cur != big) { // if the node we are visiting now has the max value\\n                result.remove(depth); // remove the previous\\n                result.add(depth, big); // add the max\\n            }\\n            \\n        }\\n        search(root.left, depth+1, result); // search left and right (the order does not matter)\\n        search(root.right, depth+1, result);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2164397,
                "title": "both-bfs-dfs-java-solution",
                "content": "Code is quite self-explanatory.\\n```\\nclass Solution {\\n    public List<Integer> largestValues(TreeNode root) {\\n        List<Integer> res = new ArrayList<>();\\n        //bfs(res,root);\\n        dfs(res, root, 0);\\n        return res;\\n    }\\n    private void dfs(List<Integer> list, TreeNode node, int level){\\n        if(node == null) return;\\n        if(list.size() == level) list.add(node.val);\\n        if(list.get(level) < node.val){\\n            list.set(level, node.val);\\n        }\\n        dfs(list, node.left, level+1);\\n        dfs(list, node.right, level+1);\\n    }\\n    private void bfs(List<Integer> list, TreeNode root){\\n        if(root == null) return;\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.offer(root);\\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            int max = Integer.MIN_VALUE;\\n            for(int i = 0; i < size; i++){\\n                TreeNode node = queue.remove();\\n                max = Math.max(max, node.val);\\n                if(node.left != null) queue.offer(node.left);\\n                if(node.right != null) queue.offer(node.right);\\n            }\\n            list.add(max);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> largestValues(TreeNode root) {\\n        List<Integer> res = new ArrayList<>();\\n        //bfs(res,root);\\n        dfs(res, root, 0);\\n        return res;\\n    }\\n    private void dfs(List<Integer> list, TreeNode node, int level){\\n        if(node == null) return;\\n        if(list.size() == level) list.add(node.val);\\n        if(list.get(level) < node.val){\\n            list.set(level, node.val);\\n        }\\n        dfs(list, node.left, level+1);\\n        dfs(list, node.right, level+1);\\n    }\\n    private void bfs(List<Integer> list, TreeNode root){\\n        if(root == null) return;\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.offer(root);\\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            int max = Integer.MIN_VALUE;\\n            for(int i = 0; i < size; i++){\\n                TreeNode node = queue.remove();\\n                max = Math.max(max, node.val);\\n                if(node.left != null) queue.offer(node.left);\\n                if(node.right != null) queue.offer(node.right);\\n            }\\n            list.add(max);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2162123,
                "title": "python3-o-n-o-n",
                "content": "O(N) || O(h) where n is the number of nodes present in the tree, and h is the height of the tree.\\nO(h) in average or best case, O(n) in worse\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n# 74ms 40.12%\\n    def largestValues(self, root: Optional[TreeNode]) -> List[int]:\\n        if not root:\\n            return []\\n        \\n        queue = [root]\\n        result = []\\n        \\n        while queue:\\n            maximumNum = float(\\'-inf\\')\\n            \\n            for i in range(len(queue)):\\n                node = queue.pop(0)\\n                maximumNum = max(maximumNum, node.val)\\n                if node.left:\\n                    queue.append(node.left)\\n                if node.right:\\n                    queue.append(node.right)\\n                    \\n            \\n            result.append(maximumNum)\\n            \\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Tree",
                    "Breadth-First Search"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n# 74ms 40.12%\\n    def largestValues(self, root: Optional[TreeNode]) -> List[int]:\\n        if not root:\\n            return []\\n        \\n        queue = [root]\\n        result = []\\n        \\n        while queue:\\n            maximumNum = float(\\'-inf\\')\\n            \\n            for i in range(len(queue)):\\n                node = queue.pop(0)\\n                maximumNum = max(maximumNum, node.val)\\n                if node.left:\\n                    queue.append(node.left)\\n                if node.right:\\n                    queue.append(node.right)\\n                    \\n            \\n            result.append(maximumNum)\\n            \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2137957,
                "title": "bfs-solution-using-priority-queue",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    vector<int> largestValues(TreeNode* root) {\\n        vector<int> ans;\\n        if(!root)return ans;\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        while(q.size()){\\n            int n = q.size();\\n            priority_queue<int>pq;\\n            for(int i =0;i<n;i++){\\n                TreeNode* curr = q.front();\\n                q.pop();\\n                pq.push(curr->val);\\n                if(curr->left)q.push(curr->left);\\n                if(curr->right)q.push(curr->right);\\n            }\\n            ans.push_back(pq.top());\\n        }\\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> largestValues(TreeNode* root) {\\n        vector<int> ans;\\n        if(!root)return ans;\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        while(q.size()){\\n            int n = q.size();\\n            priority_queue<int>pq;\\n            for(int i =0;i<n;i++){\\n                TreeNode* curr = q.front();\\n                q.pop();\\n                pq.push(curr->val);\\n                if(curr->left)q.push(curr->left);\\n                if(curr->right)q.push(curr->right);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2110697,
                "title": "using-a-queue-optimal-solution",
                "content": "```\\n#include<bits/stdc++.h>\\nclass Solution {\\npublic:\\n    vector<int> largestValues(TreeNode* root) {\\n        vector<int> res;\\n        if(root==NULL) return res;\\n        int levelmax=INT_MIN;\\n        queue<TreeNode*> que;\\n        que.push(root);\\n        que.push(NULL);\\n        while(!que.empty())\\n        {\\n            if(que.front()==NULL)\\n            {\\n                res.push_back(levelmax);\\n                que.pop();\\n                if(que.size()==0)\\n                {\\n                    break;\\n                }\\n                que.push(NULL);\\n                levelmax=INT_MIN;\\n            }\\n            TreeNode*frontt=que.front();\\n            que.pop();\\n            levelmax=max(levelmax,frontt->val);\\n            if(frontt->left) que.push(frontt->left);\\n            if(frontt->right) que.push(frontt->right); \\n        }\\n        return res;   \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#include<bits/stdc++.h>\\nclass Solution {\\npublic:\\n    vector<int> largestValues(TreeNode* root) {\\n        vector<int> res;\\n        if(root==NULL) return res;\\n        int levelmax=INT_MIN;\\n        queue<TreeNode*> que;\\n        que.push(root);\\n        que.push(NULL);\\n        while(!que.empty())\\n        {\\n            if(que.front()==NULL)\\n            {\\n                res.push_back(levelmax);\\n                que.pop();\\n                if(que.size()==0)\\n                {\\n                    break;\\n                }\\n                que.push(NULL);\\n                levelmax=INT_MIN;\\n            }\\n            TreeNode*frontt=que.front();\\n            que.pop();\\n            levelmax=max(levelmax,frontt->val);\\n            if(frontt->left) que.push(frontt->left);\\n            if(frontt->right) que.push(frontt->right); \\n        }\\n        return res;   \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2082658,
                "title": "c-easy-level-order-traversal",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> largestValues(TreeNode* root) \\n    {\\n        vector<int>ans;\\n        if(root==NULL)\\n        {\\n            return ans;\\n        }\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        while(q.empty()==false)\\n        {\\n            int sz = q.size();\\n            int maxm=INT_MIN;\\n            while(sz--)\\n            {\\n                TreeNode* curr = q.front();\\n                q.pop();\\n                maxm=max(maxm,curr->val);\\n                if(curr->left!=NULL)\\n                {\\n                    q.push(curr->left);\\n                }\\n                if(curr->right!=NULL)\\n                {\\n                    q.push(curr->right);\\n                }\\n            }\\n            ans.push_back(maxm);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> largestValues(TreeNode* root) \\n    {\\n        vector<int>ans;\\n        if(root==NULL)\\n        {\\n            return ans;\\n        }\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        while(q.empty()==false)\\n        {\\n            int sz = q.size();\\n            int maxm=INT_MIN;\\n            while(sz--)\\n            {\\n                TreeNode* curr = q.front();\\n                q.pop();\\n                maxm=max(maxm,curr->val);\\n                if(curr->left!=NULL)\\n                {\\n                    q.push(curr->left);\\n                }\\n                if(curr->right!=NULL)\\n                {\\n                    q.push(curr->right);\\n                }\\n            }\\n            ans.push_back(maxm);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2072144,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public List<Integer> largestValues(TreeNode root) {\\n        List<Integer> l=new ArrayList<>();\\n        if(root==null) return l;\\n        Queue<TreeNode> q=new LinkedList<>();\\n        q.add(root);\\n        while(!q.isEmpty()){\\n            int max=Integer.MIN_VALUE;\\n            int size=q.size();\\n            for(int i=0;i<size;i++){\\n                TreeNode c=q.remove();\\n                max=Math.max(max,c.val);\\n                if(c.left!=null) q.add(c.left);\\n                if(c.right!=null) q.add(c.right);\\n            }\\n            l.add(max);\\n        }\\n        return l;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> largestValues(TreeNode root) {\\n        List<Integer> l=new ArrayList<>();\\n        if(root==null) return l;\\n        Queue<TreeNode> q=new LinkedList<>();\\n        q.add(root);\\n        while(!q.isEmpty()){\\n            int max=Integer.MIN_VALUE;\\n            int size=q.size();\\n            for(int i=0;i<size;i++){\\n                TreeNode c=q.remove();\\n                max=Math.max(max,c.val);\\n                if(c.left!=null) q.add(c.left);\\n                if(c.right!=null) q.add(c.right);\\n            }\\n            l.add(max);\\n        }\\n        return l;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2056074,
                "title": "find-largest-value-in-each-tree-row-c-easy-level-order-traversal",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> largestValues(TreeNode* root) {\\n        vector<int> ans;\\n        if(root == NULL) return ans;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty())\\n        {\\n            int res = INT_MIN;\\n            int sz = q.size();\\n            vector<int> tmp(sz);\\n            for(int i = 0;i<sz;i++)\\n            {\\n                TreeNode *curr = q.front();\\n                q.pop();\\n               res = max(res,curr->val);\\n                if(curr->right)\\n                {\\n                    q.push(curr->right);\\n                }\\n                if(curr->left)\\n                {\\n                    q.push(curr->left);\\n                }\\n            }\\n            ans.push_back(res);\\n        }\\n        return ans;\\n        // vector<int> k(ans.size());\\n        // for(int i = 0;i<ans.size();i++)\\n        // {\\n        //     k[i] = ans[i];\\n        // }\\n        // return k;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> largestValues(TreeNode* root) {\\n        vector<int> ans;\\n        if(root == NULL) return ans;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty())\\n        {\\n            int res = INT_MIN;\\n            int sz = q.size();\\n            vector<int> tmp(sz);\\n            for(int i = 0;i<sz;i++)\\n            {\\n                TreeNode *curr = q.front();\\n                q.pop();\\n               res = max(res,curr->val);\\n                if(curr->right)\\n                {\\n                    q.push(curr->right);\\n                }\\n                if(curr->left)\\n                {\\n                    q.push(curr->left);\\n                }\\n            }\\n            ans.push_back(res);\\n        }\\n        return ans;\\n        // vector<int> k(ans.size());\\n        // for(int i = 0;i<ans.size();i++)\\n        // {\\n        //     k[i] = ans[i];\\n        // }\\n        // return k;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2026988,
                "title": "using-level-order-traversal",
                "content": "```\\nvector<int> largestValues(TreeNode* root) {\\n        vector<int>ans;\\n        int maxi;\\n        if(root == NULL)\\n            return ans;\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        while(!q.empty())\\n        {\\n            int size=q.size();\\n            maxi=INT_MIN;\\n            for(int i=0;i<size;i++)\\n            {\\n                auto x=q.front();\\n                q.pop();\\n                maxi=max(maxi,x->val);\\n                if(x->left!=NULL)\\n                    q.push(x->left);\\n                if(x->right!=NULL)\\n                    q.push(x->right);\\n            }\\n            ans.push_back(maxi);\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nvector<int> largestValues(TreeNode* root) {\\n        vector<int>ans;\\n        int maxi;\\n        if(root == NULL)\\n            return ans;\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        while(!q.empty())\\n        {\\n            int size=q.size();\\n            maxi=INT_MIN;\\n            for(int i=0;i<size;i++)\\n            {\\n                auto x=q.front();\\n                q.pop();\\n                maxi=max(maxi,x->val);\\n                if(x->left!=NULL)\\n                    q.push(x->left);\\n                if(x->right!=NULL)\\n                    q.push(x->right);\\n            }\\n            ans.push_back(maxi);\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1992430,
                "title": "c-easy-level-order-traversal-approach",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> largestValues(TreeNode* root) {\\n        if(!root)\\n            return {};\\n        \\n        queue<TreeNode*>q;\\n        q.push(root);\\n        vector<int>v;\\n        while(!q.empty()){\\n            int s=q.size();\\n            int maxim=INT_MIN;\\n            for(int i=0;i<s;i++){\\n                TreeNode * temp=q.front();\\n                q.pop();\\n                maxim=max(maxim,temp->val);\\n                if(temp->left)\\n                q.push(temp->left);\\n                if(temp->right)\\n                q.push(temp->right);\\n            }\\n            v.push_back(maxim);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> largestValues(TreeNode* root) {\\n        if(!root)\\n            return {};\\n        \\n        queue<TreeNode*>q;\\n        q.push(root);\\n        vector<int>v;\\n        while(!q.empty()){\\n            int s=q.size();\\n            int maxim=INT_MIN;\\n            for(int i=0;i<s;i++){\\n                TreeNode * temp=q.front();\\n                q.pop();\\n                maxim=max(maxim,temp->val);\\n                if(temp->left)\\n                q.push(temp->left);\\n                if(temp->right)\\n                q.push(temp->right);\\n            }\\n            v.push_back(maxim);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1983722,
                "title": "515-simple-c-bfs-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> largestValues(TreeNode* root) {\\n        vector<int> ans;\\n        queue<TreeNode*> q;\\n        if(!root){\\n            return ans;\\n        }\\n        q.push(root);\\n        q.push(nullptr);\\n        int cm=INT_MIN;\\n        while (!q.empty())\\n        {\\n            TreeNode *curr=q.front();\\n            q.pop();\\n            if(!curr){\\n                ans.push_back(cm);\\n                if (!q.empty())\\n                {\\n                    \\n                    cm=INT_MIN;\\n                    q.push(nullptr);\\n\\n                }\\n                \\n                \\n\\n            }\\n            else\\n            {\\n                cm=max(cm,curr->val);\\n                if(curr->left){\\n                    q.push(curr->left);\\n\\n                }\\n                if(curr->right){\\n                    q.push(curr->right);\\n                }\\n            }\\n            \\n            /* code */\\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree",
                    "Breadth-First Search",
                    "Queue",
                    "Binary Tree",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> largestValues(TreeNode* root) {\\n        vector<int> ans;\\n        queue<TreeNode*> q;\\n        if(!root){\\n            return ans;\\n        }\\n        q.push(root);\\n        q.push(nullptr);\\n        int cm=INT_MIN;\\n        while (!q.empty())\\n        {\\n            TreeNode *curr=q.front();\\n            q.pop();\\n            if(!curr){\\n                ans.push_back(cm);\\n                if (!q.empty())\\n                {\\n                    \\n                    cm=INT_MIN;\\n                    q.push(nullptr);\\n\\n                }\\n                \\n                \\n\\n            }\\n            else\\n            {\\n                cm=max(cm,curr->val);\\n                if(curr->left){\\n                    q.push(curr->left);\\n\\n                }\\n                if(curr->right){\\n                    q.push(curr->right);\\n                }\\n            }\\n            \\n            /* code */\\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1912597,
                "title": "python-solution",
                "content": "# class Solution:\\n    def largestValues(self, root: Optional[TreeNode]) -> List[int]:\\n        if not root: return []\\n        ans, lrg = [], -float(\\'inf\\')\\n        queue = [root,\\'null\\']\\n        \\n        while queue:\\n            k = queue.pop(0)\\n            if k == \\'null\\':\\n                ans.append(lrg)\\n                lrg = -float(\\'inf\\')\\n                if not queue: return ans\\n                queue.append(\\'null\\')\\n            else:\\n                if k.val > lrg: lrg = k.val\\n                if k.left: queue.append(k.left)\\n                if k.right: queue.append(k.right)\\n                \\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "# class Solution:\\n    def largestValues(self, root: Optional[TreeNode]) -> List[int]:\\n        if not root: return []\\n        ans, lrg = [], -float(\\'inf\\')\\n        queue = [root,\\'null\\']\\n        \\n        while queue:\\n            k = queue.pop(0)\\n            if k == \\'null\\':\\n                ans.append(lrg)\\n                lrg = -float(\\'inf\\')\\n                if not queue: return ans\\n                queue.append(\\'null\\')\\n            else:\\n                if k.val > lrg: lrg = k.val\\n                if k.left: queue.append(k.left)\\n                if k.right: queue.append(k.right)\\n                \\n",
                "codeTag": "Java"
            },
            {
                "id": 1911121,
                "title": "16ms-cpp-bfs-solution-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> largestValues(TreeNode* root) {\\n    //bfs \\n    //level order traversal\\n        vector<int>res;\\n        if(root==NULL) return res;\\n        queue<TreeNode*>q;\\n        q.push(root);\\n\\n        while(!q.empty()){\\n            int mi=INT_MIN;\\n            int x=q.size();\\n            for(int i=0;i<x;i++){\\n                if(q.front()->val>mi)\\n                    mi=q.front()->val;\\n                if(q.front()->left)\\n                q.push(q.front()->left);\\n\\n                if(q.front()->right)\\n                    q.push(q.front()->right);\\n                q.pop();\\n\\n            }\\n            res.push_back(mi);\\n        }\\n        return res;\\n}\\n\\n};\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> largestValues(TreeNode* root) {\\n    //bfs \\n    //level order traversal\\n        vector<int>res;\\n        if(root==NULL) return res;\\n        queue<TreeNode*>q;\\n        q.push(root);\\n\\n        while(!q.empty()){\\n            int mi=INT_MIN;\\n            int x=q.size();\\n            for(int i=0;i<x;i++){\\n                if(q.front()->val>mi)\\n                    mi=q.front()->val;\\n                if(q.front()->left)\\n                q.push(q.front()->left);\\n\\n                if(q.front()->right)\\n                    q.push(q.front()->right);\\n                q.pop();\\n\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1907996,
                "title": "bfs-simple-iterative-technique-straightforward",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<Integer> largestValues(TreeNode root) {\\n        List<Integer> answer = new ArrayList<>();\\n        \\n        if(root==null)\\n            return answer;\\n        \\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.add(root);\\n        \\n        while(!queue.isEmpty()){\\n            \\n            int size = queue.size();\\n            int largest = Integer.MIN_VALUE;\\n            \\n            for(int i=0;i<size;i++){\\n                \\n                TreeNode node = queue.remove();\\n                largest =Math.max(largest, node.val);\\n                \\n                if(node.left!=null)\\n                    queue.add(node.left);\\n                \\n                if(node.right!=null)\\n                    queue.add(node.right);\\n                \\n            }\\n            \\n            answer.add(largest);\\n        }\\n        \\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Breadth-First Search",
                    "Iterator"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<Integer> largestValues(TreeNode root) {\\n        List<Integer> answer = new ArrayList<>();\\n        \\n        if(root==null)\\n            return answer;\\n        \\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.add(root);\\n        \\n        while(!queue.isEmpty()){\\n            \\n            int size = queue.size();\\n            int largest = Integer.MIN_VALUE;\\n            \\n            for(int i=0;i<size;i++){\\n                \\n                TreeNode node = queue.remove();\\n                largest =Math.max(largest, node.val);\\n                \\n                if(node.left!=null)\\n                    queue.add(node.left);\\n                \\n                if(node.right!=null)\\n                    queue.add(node.right);\\n                \\n            }\\n            \\n            answer.add(largest);\\n        }\\n        \\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1879536,
                "title": "dfs-bfs-approach-simple-python-solution",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def largestValues(self, root: Optional[TreeNode]) -> List[int]:\\n#DFS\\n        if not root:\\n            return []\\n        \\n        def dfs(node,level):\\n            if not node:\\n                return \\n            if level in mp:\\n                if node.val > mp[level]:\\n                    mp[level] = node.val\\n            elif level not in mp:\\n                mp[level] = node.val\\n                \\n            dfs(node.left, level+1)\\n            dfs(node.right, level+1)\\n            \\n        mp = defaultdict()\\n        \\n        dfs(root,1)\\n        \\n        return [v for _,v in mp.items()]\\n    \\n#BFS\\n        if not root:\\n            return []\\n        \\n        q = deque([root])\\n        res = []\\n        \\n        while q:\\n            mx = float(\"-inf\")\\n            n = len(q)\\n            \\n            for i in range(n):\\n                node = q.popleft()\\n                if node.val > mx:\\n                    mx = node.val \\n                if node.left:\\n                    q.append(node.left)\\n                if node.right:\\n                    q.append(node.right)\\n            res.append(mx)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def largestValues(self, root: Optional[TreeNode]) -> List[int]:\\n#DFS\\n        if not root:\\n            return []\\n        \\n        def dfs(node,level):\\n            if not node:\\n                return \\n            if level in mp:\\n                if node.val > mp[level]:\\n                    mp[level] = node.val\\n            elif level not in mp:\\n                mp[level] = node.val\\n                \\n            dfs(node.left, level+1)\\n            dfs(node.right, level+1)\\n            \\n        mp = defaultdict()\\n        \\n        dfs(root,1)\\n        \\n        return [v for _,v in mp.items()]\\n    \\n#BFS\\n        if not root:\\n            return []\\n        \\n        q = deque([root])\\n        res = []\\n        \\n        while q:\\n            mx = float(\"-inf\")\\n            n = len(q)\\n            \\n            for i in range(n):\\n                node = q.popleft()\\n                if node.val > mx:\\n                    mx = node.val \\n                if node.left:\\n                    q.append(node.left)\\n                if node.right:\\n                    q.append(node.right)\\n            res.append(mx)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1795189,
                "title": "c-easy-sol",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    vector<int> largestValues(TreeNode* root) {\\n       vector<int> result;\\n         if(!root)\\n        {\\n            return result;\\n        }\\n        queue<TreeNode*> q;  \\n        q.push(root);\\n        while(!q.empty())\\n        {\\n             int max_ele=INT_MIN;\\n            long count=q.size();\\n            for(int i=0;i<count;i++)\\n            { \\n                TreeNode* top=q.front();\\n                q.pop();\\n                max_ele=max(max_ele,top->val);\\n                if(top->left!=NULL)\\n                {\\n                    q.push(top->left);\\n                }\\n                if(top->right!=NULL)\\n                {\\n                    q.push(top->right);\\n                }\\n                    \\n            }\\n                result.push_back(max_ele);  \\n        }\\n            return result;\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    vector<int> largestValues(TreeNode* root) {\\n       vector<int> result;\\n         if(!root)\\n        {\\n            return result;\\n        }\\n        queue<TreeNode*> q;  \\n        q.push(root);\\n        while(!q.empty())\\n        {\\n             int max_ele=INT_MIN;\\n            long count=q.size();\\n            for(int i=0;i<count;i++)\\n            { \\n                TreeNode* top=q.front();\\n                q.pop();\\n                max_ele=max(max_ele,top->val);\\n                if(top->left!=NULL)\\n                {\\n                    q.push(top->left);\\n                }\\n                if(top->right!=NULL)\\n                {\\n                    q.push(top->right);\\n                }\\n                    \\n            }\\n                result.push_back(max_ele);  \\n        }\\n            return result;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1770438,
                "title": "dfs-variation",
                "content": "**Algorithm**:\\nJust check if that level found before or not.\\nIf found before update maximum everytime.\\nIf level not encountered before then simply assign value.\\nAfter that fetch value from map to vector.\\n\\n# C++\\n     vector<int> largestValues(TreeNode* root) {\\n         vector<int> ans;\\n         map<int,int> mp;\\n         helper(root,mp,0);\\n         for(auto i:mp) ans.push_back(i.second);\\n         return ans;\\n     }\\n    \\n     void helper(TreeNode* root, map<int,int> &mp , int level){    \\n        //Base Case -> Null tree\\n        if(!root) return;\\n        \\n        //now update maximum value in its level key\\n        mp[level]= mp.count(level)==0? root->val : max(mp[level],root->val);\\n        \\n        //call for left and right\\n        helper(root->left,mp,level+1);\\n        helper(root->right,mp,level+1);\\n     }",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "**Algorithm**:\\nJust check if that level found before or not.\\nIf found before update maximum everytime.\\nIf level not encountered before then simply assign value.\\nAfter that fetch value from map to vector.\\n\\n# C++\\n     vector<int> largestValues(TreeNode* root) {\\n         vector<int> ans;\\n         map<int,int> mp;\\n         helper(root,mp,0);\\n         for(auto i:mp) ans.push_back(i.second);\\n         return ans;\\n     }\\n    \\n     void helper(TreeNode* root, map<int,int> &mp , int level){    \\n        //Base Case -> Null tree\\n        if(!root) return;\\n        \\n        //now update maximum value in its level key\\n        mp[level]= mp.count(level)==0? root->val : max(mp[level],root->val);\\n        \\n        //call for left and right\\n        helper(root->left,mp,level+1);\\n        helper(root->right,mp,level+1);\\n     }",
                "codeTag": "Unknown"
            },
            {
                "id": 1764813,
                "title": "c-very-easy-solution-with-explanation",
                "content": "![image](https://assets.leetcode.com/users/images/752cf028-e43a-4cf3-be39-6191b8b87b8f_1644650403.8544376.png)\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> res;\\n    //Geeks for Geeks function for depth of a binary tree\\n    //used this for size of the vector (this will be the number of levels)\\n    int maxDepth(TreeNode* node){\\n        if (node == NULL) return 0;\\n        else{\\n            int lDepth = maxDepth(node->left);\\n            int rDepth = maxDepth(node->right);\\n            if (lDepth > rDepth) return(lDepth + 1);\\n            else return(rDepth + 1);\\n        }\\n    }\\n    //simple depth first traversal\\n    void solve(TreeNode* root, int level){\\n        if(!root) return;\\n        if(level >= res.size()) return;\\n        res[level] = max(res[level], root->val);\\n        solve(root->left, level+1);\\n        solve(root->right, level+1);\\n    }\\n    vector<int> largestValues(TreeNode* root) {\\n        res.resize(maxDepth(root), INT_MIN); //updated the size\\n        solve(root, 0); \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> res;\\n    //Geeks for Geeks function for depth of a binary tree\\n    //used this for size of the vector (this will be the number of levels)\\n    int maxDepth(TreeNode* node){\\n        if (node == NULL) return 0;\\n        else{\\n            int lDepth = maxDepth(node->left);\\n            int rDepth = maxDepth(node->right);\\n            if (lDepth > rDepth) return(lDepth + 1);\\n            else return(rDepth + 1);\\n        }\\n    }\\n    //simple depth first traversal\\n    void solve(TreeNode* root, int level){\\n        if(!root) return;\\n        if(level >= res.size()) return;\\n        res[level] = max(res[level], root->val);\\n        solve(root->left, level+1);\\n        solve(root->right, level+1);\\n    }\\n    vector<int> largestValues(TreeNode* root) {\\n        res.resize(maxDepth(root), INT_MIN); //updated the size\\n        solve(root, 0); \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1758611,
                "title": "java-hashmap-99-faster-simple-solution",
                "content": "```\\nclass Solution {\\n    HashMap<Integer,Integer> map =new HashMap<>();\\n    public List<Integer> largestValues(TreeNode root) {\\n        \\n        get(map,root,0);\\n        \\n        List<Integer> l=new ArrayList<>();\\n        \\n        for(int a : map.keySet()){\\n            l.add(map.get(a));\\n        }\\n        \\n        return l;\\n    }\\n    \\n    public void get(HashMap<Integer,Integer> map,TreeNode root,int level){\\n        if(root==null)return;\\n        \\n        if(!map.containsKey(level)){\\n            map.put(level,root.val);\\n        }else{\\n            if(root.val>map.get(level)){\\n                map.put(level,root.val);\\n            }\\n        }\\n        \\n        get(map,root.left,level+1);\\n        get(map,root.right,level+1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    HashMap<Integer,Integer> map =new HashMap<>();\\n    public List<Integer> largestValues(TreeNode root) {\\n        \\n        get(map,root,0);\\n        \\n        List<Integer> l=new ArrayList<>();\\n        \\n        for(int a : map.keySet()){\\n            l.add(map.get(a));\\n        }\\n        \\n        return l;\\n    }\\n    \\n    public void get(HashMap<Integer,Integer> map,TreeNode root,int level){\\n        if(root==null)return;\\n        \\n        if(!map.containsKey(level)){\\n            map.put(level,root.val);\\n        }else{\\n            if(root.val>map.get(level)){\\n                map.put(level,root.val);\\n            }\\n        }\\n        \\n        get(map,root.left,level+1);\\n        get(map,root.right,level+1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1642095,
                "title": "c-easy-to-understand-level-order-traversal",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> largestValues(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        q.push(NULL);\\n        vector<int> ans;\\n        if(!root)\\n        return ans;\\n        int maxi=INT_MIN;\\n        while(!q.empty())\\n        {\\n            TreeNode* node=q.front();\\n            q.pop();\\n            if(node==NULL)\\n            {\\n                ans.push_back(maxi);\\n                maxi=INT_MIN;\\n                if(!q.empty())\\n                {\\n                    q.push(NULL);\\n                }\\n            }\\n            else\\n            {\\n                maxi=max(maxi,node->val);\\n                if(node->left)\\n                q.push(node->left);\\n                if(node->right)\\n                q.push(node->right);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> largestValues(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        q.push(NULL);\\n        vector<int> ans;\\n        if(!root)\\n        return ans;\\n        int maxi=INT_MIN;\\n        while(!q.empty())\\n        {\\n            TreeNode* node=q.front();\\n            q.pop();\\n            if(node==NULL)\\n            {\\n                ans.push_back(maxi);\\n                maxi=INT_MIN;\\n                if(!q.empty())\\n                {\\n                    q.push(NULL);\\n                }\\n            }\\n            else\\n            {\\n                maxi=max(maxi,node->val);\\n                if(node->left)\\n                q.push(node->left);\\n                if(node->right)\\n                q.push(node->right);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1608414,
                "title": "c-bfs-4ms",
                "content": "**BFS**\\n```\\nclass Solution {\\npublic:\\n    vector<int> largestValues(TreeNode* root) {\\n        vector<int> vec;\\n        if (root == NULL) return vec;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while (!q.empty()) {\\n            int length = q.size();\\n            int num = INT_MIN;\\n            for (int i = 0; i < length; i++) {\\n                TreeNode* now = q.front();\\n                q.pop();\\n                num = max(num, now->val);\\n                if (now->left != NULL) {\\n                    q.push(now->left);\\n                }\\n                if (now->right != NULL) {\\n                    q.push(now->right);\\n                }\\n            }\\n            vec.push_back(num);\\n        }\\n        return vec;\\n    }\\n};\\n```\\n**DFS**\\n```\\nclass Solution {\\npublic:\\n    vector<int> largestValues(TreeNode* root) {\\n        vector<int> ret;\\n        helper(root, 0, ret);\\n        return ret;\\n    }\\n    \\n    void helper(TreeNode* root, int depth, vector<int>& ret) {\\n        if (root == NULL) return;\\n        if (ret.size() < depth + 1) {\\n            ret.push_back(root->val);\\n        } else {\\n            ret[depth] = max(ret[depth], root->val);\\n        }\\n        helper(root->left, depth + 1, ret);\\n        helper(root->right, depth + 1, ret);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> largestValues(TreeNode* root) {\\n        vector<int> vec;\\n        if (root == NULL) return vec;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while (!q.empty()) {\\n            int length = q.size();\\n            int num = INT_MIN;\\n            for (int i = 0; i < length; i++) {\\n                TreeNode* now = q.front();\\n                q.pop();\\n                num = max(num, now->val);\\n                if (now->left != NULL) {\\n                    q.push(now->left);\\n                }\\n                if (now->right != NULL) {\\n                    q.push(now->right);\\n                }\\n            }\\n            vec.push_back(num);\\n        }\\n        return vec;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> largestValues(TreeNode* root) {\\n        vector<int> ret;\\n        helper(root, 0, ret);\\n        return ret;\\n    }\\n    \\n    void helper(TreeNode* root, int depth, vector<int>& ret) {\\n        if (root == NULL) return;\\n        if (ret.size() < depth + 1) {\\n            ret.push_back(root->val);\\n        } else {\\n            ret[depth] = max(ret[depth], root->val);\\n        }\\n        helper(root->left, depth + 1, ret);\\n        helper(root->right, depth + 1, ret);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1604529,
                "title": "java-easy-clean-solution",
                "content": "\\n    public List<Integer> largestValues(TreeNode root) {\\n        List<Integer> ans = new ArrayList<>();\\n        if(root == null) return ans;\\n\\t\\t\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.offer(root);\\n        while(!queue.isEmpty())\\n\\t\\t{\\n            int size = queue.size();\\n            int max = Integer.MIN_VALUE;\\n\\t\\t\\t\\n            for(int i = 0; i  <  size; i++){\\n                TreeNode current = queue.remove();\\n                if(current.val > max)\\n                    max = current.val;\\n                if(current.left != null)\\n                    queue.add(current.left);\\n                if(current.right != null)\\n                    queue.add(current.right);       \\n            }\\n            ans.add(max);\\n        }\\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "\\n    public List<Integer> largestValues(TreeNode root) {\\n        List<Integer> ans = new ArrayList<>();\\n        if(root == null) return ans;\\n\\t\\t\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.offer(root);\\n        while(!queue.isEmpty())\\n\\t\\t{\\n            int size = queue.size();\\n            int max = Integer.MIN_VALUE;\\n\\t\\t\\t\\n            for(int i = 0; i  <  size; i++){\\n                TreeNode current = queue.remove();\\n                if(current.val > max)\\n                    max = current.val;\\n                if(current.left != null)\\n                    queue.add(current.left);\\n                if(current.right != null)\\n                    queue.add(current.right);       \\n            }\\n            ans.add(max);\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1596119,
                "title": "python-dfs",
                "content": "First Solution\\n```\\ndef largestValues(self, root: Optional[TreeNode]) -> List[int]:\\n        dic = {}\\n        def dfs(root,dic,depth):\\n            if not root:\\n                return\\n            depth+=1\\n            if depth not in dic:\\n                dic[depth] = []\\n                dic[depth].append(root.val)\\n            else:\\n                dic[depth].append(root.val)\\n            dfs(root.left,dic,depth) \\n            dfs(root.right,dic,depth) \\n        depth = 0\\n        dfs(root,dic,depth)\\n        out = []\\n        for key in dic:\\n            out.append(max(dic[key]))\\n        return out\\n```\\nSecon Solution (used 1 array instead of 1 dictiornary + 1 array)\\n```\\n    def largestValues(self, root: Optional[TreeNode]) -> List[int]:\\n        out = []\\n        def dfs(root,dic,depth):\\n            if not root:\\n                return\\n            depth+=1\\n            if len(out) == depth:\\n                out.append(root.val)\\n            else:\\n                if out[depth] < root.val:\\n                    out[depth] = root.val\\n            dfs(root.left,dic,depth) \\n            dfs(root.right,dic,depth) \\n        depth = -1\\n        dfs(root,out,depth)\\n        return out\\n```",
                "solutionTags": [],
                "code": "```\\ndef largestValues(self, root: Optional[TreeNode]) -> List[int]:\\n        dic = {}\\n        def dfs(root,dic,depth):\\n            if not root:\\n                return\\n            depth+=1\\n            if depth not in dic:\\n                dic[depth] = []\\n                dic[depth].append(root.val)\\n            else:\\n                dic[depth].append(root.val)\\n            dfs(root.left,dic,depth) \\n            dfs(root.right,dic,depth) \\n        depth = 0\\n        dfs(root,dic,depth)\\n        out = []\\n        for key in dic:\\n            out.append(max(dic[key]))\\n        return out\\n```\n```\\n    def largestValues(self, root: Optional[TreeNode]) -> List[int]:\\n        out = []\\n        def dfs(root,dic,depth):\\n            if not root:\\n                return\\n            depth+=1\\n            if len(out) == depth:\\n                out.append(root.val)\\n            else:\\n                if out[depth] < root.val:\\n                    out[depth] = root.val\\n            dfs(root.left,dic,depth) \\n            dfs(root.right,dic,depth) \\n        depth = -1\\n        dfs(root,out,depth)\\n        return out\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1581763,
                "title": "python-bfs-faster-than-95",
                "content": "```\\nclass Solution:\\n    def averageOfLevels(self, root: Optional[TreeNode]) -> List[float]:\\n        level=0\\n        if not root:\\n            return []\\n\\n        queue = [root]\\n        \\n        \\n        res=[[root.val]]\\n        list2=[]    \\n        list2.append(root.val)\\n        while(len(queue) > 0):\\n       \\n   \\n            list1=[]\\n          \\n \\n            for i in range(len(queue)):\\n                node = queue.pop(0)\\n        \\n                if node.left is not None:\\n                    list1.append(node.left.val)\\n                    queue.append(node.left)\\n\\n                if node.right is not None:\\n                    list1.append(node.right.val)\\n                    queue.append(node.right)\\n            level+=1  \\n          \\n            if list1:\\n                a=len(list1)\\n                list2.append(sum(list1)/a) \\n               \\n            \\n        return list2\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def averageOfLevels(self, root: Optional[TreeNode]) -> List[float]:\\n        level=0\\n        if not root:\\n            return []\\n\\n        queue = [root]\\n        \\n        \\n        res=[[root.val]]\\n        list2=[]    \\n        list2.append(root.val)\\n        while(len(queue) > 0):\\n       \\n   \\n            list1=[]\\n          \\n \\n            for i in range(len(queue)):\\n                node = queue.pop(0)\\n        \\n                if node.left is not None:\\n                    list1.append(node.left.val)\\n                    queue.append(node.left)\\n\\n                if node.right is not None:\\n                    list1.append(node.right.val)\\n                    queue.append(node.right)\\n            level+=1  \\n          \\n            if list1:\\n                a=len(list1)\\n                list2.append(sum(list1)/a) \\n               \\n            \\n        return list2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1568544,
                "title": "c-bfs-queue-99-fast",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> largestValues(TreeNode* root) {\\n        if(root==NULL) return {};\\n        vector<int> ans;\\n        \\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int sz = q.size();\\n            int mx_val=INT_MIN;\\n            for(int i=0;i<sz;i++){\\n                TreeNode* tmp = q.front();\\n                q.pop();\\n                mx_val=max(mx_val,tmp->val);\\n                if(tmp->left) q.push(tmp->left);\\n                if(tmp->right) q.push(tmp->right);\\n            }\\n              ans.push_back(mx_val);\\n        }\\n          return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> largestValues(TreeNode* root) {\\n        if(root==NULL) return {}",
                "codeTag": "Java"
            },
            {
                "id": 1566900,
                "title": "c-find-largest-value-in-each-tree-row-bfs",
                "content": "https://leetcode.com/problems/find-largest-value-in-each-tree-row\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> largestValues(TreeNode* root) {\\n        vector<vector<int> > ans;\\n        queue<TreeNode*> q;\\n        vector<int> res;\\n        if(!root) return res;\\n        q.push(root);\\n        while(!q.empty())\\n        {\\n            int l=q.size();\\n              vector<int> v;\\n            for(int i=0;i<l;i++)\\n            {\\n                TreeNode* temp=q.front();\\n                q.pop();\\n                v.push_back(temp->val);\\n            \\n                if(temp->left)q.push(temp->left);\\n                if(temp->right)q.push(temp->right);\\n            }\\n            ans.push_back(v);\\n            int m=v[0];\\n            for(int i=1;i<v.size();i++)\\n            {\\n                m=max(m,v[i]);\\n            }\\n            res.push_back(m);\\n        }   \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> largestValues(TreeNode* root) {\\n        vector<vector<int> > ans;\\n        queue<TreeNode*> q;\\n        vector<int> res;\\n        if(!root) return res;\\n        q.push(root);\\n        while(!q.empty())\\n        {\\n            int l=q.size();\\n              vector<int> v;\\n            for(int i=0;i<l;i++)\\n            {\\n                TreeNode* temp=q.front();\\n                q.pop();\\n                v.push_back(temp->val);\\n            \\n                if(temp->left)q.push(temp->left);\\n                if(temp->right)q.push(temp->right);\\n            }\\n            ans.push_back(v);\\n            int m=v[0];\\n            for(int i=1;i<v.size();i++)\\n            {\\n                m=max(m,v[i]);\\n            }\\n            res.push_back(m);\\n        }   \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1521397,
                "title": "c-solution-using-map-and-set",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int>result;    \\n    map<int, set<int, greater<int> >> m;\\n    void largest(TreeNode* root, int level){\\n        if(!root){ \\n            return;\\n        }\\n        m[level].insert(root->val);\\n        largest(root->left, level+1);\\n        largest(root->right, level+1);\\n    }\\n    \\n    vector<int> largestValues(TreeNode* root) {\\n        largest(root, 0);\\n        map<int, set<int, greater<int> >>::iterator it;\\n        for(it=m.begin(); it != m.end(); it++){\\n            result.push_back(*it->second.begin());\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>result;    \\n    map<int, set<int, greater<int> >> m;\\n    void largest(TreeNode* root, int level){\\n        if(!root){ \\n            return;\\n        }\\n        m[level].insert(root->val);\\n        largest(root->left, level+1);\\n        largest(root->right, level+1);\\n    }\\n    \\n    vector<int> largestValues(TreeNode* root) {\\n        largest(root, 0);\\n        map<int, set<int, greater<int> >>::iterator it;\\n        for(it=m.begin(); it != m.end(); it++){\\n            result.push_back(*it->second.begin());\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1499978,
                "title": "python-easy-dfs",
                "content": "```\\nclass Solution:\\n    def largestValues(self, root: Optional[TreeNode]) -> List[int]:\\n                \\n                  \\n                  arr=[]\\n                  \\n                  def dfs(root,r=0):\\n                        \\n                        if not root:\\n                            return\\n                        \\n                        if r>=len(arr):\\n                            arr.append(root.val)\\n                        else:\\n                            arr[r]=max(root.val,arr[r])\\n                        \\n                        dfs(root.left,r+1)\\n                        dfs(root.right,r+1)\\n                  \\n                  dfs(root)\\n                  return arr  \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def largestValues(self, root: Optional[TreeNode]) -> List[int]:\\n                \\n                  \\n                  arr=[]\\n                  \\n                  def dfs(root,r=0):\\n                        \\n                        if not root:\\n                            return\\n                        \\n                        if r>=len(arr):\\n                            arr.append(root.val)\\n                        else:\\n                            arr[r]=max(root.val,arr[r])\\n                        \\n                        dfs(root.left,r+1)\\n                        dfs(root.right,r+1)\\n                  \\n                  dfs(root)\\n                  return arr  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1489828,
                "title": "c-easy-to-understand-100",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> v;\\n    vector<int> largestValues(TreeNode* root) {\\n        if(root==NULL)\\n            return v;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int si = q.size();\\n            int maxele = INT_MIN;\\n            while(si--){\\n                TreeNode* temp = q.front();\\n                maxele = max(maxele,temp->val);\\n                q.pop();\\n                if(temp->left)\\n                    q.push(temp->left);\\n                if(temp->right)\\n                    q.push(temp->right);\\n            }\\n            v.push_back(maxele);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> v;\\n    vector<int> largestValues(TreeNode* root) {\\n        if(root==NULL)\\n            return v;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int si = q.size();\\n            int maxele = INT_MIN;\\n            while(si--){\\n                TreeNode* temp = q.front();\\n                maxele = max(maxele,temp->val);\\n                q.pop();\\n                if(temp->left)\\n                    q.push(temp->left);\\n                if(temp->right)\\n                    q.push(temp->right);\\n            }\\n            v.push_back(maxele);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1489827,
                "title": "c-simple-solution-level-order-traversal",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> largestValues(TreeNode* root) {\\n        vector<int>ans;\\n        if(root==nullptr)\\n            return ans;\\n        queue<TreeNode *>q;\\n        q.push(root);\\n        \\n        while(!q.empty())\\n        {\\n             int size=q.size();\\n        \\n          long int max1=LONG_MIN;\\n            while(size--)\\n            {\\n                    TreeNode *tmp=q.front();\\n            q.pop();\\n             if(tmp->val>max1)\\n                 max1=tmp->val;\\n                if(tmp->left)\\n                    q.push(tmp->left);\\n                if(tmp->right)\\n                    q.push(tmp->right);\\n            }\\n            ans.push_back(max1);           \\n         }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> largestValues(TreeNode* root) {\\n        vector<int>ans;\\n        if(root==nullptr)\\n            return ans;\\n        queue<TreeNode *>q;\\n        q.push(root);\\n        \\n        while(!q.empty())\\n        {\\n             int size=q.size();\\n        \\n          long int max1=LONG_MIN;\\n            while(size--)\\n            {\\n                    TreeNode *tmp=q.front();\\n            q.pop();\\n             if(tmp->val>max1)\\n                 max1=tmp->val;\\n                if(tmp->left)\\n                    q.push(tmp->left);\\n                if(tmp->right)\\n                    q.push(tmp->right);\\n            }\\n            ans.push_back(max1);           \\n         }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1484247,
                "title": "python-python3-find-largest-value-in-each-tree-row",
                "content": "***ShamelessSelfPromotion***: My other leetcode [solutions](https://leetcode.com/discuss/general-discussion/1112952/Collection-of-my-leetcode-solution-posts) to various questions can be found [here](https://leetcode.com/discuss/general-discussion/1112952/Collection-of-my-leetcode-solution-posts)\\n\\nAlgorithm:\\n1. Level order traversal and append the max val to final_ans array.\\n2. return that array\\n\\nTime: ```O(N)```\\nSpace: ```O(N)```\\n\\n<iframe src=\"https://leetcode.com/playground/L7Yxb7zd/shared\" frameBorder=\"0\" width=\"700\" height=\"450\"></iframe>",
                "solutionTags": [],
                "code": "```O(N)```\n```O(N)```",
                "codeTag": "Unknown"
            },
            {
                "id": 1476510,
                "title": "3-ms-easy-java-code",
                "content": "**please upvote if this is helpful for you.**\\n```\\nclass Solution {\\n    public List<Integer> largestValues(TreeNode root) {\\n        \\n        if(root == null) {\\n            return new ArrayList<>();\\n        }\\n        List<Integer> li = new ArrayList<>();\\n        \\n        ArrayList<TreeNode> q = new ArrayList<>();\\n        ArrayList<Integer> val = new ArrayList<>();\\n        q.add(root);\\n        val.add(root.val);\\n        \\n        while(q.size()>0) {\\n            \\n            int size = q.size();\\n            li.add(Collections.max(val));\\n            \\n            for(int i=0;i<size;i++) {\\n                TreeNode temp = q.remove(0);\\n                val.remove(0);\\n                \\n                if(temp.left != null) {\\n                    q.add(temp.left);\\n                    val.add(temp.left.val);\\n                }\\n                if(temp.right != null) {\\n                    q.add(temp.right);\\n                    val.add(temp.right.val);\\n                }\\n            }\\n        }\\n        return li;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> largestValues(TreeNode root) {\\n        \\n        if(root == null) {\\n            return new ArrayList<>();\\n        }\\n        List<Integer> li = new ArrayList<>();\\n        \\n        ArrayList<TreeNode> q = new ArrayList<>();\\n        ArrayList<Integer> val = new ArrayList<>();\\n        q.add(root);\\n        val.add(root.val);\\n        \\n        while(q.size()>0) {\\n            \\n            int size = q.size();\\n            li.add(Collections.max(val));\\n            \\n            for(int i=0;i<size;i++) {\\n                TreeNode temp = q.remove(0);\\n                val.remove(0);\\n                \\n                if(temp.left != null) {\\n                    q.add(temp.left);\\n                    val.add(temp.left.val);\\n                }\\n                if(temp.right != null) {\\n                    q.add(temp.right);\\n                    val.add(temp.right.val);\\n                }\\n            }\\n        }\\n        return li;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1445644,
                "title": "0ms-bfs-c",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> largestValues(TreeNode* root) {\\n        vector<int> v;\\n        if(!root) return {};\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int sz = q.size();\\n            int mx=INT_MIN;\\n            for(int i=0;i<sz;i++){\\n                TreeNode* n = q.front();\\n                q.pop();\\n                mx = max(n->val,mx);\\n                if(n->left) q.push(n->left);\\n                if(n->right) q.push(n->right);\\n            }\\n            v.push_back(mx);\\n        }\\n        \\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> largestValues(TreeNode* root) {\\n        vector<int> v;\\n        if(!root) return {};\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int sz = q.size();\\n            int mx=INT_MIN;\\n            for(int i=0;i<sz;i++){\\n                TreeNode* n = q.front();\\n                q.pop();\\n                mx = max(n->val,mx);\\n                if(n->left) q.push(n->left);\\n                if(n->right) q.push(n->right);\\n            }\\n            v.push_back(mx);\\n        }\\n        \\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1406990,
                "title": "515-its-for-you-c-ps-easy",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    vector<int> largestValues(TreeNode* root) {\\n        vector<int> result{};                       //declare the returning variable\\n        \\n        if(!root) return result;                    //if the root is null\\n        \\n        queue<TreeNode*> Q;                         // Queue for BFS traversal\\n        Q.push(root);                               // insert root as the source\\n        \\n        while(!Q.empty()){                          // for each level traversal\\n            \\n            int n = Q.size();                       // number of nodes in the level\\n            int max = INT_MIN;                      // assigning max to the minimum number\\n            \\n            for(int i = 0; i < n; i++){             // loop for each nodes in the level\\n                \\n                TreeNode* node = Q.front();         // current node access\\n                Q.pop();                            // remove from the queue.\\n                \\n                if(node->val >= max)                // this will find the max element in the level\\n                    max = node->val;\\n                \\n                if(node->left)                      // push the left subtree in the queue, concept of BFS\\n                    Q.push(node->left);\\n                if(node->right)                     // push the right subtree in the queue, concept of BFS\\n                    Q.push(node->right);\\n            }\\n            result.push_back(max);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    vector<int> largestValues(TreeNode* root) {\\n        vector<int> result{};                       //declare the returning variable\\n        \\n        if(!root) return result;                    //if the root is null\\n        \\n        queue<TreeNode*> Q;                         // Queue for BFS traversal\\n        Q.push(root);                               // insert root as the source\\n        \\n        while(!Q.empty()){                          // for each level traversal\\n            \\n            int n = Q.size();                       // number of nodes in the level\\n            int max = INT_MIN;                      // assigning max to the minimum number\\n            \\n            for(int i = 0; i < n; i++){             // loop for each nodes in the level\\n                \\n                TreeNode* node = Q.front();         // current node access\\n                Q.pop();                            // remove from the queue.\\n                \\n                if(node->val >= max)                // this will find the max element in the level\\n                    max = node->val;\\n                \\n                if(node->left)                      // push the left subtree in the queue, concept of BFS\\n                    Q.push(node->left);\\n                if(node->right)                     // push the right subtree in the queue, concept of BFS\\n                    Q.push(node->right);\\n            }\\n            result.push_back(max);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1396419,
                "title": "c-solution-using-level-order-traversal",
                "content": "class Solution {\\npublic:\\n    vector<int> largestValues(TreeNode* root) {\\n        \\n        vector<int> v;\\n        if(root==NULL)\\n            return v;\\n        \\n        queue<TreeNode*> q;\\n        q.push(root);\\n        \\n        while(!q.empty())\\n        {\\n            int maxm=INT_MIN;\\n            int n=q.size();\\n            for(int i=0;i<n;i++)\\n            {\\n                TreeNode* temp=q.front();\\n                q.pop();\\n                maxm=max(maxm,temp->val);\\n                \\n                if(temp->left)\\n                    q.push(temp->left);\\n                \\n                if(temp->right)\\n                    q.push(temp->right);\\n            }\\n            v.push_back(maxm);\\n        }\\n        \\n        return v;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> largestValues(TreeNode* root) {\\n        \\n        vector<int> v;\\n        if(root==NULL)\\n            return v;\\n        \\n        queue<TreeNode*> q;\\n        q.push(root);\\n        \\n        while(!q.empty())\\n        {\\n            int maxm=INT_MIN;\\n            int n=q.size();\\n            for(int i=0;i<n;i++)\\n            {\\n                TreeNode* temp=q.front();\\n                q.pop();\\n                maxm=max(maxm,temp->val);\\n                \\n                if(temp->left)\\n                    q.push(temp->left);\\n                \\n                if(temp->right)\\n                    q.push(temp->right);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1391633,
                "title": "c-easy-solution-2-methods-bfs-dfs",
                "content": "METHOD1: BFS\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> largestValues(TreeNode* root) {\\n        if (!root) return {};\\n        vector<int> res;\\n        int maxVal = INT_MIN;\\n        // BFS\\n        queue<TreeNode*> bfs;\\n        bfs.push(root);\\n        bfs.push(NULL);\\n        while (!bfs.empty()) {\\n            auto currNode = bfs.front();\\n            bfs.pop();\\n            if (currNode) {\\n                // ProTip: Don\\'t use root instead of currNode in below lines (common mistake)\\n                maxVal = max(maxVal, currNode->val);\\n                if (currNode->left) bfs.push(currNode->left);\\n                if (currNode->right) bfs.push(currNode->right);\\n            }\\n            else {\\n                res.push_back(maxVal);\\n                maxVal = INT_MIN;\\n                if (!bfs.empty()) bfs.push(NULL);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nMETHOD2: DFS\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> levelMax;\\n    int maxLevel = -1;\\n    int getLevelBT(TreeNode *root) {\\n        if (!root) return 0;\\n        return 1 + max(getLevelBT(root->left), getLevelBT(root->right));\\n    }\\n    void levelMaxValue(TreeNode *root, int level) {\\n        if (!root) return;\\n        levelMax[level] = max(levelMax[level], root->val);\\n        levelMaxValue(root->left, level + 1);\\n        levelMaxValue(root->right, level + 1);\\n    }\\n    vector<int> largestValues(TreeNode* root) {\\n        if (!root) return {};\\n        maxLevel = getLevelBT(root);\\n        levelMax = vector<int> (maxLevel, INT_MIN);\\n        levelMaxValue(root, 0);\\n        vector<int> res;\\n        for (int i = 0; i < maxLevel; i++)\\n            res.push_back(levelMax[i]);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> largestValues(TreeNode* root) {\\n        if (!root) return {};\\n        vector<int> res;\\n        int maxVal = INT_MIN;\\n        // BFS\\n        queue<TreeNode*> bfs;\\n        bfs.push(root);\\n        bfs.push(NULL);\\n        while (!bfs.empty()) {\\n            auto currNode = bfs.front();\\n            bfs.pop();\\n            if (currNode) {\\n                // ProTip: Don\\'t use root instead of currNode in below lines (common mistake)\\n                maxVal = max(maxVal, currNode->val);\\n                if (currNode->left) bfs.push(currNode->left);\\n                if (currNode->right) bfs.push(currNode->right);\\n            }\\n            else {\\n                res.push_back(maxVal);\\n                maxVal = INT_MIN;\\n                if (!bfs.empty()) bfs.push(NULL);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> levelMax;\\n    int maxLevel = -1;\\n    int getLevelBT(TreeNode *root) {\\n        if (!root) return 0;\\n        return 1 + max(getLevelBT(root->left), getLevelBT(root->right));\\n    }\\n    void levelMaxValue(TreeNode *root, int level) {\\n        if (!root) return;\\n        levelMax[level] = max(levelMax[level], root->val);\\n        levelMaxValue(root->left, level + 1);\\n        levelMaxValue(root->right, level + 1);\\n    }\\n    vector<int> largestValues(TreeNode* root) {\\n        if (!root) return {};\\n        maxLevel = getLevelBT(root);\\n        levelMax = vector<int> (maxLevel, INT_MIN);\\n        levelMaxValue(root, 0);\\n        vector<int> res;\\n        for (int i = 0; i < maxLevel; i++)\\n            res.push_back(levelMax[i]);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1354432,
                "title": "3ms-easy-to-understand-java-bfs-solution",
                "content": "\\tpublic List<Integer> largestValues(TreeNode root) {\\n        Queue<TreeNode> q = new LinkedList();\\n        List<Integer> ans = new ArrayList<>();\\n        if(root==null) return ans;\\n        q.offer(root);\\n        while(!q.isEmpty()){\\n            int len = q.size();\\n            List<Integer> temp = new ArrayList<>();\\n            for(int i=0;i<len;i++){\\n                if(q.peek().left!=null) q.offer(q.peek().left);\\n                if(q.peek().right!=null) q.offer(q.peek().right);\\n                temp.add(q.poll().val);\\n            }\\n            ans.add(Collections.max(temp));\\n        }\\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "\\tpublic List<Integer> largestValues(TreeNode root) {\\n        Queue<TreeNode> q = new LinkedList();\\n        List<Integer> ans = new ArrayList<>();\\n        if(root==null) return ans;\\n        q.offer(root);\\n        while(!q.isEmpty()){\\n            int len = q.size();\\n            List<Integer> temp = new ArrayList<>();\\n            for(int i=0;i<len;i++){\\n                if(q.peek().left!=null) q.offer(q.peek().left);\\n                if(q.peek().right!=null) q.offer(q.peek().right);\\n                temp.add(q.poll().val);\\n            }\\n            ans.add(Collections.max(temp));\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1353419,
                "title": "simple-solution-java-0ms",
                "content": "\\nclass Solution {\\n    ArrayList<Integer> max= new ArrayList<Integer>();\\n    int level=0;\\n    \\n    public List<Integer> largestValues(TreeNode root) {\\n        if(root ==null){\\n            return max;\\n        }\\n        largeVal(root, max,level);\\n        return max;\\n    }\\n\\tpublic void largeVal(TreeNode root, ArrayList<Integer> max,int level){\\n        if(root == null){\\n            return;\\n        }\\n       if(level >= max.size()){\\n           max.add(root.val);\\n       }\\n       else{\\n            max.set(level, Math.max(max.get(level),root.val));\\n       }\\n       largeVal(root.left,max,level+1);\\n       largeVal(root.right,max,level+1);\\n    }    \\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    ArrayList<Integer> max= new ArrayList<Integer>();\\n    int level=0;\\n    \\n    public List<Integer> largestValues(TreeNode root) {\\n        if(root ==null){\\n            return max;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1350434,
                "title": "runtime-1-ms-comfortable-java-sol",
                "content": "```\\nclass Solution \\n{\\n    ArrayList<Integer> res = new ArrayList<Integer>();\\n    public List<Integer> largestValues(TreeNode root) \\n    {\\n        if(root==null)\\n            return res;\\n        LinkedList<TreeNode> que = new LinkedList<TreeNode>();\\n        \\n        que.addLast(root);\\n        while(que.size()!=0)\\n        {\\n            int size=que.size();\\n            int max=Integer.MIN_VALUE;\\n            while(size-->0)\\n            {\\n                TreeNode rn = que.removeFirst();\\n                max=Math.max(max,rn.val);\\n                if (rn.left != null)\\n                    que.addLast(rn.left);\\n                if (rn.right != null)\\n                    que.addLast(rn.right);\\n            }\\n            res.add(max);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution \\n{\\n    ArrayList<Integer> res = new ArrayList<Integer>();\\n    public List<Integer> largestValues(TreeNode root) \\n    {\\n        if(root==null)\\n            return res;\\n        LinkedList<TreeNode> que = new LinkedList<TreeNode>();\\n        \\n        que.addLast(root);\\n        while(que.size()!=0)\\n        {\\n            int size=que.size();\\n            int max=Integer.MIN_VALUE;\\n            while(size-->0)\\n            {\\n                TreeNode rn = que.removeFirst();\\n                max=Math.max(max,rn.val);\\n                if (rn.left != null)\\n                    que.addLast(rn.left);\\n                if (rn.right != null)\\n                    que.addLast(rn.right);\\n            }\\n            res.add(max);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1568405,
                "content": [
                    {
                        "username": "VHNRaju",
                        "content": "![image](https://assets.leetcode.com/users/images/438ebdf1-0d61-47f1-ada2-cfe061679331_1595999636.9127004.png)\\n"
                    },
                    {
                        "username": "ajv97",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "utkarsh_v1901",
                        "content": "Why medium?"
                    },
                    {
                        "username": "Limon020",
                        "content": "its a medium, just one of the easier ones"
                    },
                    {
                        "username": "AjayRawat0706",
                        "content": "JAVA SOLUTION 100% fast\n\nclass Solution {\n    public List<Integer> largestValues(TreeNode root) {\n         Queue <TreeNode> q=new LinkedList<>();\n          List<Integer> list=new ArrayList<Integer>(); \n          if(root==null){\n              return list;\n          }\n          q.add(root);\n          \n          while(q.isEmpty()==false){\n              int count=q.size();\n              int curr=Integer.MIN_VALUE;\n              for(int i=0;i<count;i++){\n                  TreeNode temp=q.poll();\n                  curr=Math.max(curr,temp.val);\n                  if(temp.left!=null){\n                      q.add(temp.left);\n                  }\n                   if(temp.right!=null){\n                      q.add(temp.right);\n                  }\n              }\n             list.add(curr);\n          } \n        return list;\n    }\n}"
                    },
                    {
                        "username": "ajv97",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Madian",
                        "content": "Should be marked as Easy not Medium."
                    },
                    {
                        "username": "pengzuo",
                        "content": "still didn\\'t get what is row of tree"
                    },
                    {
                        "username": "ajv97",
                        "content": "Essentially it means the level of the tree. For example, root is the 1st level/row, the children of the root are in 2nd level/row, and the grandchildren are in 3rd level/row and so on."
                    },
                    {
                        "username": "divyanshag2002",
                        "content": "class Solution {\\npublic:\\n    int height (TreeNode * root)\\n    {\\n        if (root == NULL)\\n        {\\n            return 0 ;\\n        }\\n        int left = height (root->left) ;\\n        int right = height (root->right) ;\\n        int ans = max (left , right) + 1 ;\\n        return ans ;\\n    }\\n    void sol (TreeNode * root , int level , vector<int> & ans)\\n    {\\n        if (root == NULL)\\n        {\\n            return ;\\n        }\\n        int ind = level  ;\\n        // store the max no on the index of current height of the node \\n        ans[ind] = max (ans[ind] , root->val) ;\\n        sol (root->left , level + 1 , ans) ;\\n        sol (root->right , level + 1 , ans) ;\\n    }\\n    vector<int> largestValues(TreeNode* root) {\\n        // if the root node is null return null vector\\n        if (!root)\\n        {\\n            return {} ;\\n        }\\n        // make a vector of size height of the tree \\n        int h = height (root) ;\\n\\n        vector<int> ans (h , INT_MIN);\\n        sol (root , 0 , ans) ;\\n        return ans ;\\n    }\\n};"
                    },
                    {
                        "username": "verisimilitude",
                        "content": "Why is this question downvoted?"
                    }
                ]
            },
            {
                "id": 1841987,
                "content": [
                    {
                        "username": "VHNRaju",
                        "content": "![image](https://assets.leetcode.com/users/images/438ebdf1-0d61-47f1-ada2-cfe061679331_1595999636.9127004.png)\\n"
                    },
                    {
                        "username": "ajv97",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "utkarsh_v1901",
                        "content": "Why medium?"
                    },
                    {
                        "username": "Limon020",
                        "content": "its a medium, just one of the easier ones"
                    },
                    {
                        "username": "AjayRawat0706",
                        "content": "JAVA SOLUTION 100% fast\n\nclass Solution {\n    public List<Integer> largestValues(TreeNode root) {\n         Queue <TreeNode> q=new LinkedList<>();\n          List<Integer> list=new ArrayList<Integer>(); \n          if(root==null){\n              return list;\n          }\n          q.add(root);\n          \n          while(q.isEmpty()==false){\n              int count=q.size();\n              int curr=Integer.MIN_VALUE;\n              for(int i=0;i<count;i++){\n                  TreeNode temp=q.poll();\n                  curr=Math.max(curr,temp.val);\n                  if(temp.left!=null){\n                      q.add(temp.left);\n                  }\n                   if(temp.right!=null){\n                      q.add(temp.right);\n                  }\n              }\n             list.add(curr);\n          } \n        return list;\n    }\n}"
                    },
                    {
                        "username": "ajv97",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Madian",
                        "content": "Should be marked as Easy not Medium."
                    },
                    {
                        "username": "pengzuo",
                        "content": "still didn\\'t get what is row of tree"
                    },
                    {
                        "username": "ajv97",
                        "content": "Essentially it means the level of the tree. For example, root is the 1st level/row, the children of the root are in 2nd level/row, and the grandchildren are in 3rd level/row and so on."
                    },
                    {
                        "username": "divyanshag2002",
                        "content": "class Solution {\\npublic:\\n    int height (TreeNode * root)\\n    {\\n        if (root == NULL)\\n        {\\n            return 0 ;\\n        }\\n        int left = height (root->left) ;\\n        int right = height (root->right) ;\\n        int ans = max (left , right) + 1 ;\\n        return ans ;\\n    }\\n    void sol (TreeNode * root , int level , vector<int> & ans)\\n    {\\n        if (root == NULL)\\n        {\\n            return ;\\n        }\\n        int ind = level  ;\\n        // store the max no on the index of current height of the node \\n        ans[ind] = max (ans[ind] , root->val) ;\\n        sol (root->left , level + 1 , ans) ;\\n        sol (root->right , level + 1 , ans) ;\\n    }\\n    vector<int> largestValues(TreeNode* root) {\\n        // if the root node is null return null vector\\n        if (!root)\\n        {\\n            return {} ;\\n        }\\n        // make a vector of size height of the tree \\n        int h = height (root) ;\\n\\n        vector<int> ans (h , INT_MIN);\\n        sol (root , 0 , ans) ;\\n        return ans ;\\n    }\\n};"
                    },
                    {
                        "username": "verisimilitude",
                        "content": "Why is this question downvoted?"
                    }
                ]
            },
            {
                "id": 1745321,
                "content": [
                    {
                        "username": "VHNRaju",
                        "content": "![image](https://assets.leetcode.com/users/images/438ebdf1-0d61-47f1-ada2-cfe061679331_1595999636.9127004.png)\\n"
                    },
                    {
                        "username": "ajv97",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "utkarsh_v1901",
                        "content": "Why medium?"
                    },
                    {
                        "username": "Limon020",
                        "content": "its a medium, just one of the easier ones"
                    },
                    {
                        "username": "AjayRawat0706",
                        "content": "JAVA SOLUTION 100% fast\n\nclass Solution {\n    public List<Integer> largestValues(TreeNode root) {\n         Queue <TreeNode> q=new LinkedList<>();\n          List<Integer> list=new ArrayList<Integer>(); \n          if(root==null){\n              return list;\n          }\n          q.add(root);\n          \n          while(q.isEmpty()==false){\n              int count=q.size();\n              int curr=Integer.MIN_VALUE;\n              for(int i=0;i<count;i++){\n                  TreeNode temp=q.poll();\n                  curr=Math.max(curr,temp.val);\n                  if(temp.left!=null){\n                      q.add(temp.left);\n                  }\n                   if(temp.right!=null){\n                      q.add(temp.right);\n                  }\n              }\n             list.add(curr);\n          } \n        return list;\n    }\n}"
                    },
                    {
                        "username": "ajv97",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Madian",
                        "content": "Should be marked as Easy not Medium."
                    },
                    {
                        "username": "pengzuo",
                        "content": "still didn\\'t get what is row of tree"
                    },
                    {
                        "username": "ajv97",
                        "content": "Essentially it means the level of the tree. For example, root is the 1st level/row, the children of the root are in 2nd level/row, and the grandchildren are in 3rd level/row and so on."
                    },
                    {
                        "username": "divyanshag2002",
                        "content": "class Solution {\\npublic:\\n    int height (TreeNode * root)\\n    {\\n        if (root == NULL)\\n        {\\n            return 0 ;\\n        }\\n        int left = height (root->left) ;\\n        int right = height (root->right) ;\\n        int ans = max (left , right) + 1 ;\\n        return ans ;\\n    }\\n    void sol (TreeNode * root , int level , vector<int> & ans)\\n    {\\n        if (root == NULL)\\n        {\\n            return ;\\n        }\\n        int ind = level  ;\\n        // store the max no on the index of current height of the node \\n        ans[ind] = max (ans[ind] , root->val) ;\\n        sol (root->left , level + 1 , ans) ;\\n        sol (root->right , level + 1 , ans) ;\\n    }\\n    vector<int> largestValues(TreeNode* root) {\\n        // if the root node is null return null vector\\n        if (!root)\\n        {\\n            return {} ;\\n        }\\n        // make a vector of size height of the tree \\n        int h = height (root) ;\\n\\n        vector<int> ans (h , INT_MIN);\\n        sol (root , 0 , ans) ;\\n        return ans ;\\n    }\\n};"
                    },
                    {
                        "username": "verisimilitude",
                        "content": "Why is this question downvoted?"
                    }
                ]
            },
            {
                "id": 2018509,
                "content": [
                    {
                        "username": "VHNRaju",
                        "content": "![image](https://assets.leetcode.com/users/images/438ebdf1-0d61-47f1-ada2-cfe061679331_1595999636.9127004.png)\\n"
                    },
                    {
                        "username": "ajv97",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "utkarsh_v1901",
                        "content": "Why medium?"
                    },
                    {
                        "username": "Limon020",
                        "content": "its a medium, just one of the easier ones"
                    },
                    {
                        "username": "AjayRawat0706",
                        "content": "JAVA SOLUTION 100% fast\n\nclass Solution {\n    public List<Integer> largestValues(TreeNode root) {\n         Queue <TreeNode> q=new LinkedList<>();\n          List<Integer> list=new ArrayList<Integer>(); \n          if(root==null){\n              return list;\n          }\n          q.add(root);\n          \n          while(q.isEmpty()==false){\n              int count=q.size();\n              int curr=Integer.MIN_VALUE;\n              for(int i=0;i<count;i++){\n                  TreeNode temp=q.poll();\n                  curr=Math.max(curr,temp.val);\n                  if(temp.left!=null){\n                      q.add(temp.left);\n                  }\n                   if(temp.right!=null){\n                      q.add(temp.right);\n                  }\n              }\n             list.add(curr);\n          } \n        return list;\n    }\n}"
                    },
                    {
                        "username": "ajv97",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Madian",
                        "content": "Should be marked as Easy not Medium."
                    },
                    {
                        "username": "pengzuo",
                        "content": "still didn\\'t get what is row of tree"
                    },
                    {
                        "username": "ajv97",
                        "content": "Essentially it means the level of the tree. For example, root is the 1st level/row, the children of the root are in 2nd level/row, and the grandchildren are in 3rd level/row and so on."
                    },
                    {
                        "username": "divyanshag2002",
                        "content": "class Solution {\\npublic:\\n    int height (TreeNode * root)\\n    {\\n        if (root == NULL)\\n        {\\n            return 0 ;\\n        }\\n        int left = height (root->left) ;\\n        int right = height (root->right) ;\\n        int ans = max (left , right) + 1 ;\\n        return ans ;\\n    }\\n    void sol (TreeNode * root , int level , vector<int> & ans)\\n    {\\n        if (root == NULL)\\n        {\\n            return ;\\n        }\\n        int ind = level  ;\\n        // store the max no on the index of current height of the node \\n        ans[ind] = max (ans[ind] , root->val) ;\\n        sol (root->left , level + 1 , ans) ;\\n        sol (root->right , level + 1 , ans) ;\\n    }\\n    vector<int> largestValues(TreeNode* root) {\\n        // if the root node is null return null vector\\n        if (!root)\\n        {\\n            return {} ;\\n        }\\n        // make a vector of size height of the tree \\n        int h = height (root) ;\\n\\n        vector<int> ans (h , INT_MIN);\\n        sol (root , 0 , ans) ;\\n        return ans ;\\n    }\\n};"
                    },
                    {
                        "username": "verisimilitude",
                        "content": "Why is this question downvoted?"
                    }
                ]
            },
            {
                "id": 1975426,
                "content": [
                    {
                        "username": "VHNRaju",
                        "content": "![image](https://assets.leetcode.com/users/images/438ebdf1-0d61-47f1-ada2-cfe061679331_1595999636.9127004.png)\\n"
                    },
                    {
                        "username": "ajv97",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "utkarsh_v1901",
                        "content": "Why medium?"
                    },
                    {
                        "username": "Limon020",
                        "content": "its a medium, just one of the easier ones"
                    },
                    {
                        "username": "AjayRawat0706",
                        "content": "JAVA SOLUTION 100% fast\n\nclass Solution {\n    public List<Integer> largestValues(TreeNode root) {\n         Queue <TreeNode> q=new LinkedList<>();\n          List<Integer> list=new ArrayList<Integer>(); \n          if(root==null){\n              return list;\n          }\n          q.add(root);\n          \n          while(q.isEmpty()==false){\n              int count=q.size();\n              int curr=Integer.MIN_VALUE;\n              for(int i=0;i<count;i++){\n                  TreeNode temp=q.poll();\n                  curr=Math.max(curr,temp.val);\n                  if(temp.left!=null){\n                      q.add(temp.left);\n                  }\n                   if(temp.right!=null){\n                      q.add(temp.right);\n                  }\n              }\n             list.add(curr);\n          } \n        return list;\n    }\n}"
                    },
                    {
                        "username": "ajv97",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Madian",
                        "content": "Should be marked as Easy not Medium."
                    },
                    {
                        "username": "pengzuo",
                        "content": "still didn\\'t get what is row of tree"
                    },
                    {
                        "username": "ajv97",
                        "content": "Essentially it means the level of the tree. For example, root is the 1st level/row, the children of the root are in 2nd level/row, and the grandchildren are in 3rd level/row and so on."
                    },
                    {
                        "username": "divyanshag2002",
                        "content": "class Solution {\\npublic:\\n    int height (TreeNode * root)\\n    {\\n        if (root == NULL)\\n        {\\n            return 0 ;\\n        }\\n        int left = height (root->left) ;\\n        int right = height (root->right) ;\\n        int ans = max (left , right) + 1 ;\\n        return ans ;\\n    }\\n    void sol (TreeNode * root , int level , vector<int> & ans)\\n    {\\n        if (root == NULL)\\n        {\\n            return ;\\n        }\\n        int ind = level  ;\\n        // store the max no on the index of current height of the node \\n        ans[ind] = max (ans[ind] , root->val) ;\\n        sol (root->left , level + 1 , ans) ;\\n        sol (root->right , level + 1 , ans) ;\\n    }\\n    vector<int> largestValues(TreeNode* root) {\\n        // if the root node is null return null vector\\n        if (!root)\\n        {\\n            return {} ;\\n        }\\n        // make a vector of size height of the tree \\n        int h = height (root) ;\\n\\n        vector<int> ans (h , INT_MIN);\\n        sol (root , 0 , ans) ;\\n        return ans ;\\n    }\\n};"
                    },
                    {
                        "username": "verisimilitude",
                        "content": "Why is this question downvoted?"
                    }
                ]
            },
            {
                "id": 1720390,
                "content": [
                    {
                        "username": "VHNRaju",
                        "content": "![image](https://assets.leetcode.com/users/images/438ebdf1-0d61-47f1-ada2-cfe061679331_1595999636.9127004.png)\\n"
                    },
                    {
                        "username": "ajv97",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "utkarsh_v1901",
                        "content": "Why medium?"
                    },
                    {
                        "username": "Limon020",
                        "content": "its a medium, just one of the easier ones"
                    },
                    {
                        "username": "AjayRawat0706",
                        "content": "JAVA SOLUTION 100% fast\n\nclass Solution {\n    public List<Integer> largestValues(TreeNode root) {\n         Queue <TreeNode> q=new LinkedList<>();\n          List<Integer> list=new ArrayList<Integer>(); \n          if(root==null){\n              return list;\n          }\n          q.add(root);\n          \n          while(q.isEmpty()==false){\n              int count=q.size();\n              int curr=Integer.MIN_VALUE;\n              for(int i=0;i<count;i++){\n                  TreeNode temp=q.poll();\n                  curr=Math.max(curr,temp.val);\n                  if(temp.left!=null){\n                      q.add(temp.left);\n                  }\n                   if(temp.right!=null){\n                      q.add(temp.right);\n                  }\n              }\n             list.add(curr);\n          } \n        return list;\n    }\n}"
                    },
                    {
                        "username": "ajv97",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Madian",
                        "content": "Should be marked as Easy not Medium."
                    },
                    {
                        "username": "pengzuo",
                        "content": "still didn\\'t get what is row of tree"
                    },
                    {
                        "username": "ajv97",
                        "content": "Essentially it means the level of the tree. For example, root is the 1st level/row, the children of the root are in 2nd level/row, and the grandchildren are in 3rd level/row and so on."
                    },
                    {
                        "username": "divyanshag2002",
                        "content": "class Solution {\\npublic:\\n    int height (TreeNode * root)\\n    {\\n        if (root == NULL)\\n        {\\n            return 0 ;\\n        }\\n        int left = height (root->left) ;\\n        int right = height (root->right) ;\\n        int ans = max (left , right) + 1 ;\\n        return ans ;\\n    }\\n    void sol (TreeNode * root , int level , vector<int> & ans)\\n    {\\n        if (root == NULL)\\n        {\\n            return ;\\n        }\\n        int ind = level  ;\\n        // store the max no on the index of current height of the node \\n        ans[ind] = max (ans[ind] , root->val) ;\\n        sol (root->left , level + 1 , ans) ;\\n        sol (root->right , level + 1 , ans) ;\\n    }\\n    vector<int> largestValues(TreeNode* root) {\\n        // if the root node is null return null vector\\n        if (!root)\\n        {\\n            return {} ;\\n        }\\n        // make a vector of size height of the tree \\n        int h = height (root) ;\\n\\n        vector<int> ans (h , INT_MIN);\\n        sol (root , 0 , ans) ;\\n        return ans ;\\n    }\\n};"
                    },
                    {
                        "username": "verisimilitude",
                        "content": "Why is this question downvoted?"
                    }
                ]
            },
            {
                "id": 1672964,
                "content": [
                    {
                        "username": "VHNRaju",
                        "content": "![image](https://assets.leetcode.com/users/images/438ebdf1-0d61-47f1-ada2-cfe061679331_1595999636.9127004.png)\\n"
                    },
                    {
                        "username": "ajv97",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "utkarsh_v1901",
                        "content": "Why medium?"
                    },
                    {
                        "username": "Limon020",
                        "content": "its a medium, just one of the easier ones"
                    },
                    {
                        "username": "AjayRawat0706",
                        "content": "JAVA SOLUTION 100% fast\n\nclass Solution {\n    public List<Integer> largestValues(TreeNode root) {\n         Queue <TreeNode> q=new LinkedList<>();\n          List<Integer> list=new ArrayList<Integer>(); \n          if(root==null){\n              return list;\n          }\n          q.add(root);\n          \n          while(q.isEmpty()==false){\n              int count=q.size();\n              int curr=Integer.MIN_VALUE;\n              for(int i=0;i<count;i++){\n                  TreeNode temp=q.poll();\n                  curr=Math.max(curr,temp.val);\n                  if(temp.left!=null){\n                      q.add(temp.left);\n                  }\n                   if(temp.right!=null){\n                      q.add(temp.right);\n                  }\n              }\n             list.add(curr);\n          } \n        return list;\n    }\n}"
                    },
                    {
                        "username": "ajv97",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Madian",
                        "content": "Should be marked as Easy not Medium."
                    },
                    {
                        "username": "pengzuo",
                        "content": "still didn\\'t get what is row of tree"
                    },
                    {
                        "username": "ajv97",
                        "content": "Essentially it means the level of the tree. For example, root is the 1st level/row, the children of the root are in 2nd level/row, and the grandchildren are in 3rd level/row and so on."
                    },
                    {
                        "username": "divyanshag2002",
                        "content": "class Solution {\\npublic:\\n    int height (TreeNode * root)\\n    {\\n        if (root == NULL)\\n        {\\n            return 0 ;\\n        }\\n        int left = height (root->left) ;\\n        int right = height (root->right) ;\\n        int ans = max (left , right) + 1 ;\\n        return ans ;\\n    }\\n    void sol (TreeNode * root , int level , vector<int> & ans)\\n    {\\n        if (root == NULL)\\n        {\\n            return ;\\n        }\\n        int ind = level  ;\\n        // store the max no on the index of current height of the node \\n        ans[ind] = max (ans[ind] , root->val) ;\\n        sol (root->left , level + 1 , ans) ;\\n        sol (root->right , level + 1 , ans) ;\\n    }\\n    vector<int> largestValues(TreeNode* root) {\\n        // if the root node is null return null vector\\n        if (!root)\\n        {\\n            return {} ;\\n        }\\n        // make a vector of size height of the tree \\n        int h = height (root) ;\\n\\n        vector<int> ans (h , INT_MIN);\\n        sol (root , 0 , ans) ;\\n        return ans ;\\n    }\\n};"
                    },
                    {
                        "username": "verisimilitude",
                        "content": "Why is this question downvoted?"
                    }
                ]
            }
        ]
    }
]