[
    {
        "title": "Count the Number of Good Subarrays",
        "question_content": "Given an integer array nums and an integer k, return the number of good subarrays of nums.\nA subarray arr is good if it there are at least k pairs of indices (i, j) such that i < j and arr[i] == arr[j].\nA subarray is a contiguous non-empty sequence of elements within an array.\n&nbsp;\nExample 1:\n\nInput: nums = [1,1,1,1,1], k = 10\nOutput: 1\nExplanation: The only good subarray is the array nums itself.\n\nExample 2:\n\nInput: nums = [3,1,4,3,2,2,4], k = 2\nOutput: 4\nExplanation: There are 4 different good subarrays:\n- [3,1,4,3,2,2] that has 2 pairs.\n- [3,1,4,3,2,2,4] that has 3 pairs.\n- [1,4,3,2,2,4] that has 2 pairs.\n- [4,3,2,2,4] that has 2 pairs.\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 105\n\t1 <= nums[i], k <= 109",
        "solutions": [
            {
                "id": 3052559,
                "title": "java-c-python-sliding-window",
                "content": "# **Intuition**\\nFirst thing we need to think about,\\nis how we calculate the the pair (i,j) in an array.\\n<br>\\n\\n# **Explanation**\\nWe can apply the method of sliding window.\\nUse a hashmap `count` to count the frequency of each `A[i]`.\\n\\nWhen add a new number `A[j]` at the right of the window,\\nwe already have `count[A[j]]`  elements with value `A[j]` in the window,\\nso we will have  `count[A[j]]` more pairs.\\n\\nIf we have pairs more than `k`,\\nwe can reduce the size of window,\\nuntil there are `pairs < k` in the sliding window.\\nThen `A[i]...A[j]` is not a good subarray,\\nfor other index `i2 < i`,\\n`A[i2]...A[j]` is a good subarray.\\nso we can update `res += i` for `i2 = 0,1,2,...i-1`.\\n\\nFinally we return the result `res`.\\n<br>\\n\\n# **Complexity**\\nTime `O(n)`\\nSpace `O(n)`\\n<br>\\n\\n**Java**\\nJava equivalent from @AaveshK\\n```java\\n    public long countGood(int[] A, int k) {\\n        long res = 0L;\\n        Map<Integer, Integer> count = new HashMap<>();\\n        for(int i = 0, j = 0; j < A.length; ++j){\\n            k -= count.getOrDefault(A[j],0);\\n            count.put(A[j],count.getOrDefault(A[j],0)+1);\\n            // Or\\n            /*\\n            count.putIfAbsent(A[j],0);\\n            k -= count.get(A[j]);\\n            count.put(A[j],count.get(A[j])+1);\\n            */\\n            while(k <= 0){\\n                count.put(A[i],count.get(A[i])-1);\\n                k += count.get(A[i++]);\\n            }\\n            res += i;\\n        }\\n        return res;\\n    }\\n```\\n**C++**\\n```cpp\\n    long long countGood(vector<int>& A, int k) {\\n        long long res = 0;\\n        unordered_map<int, int> count;\\n        for (int i = 0, j = 0; j < A.size(); ++j) {\\n            k -= count[A[j]]++;\\n            while (k <= 0)\\n                k += --count[A[i++]];\\n            res += i;\\n        }\\n        return res;\\n    }\\n```\\n\\n**Python**\\n```py\\n    def countGood(self, A: List[int], k: int) -> int:\\n        res = cur = i = 0\\n        count = Counter()\\n        for j in range(len(A)):\\n            k -= count[A[j]]\\n            count[A[j]] += 1\\n            while k <= 0:\\n                count[A[i]] -= 1\\n                k += count[A[i]]\\n                i += 1\\n            res += i\\n        return res\\n```\\n<br>\\n\\n# More Similar Sliding Window Problems\\nHere are some similar sliding window problems.\\nAlso find more explanations and discussion.\\nGood luck and have fun.\\n\\n- 2401. [Longest Nice Subarray](https://leetcode.com/problems/longest-nice-subarray/discuss/2527496/Python-Sliding-Window)\\n- 2398. [Maximum Number of Robots Within Budget](https://leetcode.com/problems/maximum-number-of-robots-within-budget/discuss/2524838/Python-Sliding-Window-O(n))\\n- 1838. [Frequency of the Most Frequent Element](https://leetcode.com/problems/frequency-of-the-most-frequent-element/discuss/1175090/JavaC%2B%2BPython-Sliding-Window)\\n- 1493. [Longest Subarray of 1\\'s After Deleting One Element](https://leetcode.com/problems/longest-subarray-of-1s-after-deleting-one-element/discuss/708112/JavaC%2B%2BPython-Sliding-Window-at-most-one-0)\\n- 1425. [Constrained Subsequence Sum](https://leetcode.com/problems/constrained-subsequence-sum/discuss/597751/JavaC++Python-O(N)-Decreasing-Deque)\\n- 1358. [Number of Substrings Containing All Three Characters](https://leetcode.com/problems/number-of-substrings-containing-all-three-characters/discuss/516977/JavaC++Python-Easy-and-Concise)\\n- 1248. [Count Number of Nice Subarrays](https://leetcode.com/problems/count-number-of-nice-subarrays/discuss/419378/JavaC%2B%2BPython-Sliding-Window-atMost(K)-atMost(K-1))\\n- 1234. [Replace the Substring for Balanced String](https://leetcode.com/problems/replace-the-substring-for-balanced-string/discuss/408978/javacpython-sliding-window/)\\n- 1004. [Max Consecutive Ones III](https://leetcode.com/problems/max-consecutive-ones-iii/discuss/247564/JavaC%2B%2BPython-Sliding-Window)\\n-  930. [Binary Subarrays With Sum](https://leetcode.com/problems/binary-subarrays-with-sum/discuss/186683/)\\n-  992. [Subarrays with K Different Integers](https://leetcode.com/problems/subarrays-with-k-different-integers/discuss/523136/JavaC%2B%2BPython-Sliding-Window)\\n-  904. [Fruit Into Baskets](https://leetcode.com/problems/fruit-into-baskets/discuss/170740/Sliding-Window-for-K-Elements)\\n-  862. [Shortest Subarray with Sum at Least K](https://leetcode.com/problems/shortest-subarray-with-sum-at-least-k/discuss/143726/C%2B%2BJavaPython-O(N)-Using-Deque)\\n-  209. [Minimum Size Subarray Sum](https://leetcode.com/problems/minimum-size-subarray-sum/discuss/433123/JavaC++Python-Sliding-Window)\\n<br>\\n",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public long countGood(int[] A, int k) {\\n        long res = 0L;\\n        Map<Integer, Integer> count = new HashMap<>();\\n        for(int i = 0, j = 0; j < A.length; ++j){\\n            k -= count.getOrDefault(A[j],0);\\n            count.put(A[j],count.getOrDefault(A[j],0)+1);\\n            // Or\\n            /*\\n            count.putIfAbsent(A[j],0);\\n            k -= count.get(A[j]);\\n            count.put(A[j],count.get(A[j])+1);\\n            */\\n            while(k <= 0){\\n                count.put(A[i],count.get(A[i])-1);\\n                k += count.get(A[i++]);\\n            }\\n            res += i;\\n        }\\n        return res;\\n    }\\n```\n```cpp\\n    long long countGood(vector<int>& A, int k) {\\n        long long res = 0;\\n        unordered_map<int, int> count;\\n        for (int i = 0, j = 0; j < A.size(); ++j) {\\n            k -= count[A[j]]++;\\n            while (k <= 0)\\n                k += --count[A[i++]];\\n            res += i;\\n        }\\n        return res;\\n    }\\n```\n```py\\n    def countGood(self, A: List[int], k: int) -> int:\\n        res = cur = i = 0\\n        count = Counter()\\n        for j in range(len(A)):\\n            k -= count[A[j]]\\n            count[A[j]] += 1\\n            while k <= 0:\\n                count[A[i]] -= 1\\n                k += count[A[i]]\\n                i += 1\\n            res += i\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3052586,
                "title": "sliding-window",
                "content": "#### please upvote if you find it useful \\uD83D\\uDE0A\\n\\nIdea:-\\n\\nKeeping increasing the window until we get the condition \\n\\nsay we have three 1\\'s the total number of combinations would be 3c2 and for 4 4c2 \\n\\nhence for every increase in 1 number we will have to add frequency of that number - 1 \\n\\nexample: \\n\\none 1 :-  0 combinations\\n\\ntwo 1:- 0 + (2 - 1) = 1 combinations\\n\\nthree 1:- 1 + (3 - 1) = 3 combinations\\n\\nfour 1 :- 3 + ( 4 - 1) = 6 and so on \\n\\nwe add this to global count if the global count becomes >= k  then we have a good subarray . Then every subarray with this as subarray will also be good hence there are (n - j) such subarrays . \\n\\nAfter reaching a good subarray we try shrinking the window \\n\\n```c++\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& nums, int k) {\\n        int i = 0, j = 0 , n = nums.size();\\n        unordered_map<int,int> mp;\\n        long long int c = 0 , ans = 0;\\n        while(j < n){\\n            mp[nums[j]]++;\\n            c += mp[nums[j]] - 1;\\n\\t\\t\\twhile(i < j and c >= k){\\n\\t\\t\\t\\tans += n - j;\\n\\t\\t\\t\\tmp[nums[i]]--;\\n\\t\\t\\t\\tc -= mp[nums[i]];\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t}\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& nums, int k) {\\n        int i = 0, j = 0 , n = nums.size();\\n        unordered_map<int,int> mp;\\n        long long int c = 0 , ans = 0;\\n        while(j < n){\\n            mp[nums[j]]++;\\n            c += mp[nums[j]] - 1;\\n\\t\\t\\twhile(i < j and c >= k){\\n\\t\\t\\t\\tans += n - j;\\n\\t\\t\\t\\tmp[nums[i]]--;\\n\\t\\t\\t\\tc -= mp[nums[i]];\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t}\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3052887,
                "title": "c-solution-sliding-window",
                "content": "The idea is based on two observation:\\n1, If a subarray is considered good, all the subarrays containing it will be considered good (because the pair count will increase)\\n2, If a subarray is not good, all of its subarrays will not be good (the pair count will get smaller)\\n\\nSo we use a sliding window, first traversing the given array and find the first sub-array satisfies the conditions.\\nIn the process, we keep a hash map to store the frequency of numbers to calculate the pairs.\\nIf the pair count is greater than k, then pop out from the beginning of the subarray to see if there\\'s any subarray also satisfy the conditons.\\nOnce the pair count is smaller than k, keep adding from the end of the array.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& nums, int k) {\\n        // the number of good subarrays\\n        long long res = 0;\\n        int n = nums.size();\\n        // Keep track of the starting index to pop\\n        int srt = 0;\\n        // Hash map\\n        map <int, int> hash;\\n        // The number of pairs in the current subarray\\n        int cur = 0;\\n        for (int i = 0; i < n; i++) {\\n            // Increase the pair count  \\n            // Consider it this way\\n            // There are currently {1, 1}\\n            // So adding another 1 would increase the pairs by 2\\n            // (pair it with each of the 1s)\\n            cur += hash[nums[i]];\\n            hash [nums[i]] ++;\\n            // If we found a good subarray\\n            while (cur >= k) {\\n                // All subarray containing it will be good\\n                res += (n - i);\\n                // Pop from the beginning\\n                //  decreasing pair count in the process \\n                cur -= hash[nums[srt]] - 1;\\n                hash[nums[srt]] --;            \\n                srt ++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\nIf you found it helpful, please consider an upvote :3",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& nums, int k) {\\n        // the number of good subarrays\\n        long long res = 0;\\n        int n = nums.size();\\n        // Keep track of the starting index to pop\\n        int srt = 0;\\n        // Hash map\\n        map <int, int> hash;\\n        // The number of pairs in the current subarray\\n        int cur = 0;\\n        for (int i = 0; i < n; i++) {\\n            // Increase the pair count  \\n            // Consider it this way\\n            // There are currently {1, 1}\\n            // So adding another 1 would increase the pairs by 2\\n            // (pair it with each of the 1s)\\n            cur += hash[nums[i]];\\n            hash [nums[i]] ++;\\n            // If we found a good subarray\\n            while (cur >= k) {\\n                // All subarray containing it will be good\\n                res += (n - i);\\n                // Pop from the beginning\\n                //  decreasing pair count in the process \\n                cur -= hash[nums[srt]] - 1;\\n                hash[nums[srt]] --;            \\n                srt ++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3052706,
                "title": "short-concise-sliding-window-c",
                "content": "```\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& nums, int k) {\\n        long long i = 0, ans = 0, count = 0, n = nums.size();\\n        unordered_map<long long, long long> m;\\n        \\n        for(int j=0; j<n; j++) {\\n            m[nums[j]]++;\\n            if(m[nums[j]] > 1) count += m[nums[j]]  - 1;\\n            \\n            while(i <= j && count >= k) {\\n                ans += n - j;\\n                m[nums[i]]--;\\n                if(m[nums[i]] >= 1) count -= m[nums[i]];\\n                i++;\\n            } \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& nums, int k) {\\n        long long i = 0, ans = 0, count = 0, n = nums.size();\\n        unordered_map<long long, long long> m;\\n        \\n        for(int j=0; j<n; j++) {\\n            m[nums[j]]++;\\n            if(m[nums[j]] > 1) count += m[nums[j]]  - 1;\\n            \\n            while(i <= j && count >= k) {\\n                ans += n - j;\\n                m[nums[i]]--;\\n                if(m[nums[i]] >= 1) count -= m[nums[i]];\\n                i++;\\n            } \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3052760,
                "title": "explained-very-simple-and-easy-to-understand",
                "content": "\\n```\\n/*\\nTrick : total no of pairs in a sub array is sum of all (element count * (element count -1))/2, and let call it cnt.\\nSo using sliding window we keep track of cnt for each update of j.\\nonce cnt >= k, then check for how many i++ still cnt  > k \\nthen evaluate no of sub arrays possible that include new {i, j} elements \\n - so to calculate no of sub arrays, just add non zero side - if one of i is  start or j is end of array\\n - othere wise simply multiply elements in i side and elements after j side.\\n Note  : Need to consider only change in i side, as starting points are already considered in previous calculation\\n Ex : \\n     3,1,4,3,2,2,4,5\\n     i         j\\n     in bove case i = 0, and j = 5, we have cnt = 2 pairs with k = 2 and in this case when i chnges to 1 cnt become 1 nd less than k.\\n     so here i side no elements where as j side there are 3 elements, so we only add the 3 elements to ans.\\n     \\n     \\n     3,1,4,3,2,2,4,5\\n       i         j\\n     in bove case i = 1, and j = 6, we have cnt = 2 pairs with k = 2 and in this case when i chnges to 3 form 1 cnt become 1 nd less than k  \\n     so here i side there are 2 elements ( i.e change in i) and j side also 2 elements, so we need to add (change in i) * (elemnets next to j)\\n\\nHope you understood the solution => Up Vote \\n    \\n*/\\n\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& nums, int k) {\\n        long long ans = 0;\\n        int i = 0, j = 0;\\n        unordered_map<long long, long long> mp;\\n        long long cnt = 0;\\n        while(j < nums.size()){\\n            cnt -= mp[nums[j]] * (mp[nums[j]] - 1)/2;\\n            mp[nums[j]]++;\\n            cnt += mp[nums[j]] * (mp[nums[j]] - 1)/2;\\n            if(cnt >= k){\\n                int t = i;\\n                while(cnt >= k && i <= j){\\n                    cnt = cnt - (mp[nums[i]] * (mp[nums[i]] - 1)/2);\\n                    mp[nums[i]]--;\\n                    cnt = cnt + (mp[nums[i]] * (mp[nums[i]] - 1)/2);\\n                    ++i;\\n                }\\n                if(i - t == 1 || (nums.size() - j - 1) == 0) ans = ans + (nums.size() - j - 1) + i - t;\\n                else ans = ans + (nums.size() - j) * (i - t);\\n                //cout<<nums.size()<<\" \"<<i<<\" \"<<j<<\" \"<<ans<<endl;\\n            }\\n            ++j;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/*\\nTrick : total no of pairs in a sub array is sum of all (element count * (element count -1))/2, and let call it cnt.\\nSo using sliding window we keep track of cnt for each update of j.\\nonce cnt >= k, then check for how many i++ still cnt  > k \\nthen evaluate no of sub arrays possible that include new {i, j} elements \\n - so to calculate no of sub arrays, just add non zero side - if one of i is  start or j is end of array\\n - othere wise simply multiply elements in i side and elements after j side.\\n Note  : Need to consider only change in i side, as starting points are already considered in previous calculation\\n Ex : \\n     3,1,4,3,2,2,4,5\\n     i         j\\n     in bove case i = 0, and j = 5, we have cnt = 2 pairs with k = 2 and in this case when i chnges to 1 cnt become 1 nd less than k.\\n     so here i side no elements where as j side there are 3 elements, so we only add the 3 elements to ans.\\n     \\n     \\n     3,1,4,3,2,2,4,5\\n       i         j\\n     in bove case i = 1, and j = 6, we have cnt = 2 pairs with k = 2 and in this case when i chnges to 3 form 1 cnt become 1 nd less than k  \\n     so here i side there are 2 elements ( i.e change in i) and j side also 2 elements, so we need to add (change in i) * (elemnets next to j)\\n\\nHope you understood the solution => Up Vote \\n    \\n*/\\n\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& nums, int k) {\\n        long long ans = 0;\\n        int i = 0, j = 0;\\n        unordered_map<long long, long long> mp;\\n        long long cnt = 0;\\n        while(j < nums.size()){\\n            cnt -= mp[nums[j]] * (mp[nums[j]] - 1)/2;\\n            mp[nums[j]]++;\\n            cnt += mp[nums[j]] * (mp[nums[j]] - 1)/2;\\n            if(cnt >= k){\\n                int t = i;\\n                while(cnt >= k && i <= j){\\n                    cnt = cnt - (mp[nums[i]] * (mp[nums[i]] - 1)/2);\\n                    mp[nums[i]]--;\\n                    cnt = cnt + (mp[nums[i]] * (mp[nums[i]] - 1)/2);\\n                    ++i;\\n                }\\n                if(i - t == 1 || (nums.size() - j - 1) == 0) ans = ans + (nums.size() - j - 1) + i - t;\\n                else ans = ans + (nums.size() - j) * (i - t);\\n                //cout<<nums.size()<<\" \"<<i<<\" \"<<j<<\" \"<<ans<<endl;\\n            }\\n            ++j;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3052838,
                "title": "java-easy-sliding-window-using-hashmap",
                "content": "```\\nclass Solution {\\n    public long countGood(int[] nums, int k) {\\n        int j=0;\\n        int i=0;\\n        long ans=0l;\\n        long count=0l;\\n        HashMap<Integer,Integer> hm=new HashMap<>();\\n        while(j<nums.length){\\n            hm.put(nums[j],hm.getOrDefault(nums[j],0)+1);\\n            count += hm.get(nums[j]) - 1;\\n            while(count>=k){\\n                ans += (nums.length - j);\\n                int lf = hm.get(nums[i]);\\n                count-=lf-1;\\n                hm.put(nums[i], hm.get(nums[i]) - 1);\\n                if(hm.get(nums[i])==0)\\n                    hm.remove(nums[i]);              \\n                i++;\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n}\\n```\\n**For Explanation I found a good video :- https://youtu.be/ZCI-mXIQWAE**\\n\\n**IF YOU LIKED THE APPROACH PLEASE UPVOTE \\uD83D\\uDE4F\\uD83D\\uDE4F\\uD83D\\uDE4F**",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public long countGood(int[] nums, int k) {\\n        int j=0;\\n        int i=0;\\n        long ans=0l;\\n        long count=0l;\\n        HashMap<Integer,Integer> hm=new HashMap<>();\\n        while(j<nums.length){\\n            hm.put(nums[j],hm.getOrDefault(nums[j],0)+1);\\n            count += hm.get(nums[j]) - 1;\\n            while(count>=k){\\n                ans += (nums.length - j);\\n                int lf = hm.get(nums[i]);\\n                count-=lf-1;\\n                hm.put(nums[i], hm.get(nums[i]) - 1);\\n                if(hm.get(nums[i])==0)\\n                    hm.remove(nums[i]);              \\n                i++;\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3054978,
                "title": "java-sliding-window-hashmap-explained",
                "content": "# Please Upvote :D\\n---\\nWe can apply the method of sliding window.\\nUse a hashmap count to count the frequency of each `A[i]`.\\n\\nWhen add a new number `A[j]` at the right of the window,\\nwe already have `count[A[j]]` elements with value `A[j]` in the window,\\nso we will have `count[A[j]]` more pairs.\\n\\nIf we have pairs more than `k`,\\nwe can reduce the size of window,\\nuntil there are `pairs < k` in the sliding window.\\nThen `A[i]...A[j]` is not a good subarray,\\nfor other index `i2 < i`,\\n`A[i2]...A[j]` is a good subarray.\\nso we can update `ans += i` for `i2 = 0,1,2,...i-1`.\\n\\nFinally we return `ans`.\\n\\n \\xA9 [@lee215](https://leetcode.com/problems/count-the-number-of-good-subarrays/solutions/3052559/java-c-python-sliding-window/?orderBy=most_votes)\\n``` java []\\nclass Solution {\\n    public long countGood(int[] nums, int k) {\\n        Map<Integer, Integer> map= new HashMap<>();\\n        long ans = 0;       // to store number of good subarrays\\n        int pairs = 0;      // to store pairs of current subarray\\n        int left = 0, right = 0;    // pointers\\n        while (right < nums.length) {\\n            // if frequency is 0, and we find an element, we don\\'t have pair yet.\\n            // If frequency >= 1, we will have pairs. Say frequency of x is 1 and we found x again, \\n            // so we have 1 pair now => n same elements = n(n - 1)/2 pairs\\n            // variable \\'pairs\\' will tell us how many pairs we have got in our current window\\n            pairs += map.getOrDefault(nums[right], 0);  // update pairs\\n            // update the frequency in the map \\n            map.put(nums[right], 1 + map.getOrDefault(nums[right], 0));\\n            // If we have found >= k pairs, We will try to shrink the window from left, \\n            // else we won\\'t enter the loop\\n            while (pairs >= k) {\\n                // we discard the element at the leftmost end of our window\\n                // and its frequency in the map decreases by 1\\n                map.put(nums[left], map.get(nums[left]) - 1);\\n                // why we are doing this, is explained by the attached image\\n                pairs -= map.get(nums[left]);\\n                left++;     // we shrink the window from left\\n            }\\n            ans += left;    // The left pointer gives us the number of valid pairs in the window [left,right]\\n\\t\\t\\t// Note : The siding window we are maintaining here has the min num of elements in range [left,right] \\n\\t\\t\\t// with atleast k pairs, if we extend our window to the left it will by default contain the minimum k pairs + may contain more\\n\\t\\t\\t// hence if [left, right] is valid that means [left-1,right] is also valid, [left-2, right] is also valid. \\n\\t\\t\\t// Thus we just add the left pointer to ans as it will contains the range from [0,left-1] which is forming the valid pair with right\\n            right++;    // expand the window from right\\n        }\\n\\n        return ans;\\n    }\\n}\\n\\n// TC: O(n), SC: O(n)\\n```\\n![image.png](https://assets.leetcode.com/users/images/a5ddcce5-4247-4f78-9db0-3b8b22ff7835_1673793741.0420659.png)\\nThat\\'s why we do `pairs -= map.get(nums[left])`.\\n",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Sliding Window"
                ],
                "code": "``` java []\\nclass Solution {\\n    public long countGood(int[] nums, int k) {\\n        Map<Integer, Integer> map= new HashMap<>();\\n        long ans = 0;       // to store number of good subarrays\\n        int pairs = 0;      // to store pairs of current subarray\\n        int left = 0, right = 0;    // pointers\\n        while (right < nums.length) {\\n            // if frequency is 0, and we find an element, we don\\'t have pair yet.\\n            // If frequency >= 1, we will have pairs. Say frequency of x is 1 and we found x again, \\n            // so we have 1 pair now => n same elements = n(n - 1)/2 pairs\\n            // variable \\'pairs\\' will tell us how many pairs we have got in our current window\\n            pairs += map.getOrDefault(nums[right], 0);  // update pairs\\n            // update the frequency in the map \\n            map.put(nums[right], 1 + map.getOrDefault(nums[right], 0));\\n            // If we have found >= k pairs, We will try to shrink the window from left, \\n            // else we won\\'t enter the loop\\n            while (pairs >= k) {\\n                // we discard the element at the leftmost end of our window\\n                // and its frequency in the map decreases by 1\\n                map.put(nums[left], map.get(nums[left]) - 1);\\n                // why we are doing this, is explained by the attached image\\n                pairs -= map.get(nums[left]);\\n                left++;     // we shrink the window from left\\n            }\\n            ans += left;    // The left pointer gives us the number of valid pairs in the window [left,right]\\n\\t\\t\\t// Note : The siding window we are maintaining here has the min num of elements in range [left,right] \\n\\t\\t\\t// with atleast k pairs, if we extend our window to the left it will by default contain the minimum k pairs + may contain more\\n\\t\\t\\t// hence if [left, right] is valid that means [left-1,right] is also valid, [left-2, right] is also valid. \\n\\t\\t\\t// Thus we just add the left pointer to ans as it will contains the range from [0,left-1] which is forming the valid pair with right\\n            right++;    // expand the window from right\\n        }\\n\\n        return ans;\\n    }\\n}\\n\\n// TC: O(n), SC: O(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3053838,
                "title": "python-3-11-lines-two-pointers-dict-t-m-689-ms-31-7-mb",
                "content": "Here\\'s the plan:\\n1. We increment`right` and use a dict `d` to keep track of the count of each integer in `nums[:right+1]`.\\n2. Once the number of pairs reaches`k`, we add the count of subarrays with subarray `[right+1]`to`ans`].\\n3. We increment`left`and adjust`d`. If we still have`k`pairs, we add a similar count to `ans`and increment `left`again. If not, we iterate`right`and start again.\\n4. Once`right`iterates`nums`completely and`left`increments so that pairs are less than`k`, we return `ans`. \\n```\\nclass Solution:\\n    def countGood(self, nums: List[int], k: int) -> int:\\n\\n        left = ans = tally = 0\\n        n, d = len(nums), defaultdict(int)\\n\\n        for right,num in enumerate(nums):    # <-- 1\\n            tally += d[num]\\n            d[num] += 1\\n            \\n            while tally >= k:                # <-- 2     \\n                ans+= n - right\\n                d[nums[left]] -= 1           # <-- 3\\n                tally -= d[nums[left]]\\n                left += 1\\n            \\n        return ans                           # <-- 4\\n```\\n[https://leetcode.com/problems/count-the-number-of-good-subarrays/submissions/878498085/](http://)\\n\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is worst case *O*(*N*).",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countGood(self, nums: List[int], k: int) -> int:\\n\\n        left = ans = tally = 0\\n        n, d = len(nums), defaultdict(int)\\n\\n        for right,num in enumerate(nums):    # <-- 1\\n            tally += d[num]\\n            d[num] += 1\\n            \\n            while tally >= k:                # <-- 2     \\n                ans+= n - right\\n                d[nums[left]] -= 1           # <-- 3\\n                tally -= d[nums[left]]\\n                left += 1\\n            \\n        return ans                           # <-- 4\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3053044,
                "title": "python-100-sliding-window-and-pair-counting",
                "content": "Well once you (atleast me) start thinking about solution, one thing is clear you have to maintain a count of pair, so let\\'s go naive. Let\\'s maintain a dictionary for every element, so if there is x no. of a, then total pair you can make is (x * (x - 1)) /2\\n\\nnow, for every possible subarray we need to find if it\\'s good, that is calculating total pairs made by elements in that subarray. this is time consuming. \\n\\nSo either we can do something with dp aur maybe sliding window.\\n\\n#1 One observation in particular is if a subarray nums[l:r] is good then nums[l: r+1] is also good and similarly, nums[l:r+2] is also good and so on.. so sliding window looks hopeful here.\\n\\nif using using sliding window, we would be scanning each element, and with each element k(count of pairs) increases\\nso for a subarray nums[l:r], we can take sum of pair possible of each element.. but that\\'s again time consuming, can we do better ?\\n#2 another observation (or maybe it\\'s a formula):\\nassume a array [1, 1, 1, 1]\\nscanning from left to right\\nelement: count -> pair \\n1: 1 -> 0\\n1: 2 -> 1 = 0 + (2 - 1)\\n1: 3 -> 3 = 1 + (3 - 1)\\n1: 4 -> 6 = 3 + (4 - 1)\\nvice a versa is also true if count of element decreases\\nso after having these observation and fitting them together we get\\n```\\nclass Solution:\\n    def countGood(self, nums: List[int], k: int) -> int:\\n        l = 0\\n        r = 0\\n        m = {}\\n        totalK = 0 # total pairs found in n[l:r]\\n        goodSub = 0\\n        while r < len(nums):\\n            if nums[r] in m:\\n                m[nums[r]] += 1\\n                totalK += m[nums[r]] - 1 # counting pairs \\n            else:\\n                m[nums[r]] = 1\\n            while totalK >= k: # we found k pairs in nums[l:r] we don\\'t need to calculate ahead\\n                goodSub += len(nums) - r # calculate good subarray which is just the number of subarrays you can get adding remaining n - r elements\\n                m[nums[l]] -= 1\\n                totalK -= m[nums[l]] # updating pairs because window is going to be reduced\\n                l += 1 # window reduced\\n            r += 1\\n        return goodSub            \\n```\\nso like the important points were updating pair while running the scan, and observing #1\\nThanks for reading.. Let me know if there is some confusion or mistake",
                "solutionTags": [
                    "Python",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def countGood(self, nums: List[int], k: int) -> int:\\n        l = 0\\n        r = 0\\n        m = {}\\n        totalK = 0 # total pairs found in n[l:r]\\n        goodSub = 0\\n        while r < len(nums):\\n            if nums[r] in m:\\n                m[nums[r]] += 1\\n                totalK += m[nums[r]] - 1 # counting pairs \\n            else:\\n                m[nums[r]] = 1\\n            while totalK >= k: # we found k pairs in nums[l:r] we don\\'t need to calculate ahead\\n                goodSub += len(nums) - r # calculate good subarray which is just the number of subarrays you can get adding remaining n - r elements\\n                m[nums[l]] -= 1\\n                totalK -= m[nums[l]] # updating pairs because window is going to be reduced\\n                l += 1 # window reduced\\n            r += 1\\n        return goodSub            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3052583,
                "title": "total-count-of-not-good-subarrays",
                "content": "```\\nclass Solution {\\n\\n    public long countGood(int[] nums, int k) {\\n        int n = nums.length;\\n        long ans = (long)(n * (long) (n + 1l)) / 2l;\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        int c = 0;\\n        for (int s = 0, i = 0; i < n; i++) {\\n            c += map.getOrDefault(nums[i], 0);\\n            map.put(nums[i], map.getOrDefault(nums[i], 0) + 1);\\n            while (c >= k) {\\n                map.put(nums[s], map.get(nums[s]) - 1);\\n                c -= map.get(nums[s]);\\n                if (map.get(nums[s]) == 0) map.remove(nums[s]);\\n                s++;\\n            }\\n            ans -= (long) (i - s + 1l);\\n        }\\n        return ans;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\n    public long countGood(int[] nums, int k) {\\n        int n = nums.length;\\n        long ans = (long)(n * (long) (n + 1l)) / 2l;\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        int c = 0;\\n        for (int s = 0, i = 0; i < n; i++) {\\n            c += map.getOrDefault(nums[i], 0);\\n            map.put(nums[i], map.getOrDefault(nums[i], 0) + 1);\\n            while (c >= k) {\\n                map.put(nums[s], map.get(nums[s]) - 1);\\n                c -= map.get(nums[s]);\\n                if (map.get(nums[s]) == 0) map.remove(nums[s]);\\n                s++;\\n            }\\n            ans -= (long) (i - s + 1l);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3080857,
                "title": "c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    #define ll long long\\n    long long countGood(vector<int>& nums, int k) {\\n         ll n = nums.size();\\n        long long int cmp=0;\\n        ll int res = 0;\\n        ll ans= n*(n+2-1)/2;\\n        unordered_map<ll, ll> mp;\\n        ll left = 0;\\n        long long int temp = 0;\\n        long long int c = 0;\\n        for (int i = 0; i < n;i++) {\\n            if (mp[nums[i]] > 0) {\\n                temp += mp[nums[i]];\\n            }\\n            mp[nums[i]]++;\\n            while (left <= i && temp >= k) {\\n                if (mp[nums[left]] > 1) {\\n                    temp -= (mp[nums[left]] - 1);\\n                }\\n                mp[nums[left]]--;\\n                left++;\\n            }\\n            res += (i - left + 1);\\n            c=max(res,c);\\n        }\\n         ans =ans -res;\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    #define ll long long\\n    long long countGood(vector<int>& nums, int k) {\\n         ll n = nums.size();\\n        long long int cmp=0;\\n        ll int res = 0;\\n        ll ans= n*(n+2-1)/2;\\n        unordered_map<ll, ll> mp;\\n        ll left = 0;\\n        long long int temp = 0;\\n        long long int c = 0;\\n        for (int i = 0; i < n;i++) {\\n            if (mp[nums[i]] > 0) {\\n                temp += mp[nums[i]];\\n            }\\n            mp[nums[i]]++;\\n            while (left <= i && temp >= k) {\\n                if (mp[nums[left]] > 1) {\\n                    temp -= (mp[nums[left]] - 1);\\n                }\\n                mp[nums[left]]--;\\n                left++;\\n            }\\n            res += (i - left + 1);\\n            c=max(res,c);\\n        }\\n         ans =ans -res;\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3847899,
                "title": "c-o-n-sliding-window",
                "content": "**Connect with me on LinkedIn**: https://www.linkedin.com/in/abhay5349singh/\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    #define ll long long\\n    \\n    long long countGood(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        \\n        ll int pairs_count=0;\\n        \\n        map<int,int> mp;\\n        int i=0, j=0;\\n        \\n        ll int ans=0;\\n        while(j<n){\\n            mp[nums[j]]++;\\n            \\n            pairs_count += mp[nums[j]]-1; // number of new pairs formed \\n            \\n            while(i<j && pairs_count >= k){\\n                 ans += n-j; // if for [i,j] we have pairs_count >= k, so all idx => [j,n-1] can be included in answer\\n                \\n                mp[nums[i]]--;\\n                pairs_count -= mp[nums[i]];\\n                \\n                i++;\\n            }\\n            j++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n**Do upvote if it helps:)**",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    #define ll long long\\n    \\n    long long countGood(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        \\n        ll int pairs_count=0;\\n        \\n        map<int,int> mp;\\n        int i=0, j=0;\\n        \\n        ll int ans=0;\\n        while(j<n){\\n            mp[nums[j]]++;\\n            \\n            pairs_count += mp[nums[j]]-1; // number of new pairs formed \\n            \\n            while(i<j && pairs_count >= k){\\n                 ans += n-j; // if for [i,j] we have pairs_count >= k, so all idx => [j,n-1] can be included in answer\\n                \\n                mp[nums[i]]--;\\n                pairs_count -= mp[nums[i]];\\n                \\n                i++;\\n            }\\n            j++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3053049,
                "title": "c-sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nWe keep a window that is a subarray of `nums`. In this window, it satisfy the requirements: at least k pairs of indices (i, j) such that i < j and arr[i] == arr[j].\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nGive two pointers, one for the right bound of the window, the other for the left bound of the window.\\n\\nWe keep moving right pointer then check the number to see how many times it was seen before as `freq[num]`.\\n\\nThat mean there are new `freq[num]` pairs that can contribute to the valid pairs. Increase the valid pairs count `count += freq[num]`.\\n\\nWhen the total number of valid pairs `count >= k`, we find a valid subarray that contains at least k valid pairs. \\n\\nWe then start shrinking the sliding window by reducing the valid pairs from left as long as the total number of valid pairs is >= `k`.\\n\\nThe entire process is to find all the valid sub arrays until we reach the end of the array.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& nums, int k) {\\n        unordered_map<int,int> freq;\\n        long long count = 0;\\n        long long ret = 0;\\n        int n = nums.size();\\n        int j = 0;\\n        for(int i=0; i<n; i++) {\\n            int num = nums[i];\\n            count += freq[num];\\n            freq[num]++;\\n            while(count >= k && j<=i ) {\\n                // n - i is the number of sub array \\n                // [j...i] is alreay a valid subarray, so\\n                // [j...i, i+1], [j...i, i+1, i+2], ... [j..i, i+1, i+2, ...n-1] is alo valid sub arrray\\n                // the number of sub arrays are n-i\\n                ret += (n - i);\\n                num = nums[j];\\n                freq[num]--;\\n                count -= freq[num];\\n                j++;\\n            }\\n            \\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& nums, int k) {\\n        unordered_map<int,int> freq;\\n        long long count = 0;\\n        long long ret = 0;\\n        int n = nums.size();\\n        int j = 0;\\n        for(int i=0; i<n; i++) {\\n            int num = nums[i];\\n            count += freq[num];\\n            freq[num]++;\\n            while(count >= k && j<=i ) {\\n                // n - i is the number of sub array \\n                // [j...i] is alreay a valid subarray, so\\n                // [j...i, i+1], [j...i, i+1, i+2], ... [j..i, i+1, i+2, ...n-1] is alo valid sub arrray\\n                // the number of sub arrays are n-i\\n                ret += (n - i);\\n                num = nums[j];\\n                freq[num]--;\\n                count -= freq[num];\\n                j++;\\n            }\\n            \\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3052574,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& nums, int k) {\\n        long long n=nums.size();\\n        long long count=0;\\n        int j=0;\\n        unordered_map<long long,long long>mp;\\n        long long len=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            mp[nums[i]]++;\\n            count+=(mp[nums[i]]-1);\\n            while(count>=k)\\n            {\\n                count-=(mp[nums[j]]-1);\\n                mp[nums[j]]--;\\n                if(mp[nums[j]]==0)\\n                {\\n                    mp.erase(nums[j]);\\n                }\\n                j++;\\n            }\\n            len+=(i-j+1);\\n        }\\n        return (1ll*n*(n+1)/2)-len;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& nums, int k) {\\n        long long n=nums.size();\\n        long long count=0;\\n        int j=0;\\n        unordered_map<long long,long long>mp;\\n        long long len=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            mp[nums[i]]++;\\n            count+=(mp[nums[i]]-1);\\n            while(count>=k)\\n            {\\n                count-=(mp[nums[j]]-1);\\n                mp[nums[j]]--;\\n                if(mp[nums[j]]==0)\\n                {\\n                    mp.erase(nums[j]);\\n                }\\n                j++;\\n            }\\n            len+=(i-j+1);\\n        }\\n        return (1ll*n*(n+1)/2)-len;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3832729,
                "title": "100-beats-c-map",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& nums, int k) {\\n        long long int ans = 0,x=0;\\n        int i=0,j=0,n=nums.size();\\n        unordered_map<int,int> mp;\\n        while(i<n){\\n            mp[nums[i]]++;\\n            x += (mp[nums[i]]-1);\\n            while(x >= k){\\n                ans += (n-i);\\n                mp[nums[j]]--;\\n                x -= mp[nums[j]];\\n                j++;\\n            }\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& nums, int k) {\\n        long long int ans = 0,x=0;\\n        int i=0,j=0,n=nums.size();\\n        unordered_map<int,int> mp;\\n        while(i<n){\\n            mp[nums[i]]++;\\n            x += (mp[nums[i]]-1);\\n            while(x >= k){\\n                ans += (n-i);\\n                mp[nums[j]]--;\\n                x -= mp[nums[j]];\\n                j++;\\n            }\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3055134,
                "title": "intuitive-sliding-window-o-n-python-solution",
                "content": "### Sliding Window\\nEasy read on [LeetCode Weekly Contest Medium (Sliding Window) 2537. Count the Number of Good Subarrays \\u2014 Hung, Chien-Hsiang | Blog (chienhsiang-hung.github.io)](https://chienhsiang-hung.github.io/blog/posts/2023/leetcode-weekly-contest-medium-sliding-window-2537.-count-the-number-of-good-subarrays/)\\n\\nIntuitive Sliding Window O(n) Python Solution \\n\\nDry run some examples with sliding window technique.\\n![draft.jpg](https://chienhsiang-hung.github.io/blog/posts/2023/leetcode-weekly-contest-medium-sliding-window-2537.-count-the-number-of-good-subarrays/draft.jpg)\\n\\nNotice. You need to make sure the left most window, mid-window, and the right most window all collected. With the trend we found below:\\n![featured-image.jpg](https://chienhsiang-hung.github.io/blog/posts/2023/leetcode-weekly-contest-medium-sliding-window-2537.-count-the-number-of-good-subarrays/featured-image.jpg)\\n\\nCombine them to implement the solution.\\n```python []\\nclass Solution:\\n    def countGood(self, nums: List[int], k: int) -> int:\\n        right = left = 0\\n        window = defaultdict(int)\\n        pairs_count = defaultdict(int)\\n        ans = 0\\n        while left < len(nums)-1:\\n            # extend window\\n            if right < len(nums):\\n                window[nums[right]] += 1\\n                if window[nums[right]] >= 2:\\n                    pairs_count[nums[right]] += window[nums[right]]-1\\n\\n            while sum([v for v in pairs_count.values()]) >= k:\\n                ans += len(nums)-right if len(nums)-right else 1\\n                # shrink window\\n                window[nums[left]] -= 1\\n                if window[nums[left]] >= 1:\\n                    pairs_count[nums[left]] -= window[nums[left]]\\n                left += 1\\n                continue\\n\\n            if right < len(nums):\\n                right += 1\\n            else:\\n                left += 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "Sliding Window"
                ],
                "code": "```python []\\nclass Solution:\\n    def countGood(self, nums: List[int], k: int) -> int:\\n        right = left = 0\\n        window = defaultdict(int)\\n        pairs_count = defaultdict(int)\\n        ans = 0\\n        while left < len(nums)-1:\\n            # extend window\\n            if right < len(nums):\\n                window[nums[right]] += 1\\n                if window[nums[right]] >= 2:\\n                    pairs_count[nums[right]] += window[nums[right]]-1\\n\\n            while sum([v for v in pairs_count.values()]) >= k:\\n                ans += len(nums)-right if len(nums)-right else 1\\n                # shrink window\\n                window[nums[left]] -= 1\\n                if window[nums[left]] >= 1:\\n                    pairs_count[nums[left]] -= window[nums[left]]\\n                left += 1\\n                continue\\n\\n            if right < len(nums):\\n                right += 1\\n            else:\\n                left += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3053164,
                "title": "accepted-easy-solution-short-simple-best-method",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& nums, int k) {\\n        long long c=0, ans=0;\\n        unordered_map<int, int> mp;\\n        int j=0, n=nums.size();\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            mp[nums[i]]++;\\n            c+=(mp[nums[i]]-1);\\n            while(c>=k && j<=i)\\n            {\\n                ans+=(n-i);\\n                mp[nums[j]]--;\\n                c-=mp[nums[j]];\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& nums, int k) {\\n        long long c=0, ans=0;\\n        unordered_map<int, int> mp;\\n        int j=0, n=nums.size();\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            mp[nums[i]]++;\\n            c+=(mp[nums[i]]-1);\\n            while(c>=k && j<=i)\\n            {\\n                ans+=(n-i);\\n                mp[nums[j]]--;\\n                c-=mp[nums[j]];\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3052684,
                "title": "python3-sliding-window",
                "content": "\\n```\\nclass Solution:\\n    def countGood(self, nums: List[int], k: int) -> int:\\n        freq = Counter()\\n        ans = ii = total = 0 \\n        for x in nums: \\n            total += freq[x]\\n            freq[x] += 1\\n            while total >= k: \\n                freq[nums[ii]] -= 1\\n                total -= freq[nums[ii]]\\n                ii += 1\\n            ans += ii \\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countGood(self, nums: List[int], k: int) -> int:\\n        freq = Counter()\\n        ans = ii = total = 0 \\n        for x in nums: \\n            total += freq[x]\\n            freq[x] += 1\\n            while total >= k: \\n                freq[nums[ii]] -= 1\\n                total -= freq[nums[ii]]\\n                ii += 1\\n            ans += ii \\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3415479,
                "title": "c-sliding-window-map-easy-to-understand-short-sweet",
                "content": "````\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& nums, int k) {\\n        long long int ans = 0;\\n        unordered_map<int,int> v;\\n        int i = 0, j = 0, cnt = 0,n=nums.size();\\n        while(i<n){\\n            while(j<n&&cnt<k){//no of possible good pairs\\n                v[nums[j]]++;\\n                cnt += v[nums[j]]-1;\\n                j++;\\n            }\\n            if(cnt<k)break;\\n            ans += (n-j+1);//after index [i,jtilln] (j to n) all good subarray\\n            v[nums[i]]--;\\n            cnt -= v[nums[i]];\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C",
                    "Hash Table",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "````\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& nums, int k) {\\n        long long int ans = 0;\\n        unordered_map<int,int> v;\\n        int i = 0, j = 0, cnt = 0,n=nums.size();\\n        while(i<n){\\n            while(j<n&&cnt<k){//no of possible good pairs\\n                v[nums[j]]++;\\n                cnt += v[nums[j]]-1;\\n                j++;\\n            }\\n            if(cnt<k)break;\\n            ans += (n-j+1);//after index [i,jtilln] (j to n) all good subarray\\n            v[nums[i]]--;\\n            cnt -= v[nums[i]];\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3177904,
                "title": "hashmap-and-sliding-window",
                "content": "If we get `k` pairs in `[j, i]` window, we have `sz - i` good arrays.\\n\\nWhile we have `k` pairs, we add `sz - i` to the result and shrink that window by moving `j` forward.\\n\\nIf we get less than `k` pairs, we move `i` forward and repeat the previous step.\\n\\n**C++**\\n```cpp\\nlong long countGood(vector<int>& n, int k) {\\n    unordered_map<int, int> cnt;\\n    long long res = 0, sz = n.size();\\n    for (int i = 0, j = 0; i < sz; ++i) {\\n        k -= cnt[n[i]]++;\\n        while (k <= 0) {\\n            res += sz - i;\\n            k += --cnt[n[j++]];\\n        }\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nlong long countGood(vector<int>& n, int k) {\\n    unordered_map<int, int> cnt;\\n    long long res = 0, sz = n.size();\\n    for (int i = 0, j = 0; i < sz; ++i) {\\n        k -= cnt[n[i]]++;\\n        while (k <= 0) {\\n            res += sz - i;\\n            k += --cnt[n[j++]];\\n        }\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3055187,
                "title": "detailed-intuition-concise-solution-and-python",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs my usual blogs i am partioning this blog into 3 parts\\n1. prerequisites\\n2. intuition\\n3. code\\n\\n*Read as much as you want*\\n#### prerequisites(optional)\\n1. subsequences hold some properties which will be used in the solution, i mean what is wrong in learning new stuff.\\nbut just 1 thing before we start - **subsequence is a sequence with some elements remove at any index**\\nif we want to know unique comparisions in a sequence it is n(n+1)/2,you don\\'t need to have a proof just create an array of size 4 you will get it or visit the solution attached below.\\neach element when added into a sequence opens a possibilty of comparision with each element in the sequence with this element,if we consider that during the time of addition we are making these comparisions we are assured that last inserted element is already compared so if after insertion array size is n nth element must compare with n-1 elements.\\n2. sliding window.\\n# Intution\\n<!-- Describe your approach to solving the problem. -->\\nwe can expand a window size until we find pair_count>=k and start shrinking as soon pair_count increases k,as elements are allowed to make pair with elements of same value our window can have any number of elements in the left,right or in the middle of elments participating in pair formation till condition is met(pair_count>=k)\\nTo check all these possibilities in one pass we can use sliding window.\\ncondition:pair_count>=k\\nour window can start from one edge of array and can expand until condition is met as soon as condition is met we can start shrinking the shrinking phase consist of two parts\\n1. finding the ending index - if we observe we can generate new subsequences by keep on appending elements and each appended element generates a new sequence,the number of these sequences can be 1+ size of sequence  - ending_index_of_window here 1 is the current sequence without appending any value as it is also valid it should also be added.\\n2. now we start shrinking from starting end of window,here a thing worth consideration is that the element we have at starting may be just not the one corresponding to pair formation but will be the one corresponding to sequence generation each removed element will generate a sequance shifted left(a new sequence) we remove elements till we have enough pair to hold our condition we don\\'t have to check the remaining pairs as we are doing in the case of last elements by adding just 1+ size of sequence  - ending_index_of_window and never questioning why it should work.\\n**here is a blog with examples** *https://leetcode.com/problems/count-the-number-of-good-subarrays/solutions/3055134/intuitive-sliding-window-o-n-python-solution/?languageTags=python*\\nRest i will clear in comments section.\\n# Code\\n```\\nclass Solution(object):\\n    def countGood(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        elements_in_current_window=dict()\\n        pair_count=0\\n        start=0\\n        end=0\\n        ans=0\\n        while(end<len(nums)):\\n            if(elements_in_current_window.has_key(nums[end])):\\n                elements_in_current_window[nums[end]]+=1 #incrementing \\n            else:\\n                elements_in_current_window[nums[end]]=1 #initializing entry in the dictionary\\n            pair_count+=elements_in_current_window[nums[end]]-1 #counting number of pairs\\n            while pair_count>=k: #The shrinking phase\\n                ans+=1+len(nums)-end-1 #the number of new sequences\\n                elements_in_current_window[nums[start]]-=1 #remove the element at the starting of the window\\n                pair_count-=elements_in_current_window[nums[start]]\\n                start+=1\\n            end+=1    \\n        return ans            \\n            \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers",
                    "Greedy",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution(object):\\n    def countGood(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        elements_in_current_window=dict()\\n        pair_count=0\\n        start=0\\n        end=0\\n        ans=0\\n        while(end<len(nums)):\\n            if(elements_in_current_window.has_key(nums[end])):\\n                elements_in_current_window[nums[end]]+=1 #incrementing \\n            else:\\n                elements_in_current_window[nums[end]]=1 #initializing entry in the dictionary\\n            pair_count+=elements_in_current_window[nums[end]]-1 #counting number of pairs\\n            while pair_count>=k: #The shrinking phase\\n                ans+=1+len(nums)-end-1 #the number of new sequences\\n                elements_in_current_window[nums[start]]-=1 #remove the element at the starting of the window\\n                pair_count-=elements_in_current_window[nums[start]]\\n                start+=1\\n            end+=1    \\n        return ans            \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3791672,
                "title": "c-using-sliding-window-t-c-o-n-s-c-o-n",
                "content": "```\\nclass Solution {\\n    \\n    /*\\n        Time Complexity : O(N)\\n        Space Complexity : O(N)\\n    */\\n    \\npublic:\\n    long long countGood(vector<int>& nums, int k) {\\n        long long res = 0, start = 0, end = 0;\\n        int pairCount = 0, n = nums.size();\\n        unordered_map<int, int> m1;\\n        \\n        while(end < nums.size()){\\n            pairCount += m1[nums[end]];\\n            m1[nums[end]]++;\\n            \\n            // When condition is satisfied, we try to shrink the window reach its limit\\n            while(start < end && pairCount >= k){\\n                res += n-end;\\n                m1[nums[start]]--;\\n                pairCount -= m1[nums[start]];\\n                start++;\\n            }\\n            \\n            end++;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    \\n    /*\\n        Time Complexity : O(N)\\n        Space Complexity : O(N)\\n    */\\n    \\npublic:\\n    long long countGood(vector<int>& nums, int k) {\\n        long long res = 0, start = 0, end = 0;\\n        int pairCount = 0, n = nums.size();\\n        unordered_map<int, int> m1;\\n        \\n        while(end < nums.size()){\\n            pairCount += m1[nums[end]];\\n            m1[nums[end]]++;\\n            \\n            // When condition is satisfied, we try to shrink the window reach its limit\\n            while(start < end && pairCount >= k){\\n                res += n-end;\\n                m1[nums[start]]--;\\n                pairCount -= m1[nums[start]];\\n                start++;\\n            }\\n            \\n            end++;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3571717,
                "title": "sliding-window-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& nums, int k) {\\n        long long ans = 0;\\n        long long cur = 0;\\n        map<int, int> cnt;\\n        for (int i = 0, j = 0; i < nums.size(); i++) {\\n            while (j < nums.size() && cur < k) {\\n                cur += cnt[nums[j]]++;\\n                j++;\\n            }\\n            if (cur >= k) {\\n                ans += nums.size() - j + 1;\\n            }\\n            cur -= --cnt[nums[i]];\\n        }\\n        return ans;\\n    }\\n};\\nDO UPVOTE if you like\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& nums, int k) {\\n        long long ans = 0;\\n        long long cur = 0;\\n        map<int, int> cnt;\\n        for (int i = 0, j = 0; i < nums.size(); i++) {\\n            while (j < nums.size() && cur < k) {\\n                cur += cnt[nums[j]]++;\\n                j++;\\n            }\\n            if (cur >= k) {\\n                ans += nums.size() - j + 1;\\n            }\\n            cur -= --cnt[nums[i]];\\n        }\\n        return ans;\\n    }\\n};\\nDO UPVOTE if you like\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3095295,
                "title": "c-solution-sliding-window",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& nums, int k) {\\n        unordered_map<int,int> mp;\\n        int l=nums.size(),temp=0,j=0;\\n        long long ans=0;\\n        for(int i=0;i<l;i++){\\n            if(mp.find(nums[i])==mp.end() || mp[nums[i]]==0){\\n                \\n                mp[nums[i]]=1;\\n            }\\n            else{\\n                int p=(mp[nums[i]]*(mp[nums[i]]-1))/2;\\n                mp[nums[i]]+=1;\\n                temp+=((mp[nums[i]]*(mp[nums[i]]-1))/2)-p;\\n                \\n            }\\n            while(temp>=k){\\n                \\n                int pr=(mp[nums[j]]*(mp[nums[j]]-1))/2;\\n                mp[nums[j]]-=1;\\n                int cur=(mp[nums[j]]*(mp[nums[j]]-1))/2;\\n                temp-=(pr-cur);\\n                ans+=(l-i);\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& nums, int k) {\\n        unordered_map<int,int> mp;\\n        int l=nums.size(),temp=0,j=0;\\n        long long ans=0;\\n        for(int i=0;i<l;i++){\\n            if(mp.find(nums[i])==mp.end() || mp[nums[i]]==0){\\n                \\n                mp[nums[i]]=1;\\n            }\\n            else{\\n                int p=(mp[nums[i]]*(mp[nums[i]]-1))/2;\\n                mp[nums[i]]+=1;\\n                temp+=((mp[nums[i]]*(mp[nums[i]]-1))/2)-p;\\n                \\n            }\\n            while(temp>=k){\\n                \\n                int pr=(mp[nums[j]]*(mp[nums[j]]-1))/2;\\n                mp[nums[j]]-=1;\\n                int cur=(mp[nums[j]]*(mp[nums[j]]-1))/2;\\n                temp-=(pr-cur);\\n                ans+=(l-i);\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3063801,
                "title": "simple-solution-using-maps-c-with-simple-code",
                "content": "# Intuition\\nTake the window and if it satifies the condition add all the subarrays by extending to the right of it and shrink the window size.\\nif it does not satisfies extend the window size and check\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& arr, int k) \\n    {\\n        int n = arr.size();\\n        int pairs = 0;\\n        long long count = 0;\\n        \\n        map<int,int>freq;\\n        \\n        int i=0, j=0;\\n        while(1)\\n        {\\n            if(pairs >= k) \\n            {\\n                count += n-j+1;\\n\\n                pairs -= freq[arr[i]]-1;\\n                freq[arr[i]]--;\\n                i++;\\n            }\\n            else \\n            {\\n               if(j == n) break;\\n\\n               freq[arr[j]]++;\\n               pairs += freq[arr[j]]-1;\\n               j++;\\n            }   \\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& arr, int k) \\n    {\\n        int n = arr.size();\\n        int pairs = 0;\\n        long long count = 0;\\n        \\n        map<int,int>freq;\\n        \\n        int i=0, j=0;\\n        while(1)\\n        {\\n            if(pairs >= k) \\n            {\\n                count += n-j+1;\\n\\n                pairs -= freq[arr[i]]-1;\\n                freq[arr[i]]--;\\n                i++;\\n            }\\n            else \\n            {\\n               if(j == n) break;\\n\\n               freq[arr[j]]++;\\n               pairs += freq[arr[j]]-1;\\n               j++;\\n            }   \\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3053820,
                "title": "c-sliding-window-easy-understand-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& nums, int k) {\\n        long long int ans = 0;\\n        int i = 0, j = 0, n = nums.size();\\n        unordered_map<int,int> mp;\\n        long long int x = 0;\\n        while(i<n){\\n            mp[nums[i]]++;\\n            x += (mp[nums[i]]-1);\\n            while(x>=k){\\n                x -= (mp[nums[j]]-1);\\n                mp[nums[j++]]--;\\n                ans += (n-i);\\n                // cout<<\"# \"<<(n-i);\\n            }\\n            i++;\\n        }\\n        return ans;\\n    }\\n};```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Hash Table",
                    "Sliding Window",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& nums, int k) {\\n        long long int ans = 0;\\n        int i = 0, j = 0, n = nums.size();\\n        unordered_map<int,int> mp;\\n        long long int x = 0;\\n        while(i<n){\\n            mp[nums[i]]++;\\n            x += (mp[nums[i]]-1);\\n            while(x>=k){\\n                x -= (mp[nums[j]]-1);\\n                mp[nums[j++]]--;\\n                ans += (n-i);\\n                // cout<<\"# \"<<(n-i);\\n            }\\n            i++;\\n        }\\n        return ans;\\n    }\\n};```",
                "codeTag": "C++"
            },
            {
                "id": 3053530,
                "title": "java-sliding-window-variables-size-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSLIDING WINDOW VARIABLE SIZE\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTHIS IS A VARIATION OF VARIABLE SIZE SLIDING WINDOW.\\nSOLVED USING HASHMAP.\\n\\n# Code\\n```\\nclass Solution {\\n    public long countGood(int[] nums, int k) {\\n        \\n        int n=nums.length;\\n        long ans=0;\\n        long c=0;\\n            \\n        HashMap<Integer,Integer> mp=new HashMap<>();\\n        int i=0;int j=0;\\n      \\n        while(j<n){\\n            \\n            if(mp.containsKey(nums[j])==false){\\n                mp.put(nums[j],1);\\n            }else{\\n                mp.put(nums[j],mp.get(nums[j])+1);\\n               \\n            }\\n            c+=mp.get(nums[j])-1;\\n//count the pairs (whenever there will be pair it\\'s value will be 2 and we will get 1 pair so we are subtracting (2-1)=1)\\n//then sliding window  will be applied \\n//till the count of pairs are greater then equal to k \\n //we will loop through and slide the intial element and decrease the count and calculate the ans\\n                \\n                while(c>=k){//run till we have the least pairs\\n                    \\n                    ans+=(n-j);\\n                    int icount=mp.get(nums[i]);\\n                    c-=icount-1;//new count \\n                    \\n                    \\n                    \\n                        mp.put(nums[i],mp.get(nums[i])-1);\\n // decrease the count of element once calculated            \\n                    \\n                    if(mp.get(nums[i])==0)mp.remove(nums[i]);\\n//removing the element whose cout is zero now \\n                    \\n                    i++;\\n                }\\n                j++;\\n                \\n                \\n            }\\n       \\n        return ans;\\n        \\n        \\n    }\\n   \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Ordered Map",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public long countGood(int[] nums, int k) {\\n        \\n        int n=nums.length;\\n        long ans=0;\\n        long c=0;\\n            \\n        HashMap<Integer,Integer> mp=new HashMap<>();\\n        int i=0;int j=0;\\n      \\n        while(j<n){\\n            \\n            if(mp.containsKey(nums[j])==false){\\n                mp.put(nums[j],1);\\n            }else{\\n                mp.put(nums[j],mp.get(nums[j])+1);\\n               \\n            }\\n            c+=mp.get(nums[j])-1;\\n//count the pairs (whenever there will be pair it\\'s value will be 2 and we will get 1 pair so we are subtracting (2-1)=1)\\n//then sliding window  will be applied \\n//till the count of pairs are greater then equal to k \\n //we will loop through and slide the intial element and decrease the count and calculate the ans\\n                \\n                while(c>=k){//run till we have the least pairs\\n                    \\n                    ans+=(n-j);\\n                    int icount=mp.get(nums[i]);\\n                    c-=icount-1;//new count \\n                    \\n                    \\n                    \\n                        mp.put(nums[i],mp.get(nums[i])-1);\\n // decrease the count of element once calculated            \\n                    \\n                    if(mp.get(nums[i])==0)mp.remove(nums[i]);\\n//removing the element whose cout is zero now \\n                    \\n                    i++;\\n                }\\n                j++;\\n                \\n                \\n            }\\n       \\n        return ans;\\n        \\n        \\n    }\\n   \\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3053399,
                "title": "two-pointer-approach",
                "content": "<!-- # warning \\nAs everyone has bombarded the logic  of sliding window i am also going to  tell the same logic with slight twist of words if you want some other approach leave and look other solution. -->\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n The basic idea  behind this solution is to use two pointers to iterate through the input vector, and maintain a map to keep track of the number of occurrences of each element. The left pointer is used to mark the start of the current subarray, and the right pointer is used to mark the end.\\n\\nincremnt the right pointer until you get the good subarray and each time duplicate elemnt get added it increases pair 1 less by its frequency\\n\\n***for e.g: 1 1 1\\n1 st 1 increases pairs count by 0\\n2 nd 1 increases pairs count by 1\\n3 rd 1 increases pairs count by 2***\\n\\nif current pairs get are greater than k then every subarray after that pointing which has same start will be good subarray.\\n\\n<!-- # Approach\\nDescribe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& nums, int k) {\\n        \\n        unordered_map<int,int> duplicate_count;\\n        int left=0,right=1,length=nums.size();\\n        long long current_pair=0,total_sub_array=0;\\n        duplicate_count[nums[left]]++;\\n\\n        while(right<length){\\n\\n            duplicate_count[nums[right]]++;\\n            current_pair+=(duplicate_count[nums[right]]-1);\\n\\n            while(left<length && current_pair>=k ){\\n\\n                total_sub_array+=(length-right);\\n\\n                duplicate_count[nums[left]]--;\\n                current_pair-=(duplicate_count[nums[left]]);\\n\\n                left++;\\n            }\\n\\n            right++;\\n\\n        }\\n\\n        return total_sub_array;\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& nums, int k) {\\n        \\n        unordered_map<int,int> duplicate_count;\\n        int left=0,right=1,length=nums.size();\\n        long long current_pair=0,total_sub_array=0;\\n        duplicate_count[nums[left]]++;\\n\\n        while(right<length){\\n\\n            duplicate_count[nums[right]]++;\\n            current_pair+=(duplicate_count[nums[right]]-1);\\n\\n            while(left<length && current_pair>=k ){\\n\\n                total_sub_array+=(length-right);\\n\\n                duplicate_count[nums[left]]--;\\n                current_pair-=(duplicate_count[nums[left]]);\\n\\n                left++;\\n            }\\n\\n            right++;\\n\\n        }\\n\\n        return total_sub_array;\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3052752,
                "title": "python3-solution-100-faster-sliding-window",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def countGood(self, A: List[int], k: int) -> int:\\n        D = defaultdict(int)\\n        ans = cnt = l = 0\\n        for i in A:\\n            cnt += D[i]\\n            D[i] += 1\\n            while cnt >= k:\\n                D[A[l]] -= 1\\n                cnt -= D[A[l]]\\n                l += 1\\n            ans += l\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def countGood(self, A: List[int], k: int) -> int:\\n        D = defaultdict(int)\\n        ans = cnt = l = 0\\n        for i in A:\\n            cnt += D[i]\\n            D[i] += 1\\n            while cnt >= k:\\n                D[A[l]] -= 1\\n                cnt -= D[A[l]]\\n                l += 1\\n            ans += l\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3052742,
                "title": "two-pointers-java",
                "content": "# Intuition and Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe number of subarrays that have atleast k pairs that ends at a particular index(r) will be equal to l, where [l..r] is the smallest subarray with atleast k pairs ending at r.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long countGood(int[] nums, int k) {\\n        int n = nums.length;\\n        Map<Integer, Integer> freq = new HashMap<>();\\n        long count = 0;\\n        int l = 0;\\n        long ans=0;\\n        for(int r=0;r<n;r++) {\\n            int curr = nums[r];\\n            int currFreq = freq.getOrDefault(nums[r], 0);\\n            count+=currFreq;\\n            freq.put(nums[r], currFreq+1);\\n            while(count >= k) {\\n                count = count - (freq.get(nums[l])-1);\\n                freq.put(nums[l], freq.get(nums[l])-1);\\n                l++;\\n            }\\n            ans+=l;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long countGood(int[] nums, int k) {\\n        int n = nums.length;\\n        Map<Integer, Integer> freq = new HashMap<>();\\n        long count = 0;\\n        int l = 0;\\n        long ans=0;\\n        for(int r=0;r<n;r++) {\\n            int curr = nums[r];\\n            int currFreq = freq.getOrDefault(nums[r], 0);\\n            count+=currFreq;\\n            freq.put(nums[r], currFreq+1);\\n            while(count >= k) {\\n                count = count - (freq.get(nums[l])-1);\\n                freq.put(nums[l], freq.get(nums[l])-1);\\n                l++;\\n            }\\n            ans+=l;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3775153,
                "title": "c-4lines-super-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& nums, int k) \\n    {\\n        long long i=0,j=0,ans=0,n=nums.size();\\n        unordered_map<int,int>count;\\n        for(;j<n;j++)\\n        {\\n            k-=count[nums[j]]++;\\n            while(k<=0)\\n            k+= --count[nums[i++]];\\n            ans+=i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& nums, int k) \\n    {\\n        long long i=0,j=0,ans=0,n=nums.size();\\n        unordered_map<int,int>count;\\n        for(;j<n;j++)\\n        {\\n            k-=count[nums[j]]++;\\n            while(k<=0)\\n            k+= --count[nums[i++]];\\n            ans+=i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495872,
                "title": "very-easy-solution-java-sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long countGood(int[] nums, int k) {\\n        HashMap<Integer,Integer>map=new HashMap<>();\\n        int i=0;\\n        int j=0;\\n        long count=0;\\n        long ans=0;\\n\\n        while(j<nums.length){\\n            map.put(nums[j],map.getOrDefault(nums[j],0)+1);\\n            count+=map.get(nums[j])-1;\\n\\n            while(count>=k){\\n                ans+=nums.length-j;\\n                count-=map.get(nums[i])-1;\\n                map.put(nums[i],map.getOrDefault(nums[i],0)-1);\\n\\n                if(map.get(nums[i])==0){\\n                    map.remove(nums[i]);\\n                }\\n                i++;\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long countGood(int[] nums, int k) {\\n        HashMap<Integer,Integer>map=new HashMap<>();\\n        int i=0;\\n        int j=0;\\n        long count=0;\\n        long ans=0;\\n\\n        while(j<nums.length){\\n            map.put(nums[j],map.getOrDefault(nums[j],0)+1);\\n            count+=map.get(nums[j])-1;\\n\\n            while(count>=k){\\n                ans+=nums.length-j;\\n                count-=map.get(nums[i])-1;\\n                map.put(nums[i],map.getOrDefault(nums[i],0)-1);\\n\\n                if(map.get(nums[i])==0){\\n                    map.remove(nums[i]);\\n                }\\n                i++;\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3066856,
                "title": "c-easy-to-understand-sliding-window-solution-with-inline-comments",
                "content": "```\\nclass Solution\\n{\\n    public:\\n        long long countGood(vector<int> &nums, int k)\\n        {\\n            if(nums.size()<2)return 0; //If only one member, then no pair is possible\\n            map<int, int> mp; // To keep the count of elements in the sliding window.\\n            int left = 0, right = 1; //Mark the initial window\\n\\n            mp[nums[left]]++;\\n            mp[nums[right]]++; //Count the numbers in the window.\\n\\n            long long ans = 0, //Tracks the answer.\\n            count = 0;  //Tracks the number of good pairs in the current window.\\n            for (auto it = mp.begin(); it != mp.end(); it++) \\n            {\\n                count += func(it->second);  //calculate number of good pairs in Initial window (nC2)\\n            }\\n            \\n            while (left <= right && right<nums.size()) //Condition to terminate the process\\n            {\\n                if (count >= k) \\n                {\\n                    ans += (nums.size() - right); //Because, all substrings with all the trailing postfixes in right side of the window will make good subarrays.\\n                    count -= func(mp[nums[left]]); //Count out left number\\'s contribution before update.\\n                    mp[nums[left]]--; //Reduce the left number\\'s count.\\n                    count += func(mp[nums[left]]); //Re-add left number\\'s contribution with updated nums[left].\\n                    left++; //Move left marker 1 index right.\\n                    while (left < right && count >= k) //Unless count is less than target (K), we can add all subarrays in the answer. \\n                    {\\n                        ans += (nums.size() - right);\\n                        count -= func(mp[nums[left]]);\\n                        mp[nums[left]]--;\\n                        count += func(mp[nums[left]]);\\n                        left++;\\n                    }\\n                }\\n                else\\n                {\\n                    right++;\\n                    if (right < nums.size()) //Adjust count value.\\n                    {\\n                        count -= func(mp[nums[right]]);\\n                        mp[nums[right]]++;\\n                        count += func(mp[nums[right]]);\\n                    }\\n                    while (count < k && right + 1 < nums.size()) //We move right unless count is greater than or equal to target (K)\\n                    {\\n                        right++;\\n                        count -= func(mp[nums[right]]);\\n                        mp[nums[right]]++;\\n                        count += func(mp[nums[right]]);\\n                    }\\n                }\\n            }\\n            return ans;\\n        }\\n\\n    long long func(long long val) // calculagte nC2 value.\\n    {\\n        if (val < 2) return 0;\\n        return (val *(val - 1)) / 2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n        long long countGood(vector<int> &nums, int k)\\n        {\\n            if(nums.size()<2)return 0; //If only one member, then no pair is possible\\n            map<int, int> mp; // To keep the count of elements in the sliding window.\\n            int left = 0, right = 1; //Mark the initial window\\n\\n            mp[nums[left]]++;\\n            mp[nums[right]]++; //Count the numbers in the window.\\n\\n            long long ans = 0, //Tracks the answer.\\n            count = 0;  //Tracks the number of good pairs in the current window.\\n            for (auto it = mp.begin(); it != mp.end(); it++) \\n            {\\n                count += func(it->second);  //calculate number of good pairs in Initial window (nC2)\\n            }\\n            \\n            while (left <= right && right<nums.size()) //Condition to terminate the process\\n            {\\n                if (count >= k) \\n                {\\n                    ans += (nums.size() - right); //Because, all substrings with all the trailing postfixes in right side of the window will make good subarrays.\\n                    count -= func(mp[nums[left]]); //Count out left number\\'s contribution before update.\\n                    mp[nums[left]]--; //Reduce the left number\\'s count.\\n                    count += func(mp[nums[left]]); //Re-add left number\\'s contribution with updated nums[left].\\n                    left++; //Move left marker 1 index right.\\n                    while (left < right && count >= k) //Unless count is less than target (K), we can add all subarrays in the answer. \\n                    {\\n                        ans += (nums.size() - right);\\n                        count -= func(mp[nums[left]]);\\n                        mp[nums[left]]--;\\n                        count += func(mp[nums[left]]);\\n                        left++;\\n                    }\\n                }\\n                else\\n                {\\n                    right++;\\n                    if (right < nums.size()) //Adjust count value.\\n                    {\\n                        count -= func(mp[nums[right]]);\\n                        mp[nums[right]]++;\\n                        count += func(mp[nums[right]]);\\n                    }\\n                    while (count < k && right + 1 < nums.size()) //We move right unless count is greater than or equal to target (K)\\n                    {\\n                        right++;\\n                        count -= func(mp[nums[right]]);\\n                        mp[nums[right]]++;\\n                        count += func(mp[nums[right]]);\\n                    }\\n                }\\n            }\\n            return ans;\\n        }\\n\\n    long long func(long long val) // calculagte nC2 value.\\n    {\\n        if (val < 2) return 0;\\n        return (val *(val - 1)) / 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3063655,
                "title": "c-full-explanation-with-intuition",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFind the minimum length of a subarray with valid pairs >= k. We can do this using sliding window approach.\\n1. start from the leftmost 0 index.\\n2. Keep expanding to the right using end pointer till pairs < k;\\n3. Keep contracting the start pointer till pairs >= k;\\n4. Now just calculate the number of subarrays that can be formed    using the min Length subarray that we just found (array between start and end).\\n5. Example ---   0 1 2 3 4 5 6 7 <-- Indexes\\nArray Given: 3,1,4,3,2,2,4,1\\n \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n**FIRST LOOP**\\nstart = 0,end = 0, k = 2;\\nend = 5 when k = 2\\nIf we contract start then k becomes 1 at index 1.\\nSo the position we have currently is start = 1 and end = 5.\\nSo the subarray possible with start = 0 and end = 5 are [0,5],[0,6] and [0,7];\\n\\n**SECOND LOOP**\\nstart = 1, end = 6 , again we get k = 2 so expanding stops\\nTrying to contract \\nstart = 2 (still k = 2)\\nstart = 3 (k becomes 1 so we stop contracting)\\n\\nSubarray possible with start = 2 and end = 6\\n[0,6],[0,7]   , [1,6],[1,7] , [2,6],[2,7] \\n\\nNote: [0,6] and [0,7] are already covered in the first loop.\\nSo we just add subarray starting from 1 and 2.\\n\\n**THIRD LOOP**\\nstart = 3 , end = 6\\nend reaches the end of the array but k remains 1.\\nSo nothing :)\\n\\n\\n# Complexity\\n- Time complexity: O (N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& nums, int k) {\\n        int start = 0;\\n        int end = 0;\\n        unordered_map<ll int,ll int> freq;\\n        ll int pairsFound = 0;\\n        int length = nums.size();\\n        ll int totalSub = 0;\\n\\n        while(end<length){\\n            int num = nums[end];\\n            ll int pairsBefore = (freq[num]*(freq[num]-1))/2;\\n            freq[num]++;\\n            ll int pairsAfter = (freq[num]*(freq[num]-1))/2;\\n            pairsFound -= pairsBefore;\\n            pairsFound += pairsAfter;\\n\\n            int prevIndex = start;\\n            while(pairsFound>=k){\\n                int startNum = nums[start];\\n                ll int pairsBefore = (freq[startNum]*(freq[startNum]-1))/2;\\n                freq[startNum]--;\\n                ll int pairsAfter = (freq[startNum]*(freq[startNum]-1))/2;\\n                \\n                pairsFound -= pairsBefore;\\n                pairsFound += pairsAfter;\\n                start++;\\n            }\\n            totalSub += (start==prevIndex+1?(length-end):((start-prevIndex)*(length-end)));\\n            end++;\\n        }\\n        return totalSub;\\n    }\\n};\\n/*\\n3,1,4,3,2,2,4\\n*/\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& nums, int k) {\\n        int start = 0;\\n        int end = 0;\\n        unordered_map<ll int,ll int> freq;\\n        ll int pairsFound = 0;\\n        int length = nums.size();\\n        ll int totalSub = 0;\\n\\n        while(end<length){\\n            int num = nums[end];\\n            ll int pairsBefore = (freq[num]*(freq[num]-1))/2;\\n            freq[num]++;\\n            ll int pairsAfter = (freq[num]*(freq[num]-1))/2;\\n            pairsFound -= pairsBefore;\\n            pairsFound += pairsAfter;\\n\\n            int prevIndex = start;\\n            while(pairsFound>=k){\\n                int startNum = nums[start];\\n                ll int pairsBefore = (freq[startNum]*(freq[startNum]-1))/2;\\n                freq[startNum]--;\\n                ll int pairsAfter = (freq[startNum]*(freq[startNum]-1))/2;\\n                \\n                pairsFound -= pairsBefore;\\n                pairsFound += pairsAfter;\\n                start++;\\n            }\\n            totalSub += (start==prevIndex+1?(length-end):((start-prevIndex)*(length-end)));\\n            end++;\\n        }\\n        return totalSub;\\n    }\\n};\\n/*\\n3,1,4,3,2,2,4\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3062300,
                "title": "swift-solution-simple-and-easy-to-understand",
                "content": "# Approach\\n1. We use a HashMap to keep track of the number of times we have seen a particular number.\\n2. We keep a count variable that keeps track of the number of duplicates we have seen.\\n3. We use the two pointer technique to count the number of pairs we have for a given window.\\n4. If we have seen k duplicates, then we add the number of elements we have not yet seen to the answer.\\n5. If we have seen more than k duplicates, we move the left pointer to the right and subtract the number of duplicates we have seen for that number.\\n6. If we have seen less than k duplicates, we move the right pointer to the right. \\n\\n<hr>\\n\\n# Explanation\\n1. Calculate the number of subarrays with at most K distinct numbers.\\n2. If we know the number of subarrays with at most K distinct numbers, we can calculate the number of subarrays with exactly K distinct numbers. \\n\\n<hr>\\n\\n> The number of subarrays with at most K distinct numbers is equal to the number of subarrays with exactly K distinct numbers minus the number of subarrays with exactly K-1 distinct numbers. \\n\\n> Note that we can calculate the number of subarrays with exactly K distinct numbers by subtracting the number of subarrays with at most K-1 distinct numbers from the number of subarrays with at most K distinct numbers.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution \\n{\\n    // Explanation: we use a sliding window to count the number of bad elements in the window. If the number of bad elements is greater than k, we move the left pointer to the right until the number of bad elements is less than k. We add the number of elements in the window to the answer.\\n    func countGood(_ nums: [Int], _ k: Int) -> Int {\\n        var j=0\\n        var i=0\\n        var ans=0\\n        var count=0\\n        // key is the number, value is the number of times it appears in the window\\n        var hm=Dictionary<Int,Int>()\\n        // we move the right pointer to the right\\n        while(j<nums.count){\\n            // we add the number of times the number appears in the window\\n            hm[nums[j]]=(hm[nums[j]] ?? 0)+1\\n            // if the number of times the number appears in the window is greater than 1, we add it to the count\\n            count += hm[nums[j]]! - 1\\n            // if the number of bad elements is greater than k, we move the left pointer to the right\\n            while(count>=k){\\n                // we add the number of elements in the window to the answer\\n                ans += (nums.count - j)\\n                // we remove the number of times the number appears in the window\\n                let lf = hm[nums[i]]\\n                // we subtract the number of times the number appears in the window from the count\\n                count-=lf!-1\\n                // we remove the number of times the number appears in the window\\n                hm[nums[i]] = hm[nums[i]]! - 1\\n                // if the number of times the number appears in the window is 0, we remove it from the hashmap\\n                if(hm[nums[i]]==0)\\n                // we remove the number of times the number appears in the window\\n                {\\n                    hm.removeValue(forKey: nums[i])  \\n                    //  print(hm)\\n                }            \\n                i+=1\\n            }\\n            j+=1\\n        }\\n        return ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution \\n{\\n    // Explanation: we use a sliding window to count the number of bad elements in the window. If the number of bad elements is greater than k, we move the left pointer to the right until the number of bad elements is less than k. We add the number of elements in the window to the answer.\\n    func countGood(_ nums: [Int], _ k: Int) -> Int {\\n        var j=0\\n        var i=0\\n        var ans=0\\n        var count=0\\n        // key is the number, value is the number of times it appears in the window\\n        var hm=Dictionary<Int,Int>()\\n        // we move the right pointer to the right\\n        while(j<nums.count){\\n            // we add the number of times the number appears in the window\\n            hm[nums[j]]=(hm[nums[j]] ?? 0)+1\\n            // if the number of times the number appears in the window is greater than 1, we add it to the count\\n            count += hm[nums[j]]! - 1\\n            // if the number of bad elements is greater than k, we move the left pointer to the right\\n            while(count>=k){\\n                // we add the number of elements in the window to the answer\\n                ans += (nums.count - j)\\n                // we remove the number of times the number appears in the window\\n                let lf = hm[nums[i]]\\n                // we subtract the number of times the number appears in the window from the count\\n                count-=lf!-1\\n                // we remove the number of times the number appears in the window\\n                hm[nums[i]] = hm[nums[i]]! - 1\\n                // if the number of times the number appears in the window is 0, we remove it from the hashmap\\n                if(hm[nums[i]]==0)\\n                // we remove the number of times the number appears in the window\\n                {\\n                    hm.removeValue(forKey: nums[i])  \\n                    //  print(hm)\\n                }            \\n                i+=1\\n            }\\n            j+=1\\n        }\\n        return ans\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3058983,
                "title": "sliding-window-with-easily-understanding-comments",
                "content": "\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar countGood = function(nums, k) {\\n    let n = nums.length, window = {}, ans = 0, curr = 0, left = 0, right = 0;\\n    \\n    while(right < n){\\n        // we keep tracking the window between left and right\\n        // if the window has the the number on the right pointer\\n        // we increment the current pairs\\n        // Note: we increment curr before the number count in the window\\n        // example: [1, 1, 1] when left = 0, right = 2\\n        // window = { 1 : 2 }, curr = 1 (before the increment), curr = 3 (after the increment)\\n        if(window[nums[right]]){\\n            curr += window[nums[right]];\\n            window[nums[right]]++;\\n        }\\n        else{\\n            window[nums[right]] = 1;\\n        }\\n\\n        // when current pairs is greater than k, we need to shrink the window\\n        while(curr >= k){\\n            // this means there are good pairs\\n            // we need to substract the window[nums[left]] - 1 rather than window[nums[left]]\\n            // Using [1, 1, 1] to demonstrate, if left = 0, right = 2, k = 2, curr = 3\\n            // we substact curr by 2, means that there are only 3 - 2 = 1 good pair left \\n            if(window[nums[left]] > 1){\\n                curr -= window[nums[left]]-1;\\n            }\\n            // shirnking the window\\n            window[nums[left]]--;\\n            left++;\\n            \\n            // ans should increment the number of subarray starts from left\\n            ans += n - right;\\n        }\\n\\n        right++;\\n    }\\n\\n    return ans;\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar countGood = function(nums, k) {\\n    let n = nums.length, window = {}, ans = 0, curr = 0, left = 0, right = 0;\\n    \\n    while(right < n){\\n        // we keep tracking the window between left and right\\n        // if the window has the the number on the right pointer\\n        // we increment the current pairs\\n        // Note: we increment curr before the number count in the window\\n        // example: [1, 1, 1] when left = 0, right = 2\\n        // window = { 1 : 2 }, curr = 1 (before the increment), curr = 3 (after the increment)\\n        if(window[nums[right]]){\\n            curr += window[nums[right]];\\n            window[nums[right]]++;\\n        }\\n        else{\\n            window[nums[right]] = 1;\\n        }\\n\\n        // when current pairs is greater than k, we need to shrink the window\\n        while(curr >= k){\\n            // this means there are good pairs\\n            // we need to substract the window[nums[left]] - 1 rather than window[nums[left]]\\n            // Using [1, 1, 1] to demonstrate, if left = 0, right = 2, k = 2, curr = 3\\n            // we substact curr by 2, means that there are only 3 - 2 = 1 good pair left \\n            if(window[nums[left]] > 1){\\n                curr -= window[nums[left]]-1;\\n            }\\n            // shirnking the window\\n            window[nums[left]]--;\\n            left++;\\n            \\n            // ans should increment the number of subarray starts from left\\n            ans += n - right;\\n        }\\n\\n        right++;\\n    }\\n\\n    return ans;\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3057587,
                "title": "java-sliding-window-100-solution",
                "content": "# Approach\\nSliding Window\\n- Two points: L , R -> The window is nums[L:R].\\n- Using HashMap cnt records every letter\\'s occurances.\\n- Iterate num from 0 to nums.length, put nums[R] into the HashMap cnt and update current pairs\\n```java []\\nif(cnt.get(nums[r]) >= 2) {\\n    pairs += cnt.get(nums[r]) - 1;\\n}\\n```\\n- If number of pairs larger than K, update result; move L point ahead and update cnt and pairs.\\n```java []\\nret += n - r;\\nif(cnt.get(nums[l]) >= 2) {\\n    pairs -= cnt.get(nums[l]) - 1;\\n}\\ncnt.put(nums[l], cnt.get(nums[l]) - 1);\\nl++;\\n```\\n- return ret\\n\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long countGood(int[] nums, int k) {\\n        long ret = 0, pairs = 0;\\n        int l = 0, r = 0, n = nums.length;\\n        //number, count\\n        HashMap<Integer, Integer> cnt = new HashMap<>();\\n        \\n        while(r < n) {\\n            cnt.put(nums[r], cnt.getOrDefault(nums[r], 0) + 1);\\n            if(cnt.get(nums[r]) >= 2) {\\n                pairs += cnt.get(nums[r]) - 1;\\n            }\\n\\n            while(pairs >= k) {\\n                ret += n - r;\\n                if(cnt.get(nums[l]) >= 2) {\\n                    pairs -= cnt.get(nums[l]) - 1;\\n                }\\n                cnt.put(nums[l], cnt.get(nums[l]) - 1);\\n                l++;\\n            }\\n\\n            r++;\\n        }\\n\\n        return ret;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```java []\\nif(cnt.get(nums[r]) >= 2) {\\n    pairs += cnt.get(nums[r]) - 1;\\n}\\n```\n```java []\\nret += n - r;\\nif(cnt.get(nums[l]) >= 2) {\\n    pairs -= cnt.get(nums[l]) - 1;\\n}\\ncnt.put(nums[l], cnt.get(nums[l]) - 1);\\nl++;\\n```\n```\\nclass Solution {\\n    public long countGood(int[] nums, int k) {\\n        long ret = 0, pairs = 0;\\n        int l = 0, r = 0, n = nums.length;\\n        //number, count\\n        HashMap<Integer, Integer> cnt = new HashMap<>();\\n        \\n        while(r < n) {\\n            cnt.put(nums[r], cnt.getOrDefault(nums[r], 0) + 1);\\n            if(cnt.get(nums[r]) >= 2) {\\n                pairs += cnt.get(nums[r]) - 1;\\n            }\\n\\n            while(pairs >= k) {\\n                ret += n - r;\\n                if(cnt.get(nums[l]) >= 2) {\\n                    pairs -= cnt.get(nums[l]) - 1;\\n                }\\n                cnt.put(nums[l], cnt.get(nums[l]) - 1);\\n                l++;\\n            }\\n\\n            r++;\\n        }\\n\\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3056312,
                "title": "sliding-window-solution-in-go",
                "content": "# Intuition\\nWe use a sliding window approach, where we count the number of pairs inside it. \\nWe count the number of good arrays by finding every minimal subarray that contains `k` or more pairs. (Minimal in the sense that the last element in the window is required to achieve the required number of pairs). Then we shorten the window from the beginning until it violates the condition. Each window we found in that way, is used as a prefix that fulfills the condition. So we add it and each of its extensions to the number of good arrays. An extension of a subarray means that the original subsarray is extended by one or more contiguous elements at its end. We can calculate the number of extensions to a subarrays directly as it is the number of elements between the end of the prefix and the end of the of the complete array. \\n\\n# Approach\\nTo count the pairs between the pointers we count the occurences of each number in a hash-map `cnts`.\\n\\nWe initialize the pointers `start` and `end` to 0. As long as `begin` is smaller than `end` we repeat the following:\\nWhen the number of pairs between the pointers is smaller tham `k`, we increment the end-pointer `end` until we have `k` or more pairs `begin` and `end` or `end` exceeds the list end. \\nBefore incrementing `end` we increment the count of the number `end` points to, i.e., `cnts[nums[end]]++`. If the newly added number is not the first occurence between the pointers, we add the number of the occurences to the number of pairs. And repeat this until we have `k` or more pairs. \\n\\nWhen this last inner loop is left before having `k` or more pairs, we know that `end` exceeded the end of nums before finding sufficient pairs. And so we return the counted number of good arrays.\\n\\nThen we add the bewly discovered number of good arrays to the overall count of good arrays.\\n\\nIn the next iteration of the outer loop, we enter the inner loop with incrementing `start` until the number of pairs between the pointers is strictly less than `k`. Therefore we reduce the occurence count of the number pointed by start and accordingly decreasing the number of pairs. In every iteration where after the increment of `start` the number of pairs is still greater than `k` we add the number of arrays to the overall good array count `res`.\\n\\nIn general the number of pairs between a number of elements `n` is calculated by the binomial $$\\\\binom{n}{2}$$. We dont need to implement this as the we achive the same result by setting it to 1 when we have two elements, and everytime we increase the count we just add the previous count of elements. Same when decreasing, but there we need to subtract first the count the of the elements.\\n\\nThe number of good arrays \\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(m)$$\\n\\nWhere $n$ is the length of `nums` and $m$ is the number of distinctive elements in `nums`. As (obviously) $m<=n$, one could say $O(n)$ for memory complexity, too.\\n\\n# Code\\n```\\n\\n\\nfunc countGood(nums []int, k int) int64 {\\n    begin, end := 0, 0\\n    pair_count := 0\\n    cnts := make(map[int]int)\\n    res := int64(0)\\n\\n    for begin<=end {\\n        for pair_count>=k {\\n            cnts[nums[begin]]--\\n            if cnts[nums[begin]]>=1 {\\n                pair_count -= cnts[nums[begin]]\\n            }\\n            begin++\\n            if pair_count>=k {\\n                res += int64(len(nums)-end+1)\\n            }\\n        }\\n\\n        for pair_count<k && end<len(nums) {\\n            if cnts[nums[end]]>=1 {\\n                pair_count +=  cnts[nums[end]]\\n            }\\n            cnts[nums[end]]++\\n            end++\\n        }\\n\\n        if pair_count<k {\\n            return res\\n        }\\n        res += int64(len(nums)-end+1)\\n\\n    }\\n\\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\n\\n\\nfunc countGood(nums []int, k int) int64 {\\n    begin, end := 0, 0\\n    pair_count := 0\\n    cnts := make(map[int]int)\\n    res := int64(0)\\n\\n    for begin<=end {\\n        for pair_count>=k {\\n            cnts[nums[begin]]--\\n            if cnts[nums[begin]]>=1 {\\n                pair_count -= cnts[nums[begin]]\\n            }\\n            begin++\\n            if pair_count>=k {\\n                res += int64(len(nums)-end+1)\\n            }\\n        }\\n\\n        for pair_count<k && end<len(nums) {\\n            if cnts[nums[end]]>=1 {\\n                pair_count +=  cnts[nums[end]]\\n            }\\n            cnts[nums[end]]++\\n            end++\\n        }\\n\\n        if pair_count<k {\\n            return res\\n        }\\n        res += int64(len(nums)-end+1)\\n\\n    }\\n\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3055923,
                "title": "java-sliding-window-detailed-explanation",
                "content": "# **IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE \\uD83D\\uDE4F**\\n<br>\\n\\nWe will solve this problem using Sliding Window.\\nBelow the code, I will explain the solution step-by-step in detail.\\n\\n# Code\\n```\\nclass Solution {\\n    public long countGood(int[] nums, int k) {\\n        \\n        int N = nums.length;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        long ans = 0;\\n        \\n        int l = 0, r;                   \\n        int pairs = 0;\\n        for (r = 0; r < N; ++r)\\n        {\\n            // Add value under r pointer\\n            int key = nums[r];\\n            map.put(key, map.getOrDefault(key, 0) + 1);\\n            pairs += map.get(key) - 1;\\n            \\n            // If the pairs in current subarray is enough\\n            if (pairs >= k)  \\n            {\\n                ans += N - r;\\n                \\n                // Shrink the window\\n                while (l < r && pairs >= k)\\n                {\\n                    // Move the left pointer\\n                    key = nums[l];\\n                    map.put(key, map.get(key) - 1);\\n                    pairs -= map.get(key);\\n                    l++;\\n                    \\n                    // See if new Good subarray appears\\n                    if (pairs >= k) ans += N - r;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n}\\n```\\n\\n---\\n\\n\\n\\n# Approach & Explanation\\n\\n1. Creating two pointers `l` & `r`. `r` is on the right for expanding the window, and `l` is on the left for contracting the window when a criteria meets.\\n\\n2. Using a `HashMap` to track the numbers within the window and their frequencies.\\n\\n3. Each time when moving the `r` pointer to the \"next index\", we add the number `Z` under that \"next index\" to the window. So we will add that number `Z` to the map, or increasing the frequency of that `Z` in the map, if its an existing key.\\n\\n4. Once adding a number `Z` to the window. By looking at its new frequency in the map, **we will know \"how many new pairs is added to the window by introducing the number Z\"**. \\n    - For example, if its new frequency is 1, it means the window doesn\\'t contain any number `Z` before. So introducing this number `Z` won\\'t add any pair. \\n\\n    - If its new frequency is 4, it means that the window contains 3 number `Z` before. So, by introducing this one more number `Z`, it will construct \"pair\" with each one of the 3 `Z` in the window. Thus, 3 new pairs is added to the window.\\n\\n5. We will have a variable `pairs` to keep tracking of the total number of pairs in the window\\n\\n6. Once the number of `pairs` in the window meets the \"required pairs number k\". We know that the current subarray under the window is a \"Good\" subarray. Now we have another question:\\n    - **How about the subarrays, which contain all index of the current subarray, and have more index to the right of the current subarray. Are they \"Good\" subarray too?**\\n\\n    - For example: **nums = [3,1,4,3,2,2,4,6], k = 2**, if the current subarry **[3,1,4,3,2,2]** is good. Is that means that **[3,1,4,3,2,2,4]** and **[3,1,4,3,2,2,4,6]** are also good subarrays? Yes!\\n\\n    - So, once we find a \"Good\" subarray, we not only want to count itself, but we want to count all the possible \"Good\" subarrays.\\n\\n7. Once we find a \"Good\" subarray, and it starts from `l` and ends at `r` pointers. What will happen if we shrink the window by moving the `l` pointer to its right? \\n\\n    - Let\\'s imagine: If the number pointed by `l` is not a number that makes up of any pairs in the window, after moving l to its right by one index, the number of pairs in the new window will remain unchanged. So, the new window is still a \"Good\" subarrays. Thus, by moving `l` pointer, it\\'s possible that we could find another new \"Good\" subarrays.\\n\\n    - For example: **nums = [3,1,4,3,2,2,4,6], k = 2**, if the current subarry **[1,4,3,2,2,4]** is good. By moving `l` pointer to shrink the window, we will get **[4,3,2,2,4]** which is also a new \"Good\" subarray.\\n\\n    - Because of the reason above, once we find out that the current subarray under the window is \"Good\", we will shrink the window by moving the `l` pointer. After each shrink by 1 index, we will check if new \"Good\" subarrays are created. We will keep moving the `l` pointer until the point that the new subarray is not \"Good\" anymore.\\n\\n8. When the new subarray is not \"Good\" anymore, we will resume the previous process of moving `r` pointer to expand the window.\\n\\n9. When the `r` pointer is at the end of the array, and no more \"Good\" subarrays are available. There\\'s no way for us to find more \"Good\" subarray by moving the `l` pointer, because it only shrinks the window and reducing pairs. So, we will end the program.\\n\\n---\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n), because we loop through the array \"nums\" in linear time. Yes, we have two pointers, so the actual time complexity would be ~O(2n).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(M), where \"M\" stands for the total number of unique numbers in \"nums\". \\n\\nIn the worst case, we can\\'t find any pair in the window, before the right pointer moves to the end of the array. So the maximum number of elements to be contained in the HashMap is M.\\n\\nTo be specific, the space complexity would be ~O(2M), 1 M for the key, another M for the value, in the hashmap.",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public long countGood(int[] nums, int k) {\\n        \\n        int N = nums.length;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        long ans = 0;\\n        \\n        int l = 0, r;                   \\n        int pairs = 0;\\n        for (r = 0; r < N; ++r)\\n        {\\n            // Add value under r pointer\\n            int key = nums[r];\\n            map.put(key, map.getOrDefault(key, 0) + 1);\\n            pairs += map.get(key) - 1;\\n            \\n            // If the pairs in current subarray is enough\\n            if (pairs >= k)  \\n            {\\n                ans += N - r;\\n                \\n                // Shrink the window\\n                while (l < r && pairs >= k)\\n                {\\n                    // Move the left pointer\\n                    key = nums[l];\\n                    map.put(key, map.get(key) - 1);\\n                    pairs -= map.get(key);\\n                    l++;\\n                    \\n                    // See if new Good subarray appears\\n                    if (pairs >= k) ans += N - r;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3055919,
                "title": "optimizing-the-approach-using-hashmap-with-timecomplexity-reducing-from-o-n-2-to-o-n",
                "content": "# Intuition\\nNaive approach with nested loop with T.C O(N^2).Optimized solution with sliding window with T.C O(N)\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/** \\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar countGood = function(nums, k) {\\n   Nested Loop:\\n   ------------\\n    /**\\n        T.C : O(N^2)\\n        S.C : O(N)\\n    */\\n    let goodSubArrayCount = 0;\\n    for(let i = 0; i < nums.length; i++) {\\n        let count = 0;\\n        const goodSubArray = new Map();\\n        goodSubArray.set(nums[i], 1);\\n        for(let j= i + 1; j < nums.length; j++) {\\n            if(goodSubArray.has(nums[j])) {\\n                goodSubArray.set(nums[j], goodSubArray.get(nums[j]) + 1);\\n                count += goodSubArray.get(nums[j]) - 1;\\n            } else {\\n                goodSubArray.set(nums[j], 1);\\n          }\\n\\n          if(count >= k) {\\n            goodSubArrayCount++;\\n          }\\n        }\\n    }\\n    return goodSubArrayCount;\\n\\n    Sliding Window:\\n    ---------------\\n    /**\\n        T.C : O(N)\\n        S.C : O(N)\\n        My own logic\\n    */\\n    \\n    let goodSubArrayCount = 0, frequencySet = new Map();\\n    let pairsCount = 0, j = 0, i = 0;\\n\\n    while(j < nums.length) {\\n        if(frequencySet.has(nums[j])) {\\n            pairsCount -= calculateFrequency(frequencySet.get(nums[j]));\\n            frequencySet.set(nums[j], frequencySet.get(nums[j]) + 1);\\n        } else {\\n            frequencySet.set(nums[j], 1);\\n        }\\n\\n        pairsCount += calculateFrequency(frequencySet.get(nums[j]));\\n        while(pairsCount >= k) {\\n            goodSubArrayCount += nums.length - j;\\n            pairsCount -= calculateFrequency(frequencySet.get(nums[i]));\\n            if(frequencySet.get(nums[i]) > 1) {\\n                frequencySet.set(nums[i], frequencySet.get(nums[i]) - 1);\\n                pairsCount += calculateFrequency(frequencySet.get(nums[i]));\\n            } else {\\n                frequencySet.delete(nums[i]);\\n            }\\n            i++;\\n        }\\n        j++;\\n    }\\n    return goodSubArrayCount;\\n};\\n\\n\\nvar calculateFrequency = function(frequencyCount) {\\n    return Math.floor((frequencyCount * (frequencyCount - 1)) / 2);\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Hash Table",
                    "Sliding Window"
                ],
                "code": "```\\n/** \\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar countGood = function(nums, k) {\\n   Nested Loop:\\n   ------------\\n    /**\\n        T.C : O(N^2)\\n        S.C : O(N)\\n    */\\n    let goodSubArrayCount = 0;\\n    for(let i = 0; i < nums.length; i++) {\\n        let count = 0;\\n        const goodSubArray = new Map();\\n        goodSubArray.set(nums[i], 1);\\n        for(let j= i + 1; j < nums.length; j++) {\\n            if(goodSubArray.has(nums[j])) {\\n                goodSubArray.set(nums[j], goodSubArray.get(nums[j]) + 1);\\n                count += goodSubArray.get(nums[j]) - 1;\\n            } else {\\n                goodSubArray.set(nums[j], 1);\\n          }\\n\\n          if(count >= k) {\\n            goodSubArrayCount++;\\n          }\\n        }\\n    }\\n    return goodSubArrayCount;\\n\\n    Sliding Window:\\n    ---------------\\n    /**\\n        T.C : O(N)\\n        S.C : O(N)\\n        My own logic\\n    */\\n    \\n    let goodSubArrayCount = 0, frequencySet = new Map();\\n    let pairsCount = 0, j = 0, i = 0;\\n\\n    while(j < nums.length) {\\n        if(frequencySet.has(nums[j])) {\\n            pairsCount -= calculateFrequency(frequencySet.get(nums[j]));\\n            frequencySet.set(nums[j], frequencySet.get(nums[j]) + 1);\\n        } else {\\n            frequencySet.set(nums[j], 1);\\n        }\\n\\n        pairsCount += calculateFrequency(frequencySet.get(nums[j]));\\n        while(pairsCount >= k) {\\n            goodSubArrayCount += nums.length - j;\\n            pairsCount -= calculateFrequency(frequencySet.get(nums[i]));\\n            if(frequencySet.get(nums[i]) > 1) {\\n                frequencySet.set(nums[i], frequencySet.get(nums[i]) - 1);\\n                pairsCount += calculateFrequency(frequencySet.get(nums[i]));\\n            } else {\\n                frequencySet.delete(nums[i]);\\n            }\\n            i++;\\n        }\\n        j++;\\n    }\\n    return goodSubArrayCount;\\n};\\n\\n\\nvar calculateFrequency = function(frequencyCount) {\\n    return Math.floor((frequencyCount * (frequencyCount - 1)) / 2);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3054959,
                "title": "python-2-pointers-with-counting",
                "content": "# Intuition\\nJust count frequency, add up pairs, when enough account to result current plus everything after (if condition is met then adding every element one by one after are also solutions), then move left pointer until rule is broken and not enough pairs.\\nRepeat this till end.\\n\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def countGood(self, A: List[int], k: int) -> int:\\n        N, count = len(A), Counter()\\n        L =  result = pair_count = 0\\n\\n        for i, v in enumerate(A):\\n            pair_count += count[v]\\n            count[v] += 1\\n            while L < i and pair_count >= k:\\n                result += N - i\\n                count[A[L]] -= 1\\n                pair_count -= count[A[L]]\\n                L += 1\\n        return result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def countGood(self, A: List[int], k: int) -> int:\\n        N, count = len(A), Counter()\\n        L =  result = pair_count = 0\\n\\n        for i, v in enumerate(A):\\n            pair_count += count[v]\\n            count[v] += 1\\n            while L < i and pair_count >= k:\\n                result += N - i\\n                count[A[L]] -= 1\\n                pair_count -= count[A[L]]\\n                L += 1\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3054137,
                "title": "c-sliding-window-easy-solution",
                "content": "# Intuition\\nThis problem is solved easily using a window sliding concept.Essentially we find number of subarray on each window in which number of pair is greater than k.\\n\\n# Approach\\nfor each window of size m we check number of pairs.if count of pair is greater than or equal to k then we count number of subarray which hold this condition.\\nfor example if n=nums.size() and s count total number of subarray in which number of pair is greater than or equal to k and we find a window in which number of pair is greater than or equal to k and  starting index of window is 0 and ending index of window is m(m<n) then s+=(n-m) and then we increment starting index of window and again follow the same procedure\\n\\n# Complexity\\n- Time complexity:\\n- n=length of nums\\nO(n)\\n\\n- Space complexity:\\n- n=length of nums\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& nums, int k) {\\n        long long int s=0;\\n        unordered_map<int,int> m;\\n        int c=0;\\n        int j=0;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            if(m.find(nums[i])!=m.end()){\\n                c+=m[nums[i]];\\n            }\\n            m[nums[i]]++;\\n            if(c>=k){\\n                s+=((long long)n-i);\\n                while(j<n&&c>=k){\\n                    if(m[nums[j]]>1){\\n                        c-=(m[nums[j]]-1);\\n                        \\n                    }\\n                    m[nums[j]]--;\\n                    if(m[nums[j]]==0){\\n                        m.erase(nums[j]);\\n                    }\\n                    if(c>=k){\\n                        s+=((long long)n-i);\\n                    }\\n                    j++;\\n                }\\n            }\\n            \\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& nums, int k) {\\n        long long int s=0;\\n        unordered_map<int,int> m;\\n        int c=0;\\n        int j=0;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            if(m.find(nums[i])!=m.end()){\\n                c+=m[nums[i]];\\n            }\\n            m[nums[i]]++;\\n            if(c>=k){\\n                s+=((long long)n-i);\\n                while(j<n&&c>=k){\\n                    if(m[nums[j]]>1){\\n                        c-=(m[nums[j]]-1);\\n                        \\n                    }\\n                    m[nums[j]]--;\\n                    if(m[nums[j]]==0){\\n                        m.erase(nums[j]);\\n                    }\\n                    if(c>=k){\\n                        s+=((long long)n-i);\\n                    }\\n                    j++;\\n                }\\n            }\\n            \\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3053757,
                "title": "sliding-window-technique-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach \\n<!-- Describe your approach to solving the problem. -->\\nSliding Window \\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n        public long countGood(int[] nums, int k) {\\n        long ans = 0;\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        int j = 0;\\n        long countPairs = 0;\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if (map.containsKey(nums[i])) {\\n\\n                int val = map.get(nums[i]);\\n                //to replace the  the previous pair with new pairs\\n                countPairs -= ((long) val * (val - 1) / 2);\\n                map.put(nums[i], map.get(nums[i]) + 1);\\n                 val = map.get(nums[i]);\\n                countPairs += ((long) val * (val - 1) / 2);\\n\\n            } else{\\n                map.put(nums[i], 1);\\n            }\\n            \\n            // System.out.println(countPairs);\\n             //sliding the window to right \\n            while (j <= i && countPairs >= k) {\\n                int cur = map.get(nums[j]);\\n                countPairs -= (long) cur * (cur - 1) / 2;\\n                map.put(nums[j], cur - 1);\\n                cur = map.get(nums[j]);\\n                countPairs += (long) (cur ) * (cur -1) / 2;\\n                j++;\\n                ans += (nums.length - i);\\n            }\\n\\n        }\\n        return ans;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n        public long countGood(int[] nums, int k) {\\n        long ans = 0;\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        int j = 0;\\n        long countPairs = 0;\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if (map.containsKey(nums[i])) {\\n\\n                int val = map.get(nums[i]);\\n                //to replace the  the previous pair with new pairs\\n                countPairs -= ((long) val * (val - 1) / 2);\\n                map.put(nums[i], map.get(nums[i]) + 1);\\n                 val = map.get(nums[i]);\\n                countPairs += ((long) val * (val - 1) / 2);\\n\\n            } else{\\n                map.put(nums[i], 1);\\n            }\\n            \\n            // System.out.println(countPairs);\\n             //sliding the window to right \\n            while (j <= i && countPairs >= k) {\\n                int cur = map.get(nums[j]);\\n                countPairs -= (long) cur * (cur - 1) / 2;\\n                map.put(nums[j], cur - 1);\\n                cur = map.get(nums[j]);\\n                countPairs += (long) (cur ) * (cur -1) / 2;\\n                j++;\\n                ans += (nums.length - i);\\n            }\\n\\n        }\\n        return ans;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3053653,
                "title": "easy-to-understand-with-note-c",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- find first good array\\n- find the shortest good array end by the left pointer [rightpointer, leftpointer]\\n- the number of new good array that added into the answer is the index of right pointer\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nboth pointers would not go back.\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\na map.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& nums, int k) {\\n        //at least k pairs\\n        //i < j and arr[i] == arr[j].\\n        unordered_map<int, int> window;\\n        int j = 0;\\n        int pair = 0;\\n        long long ans = 0;\\n        int i = 0;\\n        int len = 0;\\n        bool first_find = false;\\n        while (j < nums.size()){\\n            int current = nums[j];\\n            pair += window[current];\\n            window[current] ++;\\n            j ++;\\n            if (pair >= k){\\n                first_find = true;\\n                //after first find, every movement of j can construct some new good array\\n            }\\n            while (pair >= k ){\\n                int move = nums[i];\\n                window[move] --;\\n                pair -= window[move];\\n                i++;\\n                \\n            }\\n            //[i-1, ..., j-1] has exactly 2 pairs\\n            if (first_find){\\n                //current array [i-1, ... , j-1] + the number of array\\n                //([0, ..., j-1] + [1, ..., j-1] + ... + [i-2, ..., j-1])\\n                //total number is i\\n                ans += i;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& nums, int k) {\\n        //at least k pairs\\n        //i < j and arr[i] == arr[j].\\n        unordered_map<int, int> window;\\n        int j = 0;\\n        int pair = 0;\\n        long long ans = 0;\\n        int i = 0;\\n        int len = 0;\\n        bool first_find = false;\\n        while (j < nums.size()){\\n            int current = nums[j];\\n            pair += window[current];\\n            window[current] ++;\\n            j ++;\\n            if (pair >= k){\\n                first_find = true;\\n                //after first find, every movement of j can construct some new good array\\n            }\\n            while (pair >= k ){\\n                int move = nums[i];\\n                window[move] --;\\n                pair -= window[move];\\n                i++;\\n                \\n            }\\n            //[i-1, ..., j-1] has exactly 2 pairs\\n            if (first_find){\\n                //current array [i-1, ... , j-1] + the number of array\\n                //([0, ..., j-1] + [1, ..., j-1] + ... + [i-2, ..., j-1])\\n                //total number is i\\n                ans += i;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3053560,
                "title": "c-solution-sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& nums, int k) {\\n        long long n = nums.size();\\n        int curr = 0;\\n        long long res = 0;\\n        long long total = (n * (n + 1) / 2);\\n        unordered_map<int, int> cnt;\\n        int l = 0;\\n        for (int r = 0; r < n; r++) {\\n            if (cnt[nums[r]] > 0) {\\n                curr += cnt[nums[r]];\\n            }\\n            cnt[nums[r]]++;\\n            while (l <= r && curr >= k) {\\n                if (cnt[nums[l]] > 1) {\\n                    curr -= (cnt[nums[l]] - 1);\\n                }\\n                cnt[nums[l]]--;\\n                l++;\\n            }\\n            res += (r - l + 1);\\n        }\\n        return  total - res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& nums, int k) {\\n        long long n = nums.size();\\n        int curr = 0;\\n        long long res = 0;\\n        long long total = (n * (n + 1) / 2);\\n        unordered_map<int, int> cnt;\\n        int l = 0;\\n        for (int r = 0; r < n; r++) {\\n            if (cnt[nums[r]] > 0) {\\n                curr += cnt[nums[r]];\\n            }\\n            cnt[nums[r]]++;\\n            while (l <= r && curr >= k) {\\n                if (cnt[nums[l]] > 1) {\\n                    curr -= (cnt[nums[l]] - 1);\\n                }\\n                cnt[nums[l]]--;\\n                l++;\\n            }\\n            res += (r - l + 1);\\n        }\\n        return  total - res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3053249,
                "title": "c-easy-sliding-window",
                "content": "```\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& nums, int k) {\\n        \\n        #define int long long\\n        \\n        int res = 0;\\n        int j = 0, n = size(nums), gp = 0;\\n        \\n        unordered_map<int,int> map;\\n        \\n        for(int i = 0; i < n; i++){\\n            \\n            if(map.find(nums[i]) != map.end())gp += map[nums[i]];\\n            \\n            map[nums[i]]++;\\n            \\n            while(gp >= k){\\n                \\n                res += n-i;\\n                \\n                gp -= map[nums[j]]-1;\\n                map[nums[j]]--;\\n                \\n                j++;\\n            }\\n        }\\n        return res;\\n        \\n        #undef int\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& nums, int k) {\\n        \\n        #define int long long\\n        \\n        int res = 0;\\n        int j = 0, n = size(nums), gp = 0;\\n        \\n        unordered_map<int,int> map;\\n        \\n        for(int i = 0; i < n; i++){\\n            \\n            if(map.find(nums[i]) != map.end())gp += map[nums[i]];\\n            \\n            map[nums[i]]++;\\n            \\n            while(gp >= k){\\n                \\n                res += n-i;\\n                \\n                gp -= map[nums[j]]-1;\\n                map[nums[j]]--;\\n                \\n                j++;\\n            }\\n        }\\n        return res;\\n        \\n        #undef int\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3053088,
                "title": "c-solution-using-sliding-window-with-comments",
                "content": "```\\n#define ll long long\\n\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& arr, int k) {\\n        ll ans=0;\\n        int pairs=0,ln= arr.size();\\n        unordered_map<int ,int> count;\\n        \\n        for(int i=0,j=0; i<ln; i++){\\n            \\n            // to find max lenght for which pairs are less then k by increasing j(ie, right of sliding window)\\n            while(j<ln && pairs<k){\\n                pairs+= count[arr[j]];\\n                count[arr[j]]++;\\n                j++;\\n            }\\n            \\n            // once min length for k pairs is found ...rest of arr will also have atleast k pairs, so ans+= restOfLenght\\n            if(pairs< k)break;\\n            \\n            ans+= (ln-j +1);\\n            // incrementing i (ie, left of sliding window)\\n            count[arr[i]]--;\\n            pairs-= count[arr[i]];\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Hash Table",
                    "Sliding Window"
                ],
                "code": "```\\n#define ll long long\\n\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& arr, int k) {\\n        ll ans=0;\\n        int pairs=0,ln= arr.size();\\n        unordered_map<int ,int> count;\\n        \\n        for(int i=0,j=0; i<ln; i++){\\n            \\n            // to find max lenght for which pairs are less then k by increasing j(ie, right of sliding window)\\n            while(j<ln && pairs<k){\\n                pairs+= count[arr[j]];\\n                count[arr[j]]++;\\n                j++;\\n            }\\n            \\n            // once min length for k pairs is found ...rest of arr will also have atleast k pairs, so ans+= restOfLenght\\n            if(pairs< k)break;\\n            \\n            ans+= (ln-j +1);\\n            // incrementing i (ie, left of sliding window)\\n            count[arr[i]]--;\\n            pairs-= count[arr[i]];\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3052885,
                "title": "easiest-sliding-window-solution",
                "content": "```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& nums, int k) {\\n        \\n        ll n = nums.size();\\n        \\n        ll i=0;\\n        map<ll,ll>m;\\n        ll total = 0;\\n        ll j=0;\\n        ll ans = 0;\\n        map<ll,ll>check;\\n        \\n        while(j<n){\\n            \\n            m[nums[j]]++;\\n            ll curr = m[nums[j]]*(m[nums[j]]-1)/2;\\n           total += m[nums[j]]-1; \\n            while(i<j && total>=k){\\n                ans++;\\n                 ans += (n-j-1);\\n               total = total -  (m[nums[i]]-1);\\n                m[nums[i]]--;\\n               \\n                i++;\\n                \\n                \\n            }\\n            j++;\\n        }\\n        \\n         \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Hash Table",
                    "Sliding Window",
                    "Counting"
                ],
                "code": "```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& nums, int k) {\\n        \\n        ll n = nums.size();\\n        \\n        ll i=0;\\n        map<ll,ll>m;\\n        ll total = 0;\\n        ll j=0;\\n        ll ans = 0;\\n        map<ll,ll>check;\\n        \\n        while(j<n){\\n            \\n            m[nums[j]]++;\\n            ll curr = m[nums[j]]*(m[nums[j]]-1)/2;\\n           total += m[nums[j]]-1; \\n            while(i<j && total>=k){\\n                ans++;\\n                 ans += (n-j-1);\\n               total = total -  (m[nums[i]]-1);\\n                m[nums[i]]--;\\n               \\n                i++;\\n                \\n                \\n            }\\n            j++;\\n        }\\n        \\n         \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3052707,
                "title": "javascript-sliding-window",
                "content": "**Solution: Sliding Window**\\n\\nIf a subarray has at least `k` good pairs, then we know that expanding the subarray will always also result in at least `k` good pairs.\\nKeep track of the count of occurances of each number.\\nWe have two pointers `i` and `j` for our sliding window.\\n  * As we move `j` up, we will gain another `count[nums[j]]` good pairs.\\n  * Move `i` up while the good pairs >= `k`. When we move `i` up, we subtract `count[nums[i]] - 1` good pairs.\\n  * Then, we will know that all subarrays with start index between `0` and `i - 1`, and end index at `j` will have at least `k` good pairs.\\n\\nTime Complexity: `O(n)`\\nSpace Complexity: `O(n)`\\n```\\nvar countGood = function(nums, k) {\\n  let n = nums.length, count = {}, goodPairs = 0, ans = 0;\\n  for (let j = 0, i = 0; j < n; j++) {\\n    goodPairs += count[nums[j]] || 0;\\n    count[nums[j]] = (count[nums[j]] || 0) + 1;\\n    while (goodPairs >= k) {\\n      goodPairs -= --count[nums[i]];\\n      i++;\\n    }\\n    ans += i;\\n  }\\n  return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar countGood = function(nums, k) {\\n  let n = nums.length, count = {}, goodPairs = 0, ans = 0;\\n  for (let j = 0, i = 0; j < n; j++) {\\n    goodPairs += count[nums[j]] || 0;\\n    count[nums[j]] = (count[nums[j]] || 0) + 1;\\n    while (goodPairs >= k) {\\n      goodPairs -= --count[nums[i]];\\n      i++;\\n    }\\n    ans += i;\\n  }\\n  return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3052584,
                "title": "sliding-window-with-hashmap-c",
                "content": "# Approach\\nFirst of all, if there are multiple occurences of same number, we can create x pairs, and this x is the sum of first n natural numbers.\\nWhile moving our right pointer, whenever we find that the number of occurences of some characters are more than 2 then we will just add the number to the pairs.\\ne.g, previously we had 3 same numbers, but now we have 4 so we can just subtract the number of counted pairs of that number and add the current count.\\nwhenever we meet the condition which satifies the requirement, i.e, if counted pairs are more than or equal to k, we will count all the arrays in which this subarray is included, i.e, the number of elements between j and n. And, then move our left pointer accordingly.\\n\\nWhenever we are moving our left pointer, we are stopping j from being incremented, so we should not calculate for j again thats why I have added a boolean flagg.\\n\\n# Complexity\\n- Time complexity:O(n)\\n\\n- Space complexity:O(n)\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int sumOfN(int num){\\n        long long ans = ((long long)num * ((long long)num - 1))/2;\\n        return ans;\\n    }\\npublic:\\n    long long countGood(vector<int>& nums, int k) {\\n        int i=0,j=0;\\n        long long ans=0;\\n        long long n = nums.size();\\n        unordered_map<int,int> hm;\\n        int countPairs = 0;\\n        bool shoulddo = true;\\n        while(j<n){\\n            if(shoulddo){\\n                hm[nums[j]]++;\\n                if(hm[nums[j]] >= 2){\\n                    countPairs += hm[nums[j]] -1;\\n                }\\n            }\\n            shoulddo = true;\\n            if(countPairs>=k){\\n                ans += n - (long long)j;\\n                hm[nums[i]]--;\\n                if(hm[nums[i]] >= 1){\\n                    countPairs -= (hm[nums[i]]);\\n                }\\n                i++;\\n                j--;\\n                shoulddo = false;\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int sumOfN(int num){\\n        long long ans = ((long long)num * ((long long)num - 1))/2;\\n        return ans;\\n    }\\npublic:\\n    long long countGood(vector<int>& nums, int k) {\\n        int i=0,j=0;\\n        long long ans=0;\\n        long long n = nums.size();\\n        unordered_map<int,int> hm;\\n        int countPairs = 0;\\n        bool shoulddo = true;\\n        while(j<n){\\n            if(shoulddo){\\n                hm[nums[j]]++;\\n                if(hm[nums[j]] >= 2){\\n                    countPairs += hm[nums[j]] -1;\\n                }\\n            }\\n            shoulddo = true;\\n            if(countPairs>=k){\\n                ans += n - (long long)j;\\n                hm[nums[i]]--;\\n                if(hm[nums[i]] >= 1){\\n                    countPairs -= (hm[nums[i]]);\\n                }\\n                i++;\\n                j--;\\n                shoulddo = false;\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3052575,
                "title": "very-short-python-solution-sliding-window",
                "content": "```\\nclass Solution:\\n    def countGood(self, nums: List[int], k: int) -> int:\\n        res, cnt, l = 0, 0, 0\\n        hm = defaultdict(int)\\n        for r, v in enumerate(nums):\\n            hm[v] += 1\\n            cnt += hm[v] - 1\\n            while cnt >= k:\\n                hm[nums[l]] -= 1\\n                cnt -= hm[nums[l]]\\n                l += 1\\n            res += r - l + 1\\n        return (len(nums) + 1) * len(nums) // 2 - res\\n                \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countGood(self, nums: List[int], k: int) -> int:\\n        res, cnt, l = 0, 0, 0\\n        hm = defaultdict(int)\\n        for r, v in enumerate(nums):\\n            hm[v] += 1\\n            cnt += hm[v] - 1\\n            while cnt >= k:\\n                hm[nums[l]] -= 1\\n                cnt -= hm[nums[l]]\\n                l += 1\\n            res += r - l + 1\\n        return (len(nums) + 1) * len(nums) // 2 - res\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3052564,
                "title": "c-sliding-window-using-map",
                "content": "```\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& nums, int k) {\\n        long long ans=0;\\n        long long cnt=0;\\n        int i=0,j=0;\\n        map<int,int> mp;\\n        map<int,bool> m;\\n        while(i<nums.size()){\\n            if(m.find(i) == m.end()){\\n                mp[nums[i]] += 1;\\n                m[i] = true;\\n                int x = mp[nums[i]];\\n                if(x > 1){\\n                    cnt += (x-1);\\n                }\\n            }\\n            if(cnt >= k){\\n                ans += (nums.size() - i);\\n                int y = mp[nums[j]];\\n                if(y > 1){\\n                    cnt -= (y-1);\\n                }\\n                mp[nums[j]] -= 1;\\n                m.erase(j);\\n                j+=1;\\n            }else{\\n                i+=1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& nums, int k) {\\n        long long ans=0;\\n        long long cnt=0;\\n        int i=0,j=0;\\n        map<int,int> mp;\\n        map<int,bool> m;\\n        while(i<nums.size()){\\n            if(m.find(i) == m.end()){\\n                mp[nums[i]] += 1;\\n                m[i] = true;\\n                int x = mp[nums[i]];\\n                if(x > 1){\\n                    cnt += (x-1);\\n                }\\n            }\\n            if(cnt >= k){\\n                ans += (nums.size() - i);\\n                int y = mp[nums[j]];\\n                if(y > 1){\\n                    cnt -= (y-1);\\n                }\\n                mp[nums[j]] -= 1;\\n                m.erase(j);\\n                j+=1;\\n            }else{\\n                i+=1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4062779,
                "title": "sliding-window",
                "content": "# Intuition\\nWe want to squeeze the sliding window to be minimum width. While we squeezing it, every sliding window [i,j] means there are \\n\\n    nums.length - j\\n\\nnumber of subarray that meet the condition.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  int countGood(List<int> nums, int k) {\\n    HashMap<int, int> map = HashMap();\\n    var res = 0;\\n    var pairs = 0;\\n    var i = 0;\\n    for (int j = 0; j < nums.length; j++) {\\n      // new pairs contributed\\n      pairs += map[nums[j]] ?? 0;\\n      map[nums[j]] = (map[nums[j]] ?? 0) + 1;\\n      while (pairs >= k) {\\n        res += nums.length - j;\\n        map[nums[i]] = map[nums[i]]! - 1;\\n        pairs -= map[nums[i]]!;\\n        i++;\\n      }      \\n    }\\n    return res;\\n  }\\n}\\n\\n\\n\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  int countGood(List<int> nums, int k) {\\n    HashMap<int, int> map = HashMap();\\n    var res = 0;\\n    var pairs = 0;\\n    var i = 0;\\n    for (int j = 0; j < nums.length; j++) {\\n      // new pairs contributed\\n      pairs += map[nums[j]] ?? 0;\\n      map[nums[j]] = (map[nums[j]] ?? 0) + 1;\\n      while (pairs >= k) {\\n        res += nums.length - j;\\n        map[nums[i]] = map[nums[i]]! - 1;\\n        pairs -= map[nums[i]]!;\\n        i++;\\n      }      \\n    }\\n    return res;\\n  }\\n}\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4032546,
                "title": "java-fastest-rolling-window-answer-in-the-universe-with-the-absolute-best-explanation-genius-tier",
                "content": "# Intuition\\nI am actually a fool but I thought this approach was pretty nifty\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public long countGood(int[] nums, int k) {\\n        /**\\n            THIS IS A SLIDING WINDOW PROBLEM\\n            keep sliding right side of window until we reach\\n            the criteria\\n            then slide left side of window, keeping track of \\n            if we still match criteria\\n            then continue sliding right side of window\\n            until we reach end\\n\\n            tricky part of the problem is tracking the \\n            relationship between number of indexes\\n            with a particular value, and the associated\\n            number of matches IF that number of values \\n            is present\\n\\n            note that the relationship between number of \\n            indexes following initial index and the number\\n            of valid matches is prevNum + prevMatches\\n\\n            as a clearer example\\n            index:  0,1,2,3,4 ,5\\n            matches:0,1,3,6,10,15 \\n            this is because the sum of \\n\\n            start from window = 0,0\\n            move right side of window until we match criteria\\n            \"at least k pairs\" means once we match criteria\\n            then can add 1 + n-right to answer since\\n            regardless of contents of remaining window, \\n            the subarray will match criteria\\n\\n            after we reach above condition\\n            move left side of window right by one\\n            holding right side static\\n            decrementing index pairs by whatever\\n            the value is at that index\\n         */\\n        int n = nums.length;\\n        // matches map\\n        Map<Integer, int[]> matches = new HashMap<>();\\n        int l = 0; int r = 0;\\n        int numberOfMatchesInRollingWindow = 0;\\n        long a = 0;\\n        while(r < nums.length){\\n            if(matches.containsKey(nums[r])){\\n                int[] num = matches.get(nums[r]);\\n                // number of indexes with value\\n                int next = num[0]+1;\\n                // resulting number of matches\\n                // need to track this for incrementing\\n                //AND decrementing purposes\\n                int nextNum = num[1] + next;\\n\\n                // remove previous number of matches\\n                // for this value and add new\\n                numberOfMatchesInRollingWindow -= num[1];\\n                num[0] = next;\\n                num[1] = nextNum;\\n                numberOfMatchesInRollingWindow += nextNum;\\n            }else{\\n                // adding new index to map\\n                matches.put(nums[r], new int[]{0, 0});\\n            }\\n            while(numberOfMatchesInRollingWindow >= k){\\n                // this means we have found a subarray\\n                // with k values;\\n                // means we can add this subarray\\n                // plus the subarrays including all \\n                // subsequent indices\\n                a+=1;\\n                a+= n - r - 1;\\n                int[] num = matches.get(nums[l]);\\n                int next = num[0]-1;\\n                int nextNum = num[1] - num[0];\\n                if(next < 0 ){\\n                    // cleanup of value falling out of \\n                    // rolling window\\n                    matches.remove(nums[l]);\\n                }else{\\n                    // decrementing rolling window matches\\n                    // by one, since an index of the value\\n                    // is falling out of the range of the \\n                    // rolling window\\n                    numberOfMatchesInRollingWindow -= num[1];\\n                    num[0] = next;\\n                    num[1] = nextNum;\\n                    numberOfMatchesInRollingWindow += nextNum;\\n                }\\n                l++;\\n            }\\n            r++;\\n        }\\n        return a;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long countGood(int[] nums, int k) {\\n        /**\\n            THIS IS A SLIDING WINDOW PROBLEM\\n            keep sliding right side of window until we reach\\n            the criteria\\n            then slide left side of window, keeping track of \\n            if we still match criteria\\n            then continue sliding right side of window\\n            until we reach end\\n\\n            tricky part of the problem is tracking the \\n            relationship between number of indexes\\n            with a particular value, and the associated\\n            number of matches IF that number of values \\n            is present\\n\\n            note that the relationship between number of \\n            indexes following initial index and the number\\n            of valid matches is prevNum + prevMatches\\n\\n            as a clearer example\\n            index:  0,1,2,3,4 ,5\\n            matches:0,1,3,6,10,15 \\n            this is because the sum of \\n\\n            start from window = 0,0\\n            move right side of window until we match criteria\\n            \"at least k pairs\" means once we match criteria\\n            then can add 1 + n-right to answer since\\n            regardless of contents of remaining window, \\n            the subarray will match criteria\\n\\n            after we reach above condition\\n            move left side of window right by one\\n            holding right side static\\n            decrementing index pairs by whatever\\n            the value is at that index\\n         */\\n        int n = nums.length;\\n        // matches map\\n        Map<Integer, int[]> matches = new HashMap<>();\\n        int l = 0; int r = 0;\\n        int numberOfMatchesInRollingWindow = 0;\\n        long a = 0;\\n        while(r < nums.length){\\n            if(matches.containsKey(nums[r])){\\n                int[] num = matches.get(nums[r]);\\n                // number of indexes with value\\n                int next = num[0]+1;\\n                // resulting number of matches\\n                // need to track this for incrementing\\n                //AND decrementing purposes\\n                int nextNum = num[1] + next;\\n\\n                // remove previous number of matches\\n                // for this value and add new\\n                numberOfMatchesInRollingWindow -= num[1];\\n                num[0] = next;\\n                num[1] = nextNum;\\n                numberOfMatchesInRollingWindow += nextNum;\\n            }else{\\n                // adding new index to map\\n                matches.put(nums[r], new int[]{0, 0});\\n            }\\n            while(numberOfMatchesInRollingWindow >= k){\\n                // this means we have found a subarray\\n                // with k values;\\n                // means we can add this subarray\\n                // plus the subarrays including all \\n                // subsequent indices\\n                a+=1;\\n                a+= n - r - 1;\\n                int[] num = matches.get(nums[l]);\\n                int next = num[0]-1;\\n                int nextNum = num[1] - num[0];\\n                if(next < 0 ){\\n                    // cleanup of value falling out of \\n                    // rolling window\\n                    matches.remove(nums[l]);\\n                }else{\\n                    // decrementing rolling window matches\\n                    // by one, since an index of the value\\n                    // is falling out of the range of the \\n                    // rolling window\\n                    numberOfMatchesInRollingWindow -= num[1];\\n                    num[0] = next;\\n                    num[1] = nextNum;\\n                    numberOfMatchesInRollingWindow += nextNum;\\n                }\\n                l++;\\n            }\\n            r++;\\n        }\\n        return a;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4003155,
                "title": "easy-o-n-sliding-window-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& nums, int k) {\\n        long long ans = 0;\\n        int l = 0;\\n        int r = 0;\\n        int n = nums.size();\\n        unordered_map<int,int> cnt;\\n        int curr_sum = 0;\\n        for(int r=0;r<n;r++){\\n            curr_sum+=cnt[nums[r]];\\n            cnt[nums[r]]++;\\n            while(curr_sum>=k){\\n                ans+=(long long)(n-r);\\n                cnt[nums[l]]--;\\n                curr_sum-=cnt[nums[l]];\\n                l++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& nums, int k) {\\n        long long ans = 0;\\n        int l = 0;\\n        int r = 0;\\n        int n = nums.size();\\n        unordered_map<int,int> cnt;\\n        int curr_sum = 0;\\n        for(int r=0;r<n;r++){\\n            curr_sum+=cnt[nums[r]];\\n            cnt[nums[r]]++;\\n            while(curr_sum>=k){\\n                ans+=(long long)(n-r);\\n                cnt[nums[l]]--;\\n                curr_sum-=cnt[nums[l]];\\n                l++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3969084,
                "title": "python-medium",
                "content": "```\\nclass Solution(object):\\n    def countGood(self, nums, k):\\n        N = len(nums)\\n        lookup = defaultdict(int)\\n        count = 0\\n        l = 0\\n        ans = 0\\n\\n\\n        for r in range(N):\\n            lookup[nums[r]] += 1\\n\\n            count += lookup[nums[r]] - 1\\n\\n            while count >= k:\\n                ans += 1 + N - r - 1\\n                lookup[nums[l]] -= 1\\n                count -= lookup[nums[l]]\\n                l += 1\\n\\n        return ans\\n\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def countGood(self, nums, k):\\n        N = len(nums)\\n        lookup = defaultdict(int)\\n        count = 0\\n        l = 0\\n        ans = 0\\n\\n\\n        for r in range(N):\\n            lookup[nums[r]] += 1\\n\\n            count += lookup[nums[r]] - 1\\n\\n            while count >= k:\\n                ans += 1 + N - r - 1\\n                lookup[nums[l]] -= 1\\n                count -= lookup[nums[l]]\\n                l += 1\\n\\n        return ans\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3962978,
                "title": "c-sliding-window-approach",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    long long countGood(vector<int>& nums, int k) {\\n        reverse(nums.begin(), nums.end());\\n        ll res = 0, low=0, high=0, curr = 0;\\n        unordered_map<int, int>mp;\\n\\n        while(high < nums.size()){\\n\\n            if(mp.find(nums[high]) == mp.end()){\\n                mp[nums[high]]+=1;\\n            }\\n            else{\\n                int val = mp[nums[high]];\\n                mp[nums[high]]+=1;\\n                curr+=(ll)val;\\n            }\\n\\n            if(curr < k)\\n                ++high;\\n            else{\\n                int remain = nums.size() - high;\\n                res+=(ll)remain;\\n                while(low < high){\\n                    int temp = mp[nums[low]];\\n                    if(temp == 1)\\n                        mp.erase(nums[low]);\\n                    else{\\n                        curr-=(ll)(temp-1);\\n                        mp[nums[low]]-=1;\\n                    }\\n                    ++low;\\n                    if(curr >= k)\\n                        res+=(ll)(nums.size()-high);\\n                    if(curr < k)\\n                        break;\\n                }\\n\\n                ++high;\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    long long countGood(vector<int>& nums, int k) {\\n        reverse(nums.begin(), nums.end());\\n        ll res = 0, low=0, high=0, curr = 0;\\n        unordered_map<int, int>mp;\\n\\n        while(high < nums.size()){\\n\\n            if(mp.find(nums[high]) == mp.end()){\\n                mp[nums[high]]+=1;\\n            }\\n            else{\\n                int val = mp[nums[high]];\\n                mp[nums[high]]+=1;\\n                curr+=(ll)val;\\n            }\\n\\n            if(curr < k)\\n                ++high;\\n            else{\\n                int remain = nums.size() - high;\\n                res+=(ll)remain;\\n                while(low < high){\\n                    int temp = mp[nums[low]];\\n                    if(temp == 1)\\n                        mp.erase(nums[low]);\\n                    else{\\n                        curr-=(ll)(temp-1);\\n                        mp[nums[low]]-=1;\\n                    }\\n                    ++low;\\n                    if(curr >= k)\\n                        res+=(ll)(nums.size()-high);\\n                    if(curr < k)\\n                        break;\\n                }\\n\\n                ++high;\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3953365,
                "title": "full-explanation-sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- First seeing this problem, We can figure that we have a sliding window problem.\\n#### SUBARRAY Explanation\\n- When we want a particular subarray we also consider the possible subarrays which we can encouter further in the process.\\n- This problem is one of them.\\n\\n- Consider, we require subarrays that contain k pairs of equal elements as mentioned. So we can have a map to figure those elements. \\n### Pair Calculation\\n- When we have certain number of elements how many pairs we can form?\\n- The Answer can be explained as:\\n- Example: `[3 1 2 3 2 2 4]`\\n- `SLIDING WINDOW`\\n- `[3]` map contains `[3:1]`\\n- `[3 1]` map contains `[3:1,1:1]`\\n- `[3 1 4]` map contains `[3:1,1:1,4:1]`\\n- `As we see we are encountering single elements till now, We can compute the pairs and their  pair count will be 0.`\\n- `When we have 1 element the pair count is zero`.\\n- `FOR 2 pair count is 1`\\n- `FOR 3 it is 2 ---> [1 1 1]---> as indices[0 1 2]----> (0,1),(0,2),(1,2).`\\n- `Then for 4 it is ---> [1 1 1 1]---> as indices[0 1 2 3]----> (0,1),(0,2),(0,3),(1,2),(1,3),(2,3). IT is 6 pairs.`\\n- `We can observe a pattern that a number contains in number-1 pairs.`\\n- `So we can add to our currPair count the current mp[number] - 1. Vice verse we can subtract (when needed) mp[number]-1 from the cnt.`\\n#### Now comes the counting subarrays task.\\n- In the example `[3 1 2 3 2 2 4] k=2`\\nwe encouter the condition `currPairs>=k at below sliding windows:`\\n-`[3 1 2 3 2]--> pairs=2 As straight forward we may inc the ans but we should observe that the ans should be incremented in other way.\\n As the remaing elements in the array to the right can also make this a subarray  so we can add the cnt as the cnt+=3 (n-j) j is the index of the end of the window. The number of elements as the end can be [2 or 2 or 4] as these are different end positions on the right.`\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        long long ans=0;\\n        int currPairs=0;\\n        unordered_map<int,int> mp;\\n        for(int r=0,l=0;r<n;r++)\\n        {\\n            currPairs+=mp[nums[r]];\\n            mp[nums[r]]++;\\n            while(currPairs>=k){\\n                ans+=n-r;\\n                mp[nums[l]]--;\\n                currPairs-=mp[nums[l++]];\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        long long ans=0;\\n        int currPairs=0;\\n        unordered_map<int,int> mp;\\n        for(int r=0,l=0;r<n;r++)\\n        {\\n            currPairs+=mp[nums[r]];\\n            mp[nums[r]]++;\\n            while(currPairs>=k){\\n                ans+=n-r;\\n                mp[nums[l]]--;\\n                currPairs-=mp[nums[l++]];\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3898159,
                "title": "solution-in-swift-sliding-window-o-n",
                "content": "# Intuition\\nTo tackle this problem, let\\'s start by considering how we can determine pairs (i, j) in an array.\\n\\n# Approach\\nWe can employ the sliding window technique. Create a dictionary named count to keep track of the frequency of each element in the array.\\n\\nWhen we introduce a new number A[j] at the right side of the window, we would have count[A[j]] occurrences of A[j] within the window. Consequently, we\\'ll have count[A[j]] additional pairs.\\n\\nIf the number of pairs exceeds k, we can adjust the window size by reducing it. We continue this process until the number of pairs within the sliding window becomes less than k. When that happens, the subarray A[i]...A[j] no longer qualifies as a good subarray. However, for any index i2 where i2 < i, the subarray A[i2]...A[j] still remains a good subarray. Consequently, we can increment the result res by i for i2 = 0, 1, 2, ..., i-1.\\n\\n# Complexity\\n- Time complexity: `O(n)`\\n- Space complexity: `O(n)`\\n\\n# Code\\n```\\nclass Solution {\\n    func countGood(_ nums: [Int], _ k: Int) -> Int {\\n        var res: Int = 0\\n        var count: [Int: Int] = [:]\\n        var remainingPairs: Int = k  // Create a mutable copy\\n        \\n        var i: Int = 0\\n        \\n        for j in 0..<nums.count {\\n            if count[nums[j]] == nil {\\n                count[nums[j]] = 0\\n            }\\n            \\n            remainingPairs -= count[nums[j]]!\\n            count[nums[j]]! += 1\\n            \\n            while remainingPairs <= 0 {\\n                remainingPairs += (count[nums[i]]! - 1)\\n                count[nums[i]]! -= 1\\n                i += 1\\n            }\\n            \\n            res += i\\n        }\\n        \\n        return res\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func countGood(_ nums: [Int], _ k: Int) -> Int {\\n        var res: Int = 0\\n        var count: [Int: Int] = [:]\\n        var remainingPairs: Int = k  // Create a mutable copy\\n        \\n        var i: Int = 0\\n        \\n        for j in 0..<nums.count {\\n            if count[nums[j]] == nil {\\n                count[nums[j]] = 0\\n            }\\n            \\n            remainingPairs -= count[nums[j]]!\\n            count[nums[j]]! += 1\\n            \\n            while remainingPairs <= 0 {\\n                remainingPairs += (count[nums[i]]! - 1)\\n                count[nums[i]]! -= 1\\n                i += 1\\n            }\\n            \\n            res += i\\n        }\\n        \\n        return res\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3873968,
                "title": "c-o-n-sliding-window-solution",
                "content": "# Intuition\\nFor any j in [0, n-1], there may be i, such that intervals [0, j], [1, j], ... [i, j] have at least k pairs. While checking all i for which interval [i, j] satisfies condition is O(N) time, if [i, j] satisfies condition for a given i, then checking all [i, j+1], ... is O(1). This is because if [i, j] has at least k pairs, then all intervals [i, j+1], ... [i, n-1] also satisfy.\\n\\n# Approach\\nUse hash map to keep track of number of elements and calcualte the number of pairs. When we add an element nums[j], then number of pairs increases by counts[nums[j]], because newly added element makes pairs with each of the previously added elements.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& nums, int k) {\\n        unordered_map<int, int> counts;\\n        int n = nums.size();\\n        long long count = 0;\\n        long long pairs = 0;\\n        int i = 0;\\n        int j = 0;\\n        counts[nums[0]]++;\\n\\n        while (j < n) {\\n            if (pairs >= k) {\\n                count += n - j;\\n                counts[nums[i]]--;\\n                pairs -= counts[nums[i]];\\n\\n                if (counts[nums[i]] == 0) {\\n                    counts.erase(nums[i]);\\n                }\\n\\n                i++;\\n            } else {\\n                j++;\\n\\n                if (j < n) {\\n                    if (counts.find(nums[j]) != counts.end()) {\\n                        pairs += counts[nums[j]];\\n                    }\\n\\n                    counts[nums[j]]++;\\n                }\\n            }\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& nums, int k) {\\n        unordered_map<int, int> counts;\\n        int n = nums.size();\\n        long long count = 0;\\n        long long pairs = 0;\\n        int i = 0;\\n        int j = 0;\\n        counts[nums[0]]++;\\n\\n        while (j < n) {\\n            if (pairs >= k) {\\n                count += n - j;\\n                counts[nums[i]]--;\\n                pairs -= counts[nums[i]];\\n\\n                if (counts[nums[i]] == 0) {\\n                    counts.erase(nums[i]);\\n                }\\n\\n                i++;\\n            } else {\\n                j++;\\n\\n                if (j < n) {\\n                    if (counts.find(nums[j]) != counts.end()) {\\n                        pairs += counts[nums[j]];\\n                    }\\n\\n                    counts[nums[j]]++;\\n                }\\n            }\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3855316,
                "title": "concise-c-sliding-window-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nPivot left side, and keep moving right side until meet the requirement.\\n\\nIt\\'s my first post. Hope you guys like it >//<\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAs mentioned, keep moving right side.\\nEverytime we move left side or right side, we have to re-calculate the pair that current number that brings to us.\\n\\nFor example, nums = [1, 1, 2, 1]\\n\\nwhen right = idx0, we count how many pair we can construct based on this new value.\\n\\nwhen right = idx1, do the same thing again. However, we have to calculate the old pairs that current number used to bring to us first.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        int left = 0;\\n        int right = 0;\\n\\n        long long res = 0;\\n        unordered_map<int, int> freq;\\n        long long count = 0;\\n\\n        for (; right < n; right++){\\n            long long old_freq = freq[nums[right]];\\n            long long old_pair = old_freq * (old_freq-1) / 2;\\n\\n            freq[nums[right]]++;\\n            long long new_freq = freq[nums[right]];\\n            long long new_pair = new_freq * (new_freq-1) / 2;\\n            \\n            // subtract the count of old_pair first, and then add the count of new_pair\\n            count = count - old_pair + new_pair;\\n\\n            while (count >= k){\\n                res += n-1 - right + 1;\\n\\n                long long old_left_freq = freq[nums[left]];\\n                long long old_left_pair = old_left_freq * (old_left_freq-1) / 2;\\n                freq[nums[left]]--;\\n\\n                long long new_left_freq = freq[nums[left]];\\n                long long new_left_pair = new_left_freq * (new_left_freq-1) / 2;\\n\\n                count = count - old_left_pair + new_left_pair;\\n\\n                left++;\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        int left = 0;\\n        int right = 0;\\n\\n        long long res = 0;\\n        unordered_map<int, int> freq;\\n        long long count = 0;\\n\\n        for (; right < n; right++){\\n            long long old_freq = freq[nums[right]];\\n            long long old_pair = old_freq * (old_freq-1) / 2;\\n\\n            freq[nums[right]]++;\\n            long long new_freq = freq[nums[right]];\\n            long long new_pair = new_freq * (new_freq-1) / 2;\\n            \\n            // subtract the count of old_pair first, and then add the count of new_pair\\n            count = count - old_pair + new_pair;\\n\\n            while (count >= k){\\n                res += n-1 - right + 1;\\n\\n                long long old_left_freq = freq[nums[left]];\\n                long long old_left_pair = old_left_freq * (old_left_freq-1) / 2;\\n                freq[nums[left]]--;\\n\\n                long long new_left_freq = freq[nums[left]];\\n                long long new_left_pair = new_left_freq * (new_left_freq-1) / 2;\\n\\n                count = count - old_left_pair + new_left_pair;\\n\\n                left++;\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3853638,
                "title": "ez-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    long long countGood(vector<int>& nums, int k) {\\n        ll ans = 0;\\n        int i = 0 ,j = 0 ,pairs = 0 ;\\n        unordered_map<int,int> mp ;\\n        for(;j<nums.size();j++){\\n            mp[nums[j]]++;\\n            pairs += mp[nums[j]]-1;\\n            while(i<j && pairs>=k){\\n                mp[nums[i]]--;\\n                pairs -= mp[nums[i]];\\n                i++;\\n                ans += nums.size() - j ;\\n            }\\n        }return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    long long countGood(vector<int>& nums, int k) {\\n        ll ans = 0;\\n        int i = 0 ,j = 0 ,pairs = 0 ;\\n        unordered_map<int,int> mp ;\\n        for(;j<nums.size();j++){\\n            mp[nums[j]]++;\\n            pairs += mp[nums[j]]-1;\\n            while(i<j && pairs>=k){\\n                mp[nums[i]]--;\\n                pairs -= mp[nums[i]];\\n                i++;\\n                ans += nums.size() - j ;\\n            }\\n        }return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3827639,
                "title": "simple-effective-easy-to-understand-for-beginner-to-pro-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nOne simple observation : \\n\\nIf you have freq of number 2 lets say 3 and if you then found one more 2 then it will become 4 right\\nNumbers of pairs increased in this process is: \\n4C2 - 3C2  = 6-3 = 3\\nSo if you maintain a cnt like how many pairs are increased at each count then you can simply write : \\nlets say m is map\\ncnt+= m[nums[j]]-1 which is **new freq-1** \\n**Note**: It will always be that, from P&C\\nMore eg. if m[3] incresed from 4 to 5 then count pairs\\n5c2 - 4c2 = 10 - 6  = 4\\n6c2 - 5c2 = 15 - 10 = 5\\n\\nso you can count no. of freq increased in O(1) time\\nThen rest is standard sliding window and 2 Pointer concept\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& nums, int k) {\\n        unordered_map<long,long> m;\\n        int i=0,j=0;\\n        int n=nums.size();\\n        long long cnt=0;\\n        long long ans=0;\\n        while(j<n){\\n            m[nums[j]]++;\\n            cnt+=m[nums[j]]-1;\\n            while(cnt >=k)\\n            {\\n                ans+=(n-j);\\n                m[nums[i]]--;\\n                cnt-=m[nums[i]];\\n                if(m[nums[i]]==0)\\n                    m.erase(nums[i]);\\n                i++;\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& nums, int k) {\\n        unordered_map<long,long> m;\\n        int i=0,j=0;\\n        int n=nums.size();\\n        long long cnt=0;\\n        long long ans=0;\\n        while(j<n){\\n            m[nums[j]]++;\\n            cnt+=m[nums[j]]-1;\\n            while(cnt >=k)\\n            {\\n                ans+=(n-j);\\n                m[nums[i]]--;\\n                cnt-=m[nums[i]];\\n                if(m[nums[i]]==0)\\n                    m.erase(nums[i]);\\n                i++;\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3804902,
                "title": "java-95th-percentile",
                "content": "# Intuition\\nAt first, I considered a brute-force approach of manually checking each subarray, which would yield a Time Complexity of $$O(n^2)$$. However, based on past experience with similar problems, it seemed likely that there existed a more efficient solution, so I began analyzing the problem for patterns to exploit.\\n\\n# Approach\\nAfter considering the likelihood of finding a solution more efficient than $$O(n^2)$$, I tried to break down the criteria for what counts as a \"good\" subarray and found that the solution will depend on the number of \"pairs\" of equal-valued elements. This brought to mind an idea to use a map for keeping track of the number of occurrences of each value present in the array.\\n\\nFrom here, I tried to analyze a few examples of duplicate-valued subarrays and happened to find a pattern in the relationship between the number of occurrences of a value and the number of pairs that could be formed from these elements. I started with the addition of each new count, starting from 1, to find the number of pairs, but I soon realized I could also use a formula to represent this progression. I didn\\'t actually end up using this formula in my solution, but it was useful for understanding the pattern so I could more efficiently solve the problem.\\n\\nAfter the previous step, I started thinking about how I could solve this problem without having to revisit the elements toward the end of the array over and over again, and it seemed like there could be a way to implement some sort of sliding window type solution by keeping track of two indices and considering the minimum amount of elements needed to reach k pairs (being especially mindful of elements with multiple occurrences).\\n\\nAt this point, I also noticed that if I reach k pairs in a subarray, then any other subarray that contains it would also have at least k pairs and therefore also be a \"good\" subarray. Instead of iterating through the rest of the subarrays with the same starting values, I realized I could perform a simple calculation using the total array length along with the subarray end index to simplify and optimize the process.\\n\\nAfter thinking through all this and writing some comments and code fragments to keep track while analyzing the problem, I put the rest of the pieces into code to implement the sliding window algorithm I ended up with. I had to make a few tweaks to my variable types and arithmetic since I was trying to use as few operations and bytes as possible, but after making those minor changes and running a few more tests, I felt confident that my algorithm was sound and submitted the final draft of my solution.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\n// occurrences : pairs -> f(x) = x*(x/2)-(x/2) = (x/2)*(x - 1)\\n// 1 : 0 -> 1 (0) = (1/2)*(1-1)\\n// 2 : 1 -> 11 (1) = (2/2)*(2-1)\\n// 3 : 3 -> 111 (2 + 1) = (3/2)*(3-1))\\n// 4 : 6 -> 1111 (3 + 2 + 1) = (4/2)*(4-1)\\n// 5 : 10 -> 11111 (4 + 3 + 2 + 1) = (5/2)*(5-1)\\n// 6 : 15 -> 111111 (5 + 4 + 3 + 2 + 1) = (6/2)*(6-1))\\n// 7 : 21 -> 111111 (6 + 5 + 4 + 3 + 2 + 1) = (7/2)*(7-1)\\n// 8 : 28 -> 111111 (7 + 6 + 5 + 4 + 3 + 2 + 1) = (8/2)*(8-1)\\n// 9 : 36 -> 111111 (8 + 7 + 6 + 5 + 4 + 3 + 2 + 1) = (9/2)*(9-1)\\n\\nclass Solution {\\n    public long countGood(int[] nums, int k) {\\n        if (nums.length == 1) return 0;\\n        long totalPairs = 0;\\n        long goodCount = 0;\\n        int i = 0;\\n        int j = 0;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        while (i < nums.length - 1) {\\n            while (j < nums.length) {\\n                if (map.containsKey(nums[j])) {\\n                    totalPairs += map.get(nums[j]);\\n                    map.put(nums[j], map.get(nums[j]) + 1);\\n                } else {\\n                    map.put(nums[j], 1);\\n                }\\n                j++;\\n                if (totalPairs >= k) {\\n                    break;\\n                }\\n            }\\n            while (totalPairs >= k) {\\n                goodCount += (nums.length - j + 1);\\n                if (map.get(nums[i]) == 1) {\\n                    map.remove(nums[i]);\\n                }\\n                else {\\n                    map.put(nums[i], map.get(nums[i]) - 1);\\n                    totalPairs -= map.get(nums[i]);\\n                }\\n                i++;\\n            }\\n            if (j == nums.length && totalPairs < k) {\\n                break;\\n            }\\n        }\\n        return goodCount;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// occurrences : pairs -> f(x) = x*(x/2)-(x/2) = (x/2)*(x - 1)\\n// 1 : 0 -> 1 (0) = (1/2)*(1-1)\\n// 2 : 1 -> 11 (1) = (2/2)*(2-1)\\n// 3 : 3 -> 111 (2 + 1) = (3/2)*(3-1))\\n// 4 : 6 -> 1111 (3 + 2 + 1) = (4/2)*(4-1)\\n// 5 : 10 -> 11111 (4 + 3 + 2 + 1) = (5/2)*(5-1)\\n// 6 : 15 -> 111111 (5 + 4 + 3 + 2 + 1) = (6/2)*(6-1))\\n// 7 : 21 -> 111111 (6 + 5 + 4 + 3 + 2 + 1) = (7/2)*(7-1)\\n// 8 : 28 -> 111111 (7 + 6 + 5 + 4 + 3 + 2 + 1) = (8/2)*(8-1)\\n// 9 : 36 -> 111111 (8 + 7 + 6 + 5 + 4 + 3 + 2 + 1) = (9/2)*(9-1)\\n\\nclass Solution {\\n    public long countGood(int[] nums, int k) {\\n        if (nums.length == 1) return 0;\\n        long totalPairs = 0;\\n        long goodCount = 0;\\n        int i = 0;\\n        int j = 0;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        while (i < nums.length - 1) {\\n            while (j < nums.length) {\\n                if (map.containsKey(nums[j])) {\\n                    totalPairs += map.get(nums[j]);\\n                    map.put(nums[j], map.get(nums[j]) + 1);\\n                } else {\\n                    map.put(nums[j], 1);\\n                }\\n                j++;\\n                if (totalPairs >= k) {\\n                    break;\\n                }\\n            }\\n            while (totalPairs >= k) {\\n                goodCount += (nums.length - j + 1);\\n                if (map.get(nums[i]) == 1) {\\n                    map.remove(nums[i]);\\n                }\\n                else {\\n                    map.put(nums[i], map.get(nums[i]) - 1);\\n                    totalPairs -= map.get(nums[i]);\\n                }\\n                i++;\\n            }\\n            if (j == nums.length && totalPairs < k) {\\n                break;\\n            }\\n        }\\n        return goodCount;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3784814,
                "title": "sliding-window-python-3",
                "content": "# Intuition\\n- It is just when you encounter k pairs you count it and move the start pointer\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- SLIDING WINDOW\\n\\n# Complexity\\n**Time complexity:**\\n- O(N)\\n\\n**Space complexity:**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n- O(N)\\n\\n# Code\\n```\\nclass Solution:\\n    def countGood(self, nums: List[int], k: int) -> int:\\n        #sliding window\\n        start = 0\\n        curr = 0\\n        total = 0\\n        hMap = {}\\n        # pairs\\n        for i in range(len(nums)):\\n            if nums[i] not in hMap:\\n                hMap[nums[i]] = 1\\n            else:\\n                prev = hMap[nums[i]]\\n                hMap[nums[i]]+=1\\n                if hMap[nums[i]]>2:\\n                    curr+=(((hMap[nums[i]]*(hMap[nums[i]]-1))//2)-(prev*(prev-1))//2)\\n                elif hMap[nums[i]] == 2:\\n                    curr+=((hMap[nums[i]]*(hMap[nums[i]]-1))//2)\\n            \\n\\n            while curr >= k:\\n                print(i,curr)\\n                total+=1\\n                if hMap[nums[start]] >= 2:\\n                    _next = hMap[nums[start]]-1\\n                    curr-= (hMap[nums[start]]*(hMap[nums[start]]-1))//2\\n                    curr+= (_next*(_next-1))//2\\n                    print(curr)\\n                hMap[nums[start]]-=1\\n                start+=1\\n                total+=len(nums)-i-1\\n        return total\\n        # return 2\\n                    \\n                        \\n                    \\n                \\n                \\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def countGood(self, nums: List[int], k: int) -> int:\\n        #sliding window\\n        start = 0\\n        curr = 0\\n        total = 0\\n        hMap = {}\\n        # pairs\\n        for i in range(len(nums)):\\n            if nums[i] not in hMap:\\n                hMap[nums[i]] = 1\\n            else:\\n                prev = hMap[nums[i]]\\n                hMap[nums[i]]+=1\\n                if hMap[nums[i]]>2:\\n                    curr+=(((hMap[nums[i]]*(hMap[nums[i]]-1))//2)-(prev*(prev-1))//2)\\n                elif hMap[nums[i]] == 2:\\n                    curr+=((hMap[nums[i]]*(hMap[nums[i]]-1))//2)\\n            \\n\\n            while curr >= k:\\n                print(i,curr)\\n                total+=1\\n                if hMap[nums[start]] >= 2:\\n                    _next = hMap[nums[start]]-1\\n                    curr-= (hMap[nums[start]]*(hMap[nums[start]]-1))//2\\n                    curr+= (_next*(_next-1))//2\\n                    print(curr)\\n                hMap[nums[start]]-=1\\n                start+=1\\n                total+=len(nums)-i-1\\n        return total\\n        # return 2\\n                    \\n                        \\n                    \\n                \\n                \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3781432,
                "title": "swift-easy-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    func countGood(_ nums: [Int], _ k: Int) -> Int {\\n        var cnt = [Int: Int]()\\n        var ans: Int64 = 0\\n        var countGood: Int64 = 0\\n        var j = 0\\n        \\n        for i in 0..<nums.count {\\n            if cnt[nums[i], default: 0] == 0 {\\n                cnt[nums[i]] = 1\\n            } else {\\n                cnt[nums[i]]! += 1\\n            }\\n            \\n            if cnt[nums[i]]! == 2 {\\n                ans += 1\\n            } else if cnt[nums[i]]! > 2 {\\n                let val = cnt[nums[i]]! - 1\\n                ans -= Int64(val * (val - 1)) / 2\\n                ans += Int64(val * (val + 1)) / 2\\n            }\\n            \\n            while ans >= k && j < i {\\n                countGood += Int64(nums.count - i)\\n                let val = cnt[nums[j], default: 0]\\n                cnt[nums[j], default: 0] = val - 1\\n                ans -= Int64(val * (val - 1)) / 2\\n                let newVal = val - 1\\n                ans += Int64(newVal * (newVal - 1)) / 2\\n                j += 1\\n            }\\n        }\\n        \\n        return Int(countGood)\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func countGood(_ nums: [Int], _ k: Int) -> Int {\\n        var cnt = [Int: Int]()\\n        var ans: Int64 = 0\\n        var countGood: Int64 = 0\\n        var j = 0\\n        \\n        for i in 0..<nums.count {\\n            if cnt[nums[i], default: 0] == 0 {\\n                cnt[nums[i]] = 1\\n            } else {\\n                cnt[nums[i]]! += 1\\n            }\\n            \\n            if cnt[nums[i]]! == 2 {\\n                ans += 1\\n            } else if cnt[nums[i]]! > 2 {\\n                let val = cnt[nums[i]]! - 1\\n                ans -= Int64(val * (val - 1)) / 2\\n                ans += Int64(val * (val + 1)) / 2\\n            }\\n            \\n            while ans >= k && j < i {\\n                countGood += Int64(nums.count - i)\\n                let val = cnt[nums[j], default: 0]\\n                cnt[nums[j], default: 0] = val - 1\\n                ans -= Int64(val * (val - 1)) / 2\\n                let newVal = val - 1\\n                ans += Int64(newVal * (newVal - 1)) / 2\\n                j += 1\\n            }\\n        }\\n        \\n        return Int(countGood)\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3768945,
                "title": "sliding-window-easy-standard-beats-84-5",
                "content": "\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& nums, int k) {\\n        long long i=0,j=0,cnt=0,res=0;\\n        unordered_map<long long,long long> dash;                //-------->nums[i],freq;\\n        int n=nums.size();\\n        while(j<n){\\n            dash[nums[j]]++;            //do some calculation\\n//Since the element nums[j] has already occurred dash[nums[j]] times in the current subarray (including the current occurrence), there are (dash[nums[j]] - 1) additional pairs of indices\\n            if(dash[nums[j]]>1){            \\n                cnt+=(dash[nums[j]]-1);\\n            }\\n//until we find that particular range in which it is a good pair\\n            while(i<=j && cnt>=k){\\n                dash[nums[i]]--;\\n                cnt-=dash[nums[i]];\\n                i++;\\n                res+=n-j;\\n            }\\n            j++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& nums, int k) {\\n        long long i=0,j=0,cnt=0,res=0;\\n        unordered_map<long long,long long> dash;                //-------->nums[i],freq;\\n        int n=nums.size();\\n        while(j<n){\\n            dash[nums[j]]++;            //do some calculation\\n//Since the element nums[j] has already occurred dash[nums[j]] times in the current subarray (including the current occurrence), there are (dash[nums[j]] - 1) additional pairs of indices\\n            if(dash[nums[j]]>1){            \\n                cnt+=(dash[nums[j]]-1);\\n            }\\n//until we find that particular range in which it is a good pair\\n            while(i<=j && cnt>=k){\\n                dash[nums[i]]--;\\n                cnt-=dash[nums[i]];\\n                i++;\\n                res+=n-j;\\n            }\\n            j++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3765818,
                "title": "clean-neat-java-sliding-window-solution-beats-76-time-wise",
                "content": "```\\nclass Solution\\n{\\n    public long countGood(int[] nums, int k)\\n    {\\n        int sp = 0;\\n        int lookup;\\n        int count = 0;\\n        long output = 0;\\n        HashMap<Integer, Integer> freqs = new HashMap<Integer, Integer>();\\n        for (int i = 0; i < nums.length; i++)\\n        {\\n            lookup = freqs.getOrDefault(nums[i], 0);\\n            freqs.put(nums[i], lookup + 1);\\n            count -= calcOptions(lookup);\\n            count += calcOptions(lookup + 1);\\n            while (sp <= i && count >= k)\\n            {\\n                output += (nums.length - i);\\n                lookup = freqs.get(nums[sp]);\\n                count -= calcOptions(lookup);\\n                count += calcOptions(lookup - 1);\\n                freqs.put(nums[sp], lookup - 1);\\n                sp++;\\n            }\\n        }\\n        return output;\\n    }\\n    \\n    private int calcOptions(int n)\\n    {\\n        return n * (n - 1) / 2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution\\n{\\n    public long countGood(int[] nums, int k)\\n    {\\n        int sp = 0;\\n        int lookup;\\n        int count = 0;\\n        long output = 0;\\n        HashMap<Integer, Integer> freqs = new HashMap<Integer, Integer>();\\n        for (int i = 0; i < nums.length; i++)\\n        {\\n            lookup = freqs.getOrDefault(nums[i], 0);\\n            freqs.put(nums[i], lookup + 1);\\n            count -= calcOptions(lookup);\\n            count += calcOptions(lookup + 1);\\n            while (sp <= i && count >= k)\\n            {\\n                output += (nums.length - i);\\n                lookup = freqs.get(nums[sp]);\\n                count -= calcOptions(lookup);\\n                count += calcOptions(lookup - 1);\\n                freqs.put(nums[sp], lookup - 1);\\n                sp++;\\n            }\\n        }\\n        return output;\\n    }\\n    \\n    private int calcOptions(int n)\\n    {\\n        return n * (n - 1) / 2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3761809,
                "title": "easy-to-understand-explanation",
                "content": "# Intuition\\nAs we know the total number of combinations of picking r elements from n is n!/(r! * (n-r)!). In this case we are dealing with pairs. So r = 2, C = n * (n-1) / 2.\\nGiven array A, we can use 2 pointer/indexes i, j as the bounds of the sub array we pick. Initially, i = j = 0, we move j rightwards, once we have k equal pairs in the sub array, we move i rightwards till it has less than k pairs.\\nLet m be the map(counter) of elements, c be the number of equal pairs in the sub array. When we move the right bound to j we get one extra char a[j] so update C like this:\\nm[a[j]] is the number of a[j] we currently have.\\nC -= m[a[j]] * (m[a[j]] - 1) / 2\\nm[a[j]] += 1\\nC += m[a[j]] * (m[a[j]] - 1) / 2 \\nThese statements can be combined as the following:\\nC += m[a[j]]\\nm[a[j]] += 1\\n\\n# Complexity\\n- Time complexity:\\nShould be O(n) or slightly worse.\\n\\n# Code\\n```\\nclass Solution:\\n    def countGood(self, a: List[int], k: int) -> int:\\n        m = defaultdict(int)\\n        i, j, n, r, c = 0, 0, len(a), 0, 0\\n        for j in range(n):\\n            c += m[a[j]]\\n            m[a[j]] += 1\\n            if c >= k:\\n                temp = i\\n                while c >= k:\\n                    m[a[i]] -= 1\\n                    c -= m[a[i]]\\n                    i += 1\\n                r += (n - j) * (i - temp)\\n        return r\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countGood(self, a: List[int], k: int) -> int:\\n        m = defaultdict(int)\\n        i, j, n, r, c = 0, 0, len(a), 0, 0\\n        for j in range(n):\\n            c += m[a[j]]\\n            m[a[j]] += 1\\n            if c >= k:\\n                temp = i\\n                while c >= k:\\n                    m[a[i]] -= 1\\n                    c -= m[a[i]]\\n                    i += 1\\n                r += (n - j) * (i - temp)\\n        return r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3755858,
                "title": "golang-sliding-window-solution",
                "content": "# Code\\n```go\\nfunc countGood(nums []int, k int) int64 {\\n\\ttotal := int64(0)\\n\\tleftBound, currPairs := 0, 0\\n\\telemMap := make(map[int]int)\\n\\tfor _, v := range nums {\\n\\t\\tcurrPairs += elemMap[v]\\n\\t\\telemMap[v]++\\n\\t\\tif currPairs < k {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tfor currPairs >= k {\\n\\t\\t\\tremoveVal := nums[leftBound]\\n\\t\\t\\tdescPair := elemMap[removeVal] - 1\\n\\t\\t\\tif currPairs - descPair < k {\\n\\t\\t\\t\\t// remove is impossible\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t\\t// remove value of index leftBound\\n\\t\\t\\tcurrPairs -= descPair\\n\\t\\t\\telemMap[removeVal]--\\n\\t\\t\\tleftBound++\\n\\t\\t}\\n\\t\\ttotal += int64(leftBound +1)\\n\\t}\\n\\treturn total\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Sliding Window"
                ],
                "code": "```go\\nfunc countGood(nums []int, k int) int64 {\\n\\ttotal := int64(0)\\n\\tleftBound, currPairs := 0, 0\\n\\telemMap := make(map[int]int)\\n\\tfor _, v := range nums {\\n\\t\\tcurrPairs += elemMap[v]\\n\\t\\telemMap[v]++\\n\\t\\tif currPairs < k {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tfor currPairs >= k {\\n\\t\\t\\tremoveVal := nums[leftBound]\\n\\t\\t\\tdescPair := elemMap[removeVal] - 1\\n\\t\\t\\tif currPairs - descPair < k {\\n\\t\\t\\t\\t// remove is impossible\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t\\t// remove value of index leftBound\\n\\t\\t\\tcurrPairs -= descPair\\n\\t\\t\\telemMap[removeVal]--\\n\\t\\t\\tleftBound++\\n\\t\\t}\\n\\t\\ttotal += int64(leftBound +1)\\n\\t}\\n\\treturn total\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3753445,
                "title": "optimized-solution-using-sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& nums, int k) {\\n        long long cnt=0;\\n        unordered_map<long long,long long>m;\\n        set<int>s;\\n        long long curr=0;\\n        int j=0;\\n        for(int i=0;i<nums.size();i++){\\n            m[nums[i]]+=1;\\n            if(m[nums[i]]>1){\\n                int n=m[nums[i]];\\n                curr+=n-1;\\n            }\\n            if(curr>=k){\\n                while(curr>=k && j<nums.size() && j<i){\\n                    cnt+=nums.size()-i;\\n                    m[nums[j]]--;\\n                    curr-=m[nums[j]];\\n                    j++;\\n                }\\n            }\\n        }\\n        // for(int j=0;j<nums.size();j++){\\n        //     m[nums[j]]-=1;\\n        //     curr-=m[nums[j]];\\n        //     // if(s.find(nums[j])!=s.end()){\\n        //     //     curr-=m[nums[j]];\\n        //     //     if(m[nums[j]]==1){\\n        //     //         s.erase(nums[j]);\\n        //     //     }\\n        //     // }\\n        //     if(curr>=k){\\n        //         cnt+=1;\\n        //     }\\n        // }\\n        return cnt;\\n        //return curr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& nums, int k) {\\n        long long cnt=0;\\n        unordered_map<long long,long long>m;\\n        set<int>s;\\n        long long curr=0;\\n        int j=0;\\n        for(int i=0;i<nums.size();i++){\\n            m[nums[i]]+=1;\\n            if(m[nums[i]]>1){\\n                int n=m[nums[i]];\\n                curr+=n-1;\\n            }\\n            if(curr>=k){\\n                while(curr>=k && j<nums.size() && j<i){\\n                    cnt+=nums.size()-i;\\n                    m[nums[j]]--;\\n                    curr-=m[nums[j]];\\n                    j++;\\n                }\\n            }\\n        }\\n        // for(int j=0;j<nums.size();j++){\\n        //     m[nums[j]]-=1;\\n        //     curr-=m[nums[j]];\\n        //     // if(s.find(nums[j])!=s.end()){\\n        //     //     curr-=m[nums[j]];\\n        //     //     if(m[nums[j]]==1){\\n        //     //         s.erase(nums[j]);\\n        //     //     }\\n        //     // }\\n        //     if(curr>=k){\\n        //         cnt+=1;\\n        //     }\\n        // }\\n        return cnt;\\n        //return curr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3750754,
                "title": "easy-sliding-window-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. --\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst find that starting index that has k equal pairs(take two pointers i and j increase j till it reaches that index).From that index to last index all the subarrays will be valid as they will have k or more than equal pairs. How start decreasing i till the above condition does not qualify and store it in ans variable .\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    long long countGood(vector<int>& nums, int k) {\\n        unordered_map<long long int,long  long int>mp;\\n        unordered_map<long long int,long long int>pairs;\\n        int i=0,j=0;\\n      \\n        int n=nums.size();\\n        long long int totalPairs=0;\\n        long long int ans=0;\\n        while(j<n){\\n           if(pairs.find(nums[j])!=pairs.end()) totalPairs-=pairs[nums[j]];\\n            mp[nums[j]]++;\\n            long long int freq=mp[nums[j]];\\n            pairs[nums[j]]=(freq)*(freq-1)/2;\\n            totalPairs+=pairs[nums[j]];\\n            while(i<=j && j<n && totalPairs>=k){\\n                ans+=(n-j);\\n                mp[nums[i]]--;\\n                totalPairs-=pairs[nums[i]];\\n                long long int currFreq=mp[nums[i]];\\n                pairs[nums[i]]=(currFreq)*(currFreq-1)/2;\\n                totalPairs+=pairs[nums[i]];\\n                i++;\\n            }\\n           \\n            \\n            j++;\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    long long countGood(vector<int>& nums, int k) {\\n        unordered_map<long long int,long  long int>mp;\\n        unordered_map<long long int,long long int>pairs;\\n        int i=0,j=0;\\n      \\n        int n=nums.size();\\n        long long int totalPairs=0;\\n        long long int ans=0;\\n        while(j<n){\\n           if(pairs.find(nums[j])!=pairs.end()) totalPairs-=pairs[nums[j]];\\n            mp[nums[j]]++;\\n            long long int freq=mp[nums[j]];\\n            pairs[nums[j]]=(freq)*(freq-1)/2;\\n            totalPairs+=pairs[nums[j]];\\n            while(i<=j && j<n && totalPairs>=k){\\n                ans+=(n-j);\\n                mp[nums[i]]--;\\n                totalPairs-=pairs[nums[i]];\\n                long long int currFreq=mp[nums[i]];\\n                pairs[nums[i]]=(currFreq)*(currFreq-1)/2;\\n                totalPairs+=pairs[nums[i]];\\n                i++;\\n            }\\n           \\n            \\n            j++;\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3742898,
                "title": "sliding-window-concept-c-beginners-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& nums, int k) {\\n         int i=0;\\n         int j=0;int c=0;\\n         long long ans=0;\\n         int n=nums.size();\\n         unordered_map<int,int>mp;\\n         while(j<n)\\n         {\\n             if(mp.find(nums[j])!=mp.end())\\n             {\\n                 c+=mp[nums[j]];\\n             }mp[nums[j]]++;\\n             while(c>=k)\\n             {\\n                 ans+=n-j;\\n                 mp[nums[i]]--;\\n                 c-=mp[nums[i]];\\n                 i++;\\n             }j++;\\n         }return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& nums, int k) {\\n         int i=0;\\n         int j=0;int c=0;\\n         long long ans=0;\\n         int n=nums.size();\\n         unordered_map<int,int>mp;\\n         while(j<n)\\n         {\\n             if(mp.find(nums[j])!=mp.end())\\n             {\\n                 c+=mp[nums[j]];\\n             }mp[nums[j]]++;\\n             while(c>=k)\\n             {\\n                 ans+=n-j;\\n                 mp[nums[i]]--;\\n                 c-=mp[nums[i]];\\n                 i++;\\n             }j++;\\n         }return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3733980,
                "title": "java-sliding-window",
                "content": "```\\nclass Solution {\\n    public long countGood(int[] arr, int k) {\\n        HashMap<Integer , Integer> map = new HashMap<>();\\n        int i = 0;\\n        int j = 0;\\n        long ans = 0;\\n        long cur = 0;\\n        while(j < arr.length){\\n            int ele = arr[j];\\n            cur += map.getOrDefault(ele,0);\\n            map.put(ele , map.getOrDefault(ele , 0) + 1);\\n            \\n            while(cur >= k){\\n                ans += arr.length - j;\\n                map.put(arr[i] , map.getOrDefault(arr[i] , 0) - 1);\\n                cur -= map.get(arr[i]);\\n                i++;\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public long countGood(int[] arr, int k) {\\n        HashMap<Integer , Integer> map = new HashMap<>();\\n        int i = 0;\\n        int j = 0;\\n        long ans = 0;\\n        long cur = 0;\\n        while(j < arr.length){\\n            int ele = arr[j];\\n            cur += map.getOrDefault(ele,0);\\n            map.put(ele , map.getOrDefault(ele , 0) + 1);\\n            \\n            while(cur >= k){\\n                ans += arr.length - j;\\n                map.put(arr[i] , map.getOrDefault(arr[i] , 0) - 1);\\n                cur -= map.get(arr[i]);\\n                i++;\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3672673,
                "title": "mapping-soution-100-fast",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& nums, int k) {\\n        long long ans=0;\\n        unordered_map<int,int>mp; // Create an unordered map to store the frequency of each number\\n        for(int i=0,j=0;j<nums.size();j++){ // Use two pointers, i and j, to define a sliding window\\n            k-=mp[nums[j]]++; // Increase the count of nums[j] in the map and subtract it from k\\n            while(k<=0) // If k becomes less than or equal to 0\\n                k+=--mp[nums[i++]]; // Decrease the count of nums[i] in the map and add it to k, then move i to the right\\n            ans+=i; // Add the current value of i to the answer\\n        }\\n        return ans; // Return the final answer\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& nums, int k) {\\n        long long ans=0;\\n        unordered_map<int,int>mp; // Create an unordered map to store the frequency of each number\\n        for(int i=0,j=0;j<nums.size();j++){ // Use two pointers, i and j, to define a sliding window\\n            k-=mp[nums[j]]++; // Increase the count of nums[j] in the map and subtract it from k\\n            while(k<=0) // If k becomes less than or equal to 0\\n                k+=--mp[nums[i++]]; // Decrease the count of nums[i] in the map and add it to k, then move i to the right\\n            ans+=i; // Add the current value of i to the answer\\n        }\\n        return ans; // Return the final answer\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3668313,
                "title": "solution-c",
                "content": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    ll countGood(vector<int>& nums, int k) {\\n        ll res = 0, pairs = 0;\\n        unordered_map<int, int> m;\\n        int l = 0, r = 0, n = nums.size();\\n        while(r < n){\\n            pairs += m[nums[r]];            \\n            m[nums[r]]++;\\n            while(pairs >= k){\\n                res += n - r;\\n                pairs -= (m[nums[l]] - 1);\\n                m[nums[l]]--;\\n                l++;\\n            }\\n            r++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    ll countGood(vector<int>& nums, int k) {\\n        ll res = 0, pairs = 0;\\n        unordered_map<int, int> m;\\n        int l = 0, r = 0, n = nums.size();\\n        while(r < n){\\n            pairs += m[nums[r]];            \\n            m[nums[r]]++;\\n            while(pairs >= k){\\n                res += n - r;\\n                pairs -= (m[nums[l]] - 1);\\n                m[nums[l]]--;\\n                l++;\\n            }\\n            r++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3658355,
                "title": "java-simple-sliding-window-solution-using-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\n    public long countGood(int[] nums, int k) {\\n\\n        HashMap<Integer , Integer> map = new HashMap<>() ;\\n        long result = 0 ;\\n\\n        int i = 0 ;\\n        int j = 0 ;\\n        int pair = 0 ;\\n\\n        while(j < nums.length){\\n\\n            if(map.containsKey(nums[j])){\\n                pair += map.get(nums[j]) ;\\n            }\\n\\n            map.put(nums[j] , map.getOrDefault(nums[j] , 0) + 1);\\n\\n            while(pair >= k){\\n\\n                result += nums.length - j ;\\n\\n                if(map.get(nums[i]) > 1){\\n                    map.put(nums[i] , map.get(nums[i]) - 1 );\\n                    pair -= map.get(nums[i]) ;\\n                }else{\\n                    map.remove(nums[i]);\\n                }\\n\\n                i++ ;\\n            }\\n\\n            j++ ;\\n        }\\n\\n        return result ;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n    public long countGood(int[] nums, int k) {\\n\\n        HashMap<Integer , Integer> map = new HashMap<>() ;\\n        long result = 0 ;\\n\\n        int i = 0 ;\\n        int j = 0 ;\\n        int pair = 0 ;\\n\\n        while(j < nums.length){\\n\\n            if(map.containsKey(nums[j])){\\n                pair += map.get(nums[j]) ;\\n            }\\n\\n            map.put(nums[j] , map.getOrDefault(nums[j] , 0) + 1);\\n\\n            while(pair >= k){\\n\\n                result += nums.length - j ;\\n\\n                if(map.get(nums[i]) > 1){\\n                    map.put(nums[i] , map.get(nums[i]) - 1 );\\n                    pair -= map.get(nums[i]) ;\\n                }else{\\n                    map.remove(nums[i]);\\n                }\\n\\n                i++ ;\\n            }\\n\\n            j++ ;\\n        }\\n\\n        return result ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3609304,
                "title": "unveiling-the-hidden-treasures-of-good-subarrays-a-star-wars-inspired-journey",
                "content": "In a galaxy far, far away, there exists a problem known as the \"Good Subarrays\" conundrum. Our mission is to decipher this puzzle and provide a detailed explanation of the optimal solution. Join me, young Padawans, as we venture into the realm of algorithms and conquer this challenge!\\n\\nImagine you are a Jedi apprentice, armed with an array of integers, and your task is to count the number of \"good\" subarrays. A subarray is considered good if it contains at least `k` pairs of indices (i, j) where i < j and the elements at those indices are equal. Your training guide, Master Yoda, has provided you with a solution that claims to solve this problem. Let\\'s break it down and analyze its inner workings.\\n\\n```python\\nclass Solution:\\n    def countGood(self, nums: List[int], k: int) -> int:\\n        \\n        counter = defaultdict(int)\\n        i, j = 0, 0\\n        ans = 0\\n        while j < len(nums):\\n            if k <= 0:\\n                ans += len(nums) - j + 1\\n                counter[nums[i]] -= 1\\n                k += counter[nums[i]]\\n                i += 1\\n            else:\\n                k -= counter[nums[j]]\\n                counter[nums[j]] += 1\\n                j += 1\\n        while k <= 0:\\n            ans += 1\\n            counter[nums[i]] -= 1\\n            k += counter[nums[i]]\\n            i += 1\\n        return ans\\n```\\n\\nOur journey begins by initializing a `counter` dictionary, which will serve as our guiding beacon through the array. The variables `i` and `j` symbolize the indices of our subarray, while `ans` represents the number of good subarrays we have discovered thus far.\\n\\nWe traverse the array, much like a Jedi knight maneuvering through a treacherous battlefield. As we move forward, we encounter elements and face crucial decisions. At each step, we check if `k` has reached zero or gone below it. If it has, we have unlocked a good subarray! We celebrate this victory by adding the count of all remaining subarrays starting from index `i`. Additionally, we must ensure that our `counter` and `k` values reflect the changes made by the departing element at index `i`. Thus, we decrease the count of `nums[i]` in the `counter` and adjust `k` accordingly. We then gracefully glide to the next element, incrementing `i` and continuing our search.\\n\\nHowever, if `k` is still greater than zero, we must intensify our efforts. We diligently update `k` by subtracting the count of `nums[j]` from it, while simultaneously increasing the count of `nums[j]` in the `counter`. The subarray grows, and we advance to the next element, ready to face any challenge that comes our way.\\n\\nOur journey continues until the array\\'s end draws near. We have traversed the galaxy, fought bravely, and discovered numerous good subarrays. But wait! We may have missed some subarrays that extend beyond the final element. To rectify this, we embark on a final mission, ensuring that no good subarray escapes our grasp. We iterate once again, adding one to `ans` for each remaining subarray and adjusting the `counter` and `k` values as we have done before.\\n\\nAt last, our mission is complete, and we return the final count of good subarrays to our masters.\\n\\nNow, let\\'s analyze the time complexity of this solution. As we traverse the array only once, the time complexity is primarily dependent on the length of the array, denoted as `n`. The while loops allow us to adjust the `i` and `j` indices based on the `k` value, but they do not introduce any additional loops or nested operations. Therefore, the overall time complexity is O(n), which is quite efficient.\\n\\nIn conclusion, the provided solution, despite its initial flaws, holds the key to counting good subarrays efficiently. With its time complexity optimized, it can help us navigate the vast universe of arrays and unveil the hidden treasures of good subarrays. May the Force be with you as you venture forth and explore the mysteries of algorithms!",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def countGood(self, nums: List[int], k: int) -> int:\\n        \\n        counter = defaultdict(int)\\n        i, j = 0, 0\\n        ans = 0\\n        while j < len(nums):\\n            if k <= 0:\\n                ans += len(nums) - j + 1\\n                counter[nums[i]] -= 1\\n                k += counter[nums[i]]\\n                i += 1\\n            else:\\n                k -= counter[nums[j]]\\n                counter[nums[j]] += 1\\n                j += 1\\n        while k <= 0:\\n            ans += 1\\n            counter[nums[i]] -= 1\\n            k += counter[nums[i]]\\n            i += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3606239,
                "title": "easy-c-clean-concise-sliding-window-similar-to-no-of-subarrays-with-atleast-sum-k",
                "content": "\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& nums, int k) {\\n        \\n        long long ans = 0, i=0, j=0, cnt = 0, n=nums.size();//SAME AS DONE ALREADY BASED UPON NUMBER OF SUBARRAYS WITH SUM ATLEAST K\\n\\n        unordered_map<int, int> mp;\\n\\n        while(j<n){\\n\\n            mp[nums[j]]++;\\n            \\n            cnt+=mp[nums[j]]-1;//as if there are more than 2 occurences of number, we can choose any of already occurence with current occurence so adding mp[nums[j]]-1 in cnt\\n\\n            if(cnt<k)\\n            j++;\\n\\n            else{\\n\\n                while(cnt>=k){\\n\\n                    ans+=n-j;\\n                    \\n                    cnt-=mp[nums[i]]-1;\\n                    mp[nums[i]]--;\\n\\n                    \\n                    i++;\\n\\n                }\\n\\n                j++;\\n\\n            }\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& nums, int k) {\\n        \\n        long long ans = 0, i=0, j=0, cnt = 0, n=nums.size();//SAME AS DONE ALREADY BASED UPON NUMBER OF SUBARRAYS WITH SUM ATLEAST K\\n\\n        unordered_map<int, int> mp;\\n\\n        while(j<n){\\n\\n            mp[nums[j]]++;\\n            \\n            cnt+=mp[nums[j]]-1;//as if there are more than 2 occurences of number, we can choose any of already occurence with current occurence so adding mp[nums[j]]-1 in cnt\\n\\n            if(cnt<k)\\n            j++;\\n\\n            else{\\n\\n                while(cnt>=k){\\n\\n                    ans+=n-j;\\n                    \\n                    cnt-=mp[nums[i]]-1;\\n                    mp[nums[i]]--;\\n\\n                    \\n                    i++;\\n\\n                }\\n\\n                j++;\\n\\n            }\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3588850,
                "title": "easy-c-code-using-two-pointer-and-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nEasy approach use Two pointers. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIncrease window untill first Good subarray is found from a fixed left pointer.\\nThe total subarrays for this left index will be (n-r) since all subarray (l..r) to subarray (l..n-1) will be Good.\\n\\nAs freq of an element >1 the count of equal pairs increase by old freq of that element.\\n\\nUse this to keep track of the total no. of equal pairs in a subarray as you iterate r.\\n\\nWhen Total equal pairs >k, add n-r to answer, remove left elemnt and decrease equal pair count by (freq of left element -1) as that many pairs will be lost..\\n\\nBut keep it in a loop because after removing left element the array could still be good. \\n\\nIf it is, keep adding (n-r) till subarray is not good.\\n\\nThen again start searching and repeat till left!\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& nums, int k) {\\n\\n        long long ans=0;\\n        int n=nums.size();\\n\\n        long long count=0;\\n\\n        int l=0,r=0;\\n\\n        unordered_map<int,int> um;\\n\\n\\n        while(l<n-1 && r<n){\\n\\n            um[nums[r]]++;\\n            if(um[nums[r]]>1){\\n                count+=um[nums[r]]-1;\\n            }\\n            while(count>=k){\\n                ans+=n-r;\\n                count-=um[nums[l]]-1;\\n                um[nums[l]]--;\\n                l=l+1;\\n            }\\n            r++;\\n\\n        }\\n\\n\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& nums, int k) {\\n\\n        long long ans=0;\\n        int n=nums.size();\\n\\n        long long count=0;\\n\\n        int l=0,r=0;\\n\\n        unordered_map<int,int> um;\\n\\n\\n        while(l<n-1 && r<n){\\n\\n            um[nums[r]]++;\\n            if(um[nums[r]]>1){\\n                count+=um[nums[r]]-1;\\n            }\\n            while(count>=k){\\n                ans+=n-r;\\n                count-=um[nums[l]]-1;\\n                um[nums[l]]--;\\n                l=l+1;\\n            }\\n            r++;\\n\\n        }\\n\\n\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3577047,
                "title": "python-sliding-window-3-pointers",
                "content": "We manually count number of pairs. By manually I mean instead of `nC2`.\\n\\nFor example `[1,1,1,1,1]` will be counted as: \\n```\\n1 -> +0 <-- cannot form a pairs as not enough same nums\\n1,1 -> +1 pair\\n1,1,1 -> +2 pairs\\n1,1,1,1 -> +3 pairs\\n1,1,1,1,1 -> +4 pairs\\n\\ntotal = 10 pairs\\n```\\nWe use 3 pointers. It\\'s easier to explain this way: `left`, `mid`, `right`\\nAt first we expand the current window (move `right` pointer) until it becomes `valid`- has k required pairs.\\nThis will be of size `right - mid + 1`.\\n\\nThen we shrink the window by using `mid` pointer to the right until the window becomes invalid (`pairs >= k` condition fails).\\nAfter this we will have:\\n`mid - 1...right` is our minimum valid window with at least k pairs.\\nWhy `- 1`? because we just made it invalid.\\nWhy do we need to make it invalid with `>= k` and not just `> k`?\\nWe need this in order to start counting `valid` windows as soon as we have one.\\nIf we don\\'t make it invalid, we are missing the `[1,1,1,1,1]` valid window with `k=10` pairs.\\n\\nIn the case `> k` `mid` will not be incremented by `1` and later `mid - left` will result in `0`, but we know that by the moment we processed the last `1` in the input, we already have 1 valid window which needs to be counted.\\n\\n`left...mid` is the padding that forms valid subarrays/windows with at least k pairs to the left of the `mid - 1...right` window.\\n```\\n[x,x,x,1,1]\\n```\\n`mid - left` will be `1,1` + 3 previous windows formed with `[x,x,x]`\\n\\n```\\nclass Solution:\\n    def countGood(self, nums: List[int], k: int) -> int:\\n        N = len(nums)\\n        freq = defaultdict(int)\\n        left = 0\\n        mid = 0\\n        count = 0\\n        pairs = 0\\n        for right in range(N):\\n            freq[nums[right]] += 1\\n            if freq[nums[right]] > 1: # pair - at least 2 same numbers\\n                pairs += freq[nums[right]] - 1 # x,1,1,1,1 -> 1+2+3+4=10\\n            while pairs >= k:\\n                freq[nums[mid]] -= 1\\n                if freq[nums[mid]] > 0: # if still a pair, decrease pairs\\n                    pairs -= freq[nums[mid]]\\n                mid += 1\\n            count += mid - left # shrinked to the right min valid window\\n        return count\\n```\\nThe same w/o conditions and remove `left` as it\\'s always `0`:\\n```\\nclass Solution:\\n    def countGood(self, nums: List[int], k: int) -> int:\\n        freq = defaultdict(int)\\n        left = count = pairs = 0\\n        for right in range(len(nums)):\\n            freq[nums[right]] += 1\\n            pairs += freq[nums[right]] - 1\\n            while pairs >= k:\\n                freq[nums[left]] -= 1\\n                pairs -= freq[nums[left]]\\n                left += 1\\n            count += left\\n        return count\\n```",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```\\n1 -> +0 <-- cannot form a pairs as not enough same nums\\n1,1 -> +1 pair\\n1,1,1 -> +2 pairs\\n1,1,1,1 -> +3 pairs\\n1,1,1,1,1 -> +4 pairs\\n\\ntotal = 10 pairs\\n```\n```\\n[x,x,x,1,1]\\n```\n```\\nclass Solution:\\n    def countGood(self, nums: List[int], k: int) -> int:\\n        N = len(nums)\\n        freq = defaultdict(int)\\n        left = 0\\n        mid = 0\\n        count = 0\\n        pairs = 0\\n        for right in range(N):\\n            freq[nums[right]] += 1\\n            if freq[nums[right]] > 1: # pair - at least 2 same numbers\\n                pairs += freq[nums[right]] - 1 # x,1,1,1,1 -> 1+2+3+4=10\\n            while pairs >= k:\\n                freq[nums[mid]] -= 1\\n                if freq[nums[mid]] > 0: # if still a pair, decrease pairs\\n                    pairs -= freq[nums[mid]]\\n                mid += 1\\n            count += mid - left # shrinked to the right min valid window\\n        return count\\n```\n```\\nclass Solution:\\n    def countGood(self, nums: List[int], k: int) -> int:\\n        freq = defaultdict(int)\\n        left = count = pairs = 0\\n        for right in range(len(nums)):\\n            freq[nums[right]] += 1\\n            pairs += freq[nums[right]] - 1\\n            while pairs >= k:\\n                freq[nums[left]] -= 1\\n                pairs -= freq[nums[left]]\\n                left += 1\\n            count += left\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3573066,
                "title": "sliding-window-python3",
                "content": "# Intuition\\nAt first I thought I would need a nested loop to enumerate all sub-arrays, then found a way to solve with a sliding window. I think this may still be $$O(n^2)$$ but not sure.\\n\\n# Approach\\nCreate a sliding window; while the sub-array within the window is good, move the left pointer forward until it\\'s no longer good; while it\\'s not good, move the right pointer forward until it\\'s good again. Any time a new good sub-array is found, increment the number of good sub-arrays by not only 1 but the number of additional sub-arrays to the end of the list that include it.\\n\\n# Complexity\\n- Time complexity: Unsure.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(k)$$ where $$k$$ is the number of different values in $$nums$$. Can approach $$O(n)$$ in the worst case.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def calcPairs(self, n: int) -> int:\\n        return n * (n - 1) / 2\\n\\n    def countGood(self, nums: List[int], k: int) -> int:\\n        # goodness keeps track of the counts of each value\\n        # in the current window\\n        goodness = {}\\n        pair_ct = 0\\n        good_subarrays_ct = 0\\n        # we will use a sliding window to hunt for goodness; this\\n        # only needs O(n) time!!\\n        idx_left = 0 # about to drop\\n        idx_right = 1 # about to add\\n        goodness[nums[idx_left]] = 1\\n        while idx_right <= len(nums):\\n            if pair_ct >= k:\\n                #print(\"{}-{} is good, adding {}\".format(idx_left, idx_right - 1, len(nums) - idx_right + 1))\\n                good_subarrays_ct += len(nums) - idx_right + 1\\n                # when the array is known to be good, move the left end until\\n                # it\\'s no longer good or left catches up to right\\n                pair_ct -= self.calcPairs(goodness[nums[idx_left]])\\n                goodness[nums[idx_left]] -= 1\\n                pair_ct += self.calcPairs(goodness[nums[idx_left]])\\n                idx_left += 1\\n                if idx_left >= idx_right:\\n                    idx_right = idx_left + 1\\n            else:\\n                #print(\"{} is not good\".format(goodness))\\n                if idx_right < len(nums):\\n                    # when the array is not yet good, consume the element at right\\n                    # and increment right\\n                    if nums[idx_right] in goodness:\\n                        pair_ct -= self.calcPairs(goodness[nums[idx_right]])\\n                    goodness[nums[idx_right]] = goodness.get(nums[idx_right], 0) + 1\\n                    pair_ct += self.calcPairs(goodness[nums[idx_right]])\\n                idx_right += 1\\n        return good_subarrays_ct\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def calcPairs(self, n: int) -> int:\\n        return n * (n - 1) / 2\\n\\n    def countGood(self, nums: List[int], k: int) -> int:\\n        # goodness keeps track of the counts of each value\\n        # in the current window\\n        goodness = {}\\n        pair_ct = 0\\n        good_subarrays_ct = 0\\n        # we will use a sliding window to hunt for goodness; this\\n        # only needs O(n) time!!\\n        idx_left = 0 # about to drop\\n        idx_right = 1 # about to add\\n        goodness[nums[idx_left]] = 1\\n        while idx_right <= len(nums):\\n            if pair_ct >= k:\\n                #print(\"{}-{} is good, adding {}\".format(idx_left, idx_right - 1, len(nums) - idx_right + 1))\\n                good_subarrays_ct += len(nums) - idx_right + 1\\n                # when the array is known to be good, move the left end until\\n                # it\\'s no longer good or left catches up to right\\n                pair_ct -= self.calcPairs(goodness[nums[idx_left]])\\n                goodness[nums[idx_left]] -= 1\\n                pair_ct += self.calcPairs(goodness[nums[idx_left]])\\n                idx_left += 1\\n                if idx_left >= idx_right:\\n                    idx_right = idx_left + 1\\n            else:\\n                #print(\"{} is not good\".format(goodness))\\n                if idx_right < len(nums):\\n                    # when the array is not yet good, consume the element at right\\n                    # and increment right\\n                    if nums[idx_right] in goodness:\\n                        pair_ct -= self.calcPairs(goodness[nums[idx_right]])\\n                    goodness[nums[idx_right]] = goodness.get(nums[idx_right], 0) + 1\\n                    pair_ct += self.calcPairs(goodness[nums[idx_right]])\\n                idx_right += 1\\n        return good_subarrays_ct\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3565576,
                "title": "java-easy-sliding-window-solution",
                "content": "```\\nclass Solution {\\n    public long countGood(int[] nums, int k) {\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        int i = 0;\\n        long ans = 0;\\n        int pairs = 0;\\n        for (int j = 0; j < nums.length; j++) {\\n            // Update the frequency count of the current number in the HashMap\\n            map.put(nums[j], map.getOrDefault(nums[j], 0) + 1);\\n            \\n            // Calculate the number of pairs with the same value\\n            pairs += map.get(nums[j]) - 1;\\n            \\n            // Check if the current window has more than or equal to k pairs\\n            while (pairs >= k) {\\n                // Update the answer by adding the length of the remaining subarrays\\n                ans += (nums.length - j);\\n                \\n                // Reduce the window size by moving the left pointer\\n                // Remove the contribution of nums[i] from pairs\\n                map.put(nums[i], map.get(nums[i]) - 1);\\n                pairs = pairs - map.get(nums[i]);\\n                i++;\\n            }       \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public long countGood(int[] nums, int k) {\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        int i = 0;\\n        long ans = 0;\\n        int pairs = 0;\\n        for (int j = 0; j < nums.length; j++) {\\n            // Update the frequency count of the current number in the HashMap\\n            map.put(nums[j], map.getOrDefault(nums[j], 0) + 1);\\n            \\n            // Calculate the number of pairs with the same value\\n            pairs += map.get(nums[j]) - 1;\\n            \\n            // Check if the current window has more than or equal to k pairs\\n            while (pairs >= k) {\\n                // Update the answer by adding the length of the remaining subarrays\\n                ans += (nums.length - j);\\n                \\n                // Reduce the window size by moving the left pointer\\n                // Remove the contribution of nums[i] from pairs\\n                map.put(nums[i], map.get(nums[i]) - 1);\\n                pairs = pairs - map.get(nums[i]);\\n                i++;\\n            }       \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3557680,
                "title": "c-simple-and-fast-solution-with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& nums, int k) {\\n        unordered_map<int,long long> mp;    // for maintaining the count of each number encountered within current sld wind\\n        int i=0;    \\n        int st=0;   // start ind of the sld wind\\n        int end=0;  // end ind of the sld wind exclusive [st,end)\\n        long long ans=0;    // no of good  subarrays\\n        int count=0;    // number of pairs which are equal(i<j && nums[i]==nums[j]) \\n        int n=nums.size();\\n\\n        while(end<n){\\n            while(end<n && count<k){\\n                if(mp.count(nums[end])){\\n                    count+=mp[nums[end]];\\n                }\\n                mp[nums[end]]++;\\n                end++;\\n            }\\n            if(count<k) break;\\n            i=st;\\n            while(st<end && count>=k){\\n                if(mp[nums[st]]==1){\\n                    mp.erase(nums[st]);\\n                }\\n                else{\\n                    mp[nums[st]]--;\\n                    count-=mp[nums[st]];\\n                }\\n                st++;\\n            }\\n            ans+=(st-i)*(n-end+1);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& nums, int k) {\\n        unordered_map<int,long long> mp;    // for maintaining the count of each number encountered within current sld wind\\n        int i=0;    \\n        int st=0;   // start ind of the sld wind\\n        int end=0;  // end ind of the sld wind exclusive [st,end)\\n        long long ans=0;    // no of good  subarrays\\n        int count=0;    // number of pairs which are equal(i<j && nums[i]==nums[j]) \\n        int n=nums.size();\\n\\n        while(end<n){\\n            while(end<n && count<k){\\n                if(mp.count(nums[end])){\\n                    count+=mp[nums[end]];\\n                }\\n                mp[nums[end]]++;\\n                end++;\\n            }\\n            if(count<k) break;\\n            i=st;\\n            while(st<end && count>=k){\\n                if(mp[nums[st]]==1){\\n                    mp.erase(nums[st]);\\n                }\\n                else{\\n                    mp[nums[st]]--;\\n                    count-=mp[nums[st]];\\n                }\\n                st++;\\n            }\\n            ans+=(st-i)*(n-end+1);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3538851,
                "title": "sliding-windows-python-super-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countGood(self, nums: List[int], k: int) -> int:\\n\\n\\n        count = collections.defaultdict(int)\\n        l = 0\\n        p = 0\\n        ans = 0\\n        for i in range(len(nums)):\\n            p += count[nums[i]]\\n            count[nums[i]] +=1\\n            while p >= k:\\n\\n                count[nums[l]] -=1\\n                p -= count[nums[l]]\\n                l +=1\\n            \\n\\n            ans +=  l\\n       \\n        return  ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countGood(self, nums: List[int], k: int) -> int:\\n\\n\\n        count = collections.defaultdict(int)\\n        l = 0\\n        p = 0\\n        ans = 0\\n        for i in range(len(nums)):\\n            p += count[nums[i]]\\n            count[nums[i]] +=1\\n            while p >= k:\\n\\n                count[nums[l]] -=1\\n                p -= count[nums[l]]\\n                l +=1\\n            \\n\\n            ans +=  l\\n       \\n        return  ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3497953,
                "title": "python3-solution-sliding-window",
                "content": "```\\nclass Solution:\\n    def countGood(self, nums: List[int], k: int) -> int:\\n        cnt = pairs = l = 0\\n        hm = dict()\\n        n = len(nums)\\n\\n        for r in range(n):\\n\\n            hm[nums[r]] = hm.get(nums[r],0)+1\\n            pairs += hm[nums[r]]-1\\n\\n            while pairs >= k:\\n                cnt += (n-r)\\n                hm[nums[l]]-=1\\n                pairs -= hm[nums[l]]\\n                l += 1\\n            \\n        return cnt\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countGood(self, nums: List[int], k: int) -> int:\\n        cnt = pairs = l = 0\\n        hm = dict()\\n        n = len(nums)\\n\\n        for r in range(n):\\n\\n            hm[nums[r]] = hm.get(nums[r],0)+1\\n            pairs += hm[nums[r]]-1\\n\\n            while pairs >= k:\\n                cnt += (n-r)\\n                hm[nums[l]]-=1\\n                pairs -= hm[nums[l]]\\n                l += 1\\n            \\n        return cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495505,
                "title": "proper-explanation-code-walk-through",
                "content": "![image](https://assets.leetcode.com/users/images/2839fc61-ee92-4bf1-b4a1-576405020c3e_1683438078.2784276.jpeg)\\n\\n\\n```\\nlet start=end=count=goodsubarr=0,map={}\\nwhile(end<nums.length){\\n \\xA0map[nums[end]]=map[nums[end]]+1 || 1\\n \\xA0count+=map[nums[end]]-1\\n  while(count>=k){\\n    goodsubarr+=nums.length-end\\n    map[nums[start]]--\\n    count-=map[nums[start]]\\n    start++\\n  }\\n  end++\\n}\\nconsole.log(goodsubarr)\\n\\n```",
                "solutionTags": [],
                "code": "```\\nlet start=end=count=goodsubarr=0,map={}\\nwhile(end<nums.length){\\n \\xA0map[nums[end]]=map[nums[end]]+1 || 1\\n \\xA0count+=map[nums[end]]-1\\n  while(count>=k){\\n    goodsubarr+=nums.length-end\\n    map[nums[start]]--\\n    count-=map[nums[start]]\\n    start++\\n  }\\n  end++\\n}\\nconsole.log(goodsubarr)\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3495493,
                "title": "with-proper-explanation",
                "content": "\\n[![image](https://assets.leetcode.com/users/images/e4464230-9c56-42cc-b31f-102bdb810038_1683437939.41247.jpeg)\\n](http://)",
                "solutionTags": [],
                "code": "\\n[![image](https://assets.leetcode.com/users/images/e4464230-9c56-42cc-b31f-102bdb810038_1683437939.41247.jpeg)\\n](http://)",
                "codeTag": "Unknown"
            },
            {
                "id": 3474632,
                "title": "java-sliding-window-solution-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nGet the (nums[start], nums[end]) that has more than k pairs, and add (len - end) for rest, add start and recalculate.\\nif we have 2 same num, we get 1 pair, if we get one more element, we will have two more pairs. Once we have one more elment, we will have prevCount - 1 more pairs.\\n\\n\\n[3,1,4,3,2,2,4], k = 2, len = 7.\\n1. Start from 3, stop at [3,1,4,3,2] add (len - end) = (7 - 4) [3,1,4,3,2] + [3,1,4,3,2,2] + [3,1,4,3,2,2,4].\\n2. Start++ to get [1,4,3,2,2], if pairs are still greater than k, add (len - start) or ++end to get[1,4,3,2,2,4]\\n3. Start++ to get[4,3,2,2,4].\\n\\nFrom each start we use sliding window to calculate all minimun possible good array.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\n    public long countGood(int[] nums, int k) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        long res = 0, pairs = 0;\\n        int start = 0, end = 0;        \\n        for(; end < nums.length; ++end){\\n            int n = nums[end];\\n            map.put(n, map.getOrDefault(n, 0) + 1);\\n            pairs += map.get(n) - 1;\\n            while(pairs >= k){\\n                res += (long)nums.length - end;\\n                n = nums[start++];\\n                pairs -= (long)map.get(n) - 1;                    \\n                map.put(n, map.get(n) - 1);     \\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long countGood(int[] nums, int k) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        long res = 0, pairs = 0;\\n        int start = 0, end = 0;        \\n        for(; end < nums.length; ++end){\\n            int n = nums[end];\\n            map.put(n, map.getOrDefault(n, 0) + 1);\\n            pairs += map.get(n) - 1;\\n            while(pairs >= k){\\n                res += (long)nums.length - end;\\n                n = nums[start++];\\n                pairs -= (long)map.get(n) - 1;                    \\n                map.put(n, map.get(n) - 1);     \\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3456056,
                "title": "count-the-number-of-good-subarrays",
                "content": "------------- Easy C++ Solution ----------------\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& nums, int k) {\\n        int i=0;\\n        int j=0;\\n        long long  count=0;\\n        int n=nums.size();\\n        map<int,int>freq;\\n        int pair=0;\\n        while(1){\\n            if(pair>=k){\\n                count+=n-j+1;\\n                pair-=freq[nums[i]]-1;\\n                freq[nums[i]]--;\\n                i++;\\n            }else{\\n                if(j==n) break;\\n                freq[nums[j]]++;\\n                pair+=freq[nums[j]]-1;\\n                j++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& nums, int k) {\\n        int i=0;\\n        int j=0;\\n        long long  count=0;\\n        int n=nums.size();\\n        map<int,int>freq;\\n        int pair=0;\\n        while(1){\\n            if(pair>=k){\\n                count+=n-j+1;\\n                pair-=freq[nums[i]]-1;\\n                freq[nums[i]]--;\\n                i++;\\n            }else{\\n                if(j==n) break;\\n                freq[nums[j]]++;\\n                pair+=freq[nums[j]]-1;\\n                j++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3442105,
                "title": "sliding-window-using-two-pointer-easy-and-concise-solution-short-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nused map to store frequency of elements \\n\\n# Complexity\\n- Time complexity:\\no(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& nums, int k) {\\n        long long cnt=0,j=0,ans=0,i=0;\\n        map<int,int> mp;\\n        while(j<nums.size()){\\n            mp[nums[j]]++;\\n            //cnt== number of pairs\\n            cnt+=mp[nums[j]]-1;\\n            j++;\\n            while(cnt>=k){\\n                // for taking all subarrays with count of pairs>=k\\n                ans+=nums.size()-j+1;\\n                // removing first element\\n                mp[nums[i]]--;\\n                cnt-=mp[nums[i]];\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& nums, int k) {\\n        long long cnt=0,j=0,ans=0,i=0;\\n        map<int,int> mp;\\n        while(j<nums.size()){\\n            mp[nums[j]]++;\\n            //cnt== number of pairs\\n            cnt+=mp[nums[j]]-1;\\n            j++;\\n            while(cnt>=k){\\n                // for taking all subarrays with count of pairs>=k\\n                ans+=nums.size()-j+1;\\n                // removing first element\\n                mp[nums[i]]--;\\n                cnt-=mp[nums[i]];\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3412726,
                "title": "short-concise-c-solution",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& nums, int k) {\\n        unordered_map<int,int> m {}; int npair = 0;\\n        long long cnt = 0 ; int sze = nums.size() , l = 0; \\n        for(int i = 0 ; i < sze ; i++){\\n            k -= m[nums[i]]++; \\n            while(k <= 0 ){cnt+= sze - i ; k+=--m[nums[l++]];}\\n        }   \\n\\n        return cnt ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& nums, int k) {\\n        unordered_map<int,int> m {}; int npair = 0;\\n        long long cnt = 0 ; int sze = nums.size() , l = 0; \\n        for(int i = 0 ; i < sze ; i++){\\n            k -= m[nums[i]]++; \\n            while(k <= 0 ){cnt+= sze - i ; k+=--m[nums[l++]];}\\n        }   \\n\\n        return cnt ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3391852,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& nums, int k) {\\n        long long ans = 0  , sum = 0 ;\\n        unordered_map<int , int> mp ; \\n        int j = 0 ; \\n        for(int i = 0 ; i < nums.size() ; i++){\\n            if(mp.find(nums[i]) != mp.end()){\\n                mp[nums[i]]++ ; \\n            }\\n            else {\\n                mp[nums[i]] = 0; \\n            }\\n            sum += mp[nums[i]] ; \\n            while(sum >= k){\\n                sum -= mp[nums[j]] ; \\n                int val = nums.size() - i  ; \\n                ans += val ;\\n                if(mp[nums[j]] == 0){\\n                    mp.erase(nums[j]) ; \\n                    j++ ;  \\n                }\\n                else {\\n                    mp[nums[j]]-- ;\\n                    j++ ;\\n                }\\n            }\\n        }\\n     \\n\\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& nums, int k) {\\n        long long ans = 0  , sum = 0 ;\\n        unordered_map<int , int> mp ; \\n        int j = 0 ; \\n        for(int i = 0 ; i < nums.size() ; i++){\\n            if(mp.find(nums[i]) != mp.end()){\\n                mp[nums[i]]++ ; \\n            }\\n            else {\\n                mp[nums[i]] = 0; \\n            }\\n            sum += mp[nums[i]] ; \\n            while(sum >= k){\\n                sum -= mp[nums[j]] ; \\n                int val = nums.size() - i  ; \\n                ans += val ;\\n                if(mp[nums[j]] == 0){\\n                    mp.erase(nums[j]) ; \\n                    j++ ;  \\n                }\\n                else {\\n                    mp[nums[j]]-- ;\\n                    j++ ;\\n                }\\n            }\\n        }\\n     \\n\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3379978,
                "title": "java-hashmap-two-pointer",
                "content": "```\\nclass Solution {\\n    public long countGood(int[] nums, int k) {\\n        HashMap<Integer, Integer> fmap = new HashMap<>();   //  frequency map\\n        long answer = 0l, pairs = 0l;\\n        int l = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            int val = nums[i];\\n            pairs += fmap.getOrDefault(val, 0);\\n            if (pairs >= k) {\\n\\t\\t\\t    //  take all the subarrays that starts at \\'l\\' and ends at (i), (i + 1), (i + 2), ...... (n-1)\\n\\t\\t\\t\\t//  because the number of equal pairs are going to increase or remain the same\\n                answer += (nums.length - i);\\n            }\\n            fmap.put(val, fmap.getOrDefault(val, 0) + 1);\\n            while (pairs >= k) {\\n                fmap.put(nums[l], fmap.get(nums[l]) - 1);\\n                pairs -= fmap.get(nums[l++]);\\n                if (pairs >= k) {\\n\\t\\t\\t\\t    //  take all the subarrays that starts at \\'l\\' and ends at (i), (i + 1), (i + 2), ...... (n-1)\\n\\t\\t\\t\\t\\t//  because the number of equal pairs are going to increase or remain the same\\n                    answer += (nums.length - i);\\n                }\\n\\t\\t\\t}\\n        }\\n        return answer;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public long countGood(int[] nums, int k) {\\n        HashMap<Integer, Integer> fmap = new HashMap<>();   //  frequency map\\n        long answer = 0l, pairs = 0l;\\n        int l = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            int val = nums[i];\\n            pairs += fmap.getOrDefault(val, 0);\\n            if (pairs >= k) {\\n\\t\\t\\t    //  take all the subarrays that starts at \\'l\\' and ends at (i), (i + 1), (i + 2), ...... (n-1)\\n\\t\\t\\t\\t//  because the number of equal pairs are going to increase or remain the same\\n                answer += (nums.length - i);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3375165,
                "title": "sliding-window-map-solution-and-approach-cpp",
                "content": "# Intuition and Approach\\n* apply sliding window.\\n* when you will find the window add the no. of sub arrays to the ans.\\n* move the left and base to next.\\n\\n# Complexity\\n- Time complexity:O(n)\\n\\n- Space complexity:O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& nums, int k) {\\n        map<int,int>mp;\\n        int l=0;\\n        int r=0;\\n        int b=0;\\n        int n=nums.size();\\n        long long cnt=0;\\n        long long ans=0;\\n        while(r<=n){\\n            if(cnt<k){\\n                if(r==n)break;\\n                int temp=mp[nums[r]];\\n                cnt+=temp;\\n                mp[nums[r]]++;\\n                r++;\\n            }\\n            else if(cnt>=k){\\n                // cout<<r<<\"\\\\n\";\\n                ans+=(l-b+1)*(n-r+1);\\n                int temp=mp[nums[l]];\\n                cnt-=(temp-1);\\n                mp[nums[l]]--;\\n                l++;\\n                b=l;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& nums, int k) {\\n        map<int,int>mp;\\n        int l=0;\\n        int r=0;\\n        int b=0;\\n        int n=nums.size();\\n        long long cnt=0;\\n        long long ans=0;\\n        while(r<=n){\\n            if(cnt<k){\\n                if(r==n)break;\\n                int temp=mp[nums[r]];\\n                cnt+=temp;\\n                mp[nums[r]]++;\\n                r++;\\n            }\\n            else if(cnt>=k){\\n                // cout<<r<<\"\\\\n\";\\n                ans+=(l-b+1)*(n-r+1);\\n                int temp=mp[nums[l]];\\n                cnt-=(temp-1);\\n                mp[nums[l]]--;\\n                l++;\\n                b=l;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3345084,
                "title": "sliding-window-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& nums, int k) {\\n        ll cnt=0;\\n        ll ans=0;\\n        int n=nums.size();\\n        int i=0;\\n        int j=0;\\n        map<ll,ll> mp;\\n        while(j<n){\\n            mp[nums[j]]++;\\n            ll a=mp[nums[j]];\\n            if(a==1){\\n                cnt+=(a*(a-1))/2;\\n            }\\n            else{\\n                cnt-=((a-1)*(a-2))/2;\\n                cnt+=(a*(a-1))/2;\\n            }\\n            while(i<j and cnt>=k){\\n                ans+=(n-j);\\n                ll b=mp[nums[i]];\\n                cnt-=(b*(b-1))/2;\\n                \\n                mp[nums[i]]--;\\n                b=mp[nums[i]];\\n                if(b!=0){\\n                    cnt+=(b)*(b-1)/2;\\n                }\\n                i++;\\n            }\\n            j++;\\n        } \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& nums, int k) {\\n        ll cnt=0;\\n        ll ans=0;\\n        int n=nums.size();\\n        int i=0;\\n        int j=0;\\n        map<ll,ll> mp;\\n        while(j<n){\\n            mp[nums[j]]++;\\n            ll a=mp[nums[j]];\\n            if(a==1){\\n                cnt+=(a*(a-1))/2;\\n            }\\n            else{\\n                cnt-=((a-1)*(a-2))/2;\\n                cnt+=(a*(a-1))/2;\\n            }\\n            while(i<j and cnt>=k){\\n                ans+=(n-j);\\n                ll b=mp[nums[i]];\\n                cnt-=(b*(b-1))/2;\\n                \\n                mp[nums[i]]--;\\n                b=mp[nums[i]];\\n                if(b!=0){\\n                    cnt+=(b)*(b-1)/2;\\n                }\\n                i++;\\n            }\\n            j++;\\n        } \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3320022,
                "title": "c-sliding-window-beat-95",
                "content": "```\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& nums, int k) {\\n        long long res = 0, cnt = 0;\\n        unordered_map<int,int> m;\\n        for(int l=0, r=0, n=nums.size(); l<n; l++){\\n            while(cnt<k && r<n){\\n                cnt += m[nums[r++]]++;\\n            }\\n            if(cnt >= k) res += n - r + 1;\\n            else break;\\n            cnt -= --m[nums[l]];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& nums, int k) {\\n        long long res = 0, cnt = 0;\\n        unordered_map<int,int> m;\\n        for(int l=0, r=0, n=nums.size(); l<n; l++){\\n            while(cnt<k && r<n){\\n                cnt += m[nums[r++]]++;\\n            }\\n            if(cnt >= k) res += n - r + 1;\\n            else break;\\n            cnt -= --m[nums[l]];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3283353,
                "title": "sliding-window-java-one-comment-to-understand-how-result-get-updated",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public long countGood(int[] nums, int k) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        long result = 0;\\n        int left = 0;\\n        int pairs = 0;\\n        for(int right = 0; right < nums.length; right++) {\\n            map.put(nums[right], map.getOrDefault(nums[right],0)+1);\\n            pairs = pairs+map.get(nums[right])-1;\\n            while(pairs >= k) {\\n                map.put(nums[left], map.get(nums[left])-1);\\n                pairs = pairs-map.get(nums[left]);\\n                left++;\\n            }\\n/*\\n1. now our left pointer pointing to an element where we have window which has less than k pairs \\n2. but before that left we can form left number of valid subarrays \\n3. subarrays are [0, right], [1, right], [2 , right]..... till [left, right]\\n4. so adding left to the result\\n*/\\n\\n            result = result+left;\\n        }\\n        return result;  \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long countGood(int[] nums, int k) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        long result = 0;\\n        int left = 0;\\n        int pairs = 0;\\n        for(int right = 0; right < nums.length; right++) {\\n            map.put(nums[right], map.getOrDefault(nums[right],0)+1);\\n            pairs = pairs+map.get(nums[right])-1;\\n            while(pairs >= k) {\\n                map.put(nums[left], map.get(nums[left])-1);\\n                pairs = pairs-map.get(nums[left]);\\n                left++;\\n            }\\n/*\\n1. now our left pointer pointing to an element where we have window which has less than k pairs \\n2. but before that left we can form left number of valid subarrays \\n3. subarrays are [0, right], [1, right], [2 , right]..... till [left, right]\\n4. so adding left to the result\\n*/\\n\\n            result = result+left;\\n        }\\n        return result;  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3268356,
                "title": "swift-sliding-window",
                "content": "\\n```\\nclass Solution {\\n    func countGood(_ nums: [Int], _ k: Int) -> Int {\\n        var map = [Int: Int]()\\n        var l = 0\\n        var pairs = 0\\n        var res = 0\\n        for r in 0..<nums.count {\\n            pairs += map[nums[r]] ?? 0\\n            map[nums[r], default: 0] += 1\\n            while pairs >= k {\\n                map[nums[l]]! -= 1\\n                pairs -= map[nums[l]]!\\n                l += 1\\n            } \\n            res += l\\n        }\\n        return res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Array",
                    "Hash Table",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    func countGood(_ nums: [Int], _ k: Int) -> Int {\\n        var map = [Int: Int]()\\n        var l = 0\\n        var pairs = 0\\n        var res = 0\\n        for r in 0..<nums.count {\\n            pairs += map[nums[r]] ?? 0\\n            map[nums[r], default: 0] += 1\\n            while pairs >= k {\\n                map[nums[l]]! -= 1\\n                pairs -= map[nums[l]]!\\n                l += 1\\n            } \\n            res += l\\n        }\\n        return res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3257278,
                "title": "runtime-118-ms-beats-98-11-memory-64-1-mb-beats-94-97-simple-sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvar countGood = function(nums, k) {\\n    let n = nums.length,map=new Map(), ans = 0, count = 0, left = 0, right = 0;\\n    \\n    while(right < n){\\n        //if it exist in window then we get 1 pair wich match the condition i < j and arr[i] == arr[j].  so we will increase the count fot this window so the we can match with k \\n        if(map.has(nums[right])){ \\n            count += map.get(nums[right])\\n           map.set(nums[right],map.get(nums[right])+1)\\n        }\\n        else{\\n          map.set(nums[right],1)\\n        }\\n\\n        // when our target match with k mean we gat k or more than k good pair\\n        while(count >= k){\\n            // deleting left index from window\\n            map.set(nums[left],map.get(nums[left])-1)\\n            count -= map.get(nums[left])\\n            left++\\n            \\n            //bcz if the window is valid for thai index then it will also valid for until last index of the arr\\n            ans += n - right;\\n        }\\n\\n        right++;\\n    }\\n\\n    return ans;\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar countGood = function(nums, k) {\\n    let n = nums.length,map=new Map(), ans = 0, count = 0, left = 0, right = 0;\\n    \\n    while(right < n){\\n        //if it exist in window then we get 1 pair wich match the condition i < j and arr[i] == arr[j].  so we will increase the count fot this window so the we can match with k \\n        if(map.has(nums[right])){ \\n            count += map.get(nums[right])\\n           map.set(nums[right],map.get(nums[right])+1)\\n        }\\n        else{\\n          map.set(nums[right],1)\\n        }\\n\\n        // when our target match with k mean we gat k or more than k good pair\\n        while(count >= k){\\n            // deleting left index from window\\n            map.set(nums[left],map.get(nums[left])-1)\\n            count -= map.get(nums[left])\\n            left++\\n            \\n            //bcz if the window is valid for thai index then it will also valid for until last index of the arr\\n            ans += n - right;\\n        }\\n\\n        right++;\\n    }\\n\\n    return ans;\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3237941,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& nums, int k) {\\n        map<int,int>mp;\\n        int i=0,j=0,n=nums.size();\\n        long long s=0,cnt=0;\\n        while(i<n)\\n        {\\n            if(mp[nums[i]]==0)\\n            {\\n                s+=(mp[nums[i]]*(mp[nums[i]]-1))/2;\\n                mp[nums[i]]++;\\n            }\\n            else{\\n                s-=(mp[nums[i]]*(mp[nums[i]]-1))/2;\\n                mp[nums[i]]++;\\n                s+=(mp[nums[i]]*(mp[nums[i]]-1))/2;\\n            }\\n            while(s>=k)\\n            {\\n                if(s>=k) cnt+=n-i;\\n                s-=(mp[nums[j]]*(mp[nums[j]]-1))/2;\\n                mp[nums[j]]--;\\n                s+=(mp[nums[j]]*(mp[nums[j]]-1))/2;\\n                j++;\\n            }\\n            i++;\\n        }\\n        return cnt;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& nums, int k) {\\n        map<int,int>mp;\\n        int i=0,j=0,n=nums.size();\\n        long long s=0,cnt=0;\\n        while(i<n)\\n        {\\n            if(mp[nums[i]]==0)\\n            {\\n                s+=(mp[nums[i]]*(mp[nums[i]]-1))/2;\\n                mp[nums[i]]++;\\n            }\\n            else{\\n                s-=(mp[nums[i]]*(mp[nums[i]]-1))/2;\\n                mp[nums[i]]++;\\n                s+=(mp[nums[i]]*(mp[nums[i]]-1))/2;\\n            }\\n            while(s>=k)\\n            {\\n                if(s>=k) cnt+=n-i;\\n                s-=(mp[nums[j]]*(mp[nums[j]]-1))/2;\\n                mp[nums[j]]--;\\n                s+=(mp[nums[j]]*(mp[nums[j]]-1))/2;\\n                j++;\\n            }\\n            i++;\\n        }\\n        return cnt;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3204796,
                "title": "c-simple-code",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& nums, int k) {\\n        int i=0,j=0;\\n        int n=nums.size();\\n        long long ans=0;\\n        int x=0;\\n        unordered_map<int,int>m;\\n        while(j<n)\\n        {\\n            m[nums[j]]++;\\n            if(m[nums[j]]>=2){\\n                x+=(m[nums[j]]-1);\\n            }\\n            if(x>=k){\\n                \\n                while(x>=k){\\n                    ans+=(n-j);\\n                    if(m[nums[i]]>=2){\\n                        x-=(m[nums[i]]-1);\\n                    }\\n                    m[nums[i]]--;\\n                    if(m[nums[i]]==0){\\n                        m.erase(nums[i]);\\n                    }\\n                    i++;\\n                }\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& nums, int k) {\\n        int i=0,j=0;\\n        int n=nums.size();\\n        long long ans=0;\\n        int x=0;\\n        unordered_map<int,int>m;\\n        while(j<n)\\n        {\\n            m[nums[j]]++;\\n            if(m[nums[j]]>=2){\\n                x+=(m[nums[j]]-1);\\n            }\\n            if(x>=k){\\n                \\n                while(x>=k){\\n                    ans+=(n-j);\\n                    if(m[nums[i]]>=2){\\n                        x-=(m[nums[i]]-1);\\n                    }\\n                    m[nums[i]]--;\\n                    if(m[nums[i]]==0){\\n                        m.erase(nums[i]);\\n                    }\\n                    i++;\\n                }\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3179511,
                "title": "easy-to-understand-sliding-window",
                "content": "```\\nclass Solution {\\npublic:   \\n    long long countGood(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        int pairs = 0;\\n        int l = 0;\\n        long long result = 0;\\n        unordered_map<int,int> mp;\\n        \\n        for (int i = 0; i < n; i++) {\\n            mp[nums[i]]++;\\n            // if elment is repeated n time then it is making n-1 pairs \\n            pairs += (mp[nums[i]]-1);\\n            // if we reached k pairs then freeze the result\\n            if (pairs >= k) {\\n                // slide the left window until we have less than k pairs\\n                while(pairs >= k) {\\n                    // we have valid n-i substring \\n                    result += (n-i);\\n                    mp[nums[l]]--;\\n                    // reducing the frequency of character, reduces pairs count by \\n                    // current frequency of a character\\n                    pairs -= (mp[nums[l]]);\\n                    l++;\\n                }\\n            }\\n        }\\n        return result;\\n       \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:   \\n    long long countGood(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        int pairs = 0;\\n        int l = 0;\\n        long long result = 0;\\n        unordered_map<int,int> mp;\\n        \\n        for (int i = 0; i < n; i++) {\\n            mp[nums[i]]++;\\n            // if elment is repeated n time then it is making n-1 pairs \\n            pairs += (mp[nums[i]]-1);\\n            // if we reached k pairs then freeze the result\\n            if (pairs >= k) {\\n                // slide the left window until we have less than k pairs\\n                while(pairs >= k) {\\n                    // we have valid n-i substring \\n                    result += (n-i);\\n                    mp[nums[l]]--;\\n                    // reducing the frequency of character, reduces pairs count by \\n                    // current frequency of a character\\n                    pairs -= (mp[nums[l]]);\\n                    l++;\\n                }\\n            }\\n        }\\n        return result;\\n       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3171643,
                "title": "c-sliding-window-intuitive",
                "content": "# Intuition\\nSince we are talking about subarrays of size k, the one thing that comes to mind is sliding window. Now the question that remains is how to find the number of good subarrays.\\n\\n# Approach\\nTo find the number of good subarrays we observe that:\\n1) When a number is added to a subarray, it increases the number of pairs by its previous appearances.\\n2) When a number is removed from the subarray, it decreases the number of pairs by its remaining appearances.\\n\\nSo we maintain a frequency map and while doing sliding window we count the number of subarrays till now. If the number exceeds k then we shrink our window.\\n\\nFinally we sum up the total number of subarrays and return it.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    ll countGood(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        unordered_map<ll, ll> m;\\n        ll cnt = 0;\\n        ll subs = 0;\\n        int j = 0;\\n        for (int i = 0; i < n; i++) {\\n            subs += m[nums[i]];\\n            m[nums[i]]++;\\n            while (subs >= k && j < i) {\\n                m[nums[j]]--;\\n                subs -= m[nums[j]];\\n                j++;\\n                cnt += n - i;\\n            }\\n        }\\n        return cnt;\\n    }\\n}; \\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Sliding Window"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    ll countGood(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        unordered_map<ll, ll> m;\\n        ll cnt = 0;\\n        ll subs = 0;\\n        int j = 0;\\n        for (int i = 0; i < n; i++) {\\n            subs += m[nums[i]];\\n            m[nums[i]]++;\\n            while (subs >= k && j < i) {\\n                m[nums[j]]--;\\n                subs -= m[nums[j]];\\n                j++;\\n                cnt += n - i;\\n            }\\n        }\\n        return cnt;\\n    }\\n}; \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3161511,
                "title": "c-o-n-sliding-window",
                "content": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        unordered_map <int, ll> m;\\n        int i = 0, j = 0; ll ans = 0, pairs = 0;\\n        while(j < n) {\\n            if(m.count(nums[j])) {\\n                pairs -= m[nums[j]] * (m[nums[j]] - 1) /2;\\n            }\\n            m[nums[j]]++;\\n            pairs += m[nums[j]] * (m[nums[j]] - 1) /2;\\n            if(pairs < k) {\\n                j++;\\n            } else if(pairs >= k) {\\n                while(pairs >= k) {\\n                    ans += n - j;\\n                    pairs -= m[nums[i]] * (m[nums[i]] - 1) /2;\\n                    m[nums[i]]--;\\n                    pairs += m[nums[i]] * (m[nums[i]] - 1) /2;\\n                    i++;\\n                }\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        unordered_map <int, ll> m;\\n        int i = 0, j = 0; ll ans = 0, pairs = 0;\\n        while(j < n) {\\n            if(m.count(nums[j])) {\\n                pairs -= m[nums[j]] * (m[nums[j]] - 1) /2;\\n            }\\n            m[nums[j]]++;\\n            pairs += m[nums[j]] * (m[nums[j]] - 1) /2;\\n            if(pairs < k) {\\n                j++;\\n            } else if(pairs >= k) {\\n                while(pairs >= k) {\\n                    ans += n - j;\\n                    pairs -= m[nums[i]] * (m[nums[i]] - 1) /2;\\n                    m[nums[i]]--;\\n                    pairs += m[nums[i]] * (m[nums[i]] - 1) /2;\\n                    i++;\\n                }\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3160038,
                "title": "dynamic-sliding-window-c",
                "content": "# Approach\\nDynamic sliding window\\n\\n# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        unordered_map<int,int> freq;\\n        int i=0;\\n        long long numOfPairs=0;\\n        long long ans=0;\\n        for(int j=0;j<n;j++)\\n        {\\n            freq[nums[j]]++;\\n            numOfPairs+=(freq[nums[j]]-1);\\n            while(i<j && numOfPairs>=k)\\n            {\\n                freq[nums[i]]--;\\n                numOfPairs-=freq[nums[i]];\\n                i++;\\n            }\\n            ans+=i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        unordered_map<int,int> freq;\\n        int i=0;\\n        long long numOfPairs=0;\\n        long long ans=0;\\n        for(int j=0;j<n;j++)\\n        {\\n            freq[nums[j]]++;\\n            numOfPairs+=(freq[nums[j]]-1);\\n            while(i<j && numOfPairs>=k)\\n            {\\n                freq[nums[i]]--;\\n                numOfPairs-=freq[nums[i]];\\n                i++;\\n            }\\n            ans+=i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3132931,
                "title": "golang-sliding-window",
                "content": "# Code\\n```\\n\\nfunc countGood(nums []int, k int) int64 {\\n    count := make(map[int]int)\\n    var ans int64 = 0\\n    var start, end int = 0, 0\\n    for end < len(nums) {\\n        k -= count[nums[end]]\\n        count[nums[end]]++\\n        for k <= 0 {\\n            count[nums[start]]--\\n            k += count[nums[start]]\\n            start++\\n        }\\n        ans += int64(start)\\n        end++\\n    }\\n    return ans\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Hash Table",
                    "Sliding Window"
                ],
                "code": "```\\n\\nfunc countGood(nums []int, k int) int64 {\\n    count := make(map[int]int)\\n    var ans int64 = 0\\n    var start, end int = 0, 0\\n    for end < len(nums) {\\n        k -= count[nums[end]]\\n        count[nums[end]]++\\n        for k <= 0 {\\n            count[nums[start]]--\\n            k += count[nums[start]]\\n            start++\\n        }\\n        ans += int64(start)\\n        end++\\n    }\\n    return ans\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3132908,
                "title": "c-sliding-window",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& nums, int k) {\\n        unordered_map<int, int> count;\\n        long long ans = 0;\\n        int start = 0;\\n        int end = 0;\\n        while(end < nums.size()) {\\n            k -= count[nums[end]]++;\\n            while(k <= 0) {\\n                k += --count[nums[start++]];\\n            }\\n            ans += start;\\n            end++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& nums, int k) {\\n        unordered_map<int, int> count;\\n        long long ans = 0;\\n        int start = 0;\\n        int end = 0;\\n        while(end < nums.size()) {\\n            k -= count[nums[end]]++;\\n            while(k <= 0) {\\n                k += --count[nums[start++]];\\n            }\\n            ans += start;\\n            end++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3119725,
                "title": "simple-solution-in-c-using-sliding-window-approach",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        long long i=0,j=0,count=0,res=0;\\n        map<long long,long long>mp;\\n        while(j<n)\\n        {\\n           mp[nums[j]]++;\\n           count+=(mp[nums[j]]-1);\\n           if(count<k)\\n           {\\n               j++;\\n           }\\n           else if(count>=k)\\n           {\\n               res+=n-j;\\n               while(count>=k)\\n               {\\n                   mp[nums[i]]--;\\n                   count-=mp[nums[i]];\\n                   if(count>=k)\\n                   res+=n-j;\\n                   if(mp[nums[i]]==0)\\n                   mp.erase(nums[i]);\\n                   i++;\\n               }\\n               j++;\\n           }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        long long i=0,j=0,count=0,res=0;\\n        map<long long,long long>mp;\\n        while(j<n)\\n        {\\n           mp[nums[j]]++;\\n           count+=(mp[nums[j]]-1);\\n           if(count<k)\\n           {\\n               j++;\\n           }\\n           else if(count>=k)\\n           {\\n               res+=n-j;\\n               while(count>=k)\\n               {\\n                   mp[nums[i]]--;\\n                   count-=mp[nums[i]];\\n                   if(count>=k)\\n                   res+=n-j;\\n                   if(mp[nums[i]]==0)\\n                   mp.erase(nums[i]);\\n                   i++;\\n               }\\n               j++;\\n           }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3116054,
                "title": "another-sliding-window-at-most-problem-golang-o-n-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWhen I saw the \"at least\" keyword in the problem, I started to think this might be an \"at most\" sliding window problem. The whole idea is instead of finding ***the number of subarrays that has \"at least k good pairs\"***, we will find ***the number of subarrays that has \"at most k-1 good pairs\" (let\\'s call it \\'total\\')***, then our result would be total subarrays - \"at most k-1 good pairs\" subarrays = n*(n+1)/2 - total.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nt = our good pairs in the window.\\nseen = map to keep the count of the numbers are in the current window.\\ntotal = number of subarray that has \"at most k-1 good pairs\"\\n\\n**Expanding Window:**\\n- Each time we add nums[i] to the window, t += seen[nums[i]] - 1, because we can pair this new nums[i] with seen[nums[i]] - 1 other elements in the window to form a good pair.\\n\\n**Shrinking Window:**\\n- The condition of shirking is when t > k-1, because we are trying to get the subarray with at most k-1 good pairs\\n- Each time we remove nums[j] out of the window, t -= seen[nums[j]]-1.\\n\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Other \"At Most\" Sliding Window Problems:\\n- [https://leetcode.com/problems/count-number-of-nice-subarrays/description/](https://leetcode.com/problems/count-number-of-nice-subarrays/description/)\\n- [https://leetcode.com/problems/longest-substring-with-at-least-k-repeating-characters/](https://leetcode.com/problems/longest-substring-with-at-least-k-repeating-characters/)\\n- [https://leetcode.com/problems/binary-subarrays-with-sum/description/](https://leetcode.com/problems/binary-subarrays-with-sum/description/)\\n- [https://leetcode.com/problems/number-of-substrings-containing-all-three-characters/description/](https://leetcode.com/problems/number-of-substrings-containing-all-three-characters/description/)\\n- [https://leetcode.com/problems/subarrays-with-k-different-integers/description/](https://leetcode.com/problems/subarrays-with-k-different-integers/description/)\\n- [https://leetcode.com/problems/number-of-substrings-containing-all-three-characters/description/](https://leetcode.com/problems/number-of-substrings-containing-all-three-characters/description/)\\n\\n# Code\\n```\\n\\nfunc countGood(nums []int, k int) int64 {\\n\\tvar t int64 = 0\\n\\tvar total int64 = 0\\n\\tseen := make(map[int]int)\\n\\tn := int64(len(nums))\\n\\tj := 0\\n\\tfor i := 0; i < len(nums); i++ {\\n\\t\\tseen[nums[i]]++\\n\\t\\tt += int64(seen[nums[i]] - 1)\\n\\t\\tfor j < i && t > int64(k-1) {\\n\\t\\t\\tt -= int64(seen[nums[j]] - 1)\\n\\t\\t\\tseen[nums[j]]--\\n\\t\\t\\tj++\\n\\t\\t}\\n\\t\\ttotal += int64(i - j + 1)\\n\\t}\\n\\treturn n*(n+1)/2 - total\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\n\\nfunc countGood(nums []int, k int) int64 {\\n\\tvar t int64 = 0\\n\\tvar total int64 = 0\\n\\tseen := make(map[int]int)\\n\\tn := int64(len(nums))\\n\\tj := 0\\n\\tfor i := 0; i < len(nums); i++ {\\n\\t\\tseen[nums[i]]++\\n\\t\\tt += int64(seen[nums[i]] - 1)\\n\\t\\tfor j < i && t > int64(k-1) {\\n\\t\\t\\tt -= int64(seen[nums[j]] - 1)\\n\\t\\t\\tseen[nums[j]]--\\n\\t\\t\\tj++\\n\\t\\t}\\n\\t\\ttotal += int64(i - j + 1)\\n\\t}\\n\\treturn n*(n+1)/2 - total\\n}\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3113525,
                "title": "sliding-window",
                "content": "# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public long countGood(int[] nums, int k) {\\n        \\n        Map<Integer, Integer> count = new HashMap<>();\\n\\n        int right = 0;\\n        int left = 0;\\n        long res = 0;\\n        int numPairs = 0;\\n        while (right < nums.length) {\\n            int elem = nums[right];\\n            Integer c = count.get(elem);\\n            if (c == null) {\\n                c = 0;\\n            }    \\n            count.put(elem, c + 1);\\n            if (c > 0) {\\n                numPairs += c;\\n            }\\n            while (left < right && numPairs >= k) {\\n                elem = nums[left];\\n                c = count.get(elem);\\n                if (c > 1) {\\n                    // At least one pair for this element\\n                    if (numPairs - (c-1) < k) {\\n                        // Don\\'t move \\'left\\' forward as it would break the condition\\n                        break;\\n                    }\\n                    // We move \\'left\\' forward as it will not break the condition\\n                    numPairs -= (c-1);\\n                    count.put(elem, c - 1);\\n                    left++;\\n                }\\n                else {\\n                    // No pair for this element: we can move \\'left\\' forward\\n                    count.put(elem, c - 1);\\n                    left++;\\n                }\\n            }\\n            if (numPairs >= k) {\\n                // Get all subarrays ending at right and starting from 0 to left\\n                res += left + 1;\\n            }\\n            ++right;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long countGood(int[] nums, int k) {\\n        \\n        Map<Integer, Integer> count = new HashMap<>();\\n\\n        int right = 0;\\n        int left = 0;\\n        long res = 0;\\n        int numPairs = 0;\\n        while (right < nums.length) {\\n            int elem = nums[right];\\n            Integer c = count.get(elem);\\n            if (c == null) {\\n                c = 0;\\n            }    \\n            count.put(elem, c + 1);\\n            if (c > 0) {\\n                numPairs += c;\\n            }\\n            while (left < right && numPairs >= k) {\\n                elem = nums[left];\\n                c = count.get(elem);\\n                if (c > 1) {\\n                    // At least one pair for this element\\n                    if (numPairs - (c-1) < k) {\\n                        // Don\\'t move \\'left\\' forward as it would break the condition\\n                        break;\\n                    }\\n                    // We move \\'left\\' forward as it will not break the condition\\n                    numPairs -= (c-1);\\n                    count.put(elem, c - 1);\\n                    left++;\\n                }\\n                else {\\n                    // No pair for this element: we can move \\'left\\' forward\\n                    count.put(elem, c - 1);\\n                    left++;\\n                }\\n            }\\n            if (numPairs >= k) {\\n                // Get all subarrays ending at right and starting from 0 to left\\n                res += left + 1;\\n            }\\n            ++right;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3109015,
                "title": "swift-sliding-window",
                "content": "# Reference\\nInspired by https://leetcode.com/problems/count-the-number-of-good-subarrays/solutions/3052559/java-c-python-sliding-window/.\\n\\n# Idea\\n## Algorithm: Sliding Window\\nWe can use a sliding window approach to solve this problem. By iterating through each element in the `nums` array, we will move the right index of the window. During each iteration, we will also check if the current sliding window is a \"good\" sub array. If it is, we will then move the left index of the window until the sliding window is no longer a \"good\" sub array. \\n\\n## Calculating Number of Good Sub Array\\nWhen the current sliding window is a good subarray, then all of the sub array starting from `0` to (current left index + 1) will be a good sub array to. Therefore, we can add the number of good sub array for the current sliding window by adding (the left index + 1) instead.\\nFor example: we have `nums`: `[1, 2, 3, 3]` and `k` = `1`. If `[3, 3]` is a good sub array, then `[2, 3, 3]` and `[1, 2, 3, 3]` will be good sub array too. Therefore, we can add `2 + 1` (`left index: 2 + 1)` as the number of good sub array to our answer.\\n\\n## Calculating Number Of Pairs Combinations\\nThere are some pattern that we can observe between the number of an element vs the number of pairs combination.\\n| Number Count | Number of Combinations |\\n| --- | --- |\\n| 0 | 0 |\\n| 1 | 0 |\\n| 2 | 1 |\\n| 3 | 3 |\\n| 4 | 6 |\\n\\nFrom the table above, we can observe some pattern between the count of a number and the number of pairs combination. \\n\\nWhenever the number of element is increase by 1, then we will have a new existing count of that number (before added by 1) pairs combination. For example: \\n- when the number of element is changed from 2 to 3, then we will have 2 new combination of pairs (from 1 pairs to 3 pairs). \\n- when the number of pairs is changed from 3 to 4, then we will have 3 new pairs combination (from 3 pairs to 6 pairs).\\n\\nMeanwhile, when the number of element is decreased by 1, we will lose the current count of that number (after we decreased by 1) number of pairs combination. For example:\\n- when the number of element is changed from 3 to 2, then we will lose 2 pairs combination (from 3 pairs to 1 pairs)\\n- when the number of element is changed from 4 to 3, then we will lose 3 pairs combination (from 6 pairs to 3 pairs)\\n\\nTherefore, when we move our sliding window, we can use this pattern to calculate the number of `k` pairs required in order the sub array to be a good sub array.\\n\\n# Code\\n```\\nclass Solution {\\n    func countGood(_ nums: [Int], _ k: Int) -> Int {\\n        var answer = 0\\n        // kNeeded: the number of pairs required in order for the sliding window to be a \\'good sub array\\'.\\n        var kNeeded = k \\n        // counter: a dictionary for storing the count of each number from our sliding window.\\n        var counter: [Int: Int] = [:]\\n        // leftIndex: the left index of our sliding window.\\n        var leftIndex: Int = 0\\n        // leftNumber: a getter helper for retrieving our the left most number from our sliding window.\\n        var leftNumber: Int { return nums[leftIndex] }\\n        for (rightIndex, rightNumber) in nums.enumerated() {\\n            // during each loop, we will add the rightNumber to our sliding window.\\n            // we can reduce the number of pairs needed by using the pattern we observed earlier\\n            kNeeded -= counter[rightNumber, default: 0]\\n            counter[rightNumber, default: 0] += 1\\n            // kNeeded <= 0 means that this is a good sub array.\\n            while kNeeded <= 0 {\\n                counter[leftNumber, default: 0] -= 1\\n                // we can increase the number of pairs needed by using the pattern we observed earlier.\\n                kNeeded += counter[leftNumber, default: 0]\\n                // move the leftIndex of our sliding window until the subarray is no longer a \\'good sub array\\'.\\n                leftIndex += 1\\n            }\\n            // using the pattern we observed earlier, we increase the number of good subarray by using (left index + 1)\\n            answer += leftIndex\\n        }\\n        \\n        return answer\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func countGood(_ nums: [Int], _ k: Int) -> Int {\\n        var answer = 0\\n        // kNeeded: the number of pairs required in order for the sliding window to be a \\'good sub array\\'.\\n        var kNeeded = k \\n        // counter: a dictionary for storing the count of each number from our sliding window.\\n        var counter: [Int: Int] = [:]\\n        // leftIndex: the left index of our sliding window.\\n        var leftIndex: Int = 0\\n        // leftNumber: a getter helper for retrieving our the left most number from our sliding window.\\n        var leftNumber: Int { return nums[leftIndex] }\\n        for (rightIndex, rightNumber) in nums.enumerated() {\\n            // during each loop, we will add the rightNumber to our sliding window.\\n            // we can reduce the number of pairs needed by using the pattern we observed earlier\\n            kNeeded -= counter[rightNumber, default: 0]\\n            counter[rightNumber, default: 0] += 1\\n            // kNeeded <= 0 means that this is a good sub array.\\n            while kNeeded <= 0 {\\n                counter[leftNumber, default: 0] -= 1\\n                // we can increase the number of pairs needed by using the pattern we observed earlier.\\n                kNeeded += counter[leftNumber, default: 0]\\n                // move the leftIndex of our sliding window until the subarray is no longer a \\'good sub array\\'.\\n                leftIndex += 1\\n            }\\n            // using the pattern we observed earlier, we increase the number of good subarray by using (left index + 1)\\n            answer += leftIndex\\n        }\\n        \\n        return answer\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3108375,
                "title": "c-sliding-window",
                "content": "# Intuition\\nUse sliding window, for each position $end$, find which position $start$ is the position that abs(end - start) is minimum among all the good substrings [start:end] ($start$ to be 0 is no substring [start:end] is good). \\nWe increase $end$ by 1 in each iteration, and with $end$ to be increased, the $start$ could only stay in same position or increase. This satisfies the criteria for sliding window to be applied.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& nums, int k) {\\n        unordered_map<int, int> map;\\n        int start = 0;\\n        int len = nums.size();\\n        int cnt = 0;\\n        long long result = 0;\\n        for (int end = 0; end < len; ++end) {\\n            cnt += map[nums[end]]++;\\n            if (cnt >= k) {\\n                while (cnt >= k) {\\n                    cnt -= --map[nums[start++]];\\n                }\\n                result += start--;\\n                cnt += map[nums[start]]++;\\n                // cout << end << \" \" << result << endl;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& nums, int k) {\\n        unordered_map<int, int> map;\\n        int start = 0;\\n        int len = nums.size();\\n        int cnt = 0;\\n        long long result = 0;\\n        for (int end = 0; end < len; ++end) {\\n            cnt += map[nums[end]]++;\\n            if (cnt >= k) {\\n                while (cnt >= k) {\\n                    cnt -= --map[nums[start++]];\\n                }\\n                result += start--;\\n                cnt += map[nums[start]]++;\\n                // cout << end << \" \" << result << endl;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3107071,
                "title": "accepted-explained-and-commented-kotlin-solution",
                "content": "\\n```\\nclass Solution {\\n    fun countGood(A: IntArray, k: Int): Long {\\n        var res = 0L\\n        val count = HashMap<Int, Int>() // Hashmap to store the count of each element in the array\\n        var i = 0\\n        var j = 0\\n        var k = k\\n        while (j < A.size) {\\n            k -= count.getOrDefault(A[j], 0) // subtract the count of current element from k\\n            count[A[j]] = count.getOrDefault(A[j], 0) + 1 // increment the count of current element in the hashmap\\n            while (k <= 0) {\\n                count[A[i]] = count[A[i]]!! - 1 // decrement the count of the first element in the window\\n                k += count[A[i++]]!! // add the count of the first element to k\\n            }\\n            res += i // add the index of the first element to the result\\n            j++\\n        }\\n        return res\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun countGood(A: IntArray, k: Int): Long {\\n        var res = 0L\\n        val count = HashMap<Int, Int>() // Hashmap to store the count of each element in the array\\n        var i = 0\\n        var j = 0\\n        var k = k\\n        while (j < A.size) {\\n            k -= count.getOrDefault(A[j], 0) // subtract the count of current element from k\\n            count[A[j]] = count.getOrDefault(A[j], 0) + 1 // increment the count of current element in the hashmap\\n            while (k <= 0) {\\n                count[A[i]] = count[A[i]]!! - 1 // decrement the count of the first element in the window\\n                k += count[A[i++]]!! // add the count of the first element to k\\n            }\\n            res += i // add the index of the first element to the result\\n            j++\\n        }\\n        return res\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3107063,
                "title": "premium-explained-solution-2-41",
                "content": "Here\\'s a breakdown of the Kotlin code for counting the number of good subarrays in an integer array:\\n\\nInitialize variables count, goodSubarrays, and pairCounter to 0, 0, and an empty mutable map, respectively. count will keep track of the number of pairs of indices (i, j) such that i < j and arr[i] == arr[j] for the current subarray being considered. goodSubarrays will keep track of the number of good subarrays found so far. pairCounter will keep track of the number of occurrences of each element in the current subarray.\\nIterate through the indices of the nums array. For each index i, the following steps are performed:\\nIf the current element (nums[i]) is already in the pairCounter map, decrease count by the number of occurrences of that element in the pairCounter map.\\nIf the current element minus 1 is in the pairCounter map, increase count by the number of occurrences of that element minus 1 in the pairCounter map.\\nAdd the current element to the pairCounter map or increase its value by 1 if it already exists in the map.\\nCheck if count is equal to k. If it is, increment goodSubarrays by 1.\\nIterate through the rest of the indices j of the nums array starting from i + 1. If nums[i] is equal to nums[j], increment goodSubarrays by 1.\\nReturn goodSubarrays as the final output.\\nIt should be noted that the above solution is not the optimal one. It has a time complexity of O(n^2) and it would be much more efficient to find a O(n) solution.\\n\\n# Code\\n```\\nfun numOfGoodSubArrays(nums: IntArray, k: Int): Int {\\n    // Initialize variables to keep track of the number of good subarrays and pairs of indices\\n    var count = 0\\n    var goodSubarrays = 0\\n    val pairCounter = mutableMapOf<Int, Int>()\\n\\n    for (i in nums.indices) {\\n        // Decrement count by the number of occurrences of nums[i] in the pairCounter map\\n        if (pairCounter.containsKey(nums[i])) {\\n            count -= pairCounter[nums[i]]!!\\n        }\\n        // Increment count by the number of occurrences of nums[i]-1 in the pairCounter map\\n        if (pairCounter.containsKey(nums[i] - 1)) {\\n            count += pairCounter[nums[i] - 1]!!\\n        }\\n        // Add or increment the value of nums[i] in the pairCounter map\\n        pairCounter[nums[i]] = pairCounter.getOrDefault(nums[i], 0) + 1\\n\\n        // Check if the current subarray is a good subarray (count == k)\\n        if (count == k) {\\n            goodSubarrays++\\n        }\\n\\n        // Iterate through the rest of the indices and check for good subarrays\\n        for (j in i + 1 until nums.size) {\\n            if (nums[i] == nums[j]) {\\n                goodSubarrays++\\n            }\\n        }\\n    }\\n\\n    return goodSubarrays\\n}\\n\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nfun numOfGoodSubArrays(nums: IntArray, k: Int): Int {\\n    // Initialize variables to keep track of the number of good subarrays and pairs of indices\\n    var count = 0\\n    var goodSubarrays = 0\\n    val pairCounter = mutableMapOf<Int, Int>()\\n\\n    for (i in nums.indices) {\\n        // Decrement count by the number of occurrences of nums[i] in the pairCounter map\\n        if (pairCounter.containsKey(nums[i])) {\\n            count -= pairCounter[nums[i]]!!\\n        }\\n        // Increment count by the number of occurrences of nums[i]-1 in the pairCounter map\\n        if (pairCounter.containsKey(nums[i] - 1)) {\\n            count += pairCounter[nums[i] - 1]!!\\n        }\\n        // Add or increment the value of nums[i] in the pairCounter map\\n        pairCounter[nums[i]] = pairCounter.getOrDefault(nums[i], 0) + 1\\n\\n        // Check if the current subarray is a good subarray (count == k)\\n        if (count == k) {\\n            goodSubarrays++\\n        }\\n\\n        // Iterate through the rest of the indices and check for good subarrays\\n        for (j in i + 1 until nums.size) {\\n            if (nums[i] == nums[j]) {\\n                goodSubarrays++\\n            }\\n        }\\n    }\\n\\n    return goodSubarrays\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3102408,
                "title": "simple-java-solution-with-explanation-sliding-window",
                "content": "```\\nclass Solution {\\n    public long countGood(int[] nums, int k) {\\n        long answer = 0;\\n        int countPrev = 0, countCurr = 0, left = 0; \\n        Map<Integer, Integer> countMap = new HashMap<>();\\n        \\n        for (int right = 0; right < nums.length; right++) {\\n            countCurr = countPrev + countMap.getOrDefault(nums[right], 0);\\n            countMap.put(nums[right], countMap.getOrDefault(nums[right], 0) + 1);\\n            // once we reach cumulative pair count == k\\n            // we know that all sub-arrays [left ... right] -> [left ... nums.length] will be part of answer\\n            // we can then increment left until the cumulative pair count drops below \\'k\\'\\n            while (countCurr >= k) {\\n                answer += (nums.length - right);\\n                countMap.put(nums[left], countMap.get(nums[left]) - 1);\\n                countCurr -= countMap.get(nums[left]); \\n                left++;\\n            }\\n            countPrev = countCurr;\\n        }\\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long countGood(int[] nums, int k) {\\n        long answer = 0;\\n        int countPrev = 0, countCurr = 0, left = 0; \\n        Map<Integer, Integer> countMap = new HashMap<>();\\n        \\n        for (int right = 0; right < nums.length; right++) {\\n            countCurr = countPrev + countMap.getOrDefault(nums[right], 0);\\n            countMap.put(nums[right], countMap.getOrDefault(nums[right], 0) + 1);\\n            // once we reach cumulative pair count == k\\n            // we know that all sub-arrays [left ... right] -> [left ... nums.length] will be part of answer\\n            // we can then increment left until the cumulative pair count drops below \\'k\\'\\n            while (countCurr >= k) {\\n                answer += (nums.length - right);\\n                countMap.put(nums[left], countMap.get(nums[left]) - 1);\\n                countCurr -= countMap.get(nums[left]); \\n                left++;\\n            }\\n            countPrev = countCurr;\\n        }\\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3090925,
                "title": "c-solution-sliding-window-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSliding window.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCreate a sliding window, update the window on go. If we get a new pair where pairs >= k we add to count the rest of combinations we could make = len(nums)-i.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n), n = number of distinct numbers from nums\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& nums, int k) {\\n        /*\\n        sliding window - when we get a new pair where pairs >= k we add to count the number of pairs we can make in the future from that point inclusive -> count += len(nums)-i and increment j updating the window.\\n        [1,1,1,1,1]\\n        1 1 -> 1 pair\\n        1 1 1 -> 3 pairs\\n        1 1 1 1 -> 6 pairs\\n        1 1 1 1 1 -> 10 pairs => (n-1)(n-1-1)/2 | n = len(nums)\\n        */\\n        int j = 0;\\n        long long pairs = 0;\\n        long long count = 0;\\n        unordered_map <int, int> mp;\\n        for(int i=0;i<nums.size();++i){\\n            if(pairs < k){\\n                mp[nums[i]] += 1;\\n                int prev = mp[nums[i]]-1;\\n                pairs -= (prev*(prev-1))/2; // delete de previous number of pairs\\n                pairs += (mp[nums[i]]*(mp[nums[i]]-1))/2; // add the current number of pairs\\n            }\\n            while(pairs >= k){\\n                count += nums.size()-i; // it\\'s inclusive\\n                mp[nums[j]] -= 1;\\n                int prev = mp[nums[j]]+1;\\n                pairs -= (prev*(prev-1))/2; // delete the previous number of pairs\\n                pairs += (mp[nums[j]]*(mp[nums[j]]-1))/2; // add the current number of pairs\\n                j += 1;\\n            \\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\\nIf you like it, please upvote!^^",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& nums, int k) {\\n        /*\\n        sliding window - when we get a new pair where pairs >= k we add to count the number of pairs we can make in the future from that point inclusive -> count += len(nums)-i and increment j updating the window.\\n        [1,1,1,1,1]\\n        1 1 -> 1 pair\\n        1 1 1 -> 3 pairs\\n        1 1 1 1 -> 6 pairs\\n        1 1 1 1 1 -> 10 pairs => (n-1)(n-1-1)/2 | n = len(nums)\\n        */\\n        int j = 0;\\n        long long pairs = 0;\\n        long long count = 0;\\n        unordered_map <int, int> mp;\\n        for(int i=0;i<nums.size();++i){\\n            if(pairs < k){\\n                mp[nums[i]] += 1;\\n                int prev = mp[nums[i]]-1;\\n                pairs -= (prev*(prev-1))/2; // delete de previous number of pairs\\n                pairs += (mp[nums[i]]*(mp[nums[i]]-1))/2; // add the current number of pairs\\n            }\\n            while(pairs >= k){\\n                count += nums.size()-i; // it\\'s inclusive\\n                mp[nums[j]] -= 1;\\n                int prev = mp[nums[j]]+1;\\n                pairs -= (prev*(prev-1))/2; // delete the previous number of pairs\\n                pairs += (mp[nums[j]]*(mp[nums[j]]-1))/2; // add the current number of pairs\\n                j += 1;\\n            \\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3085348,
                "title": "sliding-window-two-pointer-98-fast-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe increase our window size till we get total number of pair to be equal or greater than k.\\nif we increase our window size from that point towards the right then obviously we will still have total number of pairs in our window to be greater than k.\\nso we add len-j+1 to our answer. \\n\\nwe do this while reducing our window size from the left ,checking if our total is still >=k , if its . then our condition still holds and we can add window size from that point onward.\\nthen we reduce\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n) for the map\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& arr, int k) {\\n        int i=0;\\n        int j=0;\\n        long long ans=0;\\n        unordered_map<int,int>mp;\\n        long long total=0;\\n        int len=arr.size();\\n     while(i<len && j< len){\\n        while(j<len && total<k){\\n            total+= mp[arr[j]]++;\\n        j++;\\n        }\\n         \\n    while(i<len && i<j && total>=k){\\n        ans+=len-j+1;\\n        total-=--mp[arr[i]];\\n        i++;\\n    }\\n    }   \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& arr, int k) {\\n        int i=0;\\n        int j=0;\\n        long long ans=0;\\n        unordered_map<int,int>mp;\\n        long long total=0;\\n        int len=arr.size();\\n     while(i<len && j< len){\\n        while(j<len && total<k){\\n            total+= mp[arr[j]]++;\\n        j++;\\n        }\\n         \\n    while(i<len && i<j && total>=k){\\n        ans+=len-j+1;\\n        total-=--mp[arr[i]];\\n        i++;\\n    }\\n    }   \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3080671,
                "title": "sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& nums, int k) {\\n        unordered_map<int,int> mp;\\n        long long count=0;int pairs=0;\\n        int i=0,j=0,n=nums.size();\\n        while(j<n){\\n            if(mp.find(nums[j])!=mp.end()){\\n                pairs+=mp[nums[j]];\\n            }\\n            mp[nums[j]]++;\\n            if(pairs>=k){\\n                count+=(n-j);\\n                while(i<j && pairs>=k){\\n                    pairs-=mp[nums[i]]-1;\\n                    mp[nums[i]]--;\\n                    if(mp[nums[i]]==0) mp.erase(nums[i]);\\n                    if(pairs>=k){\\n                        count+=(n-j);\\n                    }\\n                    i++;\\n                }\\n            }\\n            j++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& nums, int k) {\\n        unordered_map<int,int> mp;\\n        long long count=0;int pairs=0;\\n        int i=0,j=0,n=nums.size();\\n        while(j<n){\\n            if(mp.find(nums[j])!=mp.end()){\\n                pairs+=mp[nums[j]];\\n            }\\n            mp[nums[j]]++;\\n            if(pairs>=k){\\n                count+=(n-j);\\n                while(i<j && pairs>=k){\\n                    pairs-=mp[nums[i]]-1;\\n                    mp[nums[i]]--;\\n                    if(mp[nums[i]]==0) mp.erase(nums[i]);\\n                    if(pairs>=k){\\n                        count+=(n-j);\\n                    }\\n                    i++;\\n                }\\n            }\\n            j++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3080645,
                "title": "sliding-window-solution-with-o-n-python",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def countGood(self, nums: List[int], k: int) -> int:\\n        \\n        left = 0\\n        right = 0\\n        d = defaultdict(int)\\n        pair = 0\\n        cnt = 0\\n        n = len(nums)\\n        while right<n:\\n\\n            char = nums[right]\\n            # print(char)\\n            if char in d:\\n                pair += d[char]\\n            # print(left,right,pair)\\n            d[nums[right]] += 1\\n\\n            while left<=right and pair >= k:\\n                print(left,right)\\n                d[nums[left]] -= 1\\n                cnt += (n-right)\\n                pair -= d[nums[left]]\\n                left += 1\\n            right += 1\\n            \\n            # print(left,right,pair)\\n        while left<n and pair >=k:\\n            cnt += (n-right)\\n            d[nums[left]] -= 1\\n            pair -= d[nums[left]]\\n            left += 1\\n\\n            \\n        return cnt\\n            \\n                \\n\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def countGood(self, nums: List[int], k: int) -> int:\\n        \\n        left = 0\\n        right = 0\\n        d = defaultdict(int)\\n        pair = 0\\n        cnt = 0\\n        n = len(nums)\\n        while right<n:\\n\\n            char = nums[right]\\n            # print(char)\\n            if char in d:\\n                pair += d[char]\\n            # print(left,right,pair)\\n            d[nums[right]] += 1\\n\\n            while left<=right and pair >= k:\\n                print(left,right)\\n                d[nums[left]] -= 1\\n                cnt += (n-right)\\n                pair -= d[nums[left]]\\n                left += 1\\n            right += 1\\n            \\n            # print(left,right,pair)\\n        while left<n and pair >=k:\\n            cnt += (n-right)\\n            d[nums[left]] -= 1\\n            pair -= d[nums[left]]\\n            left += 1\\n\\n            \\n        return cnt\\n            \\n                \\n\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3079999,
                "title": "clean-c-sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& nums, int k) {\\n        \\n        long long start = 0;\\n        unordered_map<long long, long long>count;\\n        long long res = 0;\\n        \\n        for (long long end = 0; end < nums.size(); end ++) {            \\n                count[nums[end]]++;\\n            \\n                if (count[nums[end]] > 1) {\\n                    int pairs = count[nums[end]] - 1;\\n                    k -= pairs;\\n                }\\n                \\n                while (k <= 0 && end > start) {\\n                    if (count[nums[start]] > 1) {\\n                        int pairs = count[nums[start]] - 1;\\n                        k += pairs;\\n                    }\\n                    count[nums[start]] --;\\n                    res += nums.size() - end;\\n                    start++;\\n                }\\n        }\\n        \\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& nums, int k) {\\n        \\n        long long start = 0;\\n        unordered_map<long long, long long>count;\\n        long long res = 0;\\n        \\n        for (long long end = 0; end < nums.size(); end ++) {            \\n                count[nums[end]]++;\\n            \\n                if (count[nums[end]] > 1) {\\n                    int pairs = count[nums[end]] - 1;\\n                    k -= pairs;\\n                }\\n                \\n                while (k <= 0 && end > start) {\\n                    if (count[nums[start]] > 1) {\\n                        int pairs = count[nums[start]] - 1;\\n                        k += pairs;\\n                    }\\n                    count[nums[start]] --;\\n                    res += nums.size() - end;\\n                    start++;\\n                }\\n        }\\n        \\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3077554,
                "title": "c-clean-code-with-comments-sliding-window-hashing-tored-the-intuition",
                "content": "### DISCLAIMER:\\nThe ques is bit tricky, the thing is there are a lot of stuffs u must assume.\\nHere we iterate all start indx, by finding the 1st end idx which satisfy the cond.\\n- so only we do ans = ans + (N-j); // we include all guys\\n\\n#### ASSUMPTIONS:\\n- When j is found\\n- j+1 .... N all will ofc satisfy\\n- Bcoz the thing is adding more ele will never DIS SATISFY\\n- When i is sol, we next try for i+1\\n- So at this time, no j-1 or j-2 can be a solution\\n- HOW?\\n- The thing is when j-1 cannot be a sol for i itself, for i+1 (shrinked window) it can never be na.\\n- so for i+1th start idx of window either j or j+1....N can only be ans.\\n- So this way we stop running loop for every i, j loop from i+1 to N.\\n- Once a j is fixed, we use it for next next. we dont reset its val. (so only declared outside of the for loop)\\n\\n# Complexity\\n- Time complexity: O(N)\\n- As at max we do 1 iteration of whole array\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n- Map may take all N ints as distinct\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    long long countGood(vector<int>& nums, int k) {\\n        int N = nums.size();\\n        long long ans = 0;\\n        unordered_map<int,int> mpp;\\n        int j=0; // end idx of window\\n        int pairs = 0;\\n\\n        //i controls the start index of window\\n        for(int i=0; i<N; i++){\\n            while(pairs<k && j<N){\\n                pairs += mpp[nums[j]]; // FRQ-1 pairs we add up\\n                mpp[nums[j]]++; //so did before including it\\n                j++;   //first end idx search\\n            }\\n            //2 reason for end of loop\\n            if(pairs >= k){\\n                ans = ans + (N-j+1); // N - (j-1)\\n                //Why J-1 Means When Pairs are k and more before it we do j++\\n                //see if j is ans j+1, j+2 .... N will satisfy ofc\\n                //N-j sub arrays poss with same i as start idx\\n            }\\n            //as i is going to go out of sliding win\\n            //so nullify its effect by red pairs\\n            mpp[nums[i]]--;  // N-1 Pair takeout. so reduce and subtract\\n            pairs -= mpp[nums[i]]; // 5 5 5 5 = 1+2+3=6 pairs => 1+2 = 3 pairs  \\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    long long countGood(vector<int>& nums, int k) {\\n        int N = nums.size();\\n        long long ans = 0;\\n        unordered_map<int,int> mpp;\\n        int j=0; // end idx of window\\n        int pairs = 0;\\n\\n        //i controls the start index of window\\n        for(int i=0; i<N; i++){\\n            while(pairs<k && j<N){\\n                pairs += mpp[nums[j]]; // FRQ-1 pairs we add up\\n                mpp[nums[j]]++; //so did before including it\\n                j++;   //first end idx search\\n            }\\n            //2 reason for end of loop\\n            if(pairs >= k){\\n                ans = ans + (N-j+1); // N - (j-1)\\n                //Why J-1 Means When Pairs are k and more before it we do j++\\n                //see if j is ans j+1, j+2 .... N will satisfy ofc\\n                //N-j sub arrays poss with same i as start idx\\n            }\\n            //as i is going to go out of sliding win\\n            //so nullify its effect by red pairs\\n            mpp[nums[i]]--;  // N-1 Pair takeout. so reduce and subtract\\n            pairs -= mpp[nums[i]]; // 5 5 5 5 = 1+2+3=6 pairs => 1+2 = 3 pairs  \\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3077170,
                "title": "window-sliding-and-hashing-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& nums, int k) {\\n        int ct=0;\\n        map<int,int> m;\\n        int n=nums.size();\\n        long long ans=0;\\n        int i=0,j=0;\\n        while(j<n){\\n            m[nums[j]]++;\\n            if(m[nums[j]]>1) ct+=(m[nums[j]]-1);\\n            if(ct>=k){\\n                while(ct>=k && i<=j){\\n                    if(m[nums[i]]>1) ct-=(m[nums[i]]-1);\\n                    ans+=(n-j);\\n                    m[nums[i]]--;\\n                    if(m[nums[i]]==0) m.erase(m[nums[i]]);\\n                    i++;\\n                }\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& nums, int k) {\\n        int ct=0;\\n        map<int,int> m;\\n        int n=nums.size();\\n        long long ans=0;\\n        int i=0,j=0;\\n        while(j<n){\\n            m[nums[j]]++;\\n            if(m[nums[j]]>1) ct+=(m[nums[j]]-1);\\n            if(ct>=k){\\n                while(ct>=k && i<=j){\\n                    if(m[nums[i]]>1) ct-=(m[nums[i]]-1);\\n                    ans+=(n-j);\\n                    m[nums[i]]--;\\n                    if(m[nums[i]]==0) m.erase(m[nums[i]]);\\n                    i++;\\n                }\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3076011,
                "title": "clean-code-with-comments-t-m-beats-97-91",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        int i = 0, j = 0;\\n\\n        unordered_map<int, int> count;  // count of nums[j] in nums[i..j]\\n        \\n        // f or f(i, j): the number of equal pairs in nums[i..j]\\n        // f(i, j) = f(i, j-1) + count of nums[j] in nums[i..j-1]\\n        // f(i, j) = f(i+1, j) + count of nums[i] in nums[i+1..j]\\n        long long f = 0;\\n        \\n        long long result = 0;\\n        \\n        for (; j < n; j++) {\\n            f += count[nums[j]]++;\\n            while (f >= k) {\\n                f -= --count[nums[i]];\\n                i++;\\n            } \\n            result += i;  //  f(s, j) >= k, 0 <= s < i\\n        } // result: total number of good subarrays of nums[0...j]\\n\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        int i = 0, j = 0;\\n\\n        unordered_map<int, int> count;  // count of nums[j] in nums[i..j]\\n        \\n        // f or f(i, j): the number of equal pairs in nums[i..j]\\n        // f(i, j) = f(i, j-1) + count of nums[j] in nums[i..j-1]\\n        // f(i, j) = f(i+1, j) + count of nums[i] in nums[i+1..j]\\n        long long f = 0;\\n        \\n        long long result = 0;\\n        \\n        for (; j < n; j++) {\\n            f += count[nums[j]]++;\\n            while (f >= k) {\\n                f -= --count[nums[i]];\\n                i++;\\n            } \\n            result += i;  //  f(s, j) >= k, 0 <= s < i\\n        } // result: total number of good subarrays of nums[0...j]\\n\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3075403,
                "title": "easy-c-solution-using-sliding-window-nc2",
                "content": "# Complexity\\n- Time complexity:\\n0(N)\\n\\n- Space complexity:\\n0(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& nums, int k) {//{* * * * *}\\n        unordered_map<int,int> mp;\\n        long long soln = 0;\\n        long long duplicate = 0;\\n        int st = 0;\\n        long long freq;\\n        for(int ed=0;ed<nums.size();ed++){//1,1,2,2,1\\n            if(duplicate>=k){\\n                //soln += (nums.size()-ed);//1,1,1,1--2\\n                while(st<=ed && duplicate>=k){\\n                    soln += (nums.size()-ed+1);\\n                    freq = mp[nums[st]];\\n                    duplicate -= (freq*(freq-1))/2;\\n                    freq = --mp[nums[st]];\\n                    duplicate += (freq*(freq-1))/2;\\n                    st++;\\n                }\\n                freq = mp[nums[ed]];\\n                duplicate -= (freq*(freq-1)/2);\\n                freq = ++mp[nums[ed]];\\n                duplicate += (freq*(freq-1)/2);\\n            }else{\\n                freq = mp[nums[ed]];\\n                duplicate -= (freq*(freq-1)/2);\\n                freq = ++mp[nums[ed]];\\n                duplicate += (freq*(freq-1))/2; \\n            }\\n        }\\n       // cout<<soln<<\"//\";\\n        while(st<=nums.size()-1 && duplicate>=k){\\n            soln += 1;\\n            freq = mp[nums[st]];\\n            duplicate -= (freq*(freq-1))/2;\\n            freq = --mp[nums[st]];\\n            duplicate += (freq*(freq-1))/2;\\n            st++;\\n        }\\n        return soln;\\n    }//4 + 3 + 2 + 1 \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& nums, int k) {//{* * * * *}\\n        unordered_map<int,int> mp;\\n        long long soln = 0;\\n        long long duplicate = 0;\\n        int st = 0;\\n        long long freq;\\n        for(int ed=0;ed<nums.size();ed++){//1,1,2,2,1\\n            if(duplicate>=k){\\n                //soln += (nums.size()-ed);//1,1,1,1--2\\n                while(st<=ed && duplicate>=k){\\n                    soln += (nums.size()-ed+1);\\n                    freq = mp[nums[st]];\\n                    duplicate -= (freq*(freq-1))/2;\\n                    freq = --mp[nums[st]];\\n                    duplicate += (freq*(freq-1))/2;\\n                    st++;\\n                }\\n                freq = mp[nums[ed]];\\n                duplicate -= (freq*(freq-1)/2);\\n                freq = ++mp[nums[ed]];\\n                duplicate += (freq*(freq-1)/2);\\n            }else{\\n                freq = mp[nums[ed]];\\n                duplicate -= (freq*(freq-1)/2);\\n                freq = ++mp[nums[ed]];\\n                duplicate += (freq*(freq-1))/2; \\n            }\\n        }\\n       // cout<<soln<<\"//\";\\n        while(st<=nums.size()-1 && duplicate>=k){\\n            soln += 1;\\n            freq = mp[nums[st]];\\n            duplicate -= (freq*(freq-1))/2;\\n            freq = --mp[nums[st]];\\n            duplicate += (freq*(freq-1))/2;\\n            st++;\\n        }\\n        return soln;\\n    }//4 + 3 + 2 + 1 \\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3074654,
                "title": "java-sliding-window-hashmap-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public long countGood(int[] nums, int k) {\\n        HashMap<Integer,Integer> count = new HashMap<>();\\n        int i = 0;\\n        int j = 0;\\n        int n = nums.length;\\n        long res = 0;\\n        int pairs = 0;\\n        while(j < n){\\n            if(!count.containsKey(nums[j])){\\n                count.put(nums[j],1);\\n                j++;\\n            }else{\\n            int rightNum = count.get(nums[j]);\\n                pairs += rightNum;\\n                count.put(nums[j],rightNum + 1);\\n                while(pairs >= k){\\n                    res += n - j;\\n                    //narrow the window\\n                    //1111 1234\\n                    count.put(nums[i],count.get(nums[i]) - 1);\\n                    int leftNum = count.get(nums[i]);\\n                    pairs -= leftNum;\\n                    i++;\\n                    \\n                }\\n                j++;\\n            \\n            }\\n        }\\n        \\n        return res;\\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long countGood(int[] nums, int k) {\\n        HashMap<Integer,Integer> count = new HashMap<>();\\n        int i = 0;\\n        int j = 0;\\n        int n = nums.length;\\n        long res = 0;\\n        int pairs = 0;\\n        while(j < n){\\n            if(!count.containsKey(nums[j])){\\n                count.put(nums[j],1);\\n                j++;\\n            }else{\\n            int rightNum = count.get(nums[j]);\\n                pairs += rightNum;\\n                count.put(nums[j],rightNum + 1);\\n                while(pairs >= k){\\n                    res += n - j;\\n                    //narrow the window\\n                    //1111 1234\\n                    count.put(nums[i],count.get(nums[i]) - 1);\\n                    int leftNum = count.get(nums[i]);\\n                    pairs -= leftNum;\\n                    i++;\\n                    \\n                }\\n                j++;\\n            \\n            }\\n        }\\n        \\n        return res;\\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3066710,
                "title": "c-sliding-window",
                "content": "# Intuition\\nUse sliding window to keep track of number of equal number pairs.\\n\\n# Approach\\nAs mentioned in the hint:\\n- When a number is added to a subarray, it increases the number of pairs by its previous appearances.\\n- When a number is removed from the subarray, it decreases the number of pairs by its remaining appearances.\\n\\nUse a map to maintain the count of appearances of a number.\\n\\n# Complexity\\n- Time complexity:\\nO(NlogN)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& nums, int k) {\\n        std::unordered_map<int,int> num_to_count;\\n        int i=0, j=0;\\n        long long result = 0, num_pairs = 0;\\n        while(true) {\\n            if (num_to_count.empty() || (num_pairs < k)) {\\n                if (j == nums.size()) {\\n                    break;\\n                }\\n                num_pairs += num_to_count[nums[j]]++;\\n                j++;\\n            } else {\\n                result += nums.size()-j+1;\\n                num_pairs -= --num_to_count[nums[i]];\\n                i++;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& nums, int k) {\\n        std::unordered_map<int,int> num_to_count;\\n        int i=0, j=0;\\n        long long result = 0, num_pairs = 0;\\n        while(true) {\\n            if (num_to_count.empty() || (num_pairs < k)) {\\n                if (j == nums.size()) {\\n                    break;\\n                }\\n                num_pairs += num_to_count[nums[j]]++;\\n                j++;\\n            } else {\\n                result += nums.size()-j+1;\\n                num_pairs -= --num_to_count[nums[i]];\\n                i++;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3066550,
                "title": "c-eays-fast",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& nums, int k) {\\n        long long res = 0;\\n        int n = nums.size();\\n        int srt = 0;\\n        map <int, int> hash;\\n        int cur = 0;\\n        for (int i = 0; i < n; i++) {\\n\\n            cur += hash[nums[i]];\\n            hash [nums[i]] ++;\\n            while (cur >= k) {\\n                res += (n - i);\\n               \\n                cur -= hash[nums[srt]] - 1;\\n                hash[nums[srt]] --;            \\n                srt ++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& nums, int k) {\\n        long long res = 0;\\n        int n = nums.size();\\n        int srt = 0;\\n        map <int, int> hash;\\n        int cur = 0;\\n        for (int i = 0; i < n; i++) {\\n\\n            cur += hash[nums[i]];\\n            hash [nums[i]] ++;\\n            while (cur >= k) {\\n                res += (n - i);\\n               \\n                cur -= hash[nums[srt]] - 1;\\n                hash[nums[srt]] --;            \\n                srt ++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3065095,
                "title": "easy-solution-sliding-window-c",
                "content": "# Approach\\nSliding Window\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& nums, int k) {\\n        int left = 0,right=0,n=nums.size(),pairs = 0,x=0;\\n        map<int,int> count;\\n        long long int ans = 0;\\n        while(right<n&&left<=right)\\n        {\\n            count[nums[right]]++;\\n            x = (count[nums[right]]);\\n            //cout<<pairs;\\n            pairs+=((x>1)?(x*(x-1))/2:0)-((x>2)?((x-1)*(x-2))/2:0);\\n            //cout<<pairs<<left<<\" \"<<right<<endl;\\n            while(pairs>=k)\\n            {\\n                ans+=n-right;\\n                count[nums[left]]--;\\n                x = (count[nums[left]]);\\n                left++;\\n                //cout<<x;\\n                pairs+=((x>1)?(x*(x-1))/2:0)-((x>0)?((x+1)*(x))/2:0);\\n            } \\n            right++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& nums, int k) {\\n        int left = 0,right=0,n=nums.size(),pairs = 0,x=0;\\n        map<int,int> count;\\n        long long int ans = 0;\\n        while(right<n&&left<=right)\\n        {\\n            count[nums[right]]++;\\n            x = (count[nums[right]]);\\n            //cout<<pairs;\\n            pairs+=((x>1)?(x*(x-1))/2:0)-((x>2)?((x-1)*(x-2))/2:0);\\n            //cout<<pairs<<left<<\" \"<<right<<endl;\\n            while(pairs>=k)\\n            {\\n                ans+=n-right;\\n                count[nums[left]]--;\\n                x = (count[nums[left]]);\\n                left++;\\n                //cout<<x;\\n                pairs+=((x>1)?(x*(x-1))/2:0)-((x>0)?((x+1)*(x))/2:0);\\n            } \\n            right++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3063906,
                "title": "java-sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public long countGood(int[] nums, int k) {\\n    long ans = 0, all = 0;\\n    int i = 0, j = 0;\\n\\n    HashMap<Integer, Integer> t = new HashMap<>();\\n    while(j != nums.length){\\n      for(; j != nums.length && all < k; j++){\\n        Integer val = t.get(nums[j]);\\n        val = val == null ? 1 : val + 1;\\n        all += val - 1;\\n        t.put(nums[j], val);\\n      }\\n\\n      if(all < k) break;\\n      int def = nums.length - j + 1;\\n      for(; all >= k; i++){\\n        ans += def;\\n        Integer val = t.get(nums[i]);\\n        all -= --val;\\n        t.put(nums[i], val);\\n      }\\n    }\\n\\n    return ans;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public long countGood(int[] nums, int k) {\\n    long ans = 0, all = 0;\\n    int i = 0, j = 0;\\n\\n    HashMap<Integer, Integer> t = new HashMap<>();\\n    while(j != nums.length){\\n      for(; j != nums.length && all < k; j++){\\n        Integer val = t.get(nums[j]);\\n        val = val == null ? 1 : val + 1;\\n        all += val - 1;\\n        t.put(nums[j], val);\\n      }\\n\\n      if(all < k) break;\\n      int def = nums.length - j + 1;\\n      for(; all >= k; i++){\\n        ans += def;\\n        Integer val = t.get(nums[i]);\\n        all -= --val;\\n        t.put(nums[i], val);\\n      }\\n    }\\n\\n    return ans;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3063654,
                "title": "using-unordered-map-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& nums, int k) {\\n        using ll=long long;\\n        int n=nums.size();\\n        int j=0;\\n        ll pair=0,ans=0;\\n        unordered_map<ll,ll>m;\\n        for(int i =0;i<n;i++)\\n        {\\n            m[nums[i]]++;\\n            pair+=m[nums[i]]-1;\\n            if(pair>=k)\\n            {\\n                while(j<=i and pair>=k)\\n                {\\n                    ans+=(n-i);\\n                    m[nums[j]]--;\\n                    pair-=m[nums[j]];\\n                    if(m[nums[j]]==0)\\n                    m.erase(nums[j]);\\n                    j++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& nums, int k) {\\n        using ll=long long;\\n        int n=nums.size();\\n        int j=0;\\n        ll pair=0,ans=0;\\n        unordered_map<ll,ll>m;\\n        for(int i =0;i<n;i++)\\n        {\\n            m[nums[i]]++;\\n            pair+=m[nums[i]]-1;\\n            if(pair>=k)\\n            {\\n                while(j<=i and pair>=k)\\n                {\\n                    ans+=(n-i);\\n                    m[nums[j]]--;\\n                    pair-=m[nums[j]];\\n                    if(m[nums[j]]==0)\\n                    m.erase(nums[j]);\\n                    j++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3063627,
                "title": "sliding-window-clean-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\ncountGood = total subarray - count bad\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long countGood(int[] nums, int k) {\\n        int n = nums.length;\\n        long ans = 0;\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        int count = 0;\\n        for (int i = 0, j = 0; j < n; j++) {\\n            ans += j + 1;\\n            count += map.getOrDefault(nums[j], 0);\\n            map.put(nums[j], map.getOrDefault(nums[j], 0) + 1);\\n            while (count >= k) {\\n                map.put(nums[i], map.get(nums[i]) - 1);\\n                count -= map.get(nums[i]);\\n                i++;\\n            }\\n            ans -= (long) (j - i + 1);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long countGood(int[] nums, int k) {\\n        int n = nums.length;\\n        long ans = 0;\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        int count = 0;\\n        for (int i = 0, j = 0; j < n; j++) {\\n            ans += j + 1;\\n            count += map.getOrDefault(nums[j], 0);\\n            map.put(nums[j], map.getOrDefault(nums[j], 0) + 1);\\n            while (count >= k) {\\n                map.put(nums[i], map.get(nums[i]) - 1);\\n                count -= map.get(nums[i]);\\n                i++;\\n            }\\n            ans -= (long) (j - i + 1);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3063624,
                "title": "easy-to-understand-with-detailed-explanation-c",
                "content": "# Intuition\\nWhen I first saw the question, Sliding Window came into my mind but I was bit confused that how I would implement the approach I had in my mind.\\n\\nI just start writing code and got next steps automatically one after the other.After completing my code, I executed my code and the pretests got passed in the first go then I submitted my code and suprisingly it also got accepted in the first go.\\n\\nBelow is the approach that I have used to solve the problem. \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nAs we have to count the number of unique subarrays therefore the concept of sliding window might be required to tackle the problem which also worked very well in this particular problem.\\n\\nI carried a map with me which will store how many times a number come in our current window and how much it is contributing to our score.\\nWhen I am expanding the window from right side I am deducting the previous score contributed by that number and adding its new contribution to our score.At the same time I am also upadting my map.\\n\\nIf score becomes greater than equal to \\'k\\' than I am updating my answer and also shrinking the window from left side and doing the similar process that I was doing while expanding the window.\\n\\nBelow is the code for the above approach. If you have any doubts post them in the comments section I will answer each every doubt.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& nums, int k) {\\n        \\n        int n=nums.size();\\n        unordered_map<long long,pair<long long,long long>> mp;\\n        long long score=0;\\n        long long ans=0;\\n        int prev=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            mp[nums[i]].first++;\\n            score-=mp[nums[i]].second;\\n            long long x=mp[nums[i]].first;\\n            long long add=((x-1)*x)/2;\\n            score+=add;\\n            mp[nums[i]].second=add;\\n            if(score>=k)\\n            {\\n                ans+=n-i;\\n                for(int j=prev;j<n;j++)\\n                {\\n                    mp[nums[j]].first--;\\n                    score-=mp[nums[j]].second;\\n                    x=mp[nums[j]].first;\\n                    add=((x-1)*x)/2;\\n                    score+=add;\\n                    mp[nums[j]].second=add;\\n                    prev++;\\n                    if(score>=k)\\n                        ans+=n-i;\\n                    else\\n                        break;                    \\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& nums, int k) {\\n        \\n        int n=nums.size();\\n        unordered_map<long long,pair<long long,long long>> mp;\\n        long long score=0;\\n        long long ans=0;\\n        int prev=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            mp[nums[i]].first++;\\n            score-=mp[nums[i]].second;\\n            long long x=mp[nums[i]].first;\\n            long long add=((x-1)*x)/2;\\n            score+=add;\\n            mp[nums[i]].second=add;\\n            if(score>=k)\\n            {\\n                ans+=n-i;\\n                for(int j=prev;j<n;j++)\\n                {\\n                    mp[nums[j]].first--;\\n                    score-=mp[nums[j]].second;\\n                    x=mp[nums[j]].first;\\n                    add=((x-1)*x)/2;\\n                    score+=add;\\n                    mp[nums[j]].second=add;\\n                    prev++;\\n                    if(score>=k)\\n                        ans+=n-i;\\n                    else\\n                        break;                    \\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3061863,
                "title": "java-o-n-sliding-window-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public long countGood(int[] nums, int k) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int l = 0, curP = 0;\\n        long res = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            map.put(nums[i], map.getOrDefault(nums[i], 0) + 1);\\n            curP += map.get(nums[i]) - 1;\\n            while (l < i && curP - map.get(nums[l]) + 1 >= k) {\\n                curP -= map.get(nums[l]) - 1;\\n                map.put(nums[l], map.getOrDefault(nums[l], 0) - 1);\\n                l++;        \\n            }\\n            if (curP >= k) res += l + 1;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public long countGood(int[] nums, int k) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int l = 0, curP = 0;\\n        long res = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            map.put(nums[i], map.getOrDefault(nums[i], 0) + 1);\\n            curP += map.get(nums[i]) - 1;\\n            while (l < i && curP - map.get(nums[l]) + 1 >= k) {\\n                curP -= map.get(nums[l]) - 1;\\n                map.put(nums[l], map.getOrDefault(nums[l], 0) - 1);\\n                l++;        \\n            }\\n            if (curP >= k) res += l + 1;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3061254,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public long countGood(int[] nums, int k) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int leftIndex = 0;\\n        int rightIndex = 0;\\n        int numPairs = 0;\\n        long result = 0;\\n        while (rightIndex < nums.length) {\\n            int rightNum = nums[rightIndex];\\n            map.put(rightNum, map.getOrDefault(rightNum, 0) + 1);\\n            if (map.get(rightNum) >= 2) {\\n                numPairs = numPairs + map.get(rightNum) - 1;\\n            }\\n            while (numPairs >= k) {\\n                result = result + nums.length - rightIndex;\\n                int leftNum = nums[leftIndex];\\n                if (map.get(leftNum) >= 2) {\\n                    numPairs = numPairs - map.get(leftNum) + 1;\\n                }\\n                map.put(leftNum, map.getOrDefault(leftNum, 0) - 1);    \\n                leftIndex++;\\n            }\\n            rightIndex++;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public long countGood(int[] nums, int k) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int leftIndex = 0;\\n        int rightIndex = 0;\\n        int numPairs = 0;\\n        long result = 0;\\n        while (rightIndex < nums.length) {\\n            int rightNum = nums[rightIndex];\\n            map.put(rightNum, map.getOrDefault(rightNum, 0) + 1);\\n            if (map.get(rightNum) >= 2) {\\n                numPairs = numPairs + map.get(rightNum) - 1;\\n            }\\n            while (numPairs >= k) {\\n                result = result + nums.length - rightIndex;\\n                int leftNum = nums[leftIndex];\\n                if (map.get(leftNum) >= 2) {\\n                    numPairs = numPairs - map.get(leftNum) + 1;\\n                }\\n                map.put(leftNum, map.getOrDefault(leftNum, 0) - 1);    \\n                leftIndex++;\\n            }\\n            rightIndex++;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3061209,
                "title": "details-about-sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def countGood(self, nums: List[int], k: int) -> int:\\n        # sliding window, i, j \\n        # i start from 0, to j\\n        res = i = 0\\n        counter = Counter()\\n        for j in range(len(nums)):\\n            \"\"\"\\n            eg. counter[A] =\\n            1 then 0 pair\\n            2 then 1 pair\\n            3 then 1 + 2 pairs\\n            4 then 1+ 2 + 3 pairs\\n            so k -= counter[A3] = k -= 0, k-= 1, k -= 2 \\n            \"\"\"\\n            k -= counter[nums[j]]\\n            counter[nums[j]] +=  1\\n            # when k <= 0 which means from nums[i:j+1] is valid subset        \\n            while k <= 0:\\n                # decrease  counter[A3] by one, if counter[A3] = 3, which means it has 1 + 2 = 3\\n                # combinations, minus 1,  counter[A3] = 2, it has 1 pair left, 2 pair less than before\\n                # so we can add 2 pairs back to k, in line 26\\n                # if count[nums[i]] = 1, and count[nums[i+1]] = 1, kill will remain the same,\\n                # i will increate by 2, res will increate by 2, if j increate, res will increate by interval 2 \\n\\n                counter[nums[i]] -= 1\\n                k += counter[nums[i]]\\n                # window start point update, i = 1, if k > 0, jump out of while loop\\n                i += 1\\n\\n            # if k > 0, res will be 0, 1, 2, 3... as if [i, j] is valid subset then [i, j+] are all valid\\n            res += i\\n        return res\\n\\n\\n\\n\\n        \\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def countGood(self, nums: List[int], k: int) -> int:\\n        # sliding window, i, j \\n        # i start from 0, to j\\n        res = i = 0\\n        counter = Counter()\\n        for j in range(len(nums)):\\n            \"\"\"\\n            eg. counter[A] =\\n            1 then 0 pair\\n            2 then 1 pair\\n            3 then 1 + 2 pairs\\n            4 then 1+ 2 + 3 pairs\\n            so k -= counter[A3] = k -= 0, k-= 1, k -= 2 \\n            \"\"\"\\n            k -= counter[nums[j]]\\n            counter[nums[j]] +=  1\\n            # when k <= 0 which means from nums[i:j+1] is valid subset        \\n            while k <= 0:\\n                # decrease  counter[A3] by one, if counter[A3] = 3, which means it has 1 + 2 = 3\\n                # combinations, minus 1,  counter[A3] = 2, it has 1 pair left, 2 pair less than before\\n                # so we can add 2 pairs back to k, in line 26\\n                # if count[nums[i]] = 1, and count[nums[i+1]] = 1, kill will remain the same,\\n                # i will increate by 2, res will increate by 2, if j increate, res will increate by interval 2 \\n\\n                counter[nums[i]] -= 1\\n                k += counter[nums[i]]\\n                # window start point update, i = 1, if k > 0, jump out of while loop\\n                i += 1\\n\\n            # if k > 0, res will be 0, 1, 2, 3... as if [i, j] is valid subset then [i, j+] are all valid\\n            res += i\\n        return res\\n\\n\\n\\n\\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3061157,
                "title": "c-short-sliding-window-hashmap-o-n-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor each window ends at position `r`, find the rightmost position `l` such that number of valid pairs in `nums[l..r]` is no less than k. Then `nums[0..r], nums[2..r], ... nums[l,,r]` are all valid subarray with pair counts no less than k. So we can add `l+1` to the result. \\n\\nWhen `r` grows, `l` must grow or stay at the previous position. The pointer `r` will move exactly `n` times and `l` will move at most `n` times, bounding the time complexity to `O(n)`. Due to the ever-growing nature of `l, r`, sliding window should be taken into consideration. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nUse a hasmap to store the counts of each number in the sliding window. When moving the right boundary of the sliding window by 1, we can increase the number of pairs by `mp[nums[l]]`. When removing the left boundary of the sliding window by 1, we can decrease the number of pairs by `mp[nums[r]] - 1`.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nAs stated above, each element will be added to the map exactly once and can be removed at most onces by the nature of sliding windown algorithm. Each add and remove operation takes on average `O(1)` time. So the time complexity is `O(n + n) = O(n)` \\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nWe will at most store all the elements in the hashmap, Hence the space complexity is at most `O(n)` if one implements the hashmap by chaining.\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& nums, int k) {\\n        unordered_map<int ,int> mp;\\n        int l = 0, r = 0, n = nums.size();\\n        long long res = 0, cur = 0;\\n        for (; r < n; ++r) {\\n            cur += mp[nums[r]]++;\\n            if (cur < k) {continue;}\\n            while (l < r && cur - (mp[nums[l]]-1) >= k) {\\n                cur -= --mp[nums[l]];\\n                ++l;\\n            }\\n            res += l+1;\\n        }\\n        return res;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& nums, int k) {\\n        unordered_map<int ,int> mp;\\n        int l = 0, r = 0, n = nums.size();\\n        long long res = 0, cur = 0;\\n        for (; r < n; ++r) {\\n            cur += mp[nums[r]]++;\\n            if (cur < k) {continue;}\\n            while (l < r && cur - (mp[nums[l]]-1) >= k) {\\n                cur -= --mp[nums[l]];\\n                ++l;\\n            }\\n            res += l+1;\\n        }\\n        return res;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3060779,
                "title": "sliding-window-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long countGood(int[] nums, int k) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        int i = 0, j = 0;\\n        int n = nums.length;\\n        int total = 0;\\n        long res = 0L;\\n        boolean b[] = new boolean[n];\\n        while(i < n ){  \\n            while(j < n){\\n\\n                if(!b[j] && map.containsKey(nums[j])){\\n                    total += map.get(nums[j]);\\n                   map.put(nums[j], map.get(nums[j])+1);\\n                   b[j] = true;\\n                }else if(!b[j] && !map.containsKey(nums[j])){map.put(nums[j], 1);\\n                   b[j] = true;\\n                }\\n\\n                if(total >= k){\\n                   res += n-j;\\n                    break;\\n                }\\n                j++;\\n            }\\n           \\n            map.put(nums[i], map.get(nums[i])-1);\\n            total -= map.get(nums[i]);\\n       \\n            if(j == n-1 && total < k) break;\\n            else if(total < k) j++;\\n            i++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public long countGood(int[] nums, int k) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        int i = 0, j = 0;\\n        int n = nums.length;\\n        int total = 0;\\n        long res = 0L;\\n        boolean b[] = new boolean[n];\\n        while(i < n ){  \\n            while(j < n){\\n\\n                if(!b[j] && map.containsKey(nums[j])){\\n                    total += map.get(nums[j]);\\n                   map.put(nums[j], map.get(nums[j])+1);\\n                   b[j] = true;\\n                }else if(!b[j] && !map.containsKey(nums[j])){map.put(nums[j], 1);\\n                   b[j] = true;\\n                }\\n\\n                if(total >= k){\\n                   res += n-j;\\n                    break;\\n                }\\n                j++;\\n            }\\n           \\n            map.put(nums[i], map.get(nums[i])-1);\\n            total -= map.get(nums[i]);\\n       \\n            if(j == n-1 && total < k) break;\\n            else if(total < k) j++;\\n            i++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3060526,
                "title": "java-clean-two-pointers",
                "content": "# Intuition\\nTwo Pointers \\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long countGood(int[] nums, int k) {\\n        HashMap<Integer, Integer> cnt = new HashMap<>();\\n\\n        long res = 0;\\n        int curPair = 0;\\n        int n = nums.length;\\n        int slow = 0;\\n\\n        for (int fast = 0; fast < nums.length; fast++) {\\n            int cur = nums[fast];\\n            if (cnt.containsKey(cur)) {\\n                cnt.put(cur, cnt.get(cur) + 1);\\n                curPair += (cnt.get(cur) - 1);\\n            } else {\\n                cnt.put(cur, 1);\\n            }\\n\\n            while (curPair >= k) {\\n                int slowPoint = nums[slow];\\n                curPair -= (cnt.get(slowPoint) - 1);\\n                cnt.put(slowPoint, cnt.get(slowPoint) - 1);\\n                slow++;\\n            }\\n            res += slow;\\n        }\\n        \\n        return res;\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long countGood(int[] nums, int k) {\\n        HashMap<Integer, Integer> cnt = new HashMap<>();\\n\\n        long res = 0;\\n        int curPair = 0;\\n        int n = nums.length;\\n        int slow = 0;\\n\\n        for (int fast = 0; fast < nums.length; fast++) {\\n            int cur = nums[fast];\\n            if (cnt.containsKey(cur)) {\\n                cnt.put(cur, cnt.get(cur) + 1);\\n                curPair += (cnt.get(cur) - 1);\\n            } else {\\n                cnt.put(cur, 1);\\n            }\\n\\n            while (curPair >= k) {\\n                int slowPoint = nums[slow];\\n                curPair -= (cnt.get(slowPoint) - 1);\\n                cnt.put(slowPoint, cnt.get(slowPoint) - 1);\\n                slow++;\\n            }\\n            res += slow;\\n        }\\n        \\n        return res;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3060058,
                "title": "two-pointer-sliding-window-c-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& v, int k) {\\n        map<int,int>mp;\\n        int l=0,r=0;\\n        long long ans=0;\\n        int c=0;\\n        while(r<v.size()){\\n            if(mp[v[r]]==0){\\n                mp[v[r]]++;\\n                r++;\\n            }\\n            else{\\n                c+=mp[v[r]];\\n                mp[v[r]]++;\\n                while(c>=k){\\n                    ans+=v.size()-r;\\n                    mp[v[l]]--;\\n                    c-=mp[v[l]];\\n                    l++;                    \\n                }\\n                r++;\\n\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& v, int k) {\\n        map<int,int>mp;\\n        int l=0,r=0;\\n        long long ans=0;\\n        int c=0;\\n        while(r<v.size()){\\n            if(mp[v[r]]==0){\\n                mp[v[r]]++;\\n                r++;\\n            }\\n            else{\\n                c+=mp[v[r]];\\n                mp[v[r]]++;\\n                while(c>=k){\\n                    ans+=v.size()-r;\\n                    mp[v[l]]--;\\n                    c-=mp[v[l]];\\n                    l++;                    \\n                }\\n                r++;\\n\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3060048,
                "title": "intuitive-approach-sliding-window-c",
                "content": "```\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& nums, int k) {\\n        long long ans = 0;\\n        int n = nums.size();\\n        int i = 0, j = 0;\\n        unordered_map<int, int> mp;\\n        int curPairs = 0;\\n        \\n        while(j < n) {\\n            int prevPairs = mp[nums[j]] * (mp[nums[j]] - 1) / 2;\\n            mp[nums[j]]++;\\n            int newPairs = mp[nums[j]] * (mp[nums[j]] - 1) / 2;\\n            curPairs = curPairs - prevPairs + newPairs;\\n\\n            // start increasing i and reducing map value, till curPairs still equal to k\\n            while(curPairs >= k) {\\n                ans += (n-j);\\n                int prevPairs = mp[nums[i]] * (mp[nums[i]] - 1) / 2;\\n                mp[nums[i]]--;\\n                int newPairs = mp[nums[i]] * (mp[nums[i]] - 1) / 2;\\n                curPairs = curPairs - prevPairs + newPairs; \\n                i++;\\n            }\\n            \\n            j++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& nums, int k) {\\n        long long ans = 0;\\n        int n = nums.size();\\n        int i = 0, j = 0;\\n        unordered_map<int, int> mp;\\n        int curPairs = 0;\\n        \\n        while(j < n) {\\n            int prevPairs = mp[nums[j]] * (mp[nums[j]] - 1) / 2;\\n            mp[nums[j]]++;\\n            int newPairs = mp[nums[j]] * (mp[nums[j]] - 1) / 2;\\n            curPairs = curPairs - prevPairs + newPairs;\\n\\n            // start increasing i and reducing map value, till curPairs still equal to k\\n            while(curPairs >= k) {\\n                ans += (n-j);\\n                int prevPairs = mp[nums[i]] * (mp[nums[i]] - 1) / 2;\\n                mp[nums[i]]--;\\n                int newPairs = mp[nums[i]] * (mp[nums[i]] - 1) / 2;\\n                curPairs = curPairs - prevPairs + newPairs; \\n                i++;\\n            }\\n            \\n            j++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3058350,
                "title": "easy-c-solution-sliding-window",
                "content": "```\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& nums, int k) {\\n        unordered_map<int,int>mp;\\n        long long total_pair = 0;\\n        mp[nums[0]]++;\\n        int i =0 , j=1;\\n        long long ans = 0;\\n        bool j_pointer = true;\\n        bool i_pointer = false;\\n        while(i<j && j<nums.size())\\n        {\\n            if(j_pointer==true)\\n            {\\n                long long h = mp[nums[j]]-1;\\n                h=((h)*(h+1))/2;\\n                total_pair-=h;\\n                mp[nums[j]]++;\\n                long long u = mp[nums[j]]-1;\\n                u=((u)*(u+1))/2;\\n                total_pair+=u;\\n            }\\n            else\\n            {\\n                long long h = mp[nums[i]]-1;\\n                h=((h)*(h+1))/2;\\n                total_pair-=h;\\n                if(mp[nums[i]]>1)\\n                {\\n                    long long u = mp[nums[i]]-2;\\n                    u=((u)*(u+1))/2;\\n                    total_pair+=u;\\n                }\\n                mp[nums[i]]--;\\n                i++;\\n            }\\n            if(total_pair>=k)\\n            {\\n                ans+=(nums.size()-j);\\n                i_pointer=true;\\n                j_pointer=false;\\n            }\\n            else\\n            {\\n                j++;\\n                i_pointer = false;\\n                j_pointer =true;\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& nums, int k) {\\n        unordered_map<int,int>mp;\\n        long long total_pair = 0;\\n        mp[nums[0]]++;\\n        int i =0 , j=1;\\n        long long ans = 0;\\n        bool j_pointer = true;\\n        bool i_pointer = false;\\n        while(i<j && j<nums.size())\\n        {\\n            if(j_pointer==true)\\n            {\\n                long long h = mp[nums[j]]-1;\\n                h=((h)*(h+1))/2;\\n                total_pair-=h;\\n                mp[nums[j]]++;\\n                long long u = mp[nums[j]]-1;\\n                u=((u)*(u+1))/2;\\n                total_pair+=u;\\n            }\\n            else\\n            {\\n                long long h = mp[nums[i]]-1;\\n                h=((h)*(h+1))/2;\\n                total_pair-=h;\\n                if(mp[nums[i]]>1)\\n                {\\n                    long long u = mp[nums[i]]-2;\\n                    u=((u)*(u+1))/2;\\n                    total_pair+=u;\\n                }\\n                mp[nums[i]]--;\\n                i++;\\n            }\\n            if(total_pair>=k)\\n            {\\n                ans+=(nums.size()-j);\\n                i_pointer=true;\\n                j_pointer=false;\\n            }\\n            else\\n            {\\n                j++;\\n                i_pointer = false;\\n                j_pointer =true;\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3058195,
                "title": "python-two-pointers-o-n",
                "content": "# Code\\n```\\nclass Solution:\\n    def countGood(self, nums: List[int], k: int) -> int:\\n        counter = Counter()\\n        cur = 0\\n        i = 0\\n        res = 0\\n        for num in nums:\\n            cur += counter[num]\\n            counter[num] += 1\\n            while cur >= k:\\n                cur -= counter[nums[i]]-1\\n                counter[nums[i]] -= 1\\n                i += 1\\n            res += i\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countGood(self, nums: List[int], k: int) -> int:\\n        counter = Counter()\\n        cur = 0\\n        i = 0\\n        res = 0\\n        for num in nums:\\n            cur += counter[num]\\n            counter[num] += 1\\n            while cur >= k:\\n                cur -= counter[nums[i]]-1\\n                counter[nums[i]] -= 1\\n                i += 1\\n            res += i\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3058016,
                "title": "java-sliding-winow",
                "content": "```\\nclass Solution {\\n    public long countGood(int[] nums, int k) {\\n        int n = nums.length, count = 0;\\n        long res = 0;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int i = 0, j = 0; j < n; j++) {\\n            map.put(nums[j], map.getOrDefault(nums[j], 0) + 1);\\n            count += (map.get(nums[j]) - 1);\\n            while (count >= k) {\\n                res += n - j;\\n                map.put(nums[i], map.get(nums[i]) - 1);\\n                count -= map.get(nums[i++]);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long countGood(int[] nums, int k) {\\n        int n = nums.length, count = 0;\\n        long res = 0;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int i = 0, j = 0; j < n; j++) {\\n            map.put(nums[j], map.getOrDefault(nums[j], 0) + 1);\\n            count += (map.get(nums[j]) - 1);\\n            while (count >= k) {\\n                res += n - j;\\n                map.put(nums[i], map.get(nums[i]) - 1);\\n                count -= map.get(nums[i++]);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3058004,
                "title": "java-one-of-the-easiest-solution-with-two-pointer-explanation",
                "content": "```\\npublic long countGood(int[] nums, int k) {\\n        int n = nums.length;\\n        Map<Integer, Long> map  = new HashMap<>();\\n        int left = 0;\\n        int right = 0;\\n        long cur = 0;\\n        long ans = 0;\\n        while(right < n){\\n            if (map.containsKey(nums[right])) {\\n                cur -= calc(map.get(nums[right]));\\n            }\\n            \\n            map.put(nums[right], map.getOrDefault(nums[right], 0L)+1);\\n            cur+= calc(map.get(nums[right]));\\n            while(left < right && cur >= k){\\n                ans+=n-right;\\n                cur-=calc(map.get(nums[left]));\\n                map.put(nums[left], map.get(nums[left])-1);\\n                cur+=calc(map.get(nums[left]));\\n                left++;\\n            }\\n            right++;\\n        }\\n        return ans;\\n    }\\n    \\n    private static long calc(long num){\\n        long ans = num * (num -1);\\n        ans/=2;\\n        return ans;\\n    }\\n```\\n\\nExplanation about the **calc Method**, here we are  doing the combination formula i.e n C 2 which is (n*(n-1) )/2.",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Sliding Window"
                ],
                "code": "```\\npublic long countGood(int[] nums, int k) {\\n        int n = nums.length;\\n        Map<Integer, Long> map  = new HashMap<>();\\n        int left = 0;\\n        int right = 0;\\n        long cur = 0;\\n        long ans = 0;\\n        while(right < n){\\n            if (map.containsKey(nums[right])) {\\n                cur -= calc(map.get(nums[right]));\\n            }\\n            \\n            map.put(nums[right], map.getOrDefault(nums[right], 0L)+1);\\n            cur+= calc(map.get(nums[right]));\\n            while(left < right && cur >= k){\\n                ans+=n-right;\\n                cur-=calc(map.get(nums[left]));\\n                map.put(nums[left], map.get(nums[left])-1);\\n                cur+=calc(map.get(nums[left]));\\n                left++;\\n            }\\n            right++;\\n        }\\n        return ans;\\n    }\\n    \\n    private static long calc(long num){\\n        long ans = num * (num -1);\\n        ans/=2;\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3057938,
                "title": "easy-sliding-window-approach",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& nums, int k) {\\n        unordered_map<int,int> m;\\n        int n=nums.size();\\n        int pairs=0;\\n        int i=0,j=0;\\n        long long count=0;\\n        \\n        for(int i=0;i<n;i++){\\n            if(m.count(nums[i])>0){\\n                pairs+=m[nums[i]];\\n                m[nums[i]]++;\\n            }\\n            else m[nums[i]]=1;\\n            \\n            if(pairs>=k) count+=(n-i);\\n            \\n            while(pairs>=k){\\n                m[nums[j]]--;\\n                pairs-=m[nums[j]];\\n                if(pairs>=k) count+=(n-i);\\n                j++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countGood(vector<int>& nums, int k) {\\n        unordered_map<int,int> m;\\n        int n=nums.size();\\n        int pairs=0;\\n        int i=0,j=0;\\n        long long count=0;\\n        \\n        for(int i=0;i<n;i++){\\n            if(m.count(nums[i])>0){\\n                pairs+=m[nums[i]];\\n                m[nums[i]]++;\\n            }\\n            else m[nums[i]]=1;\\n            \\n            if(pairs>=k) count+=(n-i);\\n            \\n            while(pairs>=k){\\n                m[nums[j]]--;\\n                pairs-=m[nums[j]];\\n                if(pairs>=k) count+=(n-i);\\n                j++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3057911,
                "title": "java-full-explanation-100-fast-o-n-hashmap-two-pointer",
                "content": "# Intuition\\n1. If the frequency of a number increases the number of pairs formed by that number is increased by current frequency -1.\\n   For eg :1 has a frequency of 2, so the number of pairs now formed by 1 is 1. Now if the frequency of 1 is increased from 2->3 so now the number of  pairs formed by 1 is 3. \\n**If you notice here the increase in the frequency is 2 which was the previous frequency of 1**\\n\\n2. We can use above intuition for saving our iteration to calculate the number of pairs .\\n\\n\\n\\n# Approach\\n1. We will use a map to store the frequency of the numbers.\\n2. We will use two pointers to iterate through the array.\\n3. First pointer will be moving from 0th index to nth index till we don\\'t match the requiremnts of a good array that is we don\\'t get k number of pairs. And as we met a pair we will reduce the k by our intuition.\\n4. If the k = 0 this means we have got a good subarray which have k number of pairs. So now we will iterate the second pointer from 0th index to nth index or till k is less than zero. \\n5. While iterating the second pointer we will reduce the frequency of the numbers as we will be reducing the size of subarray to check how many good subarrays can be still formed by reducing the size .\\n6. If our k gets greater than 0 while moving the second pointer we will stop the pointer their and add the index of the second pointer.\\n7. Then we will again move the first pointer and follow the steps from 3.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public long countGood(int[] nums, int k) {\\n        long ans =0;\\n        HashMap<Integer,Integer> hm = new HashMap<>();\\n        for(int i =0,j=0;j<nums.length;j++){\\n            k-=hm.getOrDefault(nums[j],0);\\n            hm.put(nums[j],hm.getOrDefault(nums[j],0)+1);\\n            while(k<=0){\\n                hm.put(nums[i],hm.get(nums[i])-1);\\n                k+=hm.get(nums[i]);\\n                i++;\\n            }\\n            ans+=i;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public long countGood(int[] nums, int k) {\\n        long ans =0;\\n        HashMap<Integer,Integer> hm = new HashMap<>();\\n        for(int i =0,j=0;j<nums.length;j++){\\n            k-=hm.getOrDefault(nums[j],0);\\n            hm.put(nums[j],hm.getOrDefault(nums[j],0)+1);\\n            while(k<=0){\\n                hm.put(nums[i],hm.get(nums[i])-1);\\n                k+=hm.get(nums[i]);\\n                i++;\\n            }\\n            ans+=i;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3057893,
                "title": "simple-c-solution-with-comments-unordered-maps",
                "content": "# Complexity\\n- Time complexity:\\n    $$O(nlog(n))$$ - for iterating the nums array and removing values.\\n\\n- Space complexity:\\n    $$O(n)$$ - for storing map values.\\n\\n# Code\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    ll countGood(vector<int>& nums, int k) {\\n        ll ans=0, currSum=0, idx=0, n=nums.size();\\n        // Map to store the occurences.\\n        unordered_map<ll,ll>mp;\\n        // Iterate all nums values\\n        for(int i=0;i<n;i++){\\n            // Add that number in index i to map\\n            mp[nums[i]]++;\\n            // Get the currSum of repeated elements.\\n            currSum+=mp[nums[i]]-1;\\n\\n            // Now shorten the selected array by removing the left values.\\n            // Until currSum>=k and idx should be less than i\\n            while(currSum>=k and idx<i){\\n                // Add the values to ans\\n                ans+=(n-i);\\n                // Remove element at index idx from map\\n                mp[nums[idx]]--;\\n                // Get updated currSum value\\n                currSum-=mp[nums[idx]];\\n                idx++;\\n            }\\n        }\\n        // Finally return ans\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    ll countGood(vector<int>& nums, int k) {\\n        ll ans=0, currSum=0, idx=0, n=nums.size();\\n        // Map to store the occurences.\\n        unordered_map<ll,ll>mp;\\n        // Iterate all nums values\\n        for(int i=0;i<n;i++){\\n            // Add that number in index i to map\\n            mp[nums[i]]++;\\n            // Get the currSum of repeated elements.\\n            currSum+=mp[nums[i]]-1;\\n\\n            // Now shorten the selected array by removing the left values.\\n            // Until currSum>=k and idx should be less than i\\n            while(currSum>=k and idx<i){\\n                // Add the values to ans\\n                ans+=(n-i);\\n                // Remove element at index idx from map\\n                mp[nums[idx]]--;\\n                // Get updated currSum value\\n                currSum-=mp[nums[idx]];\\n                idx++;\\n            }\\n        }\\n        // Finally return ans\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3057340,
                "title": "python-sliding-window-solution-best-time-space-complexity-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSliding Window\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe maintain a window by ```left``` and ```right``` pointers, adding the newly added possible pairs to ```curPairs``` and subtracting the number of pairs as we increment ```left```. We maintain the window such that the number of pairs is always greater or equal to ```k```.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$ for the frequency map\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```python []\\nclass Solution:\\n    def countGood(self, nums: List[int], k: int) -> int:\\n        sz, hashMap = len(nums), defaultdict(int)\\n        ans = curPairs = temp = left = right = 0\\n        for right in range(sz):\\n            hashMap[nums[right]] += 1\\n            curPairs += (hashMap[nums[right]] - 1)\\n            while curPairs >= k and left < right:\\n                ans += (sz - right)\\n                hashMap[nums[left]] -= 1\\n                curPairs -= hashMap[nums[left]]\\n                left += 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```left```\n```right```\n```curPairs```\n```left```\n```k```\n```python []\\nclass Solution:\\n    def countGood(self, nums: List[int], k: int) -> int:\\n        sz, hashMap = len(nums), defaultdict(int)\\n        ans = curPairs = temp = left = right = 0\\n        for right in range(sz):\\n            hashMap[nums[right]] += 1\\n            curPairs += (hashMap[nums[right]] - 1)\\n            while curPairs >= k and left < right:\\n                ans += (sz - right)\\n                hashMap[nums[left]] -= 1\\n                curPairs -= hashMap[nums[left]]\\n                left += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3057338,
                "title": "we-keep-track-of-number-of-pairs-100-faster-than-java-online-submissions",
                "content": "Required Ways = Total ways - who are not making pairs of atleast \\'k\\' ;\\n\\nWe\\'ll keep track of count that formed pairs \\nwhile count>= k we decrease count from left using \\'j\\'\\nwhile coun<k we count how many numbers are not forming pairs\\nin last we delete this res from total of ways \\nhence we get our ans \\n```\\npublic long countGood(int[] nums, int k) {\\n        Map<Integer,Integer> map = new HashMap<>();\\n        long res = 0 , count = 0 ; \\n        for(int i = 0 , j = 0 ; i < nums.length ; i++){\\n            map.put(nums[i],map.getOrDefault(nums[i],0)+1);\\n            count += map.get(nums[i])-1;\\n            while(count>=k){\\n                map.put(nums[j],map.get(nums[j])-1);\\n                count-=map.get(nums[j]);\\n                j++;\\n            }\\n            res += i-j+1;\\n        }\\n        long a = nums.length;\\n        return (a*(a+1))/2 - res ; \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic long countGood(int[] nums, int k) {\\n        Map<Integer,Integer> map = new HashMap<>();\\n        long res = 0 , count = 0 ; \\n        for(int i = 0 , j = 0 ; i < nums.length ; i++){\\n            map.put(nums[i],map.getOrDefault(nums[i],0)+1);\\n            count += map.get(nums[i])-1;\\n            while(count>=k){\\n                map.put(nums[j],map.get(nums[j])-1);\\n                count-=map.get(nums[j]);\\n                j++;\\n            }\\n            res += i-j+1;\\n        }\\n        long a = nums.length;\\n        return (a*(a+1))/2 - res ; \\n    }\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1762520,
                "content": [
                    {
                        "username": "cty549868165",
                        "content": "Hardest one in medium level!!!!! so many details need to be considered."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "SLIDING WINDOW was the only concept coming in mind this whole time. \\nI wonder what will be the best logic to count the number of GOOD subarrays \\uD83E\\uDD14"
                    },
                    {
                        "username": "deep_patel23",
                        "content": "Sliding window + nC2 (combination formula)\\nFind beginner friendly solution here: https://youtu.be/dophWA1gv1g"
                    },
                    {
                        "username": "Magsut",
                        "content": "In my opinion, we can use sliding window + greedy algorithm to solve this problem "
                    },
                    {
                        "username": "_tofu_",
                        "content": "O(N) time, O(1) space, classic sliding window version. Just have to notice that lots of logic need to be considered carefully.\\n\\n```\\nclass Solution2 {\\npublic:\\n    long long countGood(vector<int> &nums, int k) {\\n        int n = nums.size();\\n        int left = 0;\\n        int right = 0;\\n\\n        long long res = 0;\\n        unordered_map<int, int> freq;\\n        long long count = 0;\\n\\n        for (; right < n; right++) {\\n            long long old_freq = freq[nums[right]];\\n            long long old_pair = old_freq * (old_freq - 1) / 2;\\n\\n            freq[nums[right]]++;\\n            long long new_freq = freq[nums[right]];\\n            long long new_pair = new_freq * (new_freq - 1) / 2;\\n\\n            count = count - old_pair + new_pair;\\n\\n            while (count >= k) {\\n                res += n - 1 - right + 1;\\n\\n                long long old_left_freq = freq[nums[left]];\\n                long long old_left_pair = old_left_freq * (old_left_freq - 1) / 2;\\n\\n                freq[nums[left]]--;\\n\\n                long long new_left_freq = freq[nums[left]];\\n                long long new_left_pair = new_left_freq * (new_left_freq - 1) / 2;\\n\\n                count = count - old_left_pair + new_left_pair;\\n                left++;\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "_Arthur_Morgan___",
                        "content": "Can someone explain me why expected output of this testcase is 9,\\n\\n`nums =\\n[3,1,4,3,3,3,4]\\nk =\\n2`\\n\\nI am getting output as  4 good subarrays when I done dry run. Below are subarrays I am getting.\\n\\n`[3,1,4,3,3,3]\\n[3,1,4,3,3,3,4]\\n[1,4,3,3,3,4]\\n[4,3,3,3,4]`\\n\\n\\nAny help would be appreciated.\\n"
                    },
                    {
                        "username": "taiwanjizhan",
                        "content": "`[3,1,4,3,3]` has 3 pairs\\n`[3,1,4,3,3,3]` has 6 pairs\\n`[3,1,4,3,3,3,4]` has 7 pairs\\n`[1,4,3,3,3]` has 3 pairs\\n`[1,4,3,3,3,4]` has 4 pairs\\n`[4,3,3,3]` has 3 pairs\\n`[4,3,3,3,4]` has 4 pairs\\n`[3,3,3]` has 3 pairs\\n`[3,3,3,4]` has 3 pairs\\ntotally 9 good subarrays"
                    },
                    {
                        "username": "aravindk3992",
                        "content": "Whats wrong with my code\\n    let nums = [1, 1, 1, 1, 1], k = 10;\\n\\n    let goodSubArrayCount = 0, frequencySet = new Map();\\n    let pairsCount = 0, j = 0, i = 0;\\n\\n    while(j < nums.length) {\\n      if(frequencySet.has(nums[j])) {\\n        frequencySet.set(nums[j], frequencySet.get(nums[j]) + 1);\\n      } else {\\n        frequencySet.set(nums[j], 1);\\n      }\\n\\n      pairsCount += this.calculateFrequency(frequencySet.get(nums[j]));\\n      while(pairsCount >= k) {\\n        goodSubArrayCount += nums.length - j;\\n        pairsCount -= this.calculateFrequency(frequencySet.get(nums[i]));\\n        if(frequencySet.get(nums[i]) > 1) {\\n          frequencySet.set(nums[i], frequencySet.get(nums[i]) - 1);\\n          pairsCount += this.calculateFrequency(frequencySet.get(nums[i]));\\n        } else {\\n          frequencySet.delete(nums[i]);\\n        }\\n        i++;\\n      }\\n      j++;\\n    }\\n    \\n    alert(goodSubArrayCount);"
                    },
                    {
                        "username": "gakharsarang1",
                        "content": "i wrote a solution it gave me wrong answer on the last testcase can anyone please tell me why\n\n\n `       long long countGood(vector<int>& \n         nums, int k) {\n        \n        \n        unordered_map<int,int> mp;\n        long long n=nums.size();\n        long long value=0,res=0;\n        long long M=1e9+7;\n        int j=0;\n\n\n        for(int i=0;i<n;i++){\n                if(mp.find(nums[i])!=mp.end()){\n                    value+=mp[nums[i]];\n                }\n                \n                mp[nums[i]]++;\n\n                if(value>=k){\n\n                    res+=(long long)n-i;\n\n\n                while(j<i-1){\n\n                    mp[nums[j]]--;\n\n                    value-=mp[nums[j]];\n\n                    if(value>=k){\n                        res+=n-i;\n                        j++;\n                        \n                    }\n\n                    else{\n                        j++;\n                        break;\n                        \n                    }\n\n\n                }\n       \n\n            }\n\n        }\n\n\n\n        return res;\n        \n        \n        \n        \n    }\n\n`"
                    },
                    {
                        "username": "taiwanjizhan",
                        "content": "To Python coders: Can this problem be solved by use/import **itertools**?"
                    }
                ]
            },
            {
                "id": 1758512,
                "content": [
                    {
                        "username": "cty549868165",
                        "content": "Hardest one in medium level!!!!! so many details need to be considered."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "SLIDING WINDOW was the only concept coming in mind this whole time. \\nI wonder what will be the best logic to count the number of GOOD subarrays \\uD83E\\uDD14"
                    },
                    {
                        "username": "deep_patel23",
                        "content": "Sliding window + nC2 (combination formula)\\nFind beginner friendly solution here: https://youtu.be/dophWA1gv1g"
                    },
                    {
                        "username": "Magsut",
                        "content": "In my opinion, we can use sliding window + greedy algorithm to solve this problem "
                    },
                    {
                        "username": "_tofu_",
                        "content": "O(N) time, O(1) space, classic sliding window version. Just have to notice that lots of logic need to be considered carefully.\\n\\n```\\nclass Solution2 {\\npublic:\\n    long long countGood(vector<int> &nums, int k) {\\n        int n = nums.size();\\n        int left = 0;\\n        int right = 0;\\n\\n        long long res = 0;\\n        unordered_map<int, int> freq;\\n        long long count = 0;\\n\\n        for (; right < n; right++) {\\n            long long old_freq = freq[nums[right]];\\n            long long old_pair = old_freq * (old_freq - 1) / 2;\\n\\n            freq[nums[right]]++;\\n            long long new_freq = freq[nums[right]];\\n            long long new_pair = new_freq * (new_freq - 1) / 2;\\n\\n            count = count - old_pair + new_pair;\\n\\n            while (count >= k) {\\n                res += n - 1 - right + 1;\\n\\n                long long old_left_freq = freq[nums[left]];\\n                long long old_left_pair = old_left_freq * (old_left_freq - 1) / 2;\\n\\n                freq[nums[left]]--;\\n\\n                long long new_left_freq = freq[nums[left]];\\n                long long new_left_pair = new_left_freq * (new_left_freq - 1) / 2;\\n\\n                count = count - old_left_pair + new_left_pair;\\n                left++;\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "_Arthur_Morgan___",
                        "content": "Can someone explain me why expected output of this testcase is 9,\\n\\n`nums =\\n[3,1,4,3,3,3,4]\\nk =\\n2`\\n\\nI am getting output as  4 good subarrays when I done dry run. Below are subarrays I am getting.\\n\\n`[3,1,4,3,3,3]\\n[3,1,4,3,3,3,4]\\n[1,4,3,3,3,4]\\n[4,3,3,3,4]`\\n\\n\\nAny help would be appreciated.\\n"
                    },
                    {
                        "username": "taiwanjizhan",
                        "content": "`[3,1,4,3,3]` has 3 pairs\\n`[3,1,4,3,3,3]` has 6 pairs\\n`[3,1,4,3,3,3,4]` has 7 pairs\\n`[1,4,3,3,3]` has 3 pairs\\n`[1,4,3,3,3,4]` has 4 pairs\\n`[4,3,3,3]` has 3 pairs\\n`[4,3,3,3,4]` has 4 pairs\\n`[3,3,3]` has 3 pairs\\n`[3,3,3,4]` has 3 pairs\\ntotally 9 good subarrays"
                    },
                    {
                        "username": "aravindk3992",
                        "content": "Whats wrong with my code\\n    let nums = [1, 1, 1, 1, 1], k = 10;\\n\\n    let goodSubArrayCount = 0, frequencySet = new Map();\\n    let pairsCount = 0, j = 0, i = 0;\\n\\n    while(j < nums.length) {\\n      if(frequencySet.has(nums[j])) {\\n        frequencySet.set(nums[j], frequencySet.get(nums[j]) + 1);\\n      } else {\\n        frequencySet.set(nums[j], 1);\\n      }\\n\\n      pairsCount += this.calculateFrequency(frequencySet.get(nums[j]));\\n      while(pairsCount >= k) {\\n        goodSubArrayCount += nums.length - j;\\n        pairsCount -= this.calculateFrequency(frequencySet.get(nums[i]));\\n        if(frequencySet.get(nums[i]) > 1) {\\n          frequencySet.set(nums[i], frequencySet.get(nums[i]) - 1);\\n          pairsCount += this.calculateFrequency(frequencySet.get(nums[i]));\\n        } else {\\n          frequencySet.delete(nums[i]);\\n        }\\n        i++;\\n      }\\n      j++;\\n    }\\n    \\n    alert(goodSubArrayCount);"
                    },
                    {
                        "username": "gakharsarang1",
                        "content": "i wrote a solution it gave me wrong answer on the last testcase can anyone please tell me why\n\n\n `       long long countGood(vector<int>& \n         nums, int k) {\n        \n        \n        unordered_map<int,int> mp;\n        long long n=nums.size();\n        long long value=0,res=0;\n        long long M=1e9+7;\n        int j=0;\n\n\n        for(int i=0;i<n;i++){\n                if(mp.find(nums[i])!=mp.end()){\n                    value+=mp[nums[i]];\n                }\n                \n                mp[nums[i]]++;\n\n                if(value>=k){\n\n                    res+=(long long)n-i;\n\n\n                while(j<i-1){\n\n                    mp[nums[j]]--;\n\n                    value-=mp[nums[j]];\n\n                    if(value>=k){\n                        res+=n-i;\n                        j++;\n                        \n                    }\n\n                    else{\n                        j++;\n                        break;\n                        \n                    }\n\n\n                }\n       \n\n            }\n\n        }\n\n\n\n        return res;\n        \n        \n        \n        \n    }\n\n`"
                    },
                    {
                        "username": "taiwanjizhan",
                        "content": "To Python coders: Can this problem be solved by use/import **itertools**?"
                    }
                ]
            },
            {
                "id": 1758881,
                "content": [
                    {
                        "username": "cty549868165",
                        "content": "Hardest one in medium level!!!!! so many details need to be considered."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "SLIDING WINDOW was the only concept coming in mind this whole time. \\nI wonder what will be the best logic to count the number of GOOD subarrays \\uD83E\\uDD14"
                    },
                    {
                        "username": "deep_patel23",
                        "content": "Sliding window + nC2 (combination formula)\\nFind beginner friendly solution here: https://youtu.be/dophWA1gv1g"
                    },
                    {
                        "username": "Magsut",
                        "content": "In my opinion, we can use sliding window + greedy algorithm to solve this problem "
                    },
                    {
                        "username": "_tofu_",
                        "content": "O(N) time, O(1) space, classic sliding window version. Just have to notice that lots of logic need to be considered carefully.\\n\\n```\\nclass Solution2 {\\npublic:\\n    long long countGood(vector<int> &nums, int k) {\\n        int n = nums.size();\\n        int left = 0;\\n        int right = 0;\\n\\n        long long res = 0;\\n        unordered_map<int, int> freq;\\n        long long count = 0;\\n\\n        for (; right < n; right++) {\\n            long long old_freq = freq[nums[right]];\\n            long long old_pair = old_freq * (old_freq - 1) / 2;\\n\\n            freq[nums[right]]++;\\n            long long new_freq = freq[nums[right]];\\n            long long new_pair = new_freq * (new_freq - 1) / 2;\\n\\n            count = count - old_pair + new_pair;\\n\\n            while (count >= k) {\\n                res += n - 1 - right + 1;\\n\\n                long long old_left_freq = freq[nums[left]];\\n                long long old_left_pair = old_left_freq * (old_left_freq - 1) / 2;\\n\\n                freq[nums[left]]--;\\n\\n                long long new_left_freq = freq[nums[left]];\\n                long long new_left_pair = new_left_freq * (new_left_freq - 1) / 2;\\n\\n                count = count - old_left_pair + new_left_pair;\\n                left++;\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "_Arthur_Morgan___",
                        "content": "Can someone explain me why expected output of this testcase is 9,\\n\\n`nums =\\n[3,1,4,3,3,3,4]\\nk =\\n2`\\n\\nI am getting output as  4 good subarrays when I done dry run. Below are subarrays I am getting.\\n\\n`[3,1,4,3,3,3]\\n[3,1,4,3,3,3,4]\\n[1,4,3,3,3,4]\\n[4,3,3,3,4]`\\n\\n\\nAny help would be appreciated.\\n"
                    },
                    {
                        "username": "taiwanjizhan",
                        "content": "`[3,1,4,3,3]` has 3 pairs\\n`[3,1,4,3,3,3]` has 6 pairs\\n`[3,1,4,3,3,3,4]` has 7 pairs\\n`[1,4,3,3,3]` has 3 pairs\\n`[1,4,3,3,3,4]` has 4 pairs\\n`[4,3,3,3]` has 3 pairs\\n`[4,3,3,3,4]` has 4 pairs\\n`[3,3,3]` has 3 pairs\\n`[3,3,3,4]` has 3 pairs\\ntotally 9 good subarrays"
                    },
                    {
                        "username": "aravindk3992",
                        "content": "Whats wrong with my code\\n    let nums = [1, 1, 1, 1, 1], k = 10;\\n\\n    let goodSubArrayCount = 0, frequencySet = new Map();\\n    let pairsCount = 0, j = 0, i = 0;\\n\\n    while(j < nums.length) {\\n      if(frequencySet.has(nums[j])) {\\n        frequencySet.set(nums[j], frequencySet.get(nums[j]) + 1);\\n      } else {\\n        frequencySet.set(nums[j], 1);\\n      }\\n\\n      pairsCount += this.calculateFrequency(frequencySet.get(nums[j]));\\n      while(pairsCount >= k) {\\n        goodSubArrayCount += nums.length - j;\\n        pairsCount -= this.calculateFrequency(frequencySet.get(nums[i]));\\n        if(frequencySet.get(nums[i]) > 1) {\\n          frequencySet.set(nums[i], frequencySet.get(nums[i]) - 1);\\n          pairsCount += this.calculateFrequency(frequencySet.get(nums[i]));\\n        } else {\\n          frequencySet.delete(nums[i]);\\n        }\\n        i++;\\n      }\\n      j++;\\n    }\\n    \\n    alert(goodSubArrayCount);"
                    },
                    {
                        "username": "gakharsarang1",
                        "content": "i wrote a solution it gave me wrong answer on the last testcase can anyone please tell me why\n\n\n `       long long countGood(vector<int>& \n         nums, int k) {\n        \n        \n        unordered_map<int,int> mp;\n        long long n=nums.size();\n        long long value=0,res=0;\n        long long M=1e9+7;\n        int j=0;\n\n\n        for(int i=0;i<n;i++){\n                if(mp.find(nums[i])!=mp.end()){\n                    value+=mp[nums[i]];\n                }\n                \n                mp[nums[i]]++;\n\n                if(value>=k){\n\n                    res+=(long long)n-i;\n\n\n                while(j<i-1){\n\n                    mp[nums[j]]--;\n\n                    value-=mp[nums[j]];\n\n                    if(value>=k){\n                        res+=n-i;\n                        j++;\n                        \n                    }\n\n                    else{\n                        j++;\n                        break;\n                        \n                    }\n\n\n                }\n       \n\n            }\n\n        }\n\n\n\n        return res;\n        \n        \n        \n        \n    }\n\n`"
                    },
                    {
                        "username": "taiwanjizhan",
                        "content": "To Python coders: Can this problem be solved by use/import **itertools**?"
                    }
                ]
            },
            {
                "id": 1758497,
                "content": [
                    {
                        "username": "cty549868165",
                        "content": "Hardest one in medium level!!!!! so many details need to be considered."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "SLIDING WINDOW was the only concept coming in mind this whole time. \\nI wonder what will be the best logic to count the number of GOOD subarrays \\uD83E\\uDD14"
                    },
                    {
                        "username": "deep_patel23",
                        "content": "Sliding window + nC2 (combination formula)\\nFind beginner friendly solution here: https://youtu.be/dophWA1gv1g"
                    },
                    {
                        "username": "Magsut",
                        "content": "In my opinion, we can use sliding window + greedy algorithm to solve this problem "
                    },
                    {
                        "username": "_tofu_",
                        "content": "O(N) time, O(1) space, classic sliding window version. Just have to notice that lots of logic need to be considered carefully.\\n\\n```\\nclass Solution2 {\\npublic:\\n    long long countGood(vector<int> &nums, int k) {\\n        int n = nums.size();\\n        int left = 0;\\n        int right = 0;\\n\\n        long long res = 0;\\n        unordered_map<int, int> freq;\\n        long long count = 0;\\n\\n        for (; right < n; right++) {\\n            long long old_freq = freq[nums[right]];\\n            long long old_pair = old_freq * (old_freq - 1) / 2;\\n\\n            freq[nums[right]]++;\\n            long long new_freq = freq[nums[right]];\\n            long long new_pair = new_freq * (new_freq - 1) / 2;\\n\\n            count = count - old_pair + new_pair;\\n\\n            while (count >= k) {\\n                res += n - 1 - right + 1;\\n\\n                long long old_left_freq = freq[nums[left]];\\n                long long old_left_pair = old_left_freq * (old_left_freq - 1) / 2;\\n\\n                freq[nums[left]]--;\\n\\n                long long new_left_freq = freq[nums[left]];\\n                long long new_left_pair = new_left_freq * (new_left_freq - 1) / 2;\\n\\n                count = count - old_left_pair + new_left_pair;\\n                left++;\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "_Arthur_Morgan___",
                        "content": "Can someone explain me why expected output of this testcase is 9,\\n\\n`nums =\\n[3,1,4,3,3,3,4]\\nk =\\n2`\\n\\nI am getting output as  4 good subarrays when I done dry run. Below are subarrays I am getting.\\n\\n`[3,1,4,3,3,3]\\n[3,1,4,3,3,3,4]\\n[1,4,3,3,3,4]\\n[4,3,3,3,4]`\\n\\n\\nAny help would be appreciated.\\n"
                    },
                    {
                        "username": "taiwanjizhan",
                        "content": "`[3,1,4,3,3]` has 3 pairs\\n`[3,1,4,3,3,3]` has 6 pairs\\n`[3,1,4,3,3,3,4]` has 7 pairs\\n`[1,4,3,3,3]` has 3 pairs\\n`[1,4,3,3,3,4]` has 4 pairs\\n`[4,3,3,3]` has 3 pairs\\n`[4,3,3,3,4]` has 4 pairs\\n`[3,3,3]` has 3 pairs\\n`[3,3,3,4]` has 3 pairs\\ntotally 9 good subarrays"
                    },
                    {
                        "username": "aravindk3992",
                        "content": "Whats wrong with my code\\n    let nums = [1, 1, 1, 1, 1], k = 10;\\n\\n    let goodSubArrayCount = 0, frequencySet = new Map();\\n    let pairsCount = 0, j = 0, i = 0;\\n\\n    while(j < nums.length) {\\n      if(frequencySet.has(nums[j])) {\\n        frequencySet.set(nums[j], frequencySet.get(nums[j]) + 1);\\n      } else {\\n        frequencySet.set(nums[j], 1);\\n      }\\n\\n      pairsCount += this.calculateFrequency(frequencySet.get(nums[j]));\\n      while(pairsCount >= k) {\\n        goodSubArrayCount += nums.length - j;\\n        pairsCount -= this.calculateFrequency(frequencySet.get(nums[i]));\\n        if(frequencySet.get(nums[i]) > 1) {\\n          frequencySet.set(nums[i], frequencySet.get(nums[i]) - 1);\\n          pairsCount += this.calculateFrequency(frequencySet.get(nums[i]));\\n        } else {\\n          frequencySet.delete(nums[i]);\\n        }\\n        i++;\\n      }\\n      j++;\\n    }\\n    \\n    alert(goodSubArrayCount);"
                    },
                    {
                        "username": "gakharsarang1",
                        "content": "i wrote a solution it gave me wrong answer on the last testcase can anyone please tell me why\n\n\n `       long long countGood(vector<int>& \n         nums, int k) {\n        \n        \n        unordered_map<int,int> mp;\n        long long n=nums.size();\n        long long value=0,res=0;\n        long long M=1e9+7;\n        int j=0;\n\n\n        for(int i=0;i<n;i++){\n                if(mp.find(nums[i])!=mp.end()){\n                    value+=mp[nums[i]];\n                }\n                \n                mp[nums[i]]++;\n\n                if(value>=k){\n\n                    res+=(long long)n-i;\n\n\n                while(j<i-1){\n\n                    mp[nums[j]]--;\n\n                    value-=mp[nums[j]];\n\n                    if(value>=k){\n                        res+=n-i;\n                        j++;\n                        \n                    }\n\n                    else{\n                        j++;\n                        break;\n                        \n                    }\n\n\n                }\n       \n\n            }\n\n        }\n\n\n\n        return res;\n        \n        \n        \n        \n    }\n\n`"
                    },
                    {
                        "username": "taiwanjizhan",
                        "content": "To Python coders: Can this problem be solved by use/import **itertools**?"
                    }
                ]
            },
            {
                "id": 1997780,
                "content": [
                    {
                        "username": "cty549868165",
                        "content": "Hardest one in medium level!!!!! so many details need to be considered."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "SLIDING WINDOW was the only concept coming in mind this whole time. \\nI wonder what will be the best logic to count the number of GOOD subarrays \\uD83E\\uDD14"
                    },
                    {
                        "username": "deep_patel23",
                        "content": "Sliding window + nC2 (combination formula)\\nFind beginner friendly solution here: https://youtu.be/dophWA1gv1g"
                    },
                    {
                        "username": "Magsut",
                        "content": "In my opinion, we can use sliding window + greedy algorithm to solve this problem "
                    },
                    {
                        "username": "_tofu_",
                        "content": "O(N) time, O(1) space, classic sliding window version. Just have to notice that lots of logic need to be considered carefully.\\n\\n```\\nclass Solution2 {\\npublic:\\n    long long countGood(vector<int> &nums, int k) {\\n        int n = nums.size();\\n        int left = 0;\\n        int right = 0;\\n\\n        long long res = 0;\\n        unordered_map<int, int> freq;\\n        long long count = 0;\\n\\n        for (; right < n; right++) {\\n            long long old_freq = freq[nums[right]];\\n            long long old_pair = old_freq * (old_freq - 1) / 2;\\n\\n            freq[nums[right]]++;\\n            long long new_freq = freq[nums[right]];\\n            long long new_pair = new_freq * (new_freq - 1) / 2;\\n\\n            count = count - old_pair + new_pair;\\n\\n            while (count >= k) {\\n                res += n - 1 - right + 1;\\n\\n                long long old_left_freq = freq[nums[left]];\\n                long long old_left_pair = old_left_freq * (old_left_freq - 1) / 2;\\n\\n                freq[nums[left]]--;\\n\\n                long long new_left_freq = freq[nums[left]];\\n                long long new_left_pair = new_left_freq * (new_left_freq - 1) / 2;\\n\\n                count = count - old_left_pair + new_left_pair;\\n                left++;\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "_Arthur_Morgan___",
                        "content": "Can someone explain me why expected output of this testcase is 9,\\n\\n`nums =\\n[3,1,4,3,3,3,4]\\nk =\\n2`\\n\\nI am getting output as  4 good subarrays when I done dry run. Below are subarrays I am getting.\\n\\n`[3,1,4,3,3,3]\\n[3,1,4,3,3,3,4]\\n[1,4,3,3,3,4]\\n[4,3,3,3,4]`\\n\\n\\nAny help would be appreciated.\\n"
                    },
                    {
                        "username": "taiwanjizhan",
                        "content": "`[3,1,4,3,3]` has 3 pairs\\n`[3,1,4,3,3,3]` has 6 pairs\\n`[3,1,4,3,3,3,4]` has 7 pairs\\n`[1,4,3,3,3]` has 3 pairs\\n`[1,4,3,3,3,4]` has 4 pairs\\n`[4,3,3,3]` has 3 pairs\\n`[4,3,3,3,4]` has 4 pairs\\n`[3,3,3]` has 3 pairs\\n`[3,3,3,4]` has 3 pairs\\ntotally 9 good subarrays"
                    },
                    {
                        "username": "aravindk3992",
                        "content": "Whats wrong with my code\\n    let nums = [1, 1, 1, 1, 1], k = 10;\\n\\n    let goodSubArrayCount = 0, frequencySet = new Map();\\n    let pairsCount = 0, j = 0, i = 0;\\n\\n    while(j < nums.length) {\\n      if(frequencySet.has(nums[j])) {\\n        frequencySet.set(nums[j], frequencySet.get(nums[j]) + 1);\\n      } else {\\n        frequencySet.set(nums[j], 1);\\n      }\\n\\n      pairsCount += this.calculateFrequency(frequencySet.get(nums[j]));\\n      while(pairsCount >= k) {\\n        goodSubArrayCount += nums.length - j;\\n        pairsCount -= this.calculateFrequency(frequencySet.get(nums[i]));\\n        if(frequencySet.get(nums[i]) > 1) {\\n          frequencySet.set(nums[i], frequencySet.get(nums[i]) - 1);\\n          pairsCount += this.calculateFrequency(frequencySet.get(nums[i]));\\n        } else {\\n          frequencySet.delete(nums[i]);\\n        }\\n        i++;\\n      }\\n      j++;\\n    }\\n    \\n    alert(goodSubArrayCount);"
                    },
                    {
                        "username": "gakharsarang1",
                        "content": "i wrote a solution it gave me wrong answer on the last testcase can anyone please tell me why\n\n\n `       long long countGood(vector<int>& \n         nums, int k) {\n        \n        \n        unordered_map<int,int> mp;\n        long long n=nums.size();\n        long long value=0,res=0;\n        long long M=1e9+7;\n        int j=0;\n\n\n        for(int i=0;i<n;i++){\n                if(mp.find(nums[i])!=mp.end()){\n                    value+=mp[nums[i]];\n                }\n                \n                mp[nums[i]]++;\n\n                if(value>=k){\n\n                    res+=(long long)n-i;\n\n\n                while(j<i-1){\n\n                    mp[nums[j]]--;\n\n                    value-=mp[nums[j]];\n\n                    if(value>=k){\n                        res+=n-i;\n                        j++;\n                        \n                    }\n\n                    else{\n                        j++;\n                        break;\n                        \n                    }\n\n\n                }\n       \n\n            }\n\n        }\n\n\n\n        return res;\n        \n        \n        \n        \n    }\n\n`"
                    },
                    {
                        "username": "taiwanjizhan",
                        "content": "To Python coders: Can this problem be solved by use/import **itertools**?"
                    }
                ]
            },
            {
                "id": 1765145,
                "content": [
                    {
                        "username": "cty549868165",
                        "content": "Hardest one in medium level!!!!! so many details need to be considered."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "SLIDING WINDOW was the only concept coming in mind this whole time. \\nI wonder what will be the best logic to count the number of GOOD subarrays \\uD83E\\uDD14"
                    },
                    {
                        "username": "deep_patel23",
                        "content": "Sliding window + nC2 (combination formula)\\nFind beginner friendly solution here: https://youtu.be/dophWA1gv1g"
                    },
                    {
                        "username": "Magsut",
                        "content": "In my opinion, we can use sliding window + greedy algorithm to solve this problem "
                    },
                    {
                        "username": "_tofu_",
                        "content": "O(N) time, O(1) space, classic sliding window version. Just have to notice that lots of logic need to be considered carefully.\\n\\n```\\nclass Solution2 {\\npublic:\\n    long long countGood(vector<int> &nums, int k) {\\n        int n = nums.size();\\n        int left = 0;\\n        int right = 0;\\n\\n        long long res = 0;\\n        unordered_map<int, int> freq;\\n        long long count = 0;\\n\\n        for (; right < n; right++) {\\n            long long old_freq = freq[nums[right]];\\n            long long old_pair = old_freq * (old_freq - 1) / 2;\\n\\n            freq[nums[right]]++;\\n            long long new_freq = freq[nums[right]];\\n            long long new_pair = new_freq * (new_freq - 1) / 2;\\n\\n            count = count - old_pair + new_pair;\\n\\n            while (count >= k) {\\n                res += n - 1 - right + 1;\\n\\n                long long old_left_freq = freq[nums[left]];\\n                long long old_left_pair = old_left_freq * (old_left_freq - 1) / 2;\\n\\n                freq[nums[left]]--;\\n\\n                long long new_left_freq = freq[nums[left]];\\n                long long new_left_pair = new_left_freq * (new_left_freq - 1) / 2;\\n\\n                count = count - old_left_pair + new_left_pair;\\n                left++;\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "_Arthur_Morgan___",
                        "content": "Can someone explain me why expected output of this testcase is 9,\\n\\n`nums =\\n[3,1,4,3,3,3,4]\\nk =\\n2`\\n\\nI am getting output as  4 good subarrays when I done dry run. Below are subarrays I am getting.\\n\\n`[3,1,4,3,3,3]\\n[3,1,4,3,3,3,4]\\n[1,4,3,3,3,4]\\n[4,3,3,3,4]`\\n\\n\\nAny help would be appreciated.\\n"
                    },
                    {
                        "username": "taiwanjizhan",
                        "content": "`[3,1,4,3,3]` has 3 pairs\\n`[3,1,4,3,3,3]` has 6 pairs\\n`[3,1,4,3,3,3,4]` has 7 pairs\\n`[1,4,3,3,3]` has 3 pairs\\n`[1,4,3,3,3,4]` has 4 pairs\\n`[4,3,3,3]` has 3 pairs\\n`[4,3,3,3,4]` has 4 pairs\\n`[3,3,3]` has 3 pairs\\n`[3,3,3,4]` has 3 pairs\\ntotally 9 good subarrays"
                    },
                    {
                        "username": "aravindk3992",
                        "content": "Whats wrong with my code\\n    let nums = [1, 1, 1, 1, 1], k = 10;\\n\\n    let goodSubArrayCount = 0, frequencySet = new Map();\\n    let pairsCount = 0, j = 0, i = 0;\\n\\n    while(j < nums.length) {\\n      if(frequencySet.has(nums[j])) {\\n        frequencySet.set(nums[j], frequencySet.get(nums[j]) + 1);\\n      } else {\\n        frequencySet.set(nums[j], 1);\\n      }\\n\\n      pairsCount += this.calculateFrequency(frequencySet.get(nums[j]));\\n      while(pairsCount >= k) {\\n        goodSubArrayCount += nums.length - j;\\n        pairsCount -= this.calculateFrequency(frequencySet.get(nums[i]));\\n        if(frequencySet.get(nums[i]) > 1) {\\n          frequencySet.set(nums[i], frequencySet.get(nums[i]) - 1);\\n          pairsCount += this.calculateFrequency(frequencySet.get(nums[i]));\\n        } else {\\n          frequencySet.delete(nums[i]);\\n        }\\n        i++;\\n      }\\n      j++;\\n    }\\n    \\n    alert(goodSubArrayCount);"
                    },
                    {
                        "username": "gakharsarang1",
                        "content": "i wrote a solution it gave me wrong answer on the last testcase can anyone please tell me why\n\n\n `       long long countGood(vector<int>& \n         nums, int k) {\n        \n        \n        unordered_map<int,int> mp;\n        long long n=nums.size();\n        long long value=0,res=0;\n        long long M=1e9+7;\n        int j=0;\n\n\n        for(int i=0;i<n;i++){\n                if(mp.find(nums[i])!=mp.end()){\n                    value+=mp[nums[i]];\n                }\n                \n                mp[nums[i]]++;\n\n                if(value>=k){\n\n                    res+=(long long)n-i;\n\n\n                while(j<i-1){\n\n                    mp[nums[j]]--;\n\n                    value-=mp[nums[j]];\n\n                    if(value>=k){\n                        res+=n-i;\n                        j++;\n                        \n                    }\n\n                    else{\n                        j++;\n                        break;\n                        \n                    }\n\n\n                }\n       \n\n            }\n\n        }\n\n\n\n        return res;\n        \n        \n        \n        \n    }\n\n`"
                    },
                    {
                        "username": "taiwanjizhan",
                        "content": "To Python coders: Can this problem be solved by use/import **itertools**?"
                    }
                ]
            },
            {
                "id": 1759432,
                "content": [
                    {
                        "username": "cty549868165",
                        "content": "Hardest one in medium level!!!!! so many details need to be considered."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "SLIDING WINDOW was the only concept coming in mind this whole time. \\nI wonder what will be the best logic to count the number of GOOD subarrays \\uD83E\\uDD14"
                    },
                    {
                        "username": "deep_patel23",
                        "content": "Sliding window + nC2 (combination formula)\\nFind beginner friendly solution here: https://youtu.be/dophWA1gv1g"
                    },
                    {
                        "username": "Magsut",
                        "content": "In my opinion, we can use sliding window + greedy algorithm to solve this problem "
                    },
                    {
                        "username": "_tofu_",
                        "content": "O(N) time, O(1) space, classic sliding window version. Just have to notice that lots of logic need to be considered carefully.\\n\\n```\\nclass Solution2 {\\npublic:\\n    long long countGood(vector<int> &nums, int k) {\\n        int n = nums.size();\\n        int left = 0;\\n        int right = 0;\\n\\n        long long res = 0;\\n        unordered_map<int, int> freq;\\n        long long count = 0;\\n\\n        for (; right < n; right++) {\\n            long long old_freq = freq[nums[right]];\\n            long long old_pair = old_freq * (old_freq - 1) / 2;\\n\\n            freq[nums[right]]++;\\n            long long new_freq = freq[nums[right]];\\n            long long new_pair = new_freq * (new_freq - 1) / 2;\\n\\n            count = count - old_pair + new_pair;\\n\\n            while (count >= k) {\\n                res += n - 1 - right + 1;\\n\\n                long long old_left_freq = freq[nums[left]];\\n                long long old_left_pair = old_left_freq * (old_left_freq - 1) / 2;\\n\\n                freq[nums[left]]--;\\n\\n                long long new_left_freq = freq[nums[left]];\\n                long long new_left_pair = new_left_freq * (new_left_freq - 1) / 2;\\n\\n                count = count - old_left_pair + new_left_pair;\\n                left++;\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "_Arthur_Morgan___",
                        "content": "Can someone explain me why expected output of this testcase is 9,\\n\\n`nums =\\n[3,1,4,3,3,3,4]\\nk =\\n2`\\n\\nI am getting output as  4 good subarrays when I done dry run. Below are subarrays I am getting.\\n\\n`[3,1,4,3,3,3]\\n[3,1,4,3,3,3,4]\\n[1,4,3,3,3,4]\\n[4,3,3,3,4]`\\n\\n\\nAny help would be appreciated.\\n"
                    },
                    {
                        "username": "taiwanjizhan",
                        "content": "`[3,1,4,3,3]` has 3 pairs\\n`[3,1,4,3,3,3]` has 6 pairs\\n`[3,1,4,3,3,3,4]` has 7 pairs\\n`[1,4,3,3,3]` has 3 pairs\\n`[1,4,3,3,3,4]` has 4 pairs\\n`[4,3,3,3]` has 3 pairs\\n`[4,3,3,3,4]` has 4 pairs\\n`[3,3,3]` has 3 pairs\\n`[3,3,3,4]` has 3 pairs\\ntotally 9 good subarrays"
                    },
                    {
                        "username": "aravindk3992",
                        "content": "Whats wrong with my code\\n    let nums = [1, 1, 1, 1, 1], k = 10;\\n\\n    let goodSubArrayCount = 0, frequencySet = new Map();\\n    let pairsCount = 0, j = 0, i = 0;\\n\\n    while(j < nums.length) {\\n      if(frequencySet.has(nums[j])) {\\n        frequencySet.set(nums[j], frequencySet.get(nums[j]) + 1);\\n      } else {\\n        frequencySet.set(nums[j], 1);\\n      }\\n\\n      pairsCount += this.calculateFrequency(frequencySet.get(nums[j]));\\n      while(pairsCount >= k) {\\n        goodSubArrayCount += nums.length - j;\\n        pairsCount -= this.calculateFrequency(frequencySet.get(nums[i]));\\n        if(frequencySet.get(nums[i]) > 1) {\\n          frequencySet.set(nums[i], frequencySet.get(nums[i]) - 1);\\n          pairsCount += this.calculateFrequency(frequencySet.get(nums[i]));\\n        } else {\\n          frequencySet.delete(nums[i]);\\n        }\\n        i++;\\n      }\\n      j++;\\n    }\\n    \\n    alert(goodSubArrayCount);"
                    },
                    {
                        "username": "gakharsarang1",
                        "content": "i wrote a solution it gave me wrong answer on the last testcase can anyone please tell me why\n\n\n `       long long countGood(vector<int>& \n         nums, int k) {\n        \n        \n        unordered_map<int,int> mp;\n        long long n=nums.size();\n        long long value=0,res=0;\n        long long M=1e9+7;\n        int j=0;\n\n\n        for(int i=0;i<n;i++){\n                if(mp.find(nums[i])!=mp.end()){\n                    value+=mp[nums[i]];\n                }\n                \n                mp[nums[i]]++;\n\n                if(value>=k){\n\n                    res+=(long long)n-i;\n\n\n                while(j<i-1){\n\n                    mp[nums[j]]--;\n\n                    value-=mp[nums[j]];\n\n                    if(value>=k){\n                        res+=n-i;\n                        j++;\n                        \n                    }\n\n                    else{\n                        j++;\n                        break;\n                        \n                    }\n\n\n                }\n       \n\n            }\n\n        }\n\n\n\n        return res;\n        \n        \n        \n        \n    }\n\n`"
                    },
                    {
                        "username": "taiwanjizhan",
                        "content": "To Python coders: Can this problem be solved by use/import **itertools**?"
                    }
                ]
            },
            {
                "id": 1759090,
                "content": [
                    {
                        "username": "cty549868165",
                        "content": "Hardest one in medium level!!!!! so many details need to be considered."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "SLIDING WINDOW was the only concept coming in mind this whole time. \\nI wonder what will be the best logic to count the number of GOOD subarrays \\uD83E\\uDD14"
                    },
                    {
                        "username": "deep_patel23",
                        "content": "Sliding window + nC2 (combination formula)\\nFind beginner friendly solution here: https://youtu.be/dophWA1gv1g"
                    },
                    {
                        "username": "Magsut",
                        "content": "In my opinion, we can use sliding window + greedy algorithm to solve this problem "
                    },
                    {
                        "username": "_tofu_",
                        "content": "O(N) time, O(1) space, classic sliding window version. Just have to notice that lots of logic need to be considered carefully.\\n\\n```\\nclass Solution2 {\\npublic:\\n    long long countGood(vector<int> &nums, int k) {\\n        int n = nums.size();\\n        int left = 0;\\n        int right = 0;\\n\\n        long long res = 0;\\n        unordered_map<int, int> freq;\\n        long long count = 0;\\n\\n        for (; right < n; right++) {\\n            long long old_freq = freq[nums[right]];\\n            long long old_pair = old_freq * (old_freq - 1) / 2;\\n\\n            freq[nums[right]]++;\\n            long long new_freq = freq[nums[right]];\\n            long long new_pair = new_freq * (new_freq - 1) / 2;\\n\\n            count = count - old_pair + new_pair;\\n\\n            while (count >= k) {\\n                res += n - 1 - right + 1;\\n\\n                long long old_left_freq = freq[nums[left]];\\n                long long old_left_pair = old_left_freq * (old_left_freq - 1) / 2;\\n\\n                freq[nums[left]]--;\\n\\n                long long new_left_freq = freq[nums[left]];\\n                long long new_left_pair = new_left_freq * (new_left_freq - 1) / 2;\\n\\n                count = count - old_left_pair + new_left_pair;\\n                left++;\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "_Arthur_Morgan___",
                        "content": "Can someone explain me why expected output of this testcase is 9,\\n\\n`nums =\\n[3,1,4,3,3,3,4]\\nk =\\n2`\\n\\nI am getting output as  4 good subarrays when I done dry run. Below are subarrays I am getting.\\n\\n`[3,1,4,3,3,3]\\n[3,1,4,3,3,3,4]\\n[1,4,3,3,3,4]\\n[4,3,3,3,4]`\\n\\n\\nAny help would be appreciated.\\n"
                    },
                    {
                        "username": "taiwanjizhan",
                        "content": "`[3,1,4,3,3]` has 3 pairs\\n`[3,1,4,3,3,3]` has 6 pairs\\n`[3,1,4,3,3,3,4]` has 7 pairs\\n`[1,4,3,3,3]` has 3 pairs\\n`[1,4,3,3,3,4]` has 4 pairs\\n`[4,3,3,3]` has 3 pairs\\n`[4,3,3,3,4]` has 4 pairs\\n`[3,3,3]` has 3 pairs\\n`[3,3,3,4]` has 3 pairs\\ntotally 9 good subarrays"
                    },
                    {
                        "username": "aravindk3992",
                        "content": "Whats wrong with my code\\n    let nums = [1, 1, 1, 1, 1], k = 10;\\n\\n    let goodSubArrayCount = 0, frequencySet = new Map();\\n    let pairsCount = 0, j = 0, i = 0;\\n\\n    while(j < nums.length) {\\n      if(frequencySet.has(nums[j])) {\\n        frequencySet.set(nums[j], frequencySet.get(nums[j]) + 1);\\n      } else {\\n        frequencySet.set(nums[j], 1);\\n      }\\n\\n      pairsCount += this.calculateFrequency(frequencySet.get(nums[j]));\\n      while(pairsCount >= k) {\\n        goodSubArrayCount += nums.length - j;\\n        pairsCount -= this.calculateFrequency(frequencySet.get(nums[i]));\\n        if(frequencySet.get(nums[i]) > 1) {\\n          frequencySet.set(nums[i], frequencySet.get(nums[i]) - 1);\\n          pairsCount += this.calculateFrequency(frequencySet.get(nums[i]));\\n        } else {\\n          frequencySet.delete(nums[i]);\\n        }\\n        i++;\\n      }\\n      j++;\\n    }\\n    \\n    alert(goodSubArrayCount);"
                    },
                    {
                        "username": "gakharsarang1",
                        "content": "i wrote a solution it gave me wrong answer on the last testcase can anyone please tell me why\n\n\n `       long long countGood(vector<int>& \n         nums, int k) {\n        \n        \n        unordered_map<int,int> mp;\n        long long n=nums.size();\n        long long value=0,res=0;\n        long long M=1e9+7;\n        int j=0;\n\n\n        for(int i=0;i<n;i++){\n                if(mp.find(nums[i])!=mp.end()){\n                    value+=mp[nums[i]];\n                }\n                \n                mp[nums[i]]++;\n\n                if(value>=k){\n\n                    res+=(long long)n-i;\n\n\n                while(j<i-1){\n\n                    mp[nums[j]]--;\n\n                    value-=mp[nums[j]];\n\n                    if(value>=k){\n                        res+=n-i;\n                        j++;\n                        \n                    }\n\n                    else{\n                        j++;\n                        break;\n                        \n                    }\n\n\n                }\n       \n\n            }\n\n        }\n\n\n\n        return res;\n        \n        \n        \n        \n    }\n\n`"
                    },
                    {
                        "username": "taiwanjizhan",
                        "content": "To Python coders: Can this problem be solved by use/import **itertools**?"
                    }
                ]
            },
            {
                "id": 1758940,
                "content": [
                    {
                        "username": "cty549868165",
                        "content": "Hardest one in medium level!!!!! so many details need to be considered."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "SLIDING WINDOW was the only concept coming in mind this whole time. \\nI wonder what will be the best logic to count the number of GOOD subarrays \\uD83E\\uDD14"
                    },
                    {
                        "username": "deep_patel23",
                        "content": "Sliding window + nC2 (combination formula)\\nFind beginner friendly solution here: https://youtu.be/dophWA1gv1g"
                    },
                    {
                        "username": "Magsut",
                        "content": "In my opinion, we can use sliding window + greedy algorithm to solve this problem "
                    },
                    {
                        "username": "_tofu_",
                        "content": "O(N) time, O(1) space, classic sliding window version. Just have to notice that lots of logic need to be considered carefully.\\n\\n```\\nclass Solution2 {\\npublic:\\n    long long countGood(vector<int> &nums, int k) {\\n        int n = nums.size();\\n        int left = 0;\\n        int right = 0;\\n\\n        long long res = 0;\\n        unordered_map<int, int> freq;\\n        long long count = 0;\\n\\n        for (; right < n; right++) {\\n            long long old_freq = freq[nums[right]];\\n            long long old_pair = old_freq * (old_freq - 1) / 2;\\n\\n            freq[nums[right]]++;\\n            long long new_freq = freq[nums[right]];\\n            long long new_pair = new_freq * (new_freq - 1) / 2;\\n\\n            count = count - old_pair + new_pair;\\n\\n            while (count >= k) {\\n                res += n - 1 - right + 1;\\n\\n                long long old_left_freq = freq[nums[left]];\\n                long long old_left_pair = old_left_freq * (old_left_freq - 1) / 2;\\n\\n                freq[nums[left]]--;\\n\\n                long long new_left_freq = freq[nums[left]];\\n                long long new_left_pair = new_left_freq * (new_left_freq - 1) / 2;\\n\\n                count = count - old_left_pair + new_left_pair;\\n                left++;\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "_Arthur_Morgan___",
                        "content": "Can someone explain me why expected output of this testcase is 9,\\n\\n`nums =\\n[3,1,4,3,3,3,4]\\nk =\\n2`\\n\\nI am getting output as  4 good subarrays when I done dry run. Below are subarrays I am getting.\\n\\n`[3,1,4,3,3,3]\\n[3,1,4,3,3,3,4]\\n[1,4,3,3,3,4]\\n[4,3,3,3,4]`\\n\\n\\nAny help would be appreciated.\\n"
                    },
                    {
                        "username": "taiwanjizhan",
                        "content": "`[3,1,4,3,3]` has 3 pairs\\n`[3,1,4,3,3,3]` has 6 pairs\\n`[3,1,4,3,3,3,4]` has 7 pairs\\n`[1,4,3,3,3]` has 3 pairs\\n`[1,4,3,3,3,4]` has 4 pairs\\n`[4,3,3,3]` has 3 pairs\\n`[4,3,3,3,4]` has 4 pairs\\n`[3,3,3]` has 3 pairs\\n`[3,3,3,4]` has 3 pairs\\ntotally 9 good subarrays"
                    },
                    {
                        "username": "aravindk3992",
                        "content": "Whats wrong with my code\\n    let nums = [1, 1, 1, 1, 1], k = 10;\\n\\n    let goodSubArrayCount = 0, frequencySet = new Map();\\n    let pairsCount = 0, j = 0, i = 0;\\n\\n    while(j < nums.length) {\\n      if(frequencySet.has(nums[j])) {\\n        frequencySet.set(nums[j], frequencySet.get(nums[j]) + 1);\\n      } else {\\n        frequencySet.set(nums[j], 1);\\n      }\\n\\n      pairsCount += this.calculateFrequency(frequencySet.get(nums[j]));\\n      while(pairsCount >= k) {\\n        goodSubArrayCount += nums.length - j;\\n        pairsCount -= this.calculateFrequency(frequencySet.get(nums[i]));\\n        if(frequencySet.get(nums[i]) > 1) {\\n          frequencySet.set(nums[i], frequencySet.get(nums[i]) - 1);\\n          pairsCount += this.calculateFrequency(frequencySet.get(nums[i]));\\n        } else {\\n          frequencySet.delete(nums[i]);\\n        }\\n        i++;\\n      }\\n      j++;\\n    }\\n    \\n    alert(goodSubArrayCount);"
                    },
                    {
                        "username": "gakharsarang1",
                        "content": "i wrote a solution it gave me wrong answer on the last testcase can anyone please tell me why\n\n\n `       long long countGood(vector<int>& \n         nums, int k) {\n        \n        \n        unordered_map<int,int> mp;\n        long long n=nums.size();\n        long long value=0,res=0;\n        long long M=1e9+7;\n        int j=0;\n\n\n        for(int i=0;i<n;i++){\n                if(mp.find(nums[i])!=mp.end()){\n                    value+=mp[nums[i]];\n                }\n                \n                mp[nums[i]]++;\n\n                if(value>=k){\n\n                    res+=(long long)n-i;\n\n\n                while(j<i-1){\n\n                    mp[nums[j]]--;\n\n                    value-=mp[nums[j]];\n\n                    if(value>=k){\n                        res+=n-i;\n                        j++;\n                        \n                    }\n\n                    else{\n                        j++;\n                        break;\n                        \n                    }\n\n\n                }\n       \n\n            }\n\n        }\n\n\n\n        return res;\n        \n        \n        \n        \n    }\n\n`"
                    },
                    {
                        "username": "taiwanjizhan",
                        "content": "To Python coders: Can this problem be solved by use/import **itertools**?"
                    }
                ]
            }
        ]
    }
]